<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PureScript by Example</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.ja.html"><strong aria-hidden="true">15.</strong> 序文 (Foreword)</a></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">16.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">17.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">18.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">19.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html"><strong aria-hidden="true">20.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html"><strong aria-hidden="true">21.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">22.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">23.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">24.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.ja.html"><strong aria-hidden="true">25.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.ja.html"><strong aria-hidden="true">26.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.ja.html"><strong aria-hidden="true">27.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.ja.html"><strong aria-hidden="true">28.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.ja.html"><strong aria-hidden="true">29.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="purescript-by-example"><a class="header" href="#purescript-by-example">PureScript by Example</a></h1>
<p>This repository contains a <a href="https://github.com/purescript-contrib/purescript-book/">community fork</a> of <em>PureScript by Example</em> by Phil Freeman, also known as &quot;the PureScript book&quot;. This version differs from the original in that it has been updated so that the code and exercises work with up-to-date versions of the compiler, libraries, and tools. Some chapters have also been rewritten to showcase the latest features of the PureScript ecosystem.</p>
<p>If you enjoyed the book or found it useful, please consider buying a copy of <a href="https://leanpub.com/purescript">the original on Leanpub</a>.</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>This book is being continuously updated as the language evolves, so please report any <a href="https://github.com/purescript-contrib/purescript-book/issues">issues</a> you discover with the material. We appreciate any feedback you have to share, even if it's as simple as pointing out a confusing section that we could make more beginner-friendly.</p>
<p>Unit tests are also being added to each chapter so you can check if your answers to the exercises are correct. See <a href="https://github.com/purescript-contrib/purescript-book/issues/79">#79</a> for the latest status on tests.</p>
<h2 id="about-the-book"><a class="header" href="#about-the-book">About the Book</a></h2>
<p>PureScript is a small, strongly, statically typed programming language with expressive types, written in and inspired by Haskell, and compiling to Javascript.</p>
<p>Functional programming in JavaScript has seen quite a lot of popularity recently, but large-scale application development is hindered by the lack of a disciplined environment in which to write code. PureScript aims to solve that problem by bringing the power of strongly-typed functional programming to the world of JavaScript development.</p>
<p>This book will show you how to get started with the PureScript programming language, from the basics (setting up a development environment) to the advanced.</p>
<p>Each chapter will be motivated by a particular problem, and in the course of solving that problem, new functional programming tools and techniques will be introduced. Here are some examples of problems that will be solved in this book:</p>
<ul>
<li>Transforming data structures with maps and folds</li>
<li>Form field validation using applicative functors</li>
<li>Testing code with QuickCheck</li>
<li>Using the canvas</li>
<li>Domain specific language implementation</li>
<li>Working with the DOM</li>
<li>JavaScript interoperability</li>
<li>Parallel asynchronous execution</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation Repo</a>, which uses the same license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various contributors</a>.</p>
<p>The exercises are licensed under the MIT license.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="functional-javascript"><a class="header" href="#functional-javascript">Functional JavaScript</a></h2>
<p>Functional programming techniques have been making appearances in JavaScript for some time now:</p>
<ul>
<li>
<p>Libraries such as <a href="https://underscorejs.org">UnderscoreJS</a> allow the developer to leverage tried-and-trusted functions such as <code>map</code>, <code>filter</code> and <code>reduce</code> to create larger programs from smaller programs by composition:</p>
<pre><code class="language-javascript">var sumOfPrimes =
    _.chain(_.range(1000))
     .filter(isPrime)
     .reduce(function(x, y) {
         return x + y;
     })
     .value();
</code></pre>
</li>
<li>
<p>Asynchronous programming in NodeJS leans heavily on functions as first-class values to define callbacks.</p>
<pre><code class="language-javascript">import { readFile, writeFile } from 'fs'

readFile(sourceFile, function (error, data) {
  if (!error) {
    writeFile(destFile, data, function (error) {
      if (!error) {
        console.log(&quot;File copied&quot;);
      }
    });
  }
});
</code></pre>
</li>
<li>
<p>Libraries such as <a href="https://reactjs.org">React</a> and <a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a> model views as pure functions of application state.</p>
</li>
</ul>
<p>Functions enable a simple form of abstraction which can yield great productivity gains. However, functional programming in JavaScript has its own disadvantages: JavaScript is verbose, untyped, and lacks powerful forms of abstraction. Unrestricted JavaScript code also makes equational reasoning very difficult.</p>
<p>PureScript is a programming language which aims to address these issues. It features lightweight syntax, which allows us to write very expressive code which is still clear and readable. It uses a rich type system to support powerful abstractions. It also generates fast, understandable code, which is important when interoperating with JavaScript, or other languages which compile to JavaScript. All in all, I hope to convince you that PureScript strikes a very practical balance between the theoretical power of purely functional programming, and the fast-and-loose programming style of JavaScript.</p>
<h2 id="types-and-type-inference"><a class="header" href="#types-and-type-inference">Types and Type Inference</a></h2>
<p>The debate over statically typed languages versus dynamically typed languages is well-documented. PureScript is a <em>statically typed</em> language, meaning that a correct program can be given a <em>type</em> by the compiler which indicates its behavior. Conversely, programs which cannot be given a type are <em>incorrect programs</em>, and will be rejected by the compiler. In PureScript, unlike in dynamically typed languages, types exist only at <em>compile-time</em>, and have no representation at runtime.</p>
<p>It is important to note that in many ways, the types in PureScript are unlike the types that you might have seen in other languages like Java or C#. While they serve the same purpose at a high level, the types in PureScript are inspired by languages like ML and Haskell. PureScript's types are expressive, allowing the developer to assert strong claims about their programs. Most importantly, PureScript's type system supports <em>type inference</em> - it requires far fewer explicit type annotations than other languages, making the type system a <em>tool</em> rather than a hindrance. As a simple example, the following code defines a <em>number</em>, but there is no mention of the <code>Number</code> type anywhere in the code:</p>
<pre><code class="language-haskell">iAmANumber =
  let square x = x * x
  in square 42.0
</code></pre>
<p>A more involved example shows that type-correctness can be confirmed without type annotations, even when there exist types which are <em>unknown to the compiler</em>:</p>
<pre><code class="language-haskell">iterate f 0 x = x
iterate f n x = iterate f (n - 1) (f x)
</code></pre>
<p>Here, the type of <code>x</code> is unknown, but the compiler can still verify that <code>iterate</code> obeys the rules of the type system, no matter what type <code>x</code> might have.</p>
<p>In this book, I will try to convince you (or reaffirm your belief) that static types are not only a means of gaining confidence in the correctness of your programs, but also an aid to development in their own right. Refactoring a large body of code in JavaScript can be difficult when using any but the simplest of abstractions, but an expressive type system together with a type checker can even make refactoring into an enjoyable, interactive experience.</p>
<p>In addition, the safety net provided by a type system enables more advanced forms of abstraction. In fact, PureScript provides a powerful form of abstraction which is fundamentally type-driven: type classes, made popular in the functional programming language Haskell.</p>
<h2 id="polyglot-web-programming"><a class="header" href="#polyglot-web-programming">Polyglot Web Programming</a></h2>
<p>Functional programming has its success stories - applications where it has been particularly successful: data analysis, parsing, compiler implementation, generic programming, parallelism, to name a few.</p>
<p>It would be possible to practice end-to-end application development in a functional language like PureScript. PureScript provides the ability to import existing JavaScript code, by providing types for its values and functions, and then to use those functions in regular PureScript code. We'll see this approach later in the book.</p>
<p>However, one of PureScript's strengths is its interoperability with other languages which target JavaScript. Another approach would be to use PureScript for a subset of your application's development, and to use one or more other languages to write the rest of the JavaScript.</p>
<p>Here are some examples:</p>
<ul>
<li>Core logic written in PureScript, with the user interface written in JavaScript.</li>
<li>Application written in JavaScript or another compile-to-JS language, with tests written in PureScript.</li>
<li>PureScript used to automate user interface tests for an existing application.</li>
</ul>
<p>In this book, we'll focus on solving small problems with PureScript. The solutions could be integrated into a larger application, but we will also look at how to call PureScript code from JavaScript, and vice versa.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>The software requirements for this book are minimal: the first chapter will guide you through setting up a development environment from scratch, and the tools we will use are available in the standard repositories of most modern operating systems.</p>
<p>The PureScript compiler itself can be downloaded as a binary distribution, or built from source on any system running an up-to-date installation of the GHC Haskell compiler, and we will walk through this process in the next chapter.</p>
<p>The code in this version of the book is compatible with versions <code>0.15.*</code> of
the PureScript compiler.</p>
<h2 id="about-you"><a class="header" href="#about-you">About You</a></h2>
<p>I will assume that you are familiar with the basics of JavaScript. Any prior familiarity with common tools from the JavaScript ecosystem, such as NPM and Gulp, will be beneficial if you wish to customize the standard setup to your own needs, but such knowledge is not necessary.</p>
<p>No prior knowledge of functional programming is required, but it certainly won't hurt. New ideas will be accompanied by practical examples, so you should be able to form an intuition for the concepts from functional programming that we will use.</p>
<p>Readers who are familiar with the Haskell programming language will recognize a lot of the ideas and syntax presented in this book, because PureScript is heavily influenced by Haskell. However, those readers should understand that there are a number of important differences between PureScript and Haskell. It is not necessarily always appropriate to try to apply ideas from one language in the other, although many of the concepts presented here will have some interpretation in Haskell.</p>
<h2 id="how-to-read-this-book"><a class="header" href="#how-to-read-this-book">How to Read This Book</a></h2>
<p>The chapters in this book are largely self contained. A beginner with little functional programming experience would be well-advised, however, to work through the chapters in order. The first few chapters lay the groundwork required to understand the material later on in the book. A reader who is comfortable with the ideas of functional programming (especially one with experience in a strongly-typed language like ML or Haskell) will probably be able to gain a general understanding of the code in the later chapters of the book without reading the preceding chapters.</p>
<p>Each chapter will focus on a single practical example, providing the motivation for any new ideas introduced. Code for each chapter are available from the book's <a href="https://github.com/purescript-contrib/purescript-book">GitHub repository</a>. Some chapters will include code snippets taken from the chapter's source code, but for a full understanding, you should read the source code from the repository alongside the material from the book. Longer sections will contain shorter snippets which you can execute in the interactive mode PSCi to test your understanding.</p>
<p>Code samples will appear in a monospaced font, as follows:</p>
<pre><code class="language-haskell">module Example where

import Effect.Console (log)

main = log &quot;Hello, World!&quot;
</code></pre>
<p>Commands which should be typed at the command line will be preceded by a dollar symbol:</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>Usually, these commands will be tailored to Linux/Mac OS users, so Windows users may need to make small changes such as modifying the file separator, or replacing shell built-ins with their Windows equivalents.</p>
<p>Commands which should be typed at the PSCi interactive mode prompt will be preceded by an angle bracket:</p>
<pre><code class="language-text">&gt; 1 + 2
3
</code></pre>
<p>Each chapter will contain exercises, labelled with their difficulty level. It is strongly recommended that you attempt the exercises in each chapter to fully understand the material.</p>
<p>This book aims to provide an introduction to the PureScript language for beginners, but it is not the sort of book that provides a list of template solutions to problems. For beginners, this book should be a fun challenge, and you will get the most benefit if you read the material, attempt the exercises, and most importantly of all, try to write some code of your own.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you get stuck at any point, there are a number of resources available online for learning PureScript:</p>
<ul>
<li>The <a href="https://discord.gg/vKn9up84bp">PureScript Discord server</a> is a great place to chat about issues you may be having. The server is dedicated to chat about PureScript</li>
<li>The <a href="https://discourse.purescript.org/">Purescript Discourse Forum</a> is another good place to search for solutions to common problems. Questions you ask here will be available to help future readers, whereas on Slack, message history is only kept for approximately 2 weeks.</li>
<li><a href="https://github.com/jordanmartinez/purescript-jordans-reference">PureScript: Jordan's Reference</a>  is an alternative learning resource that goes into great depth. If a concept in this book is difficult to understand, consider reading the corresponding section in that reference.</li>
<li><a href="https://pursuit.purescript.org">Pursuit</a> is a searchable database of PureScript types and functions. Read Pursuit's help page to <a href="https://pursuit.purescript.org/help/users">learn what kinds of searches you can do</a>.</li>
<li>The unofficial <a href="https://github.com/JordanMartinez/purescript-cookbook">PureScript Cookbook</a> provides answers via code to &quot;How do I do X?&quot;-type questions.</li>
<li>The <a href="https://github.com/purescript/documentation">PureScript documentation repository</a> collects articles and examples on a wide variety of topics, written by PureScript developers and users.</li>
<li>The <a href="https://www.purescript.org">PureScript website</a> contains links to several learning resources, including code samples, videos and other resources for beginners.</li>
<li><a href="https://try.purescript.org">Try PureScript!</a> is a website which allows users to compile PureScript code in the web browser, and contains several simple examples of code.</li>
</ul>
<p>If you prefer to learn by reading examples, the <code>purescript</code>, <code>purescript-node</code> and <code>purescript-contrib</code> GitHub organizations contain plenty of examples of PureScript code.</p>
<h2 id="about-the-author"><a class="header" href="#about-the-author">About the Author</a></h2>
<p>I am the original developer of the PureScript compiler. I'm based in Los Angeles, California, and started programming at an early age in BASIC on an 8-bit personal computer, the Amstrad CPC. Since then I have worked professionally in a variety of programming languages (including Java, Scala, C#, F#, Haskell and PureScript).</p>
<p>Not long into my professional career, I began to appreciate functional programming and its connections with mathematics, and enjoyed learning functional concepts using the Haskell programming language.</p>
<p>I started working on the PureScript compiler in response to my experience with JavaScript. I found myself using functional programming techniques that I had picked up in languages like Haskell, but wanted a more principled environment in which to apply them. Solutions at the time included various attempts to compile Haskell to JavaScript while preserving its semantics (Fay, Haste, GHCJS), but I was interested to see how successful I could be by approaching the problem from the other side - attempting to keep the semantics of JavaScript, while enjoying the syntax and type system of a language like Haskell.</p>
<p>I maintain <a href="https://blog.functorial.com">a blog</a>, and can be <a href="https://twitter.com/paf31">reached on Twitter</a>.</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>I would like to thank the many contributors who helped PureScript to reach its current state. Without the huge collective effort which has been made on the compiler, tools, libraries, documentation and tests, the project would certainly have failed.</p>
<p>The PureScript logo which appears on the cover of this book was created by Gareth Hughes, and is gratefully reused here under the terms of the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 license</a>.</p>
<p>Finally, I would like to thank everyone who has given me feedback and corrections on the contents of this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="chapter-goals"><a class="header" href="#chapter-goals">Chapter Goals</a></h2>
<p>In this chapter, we'll set up a working PureScript development environment, solve some exercises, and use the tests provided with this book to check our answers. You may also find a <a href="https://www.youtube.com/watch?v=GPjPwb6d-70">video walkthrough of this chapter</a> helpful if that better suits your learning style.</p>
<h2 id="environment-setup"><a class="header" href="#environment-setup">Environment Setup</a></h2>
<p>First, work through this <a href="https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md">Getting Started Guide</a> in the Documentation Repo to setup your environment and learn a few basics about the language. Don't worry if the code in the example solution to the <a href="http://projecteuler.net/problem=1">Project Euler</a> problem is confusing or contains unfamiliar syntax. We'll cover all of this in great detail in the upcoming chapters.</p>
<h2 id="solving-exercises"><a class="header" href="#solving-exercises">Solving Exercises</a></h2>
<p>Now that you've installed the necessary development tools, clone this book's repo.</p>
<pre><code class="language-sh">git clone https://github.com/purescript-contrib/purescript-book.git
</code></pre>
<p>The book repo contains PureScript example code and unit tests for the exercises that accompany each chapter. There's some initial setup required to reset the exercise solutions so they are ready to be solved by you. Use the <code>resetSolutions.sh</code> script to simplify this process. While you're at it, you should also strip out all the anchor comments with the <code>removeAnchors.sh</code> script (these anchors are used for copying code snippets into the book's rendered markdown, and you probably don't need this clutter in your local repo):</p>
<pre><code class="language-sh">cd purescript-book
./scripts/resetSolutions.sh
./scripts/removeAnchors.sh
git add .
git commit --all --message &quot;Exercises ready to be solved&quot;
</code></pre>
<p>Now run the tests for this chapter:</p>
<pre><code class="language-sh">cd exercises/chapter2
spago test
</code></pre>
<p>You should see the following successful test output:</p>
<pre><code class="language-sh">→ Suite: Euler - Sum of Multiples
  ✓ Passed: below 10
  ✓ Passed: below 1000

All 2 tests passed! 🎉
</code></pre>
<p>Note that the <code>answer</code> function (found in <code>src/Euler.purs</code>) has been modified to find the multiples of 3 and 5 below any integer. The test suite (found in <code>test/Main.purs</code>) for this <code>answer</code> function is more comprehensive than the test in the earlier getting-started guide. Don't worry about understanding how this test framework code works while reading these early chapters.</p>
<p>The remainder of the book contains lots of exercises. If you write your solutions in the <code>Test.MySolutions</code> module (<code>test/MySolutions.purs</code>), you can check your work against the provided test suite.</p>
<p>Let's work through this next exercise together in test-driven-development style.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<ol>
<li>(Medium) Write a <code>diagonal</code> function to compute the length of the diagonal (or hypotenuse) of a right-angled triangle when given the lengths of the two other sides.</li>
</ol>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>We'll start by enabling the tests for this exercise. Move the start of the block-comment down a few lines as shown below. Block comments start with <code>{-</code> and end with <code>-}</code>:</p>
<pre><code class="language-hs">    suite &quot;diagonal&quot; do
      test &quot;3 4 5&quot; do
        Assert.equal 5.0 (diagonal 3.0 4.0)
      test &quot;5 12 13&quot; do
        Assert.equal 13.0 (diagonal 5.0 12.0)
    {-  Move this block comment starting point to enable more tests
</code></pre>
<p>If we attempt to run the test now, we'll encounter a compilation error because we have not yet implemented our <code>diagonal</code> function.</p>
<pre><code class="language-sh">$ spago test

Error found:
in module Test.Main
at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)

  Unknown value diagonal
</code></pre>
<p>Let's first take a look at what happens with a faulty version of this function. Add the following code to <code>test/MySolutions.purs</code>:</p>
<pre><code class="language-hs">import Data.Number (sqrt)

diagonal w h = sqrt (w * w + h)
</code></pre>
<p>And check our work by running <code>spago test</code>:</p>
<pre><code class="language-hs">→ Suite: diagonal
  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989
  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219

2 tests failed:
</code></pre>
<p>Uh-oh, that's not quite right. Let's fix this with the correct application of the Pythagorean formula by changing the function to:</p>
<pre><code class="language-hs">diagonal w h = sqrt (w * w + h * h)
</code></pre>
<p>Trying <code>spago test</code> again now shows all tests are passing:</p>
<pre><code class="language-hs">→ Suite: Euler - Sum of Multiples
  ✓ Passed: below 10
  ✓ Passed: below 1000
→ Suite: diagonal
  ✓ Passed: 3 4 5
  ✓ Passed: 5 12 13

All 4 tests passed! 🎉
</code></pre>
<p>Success! Now you're ready to try these next exercises on your own.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>circleArea</code> which computes the area of a circle with a given radius. Use the <code>pi</code> constant, which is defined in the <code>Numbers</code> module. <em>Hint</em>: don't forget to import <code>pi</code> by modifying the <code>import Data.Number</code> statement.</li>
<li>(Medium) Write a function <code>leftoverCents</code> which takes an <code>Int</code> and returns what's leftover after dividing by <code>100</code>. Use the <code>rem</code> function. Search <a href="https://pursuit.purescript.org/">Pursuit</a> for this function to learn about usage and which module to import it from. <em>Note:</em> Your IDE may support auto-importing of this function if you accept the auto-completion suggestion.</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we installed the PureScript compiler and the Spago tool. We also learned how to write solutions to exercises and check these for correctness.</p>
<p>There will be many more exercises in the chapters ahead, and working through those really helps with learning the material. If you're stumped by any of the exercises, please reach out to any of the community resources listed in the <a href="https://book.purescript.org/chapter1.html#getting-help">Getting Help</a> section of this book, or even file an issue in this <a href="https://github.com/purescript-contrib/purescript-book/issues">book's repo</a>. This reader feedback on which exercises could be made more approachable helps us improve the book.</p>
<p>Once you solve all the exercises in a chapter, you may compare your answers against those in the <code>no-peeking/Solutions.purs</code>. No peeking please without putting in an honest effort to solve these yourself though. And even if you are stuck, try asking a community member for help first, as we would prefer to give you a small hint rather than spoil the exercise. If you found a more elegant solution (that still only requires knowledge of covered content), please send us a PR.</p>
<p>The repo is continuously being revised, so be sure to check for updates before starting each new chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-and-records"><a class="header" href="#functions-and-records">Functions and Records</a></h1>
<h2 id="chapter-goals-1"><a class="header" href="#chapter-goals-1">Chapter Goals</a></h2>
<p>This chapter will introduce two building blocks of PureScript programs: functions and records. In addition, we'll see how to structure PureScript programs, and how to use types as an aid to program development.</p>
<p>We will build a simple address book application to manage a list of contacts. This code will introduce some new ideas from the syntax of PureScript.</p>
<p>The front-end of our application will be the interactive mode PSCi, but it would be possible to build on this code to write a front-end in JavaScript. In fact, we will do exactly that in later chapters, adding form validation and save/restore functionality.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The source code for this chapter is contained in the file <code>src/Data/AddressBook.purs</code>. This file starts with a module declaration and its import list:</p>
<pre><code class="language-haskell">module Data.AddressBook where

import Prelude

import Control.Plus (empty)
import Data.List (List(..), filter, head)
import Data.Maybe (Maybe)
</code></pre>
<p>Here, we import several modules:</p>
<ul>
<li>The <code>Control.Plus</code> module, which defines the <code>empty</code> value.</li>
<li>The <code>Data.List</code> module, which is provided by the <code>lists</code> package which can be installed using Spago. It contains a few functions which we will need for working with linked lists.</li>
<li>The <code>Data.Maybe</code> module, which defines data types and functions for working with optional values.</li>
</ul>
<p>Notice that the imports for these modules are listed explicitly in parentheses. This is generally a good practice, as it helps to avoid conflicting imports.</p>
<p>Assuming you have cloned the book's source code repository, the project for this chapter can be built using Spago, with the following commands:</p>
<pre><code class="language-text">$ cd chapter3
$ spago build
</code></pre>
<h2 id="simple-types"><a class="header" href="#simple-types">Simple Types</a></h2>
<p>PureScript defines three built-in types which correspond to JavaScript's primitive types: numbers, strings and booleans. These are defined in the <code>Prim</code> module, which is implicitly imported by every module. They are called <code>Number</code>, <code>String</code>, and <code>Boolean</code>, respectively, and you can see them in PSCi by using the <code>:type</code> command to print the types of some simple values:</p>
<pre><code class="language-text">$ spago repl

&gt; :type 1.0
Number

&gt; :type &quot;test&quot;
String

&gt; :type true
Boolean
</code></pre>
<p>PureScript defines some other built-in types: integers, characters, arrays, records, and functions.</p>
<p>Integers are differentiated from floating point values of type <code>Number</code> by the lack of a decimal point:</p>
<pre><code class="language-text">&gt; :type 1
Int
</code></pre>
<p>Character literals are wrapped in single quotes, unlike string literals which use double quotes:</p>
<pre><code class="language-text">&gt; :type 'a'
Char
</code></pre>
<p>Arrays correspond to JavaScript arrays, but unlike in JavaScript, all elements of a PureScript array must have the same type:</p>
<pre><code class="language-text">&gt; :type [1, 2, 3]
Array Int

&gt; :type [true, false]
Array Boolean

&gt; :type [1, false]
Could not match type Int with type Boolean.
</code></pre>
<p>The error in the last example is an error from the type checker, which unsuccessfully attempted to <em>unify</em> (i.e. make equal) the types of the two elements.</p>
<p>Records correspond to JavaScript's objects, and record literals have the same syntax as JavaScript's object literals:</p>
<pre><code class="language-text">&gt; author = { name: &quot;Phil&quot;, interests: [&quot;Functional Programming&quot;, &quot;JavaScript&quot;] }

&gt; :type author
{ name :: String
, interests :: Array String
}
</code></pre>
<p>This type indicates that the specified object has two <em>fields</em>, a <code>name</code> field which has type <code>String</code>, and an <code>interests</code> field, which has type <code>Array String</code>, i.e. an array of <code>String</code>s.</p>
<p>Fields of records can be accessed using a dot, followed by the label of the field to access:</p>
<pre><code class="language-text">&gt; author.name
&quot;Phil&quot;

&gt; author.interests
[&quot;Functional Programming&quot;,&quot;JavaScript&quot;]
</code></pre>
<p>PureScript's functions correspond to JavaScript's functions. The PureScript standard libraries provide plenty of examples of functions, and we will see more in this chapter:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c

&gt; :type const
forall a b. a -&gt; b -&gt; a
</code></pre>
<p>Functions can be defined at the top-level of a file by specifying arguments before the equals sign:</p>
<pre><code class="language-haskell">add :: Int -&gt; Int -&gt; Int
add x y = x + y
</code></pre>
<p>Alternatively, functions can be defined inline, by using a backslash character followed by a space-delimited list of argument names. To enter a multi-line declaration in PSCi, we can enter &quot;paste mode&quot; by using the <code>:paste</code> command. In this mode, declarations are terminated using the <em>Control-D</em> key sequence:</p>
<pre><code class="language-text">&gt; :paste
… add :: Int -&gt; Int -&gt; Int
… add = \x y -&gt; x + y
… ^D
</code></pre>
<p>Having defined this function in PSCi, we can <em>apply</em> it to its arguments by separating the two arguments from the function name by whitespace:</p>
<pre><code class="language-text">&gt; add 10 20
30
</code></pre>
<h2 id="quantified-types"><a class="header" href="#quantified-types">Quantified Types</a></h2>
<p>In the previous section, we saw the types of some functions defined in the Prelude. For example, the <code>flip</code> function had the following type:</p>
<pre><code class="language-text">&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</code></pre>
<p>The keyword <code>forall</code> here indicates that <code>flip</code> has a <em>universally quantified type</em>. It means that we can substitute any types for <code>a</code>, <code>b</code> and <code>c</code>, and <code>flip</code> will work with those types.</p>
<p>For example, we might choose the type <code>a</code> to be <code>Int</code>, <code>b</code> to be <code>String</code> and <code>c</code> to be <code>String</code>. In that case we could <em>specialize</em> the type of <code>flip</code> to</p>
<pre><code class="language-text">(Int -&gt; String -&gt; String) -&gt; String -&gt; Int -&gt; String
</code></pre>
<p>We don't have to indicate in code that we want to specialize a quantified type - it happens automatically. For example, we can just use <code>flip</code> as if it had this type already:</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) &quot;Ten&quot; 10

&quot;10Ten&quot;
</code></pre>
<p>While we can choose any types for <code>a</code>, <code>b</code> and <code>c</code>, we have to be consistent. The type of the function we passed to <code>flip</code> had to be consistent with the types of the other arguments. That is why we passed the string <code>&quot;Ten&quot;</code> as the second argument, and the number <code>10</code> as the third. It would not work if the arguments were reversed:</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) 10 &quot;Ten&quot;

Could not match type Int with type String
</code></pre>
<h2 id="notes-on-indentation"><a class="header" href="#notes-on-indentation">Notes On Indentation</a></h2>
<p>PureScript code is <em>indentation-sensitive</em>, just like Haskell, but unlike JavaScript. This means that the whitespace in your code is not meaningless, but rather is used to group regions of code, just like curly braces in C-like languages.</p>
<p>If a declaration spans multiple lines, then any lines except the first must be indented past the indentation level of the first line.</p>
<p>Therefore, the following is valid PureScript code:</p>
<pre><code class="language-haskell">add x y z = x +
  y + z
</code></pre>
<p>But this is not valid code:</p>
<pre><code class="language-haskell">add x y z = x +
y + z
</code></pre>
<p>In the second case, the PureScript compiler will try to parse <em>two</em> declarations, one for each line.</p>
<p>Generally, any declarations defined in the same block should be indented at the same level. For example, in PSCi, declarations in a let statement must be indented equally. This is valid:</p>
<pre><code class="language-text">&gt; :paste
… x = 1
… y = 2
… ^D
</code></pre>
<p>but this is not:</p>
<pre><code class="language-text">&gt; :paste
… x = 1
…  y = 2
… ^D
</code></pre>
<p>Certain PureScript keywords (such as <code>where</code>, <code>of</code> and <code>let</code>) introduce a new block of code, in which declarations must be further-indented:</p>
<pre><code class="language-haskell">example x y z = foo + bar
  where
    foo = x * y
    bar = y * z
</code></pre>
<p>Note how the declarations for <code>foo</code> and <code>bar</code> are indented past the declaration of <code>example</code>.</p>
<p>The only exception to this rule is the <code>where</code> keyword in the initial <code>module</code> declaration at the top of a source file.</p>
<h2 id="defining-our-types"><a class="header" href="#defining-our-types">Defining Our Types</a></h2>
<p>A good first step when tackling a new problem in PureScript is to write out type definitions for any values you will be working with. First, let's define a type for records in our address book:</p>
<pre><code class="language-haskell">type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }
</code></pre>
<p>This defines a <em>type synonym</em> called <code>Entry</code> - the type <code>Entry</code> is equivalent to the type on the right of the equals symbol: a record type with three fields - <code>firstName</code>, <code>lastName</code> and <code>address</code>. The two name fields will have type <code>String</code>, and the <code>address</code> field will have type <code>Address</code>, defined as follows:</p>
<pre><code class="language-haskell">type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }
</code></pre>
<p>Note that records can contain other records.</p>
<p>Now let's define a third type synonym, for our address book data structure, which will be represented simply as a linked list of entries:</p>
<pre><code class="language-haskell">type AddressBook = List Entry
</code></pre>
<p>Note that <code>List Entry</code> is not the same as <code>Array Entry</code>, which represents an <em>array</em> of entries.</p>
<h2 id="type-constructors-and-kinds"><a class="header" href="#type-constructors-and-kinds">Type Constructors and Kinds</a></h2>
<p><code>List</code> is an example of a <em>type constructor</em>. Values do not have the type <code>List</code> directly, but rather <code>List a</code> for some type <code>a</code>. That is, <code>List</code> takes a <em>type argument</em> <code>a</code> and <em>constructs</em> a new type <code>List a</code>.</p>
<p>Note that just like function application, type constructors are applied to other types simply by juxtaposition: the type <code>List Entry</code> is in fact the type constructor <code>List</code> <em>applied</em> to the type <code>Entry</code> - it represents a list of entries.</p>
<p>If we try to incorrectly define a value of type <code>List</code> (by using the type annotation operator <code>::</code>), we will see a new type of error:</p>
<pre><code class="language-text">&gt; import Data.List
&gt; Nil :: List
In a type-annotated expression x :: t, the type t must have kind Type
</code></pre>
<p>This is a <em>kind error</em>. Just like values are distinguished by their <em>types</em>, types are distinguished by their <em>kinds</em>, and just like ill-typed values result in <em>type errors</em>, <em>ill-kinded</em> types result in <em>kind errors</em>.</p>
<p>There is a special kind called <code>Type</code> which represents the kind of all types which have values, like <code>Number</code> and <code>String</code>.</p>
<p>There are also kinds for type constructors. For example, the kind <code>Type -&gt; Type</code> represents a function from types to types, just like <code>List</code>. So the error here occurred because values are expected to have types with kind <code>Type</code>, but <code>List</code> has kind <code>Type -&gt; Type</code>.</p>
<p>To find out the kind of a type, use the <code>:kind</code> command in PSCi. For example:</p>
<pre><code class="language-text">&gt; :kind Number
Type

&gt; import Data.List
&gt; :kind List
Type -&gt; Type

&gt; :kind List String
Type
</code></pre>
<p>PureScript's <em>kind system</em> supports other interesting kinds, which we will see later in the book.</p>
<h2 id="displaying-address-book-entries"><a class="header" href="#displaying-address-book-entries">Displaying Address Book Entries</a></h2>
<p>Let's write our first function, which will render an address book entry as a string. We start by giving the function a type. This is optional, but good practice, since it acts as a form of documentation. In fact, the PureScript compiler will give a warning if a top-level declaration does not contain a type annotation. A type declaration separates the name of a function from its type with the <code>::</code> symbol:</p>
<pre><code class="language-haskell">showEntry :: Entry -&gt; String
</code></pre>
<p>This type signature says that <code>showEntry</code> is a function, which takes an <code>Entry</code> as an argument and returns a <code>String</code>. Here is the code for <code>showEntry</code>:</p>
<pre><code class="language-haskell">showEntry entry = entry.lastName &lt;&gt; &quot;, &quot; &lt;&gt;
                  entry.firstName &lt;&gt; &quot;: &quot; &lt;&gt;
                  showAddress entry.address
</code></pre>
<p>This function concatenates the three fields of the <code>Entry</code> record into a single string, using the <code>showAddress</code> function to turn the record inside the <code>address</code> field into a <code>String</code>. <code>showAddress</code> is defined similarly:</p>
<pre><code class="language-haskell">showAddress :: Address -&gt; String
showAddress addr = addr.street &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.city &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.state
</code></pre>
<p>A function definition begins with the name of the function, followed by a list of argument names. The result of the function is specified after the equals sign. Fields are accessed with a dot, followed by the field name. In PureScript, string concatenation uses the diamond operator (<code>&lt;&gt;</code>), instead of the plus operator like in JavaScript.</p>
<h2 id="test-early-test-often"><a class="header" href="#test-early-test-often">Test Early, Test Often</a></h2>
<p>The PSCi interactive mode allows for rapid prototyping with immediate feedback, so let's use it to verify that our first few functions behave as expected.</p>
<p>First, build the code you've written:</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>Next, load PSCi, and use the <code>import</code> command to import your new module:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.AddressBook
</code></pre>
<p>We can create an entry by using a record literal, which looks just like an anonymous object in JavaScript.</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>Now, try applying our function to the example:</p>
<pre><code class="language-text">&gt; showAddress address

&quot;123 Fake St., Faketown, CA&quot;
</code></pre>
<p>Let's also test <code>showEntry</code> by creating an address book entry record containing our example address:</p>
<pre><code class="language-text">&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; showEntry entry

&quot;Smith, John: 123 Fake St., Faketown, CA&quot;
</code></pre>
<h2 id="creating-address-books"><a class="header" href="#creating-address-books">Creating Address Books</a></h2>
<p>Now let's write some utility functions for working with address books. We will need a value which represents an empty address book: an empty list.</p>
<pre><code class="language-haskell">emptyBook :: AddressBook
emptyBook = empty
</code></pre>
<p>We will also need a function for inserting a value into an existing address book. We will call this function <code>insertEntry</code>. Start by giving its type:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>This type signature says that <code>insertEntry</code> takes an <code>Entry</code> as its first argument, and an <code>AddressBook</code> as a second argument, and returns a new <code>AddressBook</code>.</p>
<p>We don't modify the existing <code>AddressBook</code> directly. Instead, we return a new <code>AddressBook</code> which contains the same data. As such, <code>AddressBook</code> is an example of an <em>immutable data structure</em>. This is an important idea in PureScript - mutation is a side-effect of code, and inhibits our ability to reason effectively about its behavior, so we prefer pure functions and immutable data where possible.</p>
<p>To implement <code>insertEntry</code>, we can use the <code>Cons</code> function from <code>Data.List</code>. To see its type, open PSCi and use the <code>:type</code> command:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type Cons

forall a. a -&gt; List a -&gt; List a
</code></pre>
<p>This type signature says that <code>Cons</code> takes a value of some type <code>a</code>, and a list of elements of type <code>a</code>, and returns a new list with entries of the same type. Let's specialize this with <code>a</code> as our <code>Entry</code> type:</p>
<pre><code class="language-haskell">Entry -&gt; List Entry -&gt; List Entry
</code></pre>
<p>But <code>List Entry</code> is the same as <code>AddressBook</code>, so this is equivalent to</p>
<pre><code class="language-haskell">Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>In our case, we already have the appropriate inputs: an <code>Entry</code>, and an <code>AddressBook</code>, so can apply <code>Cons</code> and get a new <code>AddressBook</code>, which is exactly what we wanted!</p>
<p>Here is our implementation of <code>insertEntry</code>:</p>
<pre><code class="language-haskell">insertEntry entry book = Cons entry book
</code></pre>
<p>This brings the two arguments <code>entry</code> and <code>book</code> into scope, on the left hand side of the equals symbol, and then applies the <code>Cons</code> function to create the result.</p>
<h2 id="curried-functions"><a class="header" href="#curried-functions">Curried Functions</a></h2>
<p>Functions in PureScript take exactly one argument. While it looks like the <code>insertEntry</code> function takes two arguments, it is in fact an example of a <em>curried function</em>.</p>
<p>The <code>-&gt;</code> operator in the type of <code>insertEntry</code> associates to the right, which means that the compiler parses the type as</p>
<pre><code class="language-haskell">Entry -&gt; (AddressBook -&gt; AddressBook)
</code></pre>
<p>That is, <code>insertEntry</code> is a function which returns a function! It takes a single argument, an <code>Entry</code>, and returns a new function, which in turn takes a single <code>AddressBook</code> argument and returns a new <code>AddressBook</code>.</p>
<p>This means that we can <em>partially apply</em> <code>insertEntry</code> by specifying only its first argument, for example. In PSCi, we can see the result type:</p>
<pre><code class="language-text">&gt; :type insertEntry entry

AddressBook -&gt; AddressBook
</code></pre>
<p>As expected, the return type was a function. We can apply the resulting function to a second argument:</p>
<pre><code class="language-text">&gt; :type (insertEntry entry) emptyBook
AddressBook
</code></pre>
<p>Note though that the parentheses here are unnecessary - the following is equivalent:</p>
<pre><code class="language-text">&gt; :type insertEntry entry emptyBook
AddressBook
</code></pre>
<p>This is because function application associates to the left, and this explains why we can just specify function arguments one after the other, separated by whitespace.</p>
<p>The <code>-&gt;</code> operator in function types is a <em>type constructor</em> for functions. It takes two type arguments, the function's argument type and the return type. The left and right operands respectively.</p>
<p>Note that in the rest of the book, I will talk about things like &quot;functions of two arguments&quot;. However, it is to be understood that this means a curried function, taking a first argument and returning a function that takes the second.</p>
<p>Now consider the definition of <code>insertEntry</code>:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry book = Cons entry book
</code></pre>
<p>If we explicitly parenthesize the right-hand side, we get <code>(Cons entry) book</code>. That is, <code>insertEntry entry</code> is a function whose argument is just passed along to the <code>(Cons entry)</code> function. But if two functions have the same result for every input, then they are the same function! So we can remove the argument <code>book</code> from both sides:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry = Cons entry
</code></pre>
<p>But now, by the same argument, we can remove <code>entry</code> from both sides:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry = Cons
</code></pre>
<p>This process is called <em>eta conversion</em>, and can be used (along with some other techniques) to rewrite functions in <em>point-free form</em>, which means functions defined without reference to their arguments.</p>
<p>In the case of <code>insertEntry</code>, <em>eta conversion</em> has resulted in a very clear definition of our function - &quot;<code>insertEntry</code> is just cons on lists&quot;. However, it is arguable whether point-free form is better in general.</p>
<h2 id="property-accessors"><a class="header" href="#property-accessors">Property Accessors</a></h2>
<p>One common pattern is to use a function to access individual fields (or &quot;properties&quot;) of a record. An inline function to extract an <code>Address</code> from an <code>Entry</code> could be written as:</p>
<pre><code class="language-haskell">\entry -&gt; entry.address
</code></pre>
<p>PureScript also allows <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#property-accessors"><em>property accessor</em></a> shorthand, where an underscore acts as the anonymous function argument, so the inline function above is equivalent to:</p>
<pre><code class="language-haskell">_.address
</code></pre>
<p>This works with any number of levels or properties, so a function to extract the city associated with an <code>Entry</code> could be written as:</p>
<pre><code class="language-haskell">_.address.city
</code></pre>
<p>For example:</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; _.lastName entry
&quot;Smith&quot;

&gt; _.address.city entry
&quot;Faketown&quot;
</code></pre>
<h2 id="querying-the-address-book"><a class="header" href="#querying-the-address-book">Querying the Address Book</a></h2>
<p>The last function we need to implement for our minimal address book application will look up a person by name and return the correct <code>Entry</code>. This will be a nice application of building programs by composing small functions - a key idea from functional programming.</p>
<p>We can first filter the address book, keeping only those entries with the correct first and last names. Then we can simply return the head (i.e. first) element of the resulting list.</p>
<p>With this high-level specification of our approach, we can calculate the type of our function. First open PSCi, and find the types of the <code>filter</code> and <code>head</code> functions:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type filter

forall a. (a -&gt; Boolean) -&gt; List a -&gt; List a

&gt; :type head

forall a. List a -&gt; Maybe a
</code></pre>
<p>Let's pick apart these two types to understand their meaning.</p>
<p><code>filter</code> is a curried function of two arguments. Its first argument is a function, which takes an element of the list and returns a <code>Boolean</code> value as a result. Its second argument is a list of elements, and the return value is another list.</p>
<p><code>head</code> takes a list as its argument, and returns a type we haven't seen before: <code>Maybe a</code>. <code>Maybe a</code> represents an optional value of type <code>a</code>, and provides a type-safe alternative to using <code>null</code> to indicate a missing value in languages like JavaScript. We will see it again in more detail in later chapters.</p>
<p>The universally quantified types of <code>filter</code> and <code>head</code> can be <em>specialized</em> by the PureScript compiler, to the following types:</p>
<pre><code class="language-haskell">filter :: (Entry -&gt; Boolean) -&gt; AddressBook -&gt; AddressBook

head :: AddressBook -&gt; Maybe Entry
</code></pre>
<p>We know that we will need to pass the first and last names that we want to search for, as arguments to our function.</p>
<p>We also know that we will need a function to pass to <code>filter</code>. Let's call this function <code>filterEntry</code>. <code>filterEntry</code> will have type <code>Entry -&gt; Boolean</code>. The application <code>filter filterEntry</code> will then have type <code>AddressBook -&gt; AddressBook</code>. If we pass the result of this function to the <code>head</code> function, we get our result of type <code>Maybe Entry</code>.</p>
<p>Putting these facts together, a reasonable type signature for our function, which we will call <code>findEntry</code>, is:</p>
<pre><code class="language-haskell">findEntry :: String -&gt; String -&gt; AddressBook -&gt; Maybe Entry
</code></pre>
<p>This type signature says that <code>findEntry</code> takes two strings, the first and last names, and a <code>AddressBook</code>, and returns an optional <code>Entry</code>. The optional result will contain a value only if the name is found in the address book.</p>
<p>And here is the definition of <code>findEntry</code>:</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -&gt; Boolean
    filterEntry entry = entry.firstName == firstName &amp;&amp; entry.lastName == lastName
</code></pre>
<p>Let's go over this code step by step.</p>
<p><code>findEntry</code> brings three names into scope: <code>firstName</code> and <code>lastName</code>, both representing strings, and <code>book</code>, an <code>AddressBook</code>.</p>
<p>The right hand side of the definition combines the <code>filter</code> and <code>head</code> functions: first, the list of entries is filtered, and the <code>head</code> function is applied to the result.</p>
<p>The predicate function <code>filterEntry</code> is defined as an auxiliary declaration inside a <code>where</code> clause. This way, the <code>filterEntry</code> function is available inside the definition of our function, but not outside it. Also, it can depend on the arguments to the enclosing function, which is essential here because <code>filterEntry</code> uses the <code>firstName</code> and <code>lastName</code> arguments to filter the specified <code>Entry</code>.</p>
<p>Note that, just like for top-level declarations, it was not necessary to specify a type signature for <code>filterEntry</code>. However, doing so is recommended as a form of documentation.</p>
<h2 id="infix-function-application"><a class="header" href="#infix-function-application">Infix Function Application</a></h2>
<p>Most of the functions discussed so far used <em>prefix</em> function application, where the function name was put <em>before</em> the arguments. For example, when using the <code>insertEntry</code> function to add an <code>Entry</code> (<code>john</code>) to an empty <code>AddressBook</code>, we might write:</p>
<pre><code class="language-haskell">&gt; book1 = insertEntry john emptyBook
</code></pre>
<p>However, this chapter has also included examples of <em>infix</em> <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#binary-operators">binary operators</a>, such as  the <code>==</code> operator in the definition of <code>filterEntry</code>, where the operator is put <em>between</em> the two arguments. These infix operators are actually defined in the PureScript source as infix aliases for their underlying <em>prefix</em> implementations. For example, <code>==</code> is defined as an infix alias for the prefix <code>eq</code> function with the line:</p>
<pre><code class="language-haskell">infix 4 eq as ==
</code></pre>
<p>and therefore <code>entry.firstName == firstName</code> in <code>filterEntry</code> could be replaced with the <code>eq entry.firstName firstName</code>. We'll cover a few more examples of defining infix operators later in this section.</p>
<p>There are situations where putting a prefix function in an infix position as an operator leads to more readable code. One example is the <code>mod</code> function:</p>
<pre><code class="language-text">&gt; mod 8 3
2
</code></pre>
<p>The above usage works fine, but is awkward to read. A more familiar phrasing is &quot;eight mod three&quot;, which you can achieve by wrapping a prefix function in backticks (`):</p>
<pre><code class="language-text">&gt; 8 `mod` 3
2
</code></pre>
<p>In the same way, wrapping <code>insertEntry</code> in backticks turns it into an infix operator, such that <code>book1</code> and <code>book2</code> below are equivalent:</p>
<pre><code class="language-haskell">book1 = insertEntry john emptyBook
book2 = john `insertEntry` emptyBook
</code></pre>
<p>We can make an <code>AddressBook</code> with multiple entries by using multiple applications of <code>insertEntry</code> as a prefix function (<code>book3</code>) or as an infix operator (<code>book4</code>) as shown below:</p>
<pre><code class="language-haskell">book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))
book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))
</code></pre>
<p>We can also define an infix operator alias (or synonym) for <code>insertEntry.</code> We'll arbitrarily choose <code>++</code> for this operator, give it a <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#precedence">precedence</a> of <code>5</code>, and make it right <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#associativity">associative</a> using <code>infixr</code>:</p>
<pre><code class="language-haskell">infixr 5 insertEntry as ++
</code></pre>
<p>This new operator lets us rewrite the above <code>book4</code> example as:</p>
<pre><code class="language-haskell">book5 = john ++ (peggy ++ (ned ++ emptyBook))
</code></pre>
<p>and the right associativity of our new <code>++</code> operator lets us get rid of the parentheses without changing the meaning:</p>
<pre><code class="language-haskell">book6 = john ++ peggy ++ ned ++ emptyBook
</code></pre>
<p>Another common technique for eliminating parens is to use <code>apply</code>'s infix operator <code>$</code>, along with your standard prefix functions.</p>
<p>For example, the earlier <code>book3</code> example could be rewritten as:</p>
<pre><code class="language-haskell">book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook
</code></pre>
<p>Substituting <code>$</code> for parens is usually easier to type and (arguably) easier to read. A mnemonic to remember the meaning of this symbol is to think of the dollar sign as being drawn from two parens that are also being crossed-out, suggesting the parens are now unnecessary.</p>
<p>Note that <code>$</code> isn't special syntax that's hardcoded into the language. It's simply the infix operator for a regular function called <code>apply</code>, which is defined in <code>Data.Function</code> as follows:</p>
<pre><code class="language-haskell">apply :: forall a b. (a -&gt; b) -&gt; a -&gt; b
apply f x = f x

infixr 0 apply as $
</code></pre>
<p>The <code>apply</code> function takes another function (of type <code>(a -&gt; b)</code>) as its first argument and a value (of type <code>a</code>) as its second argument, then calls that function with that value. If it seems like this function doesn't contribute anything meaningful, you are absolutely correct! Your program is logically identical without it (see <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>). The syntactic utility of this function comes from the special properties assigned to its infix operator. <code>$</code> is a right-associative (<code>infixr</code>), low precedence (<code>0</code>) operator, which lets us remove sets of parentheses for deeply-nested applications.</p>
<p>Another parens-busting opportunity for the <code>$</code> operator is in our earlier <code>findEntry</code> function:</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head $ filter filterEntry book
</code></pre>
<p>We'll see an even more elegant way to rewrite this line with &quot;function composition&quot; in the next section.</p>
<p>If you'd like to use a concise infix operator alias as a prefix function, you can surround it in parentheses:</p>
<pre><code class="language-text">&gt; 8 + 3
11

&gt; (+) 8 3
11
</code></pre>
<p>Alternatively, operators can be partially applied by surrounding the expression with parentheses and using <code>_</code> as an operand in an <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#operator-sections">operator section</a>. You can think of this as a more convenient way to create simple anonymous functions (although in the below example, we're then binding that anonymous function to a name, so it's not so anonymous anymore):</p>
<pre><code class="language-text">&gt; add3 = (3 + _)
&gt; add3 2
5
</code></pre>
<p>To summarize, the following are equivalent definitions of a function that adds <code>5</code> to its argument:</p>
<pre><code class="language-haskell">add5 x = 5 + x
add5 x = add 5 x
add5 x = (+) 5 x
add5 x = 5 `add` x
add5   = add 5
add5   = \x -&gt; 5 + x
add5   = (5 + _)
add5 x = 5 `(+)` x  -- Yo Dawg, I herd you like infix, so we put infix in your infix!
</code></pre>
<h2 id="function-composition"><a class="header" href="#function-composition">Function Composition</a></h2>
<p>Just like we were able to simplify the <code>insertEntry</code> function by using eta conversion, we can simplify the definition of <code>findEntry</code> by reasoning about its arguments.</p>
<p>Note that the <code>book</code> argument is passed to the <code>filter filterEntry</code> function, and the result of this application is passed to <code>head</code>. In other words, <code>book</code> is passed to the <em>composition</em> of the functions <code>filter filterEntry</code> and <code>head</code>.</p>
<p>In PureScript, the function composition operators are <code>&lt;&lt;&lt;</code> and <code>&gt;&gt;&gt;</code>. The first is &quot;backwards composition&quot;, and the second is &quot;forwards composition&quot;.</p>
<p>We can rewrite the right-hand side of <code>findEntry</code> using either operator. Using backwards-composition, the right-hand side would be</p>
<pre><code class="language-haskell">(head &lt;&lt;&lt; filter filterEntry) book
</code></pre>
<p>In this form, we can apply the eta conversion trick from earlier, to arrive at the final form of <code>findEntry</code>:</p>
<pre><code class="language-haskell">findEntry firstName lastName = head &lt;&lt;&lt; filter filterEntry
  where
    ...
</code></pre>
<p>An equally valid right-hand side would be:</p>
<pre><code class="language-haskell">filter filterEntry &gt;&gt;&gt; head
</code></pre>
<p>Either way, this gives a clear definition of the <code>findEntry</code> function: &quot;<code>findEntry</code> is the composition of a filtering function and the <code>head</code> function&quot;.</p>
<p>I will let you make your own decision which definition is easier to understand, but it is often useful to think of functions as building blocks in this way - each function executing a single task, and solutions assembled using function composition.</p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>(Easy) Test your understanding of the <code>findEntry</code> function by writing down the types of each of its major subexpressions. For example, the type of the <code>head</code> function as used is specialized to <code>AddressBook -&gt; Maybe Entry</code>. <em>Note</em>: There is no test for this exercise.</li>
<li>(Medium) Write a function <code>findEntryByStreet :: String -&gt; AddressBook -&gt; Maybe Entry</code> which looks up an <code>Entry</code> given a street address. <em>Hint</em> reusing the existing code in <code>findEntry</code>. Test your function in PSCi and by running <code>spago test</code>.</li>
<li>(Medium) Rewrite <code>findEntryByStreet</code> to replace <code>filterEntry</code> with the composition (using <code>&lt;&lt;&lt;</code> or <code>&gt;&gt;&gt;</code>) of: a property accessor (using the <code>_.</code> notation); and a function that tests whether its given string argument is equal to the given street address.</li>
<li>(Medium) Write a function <code>isInBook</code> which tests whether a name appears in a <code>AddressBook</code>, returning a Boolean value. <em>Hint</em>: Use PSCi to find the type of the <code>Data.List.null</code> function, which tests whether a list is empty or not.</li>
<li>(Difficult) Write a function <code>removeDuplicates</code> which removes &quot;duplicate&quot; address book entries. We'll consider entries duplicated if they share the same first and last names, while ignoring <code>address</code> fields. <em>Hint</em>: Use PSCi to find the type of the <code>Data.List.nubByEq</code> function, which removes duplicate elements from a list based on an equality predicate. Note that the first element in each set of duplicates (closest to list head) is the one that is kept.</li>
</ol>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>In this chapter, we covered several new functional programming concepts:</p>
<ul>
<li>How to use the interactive mode PSCi to experiment with functions and test ideas.</li>
<li>The role of types as both a correctness tool, and an implementation tool.</li>
<li>The use of curried functions to represent functions of multiple arguments.</li>
<li>Creating programs from smaller components by composition.</li>
<li>Structuring code neatly using <code>where</code> expressions.</li>
<li>How to avoid null values by using the <code>Maybe</code> type.</li>
<li>Using techniques like eta conversion and function composition to refactor code into a clear specification.</li>
</ul>
<p>In the following chapters, we'll build on these ideas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion-maps-and-folds"><a class="header" href="#recursion-maps-and-folds">Recursion, Maps And Folds</a></h1>
<h2 id="chapter-goals-2"><a class="header" href="#chapter-goals-2">Chapter Goals</a></h2>
<p>In this chapter, we will look at how recursive functions can be used to structure algorithms. Recursion is a basic technique used in functional programming, which we will use throughout this book.</p>
<p>We will also cover some standard functions from PureScript's standard libraries. We will see the <code>map</code> and <code>fold</code> functions, as well as some useful special cases, like <code>filter</code> and <code>concatMap</code>.</p>
<p>The motivating example for this chapter is a library of functions for working with a virtual filesystem. We will apply the techniques learned in this chapter to write functions which compute properties of the files represented by a model of a filesystem.</p>
<h2 id="project-setup-1"><a class="header" href="#project-setup-1">Project Setup</a></h2>
<p>The source code for this chapter is contained in <code>src/Data/Path.purs</code> and <code>test/Examples.purs</code>. The <code>Data.Path</code> module contains a model of a virtual filesystem. You do not need to modify the contents of this module. Implement your solutions to the exercises in the <code>Test.MySolutions</code> module. Enable accompanying tests in the <code>Test.Main</code> module as you complete each exercise and check your work by running <code>spago test</code>.</p>
<p>The project has the following dependencies:</p>
<ul>
<li><code>maybe</code>, which defines the <code>Maybe</code> type constructor</li>
<li><code>arrays</code>, which defines functions for working with arrays</li>
<li><code>strings</code>, which defines functions for working with JavaScript strings</li>
<li><code>foldable-traversable</code>, which defines functions for folding arrays and other data structures</li>
<li><code>console</code>, which defines functions for printing to the console</li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Recursion is an important technique in programming in general, but particularly common in pure functional programming, because, as we will see in this chapter, recursion helps to reduce the mutable state in our programs.</p>
<p>Recursion is closely linked to the <em>divide and conquer</em> strategy: to solve a problem on certain inputs, we can break down the inputs into smaller parts, solve the problem on those parts, and then assemble a solution from the partial solutions.</p>
<p>Let's see some simple examples of recursion in PureScript.</p>
<p>Here is the usual <em>factorial function</em> example:</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n =
  if n == 0 then
    1
  else
    n * factorial (n - 1)
</code></pre>
<p>Here, we can see how the factorial function is computed by reducing the problem to a subproblem - that of computing the factorial of a smaller integer. When we reach zero, the answer is immediate.</p>
<p>Here is another common example, which computes the <em>Fibonacci function</em>:</p>
<pre><code class="language-haskell">fib :: Int -&gt; Int
fib n =
  if n == 0 then
    0
  else if n == 1 then
    1
  else
    fib (n - 1) + fib (n - 2)
</code></pre>
<p>Again, this problem is solved by considering the solutions to subproblems. In this case, there are two subproblems, corresponding to the expressions <code>fib (n - 1)</code> and <code>fib (n - 2)</code>. When these two subproblems are solved, we assemble the result by adding the partial results.</p>
<p>Note that, while the above examples of <code>factorial</code> and <code>fib</code> work as intended, a more idiomatic implementation would use pattern matching instead of <code>if</code>/<code>then</code>/<code>else</code>. Pattern matching techniques are discussed in a later chapter.</p>
<h2 id="recursion-on-arrays"><a class="header" href="#recursion-on-arrays">Recursion on Arrays</a></h2>
<p>We are not limited to defining recursive functions over the <code>Int</code> type! We will see recursive functions defined over a wide array of data types when we cover <em>pattern matching</em> later in the book, but for now, we will restrict ourselves to numbers and arrays.</p>
<p>Just as we branch based on whether the input is non-zero, in the array case, we will branch based on whether the input is non-empty. Consider this function, which computes the length of an array using recursion:</p>
<pre><code class="language-haskell">import Prelude

import Data.Array (null, tail)
import Data.Maybe (fromMaybe)

length :: forall a. Array a -&gt; Int
length arr =
  if null arr then
    0
  else
    1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>In this function, we use an <code>if .. then .. else</code> expression to branch based on the emptiness of the array. The <code>null</code> function returns <code>true</code> on an empty array. Empty arrays have length zero, and a non-empty array has a length that is one more than the length of its tail.</p>
<p>The <code>tail</code> function returns a <code>Maybe</code> wrapping the given array without its first element. If the array is empty (i.e. it doesn't have a tail) <code>Nothing</code> is returned. The <code>fromMaybe</code> function takes a default value and a <code>Maybe</code> value. If the latter is <code>Nothing</code> it returns the default, in the other case it returns the value wrapped by <code>Just</code>.</p>
<p>This example is obviously a very impractical way to find the length of an array in JavaScript, but should provide enough help to allow you to complete the following exercises:</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>(Easy) Write a recursive function <code>isEven</code> which returns <code>true</code> if and only if its input is an even integer.</li>
<li>(Medium) Write a recursive function <code>countEven</code> which counts the number of even integers in an array. <em>Hint</em>: the function <code>head</code> (also available in <code>Data.Array</code>) can be used to find the first element in a non-empty array.</li>
</ol>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<p>The <code>map</code> function is an example of a recursive function on arrays. It is used to transform the elements of an array by applying a function to each element in turn. Therefore, it changes the <em>contents</em> of the array, but preserves its <em>shape</em> (i.e. its length).</p>
<p>When we cover <em>type classes</em> later in the book we will see that the <code>map</code> function is an example of a more general pattern of shape-preserving functions which transform a class of type constructors called <em>functors</em>.</p>
<p>Let's try out the <code>map</code> function in PSCi:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; map (\n -&gt; n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>Notice how <code>map</code> is used - we provide a function which should be &quot;mapped over&quot; the array in the first argument, and the array itself in its second.</p>
<h2 id="infix-operators"><a class="header" href="#infix-operators">Infix Operators</a></h2>
<p>The <code>map</code> function can also be written between the mapping function and the array, by wrapping the function name in backticks:</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) `map` [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>This syntax is called <em>infix function application</em>, and any function can be made infix in this way. It is usually most appropriate for functions with two arguments.</p>
<p>There is an operator which is equivalent to the <code>map</code> function when used with arrays, called <code>&lt;$&gt;</code>. This operator can be used infix like any other binary operator:</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) &lt;$&gt; [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>Let's look at the type of <code>map</code>:</p>
<pre><code class="language-text">&gt; :type map
forall a b f. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The type of <code>map</code> is actually more general than we need in this chapter. For our purposes, we can treat <code>map</code> as if it had the following less general type:</p>
<pre><code class="language-text">forall a b. (a -&gt; b) -&gt; Array a -&gt; Array b
</code></pre>
<p>This type says that we can choose any two types, <code>a</code> and <code>b</code>, with which to apply the <code>map</code> function. <code>a</code> is the type of elements in the source array, and <code>b</code> is the type of elements in the target array. In particular, there is no reason why <code>map</code> has to preserve the type of the array elements. We can use <code>map</code> or <code>&lt;$&gt;</code> to transform integers to strings, for example:</p>
<pre><code class="language-text">&gt; show &lt;$&gt; [1, 2, 3, 4, 5]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>Even though the infix operator <code>&lt;$&gt;</code> looks like special syntax, it is in fact just an alias for a regular PureScript function. The function is simply <em>applied</em> using infix syntax. In fact, the function can be used like a regular function by enclosing its name in parentheses. This means that we can used the parenthesized name <code>(&lt;$&gt;)</code> in place of <code>map</code> on arrays:</p>
<pre><code class="language-text">&gt; (&lt;$&gt;) show [1, 2, 3, 4, 5]
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>Infix function names are defined as <em>aliases</em> for existing function names. For example, the <code>Data.Array</code> module defines an infix operator <code>(..)</code> as a synonym for the <code>range</code> function, as follows:</p>
<pre><code class="language-haskell">infix 8 range as ..
</code></pre>
<p>We can use this operator as follows:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; 1 .. 5
[1, 2, 3, 4, 5]

&gt; show &lt;$&gt; (1 .. 5)
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p><em>Note</em>: Infix operators can be a great tool for defining domain-specific languages with a natural syntax. However, used excessively, they can render code unreadable to beginners, so it is wise to exercise caution when defining any new operators.</p>
<p>In the example above, we parenthesized the expression <code>1 .. 5</code>, but this was actually not necessary, because the <code>Data.Array</code> module assigns a higher precedence level to the <code>..</code> operator than that assigned to the <code>&lt;$&gt;</code> operator. In the example above, the precedence of the <code>..</code> operator was defined as <code>8</code>, the number after the <code>infix</code> keyword. This is higher than the precedence level of <code>&lt;$&gt;</code>, meaning that we do not need to add parentheses:</p>
<pre><code class="language-text">&gt; show &lt;$&gt; 1 .. 5
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>If we wanted to assign an <em>associativity</em> (left or right) to an infix operator, we could do so with the <code>infixl</code> and <code>infixr</code> keywords instead.  Using <code>infix</code> assigns no associativity, meaning that you must parenthesize any expression using the same operator multiple times or using multiple operators of the same precedence.</p>
<h2 id="filtering-arrays"><a class="header" href="#filtering-arrays">Filtering Arrays</a></h2>
<p>The <code>Data.Array</code> module provides another function <code>filter</code>, which is commonly used together with <code>map</code>. It provides the ability to create a new array from an existing array, keeping only those elements which match a predicate function.</p>
<p>For example, suppose we wanted to compute an array of all numbers between 1 and 10 which were even. We could do so as follows:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; filter (\n -&gt; n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
</code></pre>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>squared</code> which calculates the squares of an array of numbers. <em>Hint</em>: Use the <code>map</code> or <code>&lt;$&gt;</code> function.</li>
<li>(Easy) Write a function <code>keepNonNegative</code> which removes the negative numbers from an array of numbers. <em>Hint</em>: Use the <code>filter</code> function.</li>
<li>(Medium)
<ul>
<li>Define an infix synonym <code>&lt;$?&gt;</code> for <code>filter</code>. <em>Note</em>: Infix synonyms may not be defined in the REPL, but you can define it in a file.</li>
<li>Write a <code>keepNonNegativeRewrite</code> function, which is the same as <code>keepNonNegative</code>, but replaces <code>filter</code> with your new infix operator <code>&lt;$?&gt;</code>.</li>
<li>Experiment with the precedence level and associativity of your operator in PSCi. <em>Note</em>: There are no unit tests for this step.</li>
</ul>
</li>
</ol>
<h2 id="flattening-arrays"><a class="header" href="#flattening-arrays">Flattening Arrays</a></h2>
<p>Another standard function on arrays is the <code>concat</code> function, defined in <code>Data.Array</code>. <code>concat</code> flattens an array of arrays into a single array:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concat
forall a. Array (Array a) -&gt; Array a

&gt; concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>There is a related function called <code>concatMap</code> which is like a combination of the <code>concat</code> and <code>map</code> functions. Where <code>map</code> takes a function from values to values (possibly of a different type), <code>concatMap</code> takes a function from values to arrays of values.</p>
<p>Let's see it in action:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concatMap
forall a b. (a -&gt; Array b) -&gt; Array a -&gt; Array b

&gt; concatMap (\n -&gt; [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
</code></pre>
<p>Here, we call <code>concatMap</code> with the function <code>\n -&gt; [n, n * n]</code> which sends an integer to the array of two elements consisting of that integer and its square. The result is an array of ten integers: the integers from 1 to 5 along with their squares.</p>
<p>Note how <code>concatMap</code> concatenates its results. It calls the provided function once for each element of the original array, generating an array for each. Finally, it collapses all of those arrays into a single array, which is its result.</p>
<p><code>map</code>, <code>filter</code> and <code>concatMap</code> form the basis for a whole range of functions over arrays called &quot;array comprehensions&quot;.</p>
<h2 id="array-comprehensions"><a class="header" href="#array-comprehensions">Array Comprehensions</a></h2>
<p>Suppose we wanted to find the factors of a number <code>n</code>. One simple way to do this would be by brute force: we could generate all pairs of numbers between 1 and <code>n</code>, and try multiplying them together. If the product was <code>n</code>, we would have found a pair of factors of <code>n</code>.</p>
<p>We can perform this computation using an array comprehension. We will do so in steps, using PSCi as our interactive development environment.</p>
<p>The first step is to generate an array of pairs of numbers below <code>n</code>, which we can do using <code>concatMap</code>.</p>
<p>Let's start by mapping each number to the array <code>1 .. n</code>:</p>
<pre><code class="language-text">&gt; pairs n = concatMap (\i -&gt; 1 .. n) (1 .. n)
</code></pre>
<p>We can test our function</p>
<pre><code class="language-text">&gt; pairs 3
[1,2,3,1,2,3,1,2,3]
</code></pre>
<p>This is not quite what we want. Instead of just returning the second element of each pair, we need to map a function over the inner copy of <code>1 .. n</code> which will allow us to keep the entire pair:</p>
<pre><code class="language-text">&gt; :paste
… pairs' n =
…   concatMap (\i -&gt;
…     map (\j -&gt; [i, j]) (1 .. n)
…   ) (1 .. n)
… ^D

&gt; pairs' 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
</code></pre>
<p>This is looking better. However, we are generating too many pairs: we keep both [1, 2] and [2, 1] for example. We can exclude the second case by making sure that <code>j</code> only ranges from <code>i</code> to <code>n</code>:</p>
<pre><code class="language-text">&gt; :paste
… pairs'' n =
…   concatMap (\i -&gt;
…     map (\j -&gt; [i, j]) (i .. n)
…   ) (1 .. n)
… ^D
&gt; pairs'' 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
</code></pre>
<p>Great! Now that we have all of the pairs of potential factors, we can use <code>filter</code> to choose the pairs which multiply to give <code>n</code>:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; factors n = filter (\pair -&gt; product pair == n) (pairs'' n)

&gt; factors 10
[[1,10],[2,5]]
</code></pre>
<p>This code uses the <code>product</code> function from the <code>Data.Foldable</code> module in the <code>foldable-traversable</code> library.</p>
<p>Excellent! We've managed to find the correct set of factor pairs without duplicates.</p>
<h2 id="do-notation"><a class="header" href="#do-notation">Do Notation</a></h2>
<p>However, we can improve the readability of our code considerably. <code>map</code> and <code>concatMap</code> are so fundamental, that they (or rather, their generalizations <code>map</code> and <code>bind</code>) form the basis of a special syntax called <em>do notation</em>.</p>
<p><em>Note</em>: Just like <code>map</code> and <code>concatMap</code> allowed us to write <em>array comprehensions</em>, the more general operators <code>map</code> and <code>bind</code> allow us to write so-called <em>monad comprehensions</em>. We'll see plenty more examples of <em>monads</em> later in the book, but in this chapter, we will only consider arrays.</p>
<p>We can rewrite our <code>factors</code> function using do notation as follows:</p>
<pre><code class="language-haskell">factors :: Int -&gt; Array (Array Int)
factors n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  pure [ i, j ]
</code></pre>
<p>The keyword <code>do</code> introduces a block of code which uses do notation. The block consists of expressions of a few types:</p>
<ul>
<li>Expressions which bind elements of an array to a name. These are indicated with the backwards-facing arrow <code>&lt;-</code>, with a name on the left, and an expression on the right whose type is an array.</li>
<li>Expressions which do not bind elements of the array to names. The <code>do</code> <em>result</em> is an example of this kind of expression and is illustrated in the last line, <code>pure [i, j]</code>.</li>
<li>Expressions which give names to expressions, using the <code>let</code> keyword.</li>
</ul>
<p>This new notation hopefully makes the structure of the algorithm clearer. If you mentally replace the arrow <code>&lt;-</code> with the word &quot;choose&quot;, you might read it as follows: &quot;choose an element <code>i</code> between 1 and n, then choose an element <code>j</code> between <code>i</code> and <code>n</code>, and return <code>[i, j]</code>&quot;.</p>
<p>In the last line, we use the <code>pure</code> function. This function can be evaluated in PSCi, but we have to provide a type:</p>
<pre><code class="language-text">&gt; pure [1, 2] :: Array (Array Int)
[[1, 2]]
</code></pre>
<p>In the case of arrays, <code>pure</code> simply constructs a singleton array. In fact, we could modify our <code>factors</code> function to use this form, instead of using <code>pure</code>:</p>
<pre><code class="language-haskell">factorsV2 :: Int -&gt; Array (Array Int)
factorsV2 n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  [ [ i, j ] ]
</code></pre>
<p>and the result would be the same.</p>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<p>One further change we can make to the <code>factors</code> function is to move the filter inside the array comprehension. This is possible using the <code>guard</code> function from the <code>Control.Alternative</code> module (from the <code>control</code> package):</p>
<pre><code class="language-haskell">import Control.Alternative (guard)

factorsV3 :: Int -&gt; Array (Array Int)
factorsV3 n = do
  i &lt;- 1 .. n
  j &lt;- i .. n
  guard $ i * j == n
  pure [ i, j ]
</code></pre>
<p>Just like <code>pure</code>, we can apply the <code>guard</code> function in PSCi to understand how it works. The type of the <code>guard</code> function is more general than we need here:</p>
<pre><code class="language-text">&gt; import Control.Alternative

&gt; :type guard
forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p>In our case, we can assume that PSCi reported the following type:</p>
<pre><code class="language-haskell">Boolean -&gt; Array Unit
</code></pre>
<p>For our purposes, the following calculations tell us everything we need to know about the <code>guard</code> function on arrays:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; length $ guard true
1

&gt; length $ guard false
0
</code></pre>
<p>That is, if <code>guard</code> is passed an expression which evaluates to <code>true</code>, then it returns an array with a single element. If the expression evaluates to <code>false</code>, then its result is empty.</p>
<p>This means that if the guard fails, then the current branch of the array comprehension will terminate early with no results. This means that a call to <code>guard</code> is equivalent to using <code>filter</code> on the intermediate array. Depending on the application, you might prefer to use <code>guard</code> instead of a <code>filter</code>. Try the two definitions of <code>factors</code> to verify that they give the same results.</p>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>isPrime</code> which tests if its integer argument is prime or not. <em>Hint</em>: Use the <code>factors</code> function.</li>
<li>(Medium) Write a function <code>cartesianProduct</code> which uses do notation to find the <em>cartesian product</em> of two arrays, i.e. the set of all pairs of elements <code>a</code>, <code>b</code>, where <code>a</code> is an element of the first array, and <code>b</code> is an element of the second.</li>
<li>(Medium) Write a function <code>triples :: Int -&gt; Array (Array Int)</code> which takes a number <code>n</code> and returns all Pythagorean triples whose components (the <code>a</code>, <code>b</code> and <code>c</code> values) are each less than or equal to <code>n</code>. A <em>Pythagorean triple</em> is an array of numbers <code>[a, b, c]</code> such that <code>a² + b² = c²</code>. <em>Hint</em>: Use the <code>guard</code> function in an array comprehension.</li>
<li>(Difficult) Write a function <code>primeFactors</code> which produces the <a href="https://www.mathsisfun.com/prime-factorization.html">prime factorization</a> of <code>n</code>, i.e. the array of prime integers whose product is <code>n</code>. <em>Hint</em>: for an integer greater than 1, break the problem down into two subproblems: finding the first factor, and finding the remaining factors.</li>
</ol>
<h2 id="folds"><a class="header" href="#folds">Folds</a></h2>
<p>Left and right folds over arrays provide another class of interesting functions which can be implemented using recursion.</p>
<p>Start by importing the <code>Data.Foldable</code> module, and inspecting the types of the <code>foldl</code> and <code>foldr</code> functions using PSCi:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :type foldl
forall a b f. Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b

&gt; :type foldr
forall a b f. Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
</code></pre>
<p>These types are actually more general than we are interested in right now. For the purposes of this chapter, we can assume that PSCi had given the following (more specific) answer:</p>
<pre><code class="language-text">&gt; :type foldl
forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Array a -&gt; b

&gt; :type foldr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Array a -&gt; b
</code></pre>
<p>In both of these cases, the type <code>a</code> corresponds to the type of elements of our array. The type <code>b</code> can be thought of as the type of an &quot;accumulator&quot;, which will accumulate a result as we traverse the array.</p>
<p>The difference between the <code>foldl</code> and <code>foldr</code> functions is the direction of the traversal. <code>foldl</code> folds the array &quot;from the left&quot;, whereas <code>foldr</code> folds the array &quot;from the right&quot;.</p>
<p>Let's see these functions in action. Let's use <code>foldl</code> to sum an array of integers. The type <code>a</code> will be <code>Int</code>, and we can also choose the result type <code>b</code> to be <code>Int</code>. We need to provide three arguments: a function <code>Int -&gt; Int -&gt; Int</code>, which will add the next element to the accumulator, an initial value for the accumulator of type <code>Int</code>, and an array of <code>Int</code>s to add. For the first argument, we can just use the addition operator, and the initial value of the accumulator will be zero:</p>
<pre><code class="language-text">&gt; foldl (+) 0 (1 .. 5)
15
</code></pre>
<p>In this case, it didn't matter whether we used <code>foldl</code> or <code>foldr</code>, because the result is the same, no matter what order the additions happen in:</p>
<pre><code class="language-text">&gt; foldr (+) 0 (1 .. 5)
15
</code></pre>
<p>Let's write an example where the choice of folding function does matter, in order to illustrate the difference. Instead of the addition function, let's use string concatenation to build a string:</p>
<pre><code class="language-text">&gt; foldl (\acc n -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;12345&quot;

&gt; foldr (\n acc -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;54321&quot;
</code></pre>
<p>This illustrates the difference between the two functions. The left fold expression is equivalent to the following application:</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 1) &lt;&gt; show 2) &lt;&gt; show 3) &lt;&gt; show 4) &lt;&gt; show 5)
</code></pre>
<p>whereas the right fold is equivalent to this:</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 5) &lt;&gt; show 4) &lt;&gt; show 3) &lt;&gt; show 2) &lt;&gt; show 1)
</code></pre>
<h2 id="tail-recursion"><a class="header" href="#tail-recursion">Tail Recursion</a></h2>
<p>Recursion is a powerful technique for specifying algorithms, but comes with a problem: evaluating recursive functions in JavaScript can lead to stack overflow errors if our inputs are too large.</p>
<p>It is easy to verify this problem, with the following code in PSCi:</p>
<pre><code class="language-text">&gt; :paste
… f n =
…   if n == 0
…     then 0
…     else 1 + f (n - 1)
… ^D

&gt; f 10
10

&gt; f 100000
RangeError: Maximum call stack size exceeded
</code></pre>
<p>This is a problem. If we are going to adopt recursion as a standard technique from functional programming, then we need a way to deal with possibly unbounded recursion.</p>
<p>PureScript provides a partial solution to this problem in the form of <em>tail recursion optimization</em>.</p>
<p><em>Note</em>: more complete solutions to the problem can be implemented in libraries using so-called <em>trampolining</em>, but that is beyond the scope of this chapter. The interested reader can consult the documentation for the <a href="https://pursuit.purescript.org/packages/purescript-free"><code>free</code></a> and <a href="https://pursuit.purescript.org/packages/purescript-tailrec"><code>tailrec</code></a> packages.</p>
<p>The key observation which enables tail recursion optimization is the following: a recursive call in <em>tail position</em> to a function can be replaced with a <em>jump</em>, which does not allocate a stack frame. A call is in <em>tail position</em> when it is the last call made before a function returns. This is the reason why we observed a stack overflow in the example - the recursive call to <code>f</code> was <em>not</em> in tail position.</p>
<p>In practice, the PureScript compiler does not replace the recursive call with a jump, but rather replaces the entire recursive function with a <em>while loop</em>.</p>
<p>Here is an example of a recursive function with all recursive calls in tail position:</p>
<pre><code class="language-haskell">factorialTailRec :: Int -&gt; Int -&gt; Int
factorialTailRec n acc =
  if n == 0
    then acc
    else factorialTailRec (n - 1) (acc * n)
</code></pre>
<p>Notice that the recursive call to <code>factorialTailRec</code> is the last thing that happens in this function - it is in tail position.</p>
<h2 id="accumulators"><a class="header" href="#accumulators">Accumulators</a></h2>
<p>One common way to turn a function which is not tail recursive into a tail recursive function is to use an <em>accumulator parameter</em>. An accumulator parameter is an additional parameter which is added to a function which <em>accumulates</em> a return value, as opposed to using the return value to accumulate the result.</p>
<p>For example, consider again the <code>length</code> function presented in the beginning of the chapter:</p>
<pre><code class="language-haskell">length :: forall a. Array a -&gt; Int
length arr =
  if null arr
    then 0
    else 1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>This implementation is not tail recursive, so the generated JavaScript will cause a stack overflow when executed on a large input array. However, we can make it tail recursive, by introducing a second function argument to accumulate the result instead:</p>
<pre><code class="language-haskell">lengthTailRec :: forall a. Array a -&gt; Int
lengthTailRec arr = length' arr 0
  where
  length' :: Array a -&gt; Int -&gt; Int
  length' arr' acc =
    if null arr'
      then acc
      else length' (fromMaybe [] $ tail arr') (acc + 1)
</code></pre>
<p>In this case, we delegate to the helper function <code>length'</code>, which is tail recursive - its only recursive call is in the last case, and is in tail position. This means that the generated code will be a <em>while loop</em>, and will not blow the stack for large inputs.</p>
<p>To understand the implementation of <code>lengthTailRec</code>, note that the helper function <code>length'</code> essentially uses the accumulator parameter to maintain an additional piece of state - the partial result. It starts out at 0, and grows by adding 1 for every element in the input array.</p>
<p>Note also that while we might think of the accumulator as &quot;state&quot;, there is no direct mutation going on.</p>
<h2 id="prefer-folds-to-explicit-recursion"><a class="header" href="#prefer-folds-to-explicit-recursion">Prefer Folds to Explicit Recursion</a></h2>
<p>If we can write our recursive functions using tail recursion, then we can benefit from tail recursion optimization, so it becomes tempting to try to write all of our functions in this form. However, it is often easy to forget that many functions can be written directly as a fold over an array or similar data structure. Writing algorithms directly in terms of combinators such as <code>map</code> and <code>fold</code> has the added advantage of code simplicity - these combinators are well-understood, and as such, communicate the <em>intent</em> of the algorithm much better than explicit recursion.</p>
<p>For example, we can reverse an array using <code>foldr</code>:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :paste
… reverse :: forall a. Array a -&gt; Array a
… reverse = foldr (\x xs -&gt; xs &lt;&gt; [x]) []
… ^D

&gt; reverse [1, 2, 3]
[3,2,1]
</code></pre>
<p>Writing <code>reverse</code> in terms of <code>foldl</code> will be left as an exercise for the reader.</p>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>allTrue</code> which uses <code>foldl</code> to test whether an array of boolean values are all true.</li>
<li>(Medium - No Test) Characterize those arrays <code>xs</code> for which the function <code>foldl (==) false xs</code> returns <code>true</code>. In other words, complete the sentence: &quot;The function returns <code>true</code> when <code>xs</code> contains ...&quot;</li>
<li>(Medium) Write a function <code>fibTailRec</code> which is the same as <code>fib</code> but in tail recursive form. <em>Hint</em>: Use an accumulator parameter.</li>
<li>(Medium) Write <code>reverse</code> in terms of <code>foldl</code>.</li>
</ol>
<h2 id="a-virtual-filesystem"><a class="header" href="#a-virtual-filesystem">A Virtual Filesystem</a></h2>
<p>In this section, we're going to apply what we've learned, writing functions which will work with a model of a filesystem. We will use maps, folds and filters to work with a predefined API.</p>
<p>The <code>Data.Path</code> module defines an API for a virtual filesystem, as follows:</p>
<ul>
<li>There is a type <code>Path</code> which represents a path in the filesystem.</li>
<li>There is a path <code>root</code> which represents the root directory.</li>
<li>The <code>ls</code> function enumerates the files in a directory.</li>
<li>The <code>filename</code> function returns the file name for a <code>Path</code>.</li>
<li>The <code>size</code> function returns the file size for a <code>Path</code> which represents a file.</li>
<li>The <code>isDirectory</code> function tests whether a <code>Path</code> is a file or a directory.</li>
</ul>
<p>In terms of types, we have the following type definitions:</p>
<pre><code class="language-haskell">root :: Path

ls :: Path -&gt; Array Path

filename :: Path -&gt; String

size :: Path -&gt; Maybe Int

isDirectory :: Path -&gt; Boolean
</code></pre>
<p>We can try out the API in PSCi:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Path

&gt; root
/

&gt; isDirectory root
true

&gt; ls root
[/bin/,/etc/,/home/]
</code></pre>
<p>The <code>Test.Examples</code> module defines functions which use the <code>Data.Path</code> API. You do not need to modify the <code>Data.Path</code> module, or understand its implementation. We will work entirely in the <code>Test.Examples</code> module.</p>
<h2 id="listing-all-files"><a class="header" href="#listing-all-files">Listing All Files</a></h2>
<p>Let's write a function which performs a deep enumeration of all files inside a directory. This function will have the following type:</p>
<pre><code class="language-haskell">allFiles :: Path -&gt; Array Path
</code></pre>
<p>We can define this function by recursion. First, we can use <code>ls</code> to enumerate the immediate children of the directory. For each child, we can recursively apply <code>allFiles</code>, which will return an array of paths. <code>concatMap</code> will allow us to apply <code>allFiles</code> and flatten the results at the same time.</p>
<p>Finally, we use the cons operator <code>:</code> to include the current file:</p>
<pre><code class="language-haskell">allFiles file = file : concatMap allFiles (ls file)
</code></pre>
<p><em>Note</em>: the cons operator <code>:</code> actually has poor performance on immutable arrays, so it is not recommended in general. Performance can be improved by using other data structures, such as linked lists and sequences.</p>
<p>Let's try this function in PSCi:</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.Path

&gt; allFiles root

[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]
</code></pre>
<p>Great! Now let's see if we can write this function using an array comprehension using do notation.</p>
<p>Recall that a backwards arrow corresponds to choosing an element from an array. The first step is to choose an element from the immediate children of the argument. Then we simply call the function recursively for that file. Since we are using do notation, there is an implicit call to <code>concatMap</code> which concatenates all of the recursive results.</p>
<p>Here is the new version:</p>
<pre><code class="language-haskell">allFiles' :: Path -&gt; Array Path
allFiles' file = file : do
  child &lt;- ls file
  allFiles' child
</code></pre>
<p>Try out the new version in PSCi - you should get the same result. I'll let you decide which version you find clearer.</p>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a function <code>onlyFiles</code> which returns all <em>files</em> (not directories) in all subdirectories of a directory.</p>
</li>
<li>
<p>(Medium) Write a function <code>whereIs</code> to search for a file by name. The function should return a value of type <code>Maybe Path</code>, indicating the directory containing the file, if it exists. It should behave as follows:</p>
<pre><code class="language-text">&gt; whereIs root &quot;ls&quot;
Just (/bin/)

&gt; whereIs root &quot;cat&quot;
Nothing
</code></pre>
<p><em>Hint</em>: Try to write this function as an array comprehension using do notation.</p>
</li>
<li>
<p>(Difficult) Write a function <code>largestSmallest</code> which takes a <code>Path</code> and returns an array containing the single largest and single smallest files in the <code>Path</code>. <em>Note</em>: consider the cases where there are zero or one files in the <code>Path</code> by returning an empty array or a one-element array respectively.</p>
</li>
</ol>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>In this chapter, we covered the basics of recursion in PureScript, as a means of expressing algorithms concisely. We also introduced user-defined infix operators, standard functions on arrays such as maps, filters and folds, and array comprehensions which combine these ideas. Finally, we showed the importance of using tail recursion in order to avoid stack overflow errors, and how to use accumulator parameters to convert functions to tail recursive form.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<h2 id="chapter-goals-3"><a class="header" href="#chapter-goals-3">Chapter Goals</a></h2>
<p>This chapter will introduce two new concepts: algebraic data types, and pattern matching. We will also briefly cover an interesting feature of the PureScript type system: row polymorphism.</p>
<p>Pattern matching is a common technique in functional programming and allows the developer to write compact functions which express potentially complex ideas, by breaking their implementation down into multiple cases.</p>
<p>Algebraic data types are a feature of the PureScript type system which enable a similar level of expressiveness in the language of types - they are closely related to pattern matching.</p>
<p>The goal of the chapter will be to write a library to describe and manipulate simple vector graphics using algebraic types and pattern matching.</p>
<h2 id="project-setup-2"><a class="header" href="#project-setup-2">Project Setup</a></h2>
<p>The source code for this chapter is defined in the file <code>src/Data/Picture.purs</code>.</p>
<p>The <code>Data.Picture</code> module defines a data type <code>Shape</code> for simple shapes, and a type <code>Picture</code> for collections of shapes, along with functions for working with those types.</p>
<p>The module imports the <code>Data.Foldable</code> module, which provides functions for folding data structures:</p>
<pre><code class="language-haskell">module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
</code></pre>
<p>The <code>Data.Picture</code> module also imports the <code>Number</code> module, but this time using the <code>as</code> keyword:</p>
<pre><code class="language-haskell">import Data.Number as Number
</code></pre>
<p>This makes the types and functions in that module available for use, but only by using the <em>qualified name</em>, like <code>Number.max</code>. This can be useful to avoid overlapping imports, or just to make it clearer which modules certain things are imported from.</p>
<p><em>Note</em>: it is not necessary to use the same module name as the original module for a qualified import. Shorter qualified names like <code>import Data.Number as N</code> are possible, and quite common.</p>
<h2 id="simple-pattern-matching"><a class="header" href="#simple-pattern-matching">Simple Pattern Matching</a></h2>
<p>Let's begin by looking at an example. Here is a function which computes the greatest common divisor of two integers using pattern matching:</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>This algorithm is called the Euclidean Algorithm. If you search for its definition online, you will likely find a set of mathematical equations which look a lot like the code above. This is one benefit of pattern matching: it allows you to define code by cases, writing simple, declarative code which looks like a specification of a mathematical function.</p>
<p>A function written using pattern matching works by pairing sets of conditions with their results. Each line is called an <em>alternative</em> or a <em>case</em>. The expressions on the left of the equals sign are called <em>patterns</em>, and each case consists of one or more patterns, separated by spaces. Cases describe which conditions the arguments must satisfy before the expression on the right of the equals sign should be evaluated and returned. Each case is tried in order, and the first case whose patterns match their inputs determines the return value.</p>
<p>For example, the <code>gcd</code> function is evaluated using the following steps:</p>
<ul>
<li>The first case is tried: if the second argument is zero, the function returns <code>n</code> (the first argument).</li>
<li>If not, the second case is tried: if the first argument is zero, the function returns <code>m</code> (the second argument).</li>
<li>Otherwise, the function evaluates and returns the expression in the last line.</li>
</ul>
<p>Note that patterns can bind values to names - each line in the example binds one or both of the names <code>n</code> and <code>m</code> to the input values. As we learn about different kinds of patterns, we will see that different types of patterns correspond to different ways to choose names from the input arguments.</p>
<h2 id="simple-patterns"><a class="header" href="#simple-patterns">Simple Patterns</a></h2>
<p>The example code above demonstrates two types of patterns:</p>
<ul>
<li>Integer literals patterns, which match something of type <code>Int</code>, only if the value matches exactly.</li>
<li>Variable patterns, which bind their argument to a name</li>
</ul>
<p>There are other types of simple patterns:</p>
<ul>
<li><code>Number</code>, <code>String</code>, <code>Char</code> and <code>Boolean</code> literals</li>
<li>Wildcard patterns, indicated with an underscore (<code>_</code>), which match any argument, and which do not bind any names.</li>
</ul>
<p>Here are two more examples which demonstrate using these simple patterns:</p>
<pre><code class="language-haskell">fromString :: String -&gt; Boolean
fromString &quot;true&quot; = true
fromString _      = false

toString :: Boolean -&gt; String
toString true  = &quot;true&quot;
toString false = &quot;false&quot;
</code></pre>
<p>Try these functions in PSCi.</p>
<h2 id="guards-1"><a class="header" href="#guards-1">Guards</a></h2>
<p>In the Euclidean algorithm example, we used an <code>if .. then .. else</code> expression to switch between the two alternatives when <code>m &gt; n</code> and <code>m &lt;= n</code>. Another option in this case would be to use a <em>guard</em>.</p>
<p>A guard is a boolean-valued expression which must be satisfied in addition to the constraints imposed by the patterns. Here is the Euclidean algorithm rewritten to use a guard:</p>
<pre><code class="language-haskell">gcdV2 :: Int -&gt; Int -&gt; Int
gcdV2 n 0 = n
gcdV2 0 n = n
gcdV2 n m | n &gt; m     = gcdV2 (n - m) m
          | otherwise = gcdV2 n (m - n)
</code></pre>
<p>In this case, the third line uses a guard to impose the extra condition that the first argument is strictly larger than the second. The guard in the final line uses the expression <code>otherwise</code>, which might seem like a keyword, but is in fact just a regular binding in <code>Prelude</code>:</p>
<pre><code class="language-text">&gt; :type otherwise
Boolean

&gt; otherwise
true
</code></pre>
<p>As this example demonstrates, guards appear on the left of the equals symbol, separated from the list of patterns by a pipe character (<code>|</code>).</p>
<h2 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h2>
<ol>
<li>(Easy) Write the <code>factorial</code> function using pattern matching. <em>Hint</em>: Consider the two corner cases of zero and non-zero inputs. <em>Note</em>: This is a repeat of an example from the previous chapter, but see if you can rewrite it here on your own.</li>
<li>(Medium) Write a function <code>binomial</code> which finds the coefficient of the x^<code>k</code>th term in the polynomial expansion of (1 + x)^<code>n</code>. This is the same as the number of ways to choose a subset of <code>k</code> elements from a set of <code>n</code> elements. Use the formula <code>n! / k! (n - k)!</code>, where <code>!</code> is the factorial function written earlier. <em>Hint</em>: Use pattern matching to handle corner cases. If it takes a long time to complete or crashes with an error about the call stack, try adding more corner cases.</li>
<li>(Medium) Write a function <code>pascal</code> which uses <a href="https://en.wikipedia.org/wiki/Pascal%27s_rule"><em>Pascal`s Rule</em></a> for computing the same binomial coefficients as the previous exercise.</li>
</ol>
<h2 id="array-patterns"><a class="header" href="#array-patterns">Array Patterns</a></h2>
<p><em>Array literal patterns</em> provide a way to match arrays of a fixed length. For example, suppose we want to write a function <code>isEmpty</code> which identifies empty arrays. We could do this by using an empty array pattern (<code>[]</code>) in the first alternative:</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty [] = true
isEmpty _ = false
</code></pre>
<p>Here is another function which matches arrays of length five, binding each of its five elements in a different way:</p>
<pre><code class="language-haskell">takeFive :: Array Int -&gt; Int
takeFive [0, 1, a, b, _] = a * b
takeFive _ = 0
</code></pre>
<p>The first pattern only matches arrays with five elements, whose first and second elements are 0 and 1 respectively. In that case, the function returns the product of the third and fourth elements. In every other case, the function returns zero. For example, in PSCi:</p>
<pre><code class="language-text">&gt; :paste
… takeFive [0, 1, a, b, _] = a * b
… takeFive _ = 0
… ^D

&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0
</code></pre>
<p>Array literal patterns allow us to match arrays of a fixed length, but PureScript does <em>not</em> provide any means of matching arrays of an unspecified length, since destructuring immutable arrays in these sorts of ways can lead to poor performance. If you need a data structure which supports this sort of matching, the recommended approach is to use <code>Data.List</code>. Other data structures exist which provide improved asymptotic performance for different operations.</p>
<h2 id="record-patterns-and-row-polymorphism"><a class="header" href="#record-patterns-and-row-polymorphism">Record Patterns and Row Polymorphism</a></h2>
<p><em>Record patterns</em> are used to match - you guessed it - records.</p>
<p>Record patterns look just like record literals, but instead of values on the right of the colon, we specify a binder for each field.</p>
<p>For example: this pattern matches any record which contains fields called <code>first</code> and <code>last</code>, and binds their values to the names <code>x</code> and <code>y</code> respectively:</p>
<pre><code class="language-haskell">showPerson :: { first :: String, last :: String } -&gt; String
showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x
</code></pre>
<p>Record patterns provide a good example of an interesting feature of the PureScript type system: <em>row polymorphism</em>. Suppose we had defined <code>showPerson</code> without a type signature above. What would its inferred type have been? Interestingly, it is not the same as the type we gave:</p>
<pre><code class="language-text">&gt; showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x

&gt; :type showPerson
forall r. { first :: String, last :: String | r } -&gt; String
</code></pre>
<p>What is the type variable <code>r</code> here? Well, if we try <code>showPerson</code> in PSCi, we see something interesting:</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;
</code></pre>
<p>We are able to append additional fields to the record, and the <code>showPerson</code> function will still work. As long as the record contains the <code>first</code> and <code>last</code> fields of type <code>String</code>, the function application is well-typed. However, it is <em>not</em> valid to call <code>showPerson</code> with too <em>few</em> fields:</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot; }

Type of expression lacks required label &quot;last&quot;
</code></pre>
<p>We can read the new type signature of <code>showPerson</code> as &quot;takes any record with <code>first</code> and <code>last</code> fields which are <code>Strings</code> <em>and any other fields</em>, and returns a <code>String</code>&quot;. This function is polymorphic in the <em>row</em> <code>r</code> of record fields, hence the name <em>row polymorphism</em>.  Note that this behavior is different than that of the original <code>showPerson</code>. Without the row variable <code>r</code>, <code>showPerson</code> only accepts records with <em>exactly</em> a <code>first</code> and <code>last</code> field and no others.</p>
<p>Note that we could have also written</p>
<pre><code class="language-haskell">&gt; showPerson p = p.last &lt;&gt; &quot;, &quot; &lt;&gt; p.first
</code></pre>
<p>and PSCi would have inferred the same type.</p>
<h2 id="record-puns"><a class="header" href="#record-puns">Record Puns</a></h2>
<p>Recall that the <code>showPerson</code> function matches a record inside its argument, binding the <code>first</code> and <code>last</code> fields to values named <code>x</code> and <code>y</code>. We could alternatively just reuse the field names themselves, and simplify this sort of pattern match as follows:</p>
<pre><code class="language-haskell">showPersonV2 :: { first :: String, last :: String } -&gt; String
showPersonV2 { first, last } = last &lt;&gt; &quot;, &quot; &lt;&gt; first
</code></pre>
<p>Here, we only specify the names of the fields, and we do not need to specify the names of the values we want to introduce. This is called a <em>record pun</em>.</p>
<p>It is also possible to use record puns to <em>construct</em> records. For example, if we have values named <code>first</code> and <code>last</code> in scope, we can construct a person record using <code>{ first, last }</code>:</p>
<pre><code class="language-haskell">unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = &quot;Jane&quot;
    last  = &quot;Doe&quot;
</code></pre>
<p>This may improve readability of code in some circumstances.</p>
<h2 id="nested-patterns"><a class="header" href="#nested-patterns">Nested Patterns</a></h2>
<p>Array patterns and record patterns both combine smaller patterns to build larger patterns. For the most part, the examples above have only used simple patterns inside array patterns and record patterns, but it is important to note that patterns can be arbitrarily <em>nested</em>, which allows functions to be defined using conditions on potentially complex data types.</p>
<p>For example, this code combines two record patterns:</p>
<pre><code class="language-haskell">type Address = { street :: String, city :: String }

type Person = { name :: String, address :: Address }

livesInLA :: Person -&gt; Boolean
livesInLA { address: { city: &quot;Los Angeles&quot; } } = true
livesInLA _ = false
</code></pre>
<h2 id="named-patterns"><a class="header" href="#named-patterns">Named Patterns</a></h2>
<p>Patterns can be <em>named</em> to bring additional names into scope when using nested patterns. Any pattern can be named by using the <code>@</code> symbol.</p>
<p>For example, this function sorts two-element arrays, naming the two elements, but also naming the array itself:</p>
<pre><code class="language-haskell">sortPair :: Array Int -&gt; Array Int
sortPair arr@[x, y]
  | x &lt;= y = arr
  | otherwise = [y, x]
sortPair arr = arr
</code></pre>
<p>This way, we save ourselves from allocating a new array if the pair is already sorted. Note that if the input array does not contain <em>exactly</em> two elements, then this function simply returns it unchanged, even if it's unsorted.</p>
<h2 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>sameCity</code> which uses record patterns to test whether two <code>Person</code> records belong to the same city.</li>
<li>(Medium) What is the most general type of the <code>sameCity</code> function, taking into account row polymorphism? What about the <code>livesInLA</code> function defined above? <em>Note</em>: There is no test for this exercise.</li>
<li>(Medium) Write a function <code>fromSingleton</code> which uses an array literal pattern to extract the sole member of a singleton array. If the array is not a singleton, your function should return a provided default value. Your function should have type <code>forall a. a -&gt; Array a -&gt; a</code></li>
</ol>
<h2 id="case-expressions"><a class="header" href="#case-expressions">Case Expressions</a></h2>
<p>Patterns do not only appear in top-level function declarations. It is possible to use patterns to match on an intermediate value in a computation, using a <code>case</code> expression. Case expressions provide a similar type of utility to anonymous functions: it is not always desirable to give a name to a function, and a <code>case</code> expression allows us to avoid naming a function just because we want to use a pattern.</p>
<p>Here is an example. This function computes &quot;longest zero suffix&quot; of an array (the longest suffix which sums to zero):</p>
<pre><code class="language-haskell">import Data.Array (tail)
import Data.Foldable (sum)
import Data.Maybe (fromMaybe)

lzs :: Array Int -&gt; Array Int
lzs [] = []
lzs xs = case sum xs of
           0 -&gt; xs
           _ -&gt; lzs (fromMaybe [] $ tail xs)
</code></pre>
<p>For example:</p>
<pre><code class="language-text">&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]
</code></pre>
<p>This function works by case analysis. If the array is empty, our only option is to return an empty array. If the array is non-empty, we first use a <code>case</code> expression to split into two cases. If the sum of the array is zero, we return the whole array. If not, we recurse on the tail of the array.</p>
<h2 id="pattern-match-failures-and-partial-functions"><a class="header" href="#pattern-match-failures-and-partial-functions">Pattern Match Failures and Partial Functions</a></h2>
<p>If patterns in a case expression are tried in order, then what happens in the case when none of the patterns in a case alternatives match their inputs? In this case, the case expression will fail at runtime with a <em>pattern match failure</em>.</p>
<p>We can see this behavior with a simple example:</p>
<pre><code class="language-haskell">import Partial.Unsafe (unsafePartial)

partialFunction :: Boolean -&gt; Boolean
partialFunction = unsafePartial \true -&gt; true
</code></pre>
<p>This function contains only a single case, which only matches a single input, <code>true</code>. If we compile this file, and test in PSCi with any other argument, we will see an error at runtime:</p>
<pre><code class="language-text">&gt; partialFunction false

Failed pattern match
</code></pre>
<p>Functions which return a value for any combination of inputs are called <em>total</em> functions, and functions which do not are called <em>partial</em>.</p>
<p>It is generally considered better to define total functions where possible. If it is known that a function does not return a result for some valid set of inputs, it is usually better to return a value capable of indicating failure, such as type <code>Maybe a</code> for some <code>a</code>, using <code>Nothing</code> when it cannot return a valid result. This way, the presence or absence of a value can be indicated in a type-safe way.</p>
<p>The PureScript compiler will generate an error if it can detect that your function is not total due to an incomplete pattern match. The <code>unsafePartial</code> function can be used to silence these errors (if you are sure that your partial function is safe!) If we removed the call to the <code>unsafePartial</code> function above, then the compiler would generate the following error:</p>
<pre><code class="language-text">A case expression could not be determined to cover all inputs.
The following additional cases are required to cover all inputs:

  false
</code></pre>
<p>This tells us that the value <code>false</code> is not matched by any pattern. In general, these warnings might include multiple unmatched cases.</p>
<p>If we also omit the type signature above:</p>
<pre><code class="language-haskell">partialFunction true = true
</code></pre>
<p>then PSCi infers a curious type:</p>
<pre><code class="language-text">&gt; :type partialFunction

Partial =&gt; Boolean -&gt; Boolean
</code></pre>
<p>We will see more types which involve the <code>=&gt;</code> symbol later on in the book (they are related to <em>type classes</em>), but for now, it suffices to observe that PureScript keeps track of partial functions using the type system, and that we must explicitly tell the type checker when they are safe.</p>
<p>The compiler will also generate a warning in certain cases when it can detect that cases are <em>redundant</em> (that is, a case only matches values which would have been matched by a prior case):</p>
<pre><code class="language-haskell">redundantCase :: Boolean -&gt; Boolean
redundantCase true = true
redundantCase false = false
redundantCase false = false
</code></pre>
<p>In this case, the last case is correctly identified as redundant:</p>
<pre><code class="language-text">A case expression contains unreachable cases:

  false
</code></pre>
<p><em>Note</em>: PSCi does not show warnings, so to reproduce this example, you will need to save this function as a file and compile it using <code>spago build</code>.</p>
<h2 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h2>
<p>This section will introduce a feature of the PureScript type system called <em>Algebraic Data Types</em> (or <em>ADTs</em>), which are fundamentally related to pattern matching.</p>
<p>However, we'll first consider a motivating example, which will provide the basis of a solution to this chapter's problem of implementing a simple vector graphics library.</p>
<p>Suppose we wanted to define a type to represent some simple shapes: lines, rectangles, circles, text, etc. In an object oriented language, we would probably define an interface or abstract class <code>Shape</code>, and one concrete subclass for each type of shape that we wanted to be able to work with.</p>
<p>However, this approach has one major drawback: to work with <code>Shape</code>s abstractly, it is necessary to identify all of the operations one might wish to perform, and to define them on the <code>Shape</code> interface. It becomes difficult to add new operations without breaking modularity.</p>
<p>Algebraic data types provide a type-safe way to solve this sort of problem, if the set of shapes is known in advance. It is possible to define new operations on <code>Shape</code> in a modular way, and still maintain type-safety.</p>
<p>Here is how <code>Shape</code> might be represented as an algebraic data type:</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String

type Point =
  { x :: Number
  , y :: Number
  }
</code></pre>
<p>This declaration defines <code>Shape</code> as a sum of different constructors, and for each constructor identifies the data that is included. A <code>Shape</code> is either a <code>Circle</code> which contains a center <code>Point</code> and a radius (a number), or a <code>Rectangle</code>, or a <code>Line</code>, or <code>Text</code>. There are no other ways to construct a value of type <code>Shape</code>.</p>
<p>An algebraic data type is introduced using the <code>data</code> keyword, followed by the name of the new type and any type arguments. The type's constructors (i.e. its <em>data constructors</em>) are defined after the equals symbol, and are separated by pipe characters (<code>|</code>). The data carried by an ADT's constructors doesn't have to be restricted to primitive types: constructors can include records, arrays, or even other ADTs.</p>
<p>Let's see another example from PureScript's standard libraries. We saw the <code>Maybe</code> type, which is used to define optional values, earlier in the book. Here is its definition from the <code>maybe</code> package:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>This example demonstrates the use of a type parameter <code>a</code>. Reading the pipe character as the word &quot;or&quot;, its definition almost reads like English: &quot;a value of type <code>Maybe a</code> is either <code>Nothing</code>, or <code>Just</code> a value of type <code>a</code>&quot;.</p>
<p>Note that we don't use the syntax <code>forall a.</code> anywhere in our data definition. <code>forall</code> syntax is necessary for functions, but is not used when defining ADTs with <code>data</code> or type aliases with <code>type</code>.</p>
<p>Data constructors can also be used to define recursive data structures. Here is one more example, defining a data type of singly-linked lists of elements of type <code>a</code>:</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
</code></pre>
<p>This example is taken from the <code>lists</code> package. Here, the <code>Nil</code> constructor represents an empty list, and <code>Cons</code> is used to create non-empty lists from a head element and a tail. Notice how the tail is defined using the data type <code>List a</code>, making this a recursive data type.</p>
<h2 id="using-adts"><a class="header" href="#using-adts">Using ADTs</a></h2>
<p>It is simple enough to use the constructors of an algebraic data type to construct a value: simply apply them like functions, providing arguments corresponding to the data included with the appropriate constructor.</p>
<p>For example, the <code>Line</code> constructor defined above required two <code>Point</code>s, so to construct a <code>Shape</code> using the <code>Line</code> constructor, we have to provide two arguments of type <code>Point</code>:</p>
<pre><code class="language-haskell">exampleLine :: Shape
exampleLine = Line p1 p2
  where
    p1 :: Point
    p1 = { x: 0.0, y: 0.0 }

    p2 :: Point
    p2 = { x: 100.0, y: 50.0 }
</code></pre>
<p>So, constructing values of algebraic data types is simple, but how do we use them? This is where the important connection with pattern matching appears: the only way to consume a value of an algebraic data type is to use a pattern to match its constructor.</p>
<p>Let's see an example. Suppose we want to convert a <code>Shape</code> into a <code>String</code>. We have to use pattern matching to discover which constructor was used to construct the <code>Shape</code>. We can do this as follows:</p>
<pre><code class="language-haskell">showShape :: Shape -&gt; String
showShape (Circle c r) =
  &quot;Circle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, radius: &quot; &lt;&gt; show r &lt;&gt; &quot;]&quot;
showShape (Rectangle c w h) =
  &quot;Rectangle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, width: &quot; &lt;&gt; show w &lt;&gt; &quot;, height: &quot; &lt;&gt; show h &lt;&gt; &quot;]&quot;
showShape (Line start end) =
  &quot;Line [start: &quot; &lt;&gt; showPoint start &lt;&gt; &quot;, end: &quot; &lt;&gt; showPoint end &lt;&gt; &quot;]&quot;
showShape (Text loc text) =
  &quot;Text [location: &quot; &lt;&gt; showPoint loc &lt;&gt; &quot;, text: &quot; &lt;&gt; show text &lt;&gt; &quot;]&quot;

showPoint :: Point -&gt; String
showPoint { x, y } =
  &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot;, &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>Each constructor can be used as a pattern, and the arguments to the constructor can themselves be bound using patterns of their own. Consider the first case of <code>showShape</code>: if the <code>Shape</code> matches the <code>Circle</code> constructor, then we bring the arguments of <code>Circle</code> (center and radius) into scope using two variable patterns, <code>c</code> and <code>r</code>. The other cases are similar.</p>
<h2 id="exercises-9"><a class="header" href="#exercises-9">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>circleAtOrigin</code> which constructs a <code>Circle</code> (of type <code>Shape</code>) centered at the origin with radius <code>10.0</code>.</li>
<li>(Medium) Write a function <code>doubleScaleAndCenter</code> which scales the size of a <code>Shape</code> by a factor of <code>2.0</code> and centers it at the origin.</li>
<li>(Medium) Write a function <code>shapeText</code> which extracts the text from a <code>Shape</code>. It should return <code>Maybe String</code>, and use the <code>Nothing</code> constructor if the input is not constructed using <code>Text</code>.</li>
</ol>
<h2 id="newtypes"><a class="header" href="#newtypes">Newtypes</a></h2>
<p>There is a special case of algebraic data types, called <em>newtypes</em>. Newtypes are introduced using the <code>newtype</code> keyword instead of the <code>data</code> keyword.</p>
<p>Newtypes must define <em>exactly one</em> constructor, and that constructor must take <em>exactly one</em> argument. That is, a newtype gives a new name to an existing type. In fact, the values of a newtype have the same runtime representation as the underlying type, so there is no runtime performance overhead. They are, however, distinct from the point of view of the type system. This gives an extra layer of type safety.</p>
<p>As an example, we might want to define newtypes as type-level aliases for <code>Number</code>, to ascribe units like volts, amps, and ohms:</p>
<pre><code class="language-haskell">newtype Volt = Volt Number
newtype Ohm = Ohm Number
newtype Amp = Amp Number
</code></pre>
<p>Then we define functions and values using these types:</p>
<pre><code class="language-haskell">calculateCurrent :: Volt -&gt; Ohm -&gt; Amp
calculateCurrent (Volt v) (Ohm r) = Amp (v / r)

battery :: Volt
battery = Volt 1.5

lightbulb :: Ohm
lightbulb = Ohm 500.0

current :: Amp
current = calculateCurrent battery lightbulb
</code></pre>
<p>This prevents us from making silly mistakes, such as attempting to calculate the current produced by <em>two</em> lightbulbs <em>without</em> a voltage source.</p>
<pre><code class="language-haskell">current :: Amp
current = calculateCurrent lightbulb lightbulb
{-
TypesDoNotUnify:
  current = calculateCurrent lightbulb lightbulb
                             ^^^^^^^^^
  Could not match type
    Ohm
  with type
    Volt
-}
</code></pre>
<p>If we instead just used <code>Number</code> without <code>newtype</code>, then the compiler can't help us catch this mistake:</p>
<pre><code class="language-haskell">-- This also compiles, but is not as type safe.
calculateCurrent :: Number -&gt; Number -&gt; Number
calculateCurrent v r = v / r

battery :: Number
battery = 1.5

lightbulb :: Number
lightbulb = 500.0

current :: Number
current = calculateCurrent lightbulb lightbulb -- uncaught mistake
</code></pre>
<p>Note that while a newtype can only have a single constructor, and the constructor must be of a single value, a newtype <em>can</em> take any number of type variables. For example, the following newtype would be a valid definition (<code>err</code> and <code>a</code> are the type variables, and the <code>CouldError</code> constructor expects a <em>single</em> value of type <code>Either err a</code>):</p>
<pre><code class="language-Haskell">newtype CouldError err a = CouldError (Either err a)
</code></pre>
<p>Also note that the constructor of a newtype often has the same name as the newtype itself, but this is not a requirement. For example, unique names are also valid:</p>
<pre><code class="language-haskell">newtype Coulomb = MakeCoulomb Number
</code></pre>
<p>In this case, <code>Coulomb</code> is the <em>type constructor</em> (of zero arguments) and <code>MakeCoulomb</code> is the <em>data constructor</em>. These constructors live in different namespaces, even when the names are identical, such as with the <code>Volt</code> example. This is true for all ADTs. Note that although the type constructor and data constructor can have different names, in practice it is idiomatic for them to share the same name. This is the case with <code>Amp</code> and <code>Volt</code> types above.</p>
<p>Another application of newtypes is to attach different <em>behavior</em> to an existing type without changing its representation at runtime. We cover that use case in the next chapter when we discuss <em>type classes</em>.</p>
<h2 id="exercises-10"><a class="header" href="#exercises-10">Exercises</a></h2>
<ol>
<li>(Easy) Define <code>Watt</code> as a <code>newtype</code> of <code>Number</code>. Then define a <code>calculateWattage</code> function using this new <code>Watt</code> type and the above definitions <code>Amp</code> and <code>Volt</code>:</li>
</ol>
<pre><code class="language-haskell">calculateWattage :: Amp -&gt; Volt -&gt; Watt
</code></pre>
<p>A wattage in <code>Watt</code>s can be calculated as the product of a given current in <code>Amp</code>s and a given voltage in <code>Volt</code>s.</p>
<h2 id="a-library-for-vector-graphics"><a class="header" href="#a-library-for-vector-graphics">A Library for Vector Graphics</a></h2>
<p>Let's use the data types we have defined above to create a simple library for using vector graphics.</p>
<p>Define a type synonym for a <code>Picture</code> - just an array of <code>Shape</code>s:</p>
<pre><code class="language-haskell">type Picture = Array Shape
</code></pre>
<p>For debugging purposes, we'll want to be able to turn a <code>Picture</code> into something readable. The <code>showPicture</code> function lets us do that:</p>
<pre><code class="language-haskell">showPicture :: Picture -&gt; Array String
showPicture = map showShape
</code></pre>
<p>Let's try it out. Compile your module with <code>spago build</code> and open PSCi with <code>spago repl</code>:</p>
<pre><code class="language-text">$ spago build
$ spago repl

&gt; import Data.Picture

&gt; showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]

[&quot;Line [start: (0.0, 0.0), end: (1.0, 1.0)]&quot;]
</code></pre>
<h2 id="computing-bounding-rectangles"><a class="header" href="#computing-bounding-rectangles">Computing Bounding Rectangles</a></h2>
<p>The example code for this module contains a function <code>bounds</code> which computes the smallest bounding rectangle for a <code>Picture</code>.</p>
<p>The <code>Bounds</code> type defines a bounding rectangle.</p>
<pre><code class="language-haskell">type Bounds =
  { top    :: Number
  , left   :: Number
  , bottom :: Number
  , right  :: Number
  }
</code></pre>
<p><code>bounds</code> uses the <code>foldl</code> function from <code>Data.Foldable</code> to traverse the array of <code>Shapes</code> in a <code>Picture</code>, and accumulate the smallest bounding rectangle:</p>
<pre><code class="language-haskell">bounds :: Picture -&gt; Bounds
bounds = foldl combine emptyBounds
  where
  combine :: Bounds -&gt; Shape -&gt; Bounds
  combine b shape = union (shapeBounds shape) b
</code></pre>
<p>In the base case, we need to find the smallest bounding rectangle of an empty <code>Picture</code>, and the empty bounding rectangle defined by <code>emptyBounds</code> suffices.</p>
<p>The accumulating function <code>combine</code> is defined in a <code>where</code> block. <code>combine</code> takes a bounding rectangle computed from <code>foldl</code>'s recursive call, and the next <code>Shape</code> in the array, and uses the <code>union</code> function to compute the union of the two bounding rectangles. The <code>shapeBounds</code> function computes the bounds of a single shape using pattern matching.</p>
<h2 id="exercises-11"><a class="header" href="#exercises-11">Exercises</a></h2>
<ol>
<li>(Medium) Extend the vector graphics library with a new operation <code>area</code> which computes the area of a <code>Shape</code>. For the purpose of this exercise, the area of a line or a piece of text is assumed to be zero.</li>
<li>(Difficult) Extend the <code>Shape</code> type with a new data constructor <code>Clipped</code>, which clips another <code>Picture</code> to a rectangle. Extend the <code>shapeBounds</code> function to compute the bounds of a clipped picture. Note that this makes <code>Shape</code> into a recursive data type.</li>
</ol>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In this chapter, we covered pattern matching, a basic but powerful technique from functional programming. We saw how to use simple patterns as well as array and record patterns to match parts of deep data structures.</p>
<p>This chapter also introduced algebraic data types, which are closely related to pattern matching. We saw how algebraic data types allow concise descriptions of data structures, and provide a modular way to extend data types with new operations.</p>
<p>Finally, we covered <em>row polymorphism</em>, a powerful type of abstraction which allows many idiomatic JavaScript functions to be given a type.</p>
<p>In the rest of the book, we will use ADTs and pattern matching extensively, so it will pay dividends to become familiar with them now. Try creating your own algebraic data types and writing functions to consume them using pattern matching.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-classes"><a class="header" href="#type-classes">Type Classes</a></h1>
<h2 id="chapter-goals-4"><a class="header" href="#chapter-goals-4">Chapter Goals</a></h2>
<p>This chapter will introduce a powerful form of abstraction which is enabled by PureScript's type system - type classes.</p>
<p>This motivating example for this chapter will be a library for hashing data structures. We will see how the machinery of type classes allow us to hash complex data structures without having to think directly about the structure of the data itself.</p>
<p>We will also see a collection of standard type classes from PureScript's Prelude and standard libraries. PureScript code leans heavily on the power of type classes to express ideas concisely, so it will be beneficial to familiarize yourself with these classes.</p>
<p>If you come from an Object Oriented background, please note that the word &quot;class&quot; means something <em>very</em> different in this context than what you're used to. A type class serves a purpose more similar to an OO interface.</p>
<h2 id="project-setup-3"><a class="header" href="#project-setup-3">Project Setup</a></h2>
<p>The source code for this chapter is defined in the file <code>src/Data/Hashable.purs</code>.</p>
<p>The project has the following dependencies:</p>
<ul>
<li><code>maybe</code>, which defines the <code>Maybe</code> data type, which represents optional values.</li>
<li><code>tuples</code>, which defines the <code>Tuple</code> data type, which represents pairs of values.</li>
<li><code>either</code>, which defines the <code>Either</code> data type, which represents disjoint unions.</li>
<li><code>strings</code>, which defines functions which operate on strings.</li>
<li><code>functions</code>, which defines some helper functions for defining PureScript functions.</li>
</ul>
<p>The module <code>Data.Hashable</code> imports several modules provided by these packages.</p>
<h2 id="show-me"><a class="header" href="#show-me">Show Me!</a></h2>
<p>Our first simple example of a type class is provided by a function we've seen several times already: the <code>show</code> function, which takes a value and displays it as a string.</p>
<p><code>show</code> is defined by a type class in the <code>Prelude</code> module called <code>Show</code>, which is defined as follows:</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String
</code></pre>
<p>This code declares a new <em>type class</em> called <code>Show</code>, which is parameterized by the type variable <code>a</code>.</p>
<p>A type class <em>instance</em> contains implementations of the functions defined in a type class, specialized to a particular type.</p>
<p>For example, here is the definition of the <code>Show</code> type class instance for <code>Boolean</code> values, taken from the Prelude:</p>
<pre><code class="language-haskell">instance showBoolean :: Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<p>This code declares a type class instance called <code>showBoolean</code> - in PureScript, type class instances can be named to aid the readability of the generated JavaScript. We say that the <code>Boolean</code> type <em>belongs to the <code>Show</code> type class</em>.</p>
<p>We can try out the <code>Show</code> type class in PSCi, by showing a few values with different types:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; show true
&quot;true&quot;

&gt; show 1.0
&quot;1.0&quot;

&gt; show &quot;Hello World&quot;
&quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>These examples demonstrate how to <code>show</code> values of various primitive types, but we can also <code>show</code> values with more complicated types:</p>
<pre><code class="language-text">&gt; import Data.Tuple

&gt; show (Tuple 1 true)
&quot;(Tuple 1 true)&quot;

&gt; import Data.Maybe

&gt; show (Just &quot;testing&quot;)
&quot;(Just \&quot;testing\&quot;)&quot;
</code></pre>
<p>The output of <code>show</code> should be a string that you can paste back into the repl (or <code>.purs</code> file) to recreate the item being shown. Here we'll use <code>logShow</code>, which just calls <code>show</code> then <code>log</code>, to render the string without quotes. Ignore the <code>unit</code> print - that will covered in Chapter 8 when we examine <code>Effect</code>s, like <code>log</code>.</p>
<pre><code class="language-text">&gt; import Effect.Console

&gt; logShow (Tuple 1 true)
(Tuple 1 true)
unit

&gt; logShow (Just &quot;testing&quot;)
(Just &quot;testing&quot;)
unit
</code></pre>
<p>If we try to show a value of type <code>Data.Either</code>, we get an interesting error message:</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; show (Left 10)

The inferred type

    forall a. Show a =&gt; String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>The problem here is not that there is no <code>Show</code> instance for the type we intended to <code>show</code>, but rather that PSCi was unable to infer the type. This is indicated by the <em>unknown type</em> <code>a</code> in the inferred type.</p>
<p>We can annotate the expression with a type, using the <code>::</code> operator, so that PSCi can choose the correct type class instance:</p>
<pre><code class="language-text">&gt; show (Left 10 :: Either Int String)
&quot;(Left 10)&quot;
</code></pre>
<p>Some types do not have a <code>Show</code> instance defined at all. One example of this is the function type <code>-&gt;</code>. If we try to <code>show</code> a function from <code>Int</code> to <code>Int</code>, we get an appropriate error message from the type checker:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; show $ \n -&gt; n + 1

No type class instance was found for

  Data.Show.Show (Int -&gt; Int)
</code></pre>
<p>Type class instances can be defined in one of two places: in the same module that the type class is defined, or in the same module that the type &quot;belonging to&quot; the type class is defined. An instance defined in any other spot is called an <a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">&quot;orphan instance&quot;</a> and is not allowed by the PureScript compiler. Some of the exercises in this chapter will require you to copy the definition of a type into your MySolutions module so that you can define type class instances for that type.</p>
<h2 id="exercises-12"><a class="header" href="#exercises-12">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Define a <code>Show</code> instance for <code>Point</code>. Match the same output as the <code>showPoint</code> function from the previous chapter. <em>Note:</em> Point is now a <code>newtype</code> (instead of a <code>type</code> synonym), which allows us to customize how to <code>show</code> it. Otherwise, we'd be stuck with the default <code>Show</code> instance for records.</p>
<pre><code class="language-haskell">newtype Point
  = Point
  { x :: Number
  , y :: Number
  }
</code></pre>
</li>
</ol>
<h2 id="common-type-classes"><a class="header" href="#common-type-classes">Common Type Classes</a></h2>
<p>In this section, we'll look at some standard type classes defined in the Prelude and standard libraries. These type classes form the basis of many common patterns of abstraction in idiomatic PureScript code, so a basic understanding of their functions is highly recommended.</p>
<h3 id="eq"><a class="header" href="#eq">Eq</a></h3>
<p>The <code>Eq</code> type class defines the <code>eq</code> function, which tests two values for equality. The <code>==</code> operator is actually just an alias for <code>eq</code>.</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>Note that in either case, the two arguments must have the same type: it does not make sense to compare two values of different types for equality.</p>
<p>Try out the <code>Eq</code> type class in PSCi:</p>
<pre><code class="language-text">&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true
</code></pre>
<h3 id="ord"><a class="header" href="#ord">Ord</a></h3>
<p>The <code>Ord</code> type class defines the <code>compare</code> function, which can be used to compare two values, for types which support ordering. The comparison operators <code>&lt;</code> and <code>&gt;</code> along with their non-strict companions <code>&lt;=</code> and <code>&gt;=</code>, can be defined in terms of <code>compare</code>.</p>
<pre><code class="language-haskell">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p>The <code>compare</code> function compares two values, and returns an <code>Ordering</code>, which has three alternatives:</p>
<ul>
<li><code>LT</code> - if the first argument is less than the second.</li>
<li><code>EQ</code> - if the first argument is equal to the second.</li>
<li><code>GT</code> - if the first argument is greater than the second.</li>
</ul>
<p>Again, we can try out the <code>compare</code> function in PSCi:</p>
<pre><code class="language-text">&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<p>The <code>Field</code> type class identifies those types which support numeric operators such as addition, subtraction, multiplication and division. It is provided to abstract over those operators, so that they can be reused where appropriate.</p>
<p><em>Note</em>: Just like the <code>Eq</code> and <code>Ord</code> type classes, the <code>Field</code> type class has special support in the PureScript compiler, so that simple expressions such as <code>1 + 2 * 3</code> get translated into simple JavaScript, as opposed to function calls which dispatch based on a type class implementation.</p>
<pre><code class="language-haskell">class EuclideanRing a &lt;= Field a
</code></pre>
<p>The <code>Field</code> type class is composed from several more general <em>superclasses</em>. This allows us to talk abstractly about types which support some but not all of the <code>Field</code> operations. For example, a type of natural numbers would be closed under addition and multiplication, but not necessarily under subtraction, so that type might have an instance of the <code>Semiring</code> class (which is a superclass of <code>Num</code>), but not an instance of <code>Ring</code> or <code>Field</code>.</p>
<p>Superclasses will be explained later in this chapter, but the full <a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">numeric type class hierarchy</a> (<a href="https://harry.garrood.me/numeric-hierarchy-overview/">cheatsheet</a>) is beyond the scope of this chapter. The interested reader is encouraged to read the documentation for the superclasses of <code>Field</code> in <code>prelude</code>.</p>
<h3 id="semigroups-and-monoids"><a class="header" href="#semigroups-and-monoids">Semigroups and Monoids</a></h3>
<p>The <code>Semigroup</code> type class identifies those types which support an <code>append</code> operation to combine two values:</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a
</code></pre>
<p>Strings form a semigroup under regular string concatenation, and so do arrays. Several other standard instances are provided by the <code>prelude</code> package.</p>
<p>The <code>&lt;&gt;</code> concatenation operator, which we have already seen, is provided as an alias for <code>append</code>.</p>
<p>The <code>Monoid</code> type class (provided by the <code>prelude</code> package) extends the <code>Semigroup</code> type class with the concept of an empty value, called <code>mempty</code>:</p>
<pre><code class="language-haskell">class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>Again, strings and arrays are simple examples of monoids.</p>
<p>A <code>Monoid</code> type class instance for a type describes how to <em>accumulate</em> a result with that type, by starting with an &quot;empty&quot; value, and combining new results. For example, we can write a function which concatenates an array of values in some monoid by using a fold. In PSCi:</p>
<pre><code class="language-haskell">&gt; import Prelude
&gt; import Data.Monoid
&gt; import Data.Foldable

&gt; foldl append mempty [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&quot;Hello World&quot;

&gt; foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
</code></pre>
<p>The <code>prelude</code> package provides many examples of monoids and semigroups, which we will use in the rest of the book.</p>
<h3 id="foldable"><a class="header" href="#foldable">Foldable</a></h3>
<p>If the <code>Monoid</code> type class identifies those types which act as the result of a fold, then the <code>Foldable</code> type class identifies those type constructors which can be used as the source of a fold.</p>
<p>The <code>Foldable</code> type class is provided in the <code>foldable-traversable</code> package, which also contains instances for some standard containers such as arrays and <code>Maybe</code>.</p>
<p>The type signatures for the functions belonging to the <code>Foldable</code> class are a little more complicated than the ones we've seen so far:</p>
<pre><code class="language-haskell">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p>It is instructive to specialize to the case where <code>f</code> is the array type constructor. In this case, we can replace <code>f a</code> with <code>Array a</code> for any a, and we notice that the types of <code>foldl</code> and <code>foldr</code> become the types that we saw when we first encountered folds over arrays.</p>
<p>What about <code>foldMap</code>? Well, that becomes <code>forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Array a -&gt; m</code>. This type signature says that we can choose any type <code>m</code> for our result type, as long as that type is an instance of the <code>Monoid</code> type class. If we can provide a function which turns our array elements into values in that monoid, then we can accumulate over our array using the structure of the monoid, and return a single value.</p>
<p>Let's try out <code>foldMap</code> in PSCi:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;
</code></pre>
<p>Here, we choose the monoid for strings, which concatenates strings together, and the <code>show</code> function which renders an <code>Int</code> as a <code>String</code>. Then, passing in an array of integers, we see that the results of <code>show</code>ing each integer have been concatenated into a single <code>String</code>.</p>
<p>But arrays are not the only types which are foldable. <code>foldable-traversable</code> also defines <code>Foldable</code> instances for types like <code>Maybe</code> and <code>Tuple</code>, and other libraries like <code>lists</code> define <code>Foldable</code> instances for their own data types. <code>Foldable</code> captures the notion of an <em>ordered container</em>.</p>
<h3 id="functor-and-type-class-laws"><a class="header" href="#functor-and-type-class-laws">Functor, and Type Class Laws</a></h3>
<p>The Prelude also defines a collection of type classes which enable a functional style of programming with side-effects in PureScript: <code>Functor</code>, <code>Applicative</code> and <code>Monad</code>. We will cover these abstractions later in the book, but for now, let's look at the definition of the <code>Functor</code> type class, which we have seen already in the form of the <code>map</code> function:</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The <code>map</code> function (and its alias <code>&lt;$&gt;</code>) allows a function to be &quot;lifted&quot; over a data structure. The precise definition of the word &quot;lifted&quot; here depends on the data structure in question, but we have already seen its behavior for some simple types:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; map (\n -&gt; n &lt; 3) [1, 2, 3, 4, 5]
[true, true, false, false, false]

&gt; import Data.Maybe
&gt; import Data.String (length)

&gt; map length (Just &quot;testing&quot;)
(Just 7)
</code></pre>
<p>How can we understand the meaning of the <code>map</code> function, when it acts on many different structures, each in a different way?</p>
<p>Well, we can build an intuition that the <code>map</code> function applies the function it is given to each element of a container, and builds a new container from the results, with the same shape as the original. But how do we make this concept precise?</p>
<p>Type class instances for <code>Functor</code> are expected to adhere to a set of <em>laws</em>, called the <em>functor laws</em>:</p>
<ul>
<li><code>map identity xs = xs</code></li>
<li><code>map g (map f xs) = map (g &lt;&lt;&lt; f) xs</code></li>
</ul>
<p>The first law is the <em>identity law</em>. It states that lifting the identity function (the function which returns its argument unchanged) over a structure just returns the original structure. This makes sense since the identity function does not modify its input.</p>
<p>The second law is the <em>composition law</em>. It states that mapping one function over a structure, and then mapping a second, is the same thing as mapping the composition of the two functions over the structure.</p>
<p>Whatever &quot;lifting&quot; means in the general sense, it should be true that any reasonable definition of lifting a function over a data structure should obey these rules.</p>
<p>Many standard type classes come with their own set of similar laws. The laws given to a type class give structure to the functions of that type class and allow us to study its instances in generality. The interested reader can research the laws ascribed to the standard type classes that we have seen already.</p>
<h3 id="deriving-instances"><a class="header" href="#deriving-instances">Deriving Instances</a></h3>
<p>Rather than writing instances manually, you can let the compiler do most of the work for you. Take a look at this <a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">Type Class Deriving guide</a>. That information will help you solve the following exercises.</p>
<h2 id="exercises-13"><a class="header" href="#exercises-13">Exercises</a></h2>
<p>The following newtype represents a complex number:</p>
<pre><code class="language-haskell">newtype Complex
  = Complex
  { real :: Number
  , imaginary :: Number
  }
</code></pre>
<ol>
<li>
<p>(Easy) Define a <code>Show</code> instance for <code>Complex</code>. Match the output format expected by the tests (e.g. <code>1.2+3.4i</code>, <code>5.6-7.8i</code>, etc.).</p>
</li>
<li>
<p>(Easy) Derive an <code>Eq</code> instance for <code>Complex</code>. <em>Note</em>: You may instead write this instance manually, but why do more work if you don't have to?</p>
</li>
<li>
<p>(Medium) Define a <code>Semiring</code> instance for <code>Complex</code>. <em>Note</em>: You can use <code>wrap</code> and <code>over2</code> from <a href="https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype"><code>Data.Newtype</code></a> to create a more concise solution. If you do so, you will also need to import <code>class Newtype</code> from <code>Data.Newtype</code> and derive a <code>Newtype</code> instance for <code>Complex</code>.</p>
</li>
<li>
<p>(Easy) Derive (via <code>newtype</code>) a <code>Ring</code> instance for <code>Complex</code>. <em>Note</em>: You may instead write this instance manually, but that's not as convenient.</p>
<p>Here's the <code>Shape</code> ADT from the previous chapter:</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String
</code></pre>
</li>
<li>
<p>(Medium) Derive (via <code>Generic</code>) a <code>Show</code> instance for <code>Shape</code>. How does the amount of code written and <code>String</code> output compare to <code>showShape</code> from the previous chapter? <em>Hint</em>: See the <a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic">Deriving from <code>Generic</code></a> section of the <a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">Type Class Deriving</a> guide.</p>
</li>
</ol>
<h2 id="type-class-constraints"><a class="header" href="#type-class-constraints">Type Class Constraints</a></h2>
<p>Types of functions can be constrained by using type classes. Here is an example: suppose we want to write a function which tests if three values are equal, by using equality defined using an <code>Eq</code> type class instance.</p>
<pre><code class="language-haskell">threeAreEqual :: forall a. Eq a =&gt; a -&gt; a -&gt; a -&gt; Boolean
threeAreEqual a1 a2 a3 = a1 == a2 &amp;&amp; a2 == a3
</code></pre>
<p>The type declaration looks like an ordinary polymorphic type defined using <code>forall</code>. However, there is a type class constraint <code>Eq a</code>, separated from the rest of the type by a double arrow <code>=&gt;</code>.</p>
<p>This type says that we can call <code>threeAreEqual</code> with any choice of type <code>a</code>, as long as there is an <code>Eq</code> instance available for <code>a</code> in one of the imported modules.</p>
<p>Constrained types can contain several type class instances, and the types of the instances are not restricted to simple type variables. Here is another example which uses <code>Ord</code> and <code>Show</code> instances to compare two values:</p>
<pre><code class="language-haskell">showCompare :: forall a. Ord a =&gt; Show a =&gt; a -&gt; a -&gt; String
showCompare a1 a2 | a1 &lt; a2 =
  show a1 &lt;&gt; &quot; is less than &quot; &lt;&gt; show a2
showCompare a1 a2 | a1 &gt; a2 =
  show a1 &lt;&gt; &quot; is greater than &quot; &lt;&gt; show a2
showCompare a1 a2 =
  show a1 &lt;&gt; &quot; is equal to &quot; &lt;&gt; show a2
</code></pre>
<p>Note that multiple constraints can be specified by using the <code>=&gt;</code> symbol multiple times, just like we specify curried functions
of multiple arguments. But remember not to confuse the two symbols:</p>
<ul>
<li><code>a -&gt; b</code> denotes the type of functions from <em>type</em> <code>a</code> to <em>type</em> <code>b</code>, whereas</li>
<li><code>a =&gt; b</code> applies the <em>constraint</em> <code>a</code> to the type <code>b</code>.</li>
</ul>
<p>The PureScript compiler will try to infer constrained types when a type annotation is not provided. This can be useful if we want to use the most general type possible for a function.</p>
<p>To see this, try using one of the standard type classes like <code>Semiring</code> in PSCi:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; :type \x -&gt; x + x
forall a. Semiring a =&gt; a -&gt; a
</code></pre>
<p>Here, we might have annotated this function as <code>Int -&gt; Int</code>, or <code>Number -&gt; Number</code>, but PSCi shows us that the most general type works for any <code>Semiring</code>, allowing us to use our function with both <code>Int</code>s and <code>Number</code>s.</p>
<h2 id="instance-dependencies"><a class="header" href="#instance-dependencies">Instance Dependencies</a></h2>
<p>Just as the implementation of functions can depend on type class instances using constrained types, so can the implementation of type class instances depend on other type class instances. This provides a powerful form of program inference, in which the implementation of a program can be inferred using its types.</p>
<p>For example, consider the <code>Show</code> type class. We can write a type class instance to <code>show</code> arrays of elements, as long as we have a way to <code>show</code> the elements themselves:</p>
<pre><code class="language-haskell">instance showArray :: Show a =&gt; Show (Array a) where
  ...
</code></pre>
<p>If a type class instance depends on multiple other instances, those instances should be grouped in parentheses and separated by
commas on the left hand side of the <code>=&gt;</code> symbol:</p>
<pre><code class="language-haskell">instance showEither :: (Show a, Show b) =&gt; Show (Either a b) where
  ...
</code></pre>
<p>These two type class instances are provided in the <code>prelude</code> library.</p>
<p>When the program is compiled, the correct type class instance for <code>Show</code> is chosen based on the inferred type of the argument to <code>show</code>. The selected instance might depend on many such instance relationships, but this complexity is not exposed to the developer.</p>
<h2 id="exercises-14"><a class="header" href="#exercises-14">Exercises</a></h2>
<ol>
<li>
<p>(Easy) The following declaration defines a type of non-empty arrays of elements of type <code>a</code>:</p>
<pre><code class="language-haskell">data NonEmpty a = NonEmpty a (Array a)
</code></pre>
<p>Write an <code>Eq</code> instance for the type <code>NonEmpty a</code> which reuses the instances for <code>Eq a</code> and <code>Eq (Array a)</code>. <em>Note:</em> you may instead derive the <code>Eq</code> instance.</p>
</li>
<li>
<p>(Medium) Write a <code>Semigroup</code> instance for <code>NonEmpty a</code> by reusing the <code>Semigroup</code> instance for <code>Array</code>.</p>
</li>
<li>
<p>(Medium) Write a <code>Functor</code> instance for <code>NonEmpty</code>.</p>
</li>
<li>
<p>(Medium) Given any type <code>a</code> with an instance of <code>Ord</code>, we can add a new &quot;infinite&quot; value which is greater than any other value:</p>
<pre><code class="language-haskell">data Extended a = Infinite | Finite a 
</code></pre>
<p>Write an <code>Ord</code> instance for <code>Extended a</code> which reuses the <code>Ord</code> instance for <code>a</code>.</p>
</li>
<li>
<p>(Difficult) Write a <code>Foldable</code> instance for <code>NonEmpty</code>. <em>Hint</em>: reuse the <code>Foldable</code> instance for arrays.</p>
</li>
<li>
<p>(Difficult) Given a type constructor <code>f</code> which defines an ordered container (and so has a <code>Foldable</code> instance), we can create a new container type which includes an extra element at the front:</p>
<pre><code class="language-haskell">data OneMore f a = OneMore a (f a)
</code></pre>
<p>The container <code>OneMore f</code> also has an ordering, where the new element comes before any element of <code>f</code>. Write a <code>Foldable</code> instance for <code>OneMore f</code>:</p>
<pre><code class="language-haskell">instance foldableOneMore :: Foldable f =&gt; Foldable (OneMore f) where
  ...
</code></pre>
</li>
<li>
<p>(Medium) Write a <code>dedupShapes :: Array Shape -&gt; Array Shape</code> function which removes duplicate <code>Shape</code>s from an array using the <code>nubEq</code> function.</p>
</li>
<li>
<p>(Medium) Write a <code>dedupShapesFast</code> function which is the same as <code>dedupShapes</code>, but uses the more efficient <code>nub</code> function.</p>
</li>
</ol>
<h2 id="multi-parameter-type-classes"><a class="header" href="#multi-parameter-type-classes">Multi Parameter Type Classes</a></h2>
<p>It's not the case that a type class can only take a single type as an argument. This is the most common case, but in fact, a type class can be parameterized by <em>zero or more</em> type arguments.</p>
<p>Let's see an example of a type class with two type arguments.</p>
<pre><code class="language-haskell">module Stream where

import Data.Array as Array
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String

class Stream stream element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }

instance streamArray :: Stream (Array a) a where
  uncons = Array.uncons

instance streamString :: Stream String Char where
  uncons = String.uncons
</code></pre>
<p>The <code>Stream</code> module defines a class <code>Stream</code> which identifies types which look like streams of elements, where elements can be pulled from the front of the stream using the <code>uncons</code> function.</p>
<p>Note that the <code>Stream</code> type class is parameterized not only by the type of the stream itself, but also by its elements. This allows us to define type class instances for the same stream type but different element types.</p>
<p>The module defines two type class instances: an instance for arrays, where <code>uncons</code> removes the head element of the array using pattern matching, and an instance for String, which removes the first character from a String.</p>
<p>We can write functions which work over arbitrary streams. For example, here is a function which accumulates a result in some <code>Monoid</code> based on the elements of a stream:</p>
<pre><code class="language-haskell">import Prelude
import Data.Monoid (class Monoid, mempty)

foldStream :: forall l e m. Stream l e =&gt; Monoid m =&gt; (e -&gt; m) -&gt; l -&gt; m
foldStream f list =
  case uncons list of
    Nothing -&gt; mempty
    Just cons -&gt; f cons.head &lt;&gt; foldStream f cons.tail
</code></pre>
<p>Try using <code>foldStream</code> in PSCi for different types of <code>Stream</code> and different types of <code>Monoid</code>.</p>
<h2 id="functional-dependencies"><a class="header" href="#functional-dependencies">Functional Dependencies</a></h2>
<p>Multi-parameter type classes can be very useful, but can easily lead to confusing types and even issues with type inference. As a simple example, consider writing a generic <code>tail</code> function on streams using the <code>Stream</code> class given above:</p>
<pre><code class="language-haskell">genericTail xs = map _.tail (uncons xs)
</code></pre>
<p>This gives a somewhat confusing error message:</p>
<pre><code class="language-text">The inferred type

  forall stream a. Stream stream a =&gt; stream -&gt; Maybe stream

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>The problem is that the <code>genericTail</code> function does not use the <code>element</code> type mentioned in the definition of the <code>Stream</code> type class, so that type is left unsolved.</p>
<p>Worse still, we cannot even use <code>genericTail</code> by applying it to a specific type of stream:</p>
<pre><code class="language-text">&gt; map _.tail (uncons &quot;testing&quot;)

The inferred type

  forall a. Stream String a =&gt; Maybe String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>Here, we might expect the compiler to choose the <code>streamString</code> instance. After all, a <code>String</code> is a stream of <code>Char</code>s, and cannot be a stream of any other type of elements.</p>
<p>The compiler is unable to make that deduction automatically, and cannot commit to the <code>streamString</code> instance. However, we can help the compiler by adding a hint to the type class definition:</p>
<pre><code class="language-haskell">class Stream stream element | stream -&gt; element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }
</code></pre>
<p>Here, <code>stream -&gt; element</code> is called a <em>functional dependency</em>. A functional dependency asserts a functional relationship between the type arguments of a multi-parameter type class. This functional dependency tells the compiler that there is a function from stream types to (unique) element types, so if the compiler knows the stream type, then it can commit to the element type.</p>
<p>This hint is enough for the compiler to infer the correct type for our generic tail function above:</p>
<pre><code class="language-text">&gt; :type genericTail
forall stream element. Stream stream element =&gt; stream -&gt; Maybe stream

&gt; genericTail &quot;testing&quot;
(Just &quot;esting&quot;)
</code></pre>
<p>Functional dependencies can be quite useful when using multi-parameter type classes to design certain APIs.</p>
<h2 id="nullary-type-classes"><a class="header" href="#nullary-type-classes">Nullary Type Classes</a></h2>
<p>We can even define type classes with zero type arguments! These correspond to compile-time assertions about our functions, allowing us to track global properties of our code in the type system.</p>
<p>An important example is the <code>Partial</code> class which we saw earlier when discussing partial functions. Take for example the functions <code>head</code> and <code>tail</code> defined in <code>Data.Array.Partial</code> that allow us to get the head or tail of an array without wrapping them in a <code>Maybe</code>, so they can fail if the array is empty:</p>
<pre><code class="language-haskell">head :: forall a. Partial =&gt; Array a -&gt; a

tail :: forall a. Partial =&gt; Array a -&gt; Array a
</code></pre>
<p>Note that there is no instance defined for the <code>Partial</code> type class! Doing so would defeat its purpose: attempting to use the <code>head</code> function directly will result in a type error:</p>
<pre><code class="language-text">&gt; head [1, 2, 3]

No type class instance was found for

  Prim.Partial
</code></pre>
<p>Instead, we can republish the <code>Partial</code> constraint for any functions making use of partial functions:</p>
<pre><code class="language-haskell">secondElement :: forall a. Partial =&gt; Array a -&gt; a
secondElement xs = head (tail xs)
</code></pre>
<p>We've already seen the <code>unsafePartial</code> function, which allows us to treat a partial function as a regular function (unsafely). This function is defined in the <code>Partial.Unsafe</code> module:</p>
<pre><code class="language-haskell">unsafePartial :: forall a. (Partial =&gt; a) -&gt; a
</code></pre>
<p>Note that the <code>Partial</code> constraint appears <em>inside the parentheses</em> on the left of the function arrow, but not in the outer <code>forall</code>. That is, <code>unsafePartial</code> is a function from partial values to regular values:</p>
<pre><code class="language-text">&gt; unsafePartial head [1, 2, 3]
1

&gt; unsafePartial secondElement [1, 2, 3]
2
</code></pre>
<h2 id="superclasses"><a class="header" href="#superclasses">Superclasses</a></h2>
<p>Just as we can express relationships between type class instances by making an instance dependent on another instance, we can express relationships between type classes themselves using so-called <em>superclasses</em>.</p>
<p>We say that one type class is a superclass of another if every instance of the second class is required to be an instance of the first, and we indicate a superclass relationship in the class definition by using a backwards facing double arrow.</p>
<p>We've already seen some examples of superclass relationships: the <code>Eq</code> class is a superclass of <code>Ord</code>, and the <code>Semigroup</code> class is a superclass of <code>Monoid</code>. For every type class instance of the <code>Ord</code> class, there must be a corresponding <code>Eq</code> instance for the same type. This makes sense, since in many cases, when the <code>compare</code> function reports that two values are incomparable, we often want to use the <code>Eq</code> class to determine if they are in fact equal.</p>
<p>In general, it makes sense to define a superclass relationship when the laws for the subclass mention the members of the superclass. For example, it is reasonable to assume, for any pair of <code>Ord</code> and <code>Eq</code> instances, that if two values are equal under the <code>Eq</code> instance, then the <code>compare</code> function should return <code>EQ</code>. In other words, <code>a == b</code> should be true exactly when <code>compare a b</code> evaluates to <code>EQ</code>. This relationship on the level of laws justifies the superclass relationship between <code>Eq</code> and <code>Ord</code>.</p>
<p>Another reason to define a superclass relationship is in the case where there is a clear &quot;is-a&quot; relationship between the two classes. That is, every member of the subclass <em>is a</em> member of the superclass as well.</p>
<h2 id="exercises-15"><a class="header" href="#exercises-15">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Define a partial function <code>unsafeMaximum :: Partial =&gt; Array Int -&gt; Int</code> which finds the maximum of a non-empty array of integers. Test out your function in PSCi using <code>unsafePartial</code>. <em>Hint</em>: Use the <code>maximum</code> function from <code>Data.Foldable</code>.</p>
</li>
<li>
<p>(Medium) The <code>Action</code> class is a multi-parameter type class which defines an action of one type on another:</p>
<pre><code class="language-haskell">class Monoid m &lt;= Action m a where
  act :: m -&gt; a -&gt; a
</code></pre>
<p>An <em>action</em> is a function which describes how monoidal values are used to determine how to modify a value of another type. There are two laws for the <code>Action</code> type class:</p>
<ul>
<li><code>act mempty a = a</code></li>
<li><code>act (m1 &lt;&gt; m2) a = act m1 (act m2 a)</code></li>
</ul>
<p>Applying an empty action is a no-op. And applying two actions in sequence is the same as applying the actions combined. That is, actions respect the operations defined by the <code>Monoid</code> class.</p>
<p>For example, the natural numbers form a monoid under multiplication:</p>
<pre><code class="language-haskell">newtype Multiply = Multiply Int

instance semigroupMultiply :: Semigroup Multiply where
  append (Multiply n) (Multiply m) = Multiply (n * m)

instance monoidMultiply :: Monoid Multiply where
  mempty = Multiply 1
</code></pre>
<p>Write an instance which implements this action:</p>
<pre><code class="language-haskell">instance actionMultiplyInt :: Action Multiply Int where
  ...
</code></pre>
<p>Remember, your instance must satisfy the laws listed above.</p>
</li>
<li>
<p>(Difficult) There are actually multiple ways to implement an instance of <code>Action Multiply Int</code>. How many can you think of? Purescript does not allow multiple implementations of a same instance, so you will have to replace your original implementation. <em>Note</em>: the tests cover 4 implementations.</p>
</li>
<li>
<p>(Medium) Write an <code>Action</code> instance which repeats an input string some number of times:</p>
<pre><code class="language-haskell">instance actionMultiplyString :: Action Multiply String where
  ...
</code></pre>
<p><em>Hint</em>: Search Pursuit for a helper-function with the signature <a href="https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String"><code>String -&gt; Int -&gt; String</code></a>. Note that <code>String</code> might appear as a more generic type (such as <code>Monoid</code>).</p>
<p>Does this instance satisfy the laws listed above?</p>
</li>
<li>
<p>(Medium) Write an instance <code>Action m a =&gt; Action m (Array a)</code>, where the action on arrays is defined by acting on each array element independently.</p>
</li>
<li>
<p>(Difficult) Given the following newtype, write an instance for <code>Action m (Self m)</code>, where the monoid <code>m</code> acts on itself using <code>append</code>:</p>
<pre><code class="language-haskell">newtype Self m = Self m
</code></pre>
<p><em>Note</em>: The testing framework requires <code>Show</code> and <code>Eq</code> instances for the <code>Self</code> and <code>Multiply</code> types. You may either write these instances manually, or let the compiler handle this for you with <a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype"><code>derive newtype instance</code></a> shorthand.</p>
</li>
<li>
<p>(Difficult) Should the arguments of the multi-parameter type class <code>Action</code> be related by some functional dependency? Why or why not? <em>Note</em>: There is no test for this exercise.</p>
</li>
</ol>
<h2 id="a-type-class-for-hashes"><a class="header" href="#a-type-class-for-hashes">A Type Class for Hashes</a></h2>
<p>In the last section of this chapter, we will use the lessons from the rest of the chapter to create a library for hashing data structures.</p>
<p>Note that this library is for demonstration purposes only, and is not intended to provide a robust hashing mechanism.</p>
<p>What properties might we expect of a hash function?</p>
<ul>
<li>A hash function should be deterministic, and map equal values to equal hash codes.</li>
<li>A hash function should distribute its results approximately uniformly over some set of hash codes.</li>
</ul>
<p>The first property looks a lot like a law for a type class, whereas the second property is more along the lines of an informal contract, and certainly would not be enforceable by PureScript's type system. However, this should provide the intuition for the following type class:</p>
<pre><code class="language-haskell">newtype HashCode = HashCode Int

instance hashCodeEq :: Eq HashCode where
  eq (HashCode a) (HashCode b) = a == b

hashCode :: Int -&gt; HashCode
hashCode h = HashCode (h `mod` 65535)

class Eq a &lt;= Hashable a where
  hash :: a -&gt; HashCode
</code></pre>
<p>with the associated law that <code>a == b</code> implies <code>hash a == hash b</code>.</p>
<p>We'll spend the rest of this section building a library of instances and functions associated with the <code>Hashable</code> type class.</p>
<p>We will need a way to combine hash codes in a deterministic way:</p>
<pre><code class="language-haskell">combineHashes :: HashCode -&gt; HashCode -&gt; HashCode
combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)
</code></pre>
<p>The <code>combineHashes</code> function will mix two hash codes and redistribute the result over the interval 0-65535.</p>
<p>Let's write a function which uses the <code>Hashable</code> constraint to restrict the types of its inputs. One common task which requires a hashing function is to determine if two values hash to the same hash code. The <code>hashEqual</code> relation provides such a capability:</p>
<pre><code class="language-haskell">hashEqual :: forall a. Hashable a =&gt; a -&gt; a -&gt; Boolean
hashEqual = eq `on` hash
</code></pre>
<p>This function uses the <code>on</code> function from <code>Data.Function</code> to define hash-equality in terms of equality of hash codes, and should read like a declarative definition of hash-equality: two values are &quot;hash-equal&quot; if they are equal after each value has been passed through the <code>hash</code> function.</p>
<p>Let's write some <code>Hashable</code> instances for some primitive types. Let's start with an instance for integers. Since a <code>HashCode</code> is really just a wrapped integer, this is simple - we can use the <code>hashCode</code> helper function:</p>
<pre><code class="language-haskell">instance hashInt :: Hashable Int where
  hash = hashCode
</code></pre>
<p>We can also define a simple instance for <code>Boolean</code> values using pattern matching:</p>
<pre><code class="language-haskell">instance hashBoolean :: Hashable Boolean where
  hash false = hashCode 0
  hash true  = hashCode 1
</code></pre>
<p>With an instance for hashing integers, we can create an instance for hashing <code>Char</code>s by using the <code>toCharCode</code> function from <code>Data.Char</code>:</p>
<pre><code class="language-haskell">instance hashChar :: Hashable Char where
  hash = hash &lt;&lt;&lt; toCharCode
</code></pre>
<p>To define an instance for arrays, we can <code>map</code> the <code>hash</code> function over the elements of the array (if the element type is also an instance of <code>Hashable</code>) and then perform a left fold over the resulting hashes using the <code>combineHashes</code> function:</p>
<pre><code class="language-haskell">instance hashArray :: Hashable a =&gt; Hashable (Array a) where
  hash = foldl combineHashes (hashCode 0) &lt;&lt;&lt; map hash
</code></pre>
<p>Notice how we build up instances using the simpler instances we have already written. Let's use our new <code>Array</code> instance to define an instance for <code>String</code>s, by turning a <code>String</code> into an array of <code>Char</code>s:</p>
<pre><code class="language-haskell">instance hashString :: Hashable String where
  hash = hash &lt;&lt;&lt; toCharArray
</code></pre>
<p>How can we prove that these <code>Hashable</code> instances satisfy the type class law that we stated above? We need to make sure that equal values have equal hash codes. In cases like <code>Int</code>, <code>Char</code>, <code>String</code> and <code>Boolean</code>, this is simple because there are no values of those types which are equal in the sense of <code>Eq</code> but not equal identically.</p>
<p>What about some more interesting types? To prove the type class law for the <code>Array</code> instance, we can use induction on the length of the array. The only array with length zero is <code>[]</code>. Any two non-empty arrays are equal only if they have equal head elements and equal tails, by the definition of <code>Eq</code> on arrays. By the inductive hypothesis, the tails have equal hashes, and we know that the head elements have equal hashes if the <code>Hashable a</code> instance must satisfy the law. Therefore, the two arrays have equal hashes, and so the <code>Hashable (Array a)</code> obeys the type class law as well.</p>
<p>The source code for this chapter includes several other examples of <code>Hashable</code> instances, such as instances for the <code>Maybe</code> and <code>Tuple</code> type.</p>
<h2 id="exercises-16"><a class="header" href="#exercises-16">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use PSCi to test the hash functions for each of the defined instances. <em>Note</em>: There is no provided unit test for this exercise.</p>
</li>
<li>
<p>(Medium) Write a function <code>arrayHasDuplicates</code> which tests if an array has any duplicate elements based on both hash and value equality. First check for hash equality with the <code>hashEqual</code> function, then check for value equality with <code>==</code> if a duplicate pair of hashes is found. <em>Hint</em>: the <code>nubByEq</code> function in <code>Data.Array</code> should make this task much simpler.</p>
</li>
<li>
<p>(Medium) Write a <code>Hashable</code> instance for the following newtype which satisfies the type class law:</p>
<pre><code class="language-haskell">newtype Hour = Hour Int

instance eqHour :: Eq Hour where
  eq (Hour n) (Hour m) = mod n 12 == mod m 12
</code></pre>
<p>The newtype <code>Hour</code> and its <code>Eq</code> instance represent the type of integers modulo 12, so that 1 and 13 are identified as equal, for example. Prove that the type class law holds for your instance.</p>
</li>
<li>
<p>(Difficult) Prove the type class laws for the <code>Hashable</code> instances for <code>Maybe</code>, <code>Either</code> and <code>Tuple</code>. <em>Note</em>: There is no test for this exercise.</p>
</li>
</ol>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>In this chapter, we've been introduced to <em>type classes</em>, a type-oriented form of abstraction which enables powerful forms of code reuse. We've seen a collection of standard type classes from the PureScript standard libraries, and defined our own library based on a type class for computing hash codes.</p>
<p>This chapter also gave an introduction to the notion of type class laws, a technique for proving properties about code which uses type classes for abstraction. Type class laws are part of a larger subject called <em>equational reasoning</em>, in which the properties of a programming language and its type system are used to enable logical reasoning about its programs. This is an important idea, and will be a theme which we will return to throughout the rest of the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applicative-validation"><a class="header" href="#applicative-validation">Applicative Validation</a></h1>
<h2 id="chapter-goals-5"><a class="header" href="#chapter-goals-5">Chapter Goals</a></h2>
<p>In this chapter, we will meet an important new abstraction - the <em>applicative functor</em>, described by the <code>Applicative</code> type class. Don't worry if the name sounds confusing - we will motivate the concept with a practical example - validating form data. This technique allows us to convert code which usually involves a lot of boilerplate checking into a simple, declarative description of our form.</p>
<p>We will also meet another type class, <code>Traversable</code>, which describes <em>traversable functors</em>, and see how this concept also arises very naturally from solutions to real-world problems.</p>
<p>The example code for this chapter will be a continuation of the address book example from chapter 3. This time, we will extend our address book data types, and write functions to validate values for those types. The understanding is that these functions could be used, for example in a web user interface, to display errors to the user as part of a data entry form.</p>
<h2 id="project-setup-4"><a class="header" href="#project-setup-4">Project Setup</a></h2>
<p>The source code for this chapter is defined in the files <code>src/Data/AddressBook.purs</code> and <code>src/Data/AddressBook/Validation.purs</code>.</p>
<p>The project has a number of dependencies, many of which we have seen before. There are two new dependencies:</p>
<ul>
<li><code>control</code>, which defines functions for abstracting control flow using type classes like <code>Applicative</code>.</li>
<li><code>validation</code>, which defines a functor for <em>applicative validation</em>, the subject of this chapter.</li>
</ul>
<p>The <code>Data.AddressBook</code> module defines data types and <code>Show</code> instances for the types in our project, and the <code>Data.AddressBook.Validation</code> module contains validation rules for those types.</p>
<h2 id="generalizing-function-application"><a class="header" href="#generalizing-function-application">Generalizing Function Application</a></h2>
<p>To explain the concept of an <em>applicative functor</em>, let's consider the type constructor <code>Maybe</code> that we met earlier.</p>
<p>The source code for this module defines a function <code>address</code> which has the following type:</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address
</code></pre>
<p>This function is used to construct a value of type <code>Address</code> from three strings: a street name, a city, and a state.</p>
<p>We can apply this function easily and see the result in PSCi:</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; address &quot;123 Fake St.&quot; &quot;Faketown&quot; &quot;CA&quot;
{ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>However, suppose we did not necessarily have a street, city, or state, and wanted to use the <code>Maybe</code> type to indicate a missing value in each of the three cases.</p>
<p>In one case, we might have a missing city. If we try to apply our function directly, we will receive an error from the type checker:</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Could not match type

  Maybe String

with type

  String
</code></pre>
<p>Of course, this is an expected type error - <code>address</code> takes strings as arguments, not values of type <code>Maybe String</code>.</p>
<p>However, it is reasonable to expect that we should be able to &quot;lift&quot; the <code>address</code> function to work with optional values described by the <code>Maybe</code> type. In fact, we can, and the <code>Control.Apply</code> provides the function <code>lift3</code> function which does exactly what we need:</p>
<pre><code class="language-text">&gt; import Control.Apply
&gt; lift3 address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Nothing
</code></pre>
<p>In this case, the result is <code>Nothing</code>, because one of the arguments (the city) was missing. If we provide all three arguments using the <code>Just</code> constructor, then the result will contain a value as well:</p>
<pre><code class="language-text">&gt; lift3 address (Just &quot;123 Fake St.&quot;) (Just &quot;Faketown&quot;) (Just &quot;CA&quot;)

Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })
</code></pre>
<p>The name of the function <code>lift3</code> indicates that it can be used to lift functions of 3 arguments. There are similar functions defined in <code>Control.Apply</code> for functions of other numbers of arguments.</p>
<h2 id="lifting-arbitrary-functions"><a class="header" href="#lifting-arbitrary-functions">Lifting Arbitrary Functions</a></h2>
<p>So, we can lift functions with small numbers of arguments by using <code>lift2</code>, <code>lift3</code>, etc. But how can we generalize this to arbitrary functions?</p>
<p>It is instructive to look at the type of <code>lift3</code>:</p>
<pre><code class="language-text">&gt; :type lift3
forall a b c d f. Apply f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d
</code></pre>
<p>In the <code>Maybe</code> example above, the type constructor <code>f</code> is <code>Maybe</code>, so that <code>lift3</code> is specialized to the following type:</p>
<pre><code class="language-haskell">forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; Maybe a -&gt; Maybe b -&gt; Maybe c -&gt; Maybe d
</code></pre>
<p>This type says that we can take any function with three arguments, and lift it to give a new function whose argument and result types are wrapped with <code>Maybe</code>.</p>
<p>Certainly, this is not possible for every type constructor <code>f</code>, so what is it about the <code>Maybe</code> type which allowed us to do this? Well, in specializing the type above, we removed a type class constraint on <code>f</code> from the <code>Apply</code> type class. <code>Apply</code> is defined in the Prelude as follows:</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The <code>Apply</code> type class is a subclass of <code>Functor</code>, and defines an additional function <code>apply</code>. As <code>&lt;$&gt;</code> was defined as an alias for <code>map</code>, the <code>Prelude</code> module defines <code>&lt;*&gt;</code> as an alias for <code>apply</code>. As we'll see, these two operators are often used together.</p>
<p>Note that this <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Apply#v:apply"><code>apply</code></a> is different than the <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:apply"><code>apply</code></a> from <code>Data.Function</code> (infixed as <code>$</code>). Luckily, infix notation is almost always used for the latter, so you don't need to worry about name collisions.</p>
<p>The type of <code>apply</code> looks a lot like the type of <code>map</code>. The difference between <code>map</code> and <code>apply</code> is that <code>map</code> takes a function as an argument, whereas the first argument to <code>apply</code> is wrapped in the type constructor <code>f</code>. We'll see how this is used soon, but first, let's see how to implement the <code>Apply</code> type class for the <code>Maybe</code> type:</p>
<pre><code class="language-haskell">instance functorMaybe :: Functor Maybe where
  map f (Just a) = Just (f a)
  map f Nothing  = Nothing

instance applyMaybe :: Apply Maybe where
  apply (Just f) (Just x) = Just (f x)
  apply _        _        = Nothing
</code></pre>
<p>This type class instance says that we can apply an optional function to an optional value, and the result is defined only if both are defined.</p>
<p>Now we'll see how <code>map</code> and <code>apply</code> can be used together to lift functions of arbitrary number of arguments.</p>
<p>For functions of one argument, we can just use <code>map</code> directly.</p>
<p>For functions of two arguments, we have a curried function <code>g</code> with type <code>a -&gt; b -&gt; c</code>, say. This is equivalent to the type <code>a -&gt; (b -&gt; c)</code>, so we can apply <code>map</code> to <code>g</code> to get a new function of type <code>f a -&gt; f (b -&gt; c)</code> for any type constructor <code>f</code> with a <code>Functor</code> instance. Partially applying this function to the first lifted argument (of type <code>f a</code>), we get a new wrapped function of type <code>f (b -&gt; c)</code>. If we also have an <code>Apply</code> instance for <code>f</code>, we can then use <code>apply</code> to apply the second lifted argument (of type <code>f b</code>) to get our final value of type <code>f c</code>.</p>
<p>Putting this all together, we see that if we have values <code>x :: f a</code> and <code>y :: f b</code>, then the expression <code>(g &lt;$&gt; x) &lt;*&gt; y</code> has type <code>f c</code> (remember, this expression is equivalent to <code>apply (map g x) y</code>). The precedence rules defined in the Prelude allow us to remove the parentheses: <code>g &lt;$&gt; x &lt;*&gt; y</code>.</p>
<p>In general, we can use <code>&lt;$&gt;</code> on the first argument, and <code>&lt;*&gt;</code> for the remaining arguments, as illustrated here for <code>lift3</code>:</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z
</code></pre>
<p>It is left as an exercise for the reader to verify the types involved in this expression.</p>
<p>As an example, we can try lifting the address function over <code>Maybe</code>, directly using the <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> functions:</p>
<pre><code class="language-text">&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Just &quot;Faketown&quot; &lt;*&gt; Just &quot;CA&quot;
Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })

&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;CA&quot;
Nothing
</code></pre>
<p>Try lifting some other functions of various numbers of arguments over <code>Maybe</code> in this way.</p>
<p>Alternatively <em>applicative do notation</em> can be used for the same purpose in a way that looks similar to the familiar <em>do notation</em>. Here is <code>lift3</code> using <em>applicative do notation</em>. Note <code>ado</code> is used instead of <code>do</code>, and <code>in</code> is used on the final line to denote the yielded value:</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = ado
  a &lt;- x
  b &lt;- y
  c &lt;- z
  in f a b c
</code></pre>
<h2 id="the-applicative-type-class"><a class="header" href="#the-applicative-type-class">The Applicative Type Class</a></h2>
<p>There is a related type class called <code>Applicative</code>, defined as follows:</p>
<pre><code class="language-haskell">class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p><code>Applicative</code> is a subclass of <code>Apply</code> and defines the <code>pure</code> function. <code>pure</code> takes a value and returns a value whose type has been wrapped with the type constructor <code>f</code>.</p>
<p>Here is the <code>Applicative</code> instance for <code>Maybe</code>:</p>
<pre><code class="language-haskell">instance applicativeMaybe :: Applicative Maybe where
  pure x = Just x
</code></pre>
<p>If we think of applicative functors as functors which allow lifting of functions, then <code>pure</code> can be thought of as lifting functions of zero arguments.</p>
<h2 id="intuition-for-applicative"><a class="header" href="#intuition-for-applicative">Intuition for Applicative</a></h2>
<p>Functions in PureScript are pure and do not support side-effects. Applicative functors allow us to work in larger &quot;programming languages&quot; which support some sort of side-effect encoded by the functor <code>f</code>.</p>
<p>As an example, the functor <code>Maybe</code> represents the side effect of possibly-missing values. Some other examples include <code>Either err</code>, which represents the side effect of possible errors of type <code>err</code>, and the arrow functor <code>r -&gt;</code> which represents the side-effect of reading from a global configuration. For now, we'll only consider the <code>Maybe</code> functor.</p>
<p>If the functor <code>f</code> represents this larger programming language with effects, then the <code>Apply</code> and <code>Applicative</code> instances allow us to lift values and function applications from our smaller programming language (PureScript) into the new language.</p>
<p><code>pure</code> lifts pure (side-effect free) values into the larger language, and for functions, we can use <code>map</code> and <code>apply</code> as described above.</p>
<p>This raises a question: if we can use <code>Applicative</code> to embed PureScript functions and values into this new language, then how is the new language any larger? The answer depends on the functor <code>f</code>. If we can find expressions of type <code>f a</code> which cannot be expressed as <code>pure x</code> for some <code>x</code>, then that expression represents a term which only exists in the larger language.</p>
<p>When <code>f</code> is <code>Maybe</code>, an example is the expression <code>Nothing</code>: we cannot write <code>Nothing</code> as <code>pure x</code> for any <code>x</code>. Therefore, we can think of PureScript as having been enlarged to include the new term <code>Nothing</code>, which represents a missing value.</p>
<h2 id="more-effects"><a class="header" href="#more-effects">More Effects</a></h2>
<p>Let's see some more examples of lifting functions over different <code>Applicative</code> functors.</p>
<p>Here is a simple example function defined in PSCi, which joins three names to form a full name:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; fullName first middle last = last &lt;&gt; &quot;, &quot; &lt;&gt; first &lt;&gt; &quot; &quot; &lt;&gt; middle

&gt; fullName &quot;Phillip&quot; &quot;A&quot; &quot;Freeman&quot;
Freeman, Phillip A
</code></pre>
<p>Now suppose that this function forms the implementation of a (very simple!) web service with the three arguments provided as query parameters. We want to make sure that the user provided each of the three parameters, so we might use the <code>Maybe</code> type to indicate the presence or otherwise absence of a parameter. We can lift <code>fullName</code> over <code>Maybe</code> to create an implementation of the web service which checks for missing parameters:</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Just &quot;A&quot; &lt;*&gt; Just &quot;Freeman&quot;
Just (&quot;Freeman, Phillip A&quot;)

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;Freeman&quot;
Nothing
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; :paste…
… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Just &quot;A&quot;
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
(Just &quot;Freeman, Phillip A&quot;)

… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Nothing
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
Nothing
</code></pre>
<p>Note that the lifted function returns <code>Nothing</code> if any of the arguments was <code>Nothing</code>.</p>
<p>This is good, because now we can send an error response back from our web service if the parameters are invalid. However, it would be better if we could indicate which field was incorrect in the response.</p>
<p>Instead of lifting over <code>Maybe</code>, we can lift over <code>Either String</code>, which allows us to return an error message. First, let's write an operator to convert optional inputs into computations which can signal an error using <code>Either String</code>:</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; :paste
… withError Nothing  err = Left err
… withError (Just a) _   = Right a
… ^D
</code></pre>
<p><em>Note</em>: In the <code>Either err</code> applicative functor, the <code>Left</code> constructor indicates an error, and the <code>Right</code> constructor indicates success.</p>
<p>Now we can lift over <code>Either String</code>, providing an appropriate error message for each parameter:</p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last =
…   fullName &lt;$&gt; (first  `withError` &quot;First name was missing&quot;)
…            &lt;*&gt; (middle `withError` &quot;Middle name was missing&quot;)
…            &lt;*&gt; (last   `withError` &quot;Last name was missing&quot;)
… ^D
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last = ado
…  f &lt;- first  `withError` &quot;First name was missing&quot;
…  m &lt;- middle `withError` &quot;Middle name was missing&quot;
…  l &lt;- last   `withError` &quot;Last name was missing&quot;
…  in fullName f m l
… ^D

&gt; :type fullNameEither
Maybe String -&gt; Maybe String -&gt; Maybe String -&gt; Either String String
</code></pre>
<p>Now our function takes three optional arguments using <code>Maybe</code>, and returns either a <code>String</code> error message or a <code>String</code> result.</p>
<p>We can try out the function with different inputs:</p>
<pre><code class="language-text">&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) (Just &quot;Freeman&quot;)
(Right &quot;Freeman, Phillip A&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) Nothing (Just &quot;Freeman&quot;)
(Left &quot;Middle name was missing&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) Nothing
(Left &quot;Last name was missing&quot;)
</code></pre>
<p>In this case, we see the error message corresponding to the first missing field, or a successful result if every field was provided. However, if we are missing multiple inputs, we still only see the first error:</p>
<pre><code class="language-text">&gt; fullNameEither Nothing Nothing Nothing
(Left &quot;First name was missing&quot;)
</code></pre>
<p>This might be good enough, but if we want to see a list of <em>all</em> missing fields in the error, then we need something more powerful than <code>Either String</code>. We will see a solution later in this chapter.</p>
<h2 id="combining-effects"><a class="header" href="#combining-effects">Combining Effects</a></h2>
<p>As an example of working with applicative functors abstractly, this section will show how to write a function which will generically combine side-effects encoded by an applicative functor <code>f</code>.</p>
<p>What does this mean? Well, suppose we have a list of wrapped arguments of type <code>f a</code> for some <code>a</code>. That is, suppose we have a list of type <code>List (f a)</code>. Intuitively, this represents a list of computations with side-effects tracked by <code>f</code>, each with return type <code>a</code>. If we could run all of these computations in order, we would obtain a list of results of type <code>List a</code>. However, we would still have side-effects tracked by <code>f</code>. That is, we expect to be able to turn something of type <code>List (f a)</code> into something of type <code>f (List a)</code> by &quot;combining&quot; the effects inside the original list.</p>
<p>For any fixed list size <code>n</code>, there is a function of <code>n</code> arguments which builds a list of size <code>n</code> out of those arguments. For example, if <code>n</code> is <code>3</code>, the function is <code>\x y z -&gt; x : y : z : Nil</code>. This function has type <code>a -&gt; a -&gt; a -&gt; List a</code>. We can use the <code>Applicative</code> instance for <code>List</code> to lift this function over <code>f</code>, to get a function of type <code>f a -&gt; f a -&gt; f a -&gt; f (List a)</code>. But, since we can do this for any <code>n</code>, it makes sense that we should be able to perform the same lifting for any <em>list</em> of arguments.</p>
<p>That means that we should be able to write a function</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>This function will take a list of arguments, which possibly have side-effects, and return a single wrapped list, applying the side-effects of each.</p>
<p>To write this function, we'll consider the length of the list of arguments. If the list is empty, then we do not need to perform any effects, and we can use <code>pure</code> to simply return an empty list:</p>
<pre><code class="language-haskell">combineList Nil = pure Nil
</code></pre>
<p>In fact, this is the only thing we can do!</p>
<p>If the list is non-empty, then we have a head element, which is a wrapped argument of type <code>f a</code>, and a tail of type <code>List (f a)</code>. We can recursively combine the effects in the tail, giving a result of type <code>f (List a)</code>. We can then use <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to lift the <code>Cons</code> constructor over the head and new tail:</p>
<pre><code class="language-haskell">combineList (Cons x xs) = Cons &lt;$&gt; x &lt;*&gt; combineList xs
</code></pre>
<p>Again, this was the only sensible implementation, based on the types we were given.</p>
<p>We can test this function in PSCi, using the <code>Maybe</code> type constructor as an example:</p>
<pre><code class="language-text">&gt; import Data.List
&gt; import Data.Maybe

&gt; combineList (fromFoldable [Just 1, Just 2, Just 3])
(Just (Cons 1 (Cons 2 (Cons 3 Nil))))

&gt; combineList (fromFoldable [Just 1, Nothing, Just 2])
Nothing
</code></pre>
<p>When specialized to <code>Maybe</code>, our function returns a <code>Just</code> only if every list element was <code>Just</code>, otherwise it returns <code>Nothing</code>. This is consistent with our intuition of working in a larger language supporting optional values - a list of computations which return optional results only has a result itself if every computation contained a result.</p>
<p>But the <code>combineList</code> function works for any <code>Applicative</code>! We can use it to combine computations which possibly signal an error using <code>Either err</code>, or which read from a global configuration using <code>r -&gt;</code>.</p>
<p>We will see the <code>combineList</code> function again later, when we consider <code>Traversable</code> functors.</p>
<h2 id="exercises-17"><a class="header" href="#exercises-17">Exercises</a></h2>
<ol>
<li>(Medium) Write versions of the numeric operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> which work with optional arguments (i.e. arguments wrapped in <code>Maybe</code>) and return a value wrapped in <code>Maybe</code>. Name these functions <code>addMaybe</code>, <code>subMaybe</code>, <code>mulMaybe</code>, and <code>divMaybe</code>. <em>Hint</em>: Use <code>lift2</code>.</li>
<li>(Medium) Extend the above exercise to work with all <code>Apply</code> types (not just <code>Maybe</code>). Name these new functions <code>addApply</code>, <code>subApply</code>, <code>mulApply</code>, and <code>divApply</code>.</li>
<li>(Difficult) Write a function <code>combineMaybe</code> which has type <code>forall a f. Applicative f =&gt; Maybe (f a) -&gt; f (Maybe a)</code>. This function takes an optional computation with side-effects, and returns a side-effecting computation which has an optional result.</li>
</ol>
<h2 id="applicative-validation-1"><a class="header" href="#applicative-validation-1">Applicative Validation</a></h2>
<p>The source code for this chapter defines several data types which might be used in an address book application. The details are omitted here, but the key functions which are exported by the <code>Data.AddressBook</code> module have the following types:</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address

phoneNumber :: PhoneType -&gt; String -&gt; PhoneNumber

person :: String -&gt; String -&gt; Address -&gt; Array PhoneNumber -&gt; Person
</code></pre>
<p>where <code>PhoneType</code> is defined as an algebraic data type:</p>
<pre><code class="language-haskell">data PhoneType
  = HomePhone
  | WorkPhone
  | CellPhone
  | OtherPhone
</code></pre>
<p>These functions can be used to construct a <code>Person</code> representing an address book entry. For example, the following value is defined in <code>Data.AddressBook</code>:</p>
<pre><code class="language-haskell">examplePerson :: Person
examplePerson =
  person &quot;John&quot; &quot;Smith&quot;
    (address &quot;123 Fake St.&quot; &quot;FakeTown&quot; &quot;CA&quot;)
    [ phoneNumber HomePhone &quot;555-555-5555&quot;
    , phoneNumber CellPhone &quot;555-555-0000&quot;
    ]
</code></pre>
<p>Test this value in PSCi (this result has been formatted):</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; examplePerson
{ firstName: &quot;John&quot;
, lastName: &quot;Smith&quot;
, homeAddress:
    { street: &quot;123 Fake St.&quot;
    , city: &quot;FakeTown&quot;
    , state: &quot;CA&quot;
    }
, phones:
    [ { type: HomePhone
      , number: &quot;555-555-5555&quot;
      }
    , { type: CellPhone
      , number: &quot;555-555-0000&quot;
      }
    ]
}
</code></pre>
<p>We saw in a previous section how we could use the <code>Either String</code> functor to validate a data structure of type <code>Person</code>. For example, provided functions to validate the two names in the structure, we might validate the entire data structure as follows:</p>
<pre><code class="language-haskell">nonEmpty1 :: String -&gt; Either String String
nonEmpty1 &quot;&quot;     = Left &quot;Field cannot be empty&quot;
nonEmpty1 value  = Right value

validatePerson1 :: Person -&gt; Either String Person
validatePerson1 p =
  person &lt;$&gt; nonEmpty1 p.firstName
         &lt;*&gt; nonEmpty1 p.lastName
         &lt;*&gt; pure p.homeAddress
         &lt;*&gt; pure p.phones
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePerson1Ado :: Person -&gt; Either String Person
validatePerson1Ado p = ado
  f &lt;- nonEmpty1 p.firstName
  l &lt;- nonEmpty1 p.lastName
  in person f l p.homeAddress p.phones
</code></pre>
<p>In the first two lines, we use the <code>nonEmpty1</code> function to validate a non-empty string. <code>nonEmpty1</code> returns an error indicated with the <code>Left</code> constructor if its input is empty, otherwise it returns the value wrapped with the <code>Right</code> constructor.</p>
<p>The final lines do not perform any validation but simply provide the <code>address</code> and <code>phones</code> fields to the <code>person</code> function as the remaining arguments.</p>
<p>This function can be seen to work in PSCi, but has a limitation which we have seen before:</p>
<pre><code class="language-text">&gt; validatePerson $ person &quot;&quot; &quot;&quot; (address &quot;&quot; &quot;&quot; &quot;&quot;) []
(Left &quot;Field cannot be empty&quot;)
</code></pre>
<p>The <code>Either String</code> applicative functor only provides the first error encountered. Given the input here, we would prefer to see two errors - one for the missing first name, and a second for the missing last name.</p>
<p>There is another applicative functor which is provided by the <code>validation</code> library. This functor is called <code>V</code>, and it provides the ability to return errors in any <em>semigroup</em>. For example, we can use <code>V (Array String)</code> to return an array of <code>String</code>s as errors, concatenating new errors onto the end of the array.</p>
<p>The <code>Data.AddressBook.Validation</code> module uses the <code>V (Array String)</code> applicative functor to validate the data structures in the <code>Data.AddressBook</code> module.</p>
<p>Here is an example of a validator taken from the <code>Data.AddressBook.Validation</code> module:</p>
<pre><code class="language-haskell">type Errors
  = Array String

nonEmpty :: String -&gt; String -&gt; V Errors String
nonEmpty field &quot;&quot;     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' cannot be empty&quot; ]
nonEmpty _     value  = pure value

lengthIs :: String -&gt; Int -&gt; String -&gt; V Errors String
lengthIs field len value | length value /= len =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must have length &quot; &lt;&gt; show len ]
lengthIs _     _   value = pure value

validateAddress :: Address -&gt; V Errors Address
validateAddress a =
  address &lt;$&gt; nonEmpty &quot;Street&quot;  a.street
          &lt;*&gt; nonEmpty &quot;City&quot;    a.city
          &lt;*&gt; lengthIs &quot;State&quot; 2 a.state
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validateAddressAdo :: Address -&gt; V Errors Address
validateAddressAdo a = ado
  street &lt;- nonEmpty &quot;Street&quot;  a.street
  city   &lt;- nonEmpty &quot;City&quot;    a.city
  state  &lt;- lengthIs &quot;State&quot; 2 a.state
  in address street city state
</code></pre>
<p><code>validateAddress</code> validates an <code>Address</code> structure. It checks that the <code>street</code> and <code>city</code> fields are non-empty, and checks that the string in the <code>state</code> field has length 2.</p>
<p>Notice how the <code>nonEmpty</code> and <code>lengthIs</code> validator functions both use the <code>invalid</code> function provided by the <code>Data.Validation</code> module to indicate an error. Since we are working in the <code>Array String</code> semigroup, <code>invalid</code> takes an array of strings as its argument.</p>
<p>We can try this function in PSCi:</p>
<pre><code class="language-text">&gt; import Data.AddressBook
&gt; import Data.AddressBook.Validation

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         , &quot;Field 'State' must have length 2&quot;
         ])

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;CA&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         ])
</code></pre>
<p>This time, we receive an array of all validation errors.</p>
<h2 id="regular-expression-validators"><a class="header" href="#regular-expression-validators">Regular Expression Validators</a></h2>
<p>The <code>validatePhoneNumber</code> function uses a regular expression to validate the form of its argument. The key is a <code>matches</code> validation function, which uses a <code>Regex</code> from the <code>Data.String.Regex</code> module to validate its input:</p>
<pre><code class="language-haskell">matches :: String -&gt; Regex -&gt; String -&gt; V Errors String
matches _     regex value | test regex value
                          = pure value
matches field _     _     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' did not match the required format&quot; ]
</code></pre>
<p>Again, notice how <code>pure</code> is used to indicate successful validation, and <code>invalid</code> is used to signal an array of errors.</p>
<p><code>validatePhoneNumber</code> is built from the <code>matches</code> function in the same way as before:</p>
<pre><code class="language-haskell">validatePhoneNumber :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumber pn =
  phoneNumber &lt;$&gt; pure pn.&quot;type&quot;
              &lt;*&gt; matches &quot;Number&quot; phoneNumberRegex pn.number
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePhoneNumberAdo :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumberAdo pn = ado
  tpe    &lt;- pure pn.&quot;type&quot;
  number &lt;- matches &quot;Number&quot; phoneNumberRegex pn.number
  in phoneNumber tpe number
</code></pre>
<p>Again, try running this validator against some valid and invalid inputs in PSCi:</p>
<pre><code class="language-text">&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555-555-5555&quot;
pure ({ type: HomePhone, number: &quot;555-555-5555&quot; })

&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555.555.5555&quot;
invalid ([&quot;Field 'Number' did not match the required format&quot;])
</code></pre>
<h2 id="exercises-18"><a class="header" href="#exercises-18">Exercises</a></h2>
<ol>
<li>(Easy) Write a regular expression <code>stateRegex :: Regex</code> to check that a string only contains two alphabetic characters. <em>Hint</em>: see the source code for <code>phoneNumberRegex</code>.</li>
<li>(Medium) Write a regular expression <code>nonEmptyRegex :: Regex</code> to check that a string is not entirely whitespace. <em>Hint</em>: If you need help developing this regex expression, check out <a href="https://regexr.com">RegExr</a> which has a great cheatsheet and interactive test environment.</li>
<li>(Medium) Write a function <code>validateAddressImproved</code> that is similar to <code>validateAddress</code>, but uses the above <code>stateRegex</code> to validate the <code>state</code> field and <code>nonEmptyRegex</code> to validate the <code>street</code> and <code>city</code> fields. <em>Hint</em>: see the source for <code>validatePhoneNumber</code> for an example of how to use <code>matches</code>.</li>
</ol>
<h2 id="traversable-functors"><a class="header" href="#traversable-functors">Traversable Functors</a></h2>
<p>The remaining validator is <code>validatePerson</code>, which combines the validators we have seen so far to validate an entire <code>Person</code> structure, including the following new <code>validatePhoneNumbers</code> function:</p>
<pre><code class="language-haskell">validatePhoneNumbers :: String -&gt; Array PhoneNumber -&gt; V Errors (Array PhoneNumber)
validatePhoneNumbers field []      =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must contain at least one value&quot; ]
validatePhoneNumbers _     phones  =
  traverse validatePhoneNumber phones

validatePerson :: Person -&gt; V Errors Person
validatePerson p =
  person &lt;$&gt; nonEmpty &quot;First Name&quot; p.firstName
         &lt;*&gt; nonEmpty &quot;Last Name&quot; p.lastName
         &lt;*&gt; validateAddress p.homeAddress
         &lt;*&gt; validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePersonAdo :: Person -&gt; V Errors Person
validatePersonAdo p = ado
  firstName &lt;- nonEmpty &quot;First Name&quot; p.firstName
  lastName  &lt;- nonEmpty &quot;Last Name&quot; p.lastName
  address   &lt;- validateAddress p.homeAddress
  numbers   &lt;- validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
  in person firstName lastName address numbers
</code></pre>
<p><code>validatePhoneNumbers</code> uses a new function we haven't seen before - <code>traverse</code>.</p>
<p><code>traverse</code> is defined in the <code>Data.Traversable</code> module, in the <code>Traversable</code> type class:</p>
<pre><code class="language-haskell">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p><code>Traversable</code> defines the class of <em>traversable functors</em>. The types of its functions might look a little intimidating, but <code>validatePerson</code> provides a good motivating example.</p>
<p>Every traversable functor is both a <code>Functor</code> and <code>Foldable</code> (recall that a <em>foldable functor</em> was a type constructor which supported a fold operation, reducing a structure to a single value). In addition, a traversable functor provides the ability to combine a collection of side-effects which depend on its structure.</p>
<p>This may sound complicated, but let's simplify things by specializing to the case of arrays. The array type constructor is traversable, which means that there is a function:</p>
<pre><code class="language-haskell">traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; Array a -&gt; m (Array b)
</code></pre>
<p>Intuitively, given any applicative functor <code>m</code>, and a function which takes a value of type <code>a</code> and returns a value of type <code>b</code> (with side-effects tracked by <code>m</code>), we can apply the function to each element of an array of type <code>Array a</code> to obtain a result of type <code>Array b</code> (with side-effects tracked by <code>m</code>).</p>
<p>Still not clear? Let's specialize further to the case where <code>m</code> is the <code>V Errors</code> applicative functor above. Now, we have a function of type</p>
<pre><code class="language-haskell">traverse :: forall a b. (a -&gt; V Errors b) -&gt; Array a -&gt; V Errors (Array b)
</code></pre>
<p>This type signature says that if we have a validation function <code>m</code> for a type <code>a</code>, then <code>traverse m</code> is a validation function for arrays of type <code>Array a</code>. But that's exactly what we need to be able to validate the <code>phones</code> field of the <code>Person</code> data structure! We pass <code>validatePhoneNumber</code> to <code>traverse</code> to create a validation function which validates each element successively.</p>
<p>In general, <code>traverse</code> walks over the elements of a data structure, performing computations with side-effects and accumulating a result.</p>
<p>The type signature for <code>Traversable</code>'s other function <code>sequence</code> might look more familiar:</p>
<pre><code class="language-haskell">sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p>In fact, the <code>combineList</code> function that we wrote earlier is just a special case of the <code>sequence</code> function from the <code>Traversable</code> type class. Setting <code>t</code> to be the type constructor <code>List</code>, we recover the type of the <code>combineList</code> function:</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>Traversable functors capture the idea of traversing a data structure, collecting a set of effectful computations, and combining their effects. In fact, <code>sequence</code> and <code>traverse</code> are equally important to the definition of <code>Traversable</code> - each can be implemented in terms of each other. This is left as an exercise for the interested reader.</p>
<p>The <code>Traversable</code> instance for lists given in the <code>Data.List</code> module is:</p>
<pre><code class="language-haskell">instance traversableList :: Traversable List where
-- traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; List a -&gt; m (List b)
traverse _ Nil         = pure Nil
traverse f (Cons x xs) = Cons &lt;$&gt; f x &lt;*&gt; traverse f xs
</code></pre>
<p>(The actual definition was later modified to improve stack safety. You can read more about that change <a href="https://github.com/purescript/purescript-lists/pull/87">here</a>.)</p>
<p>In the case of an empty list, we can simply return an empty list using <code>pure</code>. If the list is non-empty, we can use the function <code>f</code> to create a computation of type <code>f b</code> from the head element. We can also call <code>traverse</code> recursively on the tail. Finally, we can lift the <code>Cons</code> constructor over the applicative functor <code>m</code> to combine the two results.</p>
<p>But there are more examples of traversable functors than just arrays and lists. The <code>Maybe</code> type constructor we saw earlier also has an instance for <code>Traversable</code>. We can try it in PSCi:</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; import Data.Traversable
&gt; import Data.AddressBook.Validation

&gt; traverse (nonEmpty &quot;Example&quot;) Nothing
pure (Nothing)

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;&quot;)
invalid ([&quot;Field 'Example' cannot be empty&quot;])

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;Testing&quot;)
pure ((Just &quot;Testing&quot;))
</code></pre>
<p>These examples show that traversing the <code>Nothing</code> value returns <code>Nothing</code> with no validation, and traversing <code>Just x</code> uses the validation function to validate <code>x</code>. That is, <code>traverse</code> takes a validation function for type <code>a</code> and returns a validation function for <code>Maybe a</code>, i.e. a validation function for optional values of type <code>a</code>.</p>
<p>Other traversable functors include <code>Array</code>, and <code>Tuple a</code> and <code>Either a</code> for any type <code>a</code>. Generally, most &quot;container&quot; data type constructors have <code>Traversable</code> instances. As an example, the exercises will include writing a <code>Traversable</code> instance for a type of binary trees.</p>
<h2 id="exercises-19"><a class="header" href="#exercises-19">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write <code>Eq</code> and <code>Show</code> instances for the following binary tree data structure:</p>
<pre><code class="language-haskell">data Tree a = Leaf | Branch (Tree a) a (Tree a)
</code></pre>
<p>Recall from the previous chapter that you may either write these instances manually or let the compiler derive them for you.</p>
<p>There are many &quot;correct&quot; formatting options for <code>Show</code> output. The test for this exercise expects the following whitespace style. This happens to match the default formatting of generic show, so you only need to make note of this if you're planning on writing this instance manually.</p>
<pre><code class="language-haskell">(Branch (Branch Leaf 8 Leaf) 42 Leaf)
</code></pre>
</li>
<li>
<p>(Medium) Write a <code>Traversable</code> instance for <code>Tree a</code>, which combines side-effects from left-to-right. <em>Hint</em>: There are some additional instance dependencies that need to be defined for <code>Traversable</code>.</p>
</li>
<li>
<p>(Medium) Write a function <code>traversePreOrder :: forall a m b. Applicative m =&gt; (a -&gt; m b) -&gt; Tree a -&gt; m (Tree b)</code> that performs a pre-order traversal of the tree. This means the order of effect execution is root-left-right, instead of left-root-right as was done for the previous in-order traverse exercise. <em>Hint</em>: No additional instances need to be defined, and you don't need to call any of the the functions defined earlier. Applicative do notation (<code>ado</code>) is the easiest way to write this function.</p>
</li>
<li>
<p>(Medium) Write a function <code>traversePostOrder</code> that performs a post-order traversal of the tree where effects are executed left-right-root.</p>
</li>
<li>
<p>(Medium) Create a new version of the <code>Person</code> type where the <code>homeAddress</code> field is optional (using <code>Maybe</code>). Then write a new version of <code>validatePerson</code> (renamed as <code>validatePersonOptionalAddress</code>) to validate this new <code>Person</code>. <em>Hint</em>: Use <code>traverse</code> to validate a field of type <code>Maybe a</code>.</p>
</li>
<li>
<p>(Difficult) Write a function <code>sequenceUsingTraverse</code> which behaves like <code>sequence</code>, but is written in terms of <code>traverse</code>.</p>
</li>
<li>
<p>(Difficult) Write a function <code>traverseUsingSequence</code> which behaves like <code>traverse</code>, but is written in terms of <code>sequence</code>.</p>
</li>
</ol>
<h2 id="applicative-functors-for-parallelism"><a class="header" href="#applicative-functors-for-parallelism">Applicative Functors for Parallelism</a></h2>
<p>In the discussion above, I chose the word &quot;combine&quot; to describe how applicative functors &quot;combine side-effects&quot;. However, in all the examples given, it would be equally valid to say that applicative functors allow us to &quot;sequence&quot; effects. This would be consistent with the intuition that traversable functors provide a <code>sequence</code> function to combine effects in sequence based on a data structure.</p>
<p>However, in general, applicative functors are more general than this. The applicative functor laws do not impose any ordering on the side-effects that their computations perform. In fact, it would be valid for an applicative functor to perform its side-effects in parallel.</p>
<p>For example, the <code>V</code> validation functor returned an <em>array</em> of errors, but it would work just as well if we picked the <code>Set</code> semigroup, in which case it would not matter what order we ran the various validators. We could even run them in parallel over the data structure!</p>
<p>As a second example, the <code>parallel</code> package provides a type class <code>Parallel</code> which supports <em>parallel computations</em>. <code>Parallel</code> provides a function <code>parallel</code> which uses some <code>Applicative</code> functor to compute the result of its input computation <em>in parallel</em>:</p>
<pre><code class="language-haskell">f &lt;$&gt; parallel computation1
  &lt;*&gt; parallel computation2
</code></pre>
<p>This computation would start computing values asynchronously using <code>computation1</code> and <code>computation2</code>. When both results have been computed, they would be combined into a single result using the function <code>f</code>.</p>
<p>We will see this idea in more detail when we apply applicative functors to the problem of <em>callback hell</em> later in the book.</p>
<p>Applicative functors are a natural way to capture side-effects which can be combined in parallel.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>In this chapter, we covered a lot of new ideas:</p>
<ul>
<li>We introduced the concept of an <em>applicative functor</em> which generalizes the idea of function application to type constructors which capture some notion of side-effect.</li>
<li>We saw how applicative functors gave a solution to the problem of validating data structures, and how by switching the applicative functor we could change from reporting a single error to reporting all errors across a data structure.</li>
<li>We met the <code>Traversable</code> type class, which encapsulates the idea of a <em>traversable functor</em>, or a container whose elements can be used to combine values with side-effects.</li>
</ul>
<p>Applicative functors are an interesting abstraction which provide neat solutions to a number of problems. We will see them a few more times throughout the book. In this case, the validation applicative functor provided a way to write validators in a declarative style, allowing us to define <em>what</em> our validators should validate and not <em>how</em> they should perform that validation. In general, we will see that applicative functors are a useful tool for the design of <em>domain specific languages</em>.</p>
<p>In the next chapter, we will see a related idea, the class of <em>monads</em>, and extend our address book example to run in the browser!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-effect-monad"><a class="header" href="#the-effect-monad">The Effect Monad</a></h1>
<h2 id="chapter-goals-6"><a class="header" href="#chapter-goals-6">Chapter Goals</a></h2>
<p>In the last chapter, we introduced applicative functors, an abstraction which we used to deal with <em>side-effects</em>: optional values, error messages and validation. This chapter will introduce another abstraction for dealing with side-effects in a more expressive way: <em>monads</em>.</p>
<p>The goal of this chapter is to explain why monads are a useful abstraction, and their connection with <em>do notation</em>.</p>
<h2 id="project-setup-5"><a class="header" href="#project-setup-5">Project Setup</a></h2>
<p>The project adds the following dependencies:</p>
<ul>
<li><code>effect</code> - defines the <code>Effect</code> monad, the subject of the second half of the chapter. This dependency is often listed in every starter project (it's been a dependency of every chapter so far), so you'll rarely have to explicitly install it.</li>
<li><code>react-basic-hooks</code> - a web framework that we will use for our Address Book app.</li>
</ul>
<h2 id="monads-and-do-notation"><a class="header" href="#monads-and-do-notation">Monads and Do Notation</a></h2>
<p>Do notation was first introduced when we covered <em>array comprehensions</em>. Array comprehensions provide syntactic sugar for the <code>concatMap</code> function from the <code>Data.Array</code> module.</p>
<p>Consider the following example. Suppose we throw two dice and want to count the number of ways in which we can score a total of <code>n</code>. We could do this using the following non-deterministic algorithm:</p>
<ul>
<li><em>Choose</em> the value <code>x</code> of the first throw.</li>
<li><em>Choose</em> the value <code>y</code> of the second throw.</li>
<li>If the sum of <code>x</code> and <code>y</code> is <code>n</code> then return the pair <code>[x, y]</code>, else fail.</li>
</ul>
<p>Array comprehensions allow us to write this non-deterministic algorithm in a natural way:</p>
<pre><code class="language-hs">import Prelude

import Control.Plus (empty)
import Data.Array ((..))

countThrows :: Int -&gt; Array (Array Int)
countThrows n = do
  x &lt;- 1 .. 6
  y &lt;- 1 .. 6
  if x + y == n
    then pure [ x, y ]
    else empty
</code></pre>
<p>We can see that this function works in PSCi:</p>
<pre><code class="language-text">&gt; import Test.Examples

&gt; countThrows 10
[[4,6],[5,5],[6,4]]

&gt; countThrows 12
[[6,6]]
</code></pre>
<p>In the last chapter, we formed an intuition for the <code>Maybe</code> applicative functor, embedding PureScript functions into a larger programming language supporting <em>optional values</em>. In the same way, we can form an intuition for the <em>array monad</em>, embedding PureScript functions into a larger programming language supporting <em>non-deterministic choice</em>.</p>
<p>In general, a <em>monad</em> for some type constructor <code>m</code> provides a way to use do notation with values of type <code>m a</code>. Note that in the array comprehension above, every line contains a computation of type <code>Array a</code> for some type <code>a</code>. In general, every line of a do notation block will contain a computation of type <code>m a</code> for some type <code>a</code> and our monad <code>m</code>. The monad <code>m</code> must be the same on every line (i.e. we fix the side-effect), but the types <code>a</code> can differ (i.e. individual computations can have different result types).</p>
<p>Here is another example of do notation, this time applied to the type constructor <code>Maybe</code>. Suppose we have some type <code>XML</code> representing XML nodes, and a function</p>
<pre><code class="language-hs">child :: XML -&gt; String -&gt; Maybe XML
</code></pre>
<p>which looks for a child element of a node, and returns <code>Nothing</code> if no such element exists.</p>
<p>In this case, we can look for a deeply-nested element by using do notation. Suppose we wanted to read a user's city from a user profile which had been encoded as an XML document:</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p>The <code>userCity</code> function looks for a child element <code>profile</code>, an element <code>address</code> inside the <code>profile</code> element, and finally an element <code>city</code> inside the <code>address</code> element. If any of these elements are missing, the return value will be <code>Nothing</code>. Otherwise, the return value is constructed using <code>Just</code> from the <code>city</code> node.</p>
<p>Remember, the <code>pure</code> function in the last line is defined for every <code>Applicative</code> functor. Since <code>pure</code> is defined as <code>Just</code> for the <code>Maybe</code> applicative functor, it would be equally valid to change the last line to <code>Just city</code>.</p>
<h2 id="the-monad-type-class"><a class="header" href="#the-monad-type-class">The Monad Type Class</a></h2>
<p>The <code>Monad</code> type class is defined as follows:</p>
<pre><code class="language-hs">class Apply m &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

class (Applicative m, Bind m) &lt;= Monad m
</code></pre>
<p>The key function here is <code>bind</code>, defined in the <code>Bind</code> type class. Just like for the <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> operators in the <code>Functor</code> and <code>Apply</code> type classes, the Prelude defines an infix alias <code>&gt;&gt;=</code> for the <code>bind</code> function.</p>
<p>The <code>Monad</code> type class extends <code>Bind</code> with the operations of the <code>Applicative</code> type class that we have already seen.</p>
<p>It will be useful to see some examples of the <code>Bind</code> type class. A sensible definition for <code>Bind</code> on arrays can be given as follows:</p>
<pre><code class="language-hs">instance bindArray :: Bind Array where
  bind xs f = concatMap f xs
</code></pre>
<p>This explains the connection between array comprehensions and the <code>concatMap</code> function that has been alluded to before.</p>
<p>Here is an implementation of <code>Bind</code> for the <code>Maybe</code> type constructor:</p>
<pre><code class="language-hs">instance bindMaybe :: Bind Maybe where
  bind Nothing  _ = Nothing
  bind (Just a) f = f a
</code></pre>
<p>This definition confirms the intuition that missing values are propagated through a do notation block.</p>
<p>Let's see how the <code>Bind</code> type class is related to do notation. Consider a simple do notation block which starts by binding a value from the result of some computation:</p>
<pre><code class="language-hs">do value &lt;- someComputation
   whatToDoNext
</code></pre>
<p>Every time the PureScript compiler sees this pattern, it replaces the code with this:</p>
<pre><code class="language-hs">bind someComputation \value -&gt; whatToDoNext
</code></pre>
<p>or, written infix:</p>
<pre><code class="language-hs">someComputation &gt;&gt;= \value -&gt; whatToDoNext
</code></pre>
<p>The computation <code>whatToDoNext</code> is allowed to depend on <code>value</code>.</p>
<p>If there are multiple binds involved, this rule is applied multiple times, starting from the top. For example, the <code>userCity</code> example that we saw earlier gets desugared as follows:</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root =
  child root &quot;profile&quot; &gt;&gt;= \prof -&gt;
    child prof &quot;address&quot; &gt;&gt;= \addr -&gt;
      child addr &quot;city&quot; &gt;&gt;= \city -&gt;
        pure city
</code></pre>
<p>It is worth noting that code expressed using do notation is often much clearer than the equivalent code using the <code>&gt;&gt;=</code> operator. However, writing binds explicitly using <code>&gt;&gt;=</code> can often lead to opportunities to write code in <em>point-free</em> form - but the usual warnings about readability apply.</p>
<h2 id="monad-laws"><a class="header" href="#monad-laws">Monad Laws</a></h2>
<p>The <code>Monad</code> type class comes equipped with three laws, called the <em>monad laws</em>. These tell us what we can expect from sensible implementations of the <code>Monad</code> type class.</p>
<p>It is simplest to explain these laws using do notation.</p>
<h3 id="identity-laws"><a class="header" href="#identity-laws">Identity Laws</a></h3>
<p>The <em>right-identity</em> law is the simplest of the three laws. It tells us that we can eliminate a call to <code>pure</code> if it is the last expression in a do notation block:</p>
<pre><code class="language-hs">do
  x &lt;- expr
  pure x
</code></pre>
<p>The right-identity law says that this is equivalent to just <code>expr</code>.</p>
<p>The <em>left-identity</em> law states that we can eliminate a call to <code>pure</code> if it is the first expression in a do notation block:</p>
<pre><code class="language-hs">do
  x &lt;- pure y
  next
</code></pre>
<p>This code is equivalent to <code>next</code>, after the name <code>x</code> has been replaced with the expression <code>y</code>.</p>
<p>The last law is the <em>associativity law</em>. It tells us how to deal with nested do notation blocks. It states that the following piece of code:</p>
<pre><code class="language-hs">c1 = do
  y &lt;- do
    x &lt;- m1
    m2
  m3
</code></pre>
<p>is equivalent to this code:</p>
<pre><code class="language-hs">c2 = do
  x &lt;- m1
  y &lt;- m2
  m3
</code></pre>
<p>Each of these computations involves three monadic expression <code>m1</code>, <code>m2</code> and <code>m3</code>. In each case, the result of <code>m1</code> is eventually bound to the name <code>x</code>, and the result of <code>m2</code> is bound to the name <code>y</code>.</p>
<p>In <code>c1</code>, the two expressions <code>m1</code> and <code>m2</code> are grouped into their own do notation block.</p>
<p>In <code>c2</code>, all three expressions <code>m1</code>, <code>m2</code> and <code>m3</code> appear in the same do notation block.</p>
<p>The associativity law tells us that it is safe to simplify nested do notation blocks in this way.</p>
<p><em>Note</em> that by the definition of how do notation gets desugared into calls to <code>bind</code>, both of <code>c1</code> and <code>c2</code> are also equivalent to this code:</p>
<pre><code class="language-hs">c3 = do
  x &lt;- m1
  do
    y &lt;- m2
    m3
</code></pre>
<h2 id="folding-with-monads"><a class="header" href="#folding-with-monads">Folding With Monads</a></h2>
<p>As an example of working with monads abstractly, this section will present a function which works with any type constructor in the <code>Monad</code> type class. This should serve to solidify the intuition that monadic code corresponds to programming &quot;in a larger language&quot; with side-effects, and also illustrate the generality which programming with monads brings.</p>
<p>The function we will write is called <code>foldM</code>. It generalizes the <code>foldl</code> function that we met earlier to a monadic context. Here is its type signature:</p>
<pre><code class="language-hs">foldM :: forall m a b. Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; List b -&gt; m a
foldl :: forall   a b.            (a -&gt; b -&gt;   a) -&gt; a -&gt; List b -&gt;   a
</code></pre>
<p>Notice that this is the same as the type of <code>foldl</code>, except for the appearance of the monad <code>m</code>.</p>
<p>Intuitively, <code>foldM</code> performs a fold over a list in some context supporting some set of side-effects.</p>
<p>For example, if we picked <code>m</code> to be <code>Maybe</code>, then our fold would be allowed to fail by returning <code>Nothing</code> at any stage - every step returns an optional result, and the result of the fold is therefore also optional.</p>
<p>If we picked <code>m</code> to be the <code>Array</code> type constructor, then every step of the fold would be allowed to return zero or more results, and the fold would proceed to the next step independently for each result. At the end, the set of results would consist of all folds over all possible paths. This corresponds to a traversal of a graph!</p>
<p>To write <code>foldM</code>, we can simply break the input list into cases.</p>
<p>If the list is empty, then to produce the result of type <code>a</code>, we only have one option: we have to return the second argument:</p>
<pre><code class="language-hs">foldM _ a Nil = pure a
</code></pre>
<p>Note that we have to use <code>pure</code> to lift <code>a</code> into the monad <code>m</code>.</p>
<p>What if the list is non-empty? In that case, we have a value of type <code>a</code>, a value of type <code>b</code>, and a function of type <code>a -&gt; b -&gt; m a</code>. If we apply the function, we obtain a monadic result of type <code>m a</code>. We can bind the result of this computation with a backwards arrow <code>&lt;-</code>.</p>
<p>It only remains to recurse on the tail of the list. The implementation is simple:</p>
<pre><code class="language-hs">foldM f a (b : bs) = do
  a' &lt;- f a b
  foldM f a' bs
</code></pre>
<p>Note that this implementation is almost identical to that of <code>foldl</code> on lists, with the exception of do notation.</p>
<p>We can define and test this function in PSCi. Here is an example - suppose we defined a &quot;safe division&quot; function on integers, which tested for division by zero and used the <code>Maybe</code> type constructor to indicate failure:</p>
<pre><code class="language-hs">safeDivide :: Int -&gt; Int -&gt; Maybe Int
safeDivide _ 0 = Nothing
safeDivide a b = Just (a / b)
</code></pre>
<p>Then we can use <code>foldM</code> to express iterated safe division:</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.List (fromFoldable)

&gt; foldM safeDivide 100 (fromFoldable [5, 2, 2])
(Just 5)

&gt; foldM safeDivide 100 (fromFoldable [2, 0, 4])
Nothing
</code></pre>
<p>The <code>foldM safeDivide</code> function returns <code>Nothing</code> if a division by zero was attempted at any point. Otherwise it returns the result of repeatedly dividing the accumulator, wrapped in the <code>Just</code> constructor.</p>
<h2 id="monads-and-applicatives"><a class="header" href="#monads-and-applicatives">Monads and Applicatives</a></h2>
<p>Every instance of the <code>Monad</code> type class is also an instance of the <code>Apply</code> type class, by virtue of the superclass relationship between the two classes.</p>
<p>However, there is also an implementation of the <code>Apply</code> type class which comes &quot;for free&quot; for any instance of <code>Monad</code>, given by the <code>ap</code> function:</p>
<pre><code class="language-hs">ap :: forall m a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
ap mf ma = do
  f &lt;- mf
  a &lt;- ma
  pure (f a)
</code></pre>
<p>If <code>m</code> is a law-abiding member of the <code>Monad</code> type class, then there is a valid <code>Apply</code> instance for <code>m</code> given by <code>ap</code>.</p>
<p>The interested reader can check that <code>ap</code> agrees with <code>apply</code> for the monads we have already encountered: <code>Array</code>, <code>Maybe</code> and <code>Either e</code>.</p>
<p>If every monad is also an applicative functor, then we should be able to apply our intuition for applicative functors to every monad. In particular, we can reasonably expect a monad to correspond, in some sense, to programming &quot;in a larger language&quot; augmented with some set of additional side-effects. We should be able to lift functions of arbitrary arities, using <code>map</code> and <code>apply</code>, into this new language.</p>
<p>But monads allow us to do more than we could do with just applicative functors, and the key difference is highlighted by the syntax of do notation. Consider the <code>userCity</code> example again, in which we looked for a user's city in an XML document which encoded their user profile:</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p>Do notation allows the second computation to depend on the result <code>prof</code> of the first, and the third computation to depend on the result <code>addr</code> of the second, and so on. This dependence on previous values is not possible using only the interface of the <code>Applicative</code> type class.</p>
<p>Try writing <code>userCity</code> using only <code>pure</code> and <code>apply</code>: you will see that it is impossible. Applicative functors only allow us to lift function arguments which are independent of each other, but monads allow us to write computations which involve more interesting data dependencies.</p>
<p>In the last chapter, we saw that the <code>Applicative</code> type class can be used to express parallelism. This was precisely because the function arguments being lifted were independent of one another. Since the <code>Monad</code> type class allows computations to depend on the results of previous computations, the same does not apply - a monad has to combine its side-effects in sequence.</p>
<h2 id="exercises-20"><a class="header" href="#exercises-20">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a function <code>third</code> which returns the third element of an array with three or more elements. Your function should return an appropriate <code>Maybe</code> type. <em>Hint:</em> Look up the types of the <code>head</code> and <code>tail</code> functions from the <code>Data.Array</code> module in the <code>arrays</code> package. Use do notation with the <code>Maybe</code> monad to combine these functions.</p>
</li>
<li>
<p>(Medium) Write a function <code>possibleSums</code> which uses <code>foldM</code> to determine all possible totals that could be made using a set of coins. The coins will be specified as an array which contains the value of each coin. Your function should have the following result:</p>
<pre><code class="language-text">&gt; possibleSums []
[0]

&gt; possibleSums [1, 2, 10]
[0,1,2,3,10,11,12,13]
</code></pre>
<p><em>Hint</em>: This function can be written as a one-liner using <code>foldM</code>. You might want to use the <code>nub</code> and <code>sort</code> functions to remove duplicates and sort the result respectively.</p>
</li>
<li>
<p>(Medium) Confirm that the <code>ap</code> function and the <code>apply</code> operator agree for the <code>Maybe</code> monad. <em>Note:</em> There are no tests for this exercise.</p>
</li>
<li>
<p>(Medium) Verify that the monad laws hold for the <code>Monad</code> instance for the <code>Maybe</code> type, as defined in the <code>maybe</code> package. <em>Note:</em> There are no tests for this exercise.</p>
</li>
<li>
<p>(Medium) Write a function <code>filterM</code> which generalizes the <code>filter</code> function on lists. Your function should have the following type signature:</p>
<pre><code class="language-hs">filterM :: forall m a. Monad m =&gt; (a -&gt; m Boolean) -&gt; List a -&gt; m (List a)
</code></pre>
</li>
<li>
<p>(Difficult) Every monad has a default <code>Functor</code> instance given by:</p>
<pre><code class="language-hs">map f a = do
  x &lt;- a
  pure (f x)
</code></pre>
<p>Use the monad laws to prove that for any monad, the following holds:</p>
<pre><code class="language-hs">lift2 f (pure a) (pure b) = pure (f a b)
</code></pre>
<p>where the <code>Apply</code> instance uses the <code>ap</code> function defined above. Recall that <code>lift2</code> was defined as follows:</p>
<pre><code class="language-hs">lift2 :: forall f a b c. Apply f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
lift2 f a b = f &lt;$&gt; a &lt;*&gt; b
</code></pre>
<p><em>Note:</em> There are no tests for this exercise.</p>
</li>
</ol>
<h2 id="native-effects"><a class="header" href="#native-effects">Native Effects</a></h2>
<p>We will now look at one particular monad which is of central importance in PureScript - the <code>Effect</code> monad.</p>
<p>The <code>Effect</code> monad is defined in the <code>Effect</code> module. It is used to manage so-called <em>native</em> side-effects. If you are familiar with Haskell, it is the equivalent of the <code>IO</code> monad.</p>
<p>What are native side-effects? They are the side-effects which distinguish JavaScript expressions from idiomatic PureScript expressions, which typically are free from side-effects. Some examples of native effects are:</p>
<ul>
<li>Console IO</li>
<li>Random number generation</li>
<li>Exceptions</li>
<li>Reading/writing mutable state</li>
</ul>
<p>And in the browser:</p>
<ul>
<li>DOM manipulation</li>
<li>XMLHttpRequest / AJAX calls</li>
<li>Interacting with a websocket</li>
<li>Writing/reading to/from local storage</li>
</ul>
<p>We have already seen plenty of examples of &quot;non-native&quot; side-effects:</p>
<ul>
<li>Optional values, as represented by the <code>Maybe</code> data type</li>
<li>Errors, as represented by the <code>Either</code> data type</li>
<li>Multi-functions, as represented by arrays or lists</li>
</ul>
<p>Note that the distinction is subtle. It is true, for example, that an error message is a possible side-effect of a JavaScript expression, in the form of an exception. In that sense, exceptions do represent native side-effects, and it is possible to represent them using <code>Effect</code>. However, error messages implemented using <code>Either</code> are not a side-effect of the JavaScript runtime, and so it is not appropriate to implement error messages in that style using <code>Effect</code>. So it is not the effect itself which is native, but rather how it is implemented at runtime.</p>
<h2 id="side-effects-and-purity"><a class="header" href="#side-effects-and-purity">Side-Effects and Purity</a></h2>
<p>In a pure language like PureScript, one question which presents itself is: without side-effects, how can one write useful real-world code?</p>
<p>The answer is that PureScript does not aim to eliminate side-effects. It aims to represent side-effects in such a way that pure computations can be distinguished from computations with side-effects in the type system. In this sense, the language is still pure.</p>
<p>Values with side-effects have different types from pure values. As such, it is not possible to pass a side-effecting argument to a function, for example, and have side-effects performed unexpectedly.</p>
<p>The only way in which side-effects managed by the <code>Effect</code> monad will be presented is to run a computation of type <code>Effect a</code> from JavaScript.</p>
<p>The Spago build tool (and other tools) provide a shortcut, by generating additional JavaScript to invoke the <code>main</code> computation when the application starts. <code>main</code> is required to be a computation in the <code>Effect</code> monad.</p>
<h2 id="the-effect-monad-1"><a class="header" href="#the-effect-monad-1">The Effect Monad</a></h2>
<p>The <code>Effect</code> monad provides a well-typed API for computations with side-effects, while at the same time generating efficient JavaScript.</p>
<p>Let's take a closer look at the return type of the familiar <code>log</code> function. <code>Effect</code> indicates that this function produces a native effect, console IO in this case.
<code>Unit</code> indicates that no <em>meaningful</em> data is returned. You can think of <code>Unit</code> as being analogous to the <code>void</code> keyword in other languages, such as C, Java, etc.</p>
<pre><code class="language-hs">log :: String -&gt; Effect Unit
</code></pre>
<blockquote>
<p><em>Aside:</em> You may encounter IDE suggestions for the more general (and more elaborately typed) <code>log</code> function from <code>Effect.Class.Console</code>. This is interchangeable with the one from <code>Effect.Console</code> when dealing with the basic <code>Effect</code> monad. Reasons for the more general version will become clearer after reading about &quot;Monad Transformers&quot; in the &quot;Monadic Adventures&quot; chapter. For the curious (and impatient), this works because there's a <code>MonadEffect</code> instance for <code>Effect</code>.</p>
<pre><code class="language-hs">log :: forall m. MonadEffect m =&gt; String -&gt; m Unit
</code></pre>
</blockquote>
<p>Now let's consider an <code>Effect</code> that returns meaningful data. The <code>random</code> function from <code>Effect.Random</code> produces a random <code>Number</code>.</p>
<pre><code class="language-hs">random :: Effect Number
</code></pre>
<p>Here's a full example program (found in <code>test/Random.purs</code> of this chapter's exercises folder).</p>
<pre><code class="language-hs">module Test.Random where

import Prelude
import Effect (Effect)
import Effect.Random (random)
import Effect.Console (logShow)

main :: Effect Unit
main = do
  n &lt;- random
  logShow n
</code></pre>
<p>Because <code>Effect</code> is a monad, we use do notation to <em>unwrap</em> the data it contains before passing this data on to the effectful <code>logShow</code> function. As a refresher, here's the equivalent code written using the <code>bind</code> operator:</p>
<pre><code class="language-hs">main :: Effect Unit
main = random &gt;&gt;= logShow
</code></pre>
<p>Try running this yourself with:</p>
<pre><code class="language-shell">spago run --main Test.Random
</code></pre>
<p>You should see a randomly chosen number between <code>0.0</code> and <code>1.0</code> printed to the console.</p>
<blockquote>
<p><em>Aside:</em> <code>spago run</code> defaults to searching in the <code>Main</code> module for a <code>main</code> function. You may also specify an alternate module as an entry point with the <code>--main</code> flag, as is done in the above example. Just be sure that this alternate module also contains a <code>main</code> function.</p>
</blockquote>
<p>Note that it's also possible to generate &quot;random&quot; (technically pseudorandom) data without resorting to impure effectful code. We'll cover these techniques in the &quot;Generative Testing&quot; chapter.</p>
<p>As mentioned previously, the <code>Effect</code> monad is of central importance to PureScript. The reason why it's central is because it is the conventional way to interoperate with PureScript's <code>Foreign Function Interface</code>, which provides the mechanism to execute a program and perform side effects. While it's desireable to avoid using the <code>Foreign Function Interface</code>, it's fairly critical to understand how it works and how to use it, so I recommend reading that chapter before doing any serious PureScript work. That said, the <code>Effect</code> monad is fairly simple. It has a few helper functions, but aside from that it doesn't do much except encapsulate side effects.</p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>Let's examine a function from the <code>node-fs</code> package that involves two <em>native</em> side effects: reading mutable state, and exceptions:</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; String -&gt; Effect String
</code></pre>
<p>If we attempt to read a file that does not exist:</p>
<pre><code class="language-hs">import Node.Encoding (Encoding(..))
import Node.FS.Sync (readTextFile)

main :: Effect Unit
main = do
  lines &lt;- readTextFile UTF8 &quot;iDoNotExist.md&quot;
  log lines
</code></pre>
<p>We encounter the following exception:</p>
<pre><code class="language-text">    throw err;
    ^
Error: ENOENT: no such file or directory, open 'iDoNotExist.md'
...
  errno: -2,
  syscall: 'open',
  code: 'ENOENT',
  path: 'iDoNotExist.md'
</code></pre>
<p>To manage this exception gracefully, we can wrap the potentially problematic code in <code>try</code> to handle either outcome:</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  result &lt;- try $ readTextFile UTF8 &quot;iDoNotExist.md&quot;
  case result of
    Right lines -&gt; log $ &quot;Contents: \n&quot; &lt;&gt; lines
    Left  error -&gt; log $ &quot;Couldn't open file. Error was: &quot; &lt;&gt; message error
</code></pre>
<p><code>try</code> runs an <code>Effect</code> and returns eventual exceptions as a <code>Left</code> value. If the computation succeeds, the result gets wrapped in a <code>Right</code>:</p>
<pre><code class="language-hs">try :: forall a. Effect a -&gt; Effect (Either Error a)
</code></pre>
<p>We can also generate our own exceptions. Here is an alternative implementation of <code>Data.List.head</code> which throws an exception if the list is empty, rather than returning a <code>Maybe</code> value of <code>Nothing</code>.</p>
<pre><code class="language-hs">exceptionHead :: List Int -&gt; Effect Int
exceptionHead l = case l of
  x : _ -&gt; pure x
  Nil -&gt; throwException $ error &quot;empty list&quot;
</code></pre>
<p>Note that the <code>exceptionHead</code> function is a somewhat impractical example, as it is best to avoid generating exceptions in PureScript code and instead use non-native effects such as <code>Either</code> and <code>Maybe</code> to manage errors and missing values.</p>
<h2 id="mutable-state"><a class="header" href="#mutable-state">Mutable State</a></h2>
<p>There is another effect defined in the core libraries: the <code>ST</code> effect.</p>
<p>The <code>ST</code> effect is used to manipulate mutable state. As pure functional programmers, we know that shared mutable state can be problematic. However, the <code>ST</code> effect uses the type system to restrict sharing in such a way that only safe <em>local</em> mutation is allowed.</p>
<p>The <code>ST</code> effect is defined in the <code>Control.Monad.ST</code> module. To see how it works, we need to look at the types of its actions:</p>
<pre><code class="language-hs">new :: forall a r. a -&gt; ST r (STRef r a)

read :: forall a r. STRef r a -&gt; ST r a

write :: forall a r. a -&gt; STRef r a -&gt; ST r a

modify :: forall r a. (a -&gt; a) -&gt; STRef r a -&gt; ST r a
</code></pre>
<p><code>new</code> is used to create a new mutable reference cell of type <code>STRef r a</code>, which can be read using the <code>read</code> action, and modified using the <code>write</code> and <code>modify</code> actions. The type <code>a</code> is the type of the value stored in the cell, and the type <code>r</code> is used to indicate a <em>memory region</em> (or <em>heap</em>) in the type system.</p>
<p>Here is an example. Suppose we want to simulate the movement of a particle falling under gravity by iterating a simple update function over a large number of small time steps.</p>
<p>We can do this by creating a mutable reference cell to hold the position and velocity of the particle, and then using a <code>for</code> loop to update the value stored in that cell:</p>
<pre><code class="language-hs">import Prelude

import Control.Monad.ST.Ref (modify, new, read)
import Control.Monad.ST (ST, for, run)

simulate :: forall r. Number -&gt; Number -&gt; Int -&gt; ST r Number
simulate x0 v0 time = do
  ref &lt;- new { x: x0, v: v0 }
  for 0 (time * 1000) \_ -&gt;
    modify
      ( \o -&gt;
          { v: o.v - 9.81 * 0.001
          , x: o.x + o.v * 0.001
          }
      )
      ref
  final &lt;- read ref
  pure final.x
</code></pre>
<p>At the end of the computation, we read the final value of the reference cell, and return the position of the particle.</p>
<p>Note that even though this function uses mutable state, it is still a pure function, so long as the reference cell <code>ref</code> is not allowed to be used by other parts of the program. We will see that this is exactly what the <code>ST</code> effect disallows.</p>
<p>To run a computation with the <code>ST</code> effect, we have to use the <code>run</code> function:</p>
<pre><code class="language-hs">run :: forall a. (forall r. ST r a) -&gt; a
</code></pre>
<p>The thing to notice here is that the region type <code>r</code> is quantified <em>inside the parentheses</em> on the left of the function arrow. That means that whatever action we pass to <code>run</code> has to work with <em>any region</em> <code>r</code> whatsoever.</p>
<p>However, once a reference cell has been created by <code>new</code>, its region type is already fixed, so it would be a type error to try to use the reference cell outside the code delimited by <code>run</code>.  This is what allows <code>run</code> to safely remove the <code>ST</code> effect, and turn <code>simulate</code> into a pure function!</p>
<pre><code class="language-hs">simulate' :: Number -&gt; Number -&gt; Int -&gt; Number
simulate' x0 v0 time = run (simulate x0 v0 time)
</code></pre>
<p>You can even try running this function in PSCi:</p>
<pre><code class="language-text">&gt; import Main

&gt; simulate' 100.0 0.0 0
100.00

&gt; simulate' 100.0 0.0 1
95.10

&gt; simulate' 100.0 0.0 2
80.39

&gt; simulate' 100.0 0.0 3
55.87

&gt; simulate' 100.0 0.0 4
21.54
</code></pre>
<p>In fact, if we inline the definition of <code>simulate</code> at the call to <code>run</code>, as follows:</p>
<pre><code class="language-hs">simulate :: Number -&gt; Number -&gt; Int -&gt; Number
simulate x0 v0 time =
  run do
    ref &lt;- new { x: x0, v: v0 }
    for 0 (time * 1000) \_ -&gt;
      modify
        ( \o -&gt;
            { v: o.v - 9.81 * 0.001
            , x: o.x + o.v * 0.001
            }
        )
        ref
    final &lt;- read ref
    pure final.x
</code></pre>
<p>then the compiler will notice that the reference cell is not allowed to escape its scope, and can safely turn <code>ref</code> into a <code>var</code>. Here is the generated JavaScript for <code>simulate</code> inlined with <code>run</code>:</p>
<pre><code class="language-javascript">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return (function __do() {

        var ref = { value: { x: x0, v: v0 } };

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        return ref.value.x;

      })();
    };
  };
};
</code></pre>
<p>Note that this resulting JavaScript is not as optimal as it could be. See <a href="https://github.com/purescript-contrib/purescript-book/issues/121">this issue</a> for more details. The above snippet should be updated once that issue is resolved.</p>
<p>For comparison, this is the generated JavaScript of the non-inlined form:</p>
<pre><code class="language-js">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return function __do() {

        var ref = Control_Monad_ST_Internal[&quot;new&quot;]({ x: x0, v: v0 })();

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        var $$final = Control_Monad_ST_Internal.read(ref)();
        return $$final.x;
      };
    };
  };
};
</code></pre>
<p>The <code>ST</code> effect is a good way to generate short JavaScript when working with locally-scoped mutable state, especially when used together with actions like <code>for</code>, <code>foreach</code>, and <code>while</code> which generate efficient loops.</p>
<h2 id="exercises-21"><a class="header" href="#exercises-21">Exercises</a></h2>
<ol>
<li>(Medium) Rewrite the <code>safeDivide</code> function as <code>exceptionDivide</code> and throw an exception using <code>throwException</code> with the message <code>&quot;div zero&quot;</code> if the denominator is zero.</li>
<li>(Medium) Write a function <code>estimatePi :: Int -&gt; Number</code> that uses <code>n</code> terms of the <a href="https://mathworld.wolfram.com/GregorySeries.html">Gregory Series</a> to calculate an approximation of <code>pi</code>. <em>Hints:</em> You can pattern your answer like the definition of <code>simulate</code> above. You might need to convert an <code>Int</code> into a <code>Number</code> using <code>toNumber :: Int -&gt; Number</code> from <code>Data.Int</code>.</li>
<li>(Medium) Write a function <code>fibonacci :: Int -&gt; Int</code> to compute the <code>n</code>th Fibonacci number, using <code>ST</code> to track the values of the previous two Fibonacci numbers. Using PSCi, compare the speed of your new <code>ST</code>-based implementation against the recursive implementation (<code>fib</code>) from Chapter 4.</li>
</ol>
<h2 id="dom-effects"><a class="header" href="#dom-effects">DOM Effects</a></h2>
<p>In the final sections of this chapter, we will apply what we have learned about effects in the <code>Effect</code> monad to the problem of working with the DOM.</p>
<p>There are a number of PureScript packages for working directly with the DOM, or with open-source DOM libraries. For example:</p>
<ul>
<li><a href="https://github.com/purescript-web/purescript-web-dom"><code>web-dom</code></a> provides type definitions and low level interface implementations for the W3C DOM spec.</li>
<li><a href="https://github.com/purescript-web/purescript-web-html"><code>web-html</code></a> provides type definitions and low level interface implementations for the W3C HTML5 spec.</li>
<li><a href="https://github.com/paf31/purescript-jquery"><code>jquery</code></a> is a set of bindings to the <a href="http://jquery.org">jQuery</a> library.</li>
</ul>
<p>There are also PureScript libraries which build abstractions on top of these libraries, such as</p>
<ul>
<li><a href="https://github.com/paf31/purescript-thermite"><code>thermite</code></a>, which builds on <a href="https://github.com/purescript-contrib/purescript-react"><code>react</code></a></li>
<li><a href="https://github.com/megamaddu/purescript-react-basic-hooks"><code>react-basic-hooks</code></a>, which builds on <a href="https://github.com/lumihq/purescript-react-basic"><code>react-basic</code></a></li>
<li><a href="https://github.com/purescript-halogen/purescript-halogen"><code>halogen</code></a> which provides a type-safe set of abstractions on top of a custom virtual DOM library.</li>
</ul>
<p>In this chapter, we will use the <code>react-basic-hooks</code> library to add a user interface to our address book application, but the interested reader is encouraged to explore alternative approaches.</p>
<h2 id="an-address-book-user-interface"><a class="header" href="#an-address-book-user-interface">An Address Book User Interface</a></h2>
<p>Using the <code>react-basic-hooks</code> library, we will define our application as a React <em>component</em>. React components describe HTML elements in code as pure data structures, which are then efficiently rendered to the DOM. In addition, components can respond to events like button clicks. The <code>react-basic-hooks</code> library uses the <code>Effect</code> monad to describe how to handle these events.</p>
<p>A full tutorial for the React library is well beyond the scope of this chapter, but the reader is encouraged to consult its documentation where needed. For our purposes, React will provide a practical example of the <code>Effect</code> monad.</p>
<p>We are going to build a form which will allow a user to add a new entry into our address book. The form will contain text boxes for the various fields (first name, last name, city, state, etc.), and an area in which validation errors will be displayed. As the user types text into the text boxes, the validation errors will be updated.</p>
<p>To keep things simple, the form will have a fixed shape: the different phone number types (home, cell, work, other) will be expanded into separate text boxes.</p>
<p>You can launch the web app from the <code>exercises/chapter8</code> directory with the following commands:</p>
<pre><code class="language-shell">$ npm install
$ npx spago build
$ npx parcel src/index.html --open
</code></pre>
<p>If development tools such as <code>spago</code> and <code>parcel</code> are installed globally, then the <code>npx</code> prefix may be omitted. You have likely already installed <code>spago</code> globally with <code>npm i -g spago</code>, and the same can be done for <code>parcel</code>.</p>
<p><code>parcel</code> should launch a browser window with our &quot;Address Book&quot; app. If you keep the <code>parcel</code> terminal open, and rebuild with <code>spago</code> in another terminal, the page should automatically refresh with your latest edits. You can also configure automatic rebuilds (and therefore automatic page refresh) on file-save if you're using an <a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors">editor</a> that supports <a href="https://github.com/purescript/purescript/tree/master/psc-ide"><code>purs ide</code></a> or are running <a href="https://github.com/kRITZCREEK/pscid"><code>pscid</code></a>.</p>
<p>In this Address Book app, you should be able to enter some values into the form fields and see the validation errors printed onto the page.</p>
<p>Let's explore how it works.</p>
<p>The <code>src/index.html</code> file is minimal:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Address Book&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The <code>&lt;script</code> line includes the JavaScript entry point, <code>index.js</code>, which contains this single line:</p>
<pre><code class="language-js">import { main } from &quot;../output/Main/index.js&quot;;

main();
</code></pre>
<p>It calls our generated JavaScript equivalent of the <code>main</code> function of <code>module Main</code> (<code>src/main.purs</code>). Recall that <code>spago build</code> puts all generated JavaScript in the <code>output</code> directory.</p>
<p>The <code>main</code> function uses the DOM and HTML APIs to render our address book component within the <code>container</code> element we defined in <code>index.html</code>:</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  log &quot;Rendering address book component&quot;
  -- Get window object
  w &lt;- window
  -- Get window's HTML document
  doc &lt;- document w
  -- Get &quot;container&quot; element in HTML
  ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
  case ctr of
    Nothing -&gt; throw &quot;Container element not found.&quot;
    Just c -&gt; do
      -- Create AddressBook react component
      addressBookApp &lt;- mkAddressBookApp
      let
        -- Create JSX node from react component. Pass-in empty props
        app = element addressBookApp {}
      -- Render AddressBook JSX node in DOM &quot;container&quot; element
      D.render app c
</code></pre>
<p>Note that these three lines:</p>
<pre><code class="language-hs">w &lt;- window
doc &lt;- document w
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>Can be consolidated to:</p>
<pre><code class="language-hs">doc &lt;- document =&lt;&lt; window
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>Or consolidated even further to:</p>
<pre><code class="language-hs">ctr &lt;- getElementById &quot;container&quot; &lt;&lt;&lt; toNonElementParentNode =&lt;&lt; document =&lt;&lt; window
-- or, equivalently:
ctr &lt;- window &gt;&gt;= document &gt;&gt;= toNonElementParentNode &gt;&gt;&gt; getElementById &quot;container&quot;
</code></pre>
<p>It is a matter of personal preference whether the intermediate <code>w</code> and <code>doc</code> variables aid in readability.</p>
<p>Let's dig into our AddressBook <code>reactComponent</code>. We'll start with a simplified component, and then build up to the actual code in <code>Main.purs</code>.</p>
<p>Take a look at this minimal component. Feel free to substitute the full component with this one to see it run:</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp =
  reactComponent
    &quot;AddressBookApp&quot;
    (\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;)
</code></pre>
<p><code>reactComponent</code> has this intimidating signature:</p>
<pre><code class="language-hs">reactComponent ::
  forall hooks props.
  Lacks &quot;children&quot; props =&gt;
  Lacks &quot;key&quot; props =&gt;
  Lacks &quot;ref&quot; props =&gt;
  String -&gt;
  ({ | props } -&gt; Render Unit hooks JSX) -&gt;
  Effect (ReactComponent { | props })
</code></pre>
<p>The important points to note are the arguments after all the type class constraints. It takes a <code>String</code> (an arbitrary component name), a function that describes how to convert <code>props</code> into rendered <code>JSX</code>, and returns our <code>ReactComponent</code> wrapped in an <code>Effect</code>.</p>
<p>The props-to-JSX function is simply:</p>
<pre><code class="language-hs">\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;
</code></pre>
<p><code>props</code> are ignored, <code>D.text</code> returns <code>JSX</code>, and <code>pure</code> lifts to rendered JSX. Now <code>component</code> has everything it needs to produce the <code>ReactComponent</code>.</p>
<p>Next we'll examine some of the additional complexities of the full Address Book component.</p>
<p>These are the first few lines of our full component:</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp = do
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p>We track <code>person</code> as a piece of state with the <code>useState</code> hook.</p>
<pre><code class="language-hs">Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p>Note that you are free to break-up component state into multiple pieces of state with multiple calls to <code>useState</code>. For example, we could rewrite this app to use a separate piece of state for each record field of <code>Person</code>, but that happens to result in a slightly less convenient architecture in this case.</p>
<p>In other examples, you may encounter the <code>/\</code> infix operator for <code>Tuple</code>. This is equivalent to the above line:</p>
<pre><code class="language-hs">firstName /\ setFirstName &lt;- useState p.firstName
</code></pre>
<p><code>useState</code> takes a default initial value and returns the current value and a way to update the value. We can check the type of <code>useState</code> to gain more insight of the types <code>person</code> and <code>setPerson</code>:</p>
<pre><code class="language-hs">useState ::
  forall state.
  state -&gt;
  Hook (UseState state) (Tuple state ((state -&gt; state) -&gt; Effect Unit))
</code></pre>
<p>We can strip the <code>Hook (UseState state)</code> wrapper off of the return value because <code>useState</code> is called within an <code>R.do</code> block. We'll elaborate on <code>R.do</code> later.</p>
<p>So now we can observe the following signatures:</p>
<pre><code class="language-hs">person :: state
setPerson :: (state -&gt; state) -&gt; Effect Unit
</code></pre>
<p>The specific type of <code>state</code> is determined by our initial default value. <code>Person</code> <code>Record</code> in this case because that is the type of <code>examplePerson</code>.</p>
<p><code>person</code> is how we access the current state at each rerender.</p>
<p><code>setPerson</code> is how we update the state. We simply provide a function that describes how to transform the current state to the new state. The record update syntax is perfect for this when the type of <code>state</code> happens to be a <code>Record</code>, for example:</p>
<pre><code class="language-hs">setPerson (\currentPerson -&gt; currentPerson {firstName = &quot;NewName&quot;})

</code></pre>
<p>or as shorthand:</p>
<pre><code class="language-hs">setPerson _ {firstName = &quot;NewName&quot;}
</code></pre>
<p>Non-<code>Record</code> states can also follow this update pattern. See <a href="https://github.com/megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541">this guide</a> for more details on best practices.</p>
<p>Recall that <code>useState</code> is used within an <code>R.do</code> block. <code>R.do</code> is a special react hooks variant of <code>do</code>. The <code>R.</code> prefix &quot;qualifies&quot; this as coming from <code>React.Basic.Hooks</code>, and means we use their hooks-compatible version of <code>bind</code> in the <code>R.do</code> block. This is known as a &quot;qualified do&quot;. It lets us ignore the <code>Hook (UseState state)</code> wrapping and bind the inner <code>Tuple</code> of values to variables.</p>
<p>Another possible state management strategy is with <code>useReducer</code>, but that is outside the scope of this chapter.</p>
<p>Rendering <code>JSX</code> occurs here:</p>
<pre><code class="language-hs">pure
  $ D.div
      { className: &quot;container&quot;
      , children:
          renderValidationErrors errors
            &lt;&gt; [ D.div
                  { className: &quot;row&quot;
                  , children:
                      [ D.form_
                          $ [ D.h3_ [ D.text &quot;Basic Information&quot; ]
                            , formField &quot;First Name&quot; &quot;First Name&quot; person.firstName \s -&gt;
                                setPerson _ { firstName = s }
                            , formField &quot;Last Name&quot; &quot;Last Name&quot; person.lastName \s -&gt;
                                setPerson _ { lastName = s }
                            , D.h3_ [ D.text &quot;Address&quot; ]
                            , formField &quot;Street&quot; &quot;Street&quot; person.homeAddress.street \s -&gt;
                                setPerson _ { homeAddress { street = s } }
                            , formField &quot;City&quot; &quot;City&quot; person.homeAddress.city \s -&gt;
                                setPerson _ { homeAddress { city = s } }
                            , formField &quot;State&quot; &quot;State&quot; person.homeAddress.state \s -&gt;
                                setPerson _ { homeAddress { state = s } }
                            , D.h3_ [ D.text &quot;Contact Information&quot; ]
                            ]
                          &lt;&gt; renderPhoneNumbers
                      ]
                  }
              ]
      }
</code></pre>
<p>Here we produce <code>JSX</code> which represents the intended state of the DOM. This JSX is typically created by applying functions corresponding to HTML tags (e.g. <code>div</code>, <code>form</code>, <code>h3</code>, <code>li</code>, <code>ul</code>, <code>label</code>, <code>input</code>) which create single HTML elements. These HTML elements are actually React components themselves, converted to JSX. There are usually three variants of each of these functions:</p>
<ul>
<li><code>div_</code>: Accepts an array of child elements. Uses default attributes.</li>
<li><code>div</code>: Accepts a <code>Record</code> of attributes. An array of child elements may be passed to the <code>children</code> field of this record.</li>
<li><code>div'</code>: Same as <code>div</code>, but returns the <code>ReactComponent</code> before conversion to <code>JSX</code>.</li>
</ul>
<p>To display validation errors (if any) at the top of our form, we create a <code>renderValidationErrors</code> helper function that turns the <code>Errors</code> structure into an array of JSX. This array is prepended to the rest of our form.</p>
<pre><code class="language-hs">renderValidationErrors :: Errors -&gt; Array R.JSX
renderValidationErrors [] = []
renderValidationErrors xs =
  let
    renderError :: String -&gt; R.JSX
    renderError err = D.li_ [ D.text err ]
  in
    [ D.div
        { className: &quot;alert alert-danger row&quot;
        , children: [ D.ul_ (map renderError xs) ]
        }
    ]
</code></pre>
<p>Note that since we are simply manipulating regular data structures here, we can use functions like <code>map</code> to build up more interesting elements:</p>
<pre><code class="language-hs">children: [ D.ul_ (map renderError xs)]
</code></pre>
<p>We use the <code>className</code> property to define classes for CSS styling. We're using the <a href="https://getbootstrap.com/">Bootstrap</a> <code>stylesheet</code> for this project, which is imported in <code>index.html</code>. For example, we want items in our form arranged as <code>row</code>s, and validation errors to be emphasized with <code>alert-danger</code> styling:</p>
<pre><code class="language-hs">className: &quot;alert alert-danger row&quot;
</code></pre>
<p>A second helper function is <code>formField</code>, which creates a text input for a single form field:</p>
<pre><code class="language-hs">formField :: String -&gt; String -&gt; String -&gt; (String -&gt; Effect Unit) -&gt; R.JSX
formField name placeholder value setValue =
  D.label
    { className: &quot;form-group row&quot;
    , children:
        [ D.div
            { className: &quot;col-sm col-form-label&quot;
            , children: [ D.text name ]
            }
        , D.div
            { className: &quot;col-sm&quot;
            , children:
                [ D.input
                    { className: &quot;form-control&quot;
                    , placeholder
                    , value
                    , onChange:
                        let
                          handleValue :: Maybe String -&gt; Effect Unit
                          handleValue (Just v) = setValue v
                          handleValue Nothing  = pure unit
                        in
                          handler targetValue handleValue
                    }
                ]
            }
        ]
    }
</code></pre>
<p>Putting the <code>input</code> and display <code>text</code> in a <code>label</code> aids in accessibility for screen readers.</p>
<p>The <code>onChange</code> attribute allows us to describe how to respond to user input. We use the <code>handler</code> function, which has the following type:</p>
<pre><code class="language-hs">handler :: forall a. EventFn SyntheticEvent a -&gt; (a -&gt; Effect Unit) -&gt; EventHandler
</code></pre>
<p>For the first argument to <code>handler</code> we use <code>targetValue</code>, which provides the value of the text within the HTML <code>input</code> element. It matches the signature expected by <code>handler</code> where the type variable <code>a</code> in this case is <code>Maybe String</code>:</p>
<pre><code class="language-hs">targetValue :: EventFn SyntheticEvent (Maybe String)
</code></pre>
<p>In JavaScript, the <code>input</code> element's <code>onChange</code> event is actually accompanied by a <code>String</code> value, but since strings in JavaScript can be null, <code>Maybe</code> is used for safety.</p>
<p>The second argument to <code>handler</code>, <code>(a -&gt; Effect Unit)</code>, must therefore have this signature:</p>
<pre><code class="language-hs">Maybe String -&gt; Effect Unit
</code></pre>
<p>It is a function that describes how to convert this <code>Maybe String</code> value into our desired effect. We define a custom <code>handleValue</code> function for this purpose and pass it to <code>handler</code> as follows:</p>
<pre><code class="language-hs">onChange:
  let
    handleValue :: Maybe String -&gt; Effect Unit
    handleValue (Just v) = setValue v
    handleValue Nothing  = pure unit
  in
    handler targetValue handleValue
</code></pre>
<p><code>setValue</code> is the function we provided to each <code>formField</code> call that takes a string and makes the appropriate record-update call to the <code>setPerson</code> hook.</p>
<p>Note that <code>handleValue</code> can be substituted as:</p>
<pre><code class="language-hs">onChange: handler targetValue $ traverse_ setValue
</code></pre>
<p>Feel free to investigate the definition of <code>traverse_</code> to see how both forms are indeed equivalent.</p>
<p>That covers the basics of our component implementation. However, you should read the source accompanying this chapter in order to get a full understanding of the way the component works.</p>
<p>Obviously, this user interface can be improved in a number of ways. The exercises will explore some ways in which we can make the application more usable.</p>
<h2 id="exercises-22"><a class="header" href="#exercises-22">Exercises</a></h2>
<p>Modify <code>src/Main.purs</code> in the following exercises. There are no unit tests for these exercises.</p>
<ol>
<li>
<p>(Easy) Modify the application to include a work phone number text box.</p>
</li>
<li>
<p>(Medium) Right now the application shows validation errors collected in a single &quot;pink-alert&quot; background.  Modify to give each validation error its own pink-alert background by separating them  with blank lines.</p>
<p><em>Hint</em>: Instead of using a <code>ul</code> element to show the validation errors in a list, modify the code to create one <code>div</code> with the <code>alert</code> and <code>alert-danger</code> styles for each error.</p>
</li>
<li>
<p>(Difficult, Extended) One problem with this user interface is that the validation errors are not displayed next to the form fields they originated from. Modify the code to fix this problem.</p>
<p><em>Hint</em>: the error type returned by the validator should be extended to indicate which field caused the error. You might want to use the following modified <code>Errors</code> type:</p>
<pre><code class="language-hs">data Field = FirstNameField
           | LastNameField
           | StreetField
           | CityField
           | StateField
           | PhoneField PhoneType

data ValidationError = ValidationError String Field

type Errors = Array ValidationError
</code></pre>
<p>You will need to write a function which extracts the validation error for a particular <code>Field</code> from the <code>Errors</code> structure.</p>
</li>
</ol>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>This chapter has covered a lot of ideas about handling side-effects in PureScript:</p>
<ul>
<li>We met the <code>Monad</code> type class, and its connection to do notation.</li>
<li>We introduced the monad laws, and saw how they allow us to transform code written using do notation.</li>
<li>We saw how monads can be used abstractly, to write code which works with different side-effects.</li>
<li>We saw how monads are examples of applicative functors, how both allow us to compute with side-effects, and the differences between the two approaches.</li>
<li>The concept of native effects was defined, and we met the <code>Effect</code> monad, which is used to handle native side-effects.</li>
<li>We used the <code>Effect</code> monad to handle a variety of effects: random number generation, exceptions, console IO, mutable state, and DOM manipulation using React.</li>
</ul>
<p>The <code>Effect</code> monad is a fundamental tool in real-world PureScript code. It will be used in the rest of the book to handle side-effects in a number of other use-cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-effects"><a class="header" href="#asynchronous-effects">Asynchronous Effects</a></h1>
<h2 id="chapter-goals-7"><a class="header" href="#chapter-goals-7">Chapter Goals</a></h2>
<p>This chapter focuses on the <code>Aff</code> monad, which is similar to the <code>Effect</code> monad, but represents <em>asynchronous</em> side-effects. We'll demonstrate examples of asynchronously interacting with the filesystem and making HTTP requests. We'll also cover how to manage sequential and parallel execution of asynchronous effects.</p>
<h2 id="project-setup-6"><a class="header" href="#project-setup-6">Project Setup</a></h2>
<p>New PureScript libraries introduced in this chapter are:</p>
<ul>
<li><code>aff</code> - defines the <code>Aff</code> monad.</li>
<li><code>node-fs-aff</code> - asynchronous filesystem operations with <code>Aff</code>.</li>
<li><code>affjax</code> - HTTP requests with AJAX and <code>Aff</code>.</li>
<li><code>parallel</code> - parallel execution of <code>Aff</code>.</li>
</ul>
<p>When running outside of the browser (such as in our Node.js environment), the <code>affjax</code> library requires the <code>xhr2</code> NPM module, which is listed as dependency in the <code>package.json</code> of this chapter. Install that by running:</p>
<pre><code class="language-shell">$ npm install
</code></pre>
<h2 id="asynchronous-javascript"><a class="header" href="#asynchronous-javascript">Asynchronous JavaScript</a></h2>
<p>A convenient way to work with asynchronous code in JavaScript is with <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await"><code>async</code> and <code>await</code></a>. See <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">this article on asynchronous JavaScript</a> for more background information.</p>
<p>Here is an example of using this technique to copy the contents of one file to another file:</p>
<pre><code class="language-js">import { promises as fsPromises } from 'fs'

async function copyFile(file1, file2) {
  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });
  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });
}

copyFile('file1.txt', 'file2.txt')
.catch(e =&gt; {
  console.log('There was a problem with copyFile: ' + e.message);
});
</code></pre>
<p>It is also possible to use callbacks or synchronous functions, but those are less desireable because:</p>
<ul>
<li>Callbacks lead to excessive nesting, known as &quot;Callback Hell&quot; or the &quot;Pyramid of Doom&quot;.</li>
<li>Synchronous functions block execution of the other code in your app.</li>
</ul>
<h2 id="asynchronous-purescript"><a class="header" href="#asynchronous-purescript">Asynchronous PureScript</a></h2>
<p>The <code>Aff</code> monad in PureScript offers similar ergonomics of JavaScript's <code>async</code>/<code>await</code> syntax. Here is the same <code>copyFile</code> example from before, but rewritten in PureScript using <code>Aff</code>:</p>
<pre><code class="language-hs">import Prelude
import Data.Either (Either(..))
import Effect.Aff (Aff, attempt, message)
import Effect.Class.Console (log)
import Node.Encoding (Encoding(..))
import Node.FS.Aff (readTextFile, writeTextFile)
import Node.Path (FilePath)

copyFile :: FilePath -&gt; FilePath -&gt; Aff Unit
copyFile file1 file2 = do
  my_data &lt;- readTextFile UTF8 file1
  writeTextFile UTF8 file2 my_data

main :: Aff Unit
main = do
  result &lt;- attempt $ copyFile &quot;file1.txt&quot; &quot;file2.txt&quot;
  case result of
    Left e -&gt; log $ &quot;There was a problem with copyFile: &quot; &lt;&gt; message e
    _ -&gt; pure unit
</code></pre>
<p>It is also possible to re-write the above snippet using callbacks or synchronous functions (for example with <code>Node.FS.Async</code> and <code>Node.FS.Sync</code> respectively), but those share the same downsides as discussed earlier with JavaScript, and so that coding style is not recommended.</p>
<p>The syntax for working with <code>Aff</code> is very similar to working with <code>Effect</code>. They are both monads, and can therefore be written with do notation.</p>
<p>For example, if we look at the signature of <code>readTextFile</code>, we see that it returns the file contents as a <code>String</code> wrapped in <code>Aff</code>:</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; FilePath -&gt; Aff String
</code></pre>
<p>We can &quot;unwrap&quot; the returned string with a bind arrow (<code>&lt;-</code>) in do notation:</p>
<pre><code class="language-hs">my_data &lt;- readTextFile UTF8 file1
</code></pre>
<p>Then pass it as the string argument to <code>writeTextFile</code>:</p>
<pre><code class="language-hs">writeTextFile :: Encoding -&gt; FilePath -&gt; String -&gt; Aff Unit
</code></pre>
<p>The only other notable feature unique to <code>Aff</code> in the above example is <code>attempt</code>, which captures errors or exceptions encountered while running <code>Aff</code> code and stores them in an <code>Either</code>:</p>
<pre><code class="language-hs">attempt :: forall a. Aff a -&gt; Aff (Either Error a)
</code></pre>
<p>You should hopefully be able to draw on your knowledge of concepts from previous chapters and combine this with the new <code>Aff</code> patterns learned in the above <code>copyFile</code> example to tackle the following exercises:</p>
<h2 id="exercises-23"><a class="header" href="#exercises-23">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a <code>concatenateFiles</code> function which concatenates two text files.</p>
</li>
<li>
<p>(Medium) Write a function <code>concatenateMany</code> to concatenate multiple text files, given an array of input file names and an output file name. <em>Hint</em>: use <code>traverse</code>.</p>
</li>
<li>
<p>(Medium) Write a function <code>countCharacters :: FilePath -&gt; Aff (Either Error Int)</code> that returns the number of characters in a file, or an error if one is encountered.</p>
</li>
</ol>
<h2 id="additional-aff-resources"><a class="header" href="#additional-aff-resources">Additional Aff Resources</a></h2>
<p>If you haven't already taken a look at the <a href="https://pursuit.purescript.org/packages/purescript-aff/">official Aff guide</a>, skim through that now. It's not a direct prerequisite for completing the remaining exercises in this chapter, but you may find it helpful to lookup some functions on Pursuit.</p>
<p>You're also welcome to consult these supplemental resources too, but again, the exercises in this chapter don't depend on them:</p>
<ul>
<li><a href="https://blog.drewolson.org/asynchronous-purescript">Drew's Aff Post</a></li>
<li><a href="https://github.com/JordanMartinez/purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff">Additional Aff Explanation and Examples</a></li>
</ul>
<h2 id="a-http-client"><a class="header" href="#a-http-client">A HTTP Client</a></h2>
<p>The <code>affjax</code> library offers a convenient way to make asynchronous AJAX HTTP requests with <code>Aff</code>. Depending on what environment you are targeting you need to use either the <a href="https://github.com/purescript-contrib/purescript-affjax-web">purescript-affjax-web</a> or the <a href="https://github.com/purescript-contrib/purescript-affjax-node">purescript-affjax-node</a> library.
In the rest of this chapter we will be targeting node and thus using <code>purescript-affjax-node</code>.
Consult the <a href="https://pursuit.purescript.org/packages/purescript-affjax">Affjax docs</a> for more usage information. Here is an example that makes HTTP GET requests at a provided URL and returns the response body or an error message:</p>
<pre><code class="language-hs">import Prelude
import Affjax.Node as AN
import Affjax.ResponseFormat as ResponseFormat
import Data.Either (Either(..))
import Effect.Aff (Aff)

getUrl :: String -&gt; Aff String
getUrl url = do
  result &lt;- AN.get ResponseFormat.string url
  pure case result of
    Left err -&gt; &quot;GET /api response failed to decode: &quot; &lt;&gt; AN.printError err
    Right response -&gt; response.body
</code></pre>
<p>When calling this in the repl, <code>launchAff_</code> is required to convert the <code>Aff</code> to a repl-compatible <code>Effect</code>:</p>
<pre><code class="language-shell">$ spago repl

&gt; :pa
… import Prelude
… import Effect.Aff (launchAff_)
… import Effect.Class.Console (log)
… import Test.HTTP (getUrl)
…
… launchAff_ do
…   str &lt;- getUrl &quot;https://reqres.in/api/users/1&quot;
…   log str
…
unit
{&quot;data&quot;:{&quot;id&quot;:1,&quot;email&quot;:&quot;george.bluth@reqres.in&quot;,&quot;first_name&quot;:&quot;George&quot;,&quot;last_name&quot;:&quot;Bluth&quot;, ...}}
</code></pre>
<h2 id="exercises-24"><a class="header" href="#exercises-24">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>writeGet</code> which makes an HTTP <code>GET</code> request to a provided url, and writes the response body to a file.</li>
</ol>
<h2 id="parallel-computations"><a class="header" href="#parallel-computations">Parallel Computations</a></h2>
<p>We've seen how to use the <code>Aff</code> monad and do notation to compose asynchronous computations in sequence. It would also be useful to be able to compose asynchronous computations <em>in parallel</em>. With <code>Aff</code>, we can compute in parallel simply by initiating our two computations one after the other.</p>
<p>The <code>parallel</code> package defines a type class <code>Parallel</code> for monads like <code>Aff</code> which support parallel execution. When we met applicative functors earlier in the book, we observed how applicative functors can be useful for combining parallel computations. In fact, an instance for <code>Parallel</code> defines a correspondence between a monad <code>m</code> (such as <code>Aff</code>) and an applicative functor <code>f</code> which can be used to combine computations in parallel:</p>
<pre><code class="language-hs">class (Monad m, Applicative f) &lt;= Parallel f m | m -&gt; f, f -&gt; m where
  sequential :: forall a. f a -&gt; m a
  parallel :: forall a. m a -&gt; f a
</code></pre>
<p>The class defines two functions:</p>
<ul>
<li><code>parallel</code>, which takes computations in the monad <code>m</code> and turns them into computations in the applicative functor <code>f</code>, and</li>
<li><code>sequential</code>, which performs a conversion in the opposite direction.</li>
</ul>
<p>The <code>aff</code> library provides a <code>Parallel</code> instance for the <code>Aff</code> monad. It uses mutable references to combine <code>Aff</code> actions in parallel, by keeping track of which of the two continuations has been called. When both results have been returned, we can compute the final result and pass it to the main continuation.</p>
<p>Because applicative functors support lifting of functions of arbitrary arity, we can perform more computations in parallel by using the applicative combinators. We can also benefit from all of the standard library functions which work with applicative functors, such as <code>traverse</code> and <code>sequence</code>!</p>
<p>We can also combine parallel computations with sequential portions of code, by using applicative combinators in a do notation block, or vice versa, using <code>parallel</code> and <code>sequential</code> to change type constructors where appropriate.</p>
<p>To demonstrate the difference between sequential and parallel execution, we'll create an array of 100 10-millisecond delays, then execute those delays with both techniques.
You'll notice in the repl that <code>seqDelay</code> is much slower than <code>parDelay</code>.
Note that parallel execution is enabled by simply replacing <code>sequence_</code> with <code>parSequence_</code>.</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parSequence_)
import Data.Array (replicate)
import Data.Foldable (sequence_)
import Effect (Effect)
import Effect.Aff (Aff, Milliseconds(..), delay, launchAff_)

delayArray :: Array (Aff Unit)
delayArray = replicate 100 $ delay $ Milliseconds 10.0

seqDelay :: Effect Unit
seqDelay = launchAff_ $ sequence_ delayArray

parDelay :: Effect Unit
parDelay = launchAff_ $ parSequence_ delayArray
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelDelay

&gt; seqDelay -- This is slow
unit

&gt; parDelay -- This is fast
unit
</code></pre>
<p>Here's a more real-world example of making multiple HTTP requests in parallel. We're reusing our <code>getUrl</code> function to fetch information from two users in parallel. Note that <code>parTraverse</code> (the parallel version of <code>traverse</code>) is used in this case. This example would also work fine with <code>traverse</code> instead, but it will be slower.</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parTraverse)
import Effect (Effect)
import Effect.Aff (launchAff_)
import Effect.Class.Console (logShow)
import Test.HTTP (getUrl)

fetchPar :: Effect Unit
fetchPar =
  launchAff_ do
    let
      urls = map (\n -&gt; &quot;https://reqres.in/api/users/&quot; &lt;&gt; show n) [ 1, 2 ]
    res &lt;- parTraverse getUrl urls
    logShow res
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelFetch

&gt; fetchPar
unit
[&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:1,\&quot;email\&quot;:\&quot;george.bluth@reqres.in\&quot;, ... }&quot;
,&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:2,\&quot;email\&quot;:\&quot;janet.weaver@reqres.in\&quot;, ... }&quot;
]
</code></pre>
<p>A full listing of available parallel functions can be found in the <a href="https://pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel"><code>parallel</code> docs on Pursuit</a>. The <a href="https://github.com/purescript-contrib/purescript-aff#parallel-execution">aff docs section on parallel</a> also contains more examples.</p>
<h2 id="exercises-25"><a class="header" href="#exercises-25">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a <code>concatenateManyParallel</code> function which has the same signature as the earlier <code>concatenateMany</code> function, but reads all input files in parallel.</p>
</li>
<li>
<p>(Medium) Write a <code>getWithTimeout :: Number -&gt; String -&gt; Aff (Maybe String)</code> function which makes an HTTP <code>GET</code> request at the provided URL and returns either:</p>
<ul>
<li><code>Nothing</code>: if the request takes longer than the provided timeout (in milliseconds).</li>
<li>The string response: if the request succeeds before the timeout elapses.</li>
</ul>
</li>
<li>
<p>(Difficult) Write a <code>recurseFiles</code> function which takes a &quot;root&quot; file and returns an array of all paths listed in that file (and listed in the listed files too). Read listed files in parallel. Paths are relative to the directory of the file they appear in. <em>Hint:</em> The <code>node-path</code> module has some helpful functions for negotiating directories.</p>
</li>
</ol>
<p>For example, if starting from the following <code>root.txt</code> file:</p>
<pre><code class="language-shell">$ cat root.txt
a.txt
b/a.txt
c/a/a.txt

$ cat a.txt
b/b.txt

$ cat b/b.txt
c/a.txt

$ cat b/c/a.txt

$ cat b/a.txt

$ cat c/a/a.txt
</code></pre>
<p>The expected output is:</p>
<pre><code class="language-hs">[&quot;root.txt&quot;,&quot;a.txt&quot;,&quot;b/a.txt&quot;,&quot;b/b.txt&quot;,&quot;b/c/a.txt&quot;,&quot;c/a/a.txt&quot;]
</code></pre>
<h2 id="conclusion-7"><a class="header" href="#conclusion-7">Conclusion</a></h2>
<p>In this chapter we covered asynchronous effects and learned how to:</p>
<ul>
<li>Run asynchronous code in the <code>Aff</code> monad with the <code>aff</code> library.</li>
<li>Make HTTP requests asynchronously with the <code>affjax</code> library.</li>
<li>Run asynchronous code in parallel with the <code>parallel</code> library.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-foreign-function-interface"><a class="header" href="#the-foreign-function-interface">The Foreign Function Interface</a></h1>
<h2 id="chapter-goals-8"><a class="header" href="#chapter-goals-8">Chapter Goals</a></h2>
<p>This chapter will introduce PureScript's <em>foreign function interface</em> (or <em>FFI</em>), which enables communication from PureScript code to JavaScript code, and vice versa. We will cover how to:</p>
<ul>
<li>Call pure, effectful, and asynchronous JavaScript functions from PureScript.</li>
<li>Work with untyped data.</li>
<li>Encode and parse JSON using the <code>argonaut</code> package.</li>
</ul>
<p>Towards the end of this chapter, we will revisit our recurring address book example. The goal of the chapter will be to add the following new functionality to our application using the FFI:</p>
<ul>
<li>Alert the user with a popup notification.</li>
<li>Store the serialized form data in the browser's local storage, and reload it when the application restarts.</li>
</ul>
<p>There is also an addendum which covers some additional topics which are not as commonly sought-after. Feel free to read these sections, but don't let them stand in the way of progressing through the remainder of the book if they're less relevant to your learning objectives:</p>
<ul>
<li>Understand the representation of PureScript values at runtime.</li>
<li>Call PureScript functions from JavaScript.</li>
</ul>
<h2 id="project-setup-7"><a class="header" href="#project-setup-7">Project Setup</a></h2>
<p>The source code for this module is a continuation of the source code from chapters 3, 7 and 8. As such, the source tree includes the appropriate source files from those chapters.</p>
<p>This chapter introduces the <code>argonaut</code> library as a dependency. This library is used for encoding and decoding JSON.</p>
<p>The exercises for this chapter should be written in <code>test/MySolutions.purs</code> and can be checked against the unit tests in <code>test/Main.purs</code> by running <code>spago test</code>.</p>
<p>The Address Book app can be launched with <code>parcel src/index.html --open</code>. It uses the same workflow from Chapter 8, so refer to that chapter for more detailed instructions.</p>
<h2 id="a-disclaimer"><a class="header" href="#a-disclaimer">A Disclaimer</a></h2>
<p>PureScript provides a straightforward foreign function interface to make working with JavaScript as simple as possible. However, it should be noted that the FFI is an <em>advanced</em> feature of the language. To use it safely and effectively, you should have an understanding of the runtime representation of the data you plan to work with. This chapter aims to impart such an understanding as pertains to code in PureScript's standard libraries.</p>
<p>PureScript's FFI is designed to be very flexible. In practice, this means that developers have a choice, between giving their foreign functions very simple types, or using the type system to protect against accidental misuses of foreign code. Code in the standard libraries tends to favor the latter approach.</p>
<p>As a simple example, a JavaScript function makes no guarantees that its return value will not be <code>null</code>. Indeed, idiomatic JavaScript code returns <code>null</code> quite frequently! However, PureScript's types are usually not inhabited by a null value. Therefore, it is the responsibility of the developer to handle these corner cases appropriately when designing their interfaces to JavaScript code using the FFI.</p>
<h2 id="calling-javascript-from-purescript"><a class="header" href="#calling-javascript-from-purescript">Calling JavaScript From PureScript</a></h2>
<p>The simplest way to use JavaScript code from PureScript is to give a type to an existing JavaScript value using a <em>foreign import</em> declaration. Foreign import declarations must have a corresponding JavaScript declaration <em>exported</em> from a <em>foreign JavaScript module</em>.</p>
<p>For example, consider the <code>encodeURIComponent</code> function, which can be used in JavaScript to encode a component of a URI by escaping special characters:</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p>This function has the correct runtime representation for the function type <code>String -&gt; String</code>, since it takes non-null strings to non-null strings, and has no other side-effects.</p>
<p>We can assign this type to the function with the following foreign import declaration:</p>
<pre><code class="language-haskell">module Test.URI where

foreign import _encodeURIComponent :: String -&gt; String
</code></pre>
<p>We also need to write a foreign JavaScript module to import it from. A corresponding foreign JavaScript module is one of the same name but extension changed from <code>.purs</code> to <code>.js</code>. If the Purescript module above is saved as <code>URI.purs</code>, then the foreign JavaScript module is saved as <code>URI.js</code>.
Since <code>encodeURIComponent</code> is already defined, we have to export it as <code>_encodeURIComponent</code>:</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

export const _encodeURIComponent = encodeURIComponent;
</code></pre>
<p>Since version 0.15, Purescript uses the ES module system when interoperating with JavaScript. In ES modules, functions and values are exported from a module by providing the <code>export</code> keyword on an object.</p>
<p>With these two pieces in place, we can now use the <code>_encodeURIComponent</code> function from PureScript like any function written in PureScript. For example, in PSCi, we can reproduce the calculation above:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; _encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>We can also define our own functions in foreign modules. Here's an example of how to create and call a custom JavaScript function that squares a <code>Number</code>:</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

export const square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="functions-of-multiple-arguments"><a class="header" href="#functions-of-multiple-arguments">Functions of Multiple Arguments</a></h2>
<p>Let's rewrite our <code>diagonal</code> function from Chapter 2 in a foreign module. This function calculates the diagonal of a right-angled triangle.</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>Recall that functions in PureScript are <em>curried</em>. <code>diagonal</code> is a function that takes a <code>Number</code> and returns a <em>function</em>, that takes a <code>Number</code> and returns a <code>Number</code>.</p>
<pre><code class="language-js">export const diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>Or with ES6 arrow syntax (see ES6 note below).</p>
<pre><code class="language-js">export const diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="uncurried-functions"><a class="header" href="#uncurried-functions">Uncurried Functions</a></h2>
<p>Writing curried functions in JavaScript isn't always feasible, despite being scarcely idiomatic. A typical multi-argument JavaScript function would be of the <em>uncurried</em> form:</p>
<pre><code class="language-js">export const diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>The module <code>Data.Function.Uncurried</code> exports <em>wrapper</em> types and utility functions to work with uncurried functions.</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>Inspecting the type constructor <code>Fn2</code>:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code> takes three type arguments. <code>Fn2 a b c</code> is a type representing an uncurried function of two arguments of types <code>a</code> and <code>b</code>, that returns a value of type <code>c</code>. We used it to import <code>diagonalUncurried</code> from the foreign module.</p>
<p>We can then call it with <code>runFn2</code> which takes the uncurried function then the arguments.</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p>The <code>functions</code> package defines similar type constructors for function arities from 0 to 10.</p>
<h2 id="a-note-about-uncurried-functions"><a class="header" href="#a-note-about-uncurried-functions">A Note About Uncurried Functions</a></h2>
<p>PureScript's curried functions has certain advantages. It allows us to partially apply functions, and to give type class instances for function types - but it comes with a performance penalty. For performance critical code, it is sometimes necessary to define uncurried JavaScript functions which accept multiple arguments.</p>
<p>We can also create uncurried functions from PureScript. For a function of two arguments, we can use the <code>mkFn2</code> function.</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>We can apply the uncurried function of two arguments by using <code>runFn2</code> as before:</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>The key here is that the compiler <em>inlines</em> the <code>mkFn2</code> and <code>runFn2</code> functions whenever they are fully applied. The result is that the generated code is very compact:</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>For contrast, here is a traditional curried function:</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>and the resulting generated code, which is less compact due to the nested functions:</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="a-note-about-modern-javascript-syntax"><a class="header" href="#a-note-about-modern-javascript-syntax">A Note About Modern JavaScript Syntax</a></h2>
<p>The arrow function syntax we saw earlier is an ES6 feature, and so it is incompatible with some older browsers (namely IE11). As of writing, it is <a href="https://caniuse.com/#feat=arrow-functions">estimated that arrow functions are unavailable for the 6% of users</a> who have not yet updated their web browser.</p>
<p>In order to be compatible with the most users, the JavaScript code generated by the PureScript compiler does not use arrow functions. It is also recommended to <strong>avoid arrow functions in public libraries</strong> for the same reason.</p>
<p>You may still use arrow functions in your own FFI code, but then should include a tool such as <a href="https://github.com/babel/babel#intro">Babel</a> in your deployment workflow to convert these back to ES5 compatible functions.</p>
<p>If you find arrow functions in ES6 more readable, you may transform JavaScript code in the compiler's <code>output</code> directory with a tool like <a href="https://github.com/lebab/lebab">Lebab</a>:</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>This operation would convert the above <code>curriedAdd</code> function to:</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>The remaining examples in this book will use arrow functions instead of nested functions.</p>
<h2 id="exercises-26"><a class="header" href="#exercises-26">Exercises</a></h2>
<ol>
<li>(Medium) Write a JavaScript function <code>volumeFn</code> in the <code>Test.MySolutions</code> module that finds the volume of a box. Use an <code>Fn</code> wrapper from <code>Data.Function.Uncurried</code>.</li>
<li>(Medium) Rewrite <code>volumeFn</code> with arrow functions as <code>volumeArrow</code>.</li>
</ol>
<h2 id="passing-simple-types"><a class="header" href="#passing-simple-types">Passing Simple Types</a></h2>
<p>The following data types may be passed between PureScript and JavaScript as-is:</p>
<div class="table-wrapper"><table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
</div>
<p>We've already seen examples with the primitive types <code>String</code> and <code>Number</code>. We'll now take a look at the structural types <code>Array</code> and <code>Record</code> (<code>Object</code> in JavaScript).</p>
<p>To demonstrate passing <code>Array</code>s, here's how to call a JavaScript function which takes an <code>Array</code> of <code>Int</code> and returns the cumulative sum as another array. Recall that, since JavaScript does not have a separate type for <code>Int</code>, both <code>Int</code> and <code>Number</code> in PureScript translate to <code>Number</code> in JavaScript.</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">export const cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p>To demonstrate passing <code>Records</code>, here's how to call a JavaScript function which takes two <code>Complex</code> numbers as records, and returns their sum as another record. Note that a <code>Record</code> in PureScript is represented as an <code>Object</code> in JavaScript:</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">export const addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>Note that the above techniques require trusting that JavaScript will return the expected types, as PureScript is not able to apply type checking to JavaScript code. We will describe this type safety concern in more detail later on in the JSON section, as well as cover techniques to protect against type mismatches.</p>
<h2 id="exercises-27"><a class="header" href="#exercises-27">Exercises</a></h2>
<ol>
<li>(Medium) Write a JavaScript function <code>cumulativeSumsComplex</code> (and corresponding PureScript foreign import) that takes an <code>Array</code> of <code>Complex</code> numbers and returns the cumulative sum as another array of complex numbers.</li>
</ol>
<h2 id="beyond-simple-types"><a class="header" href="#beyond-simple-types">Beyond Simple Types</a></h2>
<p>We have seen examples of how to send and receive types with a native JavaScript representation, such as <code>String</code>, <code>Number</code>, <code>Array</code>, and <code>Record</code>, over FFI. Now we'll cover how to use some of the other types available in PureScript, like <code>Maybe</code>.</p>
<p>Suppose we wanted to recreate the <code>head</code> function on arrays by using a foreign declaration. In JavaScript, we might write the function as follows:</p>
<pre><code class="language-javascript">export const head = arr =&gt;
  arr[0];
</code></pre>
<p>How would we type this function? We might try to give it the type <code>forall a. Array a -&gt; a</code>, but for empty arrays, this function returns <code>undefined</code>. Therefore, the type <code>forall a. Array a -&gt; a</code> does not correctly represent this implementation.</p>
<p>We instead want to return a <code>Maybe</code> value to handle this corner case:</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>But how do we return a <code>Maybe</code>? It is tempting to write the following:</p>
<pre><code class="language-js">// Don't do this
import Data_Maybe from '../Data.Maybe'

export const maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>Importing and using the <code>Data.Maybe</code> module directly in the foreign module isn't recommended as it makes our code brittle to changes in the code generator — <code>create</code> and <code>value</code> are not public APIs. Additionally, doing this can cause problems when using <code>purs bundle</code> for dead code elimination.</p>
<p>The recommended approach is to add extra parameters to our FFI-defined function to accept the functions we need.</p>
<pre><code class="language-js">export const maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>Note that we wrote:</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>and not:</p>
<pre><code class="language-hs">forall a. ( a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>While both forms work, the latter is more vulnerable to unwanted inputs in place of <code>Just</code> and <code>Nothing</code>.
For example, in the more vulnerable case we could call it as follows:</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>which returns <code>Just 1000</code> for any array input.
This vulnerability is allowed because <code>(\_ -&gt; Just 1000)</code> and <code>Just 1000</code> match the signatures of <code>(a -&gt; Maybe a)</code> and <code>Maybe a</code> respectively when <code>a</code> is <code>Int</code> (based on input array).</p>
<p>In the more secure type signature, even when <code>a</code> is determined to be <code>Int</code> based on the input array, we still need to provide valid functions matching the signatures involving <code>forall x</code>.
The <em>only</em> option for <code>(forall x. Maybe x)</code> is <code>Nothing</code>, since a <code>Just</code> value would assume a type for <code>x</code> and will no longer be valid for all <code>x</code>. The only options for <code>(forall x. x -&gt; Maybe x)</code> are <code>Just</code> (our desired argument) and <code>(\_ -&gt; Nothing)</code>, which is the only remaining vulnerability.</p>
<h2 id="defining-foreign-types"><a class="header" href="#defining-foreign-types">Defining Foreign Types</a></h2>
<p>Suppose instead of returning a <code>Maybe a</code>, we want to actually return <code>arr[0]</code>. We want a type that represents a value either of type <code>a</code> or the <code>undefined</code> value (but not <code>null</code>). We'll call this type <code>Undefined a</code>.</p>
<p>We can define a <em>foreign type</em> using a <em>foreign type declaration</em>. The syntax is similar to defining a foreign function:</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>The <code>data</code> keyword here indicates that we are defining a <em>type</em>, not a value. Instead of a type signature, we give the <em>kind</em> of the new type. In this case, we declare the kind of <code>Undefined</code> to be <code>Type -&gt; Type</code>. In other words, <code>Undefined</code> is a type constructor.</p>
<p>We can now simply reuse our original definition for <code>head</code>:</p>
<pre><code class="language-javascript">export const undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>And in the PureScript module:</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p>The body of the <code>undefinedHead</code> function returns <code>arr[0]</code> which may be <code>undefined</code>, and the type signature correctly reflects that fact.</p>
<p>This function has the correct runtime representation for its type, but is quite useless since we have no way to use a value of type <code>Undefined a</code>. Well, not exactly. We can use this type in another FFI!</p>
<p>We can write a function that will tell us whether a value is undefined or not:</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>This is defined in our foreign JavaScript module as follows:</p>
<pre><code class="language-javascript">export const isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>We can now use <code>isUndefined</code> and <code>undefinedHead</code> together from PureScript to define a useful function:</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>Here, the foreign function we defined is very simple, which means we can benefit from the use of PureScript's typechecker as much as possible. This is good practice in general: foreign functions should be kept as small as possible, and application logic moved into PureScript code wherever possible.</p>
<h2 id="exceptions-1"><a class="header" href="#exceptions-1">Exceptions</a></h2>
<p>Another option is to simply throw an exception in the case of an empty array. Strictly speaking, pure functions should not throw exceptions, but we have the flexibility to do so. We indicate the lack of safety in the function name:</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>In our foreign JavaScript module, we can define <code>unsafeHead</code> as follows:</p>
<pre><code class="language-javascript">export const unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="exercises-28"><a class="header" href="#exercises-28">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Given a record that represents a quadratic polynomial <code>a*x^2 + b*x + c = 0</code>:</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>Write a JavaScript function <code>quadraticRootsImpl</code> and a wrapper <code>quadraticRoots :: Quadratic -&gt; Pair Complex</code> that uses the quadratic formula to find the roots of this polynomial. Return the two roots as a <code>Pair</code> of <code>Complex</code> numbers. <em>Hint:</em> Use the <code>quadraticRoots</code> wrapper to pass a constructor for <code>Pair</code> to <code>quadraticRootsImpl</code>.</p>
</li>
<li>
<p>(Medium) Write the function <code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>. This function converts <code>undefined</code> to <code>Nothing</code> and <code>a</code> values to <code>Just</code>s.</p>
</li>
<li>
<p>(Difficult) With <code>toMaybe</code> in place, we can rewrite <code>maybeHead</code> as</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>Is this a better approach than our previous implementation? <em>Note:</em> There is no unit test for this exercise.</p>
</li>
</ol>
<h2 id="using-type-class-member-functions"><a class="header" href="#using-type-class-member-functions">Using Type Class Member Functions</a></h2>
<p>Just like our earlier guide on passing the <code>Maybe</code> constructor over FFI, this is another case of writing PureScript that calls JavaScript, which in turn calls PureScript functions again. Here we will explore how to pass type class member functions over the FFI.</p>
<p>We start with writing a foreign JavaScript function which expects the appropriate instance of <code>show</code> to match the type of <code>x</code>.</p>
<pre><code class="language-js">export const boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + &quot;!!!&quot;;
</code></pre>
<p>Then we write the matching signature:</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>and a wrapper function that passes the correct instance of <code>show</code>:</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>Alternatively in point-free form:</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>We can then call the wrapper:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 &quot;Hat&quot;)
&quot;(TUPLE 1 \&quot;HAT\&quot;)!!!&quot;
</code></pre>
<p>Here's another example demonstrating passing multiple functions, including a function of multiple arguments (<code>eq</code>):</p>
<pre><code class="language-js">export const showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return &quot;Equivalent&quot;;
  } else {
    return show(a) + &quot; is not equal to &quot; + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
&quot;Nothing is not equal to (Just 5)&quot;
</code></pre>
<h2 id="effectful-functions"><a class="header" href="#effectful-functions">Effectful Functions</a></h2>
<p>Let's extend our <code>bold</code> function to log to the console. Logging is an <code>Effect</code>, and <code>Effect</code>s are represented in JavaScript as a function of zero arguments, <code>()</code> with arrow notation:</p>
<pre><code class="language-js">export const yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + &quot;!!!&quot;);
</code></pre>
<p>The new foreign import is the same as before, except that the return type changed from <code>String</code> to <code>Effect Unit</code>.</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>When testing this in the repl, notice that the string is printed directly to the console (instead of being quoted) and a <code>unit</code> value is returned.</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 &quot;Hat&quot;)
(TUPLE 1 &quot;HAT&quot;)!!!
unit
</code></pre>
<p>There are also <code>EffectFn</code> wrappers from <code>Effect.Uncurried</code>. These are similar to the <code>Fn</code> wrappers from <code>Data.Function.Uncurried</code> that we've already seen. These wrappers let you call uncurried effectful functions in PureScript.</p>
<p>You'd generally only use these if you want to call existing JavaScript library APIs directly, rather than wrapping those APIs in curried functions. So it doesn't make much sense to present an example of uncurried <code>yell</code>, where the JavaScript relies on PureScript type class members, since you wouldn't find that in the existing JavaScript ecosystem.</p>
<p>Instead, we'll modify our previous <code>diagonal</code> example to include logging in addition to returning the result:</p>
<pre><code class="language-js">export const diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log(&quot;Diagonal is &quot; + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="asynchronous-functions"><a class="header" href="#asynchronous-functions">Asynchronous Functions</a></h2>
<p>Promises in JavaScript translate directly to asynchronous effects in PureScript with the help of the <code>aff-promise</code> library. See that library's <a href="https://pursuit.purescript.org/packages/purescript-aff-promise">documentation</a> for more information. We'll just go through a few examples.</p>
<p>Suppose we want to use this JavaScript <code>wait</code> promise (or asynchronous function) in our PureScript project. It may be used to delay execution for <code>ms</code> milliseconds.</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>We just need to export it wrapped as an <code>Effect</code> (function of zero arguments):</p>
<pre><code class="language-js">export const sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>Then import it as follows:</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>We can then run this <code>Promise</code> in an <code>Aff</code> block like so:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
… launchAff_ do
…   log &quot;waiting&quot;
…   sleep 300
…   log &quot;done waiting&quot;
…
waiting
unit
done waiting
</code></pre>
<p>Note that asynchronous logging in the repl just waits to print until the entire block has finished executing. This code behaves more predictably when run with <code>spago test</code> where there is a slight delay <em>between</em> prints.</p>
<p>Let's look at another example where we return a value from a promise. This function is written with <code>async</code> and <code>await</code>, which is just syntactic sugar for promises.</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

export const diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p>Since we're returning a <code>Number</code>, we represent this type in the <code>Promise</code> and <code>Aff</code> wrappers:</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
… launchAff_ do
…   res &lt;- diagonalAsync 300 3.0 4.0
…   logShow res
…
unit
5.0
</code></pre>
<h2 id="exercises-29"><a class="header" href="#exercises-29">Exercises</a></h2>
<p>Exercises for the above sections are still on the ToDo list. If you have any ideas for good exercises, please make a suggestion.</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>There are many reasons to use JSON in an application, for example, it's a common means of communicating with web APIs. This section will discuss other use-cases too, beginning with a technique to improve type safety when passing structural data over the FFI.</p>
<p>Let's revisit our earlier FFI functions <code>cumulativeSums</code> and <code>addComplex</code> and introduce a bug to each:</p>
<pre><code class="language-js">export const cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push(&quot;Broken&quot;); // Bug
  return sums;
};

export const addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>We can use the original type signatures, and the code will still compile, despite the fact that the return types are incorrect.</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>We can even execute the code, which might either produce unexpected results or a runtime error:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>For example, our resulting <code>sums</code> is no-longer a valid <code>Array Int</code>, now that a <code>String</code> is included in the Array. And further operations produce unexpected behavior, rather than an outright error, as the <code>sum</code> of these <code>sums</code> is <code>0</code> rather than <code>10</code>. This could be a difficult bug to track down!</p>
<p>Likewise, there are no errors when calling <code>addComplexBroken</code>; however, accessing the <code>imag</code> field of our <code>Complex</code> result will either produce unexpected behavior (returning <code>NaN</code> instead of <code>7.0</code>), or a non-obvious runtime error.</p>
<p>Let's use JSON to make our PureScript code more impervious to bugs in JavaScript code.</p>
<p>The <code>argonaut</code> library contains the JSON decoding and encoding capabilities we need. That library has excellent <a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">documentation</a>, so we will only cover basic usage in this book.</p>
<p>If we create an alternate foreign import that defines the return type as <code>Json</code>:</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>Note that we're simply pointing to our existing broken functions:</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSumsBroken
export const addComplexJson = addComplexBroken
</code></pre>
<p>And then write a wrapper to decode the returned foreign <code>Json</code> value:</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>Then any values that can't be successfully decoded to our return type appear as a <code>Left</code> error <code>String</code>:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left &quot;Couldn't decode Array (Failed at index 3): Value is not a Number&quot;)

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left &quot;JSON was missing expected field: imag&quot;)
</code></pre>
<p>If we call the working versions, a <code>Right</code> value is returned.</p>
<p>Try this yourself by modifying <code>test/Examples.js</code> with the following change to point to the working versions before running the next repl block.</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSums
export const addComplexJson = addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>Using JSON is also the easiest way to pass other structural types, such as <code>Map</code> and <code>Set</code> through the FFI. Note that since JSON only consists of booleans, numbers, strings, arrays, and objects of other JSON values, we can't write a <code>Map</code> and <code>Set</code> directly in JSON. But we can represent these structures as arrays (assuming the keys and values can also be represented in JSON), and then decode them back to <code>Map</code> or <code>Set</code>.</p>
<p>Here's an example of a foreign function signature that modifies a <code>Map</code> of <code>String</code> keys and <code>Int</code> values, along with the wrapper function that handles JSON encoding and decoding.</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>Note that this is a prime use case for function composition. Both of these alternatives are equivalent to the above:</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>Here is the JavaScript implementation. Note the <code>Array.from</code> step which is necessary to convert the JavaScript <code>Map</code> into a JSON-friendly format before decoding converts it back to a PureScript <code>Map</code>.</p>
<pre><code class="language-js">export const mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set(&quot;Foo&quot;, 42);
  return Array.from(m);
};
</code></pre>
<p>Now we can send and receive a <code>Map</code> over the FFI:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple &quot;hat&quot; 1, Tuple &quot;cat&quot; 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple &quot;Foo&quot; 42),(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)]))
</code></pre>
<h2 id="exercises-30"><a class="header" href="#exercises-30">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Write a JavaScript function and PureScript wrapper <code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code> that returns a <code>Set</code> of all the values in a <code>Map</code>. <em>Hint</em>: The <code>.values()</code> instance method for Map may be useful in your JavaScript code.</p>
</li>
<li>
<p>(Easy) Write a new wrapper for the previous JavaScript function with the signature <code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code> so it works with a wider variety of maps. Note that you'll need to add some type class constraints for <code>k</code> and <code>v</code>. The compiler will guide you.</p>
</li>
<li>
<p>(Medium) Rewrite the earlier <code>quadraticRoots</code> function as <code>quadraticRootsSet</code> which returns the <code>Complex</code> roots as a <code>Set</code> via JSON (instead of as a <code>Pair</code>).</p>
</li>
<li>
<p>(Difficult) Rewrite the earlier <code>quadraticRoots</code> function as <code>quadraticRootsSafe</code> which uses JSON to pass the <code>Pair</code> of <code>Complex</code> roots over FFI. Don't use the <code>Pair</code> constructor in JavaScript, but instead, just return the pair in a decoder-compatible format.
<em>Hint</em>: You'll need to write a <code>DecodeJson</code> instance for <code>Pair</code>. Consult the <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonaut docs</a> for instruction on writing your own decode instance. Their <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a> instance may also be a helpful reference.  Note that you'll need a <code>newtype</code> wrapper for <code>Pair</code> to avoid creating an &quot;orphan instance&quot;.</p>
</li>
<li>
<p>(Medium) Write a <code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code> function to parse and decode a JSON string containing a 2D array, such as <code>&quot;[[1, 2, 3], [4, 5], [6]]&quot;</code>. <em>Hint</em>: You'll need to use <code>jsonParser</code> to convert the <code>String</code> into <code>Json</code> before decoding.</p>
</li>
<li>
<p>(Medium) The following data type represents a binary tree with values at the leaves:</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>Derive generic <code>EncodeJson</code> and <code>DecodeJson</code> instances for the <code>Tree</code> type.
Consult the <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonaut docs</a> for instructions on how to do this.
Note that you'll also need generic instances of <code>Show</code> and <code>Eq</code> to enable unit testing for this exercise, but those should be straightforward to implement after tackling the JSON instances.</p>
</li>
<li>
<p>(Difficult) The following <code>data</code> type should be represented directly in JSON as either an integer or a string:</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>Write instances of <code>EncodeJson</code> and <code>DecodeJson</code> for the <code>IntOrString</code> data type which implement this behavior. <em>Hint</em>: The <code>alt</code> operator from <code>Control.Alt</code> may be helpful.</p>
</li>
</ol>
<h2 id="address-book"><a class="header" href="#address-book">Address book</a></h2>
<p>In this section we will apply our newly-acquired FFI and JSON knowledge to build on our address book example from chapter 8. We will add the following features:</p>
<ul>
<li>A Save button at the bottom of the form that, when clicked, serializes the state of the form to JSON and saves it in local storage.</li>
<li>Automatic retrieval of the JSON document from local storage upon page reload. The form fields are populated with the contents of this document.</li>
<li>A pop-up alert if there is an issue saving or loading the form state.</li>
</ul>
<p>We'll start by creating FFI wrappers for the following Web Storage APIs in our <code>Effect.Storage</code> module:</p>
<ul>
<li><code>setItem</code> takes a key and a value (both strings), and returns a computation which stores (or updates) the value in local storage at the specified key.</li>
<li><code>getItem</code> takes a key, and attempts to retrieve the associated value from local storage. However, since the <code>getItem</code> method on <code>window.localStorage</code> can return <code>null</code>, the return type is not <code>String</code>, but <code>Json</code>.</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>Here is the corresponding JavaScript implementation of these functions in <code>Effect/Storage.js</code>:</p>
<pre><code class="language-js">export const setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

export const getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>We'll create a save button like so:</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: &quot;form-group row col-form-label&quot;
    , children:
        [ D.button
            { className: &quot;btn-primary btn&quot;
            , onClick: handler_ validateAndSave
            , children: [ D.text &quot;Save&quot; ]
            }
        ]
    }
</code></pre>
<p>And write our validated <code>person</code> as a JSON string with <code>setItem</code> in the <code>validateAndSave</code> function:</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log &quot;Running validators&quot;
  case validatePerson' person of
    Left errs -&gt; log $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;
    Right validPerson -&gt; do
      setItem &quot;person&quot; $ stringify $ encodeJson validPerson
      log &quot;Saved&quot;
</code></pre>
<p>Note that if we attempt to compile at this stage, we'll encounter the following error:</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>This is because <code>PhoneType</code> in the <code>Person</code> record needs an <code>EncodeJson</code> instance. We'll just derive a generic encode instance, and a decode instance too while we're at it. More information how this works is available in the argonaut docs:</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance genericPhoneType :: Generic PhoneType _

instance encodeJsonPhoneType :: EncodeJson PhoneType where encodeJson = genericEncodeJson
instance decodeJsonPhoneType :: DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>Now we can save our <code>person</code> to local storage, but this isn't very useful unless we can retrieve the data. We'll tackle that next.</p>
<p>We'll start with retrieving the &quot;person&quot; string from local storage:</p>
<pre><code class="language-hs">item &lt;- getItem &quot;person&quot;
</code></pre>
<p>Then we'll create a helper function to handle converting the string from local storage to our <code>Person</code> record. Note that this string in storage may be <code>null</code>, so we represent it as a foreign <code>Json</code> until it is successfully decoded as a <code>String</code>. There are a number of other conversion steps along the way - each of which return an <code>Either</code> value, so it makes sense to organize these together in a <code>do</code> block.</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>Then we inspect this result to see if it succeeded. If it failed, we'll log the errors and use our default <code>examplePerson</code>, otherwise we'll use the person retrieved from local storage.</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>Finally, we'll pass this <code>initialPerson</code> to our component via the <code>props</code> record:</p>
<pre><code class="language-hs">-- Create JSX node from react component.
app = element addressBookApp { initialPerson }
</code></pre>
<p>And pick it up on the other side to use in our state hook:</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>As a finishing touch, we'll improve the quality of our error messages by appending to the <code>String</code> of each <code>Left</code> value with <code>lmap</code>.</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap (&quot;No string in local storage: &quot; &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap (&quot;Cannot parse JSON string: &quot;   &lt;&gt; _) $ jsonParser jsonString
  lmap               (&quot;Cannot decode Person: &quot;       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>Only the first error should ever occur during normal operation of this app. You can trigger the other errors by opening your web browser's dev tools, editing the saved &quot;person&quot; string in local storage, and refreshing the page. How you modify the JSON string determines which error is triggered. See if you can trigger each of them.</p>
<p>That covers local storage. Next we'll implement the <code>alert</code> action, which is very similar to the <code>log</code> action from the <code>Effect.Console</code> module. The only difference is that the <code>alert</code> action uses the <code>window.alert</code> method, whereas the <code>log</code> action uses the <code>console.log</code> method. As such, <code>alert</code> can only be used in environments where <code>window.alert</code> is defined, such as a web browser.</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">export const alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>We want this alert to appear when either:</p>
<ul>
<li>A user attempts to save a form with validation errors.</li>
<li>The state cannot be retrieved from local storage.</li>
</ul>
<p>That is accomplished by simply replacing <code>log</code> with <code>alert</code> on these lines:</p>
<pre><code class="language-hs">Left errs -&gt; alert $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;

alert $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
</code></pre>
<h2 id="exercises-31"><a class="header" href="#exercises-31">Exercises</a></h2>
<ol>
<li>(Easy) Write a wrapper for the <code>removeItem</code> method on the <code>localStorage</code> object, and add your foreign function to the <code>Effect.Storage</code> module.</li>
<li>(Medium) Add a &quot;Reset&quot; button that, when clicked, calls the newly-created <code>removeItem</code> function to delete the &quot;person&quot; entry from local storage.</li>
<li>(Easy) Write a wrapper for the <code>confirm</code> method on the JavaScript <code>Window</code> object, and add your foreign function to the <code>Effect.Alert</code> module.</li>
<li>(Medium) Call this <code>confirm</code> function when a users clicks the &quot;Reset&quot; button to ask if they're sure they want to reset their address book.</li>
</ol>
<h2 id="conclusion-8"><a class="header" href="#conclusion-8">Conclusion</a></h2>
<p>In this chapter, we've learned how to work with foreign JavaScript code from PureScript and we've seen the issues involved with writing trustworthy code using the FFI:</p>
<ul>
<li>We've seen the importance of ensuring that foreign functions have correct representations.</li>
<li>We learned how to deal with corner cases like null values and other types of JavaScript data, by using foreign types, or the <code>Json</code> data type.</li>
<li>We saw how to safely serialize and deserialize JSON data.</li>
</ul>
<p>For more examples, the <code>purescript</code>, <code>purescript-contrib</code> and <code>purescript-node</code> GitHub organizations provide plenty of examples of libraries which use the FFI. In the remaining chapters, we will see some of these libraries put to use to solve real-world problems in a type-safe way.</p>
<h2 id="addendum"><a class="header" href="#addendum">Addendum</a></h2>
<h3 id="calling-purescript-from-javascript"><a class="header" href="#calling-purescript-from-javascript">Calling PureScript from JavaScript</a></h3>
<p>Calling a PureScript function from JavaScript is very simple, at least for functions with simple types.</p>
<p>Let's take the following simple module as an example:</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>This function finds the greatest common divisor of two numbers by repeated subtraction. It is a nice example of a case where you might like to use PureScript to define the function, but have a requirement to call it from JavaScript: it is simple to define this function in PureScript using pattern matching and recursion, and the implementor can benefit from the use of the type checker.</p>
<p>To understand how this function can be called from JavaScript, it is important to realize that PureScript functions always get turned into JavaScript functions of a single argument, so we need to apply its arguments one-by-one:</p>
<pre><code class="language-javascript">import Test from 'Test.js';
Test.gcd(15)(20);
</code></pre>
<p>Here, I am assuming that the code was compiled with <code>spago build</code>, which compiles PureScript modules to ES modules. For that reason, I was able to reference the <code>gcd</code> function on the <code>Test</code> object, after importing the <code>Test</code> module using <code>import</code>.</p>
<p>You might also like to bundle JavaScript code for the browser, using <code>spago bundle-app --to file.js</code>. In that case, you would access the <code>Test</code> module from the global PureScript namespace, which defaults to <code>PS</code>:</p>
<pre><code class="language-javascript">var Test = PS.Test;
Test.gcd(15)(20);
</code></pre>
<h3 id="understanding-name-generation"><a class="header" href="#understanding-name-generation">Understanding Name Generation</a></h3>
<p>PureScript aims to preserve names during code generation as much as possible. In particular, most identifiers which are neither PureScript nor JavaScript keywords can be expected to be preserved, at least for names of top-level declarations.</p>
<p>If you decide to use a JavaScript keyword as an identifier, the name will be escaped with a double dollar symbol. For example,</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>In addition, if you would like to use special characters in your identifier names, they will be escaped using a single dollar symbol. For example,</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>Where compiled PureScript code is intended to be called from JavaScript, it is recommended that identifiers only use alphanumeric characters, and avoid JavaScript keywords. If user-defined operators are provided for use in PureScript code, it is good practice to provide an alternative function with an alphanumeric name for use in JavaScript.</p>
<h3 id="runtime-data-representation"><a class="header" href="#runtime-data-representation">Runtime Data Representation</a></h3>
<p>Types allow us to reason at compile-time that our programs are &quot;correct&quot; in some sense - that is, they will not break at runtime. But what does that mean? In PureScript, it means that the type of an expression should be compatible with its representation at runtime.</p>
<p>For that reason, it is important to understand the representation of data at runtime to be able to use PureScript and JavaScript code together effectively. This means that for any given PureScript expression, we should be able to understand the behavior of the value it will evaluate to at runtime.</p>
<p>The good news is that PureScript expressions have particularly simple representations at runtime. It should always be possible to understand the runtime data representation of an expression by considering its type.</p>
<p>For simple types, the correspondence is almost trivial. For example, if an expression has the type <code>Boolean</code>, then its value <code>v</code> at runtime should satisfy <code>typeof v === 'boolean'</code>. That is, expressions of type <code>Boolean</code> evaluate to one of the (JavaScript) values <code>true</code> or <code>false</code>. In particular, there is no PureScript expression of type <code>Boolean</code> which evaluates to <code>null</code> or <code>undefined</code>.</p>
<p>A similar law holds for expressions of type <code>Int</code>, <code>Number</code>, and <code>String</code> - expressions of type <code>Int</code> or <code>Number</code> evaluate to non-null JavaScript numbers, and expressions of type <code>String</code> evaluate to non-null JavaScript strings. Expressions of type <code>Int</code> will evaluate to integers at runtime, even though they cannot be distinguished from values of type <code>Number</code> by using <code>typeof</code>.</p>
<p>What about <code>Unit</code>? Well, since <code>Unit</code> has only one inhabitant (<code>unit</code>) and its value is not observable, it doesn't actually matter what it's represented with at runtime. Old code tends to represent it using <code>{}</code>. Newer code, however, tends to use <code>undefined</code>. So, although it doesn't really matter what you use to represent <code>Unit</code>, it is recommended to use <code>undefined</code> (not returning anything from a function also returns <code>undefined</code>).</p>
<p>What about some more complex types?</p>
<p>As we have already seen, PureScript functions correspond to JavaScript functions of a single argument. More precisely, if an expression <code>f</code> has type <code>a -&gt; b</code> for some types <code>a</code> and <code>b</code>, and an expression <code>x</code> evaluates to a value with the correct runtime representation for type <code>a</code>, then <code>f</code> evaluates to a JavaScript function, which when applied to the result of evaluating <code>x</code>, has the correct runtime representation for type <code>b</code>. As a simple example, an expression of type <code>String -&gt; String</code> evaluates to a function which takes non-null JavaScript strings to non-null JavaScript strings.</p>
<p>As you might expect, PureScript's arrays correspond to JavaScript arrays. But remember - PureScript arrays are homogeneous, so every element has the same type. Concretely, if a PureScript expression <code>e</code> has type <code>Array a</code> for some type <code>a</code>, then <code>e</code> evaluates to a (non-null) JavaScript array, all of whose elements have the correct runtime representation for type <code>a</code>.</p>
<p>We've already seen that PureScript's records evaluate to JavaScript objects. Just as for functions and arrays, we can reason about the runtime representation of data in a record's fields by considering the types associated with its labels. Of course, the fields of a record are not required to be of the same type.</p>
<h3 id="representing-adts"><a class="header" href="#representing-adts">Representing ADTs</a></h3>
<p>For every constructor of an algebraic data type, the PureScript compiler creates a new JavaScript object type by defining a function. Its constructors correspond to functions which create new JavaScript objects based on those prototypes.</p>
<p>For example, consider the following simple ADT:</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>The PureScript compiler generates the following code:</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>Here, we see two JavaScript object types: <code>Zero</code> and <code>One</code>. It is possible to create values of each type by using JavaScript's <code>new</code> keyword. For constructors with arguments, the compiler stores the associated data in fields called <code>value0</code>, <code>value1</code>, etc.</p>
<p>The PureScript compiler also generates helper functions. For constructors with no arguments, the compiler generates a <code>value</code> property, which can be reused instead of using the <code>new</code> operator repeatedly. For constructors with one or more arguments, the compiler generates a <code>create</code> function, which takes arguments with the appropriate representation and applies the appropriate constructor.</p>
<p>What about constructors with more than one argument? In that case, the PureScript compiler also creates a new object type, and a helper function. This time, however, the helper function is curried function of two arguments. For example, this algebraic data type:</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>generates this JavaScript code:</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>Here, values of the object type <code>Two</code> can be created using the <code>new</code> keyword, or by using the <code>Two.create</code> function.</p>
<p>The case of newtypes is slightly different. Recall that a newtype is like an algebraic data type, restricted to having a single constructor taking a single argument. In this case, the runtime representation of the newtype is actually the same as the type of its argument.</p>
<p>For example, this newtype representing telephone numbers:</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>is actually represented as a JavaScript string at runtime. This is useful for designing libraries, since newtypes provide an additional layer of type safety, but without the runtime overhead of another function call.</p>
<h3 id="representing-quantified-types"><a class="header" href="#representing-quantified-types">Representing Quantified Types</a></h3>
<p>Expressions with quantified (polymorphic) types have restrictive representations at runtime. In practice, this means that there are relatively few expressions with a given quantified type, but that we can reason about them quite effectively.</p>
<p>Consider this polymorphic type, for example:</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>What sort of functions have this type? Well, there is certainly one function with this type - namely, the <code>identity</code> function, defined in the <code>Prelude</code>:</p>
<pre><code class="language-haskell">id :: forall a. a -&gt; a
id a = a
</code></pre>
<p>In fact, the <code>identity</code> function is the <em>only</em> (total) function with this type! This certainly seems to be the case (try writing an expression with this type which is not observably equivalent to <code>identity</code>), but how can we be sure? We can be sure by considering the runtime representation of the type.</p>
<p>What is the runtime representation of a quantified type <code>forall a. t</code>? Well, any expression with the runtime representation for this type must have the correct runtime representation for the type <code>t</code> for any choice of type <code>a</code>. In our example above, a function of type <code>forall a. a -&gt; a</code> must have the correct runtime representation for the types <code>String -&gt; String</code>, <code>Number -&gt; Number</code>, <code>Array Boolean -&gt; Array Boolean</code>, and so on. It must take strings to strings, numbers to numbers, etc.</p>
<p>But that is not enough - the runtime representation of a quantified type is more strict than this. We require any expression to be <em>parametrically polymorphic</em> - that is, it cannot use any information about the type of its argument in its implementation. This additional condition prevents problematic implementations such as the following JavaScript function from inhabiting a polymorphic type:</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>Certainly, this function takes strings to strings, numbers to numbers, etc. but it does not meet the additional condition, since it inspects the (runtime) type of its argument, so this function would not be a valid inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>Without being able to inspect the runtime type of our function argument, our only option is to return the argument unchanged, and so <code>identity</code> is indeed the only inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>A full discussion of <em>parametric polymorphism</em> and <em>parametricity</em> is beyond the scope of this book. Note however, that since PureScript's types are <em>erased</em> at runtime, a polymorphic function in PureScript <em>cannot</em> inspect the runtime representation of its arguments (without using the FFI), and so this representation of polymorphic data is appropriate.</p>
<h3 id="representing-constrained-types"><a class="header" href="#representing-constrained-types">Representing Constrained Types</a></h3>
<p>Functions with a type class constraint have an interesting representation at runtime. Because the behavior of the function might depend on the type class instance chosen by the compiler, the function is given an additional argument, called a <em>type class dictionary</em>, which contains the implementation of the type class functions provided by the chosen instance.</p>
<p>For example, here is a simple PureScript function with a constrained type which uses the <code>Show</code> type class:</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>The generated JavaScript looks like this:</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p>Notice that <code>shout</code> is compiled to a (curried) function of two arguments, not one. The first argument <code>dict</code> is the type class dictionary for the <code>Show</code> constraint. <code>dict</code> contains the implementation of the <code>show</code> function for the type <code>a</code>.</p>
<p>We can call this function from JavaScript by passing an explicit type class dictionary from <code>Data.Show</code> as the first parameter:</p>
<pre><code class="language-javascript">import { showNumber } from 'Data.Show'

shout(showNumber)(42);
</code></pre>
<h3 id="exercises-32"><a class="header" href="#exercises-32">Exercises</a></h3>
<ol>
<li>
<p>(Easy) What are the runtime representations of these types?</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>What can you say about the expressions which have these types?</p>
</li>
<li>
<p>(Medium) Try using the functions defined in the <code>arrays</code> package, calling them from JavaScript, by compiling the library using <code>spago build</code> and importing modules using the <code>import</code> function in NodeJS. <em>Hint</em>: you may need to configure the output path so that the generated ES modules are available on the NodeJS module path.</p>
</li>
</ol>
<h3 id="representing-side-effects"><a class="header" href="#representing-side-effects">Representing Side Effects</a></h3>
<p>The <code>Effect</code> monad is also defined as a foreign type. Its runtime representation is quite simple - an expression of type <code>Effect a</code> should evaluate to a JavaScript function of <strong>no arguments</strong>, which performs any side-effects and returns a value with the correct runtime representation for type <code>a</code>.</p>
<p>The definition of the <code>Effect</code> type constructor is given in the <code>Effect</code> module as follows:</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>As a simple example, consider the <code>random</code> function defined in the <code>random</code> package. Recall that its type was:</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p>The definition of the <code>random</code> function is given here:</p>
<pre><code class="language-javascript">export const random = Math.random;
</code></pre>
<p>Notice that the <code>random</code> function is represented at runtime as a function of no arguments. It performs the side effect of generating a random number, and returns it, and the return value matches the runtime representation of the <code>Number</code> type: it is a non-null JavaScript number.</p>
<p>As a slightly more interesting example, consider the <code>log</code> function defined by the <code>Effect.Console</code> module in the <code>console</code> package. The <code>log</code> function has the following type:</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>And here is its definition:</p>
<pre><code class="language-javascript">export const log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>The representation of <code>log</code> at runtime is a JavaScript function of a single argument, returning a function of no arguments. The inner function performs the side-effect of writing a message to the console.</p>
<p>Expressions of type <code>Effect a</code> can be invoked from JavaScript like regular JavaScript methods. For example, since the <code>main</code> function is required to have type <code>Effect a</code> for some type <code>a</code>, it can be invoked as follows:</p>
<pre><code class="language-javascript">import { main } from 'Main'

main();
</code></pre>
<p>When using <code>spago bundle-app --to</code> or <code>spago run</code>, this call to <code>main</code> is generated automatically, whenever the <code>Main</code> module is defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monadic-adventures"><a class="header" href="#monadic-adventures">Monadic Adventures</a></h1>
<h2 id="chapter-goals-9"><a class="header" href="#chapter-goals-9">Chapter Goals</a></h2>
<p>The goal of this chapter will be to learn about <em>monad transformers</em>, which provide a way to combine side-effects provided by different monads. The motivating example will be a text adventure game which can be played on the console in NodeJS. The various side-effects of the game (logging, state, and configuration) will all be provided by a monad transformer stack.</p>
<h2 id="project-setup-8"><a class="header" href="#project-setup-8">Project Setup</a></h2>
<p>This module's project introduces the following new dependencies:</p>
<ul>
<li><code>ordered-collections</code>, which provides data types for immutable maps and sets</li>
<li><code>transformers</code>, which provides implementations of standard monad transformers</li>
<li><code>node-readline</code>, which provides FFI bindings to the <a href="https://nodejs.org/api/readline.html"><code>readline</code></a> interface provided by NodeJS</li>
<li><code>optparse</code>, which provides applicative parsers for processing command line arguments</li>
</ul>
<h2 id="how-to-play-the-game"><a class="header" href="#how-to-play-the-game">How To Play The Game</a></h2>
<p>To run the project, use <code>spago run</code></p>
<p>By default you will see a usage message:</p>
<pre><code class="language-text">Monadic Adventures! A game to learn monad transformers

Usage: run.js (-p|--player &lt;player name&gt;) [-d|--debug]
  Play the game as &lt;player name&gt;

Available options:
  -p,--player &lt;player name&gt;
                           The player's name &lt;String&gt;
  -d,--debug               Use debug mode
  -h,--help                Show this help text
</code></pre>
<p>To provide command line arguments, you can either call <code>spago run</code> with the <code>-a</code> option to pass additional arguments directly to your application, or you can call <code>spago bundle-app</code>, which will create an index.js file that can be run directly with <code>node</code>.<br />
For example, to provide the player name using the <code>-p</code> option:</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;
&gt;
</code></pre>
<pre><code class="language-text">$ spago bundle-app 
$ node index.js -p Phil
&gt;
</code></pre>
<p>From the prompt, you can enter commands like <code>look</code>, <code>inventory</code>, <code>take</code>, <code>use</code>, <code>north</code>, <code>south</code>, <code>east</code>, and <code>west</code>. There is also a <code>debug</code> command, which can be used to print the game state when the <code>--debug</code> command line option is provided.</p>
<p>The game is played on a two-dimensional grid, and the player moves by issuing commands <code>north</code>, <code>south</code>, <code>east</code>, and <code>west</code>. The game contains a collection of items which can either be in the player's possession (in the user's <em>inventory</em>), or on the game grid at some location. Items can be picked up by the player, using the <code>take</code> command.</p>
<p>For reference, here is a complete walkthrough of the game:</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre>
<p>The game is very simple, but the aim of the chapter is to use the <code>transformers</code> package to build a library which will enable rapid development of this type of game.</p>
<h2 id="the-state-monad"><a class="header" href="#the-state-monad">The State Monad</a></h2>
<p>We will start by looking at some of the monads provided by the <code>transformers</code> package.</p>
<p>The first example is the <code>State</code> monad, which provides a way to model <em>mutable state</em> in pure code. We have already seen an approach to mutable state provided by the <code>Effect</code> monad. <code>State</code> provides an alternative.</p>
<p>The <code>State</code> type constructor takes two type parameters: the type <code>s</code> of the state, and the return type <code>a</code>. Even though we speak of the &quot;<code>State</code> monad&quot;, the instance of the <code>Monad</code> type class is actually provided for the <code>State s</code> type constructor, for any type <code>s</code>.</p>
<p>The <code>Control.Monad.State</code> module provides the following API:</p>
<pre><code class="language-haskell">get     :: forall s.             State s s
gets    :: forall s. (s -&gt; a) -&gt; State s a
put     :: forall s. s        -&gt; State s Unit
modify  :: forall s. (s -&gt; s) -&gt; State s s
modify_ :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>Note that these API signatures are presented in a simplified form using the <code>State</code> type constructor for now. The actual API involves <code>MonadState</code> which we'll cover in the later &quot;Type Classes&quot; section of this chapter, so don't worry if you see different signatures in your IDE tooltips or on Pursuit.</p>
<p>Let's see an example. One use of the <code>State</code> monad might be to add the values in an array of integers to the current state. We could do that by choosing <code>Int</code> as the state type <code>s</code>, and using <code>traverse_</code> to traverse the array, with a call to <code>modify</code> for each array element:</p>
<pre><code class="language-haskell">import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class

sumArray :: Array Int -&gt; State Int Unit
sumArray = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre>
<p>The <code>Control.Monad.State</code> module provides three functions for running a computation in the <code>State</code> monad:</p>
<pre><code class="language-haskell">evalState :: forall s a. State s a -&gt; s -&gt; a
execState :: forall s a. State s a -&gt; s -&gt; s
runState  :: forall s a. State s a -&gt; s -&gt; Tuple a s
</code></pre>
<p>Each of these functions takes an initial state of type <code>s</code> and a computation of type <code>State s a</code>. <code>evalState</code> only returns the return value, <code>execState</code> only returns the final state, and <code>runState</code> returns both, expressed as a value of type <code>Tuple a s</code>.</p>
<p>Given the <code>sumArray</code> function above, we could use <code>execState</code> in PSCi to sum the numbers in several arrays as follows:</p>
<pre><code class="language-text">&gt; :paste
… execState (do
…   sumArray [1, 2, 3]
…   sumArray [4, 5]
…   sumArray [6]) 0
… ^D
21
</code></pre>
<h2 id="exercises-33"><a class="header" href="#exercises-33">Exercises</a></h2>
<ol>
<li>
<p>(Easy) What is the result of replacing <code>execState</code> with <code>runState</code> or <code>evalState</code> in our example above?</p>
</li>
<li>
<p>(Medium) A string of parentheses is <em>balanced</em> if it is obtained by either concatenating zero-or-more shorter balanced
strings, or by wrapping a shorter balanced string in a pair of parentheses.</p>
<p>Use the <code>State</code> monad and the <code>traverse_</code> function to write a function</p>
<pre><code class="language-haskell">testParens :: String -&gt; Boolean
</code></pre>
<p>which tests whether or not a <code>String</code> of parentheses is balanced, by keeping track of the number of opening parentheses
which have not been closed. Your function should work as follows:</p>
<pre><code class="language-text">&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false
</code></pre>
<p><em>Hint</em>: you may like to use the <code>toCharArray</code> function from the <code>Data.String.CodeUnits</code> module to turn the input string into an array of characters.</p>
</li>
</ol>
<h2 id="the-reader-monad"><a class="header" href="#the-reader-monad">The Reader Monad</a></h2>
<p>Another monad provided by the <code>transformers</code> package is the <code>Reader</code> monad. This monad provides the ability to read from a global configuration. Whereas the <code>State</code> monad provides the ability to read and write a single piece of mutable state, the <code>Reader</code> monad only provides the ability to read a single piece of data.</p>
<p>The <code>Reader</code> type constructor takes two type arguments: a type <code>r</code> which represents the configuration type, and the return type <code>a</code>.</p>
<p>The <code>Control.Monad.Reader</code> module provides the following API:</p>
<pre><code class="language-haskell">ask   :: forall r. Reader r r
local :: forall r a. (r -&gt; r) -&gt; Reader r a -&gt; Reader r a
</code></pre>
<p>The <code>ask</code> action can be used to read the current configuration, and the <code>local</code> action can be used to run a computation with a modified configuration.</p>
<p>For example, suppose we were developing an application controlled by permissions, and we wanted to use the <code>Reader</code> monad to hold the current user's permissions object. We might choose the type <code>r</code> to be some type <code>Permissions</code> with the following API:</p>
<pre><code class="language-haskell">hasPermission :: String -&gt; Permissions -&gt; Boolean
addPermission :: String -&gt; Permissions -&gt; Permissions
</code></pre>
<p>Whenever we wanted to check if the user had a particular permission, we could use <code>ask</code> to retrieve the current permissions object. For example, only administrators might be allowed to create new users:</p>
<pre><code class="language-haskell">createUser :: Reader Permissions (Maybe User)
createUser = do
  permissions &lt;- ask
  if hasPermission &quot;admin&quot; permissions
    then map Just newUser
    else pure Nothing
</code></pre>
<p>To elevate the user's permissions, we might use the <code>local</code> action to modify the <code>Permissions</code> object during the execution of some computation:</p>
<pre><code class="language-haskell">runAsAdmin :: forall a. Reader Permissions a -&gt; Reader Permissions a
runAsAdmin = local (addPermission &quot;admin&quot;)
</code></pre>
<p>Then we could write a function to create a new user, even if the user did not have the <code>admin</code> permission:</p>
<pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre>
<p>To run a computation in the <code>Reader</code> monad, the <code>runReader</code> function can be used to provide the global configuration:</p>
<pre><code class="language-haskell">runReader :: forall r a. Reader r a -&gt; r -&gt; a
</code></pre>
<h2 id="exercises-34"><a class="header" href="#exercises-34">Exercises</a></h2>
<p>In these exercises, we will use the <code>Reader</code> monad to build a small library for rendering documents with indentation. The &quot;global configuration&quot; will be a number indicating the current indentation level:</p>
<pre><code class="language-haskell">type Level = Int

type Doc = Reader Level String
</code></pre>
<ol>
<li>
<p>(Easy) Write a function <code>line</code> which renders a function at the current indentation level. Your function should have the following type:</p>
<pre><code class="language-haskell">line :: String -&gt; Doc
</code></pre>
<p><em>Hint</em>: use the <code>ask</code> function to read the current indentation level. The <code>power</code> function from <code>Data.Monoid</code> may be helpful too.</p>
</li>
<li>
<p>(Easy) Use the <code>local</code> function to write a function</p>
<pre><code class="language-haskell">indent :: Doc -&gt; Doc
</code></pre>
<p>which increases the indentation level for a block of code.</p>
</li>
<li>
<p>(Medium) Use the <code>sequence</code> function defined in <code>Data.Traversable</code> to write a function</p>
<pre><code class="language-haskell">cat :: Array Doc -&gt; Doc
</code></pre>
<p>which concatenates a collection of documents, separating them with new lines.</p>
</li>
<li>
<p>(Medium) Use the <code>runReader</code> function to write a function</p>
<pre><code class="language-haskell">render :: Doc -&gt; String
</code></pre>
<p>which renders a document as a String.</p>
</li>
</ol>
<p>You should now be able to use your library to write simple documents, as follows:</p>
<pre><code class="language-haskell">render $ cat
  [ line &quot;Here is some indented text:&quot;
  , indent $ cat
      [ line &quot;I am indented&quot;
      , line &quot;So am I&quot;
      , indent $ line &quot;I am even more indented&quot;
      ]
  ]
</code></pre>
<h2 id="the-writer-monad"><a class="header" href="#the-writer-monad">The Writer Monad</a></h2>
<p>The <code>Writer</code> monad provides the ability to accumulate a secondary value in addition to the return value of a computation.</p>
<p>A common use case is to accumulate a log of type <code>String</code> or <code>Array String</code>, but the <code>Writer</code> monad is more general than this. It can actually be used to accumulate a value in any monoid, so it might be used to keep track of an integer total using the <code>Additive Int</code> monoid, or to track whether any of several intermediate <code>Boolean</code> values were true, using the <code>Disj Boolean</code> monoid.</p>
<p>The <code>Writer</code> type constructor takes two type arguments: a type <code>w</code> which should be an instance of the <code>Monoid</code> type class, and the return type <code>a</code>.</p>
<p>The key element of the <code>Writer</code> API is the <code>tell</code> function:</p>
<pre><code class="language-haskell">tell :: forall w a. Monoid w =&gt; w -&gt; Writer w Unit
</code></pre>
<p>The <code>tell</code> action appends the provided value to the current accumulated result.</p>
<p>As an example, let's add a log to an existing function by using the <code>Array String</code> monoid. Consider our previous implementation of the <em>greatest common divisor</em> function:</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>We could add a log to this function by changing the return type to <code>Writer (Array String) Int</code>:</p>
<pre><code class="language-haskell">import Control.Monad.Writer
import Control.Monad.Writer.Class

gcdLog :: Int -&gt; Int -&gt; Writer (Array String) Int
</code></pre>
<p>We only have to change our function slightly to log the two inputs at each step:</p>
<pre><code class="language-haskell">    gcdLog n 0 = pure n
    gcdLog 0 m = pure m
    gcdLog n m = do
      tell [&quot;gcdLog &quot; &lt;&gt; show n &lt;&gt; &quot; &quot; &lt;&gt; show m]
      if n &gt; m
        then gcdLog (n - m) m
        else gcdLog n (m - n)
</code></pre>
<p>We can run a computation in the <code>Writer</code> monad by using either of the <code>execWriter</code> or <code>runWriter</code> functions:</p>
<pre><code class="language-haskell">execWriter :: forall w a. Writer w a -&gt; w
runWriter  :: forall w a. Writer w a -&gt; Tuple a w
</code></pre>
<p>Just like in the case of the <code>State</code> monad, <code>execWriter</code> only returns the accumulated log, whereas <code>runWriter</code> returns both the log and the result.</p>
<p>We can test our modified function in PSCi:</p>
<pre><code class="language-text">&gt; import Control.Monad.Writer
&gt; import Control.Monad.Writer.Class

&gt; runWriter (gcdLog 21 15)
Tuple 3 [&quot;gcdLog 21 15&quot;,&quot;gcdLog 6 15&quot;,&quot;gcdLog 6 9&quot;,&quot;gcdLog 6 3&quot;,&quot;gcdLog 3 3&quot;]
</code></pre>
<h2 id="exercises-35"><a class="header" href="#exercises-35">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Rewrite the <code>sumArray</code> function above using the <code>Writer</code> monad and the <code>Additive Int</code> monoid from the <code>monoid</code> package.</p>
</li>
<li>
<p>(Medium) The <em>Collatz</em> function is defined on natural numbers <code>n</code> as <code>n / 2</code> when <code>n</code> is even, and <code>3 * n + 1</code> when <code>n</code> is odd. For example, the iterated Collatz sequence starting at <code>10</code> is as follows:</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>It is conjectured that the iterated Collatz sequence always reaches <code>1</code> after some finite number of applications of the Collatz function.</p>
<p>Write a function which uses recursion to calculate how many iterations of the Collatz function are required before the sequence reaches <code>1</code>.</p>
<p>Modify your function to use the <code>Writer</code> monad to log each application of the Collatz function.</p>
</li>
</ol>
<h2 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h2>
<p>Each of the three monads above: <code>State</code>, <code>Reader</code> and <code>Writer</code>, are also examples of so-called <em>monad transformers</em>. The equivalent monad transformers are called <code>StateT</code>, <code>ReaderT</code>, and <code>WriterT</code> respectively.</p>
<p>What is a monad transformer? Well, as we have seen, a monad augments PureScript code with some type of side effect, which can be interpreted in PureScript by using the appropriate handler (<code>runState</code>, <code>runReader</code>, <code>runWriter</code>, etc.) This is fine if we only need to use <em>one</em> side-effect. However, it is often useful to use more than one side-effect at once. For example, we might want to use <code>Reader</code> together with <code>Maybe</code> to express <em>optional results</em> in the context of some global configuration. Or we might want the mutable state provided by the <code>State</code> monad together with the pure error tracking capability of the <code>Either</code> monad. This is the problem solved by <em>monad transformers</em>.</p>
<p>Note that we have already seen that the <code>Effect</code> monad provides a partial solution to this problem. Monad transformers provide another solution, and each approach has its own benefits and limitations.</p>
<p>A monad transformer is a type constructor which is parameterized not only by a type, but by another type constructor. It takes one monad and turns it into another monad, adding its own variety of side-effects.</p>
<p>Let's see an example. The monad transformer version of the <code>State</code> monad is <code>StateT</code>, defined in the <code>Control.Monad.State.Trans</code> module. We can find the kind of <code>StateT</code> using PSCi:</p>
<pre><code class="language-text">&gt; import Control.Monad.State.Trans
&gt; :kind StateT
Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>This looks quite confusing, but we can apply <code>StateT</code> one argument at a time to understand how to use it.</p>
<p>The first type argument is the type of the state we wish to use, as was the case for <code>State</code>. Let's use a state of type <code>String</code>:</p>
<pre><code class="language-text">&gt; :kind StateT String
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>The next argument is a type constructor of kind <code>Type -&gt; Type</code>. It represents the underlying monad, which we want to add the effects of <code>StateT</code> to. For the sake of an example, let's choose the <code>Either String</code> monad:</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String)
Type -&gt; Type
</code></pre>
<p>We are left with a type constructor. The final argument represents the return type, and we might instantiate it to <code>Number</code> for example:</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String) Number
Type
</code></pre>
<p>Finally we are left with something of kind <code>Type</code>, which means we can try to find values of this type.</p>
<p>The monad we have constructed - <code>StateT String (Either String)</code> - represents computations which can fail with an error, and which can use mutable state.</p>
<p>We can use the actions of the outer <code>StateT String</code> monad (<code>get</code>, <code>put</code>, and <code>modify</code>) directly, but in order to use the effects of the wrapped monad (<code>Either String</code>), we need to &quot;lift&quot; them over the monad transformer. The <code>Control.Monad.Trans</code> module defines the <code>MonadTrans</code> type class, which captures those type constructors which are monad transformers, as follows:</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>This class contains a single member, <code>lift</code>, which takes computations in any underlying monad <code>m</code> and lifts them into the wrapped monad <code>t m</code>. In our case, the type constructor <code>t</code> is <code>StateT String</code>, and <code>m</code> is the <code>Either String</code> monad, so <code>lift</code> provides a way to lift computations of type <code>Either String a</code> to computations of type <code>StateT String (Either String) a</code>. This means that we can use the effects of <code>StateT String</code> and <code>Either String</code> side-by-side, as long as we use <code>lift</code> every time we use a computation of type <code>Either String a</code>.</p>
<p>For example, the following computation reads the underlying state, and then throws an error if the state is the empty string:</p>
<pre><code class="language-haskell">import Data.String (drop, take)

split :: StateT String (Either String) String
split = do
  s &lt;- get
  case s of
    &quot;&quot; -&gt; lift $ Left &quot;Empty string&quot;
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>If the state is not empty, the computation uses <code>put</code> to update the state to <code>drop 1 s</code> (that is, <code>s</code> with the first character removed), and returns <code>take 1 s</code> (that is, the first character of <code>s</code>).</p>
<p>Let's try this in PSCi:</p>
<pre><code class="language-text">&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;
</code></pre>
<p>This is not very remarkable, since we could have implemented this without <code>StateT</code>. However, since we are working in a monad, we can use do notation or applicative combinators to build larger computations from smaller ones. For example, we can apply <code>split</code> twice to read the first two characters from a string:</p>
<pre><code class="language-text">&gt; runStateT ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple &quot;te&quot; &quot;st&quot;))
</code></pre>
<p>We can use the <code>split</code> function with a handful of other actions to build a basic parsing library. In fact, this is the approach taken by the <code>parsing</code> library. This is the power of monad transformers - we can create custom-built monads for a variety of problems, choosing the side-effects that we need, and keeping the expressiveness of do notation and applicative combinators.</p>
<h2 id="the-exceptt-monad-transformer"><a class="header" href="#the-exceptt-monad-transformer">The ExceptT Monad Transformer</a></h2>
<p>The <code>transformers</code> package also defines the <code>ExceptT e</code> monad transformer, which is the transformer corresponding to the <code>Either e</code> monad. It provides the following API:</p>
<pre><code class="language-haskell">class MonadError e m where
  throwError :: forall a. e -&gt; m a
  catchError :: forall a. m a -&gt; (e -&gt; m a) -&gt; m a

instance monadErrorExceptT :: Monad m =&gt; MonadError e (ExceptT e m)

runExceptT :: forall e m a. ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p>The <code>MonadError</code> class captures those monads which support throwing and catching of errors of some type <code>e</code>, and an instance is provided for the <code>ExceptT e</code> monad transformer. The <code>throwError</code> action can be used to indicate failure, just like <code>Left</code> in the <code>Either e</code> monad. The <code>catchError</code> action allows us to continue after an error is thrown using <code>throwError</code>.</p>
<p>The <code>runExceptT</code> handler is used to run a computation of type <code>ExceptT e m a</code>.</p>
<p>This API is similar to that provided by the <code>exceptions</code> package and the <code>Exception</code> effect. However, there are some important differences:</p>
<ul>
<li><code>Exception</code> uses actual JavaScript exceptions, whereas <code>ExceptT</code> models errors as a pure data structure.</li>
<li>The <code>Exception</code> effect only supports exceptions of one type, namely JavaScript's <code>Error</code> type, whereas <code>ExceptT</code> supports errors of any type. In particular, we are free to define new error types.</li>
</ul>
<p>Let's try out <code>ExceptT</code> by using it to wrap the <code>Writer</code> monad. Again, we are free to use actions from the monad transformer <code>ExceptT e</code> directly, but computations in the <code>Writer</code> monad should be lifted using <code>lift</code>:</p>
<pre><code class="language-haskell">import Control.Monad.Except
import Control.Monad.Writer

writerAndExceptT :: ExceptT String (Writer (Array String)) String
writerAndExceptT = do
  lift $ tell [&quot;Before the error&quot;]
  _ &lt;- throwError &quot;Error!&quot;
  lift $ tell [&quot;After the error&quot;]
  pure &quot;Return value&quot;
</code></pre>
<p>If we test this function in PSCi, we can see how the two effects of accumulating a log and throwing an error interact. First, we can run the outer <code>ExceptT</code> computation of type by using <code>runExceptT</code>, leaving a result of type <code>Writer (Array String) (Either String String)</code>. We can then use <code>runWriter</code> to run the inner <code>Writer</code> computation:</p>
<pre><code class="language-text">&gt; runWriter $ runExceptT writerAndExceptT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]
</code></pre>
<p>Note that only those log messages which were written before the error was thrown actually get appended to the log.</p>
<h2 id="monad-transformer-stacks"><a class="header" href="#monad-transformer-stacks">Monad Transformer Stacks</a></h2>
<p>As we have seen, monad transformers can be used to build new monads on top of existing monads. For some monad transformer <code>t1</code> and some monad <code>m</code>, the application <code>t1 m</code> is also a monad. That means that we can apply a <em>second</em> monad transformer <code>t2</code> to the result <code>t1 m</code> to construct a third monad <code>t2 (t1 m)</code>. In this way, we can construct a <em>stack</em> of monad transformers, which combine the side-effects provided by their constituent monads.</p>
<p>In practice, the underlying monad <code>m</code> is either the <code>Effect</code> monad, if native side-effects are required, or the <code>Identity</code> monad, defined in the <code>Data.Identity</code> module. The <code>Identity</code> monad adds no new side-effects, so transforming the <code>Identity</code> monad only provides the effects of the monad transformer. In fact, the <code>State</code>, <code>Reader</code> and <code>Writer</code> monads are implemented by transforming the <code>Identity</code> monad with <code>StateT</code>, <code>ReaderT</code> and <code>WriterT</code> respectively.</p>
<p>Let's see an example in which three side effects are combined. We will use the <code>StateT</code>, <code>WriterT</code> and <code>ExceptT</code> effects, with the <code>Identity</code> monad on the bottom of the stack. This monad transformer stack will provide the side effects of mutable state, accumulating a log, and pure errors.</p>
<p>We can use this monad transformer stack to reproduce our <code>split</code> action with the added feature of logging.</p>
<pre><code class="language-haskell">type Errors = Array String

type Log = Array String

type Parser = StateT String (WriterT Log (ExceptT Errors Identity))

split :: Parser String
split = do
  s &lt;- get
  lift $ tell [&quot;The state is &quot; &lt;&gt; s]
  case s of
    &quot;&quot; -&gt; lift $ lift $ throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>If we test this computation in PSCi, we see that the state is appended to the log for every invocation of <code>split</code>.</p>
<p>Note that we have to remove the side-effects in the order in which they appear in the monad transformer stack: first we use <code>runStateT</code> to remove the <code>StateT</code> type constructor, then <code>runWriterT</code>, then <code>runExceptT</code>. Finally, we run the computation in the <code>Identity</code> monad by using <code>unwrap</code>.</p>
<pre><code class="language-text">&gt; runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
(Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;]))

&gt; runParser ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;]))
</code></pre>
<p>However, if the parse is unsuccessful because the state is empty, then no log is printed at all:</p>
<pre><code class="language-text">&gt; runParser split &quot;&quot;
(Left [&quot;Empty string&quot;])
</code></pre>
<p>This is because of the way in which the side-effects provided by the <code>ExceptT</code> monad transformer interact with the side-effects provided by the <code>WriterT</code> monad transformer. We can address this by changing the order in which the monad transformer stack is composed. If we move the <code>ExceptT</code> transformer to the top of the stack, then the log will contain all messages written up until the first error, as we saw earlier when we transformed <code>Writer</code> with <code>ExceptT</code>.</p>
<p>One problem with this code is that we have to use the <code>lift</code> function multiple times to lift computations over multiple monad transformers: for example, the call to <code>throwError</code> has to be lifted twice, once over <code>WriterT</code> and a second time over <code>StateT</code>. This is fine for small monad transformer stacks, but quickly becomes inconvenient.</p>
<p>Fortunately, as we will see, we can use the automatic code generation provided by type class inference to do most of this &quot;heavy lifting&quot; for us.</p>
<h2 id="exercises-36"><a class="header" href="#exercises-36">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use the <code>ExceptT</code> monad transformer over the <code>Identity</code> functor to write a function <code>safeDivide</code> which divides two numbers, throwing an error (as the String &quot;Divide by zero!&quot;) if the denominator is zero.</p>
</li>
<li>
<p>(Medium) Write a parser</p>
<pre><code class="language-haskell">string :: String -&gt; Parser String
</code></pre>
<p>which matches a string as a prefix of the current state, or fails with an error message.</p>
<p>Your parser should work as follows:</p>
<pre><code class="language-text">&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;
(Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;]))
</code></pre>
<p><em>Hint</em>: you can use the implementation of <code>split</code> as a starting point. You might find the <code>stripPrefix</code> function useful.</p>
</li>
<li>
<p>(Difficult) Use the <code>ReaderT</code> and <code>WriterT</code> monad transformers to reimplement the document printing library which we wrote earlier using the <code>Reader</code> monad.</p>
<p>Instead of using <code>line</code> to emit strings and <code>cat</code> to concatenate strings, use the <code>Array String</code> monoid with the <code>WriterT</code> monad transformer, and <code>tell</code> to append a line to the result. Use the same names as in the original implementation but ending with an apostrophe (<code>'</code>).</p>
</li>
</ol>
<h2 id="type-classes-to-the-rescue"><a class="header" href="#type-classes-to-the-rescue">Type Classes to the Rescue!</a></h2>
<p>When we looked at the <code>State</code> monad at the start of this chapter, I gave the following types for the actions of the <code>State</code> monad:</p>
<pre><code class="language-haskell">get    :: forall s.             State s s
put    :: forall s. s        -&gt; State s Unit
modify :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>In reality, the types given in the <code>Control.Monad.State.Class</code> module are more general than this:</p>
<pre><code class="language-haskell">get    :: forall m s. MonadState s m =&gt;             m s
put    :: forall m s. MonadState s m =&gt; s        -&gt; m Unit
modify :: forall m s. MonadState s m =&gt; (s -&gt; s) -&gt; m Unit
</code></pre>
<p>The <code>Control.Monad.State.Class</code> module defines the <code>MonadState</code> (multi-parameter) type class, which allows us to abstract over &quot;monads which support pure mutable state&quot;. As one would expect, the <code>State s</code> type constructor is an instance of the <code>MonadState s</code> type class, but there are many more interesting instances of this class.</p>
<p>In particular, there are instances of <code>MonadState</code> for the <code>WriterT</code>, <code>ReaderT</code> and <code>ExceptT</code> monad transformers, provided in the <code>transformers</code> package. Each of these monad transformers has an instance for <code>MonadState</code> whenever the underlying <code>Monad</code> does. In practice, this means that as long as <code>StateT</code> appears <em>somewhere</em> in the monad transformer stack, and everything above <code>StateT</code> is an instance of <code>MonadState</code>, then we are free to use <code>get</code>, <code>put</code> and <code>modify</code> directly, without the need to use <code>lift</code>.</p>
<p>Indeed, the same is true of the actions we covered for the <code>ReaderT</code>, <code>WriterT</code>, and <code>ExceptT</code> transformers. <code>transformers</code> defines a type class for each of the major transformers, allowing us to abstract over monads which support their operations.</p>
<p>In the case of the <code>split</code> function above, the monad stack we constructed is an instance of each of the <code>MonadState</code>, <code>MonadWriter</code> and <code>MonadError</code> type classes. This means that we don't need to call <code>lift</code> at all! We can just use the actions <code>get</code>, <code>put</code>, <code>tell</code> and <code>throwError</code> as if they were defined on the monad stack itself:</p>
<pre><code class="language-haskell">split :: Parser String
split = do
  s &lt;- get
  tell [&quot;The state is &quot; &lt;&gt; show s]
  case s of
    &quot;&quot; -&gt; throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>This computation really looks like we have extended our programming language to support the three new side-effects of mutable state, logging and error handling. However, everything is still implemented using pure functions and immutable data under the hood.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>The <code>control</code> package defines a number of abstractions for working with computations which can fail. One of these is the <code>Alternative</code> type class:</p>
<pre><code class="language-haskell">class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<p><code>Alternative</code> provides two new combinators: the <code>empty</code> value, which provides a prototype for a failing computation, and the <code>alt</code> function (and its alias, <code>&lt;|&gt;</code>) which provides the ability to fall back to an <em>alternative</em> computation in the case of an error.</p>
<p>The <code>Data.Array</code> module provides two useful functions for working with type constructors in the <code>Alternative</code> type class:</p>
<pre><code class="language-haskell">many :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
some :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
</code></pre>
<p>There is also an equivalent <code>many</code> and <code>some</code> for <code>Data.List</code></p>
<p>The <code>many</code> combinator uses the <code>Alternative</code> type class to repeatedly run a computation <em>zero-or-more</em> times. The <code>some</code> combinator is similar, but requires at least the first computation to succeed.</p>
<p>In the case of our <code>Parser</code> monad transformer stack, there is an instance of <code>Alternative</code> induced by the <code>ExceptT</code> component, which supports failure by composing errors in different branches using a <code>Monoid</code> instance (this is why we chose <code>Array String</code> for our <code>Errors</code> type). This means that we can use the <code>many</code> and <code>some</code> functions to run a parser multiple times:</p>
<pre><code class="language-text">&gt; import Data.Array (many)

&gt; runParser (many split) &quot;test&quot;
(Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;)
              [ &quot;The state is \&quot;test\&quot;&quot;
              , &quot;The state is \&quot;est\&quot;&quot;
              , &quot;The state is \&quot;st\&quot;&quot;
              , &quot;The state is \&quot;t\&quot;&quot;
              ]))
</code></pre>
<p>Here, the input string <code>&quot;test&quot;</code> has been repeatedly split to return an array of four single-character strings, the leftover state is empty, and the log shows that we applied the <code>split</code> combinator four times.</p>
<h2 id="monad-comprehensions"><a class="header" href="#monad-comprehensions">Monad Comprehensions</a></h2>
<p>The <code>Control.MonadPlus</code> module defines a subclass of the <code>Alternative</code> type class, called <code>MonadPlus</code>. <code>MonadPlus</code> captures those type constructors which are both monads and instances of <code>Alternative</code>:</p>
<pre><code class="language-haskell">class (Monad m, Alternative m) &lt;= MonadPlus m
</code></pre>
<p>In particular, our <code>Parser</code> monad is an instance of <code>MonadPlus</code>.</p>
<p>When we covered array comprehensions earlier in the book, we introduced the <code>guard</code> function, which could be used to filter out unwanted results. In fact, the <code>guard</code> function is more general, and can be used for any monad which is an instance of <code>MonadPlus</code>:</p>
<pre><code class="language-haskell">guard :: forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p>The <code>&lt;|&gt;</code> operator allows us to backtrack in case of failure. To see how this is useful, let's define a variant of the <code>split</code> combinator which only matches upper case characters:</p>
<pre><code class="language-haskell">upper :: Parser String
upper = do
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre>
<p>Here, we use a <code>guard</code> to fail if the string is not upper case. Note that this code looks very similar to the array comprehensions we saw earlier - using <code>MonadPlus</code> in this way, we sometimes refer to constructing <em>monad comprehensions</em>.</p>
<h2 id="backtracking"><a class="header" href="#backtracking">Backtracking</a></h2>
<p>We can use the <code>&lt;|&gt;</code> operator to backtrack to another alternative in case of failure. To demonstrate this, let's define one more parser, which matches lower case characters:</p>
<pre><code class="language-haskell">lower :: Parser String
lower = do
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre>
<p>With this, we can define a parser which eagerly matches many upper case characters if the first character is upper case, or many lower case character if the first character is lower case:</p>
<pre><code class="language-text">&gt; upperOrLower = some upper &lt;|&gt; some lower
</code></pre>
<p>This parser will match characters until the case changes:</p>
<pre><code class="language-text">&gt; runParser upperOrLower &quot;abcDEF&quot;
(Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;))
              [ &quot;The state is \&quot;abcDEF\&quot;&quot;
              , &quot;The state is \&quot;bcDEF\&quot;&quot;
              , &quot;The state is \&quot;cDEF\&quot;&quot;
              ]))
</code></pre>
<p>We can even use <code>many</code> to fully split a string into its lower and upper case components:</p>
<pre><code class="language-text">&gt; components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
(Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;)
              [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;CDeFgh\&quot;&quot;
              , &quot;The state is \&quot;DeFgh\&quot;&quot;
              , &quot;The state is \&quot;eFgh\&quot;&quot;
              , &quot;The state is \&quot;Fgh\&quot;&quot;
              , &quot;The state is \&quot;gh\&quot;&quot;
              , &quot;The state is \&quot;h\&quot;&quot;
              ]))
</code></pre>
<p>Again, this illustrates the power of reusability that monad transformers bring - we were able to write a backtracking parser in a declarative style with only a few lines of code, by reusing standard abstractions!</p>
<h2 id="exercises-37"><a class="header" href="#exercises-37">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Remove the calls to the <code>lift</code> function from your implementation of the <code>string</code> parser. Verify that the new implementation type checks, and convince yourself that it should.</p>
</li>
<li>
<p>(Medium) Use your <code>string</code> parser with the <code>some</code> combinator to write a parser <code>asFollowedByBs</code> which recognizes strings consisting of several copies of the string <code>&quot;a&quot;</code> followed by several copies of the string <code>&quot;b&quot;</code>.</p>
</li>
<li>
<p>(Medium) Use the <code>&lt;|&gt;</code> operator to write a parser <code>asOrBs</code> which recognizes strings of the letters <code>a</code> or <code>b</code> in any order.</p>
</li>
<li>
<p>(Difficult) The <code>Parser</code> monad might also be defined as follows:</p>
<pre><code class="language-haskell">type Parser = ExceptT Errors (StateT String (WriterT Log Identity))
</code></pre>
<p>What effect does this change have on our parsing functions?</p>
</li>
</ol>
<h2 id="the-rws-monad"><a class="header" href="#the-rws-monad">The RWS Monad</a></h2>
<p>One particular combination of monad transformers is so common that it is provided as a single monad transformer in the <code>transformers</code> package. The <code>Reader</code>, <code>Writer</code> and <code>State</code> monads are combined into the <em>reader-writer-state</em> monad, or more simply the <code>RWS</code> monad. This monad has a corresponding monad transformer called the <code>RWST</code> monad transformer.</p>
<p>We will use the <code>RWS</code> monad to model the game logic for our text adventure game.</p>
<p>The <code>RWS</code> monad is defined in terms of three type parameters (in addition to its return type):</p>
<pre><code class="language-haskell">type RWS r w s = RWST r w s Identity
</code></pre>
<p>Notice that the <code>RWS</code> monad is defined in terms of its own monad transformer, by setting the base monad to <code>Identity</code> which provides no side-effects.</p>
<p>The first type parameter, <code>r</code>, represents the global configuration type. The second, <code>w</code>, represents the monoid which we will use to accumulate a log, and the third, <code>s</code> is the type of our mutable state.</p>
<p>In the case of our game, our global configuration is defined in a type called <code>GameEnvironment</code> in the <code>Data.GameEnvironment</code> module:</p>
<pre><code class="language-haskell">type PlayerName = String

newtype GameEnvironment = GameEnvironment
  { playerName    :: PlayerName
  , debugMode     :: Boolean
  }
</code></pre>
<p>It defines the player name, and a flag which indicates whether or not the game is running in debug mode. These options will be set from the command line when we come to run our monad transformer.</p>
<p>The mutable state is defined in a type called <code>GameState</code> in the <code>Data.GameState</code> module:</p>
<pre><code class="language-haskell">import Data.Map as M
import Data.Set as S

newtype GameState = GameState
  { items       :: M.Map Coords (S.Set GameItem)
  , player      :: Coords
  , inventory   :: S.Set GameItem
  }
</code></pre>
<p>The <code>Coords</code> data type represents points on a two-dimensional grid, and the <code>GameItem</code> data type is an enumeration of the items in the game:</p>
<pre><code class="language-haskell">data GameItem = Candle | Matches
</code></pre>
<p>The <code>GameState</code> type uses two new data structures: <code>Map</code> and <code>Set</code>, which represent sorted maps and sorted sets respectively. The <code>items</code> property is a mapping from coordinates of the game grid to sets of game items at that location. The <code>player</code> property stores the current coordinates of the player, and the <code>inventory</code> property stores a set of game items currently held by the player.</p>
<p>The <code>Map</code> and <code>Set</code> data structures are sorted by their keys, can be used with any key type in the <code>Ord</code> type class. This means that the keys in our data structures should be totally ordered.</p>
<p>We will see how the <code>Map</code> and <code>Set</code> structures are used as we write the actions for our game.</p>
<p>For our log, we will use the <code>List String</code> monoid. We can define a type synonym for our <code>Game</code> monad, implemented using <code>RWS</code>:</p>
<pre><code class="language-haskell">type Log = L.List String

type Game = RWS GameEnvironment Log GameState
</code></pre>
<h2 id="implementing-game-logic"><a class="header" href="#implementing-game-logic">Implementing Game Logic</a></h2>
<p>Our game is going to be built from simple actions defined in the <code>Game</code> monad, by reusing the actions from the <code>Reader</code>, <code>Writer</code> and <code>State</code> monads. At the top level of our application, we will run the pure computations in the <code>Game</code> monad, and use the <code>Effect</code> monad to turn the results into observable side-effects, such as printing text to the console.</p>
<p>One of the simplest actions in our game is the <code>has</code> action. This action tests whether the player's inventory contains a particular game item. It is defined as follows:</p>
<pre><code class="language-haskell">has :: GameItem -&gt; Game Boolean
has item = do
  GameState state &lt;- get
  pure $ item `S.member` state.inventory
</code></pre>
<p>This function uses the <code>get</code> action defined in the <code>MonadState</code> type class to read the current game state, and then uses the <code>member</code> function defined in <code>Data.Set</code> to test whether the specified <code>GameItem</code> appears in the <code>Set</code> of inventory items.</p>
<p>Another action is the <code>pickUp</code> action. It adds a game item to the player's inventory if it appears in the current room. It uses actions from the <code>MonadWriter</code> and <code>MonadState</code> type classes. First of all, it reads the current game state:</p>
<pre><code class="language-haskell">pickUp :: GameItem -&gt; Game Unit
pickUp item = do
  GameState state &lt;- get
</code></pre>
<p>Next, <code>pickUp</code> looks up the set of items in the current room. It does this by using the <code>lookup</code> function defined in <code>Data.Map</code>:</p>
<pre><code class="language-haskell">  case state.player `M.lookup` state.items of
</code></pre>
<p>The <code>lookup</code> function returns an optional result indicated by the <code>Maybe</code> type constructor. If the key does not appear in the map, the <code>lookup</code> function returns <code>Nothing</code>, otherwise it returns the corresponding value in the <code>Just</code> constructor.</p>
<p>We are interested in the case where the corresponding item set contains the specified game item. Again we can test this using the <code>member</code> function:</p>
<pre><code class="language-haskell">    Just items | item `S.member` items -&gt; do
</code></pre>
<p>In this case, we can use <code>put</code> to update the game state, and <code>tell</code> to add a message to the log:</p>
<pre><code class="language-haskell">          let newItems = M.update (Just &lt;&lt;&lt; S.delete item) state.player state.items
              newInventory = S.insert item state.inventory
          put $ GameState state { items     = newItems
                                , inventory = newInventory
                                }
          tell (L.singleton (&quot;You now have the &quot; &lt;&gt; show item))
</code></pre>
<p>Note that there is no need to <code>lift</code> either of the two computations here, because there are appropriate instances for both <code>MonadState</code> and <code>MonadWriter</code> for our <code>Game</code> monad transformer stack.</p>
<p>The argument to <code>put</code> uses a record update to modify the game state's <code>items</code> and <code>inventory</code> fields. We use the <code>update</code> function from <code>Data.Map</code> which modifies a value at a particular key. In this case, we modify the set of items at the player's current location, using the <code>delete</code> function to remove the specified item from the set. <code>inventory</code> is also updated, using <code>insert</code> to add the new item to the player's inventory set.</p>
<p>Finally, the <code>pickUp</code> function handles the remaining cases, by notifying the user using <code>tell</code>:</p>
<pre><code class="language-haskell">    _ -&gt; tell (L.singleton &quot;I don't see that item here.&quot;)
</code></pre>
<p>As an example of using the <code>Reader</code> monad, we can look at the code for the <code>debug</code> command. This command allows the user to inspect the game state at runtime if the game is running in debug mode:</p>
<pre><code class="language-haskell">  GameEnvironment env &lt;- ask
  if env.debugMode
    then do
      state :: GameState &lt;- get
      tell (L.singleton (show state))
    else tell (L.singleton &quot;Not running in debug mode.&quot;)
</code></pre>
<p>Here, we use the <code>ask</code> action to read the game configuration. Again, note that we don't need to <code>lift</code> any computation, and we can use actions defined in the <code>MonadState</code>, <code>MonadReader</code> and <code>MonadWriter</code> type classes in the same do notation block.</p>
<p>If the <code>debugMode</code> flag is set, then the <code>tell</code> action is used to write the state to the log. Otherwise, an error message is added.</p>
<p>The remainder of the <code>Game</code> module defines a set of similar actions, each using only the actions defined by the <code>MonadState</code>, <code>MonadReader</code> and <code>MonadWriter</code> type classes.</p>
<h2 id="running-the-computation"><a class="header" href="#running-the-computation">Running the Computation</a></h2>
<p>Since our game logic runs in the <code>RWS</code> monad, it is necessary to run the computation in order to respond to the user's commands.</p>
<p>The front-end of our game is built using two packages: <code>optparse</code>, which provides applicative command line parsing, and <code>node-readline</code>, which wraps NodeJS' <code>readline</code> module, allowing us to write interactive console-based applications.</p>
<p>The interface to our game logic is provided by the function <code>game</code> in the <code>Game</code> module:</p>
<pre><code class="language-haskell">game :: Array String -&gt; Game Unit
</code></pre>
<p>To run this computation, we pass a list of words entered by the user as an array of strings, and run the resulting <code>RWS</code> computation using <code>runRWS</code>:</p>
<pre><code class="language-haskell">data RWSResult state result writer = RWSResult state result writer

runRWS :: forall r w s a. RWS r w s a -&gt; r -&gt; s -&gt; RWSResult s a w
</code></pre>
<p><code>runRWS</code> looks like a combination of <code>runReader</code>, <code>runWriter</code> and <code>runState</code>. It takes a global configuration and an initial state as an argument, and returns a data structure containing the log, the result and the final state.</p>
<p>The front-end of our application is defined by a function <code>runGame</code>, with the following type signature:</p>
<pre><code class="language-haskell">runGame :: GameEnvironment -&gt; Effect Unit
</code></pre>
<p>This function interacts with the user via the console (using the <code>node-readline</code> and <code>console</code> packages). <code>runGame</code> takes the game configuration as a function argument.</p>
<p>The <code>node-readline</code> package provides the <code>LineHandler</code> type, which represents actions in the <code>Effect</code> monad which handle user input from the terminal. Here is the corresponding API:</p>
<pre><code class="language-haskell">type LineHandler a = String -&gt; Effect a

foreign import setLineHandler
  :: forall a
   . Interface
  -&gt; LineHandler a
  -&gt; Effect Unit
</code></pre>
<p>The <code>Interface</code> type represents a handle for the console, and is passed as an argument to the functions which interact with it. An <code>Interface</code> can be created using the <code>createConsoleInterface</code> function:</p>
<pre><code class="language-haskell">import Node.ReadLine as RL

runGame env = do
  interface &lt;- RL.createConsoleInterface RL.noCompletion
</code></pre>
<p>The first step is to set the prompt at the console. We pass the <code>interface</code> handle, and provide the prompt string and indentation level:</p>
<pre><code class="language-haskell">  RL.setPrompt &quot;&gt; &quot; interface
</code></pre>
<p>In our case, we are interested in implementing the line handler function. Our line handler is defined using a helper function in a <code>let</code> declaration, as follows:</p>
<pre><code class="language-haskell">    lineHandler :: GameState -&gt; String -&gt; Effect Unit
    lineHandler currentState input = do
      case runRWS (game (split (wrap &quot; &quot;) input)) env currentState of
        RWSResult state _ written -&gt; do
          for_ written log
          RL.setLineHandler (lineHandler state) $ interface
      RL.prompt interface
      pure unit
</code></pre>
<p>The <code>let</code> binding is closed over both the game configuration, named <code>env</code>, and the console handle, named <code>interface</code>.</p>
<p>Our handler takes an additional first argument, the game state. This is required since we need to pass the game state to <code>runRWS</code> to run the game's logic.</p>
<p>The first thing this action does is to break the user input into words using the <code>split</code> function from the <code>Data.String</code> module. It then uses <code>runRWS</code> to run the <code>game</code> action (in the <code>RWS</code> monad), passing the game environment and current game state.</p>
<p>Having run the game logic, which is a pure computation, we need to print any log messages to the screen and show the user a prompt for the next command. The <code>for_</code> action is used to traverse the log (of type <code>List String</code>) and print its entries to the console. Finally, <code>setLineHandler</code> is used to update the line handler function to use the updated game state, and the prompt is displayed again using the <code>prompt</code> action.</p>
<p>The <code>runGame</code> function finally attaches the initial line handler to the console interface, and displays the initial prompt:</p>
<pre><code class="language-haskell">  RL.setLineHandler (lineHandler initialGameState) interface
  RL.prompt interface
</code></pre>
<h2 id="exercises-38"><a class="header" href="#exercises-38">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Implement a new command <code>cheat</code>, which moves all game items from the game grid into the user's inventory. Create a function <code>cheat :: Game Unit</code> in the <code>Game</code> module, and use this function from <code>game</code>.</p>
</li>
<li>
<p>(Difficult) The <code>Writer</code> component of the <code>RWS</code> monad is currently used for two types of messages: error messages and informational messages. Because of this, several parts of the code use case statements to handle error cases.</p>
<p>Refactor the code to use the <code>ExceptT</code> monad transformer to handle the error messages, and <code>RWS</code> to handle informational messages. <em>Note:</em> There are no tests for this exercise.</p>
</li>
</ol>
<h2 id="handling-command-line-options"><a class="header" href="#handling-command-line-options">Handling Command Line Options</a></h2>
<p>The final piece of the application is responsible for parsing command line options and creating the <code>GameEnvironment</code> configuration record. For this, we use the <code>optparse</code> package.</p>
<p><code>optparse</code> is an example of <em>applicative command line option parsing</em>. Recall that an applicative functor allows us to lift functions of arbitrary arity over a type constructor representing some type of side-effect. In the case of the <code>optparse</code> package, the functor we are interested in is the <code>Parser</code> functor (imported from the optparse module <code>Options.Applicative</code>, not to be confused with our <code>Parser</code> that we defined in the <code>Split</code> module), which adds the side-effect of reading from command line options. It provides the following handler:</p>
<pre><code class="language-haskell">customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a
</code></pre>
<p>This is best illustrated by example. The application's <code>main</code> function is defined using <code>customExecParser</code> as follows:</p>
<pre><code class="language-haskell">main = OP.customExecParser prefs argParser &gt;&gt;= runGame 
</code></pre>
<p>The first argument is used to configure the <code>optparse</code> library. In our case, we simply configure it to show the help message when the application is run without any arguments (instead of showing a &quot;missing argument&quot; error) by using <code>OP.prefs OP.showHelpOnEmpty</code>, but the <code>Options.Applicative.Builder</code> module provides several other options.</p>
<p>The second argument is the complete description of our parser program:</p>
<pre><code class="language-haskell">  argParser :: OP.ParserInfo GameEnvironment
  argParser = OP.info (env &lt;**&gt; OP.helper) parserOptions

  parserOptions = fold 
    [ OP.fullDesc
    , OP.progDesc &quot;Play the game as &lt;player name&gt;&quot;
    , OP.header &quot;Monadic Adventures! A game to learn monad transformers&quot; 
    ]
</code></pre>
<p>Here <code>OP.info</code> combines a <code>Parser</code> with a set of options for how the help message is formatted. <code>env &lt;**&gt; OP.helper</code> takes any command line argument <code>Parser</code> named <code>env</code> and adds a <code>--help</code> option to it automatically. Options for the help message are of type <code>InfoMod</code>, which is a monoid, so we can use the <code>fold</code> function to add several options together.</p>
<p>The interesting part of our parser is constructing the <code>GameEnvironment</code>:</p>
<pre><code class="language-haskell">  env :: OP.Parser GameEnvironment
  env = gameEnvironment &lt;$&gt; player &lt;*&gt; debug

  player :: OP.Parser String
  player = OP.strOption $ fold 
    [ OP.long &quot;player&quot;
    , OP.short 'p'
    , OP.metavar &quot;&lt;player name&gt;&quot;
    , OP.help &quot;The player's name &lt;String&gt;&quot;
    ]

  debug :: OP.Parser Boolean
  debug = OP.switch $ fold 
    [ OP.long &quot;debug&quot;
    , OP.short 'd'
    , OP.help &quot;Use debug mode&quot;
    ]
</code></pre>
<p><code>player</code> and <code>debug</code> are both <code>Parser</code>s, so we can use our applicative operators <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to lift our <code>gameEnvironment</code> function, which has the type <code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code> over <code>Parser</code>. <code>OP.strOption</code> constructs a command line option that expects a string value, and is configured via a collection of <code>Mod</code>s folded together. <code>OP.flag</code> works similarly, but doesn't expect an associated value. <code>optparse</code> offers extensive <a href="https://pursuit.purescript.org/packages/purescript-optparse">documentation</a> on different modifiers available to build various command line parsers.</p>
<p>Notice how we were able to use the notation afforded by the applicative operators to give a compact, declarative specification of our command line interface. In addition, it is simple to add new command line arguments, simply by adding a new function argument to <code>runGame</code>, and then using <code>&lt;*&gt;</code> to lift <code>runGame</code> over an additional argument in the definition of <code>env</code>.</p>
<h2 id="exercises-39"><a class="header" href="#exercises-39">Exercises</a></h2>
<ol>
<li>(Medium) Add a new Boolean-valued property <code>cheatMode</code> to the <code>GameEnvironment</code> record. Add a new command line flag <code>-c</code> to the <code>optparse</code> configuration which enables cheat mode. The <code>cheat</code> command from the previous exercise should be disallowed if cheat mode is not enabled.</li>
</ol>
<h2 id="conclusion-9"><a class="header" href="#conclusion-9">Conclusion</a></h2>
<p>This chapter was a practical demonstration of the techniques we've learned so far, using monad transformers to build a pure specification of our game, and the <code>Effect</code> monad to build a front-end using the console.</p>
<p>Because we separated our implementation from the user interface, it would be possible to create other front-ends for our game. For example, we could use the <code>Effect</code> monad to render the game in the browser using the Canvas API or the DOM.</p>
<p>We have seen how monad transformers allow us to write safe code in an imperative style, where effects are tracked by the type system. In addition, type classes provide a powerful way to abstract over the actions provided by a monad, enabling code reuse. We were able to use standard abstractions like <code>Alternative</code> and <code>MonadPlus</code> to build useful monads by combining standard monad transformers.</p>
<p>Monad transformers are an excellent demonstration of the sort of expressive code that can be written by relying on advanced type system features such as higher-kinded polymorphism and multi-parameter type classes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas-graphics"><a class="header" href="#canvas-graphics">Canvas Graphics</a></h1>
<h2 id="chapter-goals-10"><a class="header" href="#chapter-goals-10">Chapter Goals</a></h2>
<p>This chapter will be an extended example focussing on the <code>canvas</code> package, which provides a way to generate 2D graphics from PureScript using the HTML5 Canvas API.</p>
<h2 id="project-setup-9"><a class="header" href="#project-setup-9">Project Setup</a></h2>
<p>This module's project introduces the following new dependencies:</p>
<ul>
<li><code>canvas</code>, which gives types to methods from the HTML5 Canvas API</li>
<li><code>refs</code>, which provides a side-effect for using <em>global mutable references</em></li>
</ul>
<p>The source code for the chapter is broken up into a set of modules, each of which defines a <code>main</code> method. Different sections of this chapter are implemented in different files, and the <code>Main</code> module can be changed by modifying the Spago build command to run the appropriate file's <code>main</code> method at each point.</p>
<p>The HTML file <code>html/index.html</code> contains a single <code>canvas</code> element which will be used in each example, and a <code>script</code> element to load the compiled PureScript code. To test the code for each section, open the HTML file in your browser. Because most exercises target the browser, there are no unit tests for this chapter.</p>
<h2 id="simple-shapes"><a class="header" href="#simple-shapes">Simple Shapes</a></h2>
<p>The <code>Example/Rectangle.purs</code> file contains a simple introductory example, which draws a single blue rectangle at the center of the canvas. The module imports the <code>Effect</code> type from the <code>Effect</code> module, and also the <code>Graphics.Canvas</code> module, which contains actions in the <code>Effect</code> monad for working with the Canvas API.</p>
<p>The <code>main</code> action starts, like in the other modules, by using the <code>getCanvasElementById</code> action to get a reference to the canvas object, and the <code>getContext2D</code> action to access the 2D rendering context for the canvas:</p>
<p>The <code>void</code> function takes a functor and replaces its value with <code>Unit</code>. In the example it is used to make <code>main</code> conform with its signature.</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><em>Note</em>: the call to <code>unsafePartial</code> here is necessary since the pattern match on the result of <code>getCanvasElementById</code> is partial, matching only the <code>Just</code> constructor. For our purposes, this is fine, but in production code, we would probably want to match the <code>Nothing</code> constructor and provide an appropriate error message.</p>
<p>The types of these actions can be found using PSCi or by looking at the documentation:</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code> and <code>Context2D</code> are types defined in the <code>Graphics.Canvas</code> module. The same module also defines the <code>Canvas</code> effect, which is used by all of the actions in the module.</p>
<p>The graphics context <code>ctx</code> manages the state of the canvas, and provides methods to render primitive shapes, set styles and colors, and apply transformations.</p>
<p>We continue by setting the fill style to solid blue using the <code>setFillStyle</code> action. The longer hex notation of <code>#0000FF</code> may also be used for blue, but shorthand notation is easier for simple colors:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p>Note that the <code>setFillStyle</code> action takes the graphics context as an argument. This is a common pattern in the <code>Graphics.Canvas</code> module.</p>
<p>Finally, we use the <code>fillPath</code> action to fill the rectangle. <code>fillPath</code> has the following type:</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code> takes a graphics context and another action which builds the path to render. To build a path, we can use the <code>rect</code> action. <code>rect</code> takes a graphics context, and a record which provides the position and size of the rectangle:</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>Build the rectangle example, providing <code>Example.Rectangle</code> as the name of the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>Now, open the <code>html/index.html</code> file and verify that this code renders a blue rectangle in the center of the canvas.</p>
<h2 id="putting-row-polymorphism-to-work"><a class="header" href="#putting-row-polymorphism-to-work">Putting Row Polymorphism to Work</a></h2>
<p>There are other ways to render paths. The <code>arc</code> function renders an arc segment, and the <code>moveTo</code>, <code>lineTo</code> and <code>closePath</code> functions can be used to render piecewise-linear paths.</p>
<p>The <code>Shapes.purs</code> file renders three shapes: a rectangle, an arc segment and a triangle.</p>
<p>We have seen that the <code>rect</code> function takes a record as its argument. In fact, the properties of the rectangle are defined in a type synonym:</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p>The <code>x</code> and <code>y</code> properties represent the location of the top-left corner, while the <code>w</code> and <code>h</code> properties represent the width and height respectively.</p>
<p>To render an arc segment, we can use the <code>arc</code> function, passing a record with the following type:</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>Here, the <code>x</code> and <code>y</code> properties represent the center point, <code>r</code> is the radius, and <code>start</code> and <code>end</code> represent the endpoints of the arc in radians.</p>
<p>For example, this code fills an arc segment centered at <code>(300, 300)</code> with radius <code>50</code>. The arc completes 2/3rds of a rotation. Note that the unit circle is flipped vertically, since the y-axis increases towards the bottom of the canvas:</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p>Notice that both the <code>Rectangle</code> and <code>Arc</code> record types contain <code>x</code> and <code>y</code> properties of type <code>Number</code>. In both cases, this pair represents a point. This means that we can write row-polymorphic functions which can act on either type of record.</p>
<p>For example, the <code>Shapes</code> module defines a <code>translate</code> function which translates a shape by modifying its <code>x</code> and <code>y</code> properties:</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>Notice the row-polymorphic type. It says that <code>translate</code> accepts any record with <code>x</code> and <code>y</code> properties <em>and any other properties</em>, and returns the same type of record. The <code>x</code> and <code>y</code> fields are updated, but the rest of the fields remain unchanged.</p>
<p>This is an example of <em>record update syntax</em>. The expression <code>shape { ... }</code> creates a new record based on the <code>shape</code> record, with the fields inside the braces updated to the specified values. Note that the expressions inside the braces are separated from their labels by equals symbols, not colons like in record literals.</p>
<p>The <code>translate</code> function can be used with both the <code>Rectangle</code> and <code>Arc</code> records, as can be seen in the <code>Shapes</code> example.</p>
<p>The third type of path rendered in the <code>Shapes</code> example is a piecewise-linear path. Here is the corresponding code:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>There are three functions in use here:</p>
<ul>
<li><code>moveTo</code> moves the current location of the path to the specified coordinates,</li>
<li><code>lineTo</code> renders a line segment between the current location and the specified coordinates, and updates the current location,</li>
<li><code>closePath</code> completes the path by rendering a line segment joining the current location to the start position.</li>
</ul>
<p>The result of this code snippet is to fill an isosceles triangle.</p>
<p>Build the example by specifying <code>Example.Shapes</code> as the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>and open <code>html/index.html</code> again to see the result. You should see the three different types of shapes rendered to the canvas.</p>
<h2 id="exercises-40"><a class="header" href="#exercises-40">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Experiment with the <code>strokePath</code> and <code>setStrokeStyle</code> functions in each of the examples so far.</p>
</li>
<li>
<p>(Easy) The <code>fillPath</code> and <code>strokePath</code> functions can be used to render complex paths with a common style by using a do notation block inside the function argument. Try changing the <code>Rectangle</code> example to render two rectangles side-by-side using the same call to <code>fillPath</code>. Try rendering a sector of a circle by using a combination of a piecewise-linear path and an arc segment.</p>
</li>
<li>
<p>(Medium) Given the following record type:</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>which represents a 2D point, write a function <code>renderPath</code> which strokes a closed path constructed from a number of points:</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>Given a function</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>which takes a <code>Number</code> between <code>0</code> and <code>1</code> as its argument and returns a <code>Point</code>, write an action which plots <code>f</code> by using your <code>renderPath</code> function. Your action should approximate the path by sampling <code>f</code> at a finite set of points.</p>
<p>Experiment by rendering different paths by varying the function <code>f</code>.</p>
</li>
</ol>
<h2 id="drawing-random-circles"><a class="header" href="#drawing-random-circles">Drawing Random Circles</a></h2>
<p>The <code>Example/Random.purs</code> file contains an example which uses the <code>Effect</code> monad to interleave two different types of side-effect: random number generation, and canvas manipulation. The example renders one hundred randomly generated circles onto the canvas.</p>
<p>The <code>main</code> action obtains a reference to the graphics context as before, and then sets the stroke and fill styles:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>Next, the code uses the <code>for_</code> function to loop over the integers between <code>0</code> and <code>100</code>:</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>On each iteration, the do notation block starts by generating three random numbers distributed between <code>0</code> and <code>1</code>. These numbers represent the <code>x</code> and <code>y</code> coordinates, and the radius of a circle:</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>Next, for each circle, the code creates an <code>Arc</code> based on these parameters and finally fills and strokes the arc with the current styles:</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x                  : x * 600.0
         , y                  : y * 600.0
         , radius             : r * 50.0
         , start              : 0.0
         , end                : Number.tau
         , useCounterClockwise: false
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>Build this example by specifying the <code>Example.Random</code> module as the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p>and view the result by opening <code>html/index.html</code>.</p>
<h2 id="transformations"><a class="header" href="#transformations">Transformations</a></h2>
<p>There is more to the canvas than just rendering simple shapes. Every canvas maintains a transformation which is used to transform shapes before rendering. Shapes can be translated, rotated, scaled, and skewed.</p>
<p>The <code>canvas</code> library supports these transformations using the following functions:</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p>The <code>translate</code> action performs a translation whose components are specified by the properties of the <code>TranslateTransform</code> record.</p>
<p>The <code>rotate</code> action performs a rotation around the origin, through some number of radians specified by the first argument.</p>
<p>The <code>scale</code> action performs a scaling, with the origin as the center. The <code>ScaleTransform</code> record specifies the scale factors along the <code>x</code> and <code>y</code> axes.</p>
<p>Finally, <code>transform</code> is the most general action of the four here. It performs an affine transformation specified by a matrix.</p>
<p>Any shapes rendered after these actions have been invoked will automatically have the appropriate transformation applied.</p>
<p>In fact, the effect of each of these functions is to <em>post-multiply</em> the transformation with the context's current transformation. The result is that if multiple transformations applied after one another, then their effects are actually applied in reverse:</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>The effect of this sequence of actions is that the scene is rotated, then scaled, and finally translated.</p>
<h2 id="preserving-the-context"><a class="header" href="#preserving-the-context">Preserving the Context</a></h2>
<p>A common use case is to render some subset of the scene using a transformation, and then to reset the transformation afterwards.</p>
<p>The Canvas API provides the <code>save</code> and <code>restore</code> methods, which manipulate a <em>stack</em> of states associated with the canvas. <code>canvas</code> wraps this functionality into the following functions:</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p>The <code>save</code> action pushes the current state of the context (including the current transformation and any styles) onto the stack, and the <code>restore</code> action pops the top state from the stack and restores it.</p>
<p>This allows us to save the current state, apply some styles and transformations, render some primitives, and finally restore the original transformation and state. For example, the following function performs some canvas action, but applies a rotation before doing so, and restores the transformation afterwards:</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>In the interest of abstracting over common use cases using higher-order functions, the <code>canvas</code> library provides the <code>withContext</code> function, which performs some canvas action while preserving the original context state:</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p>We could rewrite the <code>rotated</code> function above using <code>withContext</code> as follows:</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="global-mutable-state"><a class="header" href="#global-mutable-state">Global Mutable State</a></h2>
<p>In this section, we'll use the <code>refs</code> package to demonstrate another effect in the <code>Effect</code> monad.</p>
<p>The <code>Effect.Ref</code> module provides a type constructor for global mutable references, and an associated effect:</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>A value of type <code>Ref a</code> is a mutable reference cell containing a value of type <code>a</code>, used to track global mutation. As such, it should be used sparingly.</p>
<p>The <code>Example/Refs.purs</code> file contains an example which uses a <code>Ref</code> to track mouse clicks on the <code>canvas</code> element.</p>
<p>The code starts by creating a new reference containing the value <code>0</code>, by using the <code>new</code> action:</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>Inside the click event handler, the <code>modify</code> action is used to update the click count, and the updated value is returned.</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p>In the <code>render</code> function, the click count is used to determine the transformation applied to a rectangle:</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Number.sin (toNumber count * Number.tau / 8.0) + 1.5
    let scaleY = Number.sin (toNumber count * Number.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Number.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>This action uses <code>withContext</code> to preserve the original transformation, and then applies the following sequence of transformations (remember that transformations are applied bottom-to-top):</p>
<ul>
<li>The rectangle is translated through <code>(-100, -100)</code> so that its center lies at the origin.</li>
<li>The rectangle is scaled around the origin.</li>
<li>The rectangle is rotated through some multiple of <code>10</code> degrees around the origin.</li>
<li>The rectangle is translated through <code>(300, 300)</code> so that it center lies at the center of the canvas.</li>
</ul>
<p>Build the example:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p>and open the <code>html/index.html</code> file. If you click the canvas repeatedly, you should see a green rectangle rotating around the center of the canvas.</p>
<h2 id="exercises-41"><a class="header" href="#exercises-41">Exercises</a></h2>
<ol>
<li>(Easy) Write a higher-order function which strokes and fills a path simultaneously. Rewrite the <code>Random.purs</code> example using your function.</li>
<li>(Medium) Use <code>Random</code> and <code>Dom</code> to create an application which renders a circle with random position, color and radius to the canvas when the mouse is clicked.</li>
<li>(Medium) Write a function which transforms the scene by rotating it around a point with specified coordinates. <em>Hint</em>: use a translation to first translate the scene to the origin.</li>
</ol>
<h2 id="l-systems"><a class="header" href="#l-systems">L-Systems</a></h2>
<p>In this final example, we will use the <code>canvas</code> package to write a function for rendering <em>L-systems</em> (or <em>Lindenmayer systems</em>).</p>
<p>An L-system is defined by an <em>alphabet</em>, an initial sequence of letters from the alphabet, and a set of <em>production rules</em>. Each production rule takes a letter of the alphabet and returns a sequence of replacement letters. This process is iterated some number of times starting with the initial sequence of letters.</p>
<p>If each letter of the alphabet is associated with some instruction to perform on the canvas, the L-system can be rendered by following the instructions in order.</p>
<p>For example, suppose the alphabet consists of the letters <code>L</code> (turn left), <code>R</code> (turn right) and <code>F</code> (move forward). We might define the following production rules:</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>If we start with the initial sequence &quot;FRRFRRFRR&quot; and iterate, we obtain the following sequence:</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>and so on. Plotting a piecewise-linear path corresponding to this set of instruction approximates a curve called the <em>Koch curve</em>. Increasing the number of iterations increases the resolution of the curve.</p>
<p>Let's translate this into the language of types and functions.</p>
<p>We can represent our alphabet of letters with the following ADT:</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>This data type defines one data constructor for each letter in our alphabet.</p>
<p>How can we represent the initial sequence of letters? Well, that's just an array of letters from our alphabet, which we will call a <code>Sentence</code>:</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>Our production rules can be represented as a function from <code>Letter</code> to <code>Sentence</code> as follows:</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>This is just copied straight from the specification above.</p>
<p>Now we can implement a function <code>lsystem</code> which will take a specification in this form, and render it to the canvas. What type should <code>lsystem</code> have? Well, it needs to take values like <code>initial</code> and <code>productions</code> as arguments, as well as a function which can render a letter of the alphabet to the canvas.</p>
<p>Here is a first approximation to the type of <code>lsystem</code>:</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>The first two argument types correspond to the values <code>initial</code> and <code>productions</code>.</p>
<p>The third argument represents a function which takes a letter of the alphabet and <em>interprets</em> it by performing some actions on the canvas. In our example, this would mean turning left in the case of the letter <code>L</code>, turning right in the case of the letter <code>R</code>, and moving forward in the case of a letter <code>F</code>.</p>
<p>The final argument is a number representing the number of iterations of the production rules we would like to perform.</p>
<p>The first observation is that the <code>lsystem</code> function should work for only one type of <code>Letter</code>, but for any type, so we should generalize our type accordingly. Let's replace <code>Letter</code> and <code>Sentence</code> with <code>a</code> and <code>Array a</code> for some quantified type variable <code>a</code>:</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>The second observation is that, in order to implement instructions like &quot;turn left&quot; and &quot;turn right&quot;, we will need to maintain some state, namely the direction in which the path is moving at any time. We need to modify our function to pass the state through the computation. Again, the <code>lsystem</code> function should work for any type of state, so we will represent it using the type variable <code>s</code>.</p>
<p>We need to add the type <code>s</code> in three places:</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>Firstly, the type <code>s</code> was added as the type of an additional argument to <code>lsystem</code>. This argument will represent the initial state of the L-system.</p>
<p>The type <code>s</code> also appears as an argument to, and as the return type of the interpretation function (the third argument to <code>lsystem</code>). The interpretation function will now receive the current state of the L-system as an argument, and will return a new, updated state as its return value.</p>
<p>In the case of our example, we can define use following type to represent the state:</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>The properties <code>x</code> and <code>y</code> represent the current position of the path, and the <code>theta</code> property represents the current direction of the path, specified as the angle between the path direction and the horizontal axis, in radians.</p>
<p>The initial state of the system might be specified as follows:</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>Now let's try to implement the <code>lsystem</code> function. We will find that its definition is remarkably simple.</p>
<p>It seems reasonable that <code>lsystem</code> should recurse on its fourth argument (of type <code>Int</code>). On each step of the recursion, the current sentence will change, having been updated by using the production rules. With that in mind, let's begin by introducing names for the function arguments, and delegating to a helper function:</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p>The <code>go</code> function works by recursion on its second argument. There are two cases: when <code>n</code> is zero, and when <code>n</code> is non-zero.</p>
<p>In the first case, the recursion is complete, and we simply need to interpret the current sentence according to the interpretation function. We have a sentence of type <code>Array a</code>, a state of type <code>s</code>, and a function of type <code>s -&gt; a -&gt; Effect s</code>. This sounds like a job for the <code>foldM</code> function which we defined earlier, and which is available from the <code>control</code> package:</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>What about in the non-zero case? In that case, we can simply apply the production rules to each letter of the current sentence, concatenate the results, and repeat by calling <code>go</code> recursively:</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>That's it! Note how the use of higher order functions like <code>foldM</code> and <code>concatMap</code> allowed us to communicate our ideas concisely.</p>
<p>However, we're not quite done. The type we have given is actually still too specific. Note that we don't use any canvas operations anywhere in our implementation. Nor do we make use of the structure of the <code>Effect</code> monad at all. In fact, our function works for <em>any</em> monad <code>m</code>!</p>
<p>Here is the more general type of <code>lsystem</code>, as specified in the accompanying source code for this chapter:</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>We can understand this type as saying that our interpretation function is free to have any side-effects at all, captured by the monad <code>m</code>. It might render to the canvas, or print information to the console, or support failure or multiple return values. The reader is encouraged to try writing L-systems which use these various types of side-effect.</p>
<p>This function is a good example of the power of separating data from implementation. The advantage of this approach is that we gain the freedom to interpret our data in multiple different ways. We might even factor <code>lsystem</code> into two smaller functions: the first would build the sentence using repeated application of <code>concatMap</code>, and the second would interpret the sentence using <code>foldM</code>. This is also left as an exercise for the reader.</p>
<p>Let's complete our example by implementing its interpretation function. The type of <code>lsystem</code> tells us that its type signature must be <code>s -&gt; a -&gt; m s</code> for some types <code>a</code> and <code>s</code> and a type constructor <code>m</code>. We know that we want <code>a</code> to be <code>Letter</code> and <code>s</code> to be <code>State</code>, and for the monad <code>m</code> we can choose <code>Effect</code>. This gives us the following type:</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>To implement this function, we need to handle the three data constructors of the <code>Letter</code> type. To interpret the letters <code>L</code> (move left) and <code>R</code> (move right), we simply have to update the state to change the angle <code>theta</code> appropriately:</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Number.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Number.tau / 6.0 }
</code></pre>
<p>To interpret the letter <code>F</code> (move forward), we can calculate the new position of the path, render a line segment, and update the state, as follows:</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Number.cos state.theta * 1.5
          y = state.y + Number.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>Note that in the source code for this chapter, the <code>interpret</code> function is defined using a <code>let</code> binding inside the <code>main</code> function, so that the name <code>ctx</code> is in scope. It would also be possible to move the context into the <code>State</code> type, but this would be inappropriate because it is not a changing part of the state of the system.</p>
<p>To render this L-system, we can simply use the <code>strokePath</code> action:</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>Compile the L-system example using</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p>and open <code>html/index.html</code>. You should see the Koch curve rendered to the canvas.</p>
<h2 id="exercises-42"><a class="header" href="#exercises-42">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Modify the L-system example above to use <code>fillPath</code> instead of <code>strokePath</code>. <em>Hint</em>: you will need to include a call to <code>closePath</code>, and move the call to <code>moveTo</code> outside of the <code>interpret</code> function.</p>
</li>
<li>
<p>(Easy) Try changing the various numerical constants in the code, to understand their effect on the rendered system.</p>
</li>
<li>
<p>(Medium) Break the <code>lsystem</code> function into two smaller functions. The first should build the final sentence using repeated application of <code>concatMap</code>, and the second should use <code>foldM</code> to interpret the result.</p>
</li>
<li>
<p>(Medium) Add a drop shadow to the filled shape, by using the <code>setShadowOffsetX</code>, <code>setShadowOffsetY</code>, <code>setShadowBlur</code> and <code>setShadowColor</code> actions. <em>Hint</em>: use PSCi to find the types of these functions.</p>
</li>
<li>
<p>(Medium) The angle of the corners is currently a constant (<code>tau/6</code>). Instead, it can be moved into the <code>Letter</code> data type, which allows it to be changed by the production rules:</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>How can this new information be used in the production rules to create interesting shapes?</p>
</li>
<li>
<p>(Difficult) An L-system is given by an alphabet with four letters: <code>L</code> (turn left through 60 degrees), <code>R</code> (turn right through 60 degrees), <code>F</code> (move forward) and <code>M</code> (also move forward).</p>
<p>The initial sentence of the system is the single letter <code>M</code>.</p>
<p>The production rules are specified as follows:</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>Render this L-system. <em>Note</em>: you will need to decrease the number of iterations of the production rules, since the size of the final sentence grows exponentially with the number of iterations.</p>
<p>Now, notice the symmetry between <code>L</code> and <code>M</code> in the production rules. The two &quot;move forward&quot; instructions can be differentiated using a <code>Boolean</code> value using the following alphabet type:</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>Implement this L-system again using this representation of the alphabet.</p>
</li>
<li>
<p>(Difficult) Use a different monad <code>m</code> in the interpretation function. You might try using <code>Effect.Console</code> to write the L-system onto the console, or using <code>Effect.Random</code> to apply random &quot;mutations&quot; to the state type.</p>
</li>
</ol>
<h2 id="conclusion-10"><a class="header" href="#conclusion-10">Conclusion</a></h2>
<p>In this chapter, we learned how to use the HTML5 Canvas API from PureScript by using the <code>canvas</code> library. We also saw a practical demonstration of many of the techniques we have learned already: maps and folds, records and row polymorphism, and the <code>Effect</code> monad for handling side-effects.</p>
<p>The examples also demonstrated the power of higher-order functions and <em>separating data from implementation</em>. It would be possible to extend these ideas to completely separate the representation of a scene from its rendering function, using an algebraic data type, for example:</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>This approach is taken in the <code>drawing</code> package, and it brings the flexibility of being able to manipulate the scene as data in various ways before rendering.</p>
<p>For examples of games rendered to the canvas, see the &quot;Behavior&quot; and &quot;Signal&quot; recipes in the <a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generative-testing"><a class="header" href="#generative-testing">Generative Testing</a></h1>
<h2 id="chapter-goals-11"><a class="header" href="#chapter-goals-11">Chapter Goals</a></h2>
<p>In this chapter, we will see a particularly elegant application of type classes to the problem of testing. Instead of testing our code by telling the compiler <em>how</em> to test, we simply assert <em>what</em> properties our code should have. Test cases can be generated randomly from this specification, using type classes to hide the boilerplate code of random data generation. This is called <em>generative testing</em> (or <em>property-based testing</em>), a technique made popular by the <a href="https://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a> library in Haskell.</p>
<p>The <code>quickcheck</code> package is a port of Haskell's QuickCheck library to PureScript, and for the most part, it preserves the types and syntax of the original library. We will see how to use <code>quickcheck</code> to test a simple library, using Spago to integrate our test suite into our development process.</p>
<h2 id="project-setup-10"><a class="header" href="#project-setup-10">Project Setup</a></h2>
<p>This chapter's project adds <code>quickcheck</code> as a dependency.</p>
<p>In a Spago project, test sources should be placed in the <code>test</code> directory, and the main module for the test suite should be named <code>Test.Main</code>. The test suite can be run using the <code>spago test</code> command.</p>
<h2 id="writing-properties"><a class="header" href="#writing-properties">Writing Properties</a></h2>
<p>The <code>Merge</code> module implements a simple function <code>merge</code>, which we will use to demonstrate the features of the <code>quickcheck</code> library.</p>
<pre><code class="language-haskell">merge :: Array Int -&gt; Array Int -&gt; Array Int
</code></pre>
<p><code>merge</code> takes two sorted arrays of integers, and merges their elements so that the result is also sorted. For example:</p>
<pre><code class="language-text">&gt; import Merge
&gt; merge [1, 3, 5] [2, 4, 5]

[1, 2, 3, 4, 5, 5]
</code></pre>
<p>In a typical test suite, we might test <code>merge</code> by generating a few small test cases like this by hand, and asserting that the results were equal to the appropriate values. However, everything we need to know about the <code>merge</code> function can be summarized by this property:</p>
<ul>
<li>If <code>xs</code> and <code>ys</code> are sorted, then <code>merge xs ys</code> is the sorted result of both arrays appended together.</li>
</ul>
<p><code>quickcheck</code> allows us to test this property directly, by generating random test cases. We simply state the properties that we want our code to have, as functions. In this case, we have a single property:</p>
<pre><code class="language-haskell">main = do
  quickCheck \xs ys -&gt;
    eq (merge (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>When we run this code, <code>quickcheck</code> will attempt to disprove the properties we claimed, by generating random inputs <code>xs</code> and <code>ys</code>, and passing them to our functions. If our function returns <code>false</code> for any inputs, the property will be incorrect, and the library will raise an error. Fortunately, the library is unable to disprove our properties after generating 100 random test cases:</p>
<pre><code class="language-text">$ spago test

Installation complete.
Build succeeded.
100/100 test(s) passed.
...
Tests succeeded.
</code></pre>
<p>If we deliberately introduce a bug into the <code>merge</code> function (for example, by changing the less-than check for a greater-than check), then an exception is thrown at runtime after the first failed test case:</p>
<pre><code class="language-text">Error: Test 1 failed:
Test returned false
</code></pre>
<p>As we can see, this error message is not very helpful, but it can be improved with a little work.</p>
<h2 id="improving-error-messages"><a class="header" href="#improving-error-messages">Improving Error Messages</a></h2>
<p>To provide error messages along with our failed test cases, <code>quickcheck</code> provides the <code>&lt;?&gt;</code> operator. Simply separate the property definition from the error message using <code>&lt;?&gt;</code>, as follows:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  let
    result = merge (sort xs) (sort ys)
    expected = sort $ xs &lt;&gt; ys
  in
    eq result expected &lt;?&gt; &quot;Result:\n&quot; &lt;&gt; show result &lt;&gt; &quot;\nnot equal to expected:\n&quot; &lt;&gt; show expected
</code></pre>
<p>This time, if we modify the code to introduce a bug, we see our improved error message after the first failed test case:</p>
<pre><code class="language-text">Error: Test 1 (seed 534161891) failed:
Result:
[-822215,-196136,-116841,618343,887447,-888285]
not equal to expected:
[-888285,-822215,-196136,-116841,618343,887447]
</code></pre>
<p>Notice how the input <code>xs</code> and <code>ys</code> were generated as arrays of randomly-selected integers.</p>
<h2 id="exercises-43"><a class="header" href="#exercises-43">Exercises</a></h2>
<ol>
<li>(Easy) Write a property which asserts that merging an array with the empty array does not modify the original array. <em>Note</em>: This new property is redundant, since this situation is already covered by our existing property. We're just trying to give you readers a simple way to practice using quickCheck.</li>
<li>(Easy) Add an appropriate error message to the remaining property for <code>merge</code>.</li>
</ol>
<h2 id="testing-polymorphic-code"><a class="header" href="#testing-polymorphic-code">Testing Polymorphic Code</a></h2>
<p>The <code>Merge</code> module defines a generalization of the <code>merge</code> function, called <code>mergePoly</code>, which works not only with arrays of numbers, but also arrays of any type belonging to the <code>Ord</code> type class:</p>
<pre><code class="language-haskell">mergePoly :: forall a. Ord a =&gt; Array a -&gt; Array a -&gt; Array a
</code></pre>
<p>If we modify our original test to use <code>mergePoly</code> in place of <code>merge</code>, we see the following error message:</p>
<pre><code class="language-text">No type class instance was found for

  Test.QuickCheck.Arbitrary.Arbitrary t0

The instance head contains unknown type variables.
Consider adding a type annotation.
</code></pre>
<p>This error message indicates that the compiler could not generate random test cases, because it did not know what type of elements we wanted our arrays to have. In these sorts of cases, we can use type annotations to force the compiler to infer a particular type, such as <code>Array Int</code>:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>We can alternatively use a helper function to specify type, which may result in cleaner code. For example, if we define a function <code>ints</code> as a synonym for the identity function:</p>
<pre><code class="language-haskell">ints :: Array Int -&gt; Array Int
ints = id
</code></pre>
<p>then we can modify our test so that the compiler infers the type <code>Array Int</code> for our two array arguments:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>Here, <code>xs</code> and <code>ys</code> both have type <code>Array Int</code>, since the <code>ints</code> function has been used to disambiguate the unknown type.</p>
<h2 id="exercises-44"><a class="header" href="#exercises-44">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>bools</code> which forces the types of <code>xs</code> and <code>ys</code> to be <code>Array Boolean</code>, and add additional properties which test <code>mergePoly</code> at that type.</li>
<li>(Medium) Choose a pure function from the core libraries (for example, from the <code>arrays</code> package), and write a QuickCheck property for it, including an appropriate error message. Your property should use a helper function to fix any polymorphic type arguments to either <code>Int</code> or <code>Boolean</code>.</li>
</ol>
<h2 id="generating-arbitrary-data"><a class="header" href="#generating-arbitrary-data">Generating Arbitrary Data</a></h2>
<p>Now we will see how the <code>quickcheck</code> library is able to randomly generate test cases for our properties.</p>
<p>Those types whose values can be randomly generated are captured by the <code>Arbitrary</code> type class:</p>
<pre><code class="language-haskell">class Arbitrary t where
  arbitrary :: Gen t
</code></pre>
<p>The <code>Gen</code> type constructor represents the side-effects of <em>deterministic random data generation</em>. It uses a pseudo-random number generator to generate deterministic random function arguments from a seed value. The <code>Test.QuickCheck.Gen</code> module defines several useful combinators for building generators.</p>
<p><code>Gen</code> is also a monad and an applicative functor, so we have the usual collection of combinators at our disposal for creating new instances of the <code>Arbitrary</code> type class.</p>
<p>For example, we can use the <code>Arbitrary</code> instance for the <code>Int</code> type, provided in the <code>quickcheck</code> library, to create a distribution on the 256 byte values, using the <code>Functor</code> instance for <code>Gen</code> to map a function from integers to bytes over arbitrary integer values:</p>
<pre><code class="language-haskell">newtype Byte = Byte Int

instance arbitraryByte :: Arbitrary Byte where
  arbitrary = map intToByte arbitrary
    where
    intToByte n | n &gt;= 0 = Byte (n `mod` 256)
                | otherwise = intToByte (-n)
</code></pre>
<p>Here, we define a type <code>Byte</code> of integral values between 0 and 255. The <code>Arbitrary</code> instance uses the <code>map</code> function to lift the <code>intToByte</code> function over the <code>arbitrary</code> action. The type of the inner <code>arbitrary</code> action is inferred as <code>Gen Int</code>.</p>
<p>We can also use this idea to improve our test for <code>merge</code>:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>In this test, we generated arbitrary arrays <code>xs</code> and <code>ys</code>, but had to sort them, since <code>merge</code> expects sorted input. On the other hand, we could create a newtype representing sorted arrays, and write an <code>Arbitrary</code> instance which generates sorted data:</p>
<pre><code class="language-haskell">newtype Sorted a = Sorted (Array a)

sorted :: forall a. Sorted a -&gt; Array a
sorted (Sorted xs) = xs

instance arbSorted :: (Arbitrary a, Ord a) =&gt; Arbitrary (Sorted a) where
  arbitrary = map (Sorted &lt;&lt;&lt; sort) arbitrary
</code></pre>
<p>With this type constructor, we can modify our test as follows:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs &lt;&gt; sorted ys)
</code></pre>
<p>This may look like a small change, but the types of <code>xs</code> and <code>ys</code> have changed to <code>Sorted Int</code>, instead of just <code>Array Int</code>. This communicates our <em>intent</em> in a clearer way - the <code>mergePoly</code> function takes sorted input. Ideally, the type of the <code>mergePoly</code> function itself would be updated to use the <code>Sorted</code> type constructor.</p>
<p>As a more interesting example, the <code>Tree</code> module defines a type of sorted binary trees with values at the branches:</p>
<pre><code class="language-haskell">data Tree a
  = Leaf
  | Branch (Tree a) a (Tree a)
</code></pre>
<p>The <code>Tree</code> module defines the following API:</p>
<pre><code class="language-haskell">insert    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Tree a
member    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Boolean
fromArray :: forall a. Ord a =&gt; Array a -&gt; Tree a
toArray   :: forall a. Tree a -&gt; Array a
</code></pre>
<p>The <code>insert</code> function is used to insert a new element into a sorted tree, and the <code>member</code> function can be used to query a tree for a particular value. For example:</p>
<pre><code class="language-text">&gt; import Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false
</code></pre>
<p>The <code>toArray</code> and <code>fromArray</code> functions can be used to convert sorted trees to and from arrays. We can use <code>fromArray</code> to write an <code>Arbitrary</code> instance for trees:</p>
<pre><code class="language-haskell">instance arbTree :: (Arbitrary a, Ord a) =&gt; Arbitrary (Tree a) where
  arbitrary = map fromArray arbitrary
</code></pre>
<p>We can now use <code>Tree a</code> as the type of an argument to our test properties, whenever there is an <code>Arbitrary</code> instance available for the type <code>a</code>. For example, we can test that the <code>member</code> test always returns <code>true</code> after inserting a value:</p>
<pre><code class="language-haskell">quickCheck \t a -&gt;
  member a $ insert a $ treeOfInt t
</code></pre>
<p>Here, the argument <code>t</code> is a randomly-generated tree of type <code>Tree Int</code>, where the type argument disambiguated by the identity function <code>treeOfInt</code>.</p>
<h2 id="exercises-45"><a class="header" href="#exercises-45">Exercises</a></h2>
<ol>
<li>(Medium) Create a newtype for <code>String</code> with an associated <code>Arbitrary</code> instance which generates collections of randomly-selected characters in the range <code>a-z</code>. <em>Hint</em>: use the <code>elements</code> and <code>arrayOf</code> functions from the <code>Test.QuickCheck.Gen</code> module.</li>
<li>(Difficult) Write a property which asserts that a value inserted into a tree is still a member of that tree after arbitrarily many more insertions.</li>
</ol>
<h2 id="testing-higher-order-functions"><a class="header" href="#testing-higher-order-functions">Testing Higher-Order Functions</a></h2>
<p>The <code>Merge</code> module defines another generalization of the <code>merge</code> function - the <code>mergeWith</code> function takes an additional function as an argument which is used to determine the order in which elements should be merged. That is, <code>mergeWith</code> is a higher-order function.</p>
<p>For example, we can pass the <code>length</code> function as the first argument, to merge two arrays which are already in length-increasing order. The result should also be in length-increasing order:</p>
<pre><code class="language-haskell">&gt; import Data.String

&gt; mergeWith length
    [&quot;&quot;, &quot;ab&quot;, &quot;abcd&quot;]
    [&quot;x&quot;, &quot;xyz&quot;]

[&quot;&quot;,&quot;x&quot;,&quot;ab&quot;,&quot;xyz&quot;,&quot;abcd&quot;]
</code></pre>
<p>How might we test such a function? Ideally, we would like to generate values for all three arguments, including the first argument which is a function.</p>
<p>There is a second type class which allows us to create randomly-generated functions. It is called <code>Coarbitrary</code>, and it is defined as follows:</p>
<pre><code class="language-haskell">class Coarbitrary t where
  coarbitrary :: forall r. t -&gt; Gen r -&gt; Gen r
</code></pre>
<p>The <code>coarbitrary</code> function takes a function argument of type <code>t</code>, and a random generator for a function result of type <code>r</code>, and uses the function argument to <em>perturb</em> the random generator. That is, it uses the function argument to modify the random output of the random generator for the result.</p>
<p>In addition, there is a type class instance which gives us <code>Arbitrary</code> functions if the function domain is <code>Coarbitrary</code> and the function codomain is <code>Arbitrary</code>:</p>
<pre><code class="language-haskell">instance arbFunction :: (Coarbitrary a, Arbitrary b) =&gt; Arbitrary (a -&gt; b)
</code></pre>
<p>In practice, this means that we can write properties which take functions as arguments. In the case of the <code>mergeWith</code> function, we can generate the first argument randomly, modifying our tests to take account of the new argument.</p>
<p>We cannot guarantee that the result will be sorted - we do not even necessarily have an <code>Ord</code> instance - but we can expect that the result be sorted with respect to the function <code>f</code> that we pass in as an argument. In addition, we need the two input arrays to be sorted with respect to <code>f</code>, so we use the <code>sortBy</code> function to sort <code>xs</code> and <code>ys</code> based on comparison after the function <code>f</code> has been applied:</p>
<pre><code class="language-haskell">quickCheck \xs ys f -&gt;
  let
    result =
      map f $
        mergeWith (intToBool f)
                  (sortBy (compare `on` f) xs)
                  (sortBy (compare `on` f) ys)
    expected =
      map f $
        sortBy (compare `on` f) $ xs &lt;&gt; ys
  in
    eq result expected
</code></pre>
<p>Here, we use a function <code>intToBool</code> to disambiguate the type of the function <code>f</code>:</p>
<pre><code class="language-haskell">intToBool :: (Int -&gt; Boolean) -&gt; Int -&gt; Boolean
intToBool = id
</code></pre>
<p>In addition to being <code>Arbitrary</code>, functions are also <code>Coarbitrary</code>:</p>
<pre><code class="language-haskell">instance coarbFunction :: (Arbitrary a, Coarbitrary b) =&gt; Coarbitrary (a -&gt; b)
</code></pre>
<p>This means that we are not limited to just values and functions - we can also randomly generate <em>higher-order functions</em>, or functions whose arguments are higher-order functions, and so on.</p>
<h2 id="writing-coarbitrary-instances"><a class="header" href="#writing-coarbitrary-instances">Writing Coarbitrary Instances</a></h2>
<p>Just as we can write <code>Arbitrary</code> instances for our data types by using the <code>Monad</code> and <code>Applicative</code> instances of <code>Gen</code>, we can write our own <code>Coarbitrary</code> instances as well. This allows us to use our own data types as the domain of randomly-generated functions.</p>
<p>Let's write a <code>Coarbitrary</code> instance for our <code>Tree</code> type. We will need a <code>Coarbitrary</code> instance for the type of the elements stored in the branches:</p>
<pre><code class="language-haskell">instance coarbTree :: Coarbitrary a =&gt; Coarbitrary (Tree a) where
</code></pre>
<p>We have to write a function which perturbs a random generator given a value of type <code>Tree a</code>. If the input value is a <code>Leaf</code>, then we will just return the generator unchanged:</p>
<pre><code class="language-haskell">  coarbitrary Leaf = id
</code></pre>
<p>If the tree is a <code>Branch</code>, then we will perturb the generator using the left subtree, the value, and the right subtree. We use function composition to create our perturbing function:</p>
<pre><code class="language-haskell">  coarbitrary (Branch l a r) =
    coarbitrary l &lt;&lt;&lt;
    coarbitrary a &lt;&lt;&lt;
    coarbitrary r
</code></pre>
<p>Now we are free to write properties whose arguments include functions taking trees as arguments. For example, the <code>Tree</code> module defines a function <code>anywhere</code>, which tests if a predicate holds on any subtree of its argument:</p>
<pre><code class="language-haskell">anywhere :: forall a. (Tree a -&gt; Boolean) -&gt; Tree a -&gt; Boolean
</code></pre>
<p>Now we are able to generate the predicate function randomly. For example, we expect the <code>anywhere</code> function to <em>respect disjunction</em>:</p>
<pre><code class="language-haskell">quickCheck \f g t -&gt;
  anywhere (\s -&gt; f s || g s) t ==
    anywhere f (treeOfInt t) || anywhere g t
</code></pre>
<p>Here, the <code>treeOfInt</code> function is used to fix the type of values contained in the tree to the type <code>Int</code>:</p>
<pre><code class="language-haskell">treeOfInt :: Tree Int -&gt; Tree Int
treeOfInt = id
</code></pre>
<h2 id="testing-without-side-effects"><a class="header" href="#testing-without-side-effects">Testing Without Side-Effects</a></h2>
<p>For the purposes of testing, we usually include calls to the <code>quickCheck</code> function in the <code>main</code> action of our test suite. However, there is a variant of the <code>quickCheck</code> function, called <code>quickCheckPure</code> which does not use side-effects. Instead, it is a pure function which takes a random seed as an input, and returns an array of test results.</p>
<p>We can test <code>quickCheckPure</code> using PSCi. Here, we test that the <code>merge</code> operation is associative:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Merge
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.LCG (mkSeed)

&gt; :paste
… quickCheckPure (mkSeed 12345) 10 \xs ys zs -&gt;
…   ((xs `merge` ys) `merge` zs) ==
…     (xs `merge` (ys `merge` zs))
… ^D

Success : Success : ...
</code></pre>
<p><code>quickCheckPure</code> takes three arguments: the random seed, the number of test cases to generate, and the property to test. If all tests pass, you should see an array of <code>Success</code> data constructors printed to the console.</p>
<p><code>quickCheckPure</code> might be useful in other situations, such as generating random input data for performance benchmarks, or generating sample form data for web applications.</p>
<h2 id="exercises-46"><a class="header" href="#exercises-46">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write <code>Coarbitrary</code> instances for the <code>Byte</code> and <code>Sorted</code> type constructors.</p>
</li>
<li>
<p>(Medium) Write a (higher-order) property which asserts associativity of the <code>mergeWith f</code> function for any function <code>f</code>. Test your property in PSCi using <code>quickCheckPure</code>.</p>
</li>
<li>
<p>(Medium) Write <code>Arbitrary</code> and <code>Coarbitrary</code> instances for the following data type:</p>
<pre><code class="language-haskell">data OneTwoThree a = One a | Two a a | Three a a a
</code></pre>
<p><em>Hint</em>: Use the <code>oneOf</code> function defined in <code>Test.QuickCheck.Gen</code> to define your <code>Arbitrary</code> instance.</p>
</li>
<li>
<p>(Medium) Use <code>all</code> to simplify the result of the <code>quickCheckPure</code> function - your new function should have type <code>List Result -&gt; Boolean</code> and should return <code>true</code> if every test passes and <code>false</code> otherwise.</p>
</li>
<li>
<p>(Medium) As another approach to simplifying the result of <code>quickCheckPure</code>, try writing a function <code>squashResults :: List Result -&gt; Result</code>. Consider using the <code>First</code> monoid from <code>Data.Maybe.First</code> with the <code>foldMap</code> function to preserve the first error in case of failure.</p>
</li>
</ol>
<h2 id="conclusion-11"><a class="header" href="#conclusion-11">Conclusion</a></h2>
<p>In this chapter, we met the <code>quickcheck</code> package, which can be used to write tests in a declarative way using the paradigm of <em>generative testing</em>. In particular:</p>
<ul>
<li>We saw how to automate QuickCheck tests using <code>spago test</code>.</li>
<li>We saw how to write properties as functions, and how to use the <code>&lt;?&gt;</code> operator to improve error messages.</li>
<li>We saw how the <code>Arbitrary</code> and <code>Coarbitrary</code> type classes enable generation of boilerplate testing code, and how they allow us to test higher-order properties.</li>
<li>We saw how to implement custom <code>Arbitrary</code> and <code>Coarbitrary</code> instances for our own data types.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-specific-languages"><a class="header" href="#domain-specific-languages">Domain-Specific Languages</a></h1>
<h2 id="chapter-goals-12"><a class="header" href="#chapter-goals-12">Chapter Goals</a></h2>
<p>In this chapter, we will explore the implementation of <em>domain-specific languages</em> (or <em>DSLs</em>) in PureScript, using a number of standard techniques.</p>
<p>A domain-specific language is a language which is well-suited to development in a particular problem domain. Its syntax and functions are chosen to maximize readability of code used to express ideas in that domain. We have already seen a number of examples of domain-specific languages in this book:</p>
<ul>
<li>The <code>Game</code> monad and its associated actions, developed in chapter 11, constitute a domain-specific language for the domain of <em>text adventure game development</em>.</li>
<li>The <code>quickcheck</code> package, covered in chapter 13, is a domain-specific language for the domain of <em>generative testing</em>. Its combinators enable a particularly expressive notation for test properties.</li>
</ul>
<p>This chapter will take a more structured approach to some of standard techniques in the implementation of domain-specific languages. It is by no means a complete exposition of the subject, but should provide you with enough knowledge to build some practical DSLs for your own tasks.</p>
<p>Our running example will be a domain-specific language for creating HTML documents. Our aim will be to develop a type-safe language for describing correct HTML documents, and we will work by improving a naive implementation in small steps.</p>
<h2 id="project-setup-11"><a class="header" href="#project-setup-11">Project Setup</a></h2>
<p>The project accompanying this chapter adds one new dependency - the <code>free</code> library, which defines the <em>free monad</em>, one of the tools which we will be using.</p>
<p>We will test this chapter's project in PSCi.</p>
<h2 id="a-html-data-type"><a class="header" href="#a-html-data-type">A HTML Data Type</a></h2>
<p>The most basic version of our HTML library is defined in the <code>Data.DOM.Simple</code> module. The module contains the following type definitions:</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Array Content)
  }

data Content
  = TextContent String
  | ElementContent Element

newtype Attribute = Attribute
  { key          :: String
  , value        :: String
  }
</code></pre>
<p>The <code>Element</code> type represents HTML elements. Each element consists of an element name, an array of attribute pairs and some content. The content property uses the <code>Maybe</code> type to indicate that an element might be open (containing other elements and text) or closed.</p>
<p>The key function of our library is a function</p>
<pre><code class="language-haskell">render :: Element -&gt; String
</code></pre>
<p>which renders HTML elements as HTML strings. We can try out this version of the library by constructing values of the appropriate types explicitly in PSCi:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Simple
&gt; import Data.Maybe
&gt; import Effect.Console

&gt; :paste
… log $ render $ Element
…   { name: &quot;p&quot;
…   , attribs: [
…       Attribute
…         { key: &quot;class&quot;
…         , value: &quot;main&quot;
…         }
…     ]
…   , content: Just [
…       TextContent &quot;Hello World!&quot;
…     ]
…   }
… ^D

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>As it stands, there are several problems with this library:</p>
<ul>
<li>Creating HTML documents is difficult - every new element requires at least one record and one data constructor.</li>
<li>It is possible to represent invalid documents:
<ul>
<li>The developer might mistype the element name</li>
<li>The developer can associate an attribute with the wrong type of element</li>
<li>The developer can use a closed element when an open element is correct</li>
</ul>
</li>
</ul>
<p>In the remainder of the chapter, we will apply certain techniques to solve these problems and turn our library into a usable domain-specific language for creating HTML documents.</p>
<h2 id="smart-constructors"><a class="header" href="#smart-constructors">Smart Constructors</a></h2>
<p>The first technique we will apply is simple but can be very effective. Instead of exposing the representation of the data to the module's users, we can use the module exports list to hide the <code>Element</code>, <code>Content</code> and <code>Attribute</code> data constructors, and only export so-called <em>smart constructors</em>, which construct data which is known to be correct.</p>
<p>Here is an example. First, we provide a convenience function for creating HTML elements:</p>
<pre><code class="language-haskell">element :: String -&gt; Array Attribute -&gt; Maybe (Array Content) -&gt; Element
element name attribs content = Element
  { name:      name
  , attribs:   attribs
  , content:   content
  }
</code></pre>
<p>Next, we create smart constructors for those HTML elements we want our users to be able to create, by applying the <code>element</code> function:</p>
<pre><code class="language-haskell">a :: Array Attribute -&gt; Array Content -&gt; Element
a attribs content = element &quot;a&quot; attribs (Just content)

p :: Array Attribute -&gt; Array Content -&gt; Element
p attribs content = element &quot;p&quot; attribs (Just content)

img :: Array Attribute -&gt; Element
img attribs = element &quot;img&quot; attribs Nothing
</code></pre>
<p>Finally, we update the module exports list to only export those functions which are known to construct correct data structures:</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute(..)
  , Content(..)

  , a
  , p
  , img

  , render
  ) where
</code></pre>
<p>The module exports list is provided immediately after the module name inside parentheses. Each module export can be one of three types:</p>
<ul>
<li>A value (or function), indicated by the name of the value,</li>
<li>A type class, indicated by the name of the class,</li>
<li>A type constructor and any associated data constructors, indicated by the name of the type followed by a parenthesized list of exported data constructors.</li>
</ul>
<p>Here, we export the <code>Element</code> <em>type</em>, but we do not export its data constructors. If we did, the user would be able to construct invalid HTML elements.</p>
<p>In the case of the <code>Attribute</code> and <code>Content</code> types, we still export all of the data constructors (indicated by the symbol <code>..</code> in the exports list). We will apply the technique of smart constructors to these types shortly.</p>
<p>Notice that we have already made some big improvements to our library:</p>
<ul>
<li>It is impossible to represent HTML elements with invalid names (of course, we are restricted to the set of element names provided by the library).</li>
<li>Closed elements cannot contain content by construction.</li>
</ul>
<p>We can apply this technique to the <code>Content</code> type very easily. We simply remove the data constructors for the <code>Content</code> type from the exports list, and provide the following smart constructors:</p>
<pre><code class="language-haskell">text :: String -&gt; Content
text = TextContent

elem :: Element -&gt; Content
elem = ElementContent
</code></pre>
<p>Let's apply the same technique to the <code>Attribute</code> type. First, we provide a general-purpose smart constructor for attributes. Here is a first attempt:</p>
<pre><code class="language-haskell">attribute :: String -&gt; String -&gt; Attribute
attribute key value = Attribute
  { key: key
  , value: value
  }

infix 4 attribute as :=
</code></pre>
<p>This representation suffers from the same problem as the original <code>Element</code> type - it is possible to represent attributes which do not exist or whose names were entered incorrectly. To solve this problem, we can create a newtype which represents attribute names:</p>
<pre><code class="language-haskell">newtype AttributeKey = AttributeKey String
</code></pre>
<p>With that, we can modify our operator as follows:</p>
<pre><code class="language-haskell">attribute :: AttributeKey -&gt; String -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: value
  }
</code></pre>
<p>If we do not export the <code>AttributeKey</code> data constructor, then the user has no way to construct values of type <code>AttributeKey</code> other than by using functions we explicitly export. Here are some examples:</p>
<pre><code class="language-haskell">href :: AttributeKey
href = AttributeKey &quot;href&quot;

_class :: AttributeKey
_class = AttributeKey &quot;class&quot;

src :: AttributeKey
src = AttributeKey &quot;src&quot;

width :: AttributeKey
width = AttributeKey &quot;width&quot;

height :: AttributeKey
height = AttributeKey &quot;height&quot;
</code></pre>
<p>Here is the final exports list for our new module. Note that we no longer export any data constructors directly:</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute
  , Content
  , AttributeKey

  , a
  , p
  , img

  , href
  , _class
  , src
  , width
  , height

  , attribute, (:=)
  , text
  , elem

  , render
  ) where
</code></pre>
<p>If we try this new module in PSCi, we can already see massive improvements in the conciseness of the user code:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Smart
&gt; import Effect.Console
&gt; log $ render $ p [ _class := &quot;main&quot; ] [ text &quot;Hello World!&quot; ]

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>Note, however, that no changes had to be made to the <code>render</code> function, because the underlying data representation never changed. This is one of the benefits of the smart constructors approach - it allows us to separate the internal data representation for a module from the representation which is perceived by users of its external API.</p>
<h2 id="exercises-47"><a class="header" href="#exercises-47">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use the <code>Data.DOM.Smart</code> module to experiment by creating new HTML documents using <code>render</code>.</p>
</li>
<li>
<p>(Medium) Some HTML attributes such as <code>checked</code> and <code>disabled</code> do not require values, and may be rendered as <em>empty attributes</em>:</p>
<pre><code class="language-html">&lt;input disabled&gt;
</code></pre>
<p>Modify the representation of an <code>Attribute</code> to take empty attributes into account. Write a function which can be used in place of <code>attribute</code> or <code>:=</code> to add an empty attribute to an element.</p>
</li>
</ol>
<h2 id="phantom-types"><a class="header" href="#phantom-types">Phantom Types</a></h2>
<p>To motivate the next technique, consider the following code:</p>
<pre><code class="language-text">&gt; log $ render $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := &quot;foo&quot;
    , height := &quot;bar&quot;
    ]

&lt;img src=&quot;cat.jpg&quot; width=&quot;foo&quot; height=&quot;bar&quot; /&gt;
unit
</code></pre>
<p>The problem here is that we have provided string values for the <code>width</code> and <code>height</code> attributes, where we should only be allowed to provide numeric values in units of pixels or percentage points.</p>
<p>To solve this problem, we can introduce a so-called <em>phantom type</em> argument to our <code>AttributeKey</code> type:</p>
<pre><code class="language-haskell">newtype AttributeKey a = AttributeKey String
</code></pre>
<p>The type variable <code>a</code> is called a <em>phantom type</em> because there are no values of type <code>a</code> involved in the right-hand side of the definition. The type <code>a</code> only exists to provide more information at compile-time. Any value of type <code>AttributeKey a</code> is simply a string at runtime, but at compile-time, the type of the value tells us the desired type of the values associated with this key.</p>
<p>We can modify the type of our <code>attribute</code> function to take the new form of <code>AttributeKey</code> into account:</p>
<pre><code class="language-haskell">attribute :: forall a. IsValue a =&gt; AttributeKey a -&gt; a -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: toValue value
  }
</code></pre>
<p>Here, the phantom type argument <code>a</code> is used to ensure that the attribute key and attribute value have compatible types. Since the user cannot create values of type <code>AttributeKey a</code> directly (only via the constants we provide in the library), every attribute will be correct by construction.</p>
<p>Note that the <code>IsValue</code> constraint ensures that whatever value type we associate to a key, its values can be converted to strings and displayed in the generated HTML. The <code>IsValue</code> type class is defined as follows:</p>
<pre><code class="language-haskell">class IsValue a where
  toValue :: a -&gt; String
</code></pre>
<p>We also provide type class instances for the <code>String</code> and <code>Int</code> types:</p>
<pre><code class="language-haskell">instance stringIsValue :: IsValue String where
  toValue = id

instance intIsValue :: IsValue Int where
  toValue = show
</code></pre>
<p>We also have to update our <code>AttributeKey</code> constants so that their types reflect the new type parameter:</p>
<pre><code class="language-haskell">href :: AttributeKey String
href = AttributeKey &quot;href&quot;

_class :: AttributeKey String
_class = AttributeKey &quot;class&quot;

src :: AttributeKey String
src = AttributeKey &quot;src&quot;

width :: AttributeKey Int
width = AttributeKey &quot;width&quot;

height :: AttributeKey Int
height = AttributeKey &quot;height&quot;
</code></pre>
<p>Now we find it is impossible to represent these invalid HTML documents, and we are forced to use numbers to represent the <code>width</code> and <code>height</code> attributes instead:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Phantom
&gt; import Effect.Console

&gt; :paste
… log $ render $ img
…   [ src    := &quot;cat.jpg&quot;
…   , width  := 100
…   , height := 200
…   ]
… ^D

&lt;img src=&quot;cat.jpg&quot; width=&quot;100&quot; height=&quot;200&quot; /&gt;
unit
</code></pre>
<h2 id="exercises-48"><a class="header" href="#exercises-48">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Create a data type which represents either pixel or percentage lengths. Write an instance of <code>IsValue</code> for your type. Modify the <code>width</code> and <code>height</code> attributes to use your new type.</p>
</li>
<li>
<p>(Difficult) By defining type-level representatives for the Boolean values <code>true</code> and <code>false</code>, we can use a phantom type to encode whether an <code>AttributeKey</code> represents an <em>empty attribute</em> such as <code>disabled</code> or <code>checked</code>.</p>
<pre><code class="language-haskell">data True
data False
</code></pre>
<p>Modify your solution to the previous exercise to use a phantom type to prevent the user from using the <code>attribute</code> operator with an empty attribute.</p>
</li>
</ol>
<h2 id="the-free-monad"><a class="header" href="#the-free-monad">The Free Monad</a></h2>
<p>In our final set of modifications to our API, we will use a construction called the <em>free monad</em> to turn our <code>Content</code> type into a monad, enabling do notation. This will allow us to structure our HTML documents in a form in which the nesting of elements becomes clearer - instead of this:</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ]
  [ elem $ img
      [ src    := &quot;cat.jpg&quot;
      , width  := 100
      , height := 200
      ]
  , text &quot;A cat&quot;
  ]
</code></pre>
<p>we will be able to write this:</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ] $ do
  elem $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := 100
    , height := 200
    ]
  text &quot;A cat&quot;
</code></pre>
<p>However, do notation is not the only benefit of a free monad. The free monad allows us to separate the <em>representation</em> of our monadic actions from their <em>interpretation</em>, and even support <em>multiple interpretations</em> of the same actions.</p>
<p>The <code>Free</code> monad is defined in the <code>free</code> library, in the <code>Control.Monad.Free</code> module. We can find out some basic information about it using PSCi, as follows:</p>
<pre><code class="language-text">&gt; import Control.Monad.Free

&gt; :kind Free
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>The kind of <code>Free</code> indicates that it takes a type constructor as an argument, and returns another type constructor. In fact, the <code>Free</code> monad can be used to turn any <code>Functor</code> into a <code>Monad</code>!</p>
<p>We begin by defining the <em>representation</em> of our monadic actions. To do this, we need to create a <code>Functor</code> with one data constructor for each monadic action we wish to support. In our case, our two monadic actions will be <code>elem</code> and <code>text</code>. In fact, we can simply modify our <code>Content</code> type as follows:</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a

instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
</code></pre>
<p>Here, the <code>ContentF</code> type constructor looks just like our old <code>Content</code> data type - however, it now takes a type argument <code>a</code>, and each data constructor has been modified to take a value of type <code>a</code> as an additional argument. The <code>Functor</code> instance simply applies the function <code>f</code> to the value of type <code>a</code> in each data constructor.</p>
<p>With that, we can define our new <code>Content</code> monad as a type synonym for the <code>Free</code> monad, which we construct by using our <code>ContentF</code> type constructor as the first type argument:</p>
<pre><code class="language-haskell">type Content = Free ContentF
</code></pre>
<p>Instead of a type synonym, we might use a <code>newtype</code> to avoid exposing the internal representation of our library to our users - by hiding the <code>Content</code> data constructor, we restrict our users to only using the monadic actions we provide.</p>
<p>Because <code>ContentF</code> is a <code>Functor</code>, we automatically get a <code>Monad</code> instance for <code>Free ContentF</code>.</p>
<p>We have to modify our <code>Element</code> data type slightly to take account of the new type argument on <code>Content</code>. We will simply require that the return type of our monadic computations be <code>Unit</code>:</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Content Unit)
  }
</code></pre>
<p>In addition, we have to modify our <code>elem</code> and <code>text</code> functions, which become our new monadic actions for the <code>Content</code> monad. To do this, we can use the <code>liftF</code> function, provided by the <code>Control.Monad.Free</code> module. Here is its type:</p>
<pre><code class="language-haskell">liftF :: forall f a. f a -&gt; Free f a
</code></pre>
<p><code>liftF</code> allows us to construct an action in our free monad from a value of type <code>f a</code> for some type <code>a</code>. In our case, we can simply use the data constructors of our <code>ContentF</code> type constructor directly:</p>
<pre><code class="language-haskell">text :: String -&gt; Content Unit
text s = liftF $ TextContent s unit

elem :: Element -&gt; Content Unit
elem e = liftF $ ElementContent e unit
</code></pre>
<p>Some other routine modifications have to be made, but the interesting changes are in the <code>render</code> function, where we have to <em>interpret</em> our free monad.</p>
<h2 id="interpreting-the-monad"><a class="header" href="#interpreting-the-monad">Interpreting the Monad</a></h2>
<p>The <code>Control.Monad.Free</code> module provides a number of functions for interpreting a computation in a free monad:</p>
<pre><code class="language-haskell">runFree
  :: forall f a
   . Functor f
  =&gt; (f (Free f a) -&gt; Free f a)
  -&gt; Free f a
  -&gt; a

runFreeM
  :: forall f m a
   . (Functor f, MonadRec m)
  =&gt; (f (Free f a) -&gt; m (Free f a))
  -&gt; Free f a
  -&gt; m a
</code></pre>
<p>The <code>runFree</code> function is used to compute a <em>pure</em> result. The <code>runFreeM</code> function allows us to use a monad to interpret the actions of our free monad.</p>
<p><em>Note</em>: Technically, we are restricted to using monads <code>m</code> which satisfy the stronger <code>MonadRec</code> constraint. In practice, this means that we don't need to worry about stack overflow, since <code>m</code> supports safe <em>monadic tail recursion</em>.</p>
<p>First, we have to choose a monad in which we can interpret our actions. We will use the <code>Writer String</code> monad to accumulate a HTML string as our result.</p>
<p>Our new <code>render</code> method starts by delegating to a helper function, <code>renderElement</code>, and using <code>execWriter</code> to run our computation in the <code>Writer</code> monad:</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render = execWriter &lt;&lt;&lt; renderElement
</code></pre>
<p><code>renderElement</code> is defined in a where block:</p>
<pre><code class="language-haskell">  where
    renderElement :: Element -&gt; Writer String Unit
    renderElement (Element e) = do
</code></pre>
<p>The definition of <code>renderElement</code> is straightforward, using the <code>tell</code> action from the <code>Writer</code> monad to accumulate several small strings:</p>
<pre><code class="language-haskell">      tell &quot;&lt;&quot;
      tell e.name
      for_ e.attribs $ \x -&gt; do
        tell &quot; &quot;
        renderAttribute x
      renderContent e.content
</code></pre>
<p>Next, we define the <code>renderAttribute</code> function, which is equally simple:</p>
<pre><code class="language-haskell">    where
      renderAttribute :: Attribute -&gt; Writer String Unit
      renderAttribute (Attribute x) = do
        tell x.key
        tell &quot;=\&quot;&quot;
        tell x.value
        tell &quot;\&quot;&quot;
</code></pre>
<p>The <code>renderContent</code> function is more interesting. Here, we use the <code>runFreeM</code> function to interpret the computation inside the free monad, delegating to a helper function, <code>renderContentItem</code>:</p>
<pre><code class="language-haskell">      renderContent :: Maybe (Content Unit) -&gt; Writer String Unit
      renderContent Nothing = tell &quot; /&gt;&quot;
      renderContent (Just content) = do
        tell &quot;&gt;&quot;
        runFreeM renderContentItem content
        tell &quot;&lt;/&quot;
        tell e.name
        tell &quot;&gt;&quot;
</code></pre>
<p>The type of <code>renderContentItem</code> can be deduced from the type signature of <code>runFreeM</code>. The functor <code>f</code> is our type constructor <code>ContentF</code>, and the monad <code>m</code> is the monad in which we are interpreting the computation, namely <code>Writer String</code>. This gives the following type signature for <code>renderContentItem</code>:</p>
<pre><code class="language-haskell">      renderContentItem :: ContentF (Content Unit) -&gt; Writer String (Content Unit)
</code></pre>
<p>We can implement this function by simply pattern matching on the two data constructors of <code>ContentF</code>:</p>
<pre><code class="language-haskell">      renderContentItem (TextContent s rest) = do
        tell s
        pure rest
      renderContentItem (ElementContent e rest) = do
        renderElement e
        pure rest
</code></pre>
<p>In each case, the expression <code>rest</code> has the type <code>Content Unit</code>, and represents the remainder of the interpreted computation. We can complete each case by returning the <code>rest</code> action.</p>
<p>That's it! We can test our new monadic API in PSCi, as follows:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Free
&gt; import Effect.Console

&gt; :paste
… log $ render $ p [] $ do
…   elem $ img [ src := &quot;cat.jpg&quot; ]
…   text &quot;A cat&quot;
… ^D

&lt;p&gt;&lt;img src=&quot;cat.jpg&quot; /&gt;A cat&lt;/p&gt;
unit
</code></pre>
<h2 id="exercises-49"><a class="header" href="#exercises-49">Exercises</a></h2>
<ol>
<li>(Medium) Add a new data constructor to the <code>ContentF</code> type to support a new action <code>comment</code>, which renders a comment in the generated HTML. Implement the new action using <code>liftF</code>. Update the interpretation <code>renderContentItem</code> to interpret your new constructor appropriately.</li>
</ol>
<h2 id="extending-the-language"><a class="header" href="#extending-the-language">Extending the Language</a></h2>
<p>A monad in which every action returns something of type <code>Unit</code> is not particularly interesting. In fact, aside from an arguably nicer syntax, our monad adds no extra functionality over a <code>Monoid</code>.</p>
<p>Let's illustrate the power of the free monad construction by extending our language with a new monadic action which returns a non-trivial result.</p>
<p>Suppose we want to generate HTML documents which contain hyperlinks to different sections of the document using <em>anchors</em>. We can accomplish this already, by generating anchor names by hand and including them at least twice in the document: once at the definition of the anchor itself, and once in each hyperlink. However, this approach has some basic issues:</p>
<ul>
<li>The developer might fail to generate unique anchor names.</li>
<li>The developer might mistype one or more instances of the anchor name.</li>
</ul>
<p>In the interest of protecting the developer from their own mistakes, we can introduce a new type which represents anchor names, and provide a monadic action for generating new unique names.</p>
<p>The first step is to add a new type for names:</p>
<pre><code class="language-haskell">newtype Name = Name String

runName :: Name -&gt; String
runName (Name n) = n
</code></pre>
<p>Again, we define this as a newtype around <code>String</code>, but we must be careful not to export the data constructor in the module's export lists.</p>
<p>Next, we define an instance for the <code>IsValue</code> type class for our new type, so that we are able to use names in attribute values:</p>
<pre><code class="language-haskell">instance nameIsValue :: IsValue Name where
  toValue (Name n) = n
</code></pre>
<p>We also define a new data type for hyperlinks which can appear in <code>a</code> elements, as follows:</p>
<pre><code class="language-haskell">data Href
  = URLHref String
  | AnchorHref Name

instance hrefIsValue :: IsValue Href where
  toValue (URLHref url) = url
  toValue (AnchorHref (Name nm)) = &quot;#&quot; &lt;&gt; nm
</code></pre>
<p>With this new type, we can modify the value type of the <code>href</code> attribute, forcing our users to use our new <code>Href</code> type. We can also create a new <code>name</code> attribute, which can be used to turn an element into an anchor:</p>
<pre><code class="language-haskell">href :: AttributeKey Href
href = AttributeKey &quot;href&quot;

name :: AttributeKey Name
name = AttributeKey &quot;name&quot;
</code></pre>
<p>The remaining problem is that our users currently have no way to generate new names. We can provide this functionality in our <code>Content</code> monad. First, we need to add a new data constructor to our <code>ContentF</code> type constructor:</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a
  | NewName (Name -&gt; a)
</code></pre>
<p>The <code>NewName</code> data constructor corresponds to an action which returns a value of type <code>Name</code>. Notice that instead of requiring a <code>Name</code> as a data constructor argument, we require the user to provide a <em>function</em> of type <code>Name -&gt; a</code>. Remembering that the type <code>a</code> represents the <em>rest of the computation</em>, we can see that this function provides a way to continue computation after a value of type <code>Name</code> has been returned.</p>
<p>We also need to update the <code>Functor</code> instance for <code>ContentF</code>, taking into account the new data constructor, as follows:</p>
<pre><code class="language-haskell">instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
  map f (NewName k) = NewName (f &lt;&lt;&lt; k)
</code></pre>
<p>Now we can build our new action by using the <code>liftF</code> function, as before:</p>
<pre><code class="language-haskell">newName :: Content Name
newName = liftF $ NewName id
</code></pre>
<p>Notice that we provide the <code>id</code> function as our continuation, meaning that we return the result of type <code>Name</code> unchanged.</p>
<p>Finally, we need to update our interpretation function, to interpret the new action. We previously used the <code>Writer String</code> monad to interpret our computations, but that monad does not have the ability to generate new names, so we must switch to something else. The <code>WriterT</code> monad transformer can be used with the <code>State</code> monad to combine the effects we need. We can define our interpretation monad as a type synonym to keep our type signatures short:</p>
<pre><code class="language-haskell">type Interp = WriterT String (State Int)
</code></pre>
<p>Here, the state of type <code>Int</code> will act as an incrementing counter, used to generate unique names.</p>
<p>Because the <code>Writer</code> and <code>WriterT</code> monads use the same type class members to abstract their actions, we do not need to change any actions - we only need to replace every reference to <code>Writer String</code> with <code>Interp</code>. We do, however, need to modify the handler used to run our computation. Instead of just <code>execWriter</code>, we now need to use <code>evalState</code> as well:</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render e = evalState (execWriterT (renderElement e)) 0
</code></pre>
<p>We also need to add a new case to <code>renderContentItem</code>, to interpret the new <code>NewName</code> data constructor:</p>
<pre><code class="language-haskell">renderContentItem (NewName k) = do
  n &lt;- get
  let fresh = Name $ &quot;name&quot; &lt;&gt; show n
  put $ n + 1
  pure (k fresh)
</code></pre>
<p>Here, we are given a continuation <code>k</code> of type <code>Name -&gt; Content a</code>, and we need to construct an interpretation of type <code>Content a</code>. Our interpretation is simple: we use <code>get</code> to read the state, use that state to generate a unique name, then use <code>put</code> to increment the state. Finally, we pass our new name to the continuation to complete the computation.</p>
<p>With that, we can try out our new functionality in PSCi, by generating a unique name inside the <code>Content</code> monad, and using it as both the name of an element and the target of a hyperlink:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Name
&gt; import Effect.Console

&gt; :paste
… render $ p [ ] $ do
…   top &lt;- newName
…   elem $ a [ name := top ] $
…     text &quot;Top&quot;
…   elem $ a [ href := AnchorHref top ] $
…     text &quot;Back to top&quot;
… ^D

&lt;p&gt;&lt;a name=&quot;name0&quot;&gt;Top&lt;/a&gt;&lt;a href=&quot;#name0&quot;&gt;Back to top&lt;/a&gt;&lt;/p&gt;
unit
</code></pre>
<p>You can verify that multiple calls to <code>newName</code> do in fact result in unique names.</p>
<h2 id="exercises-50"><a class="header" href="#exercises-50">Exercises</a></h2>
<ol>
<li>
<p>(Medium) We can simplify the API further by hiding the <code>Element</code> type from its users. Make these changes in the following steps:</p>
<ul>
<li>Combine functions like <code>p</code> and <code>img</code> (with return type <code>Element</code>) with the <code>elem</code> action to create new actions with return type <code>Content Unit</code>.</li>
<li>Change the <code>render</code> function to accept an argument of type <code>Content Unit</code> instead of <code>Element</code>.</li>
</ul>
</li>
<li>
<p>(Medium) Hide the implementation of the <code>Content</code> monad by using a <code>newtype</code> instead of a type synonym. You should not export the data
constructor for your <code>newtype</code>.</p>
</li>
<li>
<p>(Difficult) Modify the <code>ContentF</code> type to support a new action</p>
<pre><code class="language-haskell">isMobile :: Content Boolean
</code></pre>
<p>which returns a boolean value indicating whether or not the document is being rendered for display on a mobile device.</p>
<p><em>Hint</em>: use the <code>ask</code> action and the <code>ReaderT</code> monad transformer to interpret this action. Alternatively, you might prefer to use the <code>RWS</code> monad.</p>
</li>
</ol>
<h2 id="conclusion-12"><a class="header" href="#conclusion-12">Conclusion</a></h2>
<p>In this chapter, we developed a domain-specific language for creating HTML documents, by incrementally improving a naive implementation using some standard techniques:</p>
<ul>
<li>We used <em>smart constructors</em> to hide the details of our data representation, only permitting the user to create documents which were <em>correct-by-construction</em>.</li>
<li>We used an <em>user-defined infix binary operator</em> to improve the syntax of the language.</li>
<li>We used <em>phantom types</em> to encode additional information in the types of our data, preventing the user from providing attribute values of the wrong type.</li>
<li>We used the <em>free monad</em> to turn our array representation of a collection of content into a monadic representation supporting do notation. We then extended this representation to support a new monadic action, and interpreted the monadic computations using standard monad transformers.</li>
</ul>
<p>These techniques all leverage PureScript's module and type systems, either to prevent the user from making mistakes or to improve the syntax of the domain-specific language.</p>
<p>The implementation of domain-specific languages in functional programming languages is an area of active research, but hopefully this provides a useful introduction some simple techniques, and illustrates the power of working in a language with expressive types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="実例によるpurescript"><a class="header" href="#実例によるpurescript">実例によるPureScript</a></h1>
<p>このリポジトリには、Phil Freemanによる<strong>PureScript by
Example</strong>の<a href="https://github.com/purescript-contrib/purescript-book/">コミュニティフォーク</a>が含まれます。
同書は&quot;the PureScript book&quot; としても知られています。
このバージョンはコードと演習が最近のバージョンのコンパイラ、ライブラリ、ツールで動くように更新されています。
PureScriptのエコシステムの最新の機能を紹介すべく書き直された章もあります。</p>
<p>本書をお楽しみいただきお役立ちいただけましたら、<a href="https://leanpub.com/purescript">Leanpubの原書</a>の購入をご検討ください。</p>
<h2 id="現状"><a class="header" href="#現状">現状</a></h2>
<p>この本は言語の進化に伴って継続的に更新されているため、内容に関して発見したどんな<a href="https://github.com/purescript-contrib/purescript-book/issues">問題</a>でもご報告ください。
より初心者にやさしくできそうな分かりづらい節を指摘するような単純なものであれ、共有いただいたどんなフィードバックにも感謝します。</p>
<p>それぞれの章には単体テストも加えられているので、演習への自分の回答が正しいかどうか確かめることができます。
テストの最新の状態については<a href="https://github.com/purescript-contrib/purescript-book/issues/79">#79</a>を見てください。</p>
<h2 id="本書について"><a class="header" href="#本書について">本書について</a></h2>
<p>PureScriptは、表現力のある型を持つ、小さく、強力で、静的に型付けされたプログラミング言語です。
Haskellで書かれ、またこの言語から着想を得ています。
そして、JavaScriptにコンパイルされます。</p>
<p>JavaScriptでの関数型プログラミングは最近かなりの人気を誇るようになりましたが、コードを書く上で統制された環境が欠けていることが大規模なアプリケーション開発の妨げとなっています。
PureScriptは、強力に型付けされた関数型プログラミングの力をJavaScriptでの開発の世界に持ち込むことにより、この問題の解決を目指しています。</p>
<p>この本は、基礎（開発環境の立ち上げ）から応用に至るまでの、PureScriptプログラミング言語の始め方を示します。</p>
<p>それぞれの章は特定の課題により動機付けられており、その問題を解いていく過程において、新しい関数型プログラミングの道具と技法が導入されていきます。
以下はこの本で解いていく課題のいくつかの例です。</p>
<ul>
<li>マップと畳み込みを使ったデータ構造の変換</li>
<li>アプリカティブ関手を使ったフォームフィールドの検証</li>
<li>QuickCheckによるコードの検査</li>
<li>Canvasの使用</li>
<li>領域特化言語の実装</li>
<li>DOMの取り回し</li>
<li>JavaScriptの相互運用性</li>
<li>並列非同期実行</li>
</ul>
<h2 id="使用許諾"><a class="header" href="#使用許諾">使用許諾</a></h2>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons
Attribution-NonCommercial-ShareAlike 3.0 Unported License:
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p><small>※以降の原文の使用許諾に関する和訳は法的効力を持ちません。<br>
本書のテキストは<a
href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">表示 - 非営利 -
継承3.0非移植 (CC BY-NC-SA 3.0)</a>のもとに使用が許諾される。</small></p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation
Repo</a>, which uses the same
license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various
contributors</a>.</p>
<p><small>いくつかのテキストは<a href="https://github.com/purescript/documentation">PureScriptのドキュメントリポジトリ</a>から派生している。
派生元も同じ使用許諾であり、<a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">様々な形で貢献された方々</a>の著作権が含まれる。</small></p>
<p>The exercises are licensed under the MIT license.</p>
<p><small>演習はMITライセンスの下に使用が許諾される。</small></p>
<hr />
<small>
<p>Copyright (C) 2015-2018 aratama.<br>
Copyright (C) 2022 gemmaro.</p>
<p>この翻訳は<a href="https://github.com/aratama">aratama</a>氏による翻訳を元に改変を加えています。
同氏の翻訳リポジトリは<a href="https://github.com/aratama/purescript-book-ja"><code>aratama/purescript-book-ja</code></a>に、Webサイトは<a href="http://aratama.github.io/purescript/">実例によるPureScript</a>にあります。
<a href="http://aratama.github.io/purescript/">aratama氏訳の使用許諾</a>は以下の通りです。</p>
<blockquote>
<p>This book is licensed under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</p>
<p>本書は<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">クリエイティブコモンズ 表示 - 非営利 - 継承 3.0 非移植ライセンス</a>でライセンスされています。</p>
</blockquote>
<p>本翻訳も原文と原翻訳にしたがい、
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>の下に使用が許諾されます。</p>
</small><div style="break-before: page; page-break-before: always;"></div><h1 id="導入"><a class="header" href="#導入">導入</a></h1>
<h2 id="関数型javascript"><a class="header" href="#関数型javascript">関数型JavaScript</a></h2>
<p>関数型プログラミングの手法がJavaScriptに姿を現しはじめてからしばらく経ちます。</p>
<ul>
<li>
<p><a href="https://underscorejs.org">UnderscoreJS</a>などのライブラリがあれば、開発
者は<code>map</code>や <code>filter</code>、<code>reduce</code>といった実績のある関数を活用して、小さい
プログラムを組み合わせることで大きなプログラムを作ることができます。</p>
<pre><code class="language-javascript">var sumOfPrimes =
    _.chain(_.range(1000))
     .filter(isPrime)
     .reduce(function(x, y) {
         return x + y;
     })
     .value();
</code></pre>
</li>
<li>
<p>NodeJSにおける非同期プログラミングでは、第一級の値としての関数をコール
バックを定義するために多用しています。</p>
<pre><code class="language-javascript">import { readFile, writeFile } from 'fs'

readFile(sourceFile, function (error, data) {
  if (!error) {
    writeFile(destFile, data, function (error) {
      if (!error) {
        console.log(&quot;File copied&quot;);
      }
    });
  }
});
</code></pre>
</li>
<li>
<p><a href="https://reactjs.org">React</a>や<a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a>などのライブラリは、アプリケーションの状態についての純粋な関数としてその外観をモデル化しています</p>
</li>
</ul>
<p>関数は単純な抽象化を可能にし、優れた生産性をもたらしてくれます。
しかし、JavaScriptでの関数型プログラミングには欠点があります。
JavaScriptは冗長で、型付けされず、強力な抽象化を欠いているのです。
また、無秩序に書かれたJavaScriptコードでは、等式推論がとても困難です。</p>
<p>PureScriptはこのような問題を解決すべく作られたプログラミング言語です。
PureScriptは、とても表現力豊かでありながらわかりやすく読みやすいコードを書けるようにする、
軽量な構文を備えています。
強力な抽象化を提供する豊かな型システムも採用しています。
また、JavaScriptやJavaScriptへとコンパイルされる他の言語と相互運用するときに重要な、
高速で理解しやすいコードを生成します。
PureScriptをひとことで言えば、純粋関数型プログラミングの理論的な強力さと、
JavaScriptのお手軽で緩いプログラミングスタイルとの、
とても現実的なバランスを狙った言語だということを理解して頂けたらと思います。</p>
<h2 id="型と型推論"><a class="header" href="#型と型推論">型と型推論</a></h2>
<p>動的型付けの言語と静的型付けの言語をめぐる議論についてはよく知られています。
PureScriptは<strong>静的型付け</strong>の言語、
つまり正しいプログラムはコンパイラによってその動作を示すような<strong>型</strong>を与えられる言語です。
逆にいえば、型を​​与えることができないプログラムは<strong>誤ったプログラム</strong>であり、
コンパイラによって拒否されます。
動的型付けの言語とは異なり、
PureScriptでは型は<strong>コンパイル時</strong>のみに存在し、
実行時には型の表現はありません。</p>
<p>PureScriptの型は、これまでJavaやC#のような他の言語で見たような型とは、
いろいろな意味で異なっていることにも注意することが大切です。
おおまかに言えばPureScriptの型はJavaやC#と同じ目的を持っているものの、
PureScriptの型はMLとHaskellのような言語に影響を受けています。
開発者がプログラムについての強い主張を表明できるので、PureScriptの型は表現力豊かなのです。
最も重要なのは、PureScriptの型システムは<strong>型推論</strong>(type inference)をサポートしていることです。
型推論があれば他の言語より遥かに少ない型注釈で住み、
型システムを厄介者ではなく<strong>道具</strong>にしてくれます。
簡単な例を示すと、次のコードは<strong>数</strong>を定義していますが、
それが <code>Number</code>型だという注釈はコードのどこにもありません。</p>
<pre><code class="language-haskell">iAmANumber =
  let square x = x * x
  in square 42.0
</code></pre>
<p>次のもっと複雑な例では、
<strong>コンパイラにとって未知</strong>の型が存在しているときでさえも、
型注釈なしで型の正しさを確かめることができるということが示されています。</p>
<pre><code class="language-haskell">iterate f 0 x = x
iterate f n x = iterate f (n - 1) (f x)
</code></pre>
<p>ここで <code>x</code>の型は不明ですが、
<code>x</code>がどんな型を持っているかにかかわらず、
<code>iterate</code>が型システムの規則に従っていることをコンパイラは検証することができます。</p>
<p>本書で納得していただきたい（または既にお持ちの信条に寄り添って改めて断言したい）ことは、
静的型が単にプログラムの正しさに自信を持つためだけのものではなく、
それ自身の正しさによって開発の手助けになるものでもあるということです。
JavaScriptではごく単純な抽象化を施すのでも大規模なコードのリファクタリングをすることは難しいですが、
型検証器のある表現力豊かな型システムは、
リファクタリングさえ楽しく対話的な体験にしてくれます。</p>
<p>加えて、型システムによって提供されるこのセーフティネットは、
より高度な抽象化をも可能にします。
実際に、関数型プログラミング言語Haskellによって知られるようになった、
型駆動の強力な抽象化の形式である『型クラス』をPureScriptは備えています。</p>
<h2 id="多言語webプログラミング"><a class="header" href="#多言語webプログラミング">多言語Webプログラミング</a></h2>
<p>関数型プログラミングはすでに多くの成功を収めています。
枚挙に暇がありませんが、特に成功している応用例をいくつか挙げると、
データ解析、構文解析、コンパイラの実装、ジェネリックプログラミング、並列処理などがあります。</p>
<p>PureScriptのような関数型言語は、
アプリケーション開発の最初から最後までを​実施することが可能です。
値や関数の型を提供することで既存のJavaScriptコードをインポートし、
通常のPureScriptコードからこれらの関数を使用する機能をPureScriptは提供しています。
この手法については本書の後半で見ていくことになります。</p>
<p>しかしながら、PureScriptの強みのひとつは、JavaScriptを対象とする他​​の言語との相互運用性にあります。アプリケーションの開発の一部にだけPureScriptを使用し、JavaScriptの残りの部分を記述するのに他の言語を使用するという方法もあります。</p>
<p>いくつかの例を示します。</p>
<ul>
<li>中核となる処理はPureScriptで記述し、ユーザーインターフェイスは
JavaScriptで記述する</li>
<li>JavaScriptや、他のJavaScriptにコンパイルする言語でアプリケーションを書
き、PureScriptでそのテストを書く</li>
<li>既存のアプリケーションのユーザインタフェースのテストを自動化するために
PureScriptを使用する</li>
</ul>
<p>この本では小規模な課題をPureScriptで解決することに焦点を当てます。
ここで学ぶ手法は大規模なアプリケーションに組み込むこともできますが、
これについてはJavaScriptからPureScriptコードを呼び出す方法、およびその逆についても見ていきます。</p>
<h2 id="ソフトウェア要件"><a class="header" href="#ソフトウェア要件">ソフトウェア要件</a></h2>
<p>この本でのソフトウェア要件は最小限です。
第1章では開発環境の構築を一から案内します。
これから使用するツールは、ほとんどの現代のオペレーティングシステムの標準リポジトリで使用できるものです。</p>
<p>PureScriptコンパイラ自体はバイナリ形式でダウンロードすることもできますし、
最新のHaskellコンパイラが稼働しているシステム上でソースからビルドすることもできます。
次の章ではこの手順を説明していきます。</p>
<p>本書のこのバージョンのコードは<code>0.15.*</code>バージョンのPureScriptコンパイラと互換性があります。</p>
<h2 id="読者について"><a class="header" href="#読者について">読者について</a></h2>
<p>読者はJavaScriptの基本をすでに理解しているものと仮定します。
すでにNPMやBowerのようなJavaScriptのエコシステムでの経験があれば、
自身の好みに応じて標準設定をカスタマイズしたい場合などに役に立ちます。
ですが、そのような知識は必須ではありません。</p>
<p>関数型プログラミングの予備知識は必要ありませんが、
あっても害にはならないでしょう。
新しい考えかたは実例とともに登場するので、
これから使う関数型プログラミングからこうした概念に対する直感的な理解を得ることができるはずです。</p>
<p>PureScriptはプログラミング言語Haskellに強く影響を受けているため、Haskellに通じている読者はこの本の中で提示された概念や構文の多くに見覚えがあるでしょう。しかしながら、読者はPureScriptとHaskellの間にはいくつか重要な違いがあることも理解しておかなければなりません。ここで紹介する概念の多くはHaskellでも同じように解釈できるとはいえ、どちらかの言語での考え方を他方の言語でそのまま応用しようとすることは、必ずしも適切ではありません。</p>
<h2 id="本書の読み進めかた"><a class="header" href="#本書の読み進めかた">本書の読み進めかた</a></h2>
<p>本書の各章は、概ね章ごとに完結しています。
しかしながら、多少の関数型プログラミングの経験がある初心者でも、
まずは各章を順番に進めていくことをおすすめします。
最初の数章では、本書の後半の内容を理解するために必要な基礎知識を養います。
関数型プログラミングの考え方に十分通じた読者
（特にMLやHaskellのよう強く型付けされた言語での経験を持つ読者）なら、
本書の前半の章を読まなくても、後半の章のコードの大まかな理解を得ることがおそらく可能でしょう。</p>
<p>各章ではそれぞれひとつの実用的な例に焦点をあて、新しい考え方を導入するための動機付けとして用います。
各章のコードは本書の<a href="https://github.com/purescript-contrib/purescript-book">GitHubのリポジトリ</a>から入手できます。
ソースコードから抜粋したコード片が掲載されている章もありますが、完全に理解するためには本書に掲載されたコードと平行してリポジトリのソースコードを読む必要があります。
対話式環境PSCiで実行し理解を確かめられるように、長めの節には短いコード片が掲載されていることがあります。</p>
<p>コード例は次のように等幅フォントで示されています。</p>
<pre><code class="language-haskell">module Example where

import Effect.Console (log)

main = log &quot;Hello, World!&quot;
</code></pre>
<p>先頭にドル記号がついた行は、コマンドラインに入力されたコマンドです。</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>通常、これらのコマンドはLinuxやMac
OSの利用者ならそのまま適用できますが、Windowsの利用者はファイル区切り文字を変更する、シェルの組み込み機能をWindowsの相当するものに置き換えるなどの小さな変更を加える必要があるかもしれません。</p>
<p>PSCi対話式モードプロンプトに入力するコマンドは、行の先頭に山括弧が付けられています。</p>
<pre><code class="language-text">&gt; 1 + 2
3
</code></pre>
<p>各章には演習が付いており、それぞれ難易度も示されています。各章の内容を完全に理解するために、演習に取り組むことを強くお勧めします。</p>
<p>この本は初心者にPureScriptへの導入を提供することを目的としており、問題についてのお決まりの解決策の一覧を提供するような種類の本ではありません。初心者にとってこの本を読むのは楽しい挑戦になるはずですし、本書の内容を読み演習に挑戦すればだいたいの利益を得られるでしょうが、なにより重要なのは、あなたが自分自身のコードを書いてみることです。</p>
<h2 id="困ったときには"><a class="header" href="#困ったときには">困ったときには</a></h2>
<p>もしどこかでつまずいたときには、PureScriptを学べるオンラインで利用可能な資料がたくさんあります。</p>
<ul>
<li><a href="https://discord.gg/vKn9up84bp">PureScriptのDiscordサーバ</a>は抱えている
問題についてチャットするのに良い場所です。サーバはPureScriptについての
チャット専用です。</li>
<li><a href="https://discourse.purescript.org/">PurescriptのDiscourseフォーラム</a>も
よくある問題への解決策を探すのに良い場所です。メッセージ履歴が約2週間
しか保たないSlackとは違い、ここで質問した内容は将来の読者の助けとして
使えるでしょう。</li>
<li><a href="https://github.com/jordanmartinez/purescript-jordans-reference">PureScript: Jordan's
Reference</a>
は別のかなり深く踏み込んだ学習資料です。この本の中のある概念が理解しに
くかったら、そちらの参考書の対応する節を読むとよいでしょう。</li>
<li><a href="https://pursuit.purescript.org">Pursuit</a>はPureScriptの型と関数を検索
できるデータベースです。Pursuitのヘルプページを読むと<a href="https://pursuit.purescript.org/help/users">どのような種類の
検索ができるのかがわかりま
す</a>。</li>
<li>非公式の<a href="https://github.com/JordanMartinez/purescript-cookbook">PureScript
Cookbook</a>は「X
するにはどうするの？」といった類の質問にコードを混じえて答えを提供しま
す。</li>
<li><a href="https://github.com/purescript/documentation">PureScriptドキュメントリポジト
リ</a>には、PureScriptの開発
者や利用者が書いた幅広い話題の記事と例が集まっています。</li>
<li><a href="https://www.purescript.org">PureScriptのWebサイト</a>には、コード例、映
像、他の初心者向け資料を含むいくつかの学習資料へのリンクがあります。</li>
<li><a href="https://try.purescript.org">Try PureScript!</a>は利用者がWebブラウザで
PureScriptのコードをコンパイルすることができるWebサイトです。いくつか
の簡単なコードの例があります。</li>
</ul>
<p>もし例を読んで学ぶ方が好きでしたら、GitHubの <code>purescript</code>組織、
<code>purescript-node</code>組織および <code>purescript-contrib</code>組織にはPureScriptコー
ドの例がたくさんあります。</p>
<h2 id="著者について"><a class="header" href="#著者について">著者について</a></h2>
<p>私はPureScriptコンパイラの最初の開発者です。私はカリフォルニア州ロサンゼルスを拠点にしており、8ビットパーソナルコンピュータ、Amstrad
CPC上のBASICでまだ幼い時にプログラミングを始めました。
それ以来、私はいくつものプログラミング言語（JavaやScala、C#、F#、Haskell、そしてPureScript）で業務に携わってきました。</p>
<p>プロとしての経歴が始まって間もなく、私は関数型プログラミングと数学の関係を理解するようになり、
そしてプログラミング言語Haskellを使って関数型の概念の学習を楽しみました。</p>
<p>JavaScriptでの経験をもとに、私はPureScriptコンパイラの開発を始めることにしました。
気が付くとHaskellのような言語から取り上げた関数型プログラミングの手法を使っていましたが、それを応用するためのもっと理にかなった環境を求めていました。
そのとき検討した案のなかには、Haskellからその意味論を維持しながらJavaScriptへとコンパイルするいろいろな試み（Fay、Haste、GHCJS）もありましたが、私が興味を持っていたのは、この問題への別の切り口からのアプローチ、すなわちHaskellのような言語の構文と型システムを楽しみながらJavaScriptの意味論も維持するということが、どのようにすれば可能になるのかでした。</p>
<p>私は<a href="http://blog.functorial.com">ブログ</a>を運営しており、<a href="http://twitter.com/paf31">Twitterで連絡をとる</a>こともできます。</p>
<h2 id="謝辞"><a class="header" href="#謝辞">謝辞</a></h2>
<p>現在の状態に到達するまでPureScriptを手伝ってくれた多くの協力者に感謝したいと思います。コンパイラやツール、ライブラリ、ドキュメント、テストでの組織的で弛まぬ努力がなかったら、プロジェクトは間違いなく失敗していたことでしょう。</p>
<p>この本の表紙に表示されたPureScriptのロゴはGareth Hughesによって作成されたもので、<a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons
Attribution 4.0
license</a>の条件の下で再利用させて頂いています 。</p>
<p>最後に、この本の内容に関する反応や訂正をくださったすべての方に、心より感謝したいと思います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="はじめよう"><a class="header" href="#はじめよう">はじめよう</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章では実際のPureScriptの開発環境を立ち上げ、
いくつかの演習を解き、
この本で提供されているテストを使って答えを確認します。
もし学習の仕方が合っていれば
<a href="https://www.youtube.com/watch?v=GPjPwb6d-70">この章を通して進めるビデオ</a>
が役に立つでしょう。</p>
<h2 id="環境構築"><a class="header" href="#環境構築">環境構築</a></h2>
<p>最初にドキュメンテーションリポジトリにあるこの
<a href="https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md">Getting Started
Guide</a>
を通しで進め、環境の構築と言語の基礎を学んでください。
<a href="http://projecteuler.net/problem=1">Project Euler</a>
への解答例にあるコードがわかりにくかったり見慣れない構文を含んでいたとしても心配要りません。
来たる章でこの全ての内容をとても詳細に押さえていきます。</p>
<h2 id="演習を解く"><a class="header" href="#演習を解く">演習を解く</a></h2>
<p>ここまでで必要な開発ツールをインストールできているので、この本のリポジトリをクローンしてください。</p>
<pre><code class="language-sh">git clone https://github.com/purescript-contrib/purescript-book.git
</code></pre>
<p>本のリポジトリにはPureScriptのコード例とそれぞれの章に付属する演習のための単体テストが含まれます。
演習の解法を白紙に戻すために必要な初期設定があり、こうすることで解く準備ができます。
<code>resetSolutions.sh</code>スクリプトを使ってこの工程を簡単にできます。
その間に<code>removeAnchors.sh</code>スクリプトで全てのアンカーコメントを取り除いておくのもよいでしょう（これらのアンカーはコードスニペットを本の変換後のMarkdownにコピーするために使われており、
自分のローカルリポジトリではこのアンカーが散らかっていないほうがよいでしょう）。</p>
<pre><code class="language-sh">cd purescript-book
./scripts/resetSolutions.sh
./scripts/removeAnchors.sh
git add .
git commit --all --message &quot;Exercises ready to be solved&quot;
</code></pre>
<p>それではこの章のテストを走らせましょう。</p>
<pre><code class="language-sh">cd exercises/chapter2
spago test
</code></pre>
<p>以下の成功したテスト出力が出るでしょう。</p>
<pre><code class="language-sh">→ Suite: Euler - Sum of Multiples
  ✓ Passed: below 10
  ✓ Passed: below 1000

All 2 tests passed! 🎉
</code></pre>
<p>なお、<code>answer</code>節（<code>src/Euler.purs</code>にあります）は、
あらゆる整数以下の3と5の倍数を見付けるように変更されています。
この<code>answer</code>関数のためのテストスート（<code>test/Main.purs</code>にあります）は
Getting Started Guideの冒頭にあるテストよりも網羅的です。
はじめの章を読んでいる間はこのテストフレームワークの仕組みを理解しようと思い詰めなくて大丈夫です。</p>
<p>本の残りの部分には多くの演習が含まれます。
<code>Test.MySolutions</code>モジュール (<code>test/MySolutions.purs</code>) に自分の解法を書けば、
提供されているテストスートを使って確認できます。</p>
<p>テスト駆動開発のスタイルでこの次の演習を一緒に進めてみましょう。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>（普通）直角三角形の対角線（あるいは斜辺）の長さを
他の2つの辺の長さを使って計算する<code>diagonal</code>関数を書いてください。</li>
</ol>
<h2 id="解法"><a class="header" href="#解法">解法</a></h2>
<p>この演習のテストを有効にするところから始めます。
以下に示すようにブロックコメントの開始を数行下に下げてください。
ブロックコメントは<code>{-</code>から始まり<code>-}</code>で終わります。</p>
<pre><code class="language-hs">    suite &quot;diagonal&quot; do
      test &quot;3 4 5&quot; do
        Assert.equal 5.0 (diagonal 3.0 4.0)
      test &quot;5 12 13&quot; do
        Assert.equal 13.0 (diagonal 5.0 12.0)
    {-  Move this block comment starting point to enable more tests
</code></pre>
<p>ここでテストを走らせようとすると、コンパイルエラーに直面します。
なぜなら<code>diagonal</code>関数をまだ実装していないからです。</p>
<pre><code class="language-sh">$ spago test

Error found:
in module Test.Main
at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)

  Unknown value diagonal
</code></pre>
<p>まずはこの関数が欠陥のあるバージョンであるときに何が起こるのか見てみましょう。
以下のコードを<code>test/MySolutions.purs</code>に追加してください。</p>
<pre><code class="language-hs">import Data.Number (sqrt)

diagonal w h = sqrt (w * w + h)
</code></pre>
<p>そして<code>spago test</code>を走らせて確認してください。</p>
<pre><code class="language-hs">→ Suite: diagonal
  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989
  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219

2 tests failed:
</code></pre>
<p>あーあ、全然正しくありませんでした。
ピタゴラスの定理を正しい適用することでこれを修正しましょう。
関数を以下のように変えます。</p>
<pre><code class="language-hs">diagonal w h = sqrt (w * w + h * h)
</code></pre>
<p>ここでもう一度<code>spago test</code>としてみると全てのテストが通っています。</p>
<pre><code class="language-hs">→ Suite: Euler - Sum of Multiples
  ✓ Passed: below 10
  ✓ Passed: below 1000
→ Suite: diagonal
  ✓ Passed: 3 4 5
  ✓ Passed: 5 12 13

All 4 tests passed! 🎉
</code></pre>
<p>成功です！
これで次の演習を自力で解くための準備ができました。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（簡単）指定された半径の円の面積を計算する関数<code>circleArea</code>を書いてみましょう。
<code>Numbers</code>モジュールで定義されている <code>pi</code>定数を使用してください。
<strong>ヒント</strong>： <code>import Data.Number</code>文を修正して、 <code>pi</code>をインポートすることを忘れないようにしましょう。</li>
<li>（普通）<code>Int</code>を取って<code>100</code>で割ったあとの余りを返す関数<code>leftoverCents</code>を書いてみましょう。
<code>rem</code>関数を使ってください。
<a href="https://pursuit.purescript.org/">Pursuit</a>でこの関数を検索して、
使用法とどのモジュールからインポートしてくるか調べましょう。
<strong>補足</strong>：自動補完の提案を受け付ければ、IDEでこの関数の自動的なインポートがサポートされているかもしれません。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章ではPureScriptコンパイラとSpagoツールをインストールしました。
演習の解答の書き方と正しさの確認方法も学びました。</p>
<p>この先の章にはより多くの演習があり、それらに取り組むうちに学習の助けになっているでしょう。
演習のどこかでお手あげになったら、
この本の<a href="chapter1.ja.html#getting-help">困ったときは</a>の節に挙げられている
コミュニティの資料のどれでも見てみるか、
この<a href="https://github.com/purescript-contrib/purescript-book/issues">本のリポジトリ</a>にイシューを報告することさえできます。
こうした演習の敷居を下げることに繋がる読者のフィードバックが、本の向上の助けになっています。</p>
<p>章の全ての演習を解いたら、<code>no-peeking/Solutions.purs</code>にあるものと解答とを比べられます。
ただしカンニングしてはだめで、これらの演習を誠実に自力で解く労力を払わないことがないようにしてください。
そしてたとえ行き詰まったにしても、まずはコミュニティメンバーに尋ねてみるようにしてください。
演習のネタバレをするよりも、小さなヒントをあげたいからです。
もっとエレガントな解法（とはいえ本の内容で押さえられている知識のみを必要とするもの）を見つけたときはPRを送ってください。</p>
<p>リポジトリは継続して改訂されているため、それぞれの新しい章を始める前に更新を確認するようにしてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="関数とレコード"><a class="header" href="#関数とレコード">関数とレコード</a></h1>
<h2 id="この章の目標-1"><a class="header" href="#この章の目標-1">この章の目標</a></h2>
<p>この章では、関数およびレコードというPureScriptプログラムの2つの構成要素を導入します。
さらに、どのようにPureScriptプログラムを構造化するのか、どのように型をプログラム開発に役立てるかを見ていきます。</p>
<p>連絡先のリストを管理する簡単​​な住所録アプリケーションを作成していきます。このコード例により、PureScriptの構文からいくつかの新しい概念を導入します。</p>
<p>このアプリケーションのフロントエンドは対話式モードであるPSCiを使うようにしていますが、このコードを土台にJavaScriptでフロントエンドを書くこともできるでしょう。
実際に後の章で、フォームの検証と保存および復元の機能を追加します。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>この章のソースコードは <code>src/Data/AddressBook.purs</code>というファイルに含まれています。
このファイルは次のようなモジュール宣言とインポート一覧から始まります。</p>
<pre><code class="language-haskell">module Data.AddressBook where

import Prelude

import Control.Plus (empty)
import Data.List (List(..), filter, head)
import Data.Maybe (Maybe)
</code></pre>
<p>ここでは、いくつかのモジュールをインポートします。</p>
<ul>
<li><code>Control.Plus</code>モジュールには<code>empty</code>値が定義されています。</li>
<li><code>Data.List</code>モジュールは<code>lists</code>パッケージで提供されておりSpagoを使ってインストールできます。
連結リストを使うために必要ないくつかの関数が含まれています。</li>
<li><code>Data.Maybe</code>モジュールは、オプショナルな値を扱うためのデータ型と関数を定義しています。</li>
</ul>
<p>訳者注：ダブルドット (<code>..</code>) を使用すると、
指定された型コンストラクタのすべてのデータコンストラクタをインポートできます。</p>
<p>このモジュールのインポート内容が括弧内で明示的に列挙されていることに注目してください。明示的な列挙はインポート内容の衝突を避けるのに役に立つので、一般に良い習慣です。</p>
<p>ソースコードリポジトリを複製したと仮定すると、この章のプロジェクトは次のコマンドでSpagoを使用して構築できます。</p>
<pre><code class="language-text">$ cd chapter3
$ spago build
</code></pre>
<h2 id="単純な型"><a class="header" href="#単純な型">単純な型</a></h2>
<p>JavaScriptのプリミティブ型に対応する組み込みデータ型として、PureScriptでは数値型と文字列型、真偽型の3つが定義されています。
これらは<code>Prim</code>モジュールで定義されており、全てのモジュールに暗黙にインポートされます。
これらはそれぞれ <code>Number</code>、 <code>String</code>、
<code>Boolean</code>と呼ばれており、PSCiで<code>:type</code>コマンドを使うと簡単な値の型を表示させて確認できます。</p>
<pre><code class="language-text">$ spago repl

&gt; :type 1.0
Number

&gt; :type &quot;test&quot;
String

&gt; :type true
Boolean
</code></pre>
<p>PureScriptには他にも、整数、文字、配列、レコード、関数といった組み込み型が定義されています。</p>
<p>整数は、小数点以下を省くことによって、型 <code>Number</code>の浮動小数点数の値と区別されます。</p>
<pre><code class="language-text">&gt; :type 1
Int
</code></pre>
<p>二重引用符を使用する文字列リテラルとは異なり、文字リテラルは一重引用符で囲みます。</p>
<pre><code class="language-text">&gt; :type 'a'
Char
</code></pre>
<p>配列はJavaScriptの配列に対応していますが、JavaScriptの配列とは異なり、PureScriptの配列のすべての要素は同じ型を持つ必要があります。</p>
<pre><code class="language-text">&gt; :type [1, 2, 3]
Array Int

&gt; :type [true, false]
Array Boolean

&gt; :type [1, false]
Could not match type Int with type Boolean.
</code></pre>
<p>最後の例で起きているエラーは型検証器によって報告されたもので、
配列の2つの要素の型を<strong>単一化</strong>（Unification、等価にするの意）しようとして失敗したことを示しています。</p>
<p>レコードはJavaScriptのオブジェクトに対応しており、レコードリテラルはJavaScriptのオブジェクトリテラルと同じ構文になっています。</p>
<pre><code class="language-text">&gt; author = { name: &quot;Phil&quot;, interests: [&quot;Functional Programming&quot;, &quot;JavaScript&quot;] }

&gt; :type author
{ name :: String
, interests :: Array String
}
</code></pre>
<p>この型が示しているのは、指定されたオブジェクトは、 <code>String</code>型のフィールド <code>name</code> と <code>Array String</code>つまり
<code>String</code>の配列の型のフィールド <code>interests</code> という2つの<strong>フィールド</strong> (field) を持っているということです。</p>
<p>レコードのフィールドは、ドットに続けて参照したいフィールドのラベルを書くと参照することができます。</p>
<pre><code class="language-text">&gt; author.name
&quot;Phil&quot;

&gt; author.interests
[&quot;Functional Programming&quot;,&quot;JavaScript&quot;]
</code></pre>
<p>PureScriptの関数はJavaScriptの関数に対応しています。PureScriptの標準ライブラリは多くの関数の例を提供しており、この章ではそれらをもう少し詳しく見ていきます。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c

&gt; :type const
forall a b. a -&gt; b -&gt; a
</code></pre>
<p>ファイルのトップレベルでは、等号の直前に引数を指定することで関数を定義することができます。</p>
<pre><code class="language-haskell">add :: Int -&gt; Int -&gt; Int
add x y = x + y
</code></pre>
<p>バックスラッシュに続けて空白文字で区切られた引数名のリストを書くことで、関数をインラインで定義することもできます。
PSCiで複数行の宣言を入力するには、 <code>:paste</code>コマンドを使用して「貼り付けモード」に入ります。
このモードでは、<strong>Control-D</strong>キーシーケンスを使用して宣言を終了します。</p>
<pre><code class="language-text">&gt; :paste
… add :: Int -&gt; Int -&gt; Int
… add = \x y -&gt; x + y
… ^D
</code></pre>
<p>PSCiでこの関数が定義されていると、次のように関数の隣に2つの引数を空白で区切って書くことで、関数をこれらの引数に<strong>適用</strong> (apply)
することができます。</p>
<pre><code class="language-text">&gt; add 10 20
30
</code></pre>
<h2 id="量化された型"><a class="header" href="#量化された型">量化された型</a></h2>
<p>前の節ではPreludeで定義された関数の型をいくつか見てきました。たとえば <code>flip</code>関数は次のような型を持っていました。</p>
<pre><code class="language-text">&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</code></pre>
<p>この <code>forall</code>キーワードは、 <code>flip</code>が<strong>全称量化された型</strong> (universally quantified type)
を持っていることを示しています。
これは、 <code>a</code>や <code>b</code>、 <code>c</code>をどの型に置き換えても、 <code>flip</code>はその型でうまく動作するという意味です。</p>
<p>例えば、 <code>a</code>を <code>Int</code>、 <code>b</code>を <code>String</code>、 <code>c</code>を <code>String</code>というように選んでみたとします。
この場合、 <code>flip</code>の型を次のように<strong>特殊化</strong> (specialize) することができます。</p>
<pre><code class="language-text">(Int -&gt; String -&gt; String) -&gt; String -&gt; Int -&gt; String
</code></pre>
<p>量化された型を特殊化したいということをコードで示す必要はありません。特殊化は自動的に行われます。たとえば、すでにその型の
<code>flip</code>を持っていたかのように、次のように単に <code>flip</code>を使用することができます。</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) &quot;Ten&quot; 10

&quot;10Ten&quot;
</code></pre>
<p><code>a</code>、 <code>b</code>、 <code>c</code>の型はどんな型でも選ぶことができるといっても、型の不整合は生じないようにしなければなりません。
<code>flip</code>に渡す関数の型は、他の引数の型と整合性がなくてはなりません。
第2引数として文字列 <code>&quot;Ten&quot;</code>、第3引数として数 <code>10</code>を渡したのはそれが理由です。
もし引数が逆になっているとうまくいかないでしょう。</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) 10 &quot;Ten&quot;

Could not match type Int with type String
</code></pre>
<h2 id="字下げについての注意"><a class="header" href="#字下げについての注意">字下げについての注意</a></h2>
<p>JavaScriptとは異なり、PureScriptのコードは字下げの大きさに影響されます (indentation-sensitive)。
これはHaskellと同じようになっています。
コード内の空白の多寡は無意味ではなく、Cのような言語で中括弧によってコードのまとまりを示しているように、PureScriptでは空白がコードのまとまりを示すのに使われているということです。</p>
<p>宣言が複数行にわたる場合は、最初の行以外は最初の行の字下げより深く字下げしなければなりません。</p>
<p>したがって、次は正しいPureScriptコードです。</p>
<pre><code class="language-haskell">add x y z = x +
  y + z
</code></pre>
<p>しかし、次は正しいコードではありません。</p>
<pre><code class="language-haskell">add x y z = x +
y + z
</code></pre>
<p>後者では、PureScriptコンパイラはそれぞれの行ごとにひとつ、つまり<strong>2つ</strong>の宣言であると構文解析します。</p>
<p>一般に、同じブロック内で定義された宣言は同じ深さで字下げする必要があります。
例えばPSCiでlet文の宣言は同じ深さで字下げしなければなりません。
次は正しいコードです。</p>
<pre><code class="language-text">&gt; :paste
… x = 1
… y = 2
… ^D
</code></pre>
<p>しかし、これは正しくありません。</p>
<pre><code class="language-text">&gt; :paste
… x = 1
…  y = 2
… ^D
</code></pre>
<p>PureScriptのいくつかの予約語（例えば <code>where</code>や <code>of</code>、
<code>let</code>）は新たなコードのまとまりを導入しますが、そのコードのまとまり内の宣言はそれより深く字下げされている必要があります。</p>
<pre><code class="language-haskell">example x y z = foo + bar
  where
    foo = x * y
    bar = y * z
</code></pre>
<p>ここで <code>foo</code>や <code>bar</code>の宣言は <code>example</code>の宣言より深く字下げされていることに注意してください。</p>
<p>ただし、ソースファイルの先頭、最初の <code>module</code>宣言における予約語 <code>where</code>だけは、この規則の唯一の例外になっています。</p>
<h2 id="独自の型の定義"><a class="header" href="#独自の型の定義">独自の型の定義</a></h2>
<p>PureScriptで新たな問題に取り組むときは、まずはこれから扱おうとする値の型の定義を書くことから始めるのがよいでしょう。最初に、住所録に含まれるレコードの型を定義してみます。</p>
<pre><code class="language-haskell">type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }
</code></pre>
<p>これは <code>Entry</code>という<strong>型同義語</strong>（type synonym、型シノニム）を定義しています。
型 <code>Entry</code>は等号の右辺と同じ型ということです。
レコードの型はいずれも文字列である <code>firstName</code>、 <code>lastName</code>、 <code>phone</code>という3つのフィールドからなります。
前者の2つのフィールドは型 <code>String</code>を持ち、 <code>address</code>は以下のように定義された型 <code>Address</code>を持っています。</p>
<pre><code class="language-haskell">type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }
</code></pre>
<p>なお、レコードには他のレコードを含めることができます。</p>
<p>それでは、3つめの型同義語も定義してみましょう。住所録のデータ構造としては、単に項目の連結リストとして格納することにします。</p>
<pre><code class="language-haskell">type AddressBook = List Entry
</code></pre>
<p><code>List Entry</code>は <code>Array Entry</code>とは同じではないということに注意してください。 <code>Array Entry</code>は住所録の項目の<strong>配列</strong>を意味しています。</p>
<h2 id="型構築子と種"><a class="header" href="#型構築子と種">型構築子と種</a></h2>
<p><code>List</code>は<strong>型構築子</strong>（type constructor、型コンストラクタ）の一例になっています。
<code>List</code>そのものは型ではなく、何らかの型 <code>a</code>があるとき <code>List a</code>が型になっています。
つまり、 <code>List</code>は<strong>型引数</strong> (type argument) <code>a</code>をとり、新たな型 <code>List a</code>を<strong>構築</strong>するのです。</p>
<p>ちょうど関数適用と同じように、型構築子は他の型に並べることで適用されることに注意してください。型 <code>List　Entry</code>は実は型構築子
<code>List</code>が型 <code>Entry</code>に<strong>適用</strong>されたものです。これは住所録項目のリストを表しています。</p>
<p>（型注釈演算子 <code>::</code>を使って）もし型 <code>List</code>の値を間違って定義しようとすると、今まで見たことのないような種類のエラーが表示されるでしょう。</p>
<pre><code class="language-text">&gt; import Data.List
&gt; Nil :: List
In a type-annotated expression x :: t, the type t must have kind Type
</code></pre>
<p>これは<strong>種エラー</strong> (kind error) です。
値がその<strong>型</strong>で区別されるのと同じように、型はその<strong>種</strong> (kind)
によって区別され、間違った型の値が<strong>型エラー</strong>になるように、<strong>間違った種</strong>の型は<strong>種エラー</strong>を引き起こします。</p>
<p><code>Number</code>や <code>String</code>のような、値を持つすべての型の種を表す <code>Type</code>と呼ばれる特別な種があります。</p>
<p>型構築子にも種があります。
たとえば、種 <code>Type -&gt; Type</code>はちょうど <code>List</code>のような型から型への関数を表しています。
ここでエラーが発生したのは、値が種 <code>Type</code>であるような型を持つと期待されていたのに、 <code>List</code>は種 <code>Type -&gt; Type</code>を持っているためです。</p>
<p>PSCiで型の種を調べるには、 <code>:kind</code>命令を使用します。例えば次のようになります。</p>
<pre><code class="language-text">&gt; :kind Number
Type

&gt; import Data.List
&gt; :kind List
Type -&gt; Type

&gt; :kind List String
Type
</code></pre>
<p>PureScriptの<strong>種システム</strong>は他にも面白い種に対応していますが、それらについては本書の他の部分で見ていくことになるでしょう。</p>
<h2 id="住所録の項目の表示"><a class="header" href="#住所録の項目の表示">住所録の項目の表示</a></h2>
<p>それでは最初に、文字列で住所録の項目を表現するような関数を書いてみましょう。
まずは関数に型を与えることから始めます。
型の定義は省略することも可能ですが、ドキュメントとしても役立つので型を書いておくようにすると良いでしょう。
実際、トップレベルの宣言に型註釈が含まれていないと、PureScriptコンパイラが警告を出します。
型宣言は関数の名前とその型を <code>::</code>記号で区切るようにして書きます。</p>
<pre><code class="language-haskell">showEntry :: Entry -&gt; String
</code></pre>
<p><code>showEntry</code>は引数として <code>Entry</code>を取り <code>string</code>を返す関数であるということを、この型シグネチャは言っています。
<code>showEntry</code>のコードは次のとおりです。</p>
<pre><code class="language-haskell">showEntry entry = entry.lastName &lt;&gt; &quot;, &quot; &lt;&gt;
                  entry.firstName &lt;&gt; &quot;: &quot; &lt;&gt;
                  showAddress entry.address
</code></pre>
<p>この関数は <code>Entry</code>レコードの3つのフィールドを連結し、単一の文字列にします。ここで使用される <code>showAddress</code>は
<code>address</code>フィールドを連接し、単一の文字列にする関数です。 <code>showAddress</code>の定義は次のとおりです。</p>
<pre><code class="language-haskell">showAddress :: Address -&gt; String
showAddress addr = addr.street &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.city &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.state
</code></pre>
<p>関数定義は関数の名前で始まり、引数名のリストが続きます。関数の結果は等号の後ろに定義します。フィールドはドットに続けてフィールド名を書くことで参照することができます。PureScriptでは、文字列連結はJavaScriptのような単一のプラス記号ではなく、ダイアモンド演算子（<code>&lt;&gt;</code>）を使用します。</p>
<h2 id="はやめにテストたびたびテスト"><a class="header" href="#はやめにテストたびたびテスト">はやめにテスト、たびたびテスト</a></h2>
<p>PSCi対話式モードでは反応を即座に得られるので、素早い試作開発に向いています。
それではこの最初の関数が正しく動作するかをPSCiを使用して確認してみましょう。</p>
<p>まず、これまでに書いたコードをビルドします。</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>次に、PSCiを起動し、この新しいモジュールをインポートするために <code>import</code>命令を使います。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.AddressBook
</code></pre>
<p>レコードリテラルを使うと、住所録の項目を作成することができます。レコードリテラルはJavaScriptの無名オブジェクトと同じような構文で名前に束縛します。</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>​それでは、この例に関数を適用してみてください。</p>
<pre><code class="language-text">&gt; showAddress address

&quot;123 Fake St., Faketown, CA&quot;
</code></pre>
<p><code>showEntry</code>も、住所を含む住所録項目の記録例を作って試しましょう。</p>
<pre><code class="language-text">&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; showEntry entry

&quot;Smith, John: 123 Fake St., Faketown, CA&quot;
</code></pre>
<h2 id="住所録の作成"><a class="header" href="#住所録の作成">住所録の作成</a></h2>
<p>今度は住所録の操作を支援する関数をいくつか書いてみましょう。
空の住所録を表す値が必要ですが、これには空のリストを使います。</p>
<pre><code class="language-haskell">emptyBook :: AddressBook
emptyBook = empty
</code></pre>
<p>既存の住所録に値を挿入する関数も必要でしょう。この関数を <code>insertEntry</code>と呼ぶことにします。関数の型を与えることから始めましょう。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>この型シグネチャに書かれているのは、最初の引数として <code>Entry</code>、第二引数として <code>AddressBook</code>を取り、新しい
<code>AddressBook</code>を返すということです。</p>
<p>既存の <code>AddressBook</code>を直接変更することはしません。
その代わりに、同じデータが含まれている新しい <code>AddressBook</code>を返すようにします。
このように、 <code>AddressBook</code>は<strong>不変データ構造</strong> (immutable data structure) の一例となっています。
これはPureScriptにおける重要な考え方です。
変更はコードの副作用であり、効率の良いコードの振る舞いの判断を妨げます。
そのため、我々は可能な限り純粋な関数や不変のデータを好むのです。</p>
<p><code>insertEntry</code>を実装するのに<code>Data.List</code>の<code>Cons</code>関数が使えます。
この関数の型を見るには、PSCiを起動し <code>:type</code>コマンドを使います。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type Cons

forall a. a -&gt; List a -&gt; List a
</code></pre>
<p><code>Cons</code>は、なんらかの型 <code>a</code>の値と、型
<code>a</code>を要素に持つリストを引数にとり、同じ型の要素を持つ新しいリストを返すということを、この型シグネチャは言っています。 <code>a</code>を
<code>Entry</code>型として特殊化してみましょう。</p>
<pre><code class="language-haskell">Entry -&gt; List Entry -&gt; List Entry
</code></pre>
<p>しかし、 <code>List Entry</code>はまさに <code>AddressBook</code>ですから、次と同じになります。</p>
<pre><code class="language-haskell">Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>今回の場合、すでに適切な入力があります。 <code>Entry</code>と <code>AddressBook</code>に <code>Cons</code>を適用すると、新しい
<code>AddressBook</code>を得ることができます。これこそまさに私たちが求めていた関数です！</p>
<p><code>insertEntry</code>の実装は次のようになります。</p>
<pre><code class="language-haskell">insertEntry entry book = Cons entry book
</code></pre>
<p>等号の左側にある2つの引数 <code>entry</code>と <code>book</code>がスコープに導入されますから、これらに <code>Cons</code>関数を適用して結果の値を作成しています。</p>
<h2 id="カリー化された関数"><a class="header" href="#カリー化された関数">カリー化された関数</a></h2>
<p>PureScriptでは、関数は常にひとつの引数だけを取ります。
<code>insertEntry</code>関数は2つの引数を取るように見えますが、これは実際には<strong>カリー化された関数</strong> (curried function)
の一例となっています。</p>
<p><code>insertEntry</code>の型に含まれる <code>-&gt;</code>は右結合の演算子であり、つまりこの型はコンパイラによって次のように解釈されます。</p>
<pre><code class="language-haskell">Entry -&gt; (AddressBook -&gt; AddressBook)
</code></pre>
<p>すなわち、 <code>insertEntry</code>は関数を返す関数である、ということです！この関数は単一の引数 <code>Entry</code>を取り、それから単一の引数
<code>AddressBook</code>を取り新しい <code>AddressBook</code>を返す新しい関数を返すのです。</p>
<p>これは例えば、最初の引数だけを与えると <code>insertEntry</code>を<strong>部分適用</strong> (partial application)
できることを意味します。
PSCiでこの結果の型を見てみましょう。</p>
<pre><code class="language-text">&gt; :type insertEntry entry

AddressBook -&gt; AddressBook
</code></pre>
<p>期待したとおり、戻り値の型は関数になっていました。
この結果の関数に、2つ目の引数を適用することもできます。</p>
<pre><code class="language-text">&gt; :type (insertEntry entry) emptyBook
AddressBook
</code></pre>
<p>ここで括弧は不要であることにも注意してください。次の式は同等です。</p>
<pre><code class="language-text">&gt; :type insertEntry entry emptyBook
AddressBook
</code></pre>
<p>これは関数適用が左結合であるためで、
なぜ単に空白で区切るだけで関数に引数を与えることができるのかの説明にもなっています。</p>
<p>関数の型の<code>-&gt;</code>演算子は関数の<strong>型構築子</strong>です。
この演算子は2つの型引数を取ります。
左右の被演算子はそれぞれ関数の引数の型と返値の型です。</p>
<p>本書では今後、「2引数の関数」というように表現することがあることに注意してください。
しかしそれはカリー化された関数を意味していると考えるべきで、その関数は最初の引数を取り2つ目の引数を取る別の関数を返すのです。</p>
<p>今度は <code>insertEntry</code>の定義について考えてみます。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry book = Cons entry book
</code></pre>
<p>もし式の右辺に明示的に括弧をつけるなら、 <code>(Cons entry) book</code>となります。
<code>insertEntry entry</code>はその引数が単に関数 <code>(Cons entry)</code>に渡されるような関数だということです。
でもこの2つの関数はどんな入力についても同じ結果を返しますから、つまりこれらは同じ関数です！
よって、両辺から引数 <code>book</code>を削除できます。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry = Cons entry
</code></pre>
<p>しかし今や同様の議論により、両辺から <code>entry</code>も削除することができます。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry = Cons
</code></pre>
<p>この処理は<strong>イータ変換</strong> (eta conversion)
と呼ばれ、（その他の技法を併用して）引数を参照することなく関数を定義する<strong>ポイントフリー形式</strong> (point-free form)
へと関数を書き換えるのに使うことができます。</p>
<p><code>insertEntry</code>の場合には、イータ変換によって「<code>insertEntry</code>は単にリストに対するconsだ」となり、関数の定義はとても明確になりました。
しかしながら、一般的にポイントフリー形式のほうがいいのかどうかには議論の余地があります。</p>
<h2 id="プロパティ取得子"><a class="header" href="#プロパティ取得子">プロパティ取得子</a></h2>
<p>よくあるパターンの1つとして、レコード中の個別のフィールド（または「プロパティ」）を取得することがあります。
<code>Entry</code>から<code>Address</code>を取り出すインライン関数は次のように書けます。</p>
<pre><code class="language-haskell">\entry -&gt; entry.address
</code></pre>
<p>PureScriptでは<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#property-accessors"><strong>プロパティ取得子</strong></a>という略記が使えます。
この略記では下線文字は無名関数の引数として振舞うため、上記のインライン関数は次と等価です。</p>
<pre><code class="language-haskell">_.address
</code></pre>
<p>これは何段階のプロパティでも動くため、<code>Entry</code>に関連付く街を取り出す関数は次のように書けます。</p>
<pre><code class="language-haskell">_.address.city
</code></pre>
<p>以下は例です。</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; _.lastName entry
&quot;Smith&quot;

&gt; _.address.city entry
&quot;Faketown&quot;
</code></pre>
<h2 id="あなたの住所録は"><a class="header" href="#あなたの住所録は">あなたの住所録は？</a></h2>
<p>最小限の住所録アプリケーションの実装で必要になる最後の関数は、名前で人を検索し適切な
<code>Entry</code>を返すものです。これは小さな関数を組み合わせることでプログラムを構築するという、関数型プログラミングで鍵となる考え方のよい応用例になるでしょう。</p>
<p>まずは住所録をフィルタリングし、該当する姓名を持つ項目だけを保持するようにするのがいいでしょう。それから、結果のリストの先頭の (head)
要素を返すだけです。</p>
<p>この大まかな仕様に従って、この関数の型を計算することができます。
まずPSCiを起動し、 <code>filter</code>関数と <code>head</code>関数の型を見てみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type filter

forall a. (a -&gt; Boolean) -&gt; List a -&gt; List a

&gt; :type head

forall a. List a -&gt; Maybe a
</code></pre>
<p>型の意味を理解するために、これらの2つの型の一部を取り出してみましょう。</p>
<p><code>filter</code>はカリー化された2引数の関数です。
最初の引数は、リストの要素を取り <code>Boolean</code>値を結果として返す関数です。
第2引数は要素のリストで、返り値は別のリストです。</p>
<p><code>head</code>は引数としてリストをとり、 <code>Maybe a</code>という今まで見たことがないような型を返します。 <code>Maybe a</code>は型
<code>a</code>のオプショナルな値、つまり
<code>a</code>の値を持つか持たないかのどちらかの値を示しており、JavaScriptのような言語で値がないことを示すために使われる
<code>null</code>の型安全な代替手段を提供します。これについては後の章で詳しく扱います。</p>
<p><code>filter</code>と <code>head</code>の全称量化された型は、PureScriptコンパイラによって次のように<strong>特殊化</strong> (specialized)
されます。</p>
<pre><code class="language-haskell">filter :: (Entry -&gt; Boolean) -&gt; AddressBook -&gt; AddressBook

head :: AddressBook -&gt; Maybe Entry
</code></pre>
<p>検索する関数の引数として姓と名前を渡す必要があるのもわかっています。</p>
<p><code>filter</code>に渡す関数も必要になることもわかります。この関数を <code>filterEntry</code>と呼ぶことにしましょう。 <code>filterEntry</code>は <code>Entry -&gt; Boolean</code>という型を持っています。 <code>filter filterEntry</code>という関数適用の式は、 <code>AddressBook -&gt; AddressBook</code>という型を持つでしょう。もしこの関数の結果を <code>head</code>関数に渡すと、型 <code>Maybe Entry</code>の結果を得ることになります。</p>
<p>これまでのことをまとめると、関数の妥当な型シグネチャは次のようになります。
<code>findEntry</code>と呼ぶことにしましょう。</p>
<pre><code class="language-haskell">findEntry :: String -&gt; String -&gt; AddressBook -&gt; Maybe Entry
</code></pre>
<p><code>findEntry</code>は、姓と名前の2つの文字列、および <code>AddressBook</code>を引数にとり、
<code>Entry</code>のオプション型の値を結果として返すということを、この型シグネチャは言っています。
オプショナルな結果は、名前が住所録で発見された場合にのみ値を持ちます。</p>
<p>そして、 <code>findEntry</code>の定義は次のようになります。</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -&gt; Boolean
    filterEntry entry = entry.firstName == firstName &amp;&amp; entry.lastName == lastName
</code></pre>
<p>一歩ずつこのコードを調べてみましょう。</p>
<p><code>findEntry</code>は、
どちらも文字列型である <code>firstName</code>と <code>lastName</code>、
<code>AddressBook</code>型の <code>book</code>という3つの名前をスコープに導入します。</p>
<p>定義の右辺では <code>filter</code>関数と <code>head</code>関数が組み合わされています。まず項目のリストをフィルタリングし、その結果に
<code>head</code>関数を適用しています。</p>
<p>真偽型を返す関数 <code>filterEntry</code>は <code>where</code>節の内部で補助的な関数として定義されています。このため、
<code>filterEntry</code>関数はこの定義の内部では使用できますが、外部では使用することができません。また、
<code>filterEntry</code>はそれを包む関数の引数に依存することができ、 <code>filterEntry</code>は指定された
<code>Entry</code>をフィルタリングするために引数 <code>firstName</code>と <code>lastName</code>を使用しているので、 <code>filterEntry</code>が
<code>findEntry</code>の内部にあることは必須になっています。</p>
<p>最上位での宣言と同じように、必ずしも
<code>filterEntry</code>の型シグネチャを指定しなくてもよいことに注意してください。ただし、ドキュメントとしても役に立つので型シグネチャを書くことは推奨されています。</p>
<h2 id="中置の関数適用"><a class="header" href="#中置の関数適用">中置の関数適用</a></h2>
<p>これまでお話しした関数のほとんどは<strong>前置</strong>関数適用でした。
関数名が引数の<strong>前</strong>に置かれていたということです。
例えば<code>insertEntry</code>関数を使って<code>Entry</code> (<code>john</code>) を空の<code>AddressBook</code>に追加する場合、以下のように書けます。</p>
<pre><code class="language-haskell">&gt; book1 = insertEntry john emptyBook
</code></pre>
<p>しかしこの章には<strong>中置</strong><a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#binary-operators">2引数演算子</a>の例も含まれています。
例えば<code>filterEntry</code>の定義中の<code>==</code>演算子で、演算子が2つの引数の<strong>間</strong>に置かれています。
実はこうした中置演算子はPureScriptのソースコードで、
背後にある<strong>前置</strong>版の実装への中置別称として定義されています。
例えば<code>==</code>は以下の行により前置の<code>eq</code>関数の中置別称として定義されています。</p>
<pre><code class="language-haskell">infix 4 eq as ==
</code></pre>
<p>したがって<code>filterEntry</code>中の<code>entry.firstName == firstName</code>は<code>eq entry.firstName firstName</code>で置き換えられます。
この節の後のほうで中置演算子を定義する例をもう少し押さえます。</p>
<p>前置関数を演算子としての中置の位置に置くとより読みやすいコードになる場面があります。
その一例が<code>mod</code>関数です。</p>
<pre><code class="language-text">&gt; mod 8 3
2
</code></pre>
<p>上の用例は正しく動きますが、読みづらいです。
より馴染みのある表現の仕方は「8 mod 3」ですが、
バックスラッシュ (`) の中に前置関数を包めばこのように書けます。</p>
<pre><code class="language-text">&gt; 8 `mod` 3
2
</code></pre>
<p>同様に、<code>insertEntry</code>をバックスラッシュで包むと中置演算子に変わります。
例えば以下の<code>book1</code>と<code>book2</code>は等価です。</p>
<pre><code class="language-haskell">book1 = insertEntry john emptyBook
book2 = john `insertEntry` emptyBook
</code></pre>
<p>複数回<code>insertEntry</code>を適用することで複数の項目がある<code>AddressBook</code>を作ることができますが、以下のように前置関数
(<code>book3</code>) として適用するか中置演算子 (<code>book4</code>) として適用するかの2択があります。</p>
<pre><code class="language-haskell">book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))
book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))
</code></pre>
<p><code>insertEntry</code>に中置演算子別称（または同義語）を定義することもできます。
この演算子の名前に適当に<code>++</code>を選び、
<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#precedence">優先度</a>を<code>5</code>にし、
そして<code>infixr</code>を使って右<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#associativity">結合</a>とします。</p>
<pre><code class="language-haskell">infixr 5 insertEntry as ++
</code></pre>
<p>この新しい演算子で上の<code>book4</code>の例を次のように書き直せます。</p>
<pre><code class="language-haskell">book5 = john ++ (peggy ++ (ned ++ emptyBook))
</code></pre>
<p>そして新しい<code>++</code>演算子が右結合なので意味を変えずに括弧を除去できます。</p>
<pre><code class="language-haskell">book6 = john ++ peggy ++ ned ++ emptyBook
</code></pre>
<p>括弧を消去する他のよくある技法は、いつもの前置関数と一緒に<code>apply</code>の中置演算子<code>$</code>を使うというものです。</p>
<p>例えば前の<code>book3</code>の例は以下のように書き直せます。</p>
<pre><code class="language-haskell">book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook
</code></pre>
<p>括弧を<code>$</code>で置き換えるのは大抵入力しやすくなりますし（議論の余地がありますが）読みやすくなります。
この記号の意味を覚えるための記憶術として、ドル記号を2つの括弧に打ち消し線が引かれたものと見ることで、これで括弧が不必要になったのだと推測できるという方法があります。</p>
<p>なお、<code>($)</code>は言語にハードコードされた特別な構文ではありません。
単に<code>apply</code>という名前の通常の関数のための中置演算子であって、<code>Data.Function</code>で以下のように定義されています。</p>
<pre><code class="language-haskell">apply :: forall a b. (a -&gt; b) -&gt; a -&gt; b
apply f x = f x

infixr 0 apply as $
</code></pre>
<p><code>apply</code>関数は、他の関数（型は<code>(a -&gt; b)</code>）を最初の引数に、値（型は<code>a</code>）を2つ目の引数に取って、その値に対して関数を呼びます。
この関数が何ら意味のあることをしていないようだと思ったら、まったくもって正しいです！
この関数がなくてもプログラムは論理的に同一です（<a href="https://en.wikipedia.org/wiki/Referential_transparency">参照透過性</a>も見てください）。
この関数の構文的な利便性はその中置演算子に割り当てられた特別な性質からきています。
<code>$</code>は右結合 (<code>infixr</code>) で低い優先度 (<code>0</code>) の演算子ですが、これにより深い入れ子になった適用から括弧の束を削除できるのです。</p>
<p>さらなる<code>$</code>演算子を使った括弧退治の機会は、以前の<code>findEntry</code>関数にあります。</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head $ filter filterEntry book
</code></pre>
<p>この行をより簡潔に書き換える方法を次節の「関数合成」で見ていきます。</p>
<p>名前の短い中置演算子を前置関数として使いたければ括弧で囲むことができます。</p>
<pre><code class="language-text">&gt; 8 + 3
11

&gt; (+) 8 3
11
</code></pre>
<p>その代わりの手段として演算子は部分適用することができ、これには式を括弧で囲んで<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#operator-sections">演算子節</a>中の引数として<code>_</code>を使います。
これは簡単な無名関数を作るより便利な方法として考えることができます（以下の例ではそこから無名関数を名前に束縛しているので、もはや別に無名とも言えなくなっていますが）。</p>
<pre><code class="language-text">&gt; add3 = (3 + _)
&gt; add3 2
5
</code></pre>
<p>まとめると、以下は引数に<code>5</code>を加える関数の等価な定義です。</p>
<pre><code class="language-haskell">add5 x = 5 + x
add5 x = add 5 x
add5 x = (+) 5 x
add5 x = 5 `add` x
add5   = add 5
add5   = \x -&gt; 5 + x
add5   = (5 + _)
add5 x = 5 `(+)` x  -- よおポチ、中置に目がないっていうから、中置の中に中置を入れといたぜ！
</code></pre>
<h2 id="関数合成"><a class="header" href="#関数合成">関数合成</a></h2>
<p>イータ変換を使うと <code>insertEntry</code>関数を簡略化できたのと同じように、引数をよく考察すると
<code>findEntry</code>の定義を簡略化することができます。</p>
<p>引数 <code>book</code>が関数 <code>filter filterEntry</code>に渡され、この適用の結果が
<code>head</code>に渡されることに注目してください。これは言いかたを変えれば、 <code>filter filterEntry</code>と <code>head</code>の<strong>合成</strong>
(composition) に <code>book</code>が渡されるということです。</p>
<p>PureScriptの関数合成演算子は <code>&lt;&lt;&lt;</code>と <code>&gt;&gt;&gt;</code>です。前者は「逆方向の合成」であり、後者は「順方向の合成」です。</p>
<p>いずれかの演算子を使用して <code>findEntry</code>の右辺を書き換えることができます。逆順の合成を使用すると、右辺は次のようになります。</p>
<pre><code class="language-haskell">(head &lt;&lt;&lt; filter filterEntry) book
</code></pre>
<p>この形式なら最初の定義にイータ変換の技を適用することができ、 <code>findEntry</code>は最終的に次のような形式に到達します。</p>
<pre><code class="language-haskell">findEntry firstName lastName = head &lt;&lt;&lt; filter filterEntry
  where
    ...
</code></pre>
<p>右辺を次のようにしても同じく妥当です。</p>
<pre><code class="language-haskell">filter filterEntry &gt;&gt;&gt; head
</code></pre>
<p>どちらにしても、これは「<code>findEntry</code>はフィルタリング関数と <code>head</code>関数の合成である」という
<code>findEntry</code>関数のわかりやすい定義を与えます。</p>
<p>どちらの定義のほうがわかりやすいかの判断はお任せしますが、このように関数を部品として捉えると有用なことがよくあります。
関数はひとつの役目だけをこなし、機能を関数合成で組み立てるというように。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>（簡単）<code>findEntry</code>関数の定義の主な部分式の型を書き下し、 <code>findEntry</code>関数についてよく理解しているか試してみましょう。
たとえば、 <code>findEntry</code>の定義のなかにある <code>head</code>関数の型は <code>AddressBook -&gt; Maybe Entry</code>と特殊化されています。
<strong>補足</strong>：この問題にはテストがありません。</li>
<li>（普通）関数<code>findEntryByStreet :: String -&gt; AddressBook -&gt; Maybe Entry</code>を書いてください。
この関数は与えられた通りの住所から<code>Entry</code>を見付け出します。
<strong>ヒント</strong>：<code>findEntry</code>にある既存のコードを再利用してください。
実装した関数をPSCiと<code>spago test</code>を走らせることでテストしてください。</li>
<li>（普通）<code>filterEntry</code>を（<code>&lt;&lt;&lt;</code>や<code>&gt;&gt;&gt;</code>を使った）合成で置き換えて、<code>findEntryByStreet</code>を書き直してください。
合成の対象は、プロパティ取得子（<code>_.</code>記法を使います）と、与えられた文字列引数が与えられた通りの住所に等しいかを判定する関数です。</li>
<li>（普通）指定された名前が <code>AddressBook</code>に存在するかどうかを調べて真偽値で返す関数<code>isInBook</code>を書いてみましょう。
<strong>ヒント</strong>：リストが空かどうかを調べる <code>Data.List.null</code>関数の型をPSCiで調べてみてみましょう。</li>
<li>（難しい）「重複」している項目を住所録から削除する関数 <code>removeDuplicates</code>を書いてみましょう。
項目が同じ姓名を共有していれば<code>address</code>フィールドに関係なく、項目が重複していると考えます。
<strong>ヒント</strong>：関数 <code>Data.List.nubBy</code>の型を、PSCiを使用して調べてみましょう。
この関数は値同士の等価性を定義する述語関数に基づいてリストから重複要素を削除します。
なお、それぞれの重複する項目の集合における最初の要素（リストの先頭に最も近い）が保持する項目です。</li>
</ol>
<h2 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h2>
<p>この章では、関数型プログラミングの新しい概念をいくつか導入しました。</p>
<ul>
<li>対話的モードPSCiを使用して関数を調べるなど思いついたことを試す方法</li>
<li>検証や実装の道具としての型の役割</li>
<li>多引数関数を表現する、カリー化された関数の使用</li>
<li>関数合成で小さな部品を組み合わせてのプログラムの構築</li>
<li><code>where</code>節を利用したコードの構造化</li>
<li><code>Maybe</code>型を使用してnull値を回避する方法</li>
<li>イータ変換や関数合成のような手法を利用した、よりわかりやすいコードへの
再構成</li>
</ul>
<p>次の章からは、これらの考えかたに基づいて進めていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="再帰マップ畳み込み"><a class="header" href="#再帰マップ畳み込み">再帰、マップ、畳み込み</a></h1>
<h2 id="この章の目標-2"><a class="header" href="#この章の目標-2">この章の目標</a></h2>
<p>この章では、アルゴリズムを構造化するときに再帰関数をどのように使うかについて見ていきましょう。再帰は関数型プログラミングの基本的な手法であり、この本の全体に亙って使われます。</p>
<p>また、PureScriptの標準ライブラリから標準的な関数をいくつか取り扱います。
<code>map</code>や<code>fold</code>といった関数だけでなく、<code>filter</code>や<code>concatMap</code>といった特別な場合において便利なものについても見ていきます。</p>
<p>この章では、仮想的なファイルシステムを操作する関数のライブラリを動機付けに用います。この章で学ぶ手法を応用して、擬似的なファイルシステムによって表されるファイルのプロパティを計算する関数を記述します。</p>
<h2 id="プロジェクトの準備-1"><a class="header" href="#プロジェクトの準備-1">プロジェクトの準備</a></h2>
<p>この章のソースコードは<code>src/Data/Path.purs</code>と<code>test/Examples.purs</code>に含まれています。
<code>Data.Path</code>モジュールは仮想ファイルシステムのモデルを含みます。
このモジュールの内容を変更する必要はありません。
演習への解答は<code>Test.MySolutions</code>モジュールに実装してください。
それぞれの演習を完了させつつ都度<code>Test.Main</code>モジュールにある対応するテストを有効にし、
<code>spago test</code>を走らせることで解答を確認してください。</p>
<p>このプロジェクトには以下の依存関係があります。</p>
<ul>
<li><code>maybe</code>: <code>Maybe</code>型構築子が定義されています。</li>
<li><code>arrays</code>: 配列を扱うための関数が定義されています。</li>
<li><code>strings</code>: JavaScriptの文字列を扱うための関数が定義されています。</li>
<li><code>foldable-traversable</code>: 配列やその他のデータ構造を畳み込む関数が定義さ
れています。</li>
<li><code>console</code>: コンソールへの出力を扱うための関数が定義されています。</li>
</ul>
<h2 id="導入-1"><a class="header" href="#導入-1">導入</a></h2>
<p>再帰は一般のプログラミングでも重要な手法ですが、特に純粋関数型プログラミングでは当たり前のように用いられます。この章で見ていくように、再帰はプログラムの変更可能な状態を減らすために役立つからです。</p>
<p>再帰は<strong>分割統治</strong> (divide and conquer) 戦略と密接な関係があります。
分割統治とはすなわち、何らかの入力としての問題を解くにあたり、入力を小さな部分に分割し、それぞれの部分について問題を解いて、部分ごとの答えから最終的な答えを組み立てるということです。</p>
<p>それでは、PureScriptにおける再帰の簡単な例をいくつか見てみましょう。</p>
<p>次は<strong>階乗関数</strong> (factorial function) のよくある例です。</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n =
  if n == 0 then
    1
  else
    n * factorial (n - 1)
</code></pre>
<p>部分問題へ問題を分割することによって階乗関数がどのように計算されるかがわかります。より小さい数へと階乗を計算していくということです。ゼロに到達すると、答えは直ちに求まります。</p>
<p>次は、<strong>フィボナッチ関数</strong> (Fibonacci function) を計算するという、これまたよくある例です。</p>
<pre><code class="language-haskell">fib :: Int -&gt; Int
fib n =
  if n == 0 then
    0
  else if n == 1 then
    1
  else
    fib (n - 1) + fib (n - 2)
</code></pre>
<p>やはり、部分問題の解決策を考えることで全体を解決していることがわかります。
このとき、<code>fib (n - 1)</code>と<code>fib (n - 2)</code>という式に対応した、2つの部分問題があります。
これらの2つの部分問題が解決されていれば、この部分的な答えを加算することで、全体の答えを組み立てることができます。</p>
<p>なお上の<code>factorial</code>と<code>fib</code>の例は意図通りに動きますが、
より慣習的な実装では<code>if</code>や<code>then</code>や<code>else</code>を使う代わりにパターン照合を使うものでしょう。
パターン照合の技法は後の章でお話しします。</p>
<h2 id="配列上での再帰"><a class="header" href="#配列上での再帰">配列上での再帰</a></h2>
<p>再帰関数の定義は、<code>Int</code>型だけに限定されるものではありません！
本書の後半で<strong>パターン照合</strong> (pattern matching)
を扱うときに、いろいろなデータ型の上での再帰関数について見ていきますが、ここでは数と配列に限っておきます。</p>
<p>入力がゼロでないかどうかについて分岐するのと同じように、配列の場合も、配列が空でないかどうかについて分岐していきます。再帰を使用して配列の長さを計算する次の関数を考えてみます。</p>
<pre><code class="language-haskell">import Prelude

import Data.Array (null, tail)
import Data.Maybe (fromMaybe)

length :: forall a. Array a -&gt; Int
length arr =
  if null arr then
    0
  else
    1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>この関数では配列が空かどうかで分岐するために<code>if ... then ... else</code>式を使っています。
この<code>null</code>関数は配列が空のときに<code>true</code>を返します。
空の配列の長さはゼロであり、空でない配列の長さは配列の先頭を取り除いた残りの部分の長さより1大きいというわけです。</p>
<p><code>tail</code>関数は与えられた配列から最初の要素を除いたものを<code>Maybe</code>に包んで返します。
配列が空であれば（つまり尾鰭がありません）<code>Nothing</code>が返ります。
<code>fromMaybe</code>関数は既定値と<code>Maybe</code>値を取ります。
後者が<code>Nothing</code>であれば既定義を返し、そうでなければ<code>Just</code>に包まれた値を返します。</p>
<p>JavaScriptで配列の長さを調べるのには、この例はどうみても実用的な方法とはいえませんが、次の演習を完了するための手がかりとしては充分でしょう。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>（簡単）入力が偶数であるとき、かつそのときに限り<code>true</code>に返すような再帰関数を書いてみましょう。</li>
<li>（少し難しい）配列内の偶数の数を数える再帰関数<code>countEven</code>を書いてみましょう。
<strong>ヒント</strong>：<code>Data.Array</code>モジュールの<code>head</code>関数を使うと、空でない配列の最初の要素を見つけることができます。</li>
</ol>
<h2 id="マップ"><a class="header" href="#マップ">マップ</a></h2>
<p><code>map</code>関数は配列に対する再帰関数のひとつです。
この関数を使うと、配列の各要素に順番に関数を適用することで、配列の要素を変換することができます。
そのため、配列の<strong>内容</strong>は変更されますが、その<strong>形状</strong>（ここでは「長さ」）は保存されます。</p>
<p>本書の後半で<strong>型クラス</strong> (type class) の内容を押さえるとき、
<code>map</code>関数が形状保存関数のより一般的な様式の一例であることを見ていきます。
これは<strong>関手</strong> (functor) と呼ばれる型構築子のクラスを変換するものです。</p>
<p>それでは、PSCiで<code>map</code>関数を試してみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; map (\n -&gt; n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p><code>map</code>がどのように使われているかに注目してください。
最初の引数には配列上で「写す」関数、第2引数には配列そのものを渡します。</p>
<h2 id="中置演算子"><a class="header" href="#中置演算子">中置演算子</a></h2>
<p>バッククォートで関数名を囲むと、写す関数と配列の間に、<code>map</code>関数を書くことができます。</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) `map` [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>この構文は<strong>中置関数適用</strong>と呼ばれ、どんな関数でもこのように中置することができます。
普通は2引数の関数に対して使うのが最適でしょう。</p>
<p>配列を扱うときは、<code>map</code>関数と等価な<code>&lt;$&gt;</code>という演算子が存在します。この演算子は他の二項演算子と同じように中置で使用することができます。</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) &lt;$&gt; [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>それでは<code>map</code>の型を見てみましょう。</p>
<pre><code class="language-text">&gt; :type map
forall a b f. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>実は<code>map</code>の型は、この章で必要とされているものよりも一般的な型になっています。今回の目的では、<code>map</code>は次のようなもっと具体的な型であるかのように考えるとよいでしょう。</p>
<pre><code class="language-text">forall a b. (a -&gt; b) -&gt; Array a -&gt; Array b
</code></pre>
<p>この型では、<code>map</code>関数に適用するときには<code>a</code>と<code>b</code>という2つの型を自由に選ぶことができる、ということも示されています。
<code>a</code>は元の配列の要素の型で、<code>b</code>は目的の配列の要素の型です。
もっと言えば、<code>map</code>が配列の要素の型を保存する必要があるわけではありません。
たとえば、<code>map</code>を使用すると数値を文字列に変換することができます。</p>
<pre><code class="language-text">&gt; show &lt;$&gt; [1, 2, 3, 4, 5]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>中置演算子<code>&lt;$&gt;</code>は特別な構文のように見えるかもしれませんが、実はPureScriptの普通の関数の別称です。
中置構文を使用した単なる<strong>適用</strong>にすぎません。
実際、括弧でその名前を囲むと、この関数を通常の関数のように使用することができます。
これは、<code>map</code>代わりに、括弧で囲まれた<code>(&lt;$&gt;)</code>という名前を使って配列に関数を適用できるということです。</p>
<pre><code class="language-text">&gt; (&lt;$&gt;) show [1, 2, 3, 4, 5]
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>中置関数は既存の関数名の別称として定義されます。
たとえば、<code>Data.Array</code>モジュールでは次のように<code>range</code>関数の同義語として中置演算子<code>(..)</code>を定義しています。</p>
<pre><code class="language-haskell">infix 8 range as ..
</code></pre>
<p>この演算子は次のように使うことができます。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; 1 .. 5
[1, 2, 3, 4, 5]

&gt; show &lt;$&gt; (1 .. 5)
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p><strong>注意</strong>： 独自の中置演算子は、自然な構文を持った領域特化言語を定義するのに優れた手段になりえます。
ただし、乱用すると初心者が読めないコードになることがありますから、新たな演算子の定義には慎重になるのが賢明です。</p>
<p>上記の例では、<code>1 .. 5</code>という式は括弧で囲まれていましたが、実際にはこれは必要ありません。
なぜなら、<code>Data.Array</code>モジュールは、<code>&lt;$&gt;</code>に割り当てられた優先順位より高い優先順位を<code>..</code>演算子に割り当てているからです。
上の例では、<code>..</code>の優先順位は、予約語<code>infix</code>のあとに書かれた数の<code>8</code> と定義されていました。
ここでは<code>&lt;$&gt;</code>の優先順位よりも高い優先順位を<code>..</code>に割り当てており、このため括弧を付け加える必要がないということです。</p>
<pre><code class="language-text">&gt; show &lt;$&gt; 1 .. 5
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>中置演算子に（左または右の）<strong>結合性</strong>を与えたい場合は、代わりに予約語<code>infixl</code>と<code>infixr</code>を使います。
<code>infix</code>を使うと何ら結合性は割り当てられず、
同じ演算子を複数回使ったり複数の同じ優先度の演算子を使ったりするときに、式を括弧で囲まなければいけなくなります。</p>
<h2 id="配列のフィルタリング"><a class="header" href="#配列のフィルタリング">配列のフィルタリング</a></h2>
<p><code>Data.Array</code>モジュールでは他にも、よく<code>map</code>と一緒に使われる関数<code>filter</code>も提供しています。
この関数は、述語関数に適合する要素のみを残し、既存の配列から新しい配列を作成する機能を提供します。</p>
<p>たとえば、1から10までの数で、偶数であるような数の配列を計算したいとします。これは次のように行うことができます。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; filter (\n -&gt; n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
</code></pre>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>（簡単）<code>map</code>関数や<code>&lt;$&gt;</code>関数を使用して、 配列に格納された数のそれぞれの平方を計算する関数<code>squared</code>を書いてみましょう。
<strong>ヒント</strong>：<code>map</code>や<code>&lt;$&gt;</code>といった関数を使ってください。</li>
<li>（簡単）<code>filter</code>関数を使用して、数の配列から負の数を取り除く関数<code>keepNonNegative</code>を書いてみましょう。
<strong>ヒント</strong>：<code>filter</code>関数を使ってください。</li>
<li>（普通）
<ul>
<li><code>filter</code>の中置同義語<code>&lt;$?&gt;</code>を定義してください。
<strong>補足</strong>：中置同義語はREPLでは定義できないかもしれませんが、ファイルでは定義することができます。</li>
<li>関数<code>keepNonNegativeRewrite</code>を書いてください。
この関数は<code>filter</code>を自前の粗しい中置演算子<code>&lt;$?&gt;</code>で置き換えたところ以外は<code>keepNonNegative</code>と同じです。</li>
<li>PSCiで自前の演算子の優先度合いと結合性を試してください。
<strong>補足</strong>：この問題のための単体試験はありません。</li>
</ul>
</li>
</ol>
<h2 id="配列の平坦化"><a class="header" href="#配列の平坦化">配列の平坦化</a></h2>
<p>配列に関する標準的な関数として<code>Data.Array</code>で定義されているものには、<code>concat</code>関数もあります。<code>concat</code>は配列の配列をひとつの配列へと平坦化します。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concat
forall a. Array (Array a) -&gt; Array a

&gt; concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>関連する関数として、<code>concat</code>と<code>map</code>を組み合わせたような<code>concatMap</code>と呼ばれる関数もあります。
<code>map</code>は（相異なる型も可能な）値からの値への関数を引数に取りますが、それに対して<code>concatMap</code>は値から値の配列の関数を取ります。</p>
<p>実際に動かして見てみましょう。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concatMap
forall a b. (a -&gt; Array b) -&gt; Array a -&gt; Array b

&gt; concatMap (\n -&gt; [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
</code></pre>
<p>ここでは、数をその数とその数の平方の2つの要素からなる配列に写す関数<code>\n -&gt; [n, n * n]</code>を引数に<code>concatMap</code>を呼び出しています。
結果は10個の整数の配列です。
配列は1から5の数とそのそれぞれの数の平方からなります。</p>
<p><code>concatMap</code>がどのように結果を連結しているのかに注目してください。
渡された関数を元の配列のそれぞれの要素について一度づつ呼び出し、その関数はそれぞれ配列を生成します。
最後にそれらの配列を単一の配列に押し潰し、それが結果となります。</p>
<p><code>map</code>と<code>filter</code>、<code>concatMap</code>は、「配列内包表記」(array comprehensions)
と呼ばれる、配列に関するあらゆる関数の基盤を形成しています。</p>
<h2 id="配列内包表記"><a class="header" href="#配列内包表記">配列内包表記</a></h2>
<p>数<code>n</code>のふたつの因数を見つけたいとしましょう。これを行うための簡単​​な方法としては、総当りで調べる方法があります。つまり、<code>1</code>から<code>n</code>の数のすべての組み合わせを生成し、それを乗算してみるわけです。もしその積が<code>n</code>なら、<code>n</code>の因数の組み合わせを見つけたということになります。</p>
<p>配列内包表記を使用すると、この計算を実行することができます。
PSCiを対話式の開発環境として使用し、ひとつづつこの手順を進めていきましょう。</p>
<p>最初の手順では<code>n</code>以下の数の組み合わせの配列を生成しますが、これには<code>concatMap</code>を使えばよいです。</p>
<p><code>1 .. n</code>のそれぞれの数を配列<code>1 .. n</code>へとマッピングすることから始めましょう。</p>
<pre><code class="language-text">&gt; pairs n = concatMap (\i -&gt; 1 .. n) (1 .. n)
</code></pre>
<p>この関数をテストしてみましょう。</p>
<pre><code class="language-text">&gt; pairs 3
[1,2,3,1,2,3,1,2,3]
</code></pre>
<p>これは求めているものとはぜんぜん違います。
単にそれぞれの組み合わせの2つ目の要素を返すのではなく、ペア全体を保持することができるように、内側の<code>1 .. n</code>の複製について関数をマッピングする必要があります。</p>
<pre><code class="language-text">&gt; :paste
… pairs' n =
…   concatMap (\i -&gt;
…     map (\j -&gt; [i, j]) (1 .. n)
…   ) (1 .. n)
… ^D

&gt; pairs' 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
</code></pre>
<p>いい感じになってきました。
しかし、<code>[1, 2]</code>と<code>[2, 1]</code>の両方があるように、重複した組み合わせが生成されています。
<code>j</code>を<code>i</code>から<code>n</code>の範囲に限定することで、2つ目の場合を取り除くことができます。</p>
<pre><code class="language-text">&gt; :paste
… pairs'' n =
…   concatMap (\i -&gt;
…     map (\j -&gt; [i, j]) (i .. n)
…   ) (1 .. n)
… ^D
&gt; pairs'' 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
</code></pre>
<p>すばらしいです！因数の候補のすべての組み合わせを手に入れたので、<code>filter</code>を使えば、その積が<code>n</code>であるような組み合わせを選び出すことができます。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; factors n = filter (\pair -&gt; product pair == n) (pairs'' n)

&gt; factors 10
[[1,10],[2,5]]
</code></pre>
<p>このコードでは、<code>foldable-traversable</code>ライブラリの<code>Data.Foldable</code>モジュールにある<code>product</code>関数を使っています。</p>
<p>うまくいきました！因数の組み合わせの正しい集合を重複なく見つけることができました。</p>
<h2 id="do記法"><a class="header" href="#do記法">do記法</a></h2>
<p>しかし、このコードの可読性は大幅に向上することができます。
<code>map</code>や<code>concatMap</code>は基本的な関数であり、<strong>do記法</strong> (do notation)
と呼ばれる特別な構文の基礎になっています（もっと厳密にいえば、それらの一般化である<code>map</code>と<code>bind</code>が基礎をなしています）。</p>
<p><strong>注意</strong>：<code>map</code>と<code>concatMap</code>が<strong>配列内包表記</strong>を書けるようにしているように、もっと一般的な演算子である<code>map</code>と<code>bind</code>は<strong>モナド内包表記</strong>
(monad comprehensions) と呼ばれているものを書けるようにします。
本書の後半では<strong>モナド</strong> (monad) の例をたっぷり見ていくことになりますが、
この章では配列のみを考えます。</p>
<p>do記法を使うと、先ほどの<code>factors</code>関数を次のように書き直すことができます。</p>
<pre><code class="language-haskell">factors :: Int -&gt; Array (Array Int)
factors n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  pure [ i, j ]
</code></pre>
<p>キーワード<code>do</code>はdo記法を使うコードのブロックを導入します。このブロックは幾つかの種類の式で構成されています。</p>
<ul>
<li>配列の要素を名前に束縛する式。
これは後ろ向きの矢印<code>&lt;-</code>で示されていて、その左側は名前、右側は配列の型を持つ式です。</li>
<li>名前に配列の要素を束縛しない式。
<code>do</code>の <em>結果</em> はこの種類の式の一例であり、最後の行の<code>pure [i, j]</code>に示されています。</li>
<li><code>let</code>キーワードを使用し、式に名前を与える式。</li>
</ul>
<p>この新しい記法を使うと、アルゴリズムの構造がわかりやすくなることがあります。
心のなかで<code>&lt;-</code>を「選ぶ」という単語に置き換えるとすると、「1からnの間の要素<code>i</code>を選び、それからiからnの間の要素<code>j</code>を選び、<code>[i, j]</code>を返す」というように読むことができるでしょう。</p>
<p>最後の行では、<code>pure</code>関数を使っています。
この関数はPSCiで評価することができますが、型を明示する必要があります。</p>
<pre><code class="language-text">&gt; pure [1, 2] :: Array (Array Int)
[[1, 2]]
</code></pre>
<p>配列の場合、<code>pure</code>は単に1要素の配列を作成します。
実際に、<code>factors</code>関数を変更して、<code>pure</code>の代わりにこの形式を使うようにすることもできます。</p>
<pre><code class="language-haskell">factorsV2 :: Int -&gt; Array (Array Int)
factorsV2 n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  [ [ i, j ] ]
</code></pre>
<p>そして、結果は同じになります。</p>
<h2 id="ガード"><a class="header" href="#ガード">ガード</a></h2>
<p><code>factors</code>関数を更に改良する方法としては、このフィルタを配列内包表記の内側に移動するというものがあります。
これは<code>control</code>ライブラリにある<code>Control.Alternative</code>モジュールの<code>guard</code>関数を使用することで可能になります。</p>
<pre><code class="language-haskell">import Control.Alternative (guard)

factorsV3 :: Int -&gt; Array (Array Int)
factorsV3 n = do
  i &lt;- 1 .. n
  j &lt;- i .. n
  guard $ i * j == n
  pure [ i, j ]
</code></pre>
<p><code>pure</code>と同じように、どのように動作するかを理解するために、PSCiで<code>guard</code>関数を適用して調べてみましょう。
<code>guard</code>関数の型は、ここで必要とされるものよりもっと一般的な型になっています。</p>
<pre><code class="language-text">&gt; import Control.Alternative

&gt; :type guard
forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p>今回の場合は、PSCiは次の型を報告するものと考えてください。</p>
<pre><code class="language-haskell">Boolean -&gt; Array Unit
</code></pre>
<p>目的からすると、次の計算の結果から配列における<code>guard</code>関数について今知りたいことはすべてわかります。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; length $ guard true
1

&gt; length $ guard false
0
</code></pre>
<p>つまり、<code>guard</code>が<code>true</code>に評価される式を渡された場合、単一の要素を持つ配列を返すのです。もし式が<code>false</code>と評価された場合は、その結果は空です。</p>
<p>ガードが失敗した場合、配列内包表記の現在の分岐は、結果なしで早めに終了されることを意味します。
これは、<code>guard</code>の呼び出しが、途中の配列に対して<code>filter</code>を使用するのと同じだということです。
実践の場面にもよりますが、<code>filter</code>の代わりに<code>guard</code>を使いたいことは多いでしょう。
これらが同じ結果になることを確認するために、<code>factors</code>の2つの定義を試してみてください。</p>
<h2 id="演習-5"><a class="header" href="#演習-5">演習</a></h2>
<ol>
<li>（簡単）整数の引数が素数であるかどうかを調べる関数<code>isPrime</code>を定義してみましょう。
<strong>ヒント</strong>：<code>factors</code>関数を使ってください。</li>
<li>（普通）do記法を使い、2つの配列の<strong>直積集合</strong>を見つけるための関数<code>cartesianProduct</code>を書いてみましょう。
直積集合とは、要素<code>a</code>、<code>b</code>のすべての組み合わせの集合のことです。
ここで<code>a</code>は最初の配列の要素、<code>b</code>は2つ目の配列の要素です。</li>
<li>（普通）数値<code>n</code>を取って構成要素（値<code>a</code>, <code>b</code>, <code>c</code>）がそれぞれ<code>n</code>以下であるような全てのピタゴラスの3つ組
(pythagorean triples) を返す関数<code>triples :: Int -&gt; Array (Array Int)</code>を書いてください。
<strong>ピタゴラスの3つ組</strong> は数値の配列<code>[a, b, c]</code>で <code>a² + b² = c²</code> です。
<strong>ヒント</strong>：配列内包表記で<code>guard</code>関数を使ってください。</li>
<li>（難しい）<code>factors</code>関数を使用して、数<code>n</code>の<a href="https://www.mathsisfun.com/prime-factorization.html">素因数分解</a>を求める関数<code>primeFactors</code>を定義してみましょう。
数<code>n</code>の素因数分解とは、素数の積が<code>n</code>であるような整数の配列のことです。
<strong>ヒント</strong>：1より大きい整数について、問題を2つの部分問題に分解してください。
最初の因数を探し、それから残りの因数を探すのです。</li>
</ol>
<h2 id="畳み込み"><a class="header" href="#畳み込み">畳み込み</a></h2>
<p>配列における左右の畳み込みは、再帰を用いて実装される別の興味深い関数の集まりを提供します。</p>
<p>PSCiを使って、<code>Data.Foldable</code>モジュールをインポートし、<code>foldl</code>と<code>foldr</code>関数の型を調べることから始めましょう。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :type foldl
forall a b f. Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b

&gt; :type foldr
forall a b f. Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
</code></pre>
<p>これらの型は、現在興味があるものよりも一般的です。
この章の目的では、PSCiは以下の（より具体的な）答えを与えていたと考えておきましょう。</p>
<pre><code class="language-text">&gt; :type foldl
forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Array a -&gt; b

&gt; :type foldr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Array a -&gt; b
</code></pre>
<p>どちらの型でも、<code>a</code>は配列の要素の型に対応しています。
型<code>b</code>は、配列を走査 (traverse) したときの結果を累積する「累積器」(accumulator) の型だと考えることができます。</p>
<p><code>foldl</code>関数と<code>foldr</code>関数の違いは走査の方向です。
<code>foldr</code>が「右から」配列を畳み込むのに対して、<code>foldl</code>は「左から」配列を畳み込みます。</p>
<p>実際にこれらの関数の動きを見てみましょう。
<code>foldl</code>を使用して数の配列の和を求めてみます。
型<code>a</code>は<code>Int</code>になり、結果の型<code>b</code>も<code>Int</code>として選択することができます。
ここでは、次の要素を累積器に加算する<code>Int -&gt; Int -&gt; Int</code>という型の関数、<code>Int</code>型の累積器の初期値、
和を求めたい<code>Int</code>の配列という、3つの引数を提供する必要があります。
最初の引数としては、加算演算子を使用することができますし、累積器の初期値はゼロになります。</p>
<pre><code class="language-text">&gt; foldl (+) 0 (1 .. 5)
15
</code></pre>
<p>この場合では、引数が逆になっていても<code>(+)</code>関数は同じ結果を返すので、<code>foldl</code>と<code>foldr</code>のどちらでも問題ありません。</p>
<pre><code class="language-text">&gt; foldr (+) 0 (1 .. 5)
15
</code></pre>
<p><code>foldl</code>と<code>foldr</code>の違いを説明するために、畳み込み関数の選択が影響する例も書いてみましょう。
加算関数の代わりに、文字列連結を使用して文字列を作ってみます。</p>
<pre><code class="language-text">&gt; foldl (\acc n -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;12345&quot;

&gt; foldr (\n acc -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;54321&quot;
</code></pre>
<p>これは、2つの関数の​​違いを示しています。左畳み込み式は、以下の関数適用と同等です。</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 1) &lt;&gt; show 2) &lt;&gt; show 3) &lt;&gt; show 4) &lt;&gt; show 5)
</code></pre>
<p>それに対し、右畳み込みは以下に相当します。</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 5) &lt;&gt; show 4) &lt;&gt; show 3) &lt;&gt; show 2) &lt;&gt; show 1)
</code></pre>
<h2 id="末尾再帰"><a class="header" href="#末尾再帰">末尾再帰</a></h2>
<p>再帰はアルゴリズムを定義するための強力な手法ですが、問題も抱えています。
JavaScriptで再帰関数を評価するとき、入力が大きすぎるとスタックオーバーフローでエラーを起こす可能性があるのです。</p>
<p>PSCiで次のコードを入力すると、この問題を簡単に検証できます。</p>
<pre><code class="language-text">&gt; :paste
… f n =
…   if n == 0
…     then 0
…     else 1 + f (n - 1)
… ^D

&gt; f 10
10

&gt; f 100000
RangeError: Maximum call stack size exceeded
</code></pre>
<p>これは問題です。関数型プログラミングの基本的な手法として再帰を採用しようとするなら、無限かもしれない再帰でも扱える方法が必要です。</p>
<p>PureScriptは<strong>末尾再帰最適化</strong> (tail recursion optimization)
の形でこの問題に対する部分的な解決策を提供しています。</p>
<p><strong>注意</strong>：この問題へのより完全な解決策としては、いわゆる<strong>トランポリン</strong> (trampolining)
を使用したライブラリで実装する方法がありますが、それはこの章で扱う範囲を超えています。
この内容に興味のある読者は
<a href="https://pursuit.purescript.org/packages/purescript-free"><code>free</code></a>や
<a href="https://pursuit.purescript.org/packages/purescript-tailrec"><code>tailrec</code></a>パッケージの
ドキュメントを参照してみてください。</p>
<p>末尾再帰最適化を可能にする上で鍵となる観点は以下となります。
<strong>末尾位置</strong> (tail position)
にある関数の再帰的な呼び出しは、スタックフレームが確保されない<strong>ジャンプ</strong>に置き換えることができます。
関数が戻るより前の最後の呼び出しであるとき、呼び出しが<strong>末尾位置</strong>にあるといいます。
なぜこの例でスタックオーバーフローを観察したのかはこれが理由です。
この<code>f</code>の再帰呼び出しは、末尾位置<strong>ではない</strong>からです。</p>
<p>実際には、PureScriptコンパイラは再帰呼び出しをジャンプに置き換えるのではなく、再帰的な関数全体を<strong>whileループ</strong>に置き換えます。</p>
<p>以下はすべての再帰呼び出しが末尾位置にある再帰関数の例です。</p>
<pre><code class="language-haskell">factorialTailRec :: Int -&gt; Int -&gt; Int
factorialTailRec n acc =
  if n == 0
    then acc
    else factorialTailRec (n - 1) (acc * n)
</code></pre>
<p><code>fact</code>への再帰呼び出しは、この関数の中で起こる最後のものである、つまり末尾位置にあることに注意してください。</p>
<h2 id="累積器"><a class="header" href="#累積器">累積器</a></h2>
<p>末尾再帰ではない関数を末尾再帰関数に変える一般的な方法としては、<strong>累積器引数</strong> (accumulator parameter)
を使用する方法があります。
累積器引数は関数に追加される余剰の引数で返り値を<strong>累積</strong>するものです。
これは結果を累積するために返り値を使うのとは対称的です。</p>
<p>例えば章の初めに示した<code>length</code>関数を再考しましょう。</p>
<pre><code class="language-haskell">length :: forall a. Array a -&gt; Int
length arr =
  if null arr
    then 0
    else 1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>この実装は末尾再帰ではないので、大きな入力配列に対して実行されると、
生成されたJavaScriptはスタックオーバーフローを発生させるでしょう。
しかし代わりに、結果を蓄積するための2つ目の引数を関数に導入することで、これを末尾再帰に変えることができます。</p>
<pre><code class="language-haskell">lengthTailRec :: forall a. Array a -&gt; Int
lengthTailRec arr = length' arr 0
  where
  length' :: Array a -&gt; Int -&gt; Int
  length' arr' acc =
    if null arr'
      then acc
      else length' (fromMaybe [] $ tail arr') (acc + 1)
</code></pre>
<p>ここでは、配列を逆転させる作業を補助関数<code>length'</code>に委譲しています。
<code>length'</code>は末尾再帰です。
その唯一の再帰呼び出しは、最後の場合の末尾位置にあります。
これは、生成されたコードが<strong>whileループ</strong>となり、大きな入力でもスタックが溢れないことを意味します。</p>
<p><code>lengthTailRec</code>の実装を理解するために補助関数<code>length'</code>に着目しましょう。
この関数は必然的に累積器引数を使って追加の状態……これは部分的な結果です……を維持しています。
0から始まり、入力の配列中の全ての要素それぞれについて1ずつ足して成長していきます。</p>
<p>累積器を「状態」と考えることもできますが、直接に変更がされているわけではないことにも注意してください。</p>
<h2 id="明示的な再帰より畳み込みを選ぶ"><a class="header" href="#明示的な再帰より畳み込みを選ぶ">明示的な再帰より畳み込みを選ぶ</a></h2>
<p>末尾再帰を使用して再帰関数を記述することができれば末尾再帰最適化の恩恵を受けることができるので、
すべての関数をこの形で書こうとする誘惑にかられます。
しかし、多くの関数は配列やそれに似たデータ構造に対する折り畳みとして直接書くことができることを忘れがちです。
<code>map</code>や<code>fold</code>のようなコンビネータを使って直接アルゴリズムを書くことには、コードの単純さという利点があります。
これらのコンビネータはよく知られており、明示的な再帰よりもアルゴリズムの<strong>意図</strong>をよりはっきりとさせるのです。</p>
<p>例えば<code>foldr</code>を使って配列を反転できます。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :paste
… reverse :: forall a. Array a -&gt; Array a
… reverse = foldr (\x xs -&gt; xs &lt;&gt; [x]) []
… ^D

&gt; reverse [1, 2, 3]
[3,2,1]
</code></pre>
<p><code>foldl</code>を使って<code>reverse</code>を書くことは、読者への課題として残しておきます。</p>
<h2 id="演習-6"><a class="header" href="#演習-6">演習</a></h2>
<ol>
<li>（簡単）<code>foldl</code>を使って真偽値配列の値が全て真か検査する関数<code>allTrue</code>を書いてください。</li>
<li>（普通。テストなし）関数<code>foldl (==) false xs</code>が真を返すような配列<code>xs</code>とはどのようなものか説明してください。
言い換えると、「関数は<code>xs</code>が……を含むときに<code>true</code>を返す」という文を完成させることになります。</li>
<li>（普通）末尾再帰の形式を取っていること以外は<code>fib</code>と同じような関数<code>fibTailRec</code>を書いてください。
<strong>ヒント</strong>：累積器引数を使ってください。</li>
<li>（普通）<code>foldl</code>を使って<code>reverse</code>を書いてみましょう。</li>
</ol>
<h2 id="仮想ファイルシステム"><a class="header" href="#仮想ファイルシステム">仮想ファイルシステム</a></h2>
<p>この節では、これまで学んだことを応用して、模擬的なファイルシステムで動作する関数を書いていきます。
事前に定義されたAPIで動作するように、マップ、畳み込み、およびフィルタを使用します。</p>
<p><code>Data.Path</code>モジュールでは、次のように仮想ファイルシステムのAPIが定義されています。</p>
<ul>
<li>ファイルシステム内のパスを表す型<code>Path</code>があります。</li>
<li>ルートディレクトリを表すパス<code>root</code>があります。</li>
<li><code>ls</code>関数はディレクトリ内のファイルを列挙します。</li>
<li><code>filename</code>関数は<code>Path</code>のファイル名を返します。</li>
<li><code>size</code>関数は<code>Path</code>が示すファイルの大きさを返します。</li>
<li><code>isDirectory</code>関数はファイルかディレクトリかを調べます。</li>
</ul>
<p>型については、型定義は次のようになっています。</p>
<pre><code class="language-haskell">root :: Path

ls :: Path -&gt; Array Path

filename :: Path -&gt; String

size :: Path -&gt; Maybe Int

isDirectory :: Path -&gt; Boolean
</code></pre>
<p>PSCiでこのAPIを試してみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Path

&gt; root
/

&gt; isDirectory root
true

&gt; ls root
[/bin/,/etc/,/home/]
</code></pre>
<p><code>Test.Examples</code>モジュールでは<code>Data.Path</code>APIを使用する関数を定義しています。
<code>Data.Path</code>モジュールを変更したり定義を理解したりする必要はありません。
全て<code>Test.Examples</code>モジュールだけで作業を行います。</p>
<h2 id="すべてのファイルの一覧"><a class="header" href="#すべてのファイルの一覧">すべてのファイルの一覧</a></h2>
<p>それでは、内側のディレクトリまで、すべてのファイルを列挙する関数を書いてみましょう。
この関数は以下のような型を持つでしょう。</p>
<pre><code class="language-haskell">allFiles :: Path -&gt; Array Path
</code></pre>
<p>再帰を使ってこの関数を定義することができます。
まずは<code>ls</code>を使用してディレクトリの直接の子を列挙します。
それぞれの子について再帰的に<code>allFiles</code>を適用すると、それぞれパスの配列が返ってくるでしょう。
<code>concatMap</code>を適用すると、この結果を同時に平坦化することができます。</p>
<p>最後に、cons演算子<code>:</code>を使って現在のファイルも含めます。</p>
<pre><code class="language-haskell">allFiles file = file : concatMap allFiles (ls file)
</code></pre>
<p><strong>注意</strong>：cons演算子<code>:</code>は、実際には不変な配列に対してパフォーマンスが悪いので、一般的には推奨されません。
リンクリストやシーケンスなどの他のデータ構造を使用すると、パフォーマンスを向上させることができます。</p>
<p>それではPSCiでこの関数を試してみましょう。</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.Path

&gt; allFiles root

[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]
</code></pre>
<p>すばらしい！
do記法で配列内包表記を使ってもこの関数を書くことができるので見ていきましょう。</p>
<p>逆向きの矢印は配列から要素を選択するのに相当することを思い出してください。
最初の手順は、引数の直接の子から要素を選択することです。
それから、単にそのファイルに対してこの再帰関数を呼びします。
do記法を使用しているので、再帰的な結果をすべて連結する<code>concatMap</code>が暗黙に呼び出されています。</p>
<p>新しいバージョンは次のようになります。</p>
<pre><code class="language-haskell">allFiles' :: Path -&gt; Array Path
allFiles' file = file : do
  child &lt;- ls file
  allFiles' child
</code></pre>
<p>PSCiで新しいコードを試してみてください。
同じ結果が返ってくるはずです。
どちらのほうがわかりやすいかの選択はお任せします。</p>
<h2 id="演習-7"><a class="header" href="#演習-7">演習</a></h2>
<ol>
<li>
<p>（簡単）ディレクトリのすべてのサブディレクトリの中まで、（ディレクトリを除く）すべてのファイルを返すような関数<code>onlyFiles</code>を書いてみてください。</p>
</li>
<li>
<p>（普通）ファイルを名前で検索する関数<code>whereIs</code>を書いてください。
この関数は型<code>Maybe Path</code>の値を返すものとします。
この値が存在するなら、そのファイルがそのディレクトリに含まれているということを表します。
この関数は次のように振る舞う必要があります。</p>
<pre><code class="language-text">&gt; whereIs root &quot;ls&quot;
Just (/bin/)

&gt; whereIs root &quot;cat&quot;
Nothing
</code></pre>
<p><strong>ヒント</strong>：この関数をdo記法を使った配列内包表記で書いてみましょう。</p>
</li>
<li>
<p>（難しい）<code>Path</code>を取って<code>Path</code>に最大のファイルと最小のファイルを1つずつ含む配列を返す関数<code>largestSmallest</code>を書いてください。
<strong>補足</strong>：空配列や1要素の配列を返すことで、
<code>Path</code>にゼロか1個のファイルがある場合についても考慮してください。</p>
</li>
</ol>
<h2 id="まとめ-2"><a class="header" href="#まとめ-2">まとめ</a></h2>
<p>この章では、アルゴリズムを簡潔に表現する手段として、PureScriptでの再帰の基本を説明しました。
また、独自の中置演算子や、マップ、フィルタリングや畳み込みなどの配列に対する標準関数、
およびこれらの概念を組み合わせた配列内包表記を導入しました。
最後に、スタックオーバーフローエラーを回避するために末尾再帰を使用することの重要性、
累積器引数を使用して末尾再帰形に関数を変換する方法を示しました。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パターン照合"><a class="header" href="#パターン照合">パターン照合</a></h1>
<h2 id="この章の目標-3"><a class="header" href="#この章の目標-3">この章の目標</a></h2>
<p>この章では、代数的データ型とパターン照合という、ふたつの新しい概念を導入します。
また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱います。</p>
<p><strong>パターン照合</strong> (pattern matching) は関数​​型プログラミングにおける一般的な手法で、
複数の場合に実装を分解することにより、開発者は潜在的に複雑な動作の関数を簡潔に書くことができます。</p>
<p>代数的データ型はPureScriptの型システムの機能であり、
型のある言語において同様の水準の表現力を可能にしています。
パターン照合とも密接に関連しています。</p>
<p>この章の目的は、代数的データ型やパターン照合を使用して、
単純なベクターグラフィックスを描画し操作するためのライブラリを書くことです。</p>
<h2 id="プロジェクトの準備-2"><a class="header" href="#プロジェクトの準備-2">プロジェクトの準備</a></h2>
<p>この章のソースコードはファイル <code>src/Data/Picture.purs</code>で定義されています。</p>
<p><code>Data.Picture</code>モジュールは、簡単な図形を表すデータ型 <code>Shape</code>や、図形の集合である型
<code>Picture</code>、及びこれらの型を扱うための関数を定義しています。</p>
<p>このモジュールでは、データ構造の畳込みを行う関数を提供する <code>Data.Foldable</code>モジュールもインポートします。</p>
<pre><code class="language-haskell">module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
</code></pre>
<p><code>Data.Picture</code>モジュールは<code>Number</code>モジュールもインポートしますが、こちらは<code>as</code>キーワードを使います。</p>
<pre><code class="language-haskell">import Data.Number as Number
</code></pre>
<p>これは型や関数をモジュール内で使用できるようにしますが、
それは<code>Number.max</code>のように<strong>修飾名</strong>を使ったときのみです。
これは重複したインポートを避けたり、
何らかのものがどのモジュールからインポートされたのかを明らかにするのに役立ちます。</p>
<p><strong>注意</strong>：元のモジュールと同じモジュール名を修飾名に使用するのは不要です。
<code>import Math as M</code>などのより短い名前にすることは可能ですし、かなりよくあります。</p>
<h2 id="単純なパターン照合"><a class="header" href="#単純なパターン照合">単純なパターン照合</a></h2>
<p>それではコード例を見ることから始めましょう。
パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになります。</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>このアルゴリズムはユークリッドの互除法と呼ばれています。
その定義をオンラインで検索すると、
おそらく上記のコードによく似た数学の方程式が見つかるでしょう。
パターン照合の利点のひとつは、
上記のようにコードを場合分けして定義することができ、
数学関数の定義と似たような簡潔で宣言型なコードを書くことができることです。</p>
<p>パターン照合を使用して書かれた関数は、
条件と結果の組み合わせによって動作します。
この定義の各行は<strong>選択肢</strong> (alternative) や<strong>場合</strong> (case) と呼ばれています。
等号の左辺の式は<strong>パターン</strong>と呼ばれており、
それぞれの場合は空白で区切られた1つ以上のパターンで構成されています。
場合の集まりは、等号の右側の式が評価され値が返される前に、
引数が満たさなければならないどれかの条件を表現しています。
それぞれの場合は上からこの順番に試されていき、
最初に入力に適合した場合が返り値を決定します。</p>
<p>たとえば、 <code>gcd</code>関数は次の手順で評価されます。</p>
<ul>
<li>まず最初の場合が試されます。第2引数がゼロの場合、関数は <code>n</code>（最初の引
数）を返します。</li>
<li>そうでなければ、2番目の場合が試されます。最初の引数がゼロの場合、関数
は <code>m</code>（第2引数）を返します。</li>
<li>それ以外の場合、関数は最後の行の式を評価して返します。</li>
</ul>
<p>パターンは値を名前に束縛することができることに注意してください。
この例の各行では <code>n</code>という名前と <code>m</code>という名前の両方、
またはどちらか一方に、入力された値を束縛しています。
これよりさまざまな種類のパターンについて学びますが、
これらのパターンは入力の引数から名前を選ぶさまざまな方法に対応付けられることがわかるでしょう。</p>
<h2 id="単純なパターン"><a class="header" href="#単純なパターン">単純なパターン</a></h2>
<p>上記のコード例では、2種類のパターンを示しました。</p>
<ul>
<li><code>Int</code>型の値が正確に一致する場合にのみ適合する、整数リテラルパターン</li>
<li>引数を名前に束縛する、変数パターン</li>
</ul>
<p>単純なパターンには他にも種類があります。</p>
<ul>
<li><code>Number</code>、<code>String</code>、<code>Char</code>、そして<code>Boolean</code>といったリテラル</li>
<li>どんな引数とも適合するが名前に束縛はしない、アンダースコア (<code>_</code>) で表
されるワイルドカードパターン</li>
</ul>
<p>ここではこれらの単純なパターンを使用した、さらに2つの例を示します。</p>
<pre><code class="language-haskell">fromString :: String -&gt; Boolean
fromString &quot;true&quot; = true
fromString _      = false

toString :: Boolean -&gt; String
toString true  = &quot;true&quot;
toString false = &quot;false&quot;
</code></pre>
<p>PSCiでこれらの関数を試してみてください。</p>
<h2 id="ガード-1"><a class="header" href="#ガード-1">ガード</a></h2>
<p>ユークリッドの互除法の例では、<code>m &gt; n</code>のときと <code>m &lt;= n</code>のときの2つに分岐するために <code>if .. then .. else</code>式を使っていました。
こういうときには他に<strong>ガード</strong> (guard) を使うという選択肢もあります。</p>
<p>ガードはパターンによる制約に加えて満たされなくてはいけない真偽値の式です。
ガードを使用してユークリッドの互除法を書き直すと、次のようになります。</p>
<pre><code class="language-haskell">gcdV2 :: Int -&gt; Int -&gt; Int
gcdV2 n 0 = n
gcdV2 0 n = n
gcdV2 n m | n &gt; m     = gcdV2 (n - m) m
          | otherwise = gcdV2 n (m - n)
</code></pre>
<p>この場合、3行目ではガードを使用して、最初の引数が第2引数よりも厳密に大きいという条件を付け加えています。
最後の行でのガードは式<code>otherwise</code>を使っており、キーワードのようにも見えますが、
実際にはただの<code>Prelude</code>における通常の束縛なのです。</p>
<pre><code class="language-text">&gt; :type otherwise
Boolean

&gt; otherwise
true
</code></pre>
<p>この例が示すように、ガードは等号の左側に現れ、パイプ文字 (<code>|</code>) でパターンのリストと区切られています。</p>
<h2 id="演習-8"><a class="header" href="#演習-8">演習</a></h2>
<ol>
<li>（簡単）パターン照合を使用して、階乗関数<code>factorial</code>を書いてみましょう。
<strong>ヒント</strong>:入力がゼロのときとゼロでないときの、ふたつのコーナーケースを考えてみてください。
<strong>補足</strong>：これは前の章からの例の繰り返しですが、ここでは自力で書き直せるかやってみてください。</li>
<li>（普通）\( (1 + x) ^ n \)を多項式展開した式にある
\( x ^ k \)の項の係数を求める関数<code>binomial</code>を書いてください。
これは<code>n</code>要素の集合から<code>k</code>要素の部分集合を選ぶ方法の数と同じです。
数式\( n! / k! (n - k)! \)を使ってください。
ここで \( ! \) は前に書いた階乗関数です。
<strong>ヒント</strong>：パターン照合を使ってコーナーケースを制御してください。
長い時間が掛かったりコールスタックのエラーでクラッシュしたりしたら、
もっとコーナーケースを追加してみてください。</li>
<li>（普通）<a href="https://en.wikipedia.org/wiki/Pascal%27s_rule"><strong>パスカルの法則</strong></a>を使って
前の演習の同じ2項係数を計算する関数<code>pascal</code>を書いてください。</li>
</ol>
<h2 id="配列パターン"><a class="header" href="#配列パターン">配列パターン</a></h2>
<p><strong>配列リテラルパターン</strong> (array literal patterns) は、固定長の配列に対して照合を行う方法を提供します。
たとえば、空の配列であることを特定する関数 <code>isEmpty</code>を書きたいとします。
最初の選択肢に空の配列パターン (<code>[]</code>) を用いるとこれを実現できます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty [] = true
isEmpty _ = false
</code></pre>
<p>次の関数では、長さ5の配列と適合し、配列の5つの要素をそれぞれ異なった方法で束縛しています。</p>
<pre><code class="language-haskell">takeFive :: Array Int -&gt; Int
takeFive [0, 1, a, b, _] = a * b
takeFive _ = 0
</code></pre>
<p>最初のパターンは、第1要素と第2要素がそれぞれ0と1であるような、5要素の配列にのみ適合します。
その場合、関数は第3要素と第4要素の積を返します。
それ以外の場合は、関数は0を返します。
PSCiで試してみると、たとえば次のようになります。</p>
<pre><code class="language-text">&gt; :paste
… takeFive [0, 1, a, b, _] = a * b
… takeFive _ = 0
… ^D

&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0
</code></pre>
<p>配列のリテラルパターンでは、固定長の配列と一致させることはできますが、
PureScriptは不特定の長さの配列を照合させる手段を提供していません。
そのような方法で不変な配列を分解すると、
実行速度が低下する可能性があるためです。
この種の照合を行うことができるデータ構造が必要な場合は、
<code>Data.List</code>を使うことをお勧めします。
そのほかの操作について、
より優れた漸近性能を提供するデータ構造も存在します。</p>
<h2 id="レコードパターンと行多相"><a class="header" href="#レコードパターンと行多相">レコードパターンと行多相</a></h2>
<p><strong>レコードパターン</strong> (Record patterns) は（ご想像のとおり）レコードに照合します。</p>
<p>レコードパターンはレコードリテラルに見た目が似ていますが、
レコードリテラルでラベルと式を<strong>コロン</strong>で区切るのとは異なり、
レコードパターンではラベルとパターンを<strong>等号</strong>で区切ります。</p>
<p>たとえば、次のパターンは <code>first</code>と <code>last</code>と呼ばれるフィールドが含まれた任意のレコードにマッチし、
これらのフィールドの値はそれぞれ <code>x</code>と <code>y</code>という名前に束縛されます。</p>
<pre><code class="language-haskell">showPerson :: { first :: String, last :: String } -&gt; String
showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x
</code></pre>
<p>レコードパターンはPureScriptの型システムの興味深い機能である
<strong>行多相</strong> (row polymorphism) の良い例となっています。
もし上の<code>showPerson</code>を型シグネチャなしで定義していたとすると、
この型はどのように推論されるのでしょうか？
面白いことに、推論される型は上で与えた型とは同じではありません。</p>
<pre><code class="language-text">&gt; showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x

&gt; :type showPerson
forall r. { first :: String, last :: String | r } -&gt; String
</code></pre>
<p>この型変数 <code>r</code>とは何でしょうか？
PSCiで <code>showPerson</code>を使ってみると、面白いことがわかります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;
</code></pre>
<p>レコードにそれ以外のフィールドが追加されていても、
<code>showPerson</code>関数はそのまま動作するのです。
型が <code>String</code>であるようなフィールド <code>first</code>と <code>last</code>がレコードに少なくとも含まれていれば、
関数適用は正しく型付けされます。
しかし、フィールドが<strong>不足</strong>していると、 <code>showPerson</code>の呼び出しは<strong>不正</strong>となります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot; }

Type of expression lacks required label &quot;last&quot;
</code></pre>
<p><code>showPerson</code>の新しい型シグネチャを読むと、「<code>String</code>な<code>first</code>と<code>last</code>フィールド<strong>と他のフィールドを何でも</strong>持つあらゆるレコードを取り、<code>String</code>を返す」となります。
なお、この振舞いは元の<code>showPerson</code>のものとは異なります。
行変数<code>r</code>がなければ<code>showPerson</code>は<strong>厳密に</strong><code>first</code>と<code>last</code>フィールドしかないレコードのみを受け付けます。</p>
<p>次のように書くことができることにも注意してください。</p>
<pre><code class="language-haskell">&gt; showPerson p = p.last &lt;&gt; &quot;, &quot; &lt;&gt; p.first
</code></pre>
<p>この場合も、 PSCiは先ほどと同じ型を推論するでしょう。</p>
<h2 id="レコード同名利用"><a class="header" href="#レコード同名利用">レコード同名利用</a></h2>
<p><code>showPerson</code>関数は引数内のレコードと一致し、
<code>first</code>と<code>last</code>フィールドを<code>x</code>と <code>y</code>という名前の値に束縛していたのでした。
別の方法として、フィールド名自体を再利用するだけで、このようなパターン一致を次のように単純化できます。</p>
<pre><code class="language-haskell">showPersonV2 :: { first :: String, last :: String } -&gt; String
showPersonV2 { first, last } = last &lt;&gt; &quot;, &quot; &lt;&gt; first
</code></pre>
<p>ここでは、プロパティの名前のみを指定し、名前に導入したい値を指定する必要はありません。
これは<strong>レコード同名利用</strong> (record pun) と呼ばれます。</p>
<p>レコード同名利用をレコードの<strong>構築</strong>に使用することもできます。
例えば、スコープ内に <code>first</code>と <code>last</code>という名前の値があれば、
<code>{ first, last }</code>を使って人物レコードを作ることができます。</p>
<pre><code class="language-haskell">unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = &quot;Jane&quot;
    last  = &quot;Doe&quot;
</code></pre>
<p>これは、状況によってはコードの可読性を向上させるのに役立ちます。</p>
<h2 id="入れ子になったパターン"><a class="header" href="#入れ子になったパターン">入れ子になったパターン</a></h2>
<p>配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大きなパターンを構成しています。
これまでの例ではほとんどの場合で配列パターンとレコードパターンの内部に単純なパターンを使用していましたが、
パターンが自由に<strong>入れ子</strong>にすることができることも知っておくのが大切です。
入れ子になったパターンを使うと、
潜在的に複雑なデータ型に対しての条件分岐を用いて関数を定義できるようになります。</p>
<p>たとえば、このコードは2つのレコードパターンを結合します。</p>
<pre><code class="language-haskell">type Address = { street :: String, city :: String }

type Person = { name :: String, address :: Address }

livesInLA :: Person -&gt; Boolean
livesInLA { address: { city: &quot;Los Angeles&quot; } } = true
livesInLA _ = false
</code></pre>
<h2 id="名前付きパターン"><a class="header" href="#名前付きパターン">名前付きパターン</a></h2>
<p>入れ子のパターンを使う場合、パターンには<strong>名前を付け</strong>て追加で名前をスコープに持ち込むことができます。
任意のパターンに名前を付けるには、 <code>@</code>記号を使います。</p>
<p>たとえば、次の関数は2要素配列を整列するもので、2つの要素の名前を付けていますが、
配列自身にも名前を付けています。</p>
<pre><code class="language-haskell">sortPair :: Array Int -&gt; Array Int
sortPair arr@[x, y]
  | x &lt;= y = arr
  | otherwise = [y, x]
sortPair arr = arr
</code></pre>
<p>このようにすれば対が既に整列されているときに新しい配列を割り当てなくて済みます。
なおもし入力の配列が<strong>厳密に</strong>2つの要素を含んでいなければ、
たとえ整列されていなかったとしても、この関数は単に元のまま変えずに返しています。</p>
<h2 id="演習-9"><a class="header" href="#演習-9">演習</a></h2>
<ol>
<li>（簡単）レコードパターンを使って、
2つの <code>Person</code>レコードが同じ都市にいるか探す関数 <code>sameCity</code>を定義してみましょう。</li>
<li>（普通）行多相を考慮すると、 <code>sameCity</code>関数の最も一般的な型は何でしょうか？
先ほど定義した <code>livesInLA</code>関数についてはどうでしょうか？
<strong>補足</strong>：この演習にテストはありません。</li>
<li>（普通）配列リテラルパターンを使って、
1要素の配列の唯一のメンバーを抽出する関数<code>fromSingleton</code>を書いてみましょう。
1要素だけを持つ配列でない場合、
関数は指定されたデフォルト値を返さなければなりません。
この関数は <code>forall a. a -&gt; Array a -&gt; a</code>という型を持っていなければなりません。</li>
</ol>
<h2 id="case式"><a class="header" href="#case式">Case式</a></h2>
<p>パターンは最上位にある関数宣言だけに現れるわけではありません。
<code>case</code>式を使って計算の途中の値に対してパターン照合を使うことができます。
case式には無名関数に似た種類の便利さがあります。
関数に名前を与えることがいつも望ましいわけではないように、
パターン照合を使いたいためだけに関数に名前をつけるようなことを避けられるようになります。</p>
<p>例を示しましょう。
次の関数は、配列の「最長ゼロ末尾」（和がゼロであるような、最も長い配列の末尾）を計算します。</p>
<pre><code class="language-haskell">import Data.Array (tail)
import Data.Foldable (sum)
import Data.Maybe (fromMaybe)

lzs :: Array Int -&gt; Array Int
lzs [] = []
lzs xs = case sum xs of
           0 -&gt; xs
           _ -&gt; lzs (fromMaybe [] $ tail xs)
</code></pre>
<p>以下は例です。</p>
<pre><code class="language-text">&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]
</code></pre>
<p>この関数は場合ごとの分析によって動作します。
もし配列が空なら、唯一の選択肢は空の配列を返すことです。
配列が空でない場合は、さらに2つの場合に分けるためにまず <code>case</code>式を使用します。
配列の合計がゼロであれば、配列全体を返します。
そうでなければ、配列の残りに対して再帰します。</p>
<h2 id="パターン照合の失敗と部分関数"><a class="header" href="#パターン照合の失敗と部分関数">パターン照合の失敗と部分関数</a></h2>
<p>case式のパターンを順番に照合していって、
もし選択肢のいずれの場合も入力が適合しなかった時は何が起こるのでしょうか？
この場合、<strong>パターン照合失敗</strong>によって、case式は実行時に失敗します。</p>
<p>簡単な例でこの動作を見てみましょう。</p>
<pre><code class="language-haskell">import Partial.Unsafe (unsafePartial)

partialFunction :: Boolean -&gt; Boolean
partialFunction = unsafePartial \true -&gt; true
</code></pre>
<p>この関数は単一の場合しか含んでおらず、その場合では単一の入力である<code>true</code>にのみ照合します。
このファイルをコンパイルしてPSCiでそれ以外の値を与えてテストすると、実行時エラーが発生します。</p>
<pre><code class="language-text">&gt; partialFunction false

Failed pattern match
</code></pre>
<p>どんな入力の組み合わせに対しても値を返すような関数は<strong>全関数</strong> (total function) と呼ばれ、
そうでない関数は<strong>部分的</strong> (partial) であると呼ばれます。</p>
<p>一般的には、可能な限り全関数として定義したほうが良いと考えられています。
もし関数が何らかの妥当な入力の集合について結果を返さないことがわかっているなら、
大抵は失敗であることを示すことができる値を返すほうがよいでしょう。
例えば何らかの<code>a</code>についての型<code>Maybe a</code>で、妥当な結果を返せないときは<code>Nothing</code>を使います。
この方法なら、型安全な方法で値の有無を示すことができます。</p>
<p>PureScriptコンパイラは、
パターンマッチが不完全で関数が全関数ではないことを検出するとエラーを生成します。
部分関数が安全である場合、
<code>unsafePartial</code>関数を使ってこれらのエラーを抑制することができます。
（その部分関数が安全だと言い切れるなら！）
もし上記の <code>unsafePartial</code>関数の呼び出しを取り除くと、コンパイラは次のエラーを生成します。</p>
<pre><code class="language-text">A case expression could not be determined to cover all inputs.
The following additional cases are required to cover all inputs:

  false
</code></pre>
<p>これは値<code>false</code>が、定義されたどのパターンとも一致しないことを示しています。
一般的にこれらの警告には、複数の不一致のケースが含まれることがあります。</p>
<p>上記の型シグネチャも省略した場合は、次のようになります。</p>
<pre><code class="language-haskell">partialFunction true = true
</code></pre>
<p>このとき、PSCiは興味深い型を推論します｡</p>
<pre><code class="language-text">&gt; :type partialFunction

Partial =&gt; Boolean -&gt; Boolean
</code></pre>
<p>本書ではのちに<code>=&gt;</code>記号を含むいろいろな型を見ることになります（これらは<strong>型クラス</strong>に関連しています）。
しかし、今のところは、PureScriptは型システムを使って部分関数を追跡していることと、
安全な場合に型検証器に明示する必要があることを確認すれば十分です。</p>
<p>コンパイラは、定義されたパターンが<strong>冗長</strong>であることを検出した場合
（前の方に定義されたパターンに一致するケースのみ）でも警告を生成します。</p>
<pre><code class="language-haskell">redundantCase :: Boolean -&gt; Boolean
redundantCase true = true
redundantCase false = false
redundantCase false = false
</code></pre>
<p>このとき、最後のケースは冗長であると正しく検出されます。</p>
<pre><code class="language-text">A case expression contains unreachable cases:

  false
</code></pre>
<p><strong>注意</strong>：PSCiは警告を表示しないので、
この例を再現するには、この関数をファイルとして保存し、 <code>pulp build</code>を使ってコンパイルします。</p>
<h2 id="代数的データ型"><a class="header" href="#代数的データ型">代数的データ型</a></h2>
<p>この節では<strong>代数的データ型</strong> (algebraic data type, ADT) と呼ばれる、
PureScriptの型システムの機能を導入します。
この機能はパターン照合と地続きの関係があります。</p>
<p>しかしまずは切り口となる例について考えていきます。
この例では単純なベクターグラフィックスライブラリの実装というこの章の課題を解決する基礎を提供します。</p>
<p>直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとします。
オブジェクト指向言語では、おそらくインタフェースもしくは抽象クラス <code>Shape</code>を定義し、
使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。</p>
<p>しかしながら、この方針は大きな欠点をひとつ抱えています。
<code>Shape</code>を抽象的に扱うためには、実行したいと思う可能性のあるすべての操作を事前に把握し、
<code>Shape</code>インタフェースに定義する必要があるのです。
このため、モジュール性を壊さずに新しい操作を追加することが難しくなります。</p>
<p>もし図形の種類が事前にわかっているなら、
代数的データ型はこうした問題を解決する型安全な方法を提供します。
モジュール性のある方法で <code>Shape</code>に新たな操作を定義し、
型安全性が維持できます。</p>
<p>代数的データ型としてどのように<code>Shape</code>が表現されるかを次に示します。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String

type Point =
  { x :: Number
  , y :: Number
  }
</code></pre>
<p>この宣言では<code>Shape</code>をそれぞれの構築子の和として定義しており、
各構築子では含まれるデータを指定します。
<code>Shape</code>は、中央 <code>Point</code>と半径（数値）を持つ <code>Circle</code>か、
<code>Rectangle</code>、 <code>Line</code>、 <code>Text</code>のいずれかです。
他には <code>Shape</code>型の値を構築する方法はありません。</p>
<p>代数的データ型の定義はキーワード <code>data</code>から始まり、
それに新しい型の名前と任意個の型引数が続きます。
その型の構築子（あるいは<strong>データ構築子</strong> (data constructor)）は等号の後に定義され、
パイプ文字 (<code>|</code>) で区切られます。
ADTの構築子が持つデータは原始型に限りません。
構築子にはレコード、配列、また他のADTさえも含むことができます。</p>
<p>それではPureScriptの標準ライブラリから別の例を見てみましょう。
オプショナルな値を定義するのに使われる <code>Maybe</code>型を本書の冒頭で扱いました。
<code>maybe</code>パッケージでは <code>Maybe</code>を次のように定義しています。</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>この例では型引数 <code>a</code>の使用方法を示しています。
パイプ文字を「または」と読むことにすると、この定義は「<code>Maybe a</code>型の値は、無い (<code>Nothing</code>) か、またはただの (<code>Just</code>) 型
<code>a</code>の値だ」とほぼ英語のように読むことができます。</p>
<p>なおデータ定義のどこにも構文<code>forall a</code>を使っていません。
<code>forall</code>構文は関数には必須ですが、<code>data</code>によるADTや<code>type</code>での型別称を定義するときは使われません。</p>
<p>データ構築子は再帰的なデータ構造を定義するために使用することもできます。
更に例を挙げると、要素が型 <code>a</code>の単方向連結リストのデータ型を定義はこのようになります。</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
</code></pre>
<p>この例は <code>lists</code>パッケージから持ってきました。
ここで <code>Nil</code>構築子は空のリストを表しており、
<code>Cons</code>は先頭となる要素と尾鰭から空でないリストを作成するために使われます。
<code>Cons</code>の2つ目のフィールドでデータ型 <code>List a</code>を使用しており、
再帰的なデータ型になっていることに注目してください。</p>
<h2 id="adtの使用"><a class="header" href="#adtの使用">ADTの使用</a></h2>
<p>代数的データ型の構築子を使用して値を構築するのはとても簡単です。
対応する構築子に含まれるデータに応じた引数を用意し、
その構築子を単に関数のように適用するだけです。</p>
<p>例えば、上で定義した <code>Line</code>構築子は2つの <code>Point</code>を必要としていますので、
<code>Line</code>構築子を使って <code>Shape</code>を構築するには、
型 <code>Point</code>のふたつの引数を与えなければなりません。</p>
<pre><code class="language-haskell">exampleLine :: Shape
exampleLine = Line p1 p2
  where
    p1 :: Point
    p1 = { x: 0.0, y: 0.0 }

    p2 :: Point
    p2 = { x: 100.0, y: 50.0 }
</code></pre>
<p>さて、代数的データ型で値を構築することは簡単ですが、
これをどうやって使ったらよいのでしょうか？
ここで代数的データ型とパターン照合との重要な接点が見えてきます。
代数的データ型の値を消費する唯一の方法は構築子に照合するパターンを使うことです。</p>
<p>例を見てみましょう。
<code>Shape</code>を <code>String</code>に変換したいとします。
<code>Shape</code>を構築するのにどの構築子が使用されたかを調べるには、
パターン照合を使用しなければなりません。
これには次のようにします。</p>
<pre><code class="language-haskell">showShape :: Shape -&gt; String
showShape (Circle c r) =
  &quot;Circle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, radius: &quot; &lt;&gt; show r &lt;&gt; &quot;]&quot;
showShape (Rectangle c w h) =
  &quot;Rectangle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, width: &quot; &lt;&gt; show w &lt;&gt; &quot;, height: &quot; &lt;&gt; show h &lt;&gt; &quot;]&quot;
showShape (Line start end) =
  &quot;Line [start: &quot; &lt;&gt; showPoint start &lt;&gt; &quot;, end: &quot; &lt;&gt; showPoint end &lt;&gt; &quot;]&quot;
showShape (Text loc text) =
  &quot;Text [location: &quot; &lt;&gt; showPoint loc &lt;&gt; &quot;, text: &quot; &lt;&gt; show text &lt;&gt; &quot;]&quot;

showPoint :: Point -&gt; String
showPoint { x, y } =
  &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot;, &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>各構築子はパターンとして使用することができ、
構築子への引数はそのパターンで束縛することができます。
<code>showShape</code>の最初の場合を考えてみましょう。
もし <code>Shape</code>が <code>Circle</code>構築子適合した場合、
2つの変数パターン <code>c</code>と <code>r</code>を使って
<code>Circle</code>の引数（中心と半径）がスコープに導入されます。
その他の場合も同様です。</p>
<h2 id="演習-10"><a class="header" href="#演習-10">演習</a></h2>
<ol>
<li>（簡単）<code>Circle</code>（型は<code>Shape</code>）を構築する関数<code>circleAtOrigin</code>を書いてください。
中心は原点にあり、半径は<code>10.0</code>です。</li>
<li>（普通）<code>Shape</code>を、原点を中心として<code>2.0</code>倍に拡大する関数<code>doubleScaleAndCenter</code>を書いてみましょう。</li>
<li>（普通）<code>Shape</code>からテキストを抽出する関数<code>shapeText</code>を書いてください。
この関数は<code>Maybe String</code>を返しますが、もし入力が<code>Text</code>を使用して構築されたのでなければ、返り値には<code>Nothing</code>構築子を使ってください。</li>
</ol>
<h2 id="newtype"><a class="header" href="#newtype">Newtype</a></h2>
<p>代数的データ型の特別な場合として、<strong>newtype</strong>と呼ばれるものがあります。
newtypeはキーワード <code>data</code>の代わりにキーワード <code>newtype</code>を使用して導入します。</p>
<p>newtype宣言では<strong>過不足なくひとつだけの</strong>構築子を定義しなければならず、
その構築子は<strong>過不足なくひとつだけの</strong>引数を取る必要があります。
つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。
実際、newtypeの値は、元の型と同じ実行時表現を持ってるので、実行時性能のオーバーヘッドがありません。
しかし、これらは型システムの観点から区別されます。
これは型安全性の追加の層を提供するのです。</p>
<p>例として、ボルト、アンペア、オームのような単位を表現するために、
<code>Number</code>の型レベルの別名を定義したくなる場合があるかもしれません。</p>
<pre><code class="language-haskell">newtype Volt = Volt Number
newtype Ohm = Ohm Number
newtype Amp = Amp Number
</code></pre>
<p>それからこれらの型を使う関数と値を定義します。</p>
<pre><code class="language-haskell">calculateCurrent :: Volt -&gt; Ohm -&gt; Amp
calculateCurrent (Volt v) (Ohm r) = Amp (v / r)

battery :: Volt
battery = Volt 1.5

lightbulb :: Ohm
lightbulb = Ohm 500.0

current :: Amp
current = calculateCurrent battery lightbulb
</code></pre>
<p>これによりつまらないミスを防ぐことができます。
例えば電源<strong>なし</strong>に<strong>2つ</strong>の電球により生み出される電流を計算しようとするなどです。</p>
<pre><code class="language-haskell">current :: Amp
current = calculateCurrent lightbulb lightbulb
{-
TypesDoNotUnify:
  current = calculateCurrent lightbulb lightbulb
                             ^^^^^^^^^
  Could not match type
    Ohm
  with type
    Volt
-}
</code></pre>
<p>もし<code>newtype</code>なしに単に<code>Numebr</code>を使っていたら、コンパイラはこのミスを補足できません。</p>
<pre><code class="language-haskell">-- これもコンパイルできますが、型安全ではありません。
calculateCurrent :: Number -&gt; Number -&gt; Number
calculateCurrent v r = v / r

battery :: Number
battery = 1.5

lightbulb :: Number
lightbulb = 500.0

current :: Number
current = calculateCurrent lightbulb lightbulb -- 補足されないミス
</code></pre>
<p>なお、newtypeは単一の構築子しかとれず、構築子は単一の値でなくてはなりませんが、
newtypeは任意の数の型変数を取ることが<strong>できます</strong>。
例えば以下のnewtypeは妥当な定義です（<code>err</code>と<code>a</code>は型変数で、<code>CouldError</code>構築子は型<code>Either err a</code>の<strong>単一</strong>の値を期待します）。</p>
<pre><code class="language-Haskell">newtype CouldError err a = CouldError (Either err a)
</code></pre>
<p>また、newtypeの構築子はよくnewtype自身と同じ名前を持つことがあることにも注意してください。
ただこれは必須ではありません。
例えば固有の名前であっても妥当です。</p>
<pre><code class="language-haskell">newtype Coulomb = MakeCoulomb Number
</code></pre>
<p>この場合<code>Coulomb</code>は<strong>型構築子</strong>（引数はゼロ）で<code>MakeCoulomb</code>は<strong>データ構築子</strong>です。
これらの構築子は異なる名前空間に属しており、<code>Volt</code>の例でそうだったように、名前に一意性があります。
これは全てのADTについて言えることです。
なお、型構築子とデータ構築子は異なる名前を持つことができますが、
実際には同じ名前を共有するのが普通です。
上の<code>Amp</code>と<code>Volt</code>の場合がこれです。</p>
<p>newtypeの別の応用は、実行時表現を変えることなく、既存の型に異なる<strong>振舞い</strong>を付加することです。
その利用例については次章で<strong>型クラス</strong>をお話しするときに押さえます。</p>
<h2 id="演習-11"><a class="header" href="#演習-11">演習</a></h2>
<ol>
<li>（簡単）<code>Watt</code>を<code>Number</code>の<code>newtype</code>として定義してください。
それからこの新しい<code>Watt</code>型と上の<code>Amp</code>と<code>Volt</code>の定義を使って<code>calculateWattage</code>関数を定義してください。</li>
</ol>
<pre><code class="language-haskell">calculateWattage :: Amp -&gt; Volt -&gt; Watt
</code></pre>
<p><code>Watt</code>中のワット数は与えられた<code>Amp</code>中の電流と与えられた<code>Volt</code>の電圧の積で計算できます。</p>
<h2 id="ベクターグラフィックスライブラリ"><a class="header" href="#ベクターグラフィックスライブラリ">ベクターグラフィックスライブラリ</a></h2>
<p>これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライブラリを作成していきましょう。</p>
<p>ただの <code>Shape</code>の配列であるような、 <code>Picture</code>という型同義語を定義しておきます。</p>
<pre><code class="language-haskell">type Picture = Array Shape
</code></pre>
<p>デバッグしていると <code>Picture</code>を <code>String</code>として表示できるようにしたくなることもあるでしょう。
これはパターン照合を使用して定義された <code>showPicture</code>関数で行うことができます。</p>
<pre><code class="language-haskell">showPicture :: Picture -&gt; Array String
showPicture = map showShape
</code></pre>
<p>試してみましょう。
モジュールを <code>spago build</code>でコンパイルし、 <code>spago repl</code>でPSCiを開きます。</p>
<pre><code class="language-text">$ spago build
$ spago repl

&gt; import Data.Picture

&gt; showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]

[&quot;Line [start: (0.0, 0.0), end: (1.0, 1.0)]&quot;]
</code></pre>
<h2 id="外接矩形の算出"><a class="header" href="#外接矩形の算出">外接矩形の算出</a></h2>
<p>このモジュールのコード例には、 <code>Picture</code>の最小外接矩形を計算する関数 <code>bounds</code>が含まれています。</p>
<p><code>Bounds</code>型は外接矩形を定義します。</p>
<pre><code class="language-haskell">type Bounds =
  { top    :: Number
  , left   :: Number
  , bottom :: Number
  , right  :: Number
  }
</code></pre>
<p><code>Picture</code>内の <code>Shape</code>の配列を走査し、最小の外接矩形を累積するため、
<code>bounds</code>は <code>Data.Foldable</code>の <code>foldl</code>関数を使用しています。</p>
<pre><code class="language-haskell">bounds :: Picture -&gt; Bounds
bounds = foldl combine emptyBounds
  where
  combine :: Bounds -&gt; Shape -&gt; Bounds
  combine b shape = union (shapeBounds shape) b
</code></pre>
<p>基底の場合では、空の <code>Picture</code>の最小外接矩形を求める必要がありますが、
<code>emptyBounds</code>で定義される空の外接矩形がその条件を満たしています。</p>
<p>累積関数 <code>combine</code>は <code>where</code>ブロックで定義されています。
<code>combine</code>は <code>foldl</code>の再帰呼び出しで計算された外接矩形と、
配列内の次の <code>Shape</code>を引数にとり、
ユーザ定義の演算子 <code>union</code>を使ってふたつの外接矩形の和を計算しています。
<code>shapeBounds</code>関数は、パターン照合を使用して、単一の図形の外接矩形を計算します。</p>
<h2 id="演習-12"><a class="header" href="#演習-12">演習</a></h2>
<ol>
<li>（普通）ベクターグラフィックライブラリを拡張し、<code>Shape</code>の面積を計算する新しい操作 <code>area</code>を追加してください。
この演習では、テキストの面積は0であるものとしてください。</li>
<li>（難しい）<code>Shape</code>を拡張し、新しいデータ構築子 <code>Clipped</code>を追加してください。
<code>Clipped</code>は他の <code>Picture</code>を矩形に切り抜きます。
切り抜いてきた<code>Picture</code>の境界を計算できるよう、<code>shapeBounds</code>関数を拡張してください。
なお、これにより<code>Shape</code>は再帰的なデータ型になります。</li>
</ol>
<h2 id="まとめ-3"><a class="header" href="#まとめ-3">まとめ</a></h2>
<p>この章では、関数型プログラミングから基本だが強力なテクニックであるパターン照合を扱いました。
複雑なデータ構造の部分と照合するために、
簡単なパターンの使い方だけではなく、
配列パターンやレコードパターンを使った深いデータ構造の一部の照合方法を見てきました。</p>
<p>またこの章では、パターン照合に密接に関連する代数的データ型を紹介しました。
代数的データ型のおかげでデータ構造を簡潔に記述することができ、
新たな操作でデータ型を拡張するためのモジュール性のある方法が提供されることを見てきました。</p>
<p>最後に強力な抽象化である<strong>行多相</strong>を扱いました。
これにより多くの既存のJavaScript関数に型を与えられます。</p>
<p>本書では今後も代数的データ型とパターン照合をいろんなところで使用するので、
今のうちにこれらに習熟しておくと後で実を結ぶことでしょう。
これ以外にも独自の代数的データ型を作成し、
パターン照合を使用してそれらを使う関数を書くことを試してみてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型クラス"><a class="header" href="#型クラス">型クラス</a></h1>
<h2 id="この章の目標-4"><a class="header" href="#この章の目標-4">この章の目標</a></h2>
<p>この章では、PureScriptの型システムによって可能になる強力な抽象化の手法である、型クラスを導入します。</p>
<p>この章ではデータ構造をハッシュするためのライブラリを題材に説明していきます。データ自身の構造について直接考えることなく複雑な構造のデータのハッシュ値を求めるために、型クラスの仕組みがどのようにして働くのかを見ていきます。</p>
<p>また、PureScriptのPreludeや標準ライブラリに含まれる、標準的な型クラスも見ていきます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大きく依存しているので、これらのクラスに慣れておくと役に立つでしょう。</p>
<p>オブジェクト指向の方面から入って来た方は、
「クラス」という単語がそれまで馴染みのあるものとこの文脈とでは
<strong>かなり</strong>異なるものを意味していることに注意してください。</p>
<h2 id="プロジェクトの準備-3"><a class="header" href="#プロジェクトの準備-3">プロジェクトの準備</a></h2>
<p>この章のソースコードは、ファイル <code>src/data/Hashable.purs</code>で定義されています。</p>
<p>このプロジェクトには以下の依存関係があります。</p>
<ul>
<li><code>maybe</code>: オプショナルな値を表す <code>Maybe</code>データ型が定義されています。</li>
<li><code>tuples</code>: 値の組を表す <code>Tuple</code>データ型が定義されています。</li>
<li><code>either</code>: 非交和を表す <code>Either</code>データ型が定義されています。</li>
<li><code>strings</code>: 文字列を操作する関数が定義されています。</li>
<li><code>functions</code>: PureScriptの記述用の補助関数が定義されています。</li>
</ul>
<p>モジュール <code>Data.Hashable</code>では、これらのパッケージによって提供されるモジュールのいくつかをインポートしています。</p>
<h2 id="見せてください"><a class="header" href="#見せてください">見せてください！</a></h2>
<p>型クラスの最初の簡単な例は、すでに何回か見たことがある関数で提供されています。
<code>show</code>は、何らかの値を取り、それを文字列として表示する関数です。</p>
<p><code>show</code>は <code>Prelude</code>モジュールの <code>Show</code>と呼ばれる型クラスで次のように定義されています。</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String
</code></pre>
<p>このコードでは、型変数 <code>a</code>でパラメータ化された、
<code>Show</code>という新しい<strong>型クラス</strong> (type class) を宣言しています。</p>
<p>型クラス<strong>インスタンス</strong>には、型クラスで定義された関数の、その型に特殊化された実装が含まれています。</p>
<p>例えば、Preludeにある <code>Boolean</code>値に対する <code>Show</code>型クラスインスタンスの定義は次の通りです。</p>
<pre><code class="language-haskell">instance showBoolean :: Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<p>このコードは <code>showBool​​ean</code>という名前の型クラスのインスタンスを宣言します。
PureScriptでは、生成されたJavaScriptの可読性を良くするために、型クラスインスタンスに名前をつけます。このとき、<strong><code>Boolean</code>型は
<code>Show</code>型クラスに属している</strong>といいます。</p>
<p>PSCiで、いろいろな型の値を<code>Show</code>型クラスを利用して表示してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; show true
&quot;true&quot;

&gt; show 1.0
&quot;1.0&quot;

&gt; show &quot;Hello World&quot;
&quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>この例ではさまざまなプリミティブ型の値を <code>show</code>しましたが、もっと複雑な型を持つ値を <code>show</code>することもできます。</p>
<pre><code class="language-text">&gt; import Data.Tuple

&gt; show (Tuple 1 true)
&quot;(Tuple 1 true)&quot;

&gt; import Data.Maybe

&gt; show (Just &quot;testing&quot;)
&quot;(Just \&quot;testing\&quot;)&quot;
</code></pre>
<p><code>show</code>の出力は、REPLに（あるいは<code>.purs</code>ファイルに）もう一度貼り付ければ、
表示されるものを再作成できるような文字列であるべきです。
以下では<code>logShow</code>を使っていますが、これは単に<code>show</code>と<code>log</code>を順に呼び出して、
引用符なしに文字列を表示するものです。
<code>unit</code>の表示は無視してください。
第8章で、<code>log</code>のような<code>Effect</code>を調べるときに押さえます。</p>
<pre><code class="language-text">&gt; import Effect.Console

&gt; logShow (Tuple 1 true)
(Tuple 1 true)
unit

&gt; logShow (Just &quot;testing&quot;)
(Just &quot;testing&quot;)
unit
</code></pre>
<p>型 <code>Data.Either</code>の値を表示しようとすると、興味深いエラーメッセージが表示されます。</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; show (Left 10)

The inferred type

    forall a. Show a =&gt; String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでの問題は <code>show</code>しようとしている型に対する <code>Show</code>インスタンスが存在しないということではなく、
PSCiがこの型を推論できなかったということです。
このエラーメッセージで<strong>未知の型</strong><code>a</code>と表示されているのがそれです。</p>
<p><code>::</code>演算子を使って式に対して型注釈を加えると、
PSCiが正しい型クラスインスタンスを選ぶことができるようになります。</p>
<pre><code class="language-text">&gt; show (Left 10 :: Either Int String)
&quot;(Left 10)&quot;
</code></pre>
<p><code>Show</code>インスタンスをまったく持っていない型もあります。
関数の型 <code>-&gt;</code>がその一例です。
<code>Int</code>から <code>Int</code>への関数を <code>show</code>しようとすると、
型検証器によってその通りのエラーメッセージが表示されます。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; show $ \n -&gt; n + 1

No type class instance was found for

  Data.Show.Show (Int -&gt; Int)
</code></pre>
<p>型クラスインスタンスは次の2つのうちいずれかの形で定義されます。
型クラスが定義されている同じモジュールで定義するか、
型クラスに「属して」いる型と同じモジュールで定義するかです。
これらとは別の場所で定義されるインスタンスは<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">「孤立インスタンス」</a>と呼ばれ、PureScriptコンパイラによって許されていません。
この章の演習のいくつかでは、
その型の型クラスインスタンスを定義できるように、
型の定義を自分の<code>MySolutions</code>モジュールに複製する必要があります。</p>
<h2 id="演習-13"><a class="header" href="#演習-13">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Show</code>インスタンスを<code>Point</code>に定義してください。
前の章の<code>showPoint</code>関数と同じ出力に一致するようにしてください。
<strong>補足</strong>：<code>Point</code>はここでは（<code>type</code>同義語ではなく）<code>newtype</code>です。
そのため<code>show</code>の仕方を変えられます。
こうでもしないとレコードへの既定の<code>Show</code>インスタンスから逃れられません。</p>
<pre><code class="language-haskell">newtype Point
  = Point
  { x :: Number
  , y :: Number
  }
</code></pre>
</li>
</ol>
<h2 id="よく見かける型クラス"><a class="header" href="#よく見かける型クラス">よく見かける型クラス</a></h2>
<p>この節では、Preludeや標準ライブラリで定義されている標準的な型クラスをいくつか見ていきましょう。
これらの型クラスはPureScript特有の抽象化の多くのよくあるパターンの基礎を形成しているため、
これらの関数の基本についてよく理解しておくことを強くお勧めします。</p>
<h3 id="eq-1"><a class="header" href="#eq-1">Eq</a></h3>
<p><code>Eq</code>型クラスは、2つの値が等しいかどうかを調べる<code>eq</code>関数を定義しています。
等値演算子 (<code>==</code>) は<code>eq</code>の別名にすぎません。</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>異なる型の2つの値を比較しても意味がありませんから、
いずれの演算子も2つの引数が同じ型を持つ必要があることに注意してください。</p>
<p>PSCiで <code>Eq</code>型クラスを試してみましょう。</p>
<pre><code class="language-text">&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true
</code></pre>
<h3 id="ord-1"><a class="header" href="#ord-1">Ord</a></h3>
<p><code>Ord</code>型クラスは順序付け可能な型に対して2つの値を比較する <code>compare</code>関数を定義します。
比較演算子 <code>&lt;</code>、 <code>&gt;</code>と、その仲間の厳密な比較ではない<code>&lt;=</code>、 <code>&gt;=</code>も、<code>compare</code>を使って定義されます。</p>
<pre><code class="language-haskell">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p><code>compare</code>関数は2つの値を比較して <code>Ordering</code>の3つの値のうちいずれかを返します。</p>
<ul>
<li><code>LT</code>- 最初の引数が2番目の値より小さいとき</li>
<li><code>EQ</code>- 最初の引数が2番目の値と等しい（または比較できない）とき</li>
<li><code>GT</code>- 最初の引数が2番目の値より大きいとき</li>
</ul>
<p>ここでも<code>compare</code>関数についてPSCiで試してみましょう。</p>
<pre><code class="language-text">&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT
</code></pre>
<h3 id="field-1"><a class="header" href="#field-1">Field</a></h3>
<p><code>Field</code>型クラスは加算、減算、乗算、除算などの数値演算子を使用可能な型を示します。
必要に応じて再利用できるように、これらの演算子を抽象化するわけです。</p>
<p><strong>注意</strong>：型クラス <code>Eq</code>や <code>Ord</code>のクラスとちょうど同じように、
<code>Field</code>型のクラスはPureScriptコンパイラで特別に扱われ、
<code>1 + 2 * 3</code>のような単純な式は単純なJavaScriptへと変換されます。
型クラスの実装に基いて呼び出される関数呼び出しとは対照的です。</p>
<pre><code class="language-haskell">class EuclideanRing a &lt;= Field a
</code></pre>
<p><code>Field</code>型クラスは、いくつかのより抽象的な<strong>上位クラス</strong> (Super Class) が組み合わさってできています。
これは、その型は<code>Field</code>型クラスの操作をすべてを提供しているわけではないが、
その一部を提供する、というように抽象的に説明することができます。
この型クラスは抽象的なすべてではないいくつかの数値演算子をサポートしています。
例えば、自然数の型は加算および乗算については閉じていますが、
減算については閉じていないため、
この型は<code>Semiring</code>クラス（これは<code>Num</code>の上位クラスです）のインスタンスですが、
<code>Ring</code>や<code>Field</code>のインスタンスではありません。</p>
<p>上位クラスについては、この章の後半で詳しく説明します。
しかし、すべての<a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">数値型クラスの階層</a>（<a href="https://harry.garrood.me/numeric-hierarchy-overview/">チートシート</a>）について述べるのはこの章の目的から外れています。
この内容に興味のある読者は<code>prelude</code>内の <code>Field</code>に関するドキュメントを参照してください。</p>
<h3 id="半群とモノイド"><a class="header" href="#半群とモノイド">半群とモノイド</a></h3>
<p><code>Semigroup</code>（半群）型クラスは、2つの値を連結する演算子 <code>append</code>を提供する型を示します。</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a
</code></pre>
<p>普通の文字列連結について文字列は半群をなし、同様に配列も半群をなします。
その他の標準的なインスタンスの幾つかは、 <code>prelude</code>パッケージで提供されています。</p>
<p>以前に見た <code>&lt;&gt;</code>連結演算子は、 <code>append</code>の別名として提供されています。</p>
<p>（<code>prelude</code>パッケージで提供されている）<code>Monoid</code>型クラスは、
<code>mempty</code>と呼ばれる空の値の概念で <code>Semigroup</code>型クラスを拡張します。</p>
<pre><code class="language-haskell">class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>ここでも文字列や配列はモノイドの簡単な例になっています。</p>
<p><code>Monoid</code>型クラスインスタンスでは、
「空」の値から始めて新たな値を合成していき、
その型で<strong>累積</strong>した結果を返すにはどうするかを記述する型クラスです。
例えば、畳み込みを使っていくつかのモノイドの値の配列を連結する関数を書くことができます。
PSCiで試すと次のようになります。</p>
<pre><code class="language-haskell">&gt; import Prelude
&gt; import Data.Monoid
&gt; import Data.Foldable

&gt; foldl append mempty [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&quot;Hello World&quot;

&gt; foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
</code></pre>
<p><code>prelude</code>パッケージにはモノイドと半群の多くの例を提供しており、
以降もこれらを本書で扱っていきます。</p>
<h3 id="foldable-1"><a class="header" href="#foldable-1">Foldable</a></h3>
<p><code>Monoid</code>型クラスは畳み込みの結果になるような型を示しますが、
<code>Foldable</code>型クラスは、畳み込みの元のデータとして使えるような型構築子を示しています。</p>
<p>また、 <code>Foldable</code>型クラスは、
配列や <code>Maybe</code>などのいくつかの標準的なコンテナのインスタンスを含む
<code>foldable-traversable</code>パッケージで提供されています。</p>
<p><code>Foldable</code>クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し複雑です。</p>
<pre><code class="language-haskell">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p>この定義は <code>f</code>を配列の型構築子として特殊化して考えてみるとわかりやすくなります。
この場合、すべての <code>a</code>について <code>f a</code>を <code>Array a</code>に置き換える事ができますが、
<code>foldl</code>と <code>foldr</code>の型が、最初に見た配列に対する畳み込みの型になるとわかります。</p>
<p><code>foldMap</code>についてはどうでしょうか？
これは <code>forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Array a -&gt; m</code>になります。
この型シグネチャは、型 <code>m</code>が <code>Monoid</code>型クラスのインスタンスであれば
どんな型でも返り値の型として選ぶことができると言っています。
配列の要素をそのモノイドの値へと変換する関数を提供すれば、
そのモノイドの構造を利用して配列を畳み込み、ひとつの値にして返すことができます。</p>
<p>それではPSCiで <code>foldMap</code>を試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;
</code></pre>
<p>ここでは繋ぎ合わせるためのモノイドとして文字列を、
そして<code>Int</code>を文字列として表示する <code>show</code>関数を選びました。
それから、数の配列を渡すと、それぞれの数を <code>show</code>してひとつの文字列へと連結した結果が出力されました。</p>
<p>しかし畳み込み可能な型は配列だけではありません。
<code>foldable-traversable</code>では <code>Maybe</code>や <code>Tuple</code>のような型の <code>Foldable</code>インスタンスが定義されており、
<code>lists</code>のような他のライブラリでは、
そのライブラリのそれぞれのデータ型に対して <code>Foldable</code>インスタンスが定義されています。
<code>Foldable</code>は<strong>順序付きコンテナ</strong> (ordered container) の概念を捉えたものなのです。</p>
<h3 id="関手と型クラス則"><a class="header" href="#関手と型クラス則">関手と型クラス則</a></h3>
<p>PureScriptで副作用を伴う関数型プログラミングのスタイルを可能にするための
<code>Functor</code>と <code>Applicative</code>、 <code>Monad</code>といった型クラスがPreludeでは定義されています。
これらの抽象については本書で後ほど扱いますが、
まずは<code>map</code>関数の形ですでに見てきた <code>Functor</code>型クラスの定義を見てみましょう。</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>map</code>関数（別名<code>&lt;$&gt;</code>）は関数をそのデータ構造まで「持ち上げる」(lift) ことができます。
ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、
すでにいくつかの単純な型についてその動作を見てきました。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; map (\n -&gt; n &lt; 3) [1, 2, 3, 4, 5]
[true, true, false, false, false]

&gt; import Data.Maybe
&gt; import Data.String (length)

&gt; map length (Just &quot;testing&quot;)
(Just 7)
</code></pre>
<p><code>map</code>演算子は様々な構造の上でそれぞれ異なる振る舞いをしますが、 <code>map</code>演算子の意味はどのように理解すればいいのでしょうか。</p>
<p>直感的には、 <code>map</code>演算子はコンテナのそれぞれの要素へ関数を適用し、
その結果から元のデータと同じ形状を持った新しいコンテナを構築するものとできます。
しかし、この着想を精密にするにはどうしたらいいでしょうか？</p>
<p><code>Functor</code>の型クラスのインスタンスは、
<strong>関手則</strong> (functor laws) と呼ばれる法則を順守するものと期待されています。</p>
<ul>
<li><code>map identity xs = xs</code></li>
<li><code>map g (map f xs) = map (g &lt;&lt;&lt; f) xs</code></li>
</ul>
<p>最初の法則は<strong>恒等射律</strong> (identity law) です。
これは、恒等関数（引数を変えずに返す関数）をその構造まで持ち上げると、
元の構造をそのまま返すという意味です。
恒等関数は入力を変更しませんから、これは理にかなっています。</p>
<p>第二の法則は<strong>合成律</strong> (composition law) です。
構造をひとつの関数で写してから2つめの関数で写すのは、
2つの関数の合成で構造を写すのと同じだ、と言っています。</p>
<p>「持ち上げ」の一般的な意味が何であれ、
データ構造に対する持ち上げ関数の正しい定義はこれらの法則に従っていなければなりません。</p>
<p>標準の型クラスの多くには、
このような法則が付随しています。
一般に、型クラスに与えられた法則は、
型クラスの関数に構造を与え、
普遍的にインスタンスについて調べられるようにします。
興味のある読者は、すでに見てきた標準の型クラスに属する法則について調べてみてもよいでしょう。</p>
<h3 id="インスタンスの導出"><a class="header" href="#インスタンスの導出">インスタンスの導出</a></h3>
<p>インスタンスを手作業で描く代わりに、ほとんどの作業をコンパイラにさせることができます。
この<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出手引き</a>を見てください。
そちらの情報が以下の演習を解く手助けになることでしょう。</p>
<h2 id="演習-14"><a class="header" href="#演習-14">演習</a></h2>
<p>（簡単）次のnewtypeは複素数を表します。</p>
<pre><code class="language-haskell">newtype Complex
  = Complex
  { real :: Number
  , imaginary :: Number
  }
</code></pre>
<ol>
<li>
<p>（簡単）<code>Complex</code>に<code>Show</code>インスタンスを定義してください。
出力の形式はテストで期待される形式と一致させてください（例：<code>1.2+3.4i</code>、<code>5.6-7.7i</code>など）。</p>
</li>
<li>
<p>（簡単）<code>Eq</code>インスタンスを<code>Complex</code>に導出してください。
<strong>補足</strong>：代わりにこのインスタンスを手作業で書いてもよいですが、しなくていいのになぜするのですか？</p>
</li>
<li>
<p>（普通）<code>Semiring</code>インタンスを<code>Complex</code>に定義してください。
<strong>補足</strong>：<a href="https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype"><code>Data.Newtype</code></a>の<code>wrap</code>と<code>over2</code>を使ってより簡潔な解法をつくることができます。
もしそうするのでしたら、<code>Data.Newtype</code>から<code>class Newtype</code>をインポートしたり、
<code>Newtype</code>インスタンスを<code>Complex</code>に導出したりする必要も出てくるでしょう。</p>
</li>
<li>
<p>（簡単）（<code>newtype</code>を介して）<code>Ring</code>インスタンスを<code>Complex</code>に導出してください。
<strong>補足</strong>：代わりにこのインスタンスを手作業で書くこともできますが、
そう手軽にはできません。</p>
<p>以下は前章からの<code>Shape</code>のADTです。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String
</code></pre>
</li>
<li>
<p>（普通）（<code>Generic</code>を介して）<code>Show</code>インスタンスを<code>Shape</code>に導出してください。
コードの量はどのくらいになりましたか？
また、前の章の<code>showShape</code>と比較して<code>String</code>の出力はどうなりましたか？
<strong>ヒント</strong>：<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出</a>手引きの<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic"><code>Generic</code>から導出する</a>節を見てください。</p>
</li>
</ol>
<h2 id="型クラス制約"><a class="header" href="#型クラス制約">型クラス制約</a></h2>
<p>型クラスを使うと、関数の型に制約を加えることができます。
例を示しましょう。
<code>Eq</code>型クラスのインスタンスで定義された等値性を使って、3つの値が等しいかどうかを調べる関数を書きたいとします。</p>
<pre><code class="language-haskell">threeAreEqual :: forall a. Eq a =&gt; a -&gt; a -&gt; a -&gt; Boolean
threeAreEqual a1 a2 a3 = a1 == a2 &amp;&amp; a2 == a3
</code></pre>
<p>この型宣言は <code>forall</code>を使って定義された通常の多相型のようにも見えます。
しかし、二重線矢印 <code>=&gt;</code>で型の残りの部分から区切られた、型クラス制約 (type class constraint) <code>Eq a</code>があります。</p>
<p>インポートされたモジュールのどれかに <code>a</code>に対する <code>Eq</code>インスタンスが存在するなら、
どんな型 <code>a</code>を選んでも <code>threeAsEqual</code>を呼び出すことができる、とこの型は言っています。</p>
<p>制約された型には複数の型クラスインスタンスを含めることができますし、インスタンスの型は単純な型変数に限定されません。 <code>Ord</code>と
<code>Show</code>のインスタンスを使って2つの値を比較する例を次に示します。</p>
<pre><code class="language-haskell">showCompare :: forall a. Ord a =&gt; Show a =&gt; a -&gt; a -&gt; String
showCompare a1 a2 | a1 &lt; a2 =
  show a1 &lt;&gt; &quot; is less than &quot; &lt;&gt; show a2
showCompare a1 a2 | a1 &gt; a2 =
  show a1 &lt;&gt; &quot; is greater than &quot; &lt;&gt; show a2
showCompare a1 a2 =
  show a1 &lt;&gt; &quot; is equal to &quot; &lt;&gt; show a2
</code></pre>
<p><code>=&gt;</code>シンボルを複数回使って複数の制約を指定できることに注意してください。
複数の引数のカリー化された関数を定義するのと同様です。
しかし、2つの記号を混同しないように注意してください。</p>
<ul>
<li><code>a -&gt; b</code>は<strong>型</strong><code>a</code>から<strong>型</strong><code>b</code>への関数の型を表します。</li>
<li>一方で、<code>a =&gt; b</code>は<strong>制約</strong><code>a</code>を型<code>b</code>に適用します。</li>
</ul>
<p>PureScriptコンパイラは、型の注釈が提供されていない場合、制約付き型を推測しようとします。
これは、関数に対して可能な最も一般的な型を使用したい場合に便利です。</p>
<p>PSCiで <code>Semiring</code>のような標準の型クラスのいずれかを使って、このことを試してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; :type \x -&gt; x + x
forall a. Semiring a =&gt; a -&gt; a
</code></pre>
<p>ここで、この関数には<code>Int -&gt; Int</code>または<code>Number -&gt; Number</code>と注釈を付けることが考えられますが、
最も一般的な型が<code>Semiring</code>で動作するため、
PSCiでは<code>Int</code>と <code>Number</code>の両方で関数を実行させることができます。</p>
<h2 id="インスタンスの依存関係"><a class="header" href="#インスタンスの依存関係">インスタンスの依存関係</a></h2>
<p>制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、
型クラスインスタンスの実装は他の型クラスインスタンスに依存することができます。
これにより、型を使ってプログラムの実装を推論するという、プログラム推論の強力な形式を提供します。</p>
<p><code>Show</code>型クラスを例に考えてみましょう。
それぞれの要素を <code>show</code>する方法がある限り、
その要素の配列を <code>show</code>する型クラスインスタンスを書くことができます。</p>
<pre><code class="language-haskell">instance showArray :: Show a =&gt; Show (Array a) where
  ...
</code></pre>
<p>型クラスインスタンスが複数の他のインスタンスに依存する場合、
括弧で囲んでそれらのインスタンスをコンマで区切り、
それを<code>=&gt;</code>シンボルの左側に置く必要があります。</p>
<pre><code class="language-haskell">instance showEither :: (Show a, Show b) =&gt; Show (Either a b) where
  ...
</code></pre>
<p>これらの2つの型クラスインスタンスは <code>prelude</code>ライブラリにあります。</p>
<p>プログラムがコンパイルされると、
<code>Show</code>の正しい型クラスのインスタンスは <code>show</code>の引数の推論された型に基づいて選ばれます。
選択されたインスタンスが沢山のそうしたインスタンスの関係に依存しているかもしれませんが、
このあたりの複雑さに開発者が関与することはありません。</p>
<h2 id="演習-15"><a class="header" href="#演習-15">演習</a></h2>
<ol>
<li>
<p>（簡単）以下の宣言では型 <code>a</code>の要素の空でない配列の型を定義しています。</p>
<pre><code class="language-haskell">data NonEmpty a = NonEmpty a (Array a)
</code></pre>
<p><code>Eq a</code>と<code>Eq (Array a)</code>へのインスタンスを再利用し、型<code>NonEmpty</code>に<code>Eq</code>インスタンスを書いてください。<strong>補足</strong>：代わりに<code>Eq</code>インスタンスは導出することもできます。</p>
</li>
<li>
<p>（普通）<code>Array</code>への<code>Semigroup</code>インスタンスを再利用して、<code>NonEmpty</code>への<code>Semigroup</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>NonEmpty</code>に<code>Functor</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>Ord</code>のインスタンス付きのあらゆる型<code>a</code>が与えられているとすると、新しくそれ以外のどんな値よりも大きい「無限の」値を付け加えられます。</p>
<pre><code class="language-haskell">data Extended a = Infinite | Finite a 
</code></pre>
<p><code>a</code>への<code>Ord</code>インスタンスを再利用して、<code>Extended a</code>に<code>Ord</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（難しい）<code>NonEmpty</code>に<code>Foldable</code>インスタンスを書いてください。
<strong>ヒント</strong>：配列への<code>Foldable</code>インスタンスを再利用してください。</p>
</li>
<li>
<p>（難しい）順序付きコンテナを定義する（そして <code>Foldable</code>のインスタンスを持っている）ような型構築子
<code>f</code>が与えられたとき、追加の要素を先頭に含めるような新たなコンテナ型を作ることができます。</p>
<pre><code class="language-haskell">data OneMore f a = OneMore a (f a)
</code></pre>
<p>このコンテナ <code>OneMore f</code>もまた順序を持っています。
ここで、新しい要素は任意の <code>f</code>の要素よりも前にきます。
この <code>OneMore f</code>の <code>Foldable</code>インスタンスを書いてみましょう。</p>
<pre><code class="language-haskell">instance foldableOneMore :: Foldable f =&gt; Foldable (OneMore f) where
  ...
</code></pre>
</li>
<li>
<p>（普通）<code>nubEq</code>関数を使い、
配列から重複する<code>Shape</code>を削除する
<code>dedupShapes :: Array Shape -&gt; Array Shape</code>関数を書いてください。</p>
</li>
<li>
<p>（普通）<code>dedupShapesFast</code>関数を書いてください。
<code>dedupShapes</code>とほぼ同じですが、より効率の良い<code>nub</code>関数を使います。</p>
</li>
</ol>
<h2 id="多変数型クラス"><a class="header" href="#多変数型クラス">多変数型クラス</a></h2>
<p>型クラスは必ずしもひとつの型だけを型変数としてとるわけではありません。
型変数がひとつだけなのが最も一般的ですが、
実際には型クラスは<strong>ゼロ個以上の</strong>型変数を持つことができます。</p>
<p>それでは2つの型引数を持つ型クラスの例を見てみましょう。</p>
<pre><code class="language-haskell">module Stream where

import Data.Array as Array
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String

class Stream stream element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }

instance streamArray :: Stream (Array a) a where
  uncons = Array.uncons

instance streamString :: Stream String Char where
  uncons = String.uncons
</code></pre>
<p>この <code>Stream</code>モジュールでは、
要素のストリームのような型を示すクラス <code>Stream</code>が定義されています。
<code>uncons</code>関数を使ってストリームの先頭から要素を取り出すことができます。</p>
<p><code>Stream</code>型クラスは、
ストリーム自身の型だけでなくその要素の型も型変数として持っていることに注意してください。
これによって、ストリームの型が同じでも要素の型について異なる型クラスインスタンスを定義することができます。</p>
<p>このモジュールでは2つの型クラスインスタンスが定義されています。
<code>uncons</code>がパターン照合で配列の先頭の要素を取り除くような配列のインスタンスと、
文字列から最初の文字を取り除くような文字列のインスタンスです。</p>
<p>任意のストリーム上で動作する関数を記述することができます。
例えば、ストリームの要素に基づいて <code>Monoid</code>に結果を累積する関数は次のようになります。</p>
<pre><code class="language-haskell">import Prelude
import Data.Monoid (class Monoid, mempty)

foldStream :: forall l e m. Stream l e =&gt; Monoid m =&gt; (e -&gt; m) -&gt; l -&gt; m
foldStream f list =
  case uncons list of
    Nothing -&gt; mempty
    Just cons -&gt; f cons.head &lt;&gt; foldStream f cons.tail
</code></pre>
<p>PSCiで使って、異なる <code>Stream</code>の型や異なる <code>Monoid</code>の型について <code>foldStream</code>を呼び出してみましょう。</p>
<h2 id="関数従属性"><a class="header" href="#関数従属性">関数従属性</a></h2>
<p>多変数型クラスは非常に便利ですが、
混乱しやすい型や型推論の問題にもつながります。
簡単な例として、上記の <code>Stream</code>クラスを使って汎用的な<code>tail</code>関数をストリームに書くことを考えてみましょう。</p>
<pre><code class="language-haskell">genericTail xs = map _.tail (uncons xs)
</code></pre>
<p>これはやや複雑なエラーメッセージを出力します。</p>
<pre><code class="language-text">The inferred type

  forall stream a. Stream stream a =&gt; stream -&gt; Maybe stream

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>エラーは、 <code>genericTail</code>関数が <code>Stream</code>型クラスの定義で言及された <code>element</code>型を使用しないので、
その型は未解決のままであることを指しています。</p>
<p>さらに、特定の型のストリームに <code>genericTail</code>を適用することができません。</p>
<pre><code class="language-text">&gt; map _.tail (uncons &quot;testing&quot;)

The inferred type

  forall a. Stream String a =&gt; Maybe String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでは、コンパイラが <code>streamString</code>インスタンスを選択することを期待しています。
結局のところ、 <code>String</code>は <code>Char</code>のストリームであり、他の型のストリームであってはなりません。</p>
<p>コンパイラは自動的にその推論を行うことができず、
<code>streamString</code>インスタンスを割り当てることができません。
しかし、型クラス定義にヒントを追加すると、コンパイラを助けることができます。</p>
<pre><code class="language-haskell">class Stream stream element | stream -&gt; element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }
</code></pre>
<p>ここで、 <code>stream -&gt; element</code>は<strong>関数従属性</strong> (functional dependency) と呼ばれます。
関数従属性は、多変数型クラスの型引数間の関数関係を宣言します。
この関数の依存関係は、ストリーム型から（一意の）要素型への関数があることをコンパイラに伝えるので、
コンパイラがストリーム型を知っていれば要素の型を割り当てられます。</p>
<p>このヒントは、コンパイラが上記の汎用的な尾鰭関数の正しい型を推論するのに十分です。</p>
<pre><code class="language-text">&gt; :type genericTail
forall stream element. Stream stream element =&gt; stream -&gt; Maybe stream

&gt; genericTail &quot;testing&quot;
(Just &quot;esting&quot;)
</code></pre>
<p>多種の型のクラスを使用して何らかのAPIを設計する場合、関数従属性は非常に有用です。</p>
<h2 id="型変数のない型クラス"><a class="header" href="#型変数のない型クラス">型変数のない型クラス</a></h2>
<p>ゼロ個の型変数を持つ型クラスを定義することもできます！
これらは関数に対するコンパイル時のアサーションに対応しており、
型システム内のコードの大域的な性質を追跡することができます。</p>
<p>重要な一例として、前に部分関数についてお話しした際に見た<code>Partial</code>クラスがあります。
<code>Data.Array.Partial</code>に定義されている関数<code>head</code>と<code>tail</code>を例に取りましょう。
この関数は配列の先頭と尾鰭を<code>Maybe</code>に包むことなく取得することができます。
なので配列が空のときに失敗する可能性があります。</p>
<pre><code class="language-haskell">head :: forall a. Partial =&gt; Array a -&gt; a

tail :: forall a. Partial =&gt; Array a -&gt; Array a
</code></pre>
<p><code>Partial</code>モジュールの <code>Partial</code>型クラスのインスタンスを定義していないことに注意してください。
こうすると目的を達成できます。
このままの定義では <code>head</code>関数を使用しようとすると型エラーになるのです。</p>
<pre><code class="language-text">&gt; head [1, 2, 3]

No type class instance was found for

  Prim.Partial
</code></pre>
<p>代わりに、これらの部分関数を利用するすべての関数で <code>Partial</code>制約を再発行することができます。</p>
<pre><code class="language-haskell">secondElement :: forall a. Partial =&gt; Array a -&gt; a
secondElement xs = head (tail xs)
</code></pre>
<p>前章で見た <code>unsafePartial</code>関数を使用し、
部分関数を通常の関数（unsafely）として扱うことができます。
この関数は <code>Partial.Unsafe</code>モジュールで定義されています。</p>
<pre><code class="language-haskell">unsafePartial :: forall a. (Partial =&gt; a) -&gt; a
</code></pre>
<p><code>Partial</code>制約は関数の矢印の左側の括弧の中に現れますが、
外側の <code>forall</code>では現れません。
つまり、 <code>unsafePartial</code>は部分的な値から通常の値への関数です。</p>
<pre><code class="language-text">&gt; unsafePartial head [1, 2, 3]
1

&gt; unsafePartial secondElement [1, 2, 3]
2
</code></pre>
<h2 id="上位クラス"><a class="header" href="#上位クラス">上位クラス</a></h2>
<p>インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス間の関係を表現することができるように、
いわゆる<strong>上位クラス</strong> (superclass) を使って型クラス間の関係を表現することができます。</p>
<p>あるクラスのどんなインスタンスも、
別のクラスのインスタンスである必要があるとき、
後者の型クラスは前者の型クラスの上位クラスであるといい、
クラス定義で逆向きの太い矢印を使って上位クラス関係を示します。</p>
<p>すでに上位クラスの関係の例を見掛けています。
<code>Eq</code>クラスは <code>Ord</code>の上位クラスですし、<code>Semigroup</code>クラスは<code>Monoid</code>の上位クラスです。
<code>Ord</code>クラスのすべての型クラスインスタンスについて、
その同じ型に対応する <code>Eq</code>インスタンスが存在しなければなりません。
<code>compare</code>関数が2つの値が比較できないと報告した時は、
それらが実は同値であるかどうかを決定するために <code>Eq</code>クラスを使いたくなることが多いでしょうから、
これは理にかなっています。</p>
<p>一般に、下位クラスの法則が上位クラスのメンバに言及しているとき、
上位クラス関係を定義するのは理にかなっています。
例えば、 <code>Ord</code>と <code>Eq</code>のインスタンスのどんな組についても、
もしふたつの値が <code>Eq</code>インスタンスのもとで同値であるなら、
<code>compare</code>関数は <code>EQ</code>を返すはずだとみなすのは妥当です。
言い換えれば、まさしく<code>a == b</code>ならば <code>compare a b == EQ</code>です。
法則の階層上のこの関係は、 <code>Eq</code>と <code>Ord</code>の間の上位クラス関係を説明します。</p>
<p>上位クラス関係を定義する別の理由となるのは、
この2つのクラスの間に明らかに &quot;is-a&quot; の関係があることです。
下位クラスのすべてのメンバは、上位クラスのメンバでもあるということです。</p>
<h2 id="演習-16"><a class="header" href="#演習-16">演習</a></h2>
<ol>
<li>
<p>（普通）部分関数<code>unsafeMaximum :: Partial =&gt; Array Int -&gt; Int</code>を定義してください。
この関数は整数の空でない配列の最大値を求めます。
<code>unsafePartial</code>を使ってPSCiで関数をテストしてください。
<strong>ヒント</strong>：<code>Data.Foldable</code>の <code>maximum</code>関数を使います。</p>
</li>
<li>
<p>（普通）次の <code>Action</code>クラスは、ある型の別の型での動作 (action) を定義する、多変数型クラスです。</p>
<pre><code class="language-haskell">class Monoid m &lt;= Action m a where
  act :: m -&gt; a -&gt; a
</code></pre>
<p><strong>動作</strong>はどのようにモノイドな値を使って他の型の値を変更する方法を決められるのかを記述する関数です。
<code>Action</code>型クラスには2つの法則があります。</p>
<ul>
<li><code>act mempty a = a</code></li>
<li><code>act (m1 &lt;&gt; m2) a = act m1 (act m2 a)</code></li>
</ul>
<p>空の動作を提供しても何も起こりません。
そして2つの動作を連続で適用することは結合した動作を適用することと同じです。
つまり、動作は<code>Monoid</code>クラスで定義される操作に倣っています。</p>
<p>たとえば、自然数は乗算のもとでモノイドを形成します。</p>
<pre><code class="language-haskell">newtype Multiply = Multiply Int

instance semigroupMultiply :: Semigroup Multiply where
  append (Multiply n) (Multiply m) = Multiply (n * m)

instance monoidMultiply :: Monoid Multiply where
  mempty = Multiply 1
</code></pre>
<p>この動作を実装するインスタンスを書いてください。</p>
<pre><code class="language-haskell">instance actionMultiplyInt :: Action Multiply Int where
  ...
</code></pre>
<p>インスタンスが上で挙げた法則を見たさなくてはならないことを思い出してください。</p>
</li>
<li>
<p>（難しい）実は<code>Action Multiply Int</code>のインスタンスを実装するには複数の方法があります。
どれだけ思い付きますか？
PureScriptは同じインスタンスの複数の実装を許さないため、
元の実装を置き換える必要があります。
<strong>補足</strong>：テストでは4つの実装を押さえています。</p>
</li>
<li>
<p>（普通）入力の文字列を何回か繰り返す<code>Action</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">instance actionMultiplyString :: Action Multiply String where
  ...
</code></pre>
<p><strong>ヒント</strong>：Pursuitでシグネチャが<a href="https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String"><code>String -&gt; Int -&gt; String</code></a>のお助け関数を検索してください。
なお<code>String</code>は（<code>Monoid</code>のような）より汎用的な型として現れます。</p>
<p>このインスタンスは上に挙げた法則を満たすでしょうか。</p>
</li>
<li>
<p>（普通）インスタンス <code>Action m a =&gt; Action m (Array a)</code>を書いてみましょう。
ここで、 配列上の動作はそれぞれの要素を独立に実行するものとして定義されます。</p>
</li>
<li>
<p>（難しい）以下のnewtypeが与えらえているとき、
<code>Action m (Self m)</code>のインスタンスを書いてください。
ここでモノイド<code>m</code>は<code>append</code>を用いて自力で動作します。</p>
<pre><code class="language-haskell">newtype Self m = Self m
</code></pre>
<p><strong>補足</strong>：テストフレームワークでは<code>Self</code>と<code>Multiply</code>型に<code>Show</code>と<code>Eq</code>インスタンスが必要になります。
手作業でこれらのインスタンスを書いてもよいですし、
<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype"><code>derive newtype instance</code></a>と書くだけでコンパイラに取り仕切ってもらうこともできます。</p>
</li>
<li>
<p>（難しい）多変数型のクラス <code>Action</code>の引数は、何らかの関数従属性によって関連づけられるべきですか。
なぜそうすべき、あるいはそうすべきでないでしょうか？
<strong>補足</strong>：この演習にはテストがありません。</p>
</li>
</ol>
<h2 id="ハッシュの型クラス"><a class="header" href="#ハッシュの型クラス">ハッシュの型クラス</a></h2>
<p>この最後の節では、章の残りを使ってデータ構造をハッシュするライブラリを作ります。</p>
<p>このライブラリの目的は説明だけであり、
堅牢なハッシングの仕組みの提供を目的としていないことに注意してください。</p>
<p>ハッシュ関数に期待される性質とはどのようなものでしょうか？</p>
<ul>
<li>ハッシュ関数は決定的でなくてはなりません。つまり、同じ値には同じハッシュ
値を対応させなければなりません。</li>
<li>ハッシュ関数はいろいろなハッシュ値の集合で結果が一様に分布しなければな
りません。</li>
</ul>
<p>最初の性質はまさに型クラスの法則のように見える一方で、
2番目の性質はよりくだけた規約の条項のようなもので、
PureScriptの型システムによって確実に強制できるようなものではなさそうです。
しかし、これは型クラスについて次のような直感的理解を与えるはずです。</p>
<pre><code class="language-haskell">newtype HashCode = HashCode Int

instance hashCodeEq :: Eq HashCode where
  eq (HashCode a) (HashCode b) = a == b

hashCode :: Int -&gt; HashCode
hashCode h = HashCode (h `mod` 65535)

class Eq a &lt;= Hashable a where
  hash :: a -&gt; HashCode
</code></pre>
<p>これに、 <code>a == b</code>ならば <code>hash a == hash b</code>を示唆するという関係性の法則が付随しています。</p>
<p>この節の残りの部分を費やして、
<code>Hashable</code>型クラスに関連付けられているインスタンスと関数のライブラリを構築していきます。</p>
<p>決定的な方法でハッシュ値を結合する方法が必要になります。</p>
<pre><code class="language-haskell">combineHashes :: HashCode -&gt; HashCode -&gt; HashCode
combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)
</code></pre>
<p><code>combineHashes</code>関数は2つのハッシュ値を混ぜて結果を0-65535の間に分布します。</p>
<p>それでは、入力の種類を制限する <code>Hashable</code>制約を使う関数を書いてみましょう。
ハッシュ関数を必要とするよくある目的としては、
2つの値が同じハッシュ値にハッシュされるかどうかを決定することです。
<code>hashEqual</code>関係はそのような機能を提供します。</p>
<pre><code class="language-haskell">hashEqual :: forall a. Hashable a =&gt; a -&gt; a -&gt; Boolean
hashEqual = eq `on` hash
</code></pre>
<p>この関数はハッシュコードの等値性を利用したハッシュ同値性を定義するために
<code>Data.Function</code>の <code>on</code>関数を使っていますが、
これはハッシュ同値性の宣言的な定義として読めるはずです。
つまり、それぞれの値が <code>hash</code>関数に渡されたあとで2つの値が等しいなら、
それらの値は「ハッシュ同値」です。</p>
<p>原始型の <code>Hashable</code>インスタンスをいくつか書いてみましょう。
まずは整数のインスタンスです。
<code>HashCode</code>は実際には単なるラップされた整数なので、これは簡単です。
<code>hashCode</code>ヘルパー関数を使うことができます。</p>
<pre><code class="language-haskell">instance hashInt :: Hashable Int where
  hash = hashCode
</code></pre>
<p>パターン照合を使うと、<code>Boolean</code>値の単純なインスタンスを定義することもできます。</p>
<pre><code class="language-haskell">instance hashBoolean :: Hashable Boolean where
  hash false = hashCode 0
  hash true  = hashCode 1
</code></pre>
<p>整数のインスタンスでは、
<code>Data.Char</code>の <code>toCharCode</code>関数を使うと<code>Char</code>をハッシュするインスタンスを作成できます。</p>
<pre><code class="language-haskell">instance hashChar :: Hashable Char where
  hash = hash &lt;&lt;&lt; toCharCode
</code></pre>
<p>（要素型が <code>Hashable</code>のインスタンスでもあるならば）配列の要素に <code>hash</code>関数を <code>map</code>してから、
<code>combineHashes</code>関数を使って結果のハッシュを左側に畳み込むことで、
配列のインスタンスを定義します。</p>
<pre><code class="language-haskell">instance hashArray :: Hashable a =&gt; Hashable (Array a) where
  hash = foldl combineHashes (hashCode 0) &lt;&lt;&lt; map hash
</code></pre>
<p>すでに書いたものより単純なインスタンスを使用して、
新たなインスタンスを構築しているやり方に注目してください。
<code>String</code>を<code>Char</code>の配列に変換し、
この新たな<code>Array</code>インスタンスを使って<code>String</code>のインスタンスを定義しましょう。</p>
<pre><code class="language-haskell">instance hashString :: Hashable String where
  hash = hash &lt;&lt;&lt; toCharArray
</code></pre>
<p>これらの <code>Hashable</code>インスタンスが
先ほどの型クラスの法則を満たしていることを証明するにはどうしたらいいでしょうか。
同じ値が等しいハッシュ値を持っていることを確認する必要があります。
<code>Int</code>、 <code>Char</code>、 <code>String</code>、 <code>Boolean</code>の場合は、
<code>Eq</code>の意味では同じ値でも厳密には同じではない、
というような型の値は存在しないので簡単です。</p>
<p>もっと面白い型についてはどうでしょうか。
この場合、配列の長さに関する帰納を使うと、型クラスの法則を証明することができます。
長さゼロの唯一の配列は <code>[]</code>です。
配列の <code>Eq</code>の定義により、任意の2つの空でない配列は、それらの先頭の要素が同じで配列の残りの部分が等しいとき、またその時に限り等しくなります。
この帰納的な仮定により、配列の残りの部分は同じハッシュ値を持ちますし、もし <code>Hashable a</code>インスタンスがこの法則を満たすなら、先頭の要素も同じハッシュ値をもつことがわかります。
したがって、2つの配列は同じハッシュ値を持ち、<code>Hashable (Array a)</code>も同様に型クラス法則を満たしています。</p>
<p>この章のソースコードには、 <code>Maybe</code>と <code>Tuple</code>型のインスタンスなど、
他にも <code>Hashable</code>インスタンスの例が含まれています。</p>
<h2 id="演習-17"><a class="header" href="#演習-17">演習</a></h2>
<ol>
<li>
<p>（簡単）PSCiを使って、定義した各インスタンスのハッシュ関数をテストしてください。
<strong>補足</strong>：この演習には単体試験がありません。</p>
</li>
<li>
<p>（普通）ハッシュと値の同値性に基づいて配列が重複する要素を持っているかどうかを調べる関数<code>arrayHasDuplicates</code>を書いてください。
まずハッシュ同値性を<code>hashEqual</code>関数で確認し、
それからもし重複するハッシュの対が見付かったら<code>==</code>で値の同値性を確認してください。
<strong>ヒント</strong>：<code>Data.Array</code>の <code>nubByEq</code>関数はこの問題をずっと簡単にしてくれるでしょう。</p>
</li>
<li>
<p>（普通）型クラスの法則を満たす、次のnewtypeの <code>Hashable</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">newtype Hour = Hour Int

instance eqHour :: Eq Hour where
  eq (Hour n) (Hour m) = mod n 12 == mod m 12
</code></pre>
</li>
</ol>
<p>newtypeの <code>Hour</code>とその <code>Eq</code>インスタンスは、12を法とする整数の型を表します。
したがって、例えば1と13は等しいと見なされます。
そのインスタンスが型クラスの法則を満たしていることを証明してください。</p>
<ol>
<li>（難しい）<code>Maybe</code>、<code>Either</code>そして<code>Tuple</code>への<code>Hashable</code>インスタンスについて型クラスの法則を証明してください。
<strong>補足</strong>：この演習にテストはありません。</li>
</ol>
<h2 id="まとめ-4"><a class="header" href="#まとめ-4">まとめ</a></h2>
<p>この章では、型に基づく抽象化で、
コードの再利用のための強力な形式化を可能にする<strong>型クラス</strong>を導入しました。
PureScriptの標準ライブラリから標準の型クラスを幾つか見てきました。
また、ハッシュ値を計算する型クラスに基づく独自のライブラリを定義しました。</p>
<p>この章では型クラス法則の考え方も導入しましたが、
これは抽象化に型クラスを使うコードについての性質を証明する手法でした。
型クラス法則は<strong>等式推論</strong> (equational reasoning) と呼ばれる大きな分野の一部であり、
プログラミング言語の性質と型システムはプログラムについて論理的な推論をできるようにするために使われています。
これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話題となるでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アプリカティブによる検証"><a class="header" href="#アプリカティブによる検証">アプリカティブによる検証</a></h1>
<h2 id="この章の目標-5"><a class="header" href="#この章の目標-5">この章の目標</a></h2>
<p>この章では、
<code>Applicative</code>型クラスによって表現される<strong>アプリカティブ関手</strong> (applicative functor)
という重要な抽象化と新たに出会うことになります。
名前が難しそうに思えても心配しないでください。
フォームデータの検証という実用的な例を使ってこの概念の動機付けをします。
アプリカティブ関手を使うと、
通常であれば大量の決まり文句を伴うようなコードを、
簡潔で宣言的な記述へと変えることができるようになります。</p>
<p>また、<strong>巡回可能関手</strong> (traversable functor) を表現する<code>Traversable</code>という別の型クラスにも出会います。
現実の問題への解決策からこの概念が自然に生じるということがわかるでしょう。</p>
<p>この章では第3章に引き続き住所録を例として扱います。
今回は住所録のデータ型を拡張し、
これらの型の値を検証する関数を書きます。
これらの関数は、例えばデータ入力フォームの一部で、
使用者へエラーを表示するウェブユーザインタフェースで使われると考えてください。</p>
<h2 id="プロジェクトの準備-4"><a class="header" href="#プロジェクトの準備-4">プロジェクトの準備</a></h2>
<p>この章のソースコードは、ふたつのファイル<code>src/Data/AddressBook.purs</code>
および<code>src/Data/AddressBook/Validation.purs</code>で定義されています。</p>
<p>このプロジェクトは多くの依存関係を持っていますが、
その大半はすでに見てきたものです。
新しい依存関係は2つです。</p>
<ul>
<li><code>control</code> - <code>Applicative</code>のような、型クラスを使用して制御フローを抽象
化する関数が定義されています。</li>
<li><code>validation</code> - この章の主題である <strong>アプリカティブによる検証</strong> のため
の関手が定義されています。</li>
</ul>
<p><code>Data.AddressBook</code>モジュールには、
このプロジェクトのデータ型とそれらの型に対する<code>Show</code>インスタンスが定義されており、
<code>Data.AddressBook.Validation</code>モジュールにはそれらの型の検証規則が含まれています。</p>
<h2 id="関数適用の一般化"><a class="header" href="#関数適用の一般化">関数適用の一般化</a></h2>
<p><strong>アプリカティブ関手</strong>の概念を理解するために、
以前扱った型構築子<code>Maybe</code>について考えてみましょう。</p>
<p>このモジュールのソースコードでは、
次のような型を持つ<code>address</code>関数が定義されています。</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address
</code></pre>
<p>この関数は、通りの名前、市、州という3つの文字列から型<code>Address</code>の値を構築するために使います。</p>
<p>この関数は簡単に適用できますので、
PSCiでどうなるか見てみましょう。</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; address &quot;123 Fake St.&quot; &quot;Faketown&quot; &quot;CA&quot;
{ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>しかし、通り、市、州の3つ全てが必ずしも入力されないものとすると、3つの場合がそれぞれ省略可能であることを示すために<code>Maybe</code>型を使用したくなります。</p>
<p>考えられる場合としては、
市が省略されている場合があるでしょう。
もし<code>address</code>関数を直接適用しようとすると、
型検証器からエラーが表示されます。</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Could not match type

  Maybe String

with type

  String
</code></pre>
<p><code>address</code>は<code>Maybe String</code>型ではなく文字列型の引数を取るので、
もちろんこれは期待通り型エラーになります。</p>
<p>しかし、もし<code>address</code>関数を「持ち上げる」ことができれば、
<code>Maybe</code>型で示される省略可能な値を扱うことができるはずだと期待することは理にかなっています。
実際にそれは可能で、
<code>Control.Apply</code>で提供されている関数<code>lift3</code>が、まさに求めているものです。</p>
<pre><code class="language-text">&gt; import Control.Apply
&gt; lift3 address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Nothing
</code></pre>
<p>このとき、引数のひとつ（市）が欠落していたので、
結果は<code>Nothing</code>になります。
もし3つの引数すべてが<code>Just</code>構築子を使って与えられれば、
結果は値を含むことになります。</p>
<pre><code class="language-text">&gt; lift3 address (Just &quot;123 Fake St.&quot;) (Just &quot;Faketown&quot;) (Just &quot;CA&quot;)

Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })
</code></pre>
<p><code>lift3</code>という関数の名前は、
3引数の関数を持ち上げるために使用できることを示しています。
関数を持ち上げる同様の関数で、
引数の数が異なるものが<code>Control.Apply</code>で定義されています。</p>
<h2 id="任意個の引数を持つ関数の持ち上げ"><a class="header" href="#任意個の引数を持つ関数の持ち上げ">任意個の引数を持つ関数の持ち上げ</a></h2>
<p>これで、<code>lift2</code>や<code>lift3</code>のような関数を使えば、
引数が2個や3個の関数を持ち上げることができるのはわかりました。
でも、これを任意個の引数の関数へと一般化することはできるのでしょうか。</p>
<p><code>lift3</code>の型を見てみるとわかりやすいでしょう。</p>
<pre><code class="language-text">&gt; :type lift3
forall a b c d f. Apply f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d
</code></pre>
<p>上の<code>Maybe</code>の例では型構築子<code>f</code>は<code>Maybe</code>ですから、<code>lift3</code>は次のように特殊化されます。</p>
<pre><code class="language-haskell">forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; Maybe a -&gt; Maybe b -&gt; Maybe c -&gt; Maybe d
</code></pre>
<p>この型が言っているのは、
3引数の任意の関数を取り、
その関数を引数と返り値が<code>Maybe</code>で包まれた新しい関数へと持ち上げる、ということです。</p>
<p>もちろんどんな型構築子<code>f</code>についても持ち上げができるわけではないのですが、
それでは<code>Maybe</code>型を持ち上げができるようにしているものは何なのでしょうか。
さて、先ほどの型の特殊化では、
<code>f</code>に対する型クラス制約から<code>Apply</code>型クラスを取り除いていました。
<code>Apply</code>はPreludeで次のように定義されています。</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>Apply</code>型クラスは<code>Functor</code>の下位クラスであり、
追加の関数<code>apply</code>が定義しています。
<code>&lt;$&gt;</code>が<code>map</code>の別名として定義されているように、
<code>Prelude</code>モジュールで<code>&lt;*&gt;</code>を<code>apply</code>の別名として定義しています。
これから見ていきますが、これら2つの演算子はよく一緒に使われます。</p>
<p>なおこの<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Apply#v:apply"><code>apply</code></a>は<code>Data.Function</code>の<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:apply"><code>apply</code></a>（中置で<code>$</code>）とは異なります。
運良く後者はほぼ常に中置記法として使われるので、名前の衝突については心配ご無用です。</p>
<p><code>apply</code>の型は<code>map</code>の型と実によく似ています。
<code>map</code>と<code>apply</code>の違いは、<code>map</code>がただの関数を引数に取るのに対し、
<code>apply</code>の最初の引数は型構築子<code>f</code>で包まれているという点です。
これをどのように使うのかはこれからすぐに見ていきますが、
その前にまず<code>Maybe</code>型について<code>Apply</code>型クラスをどう実装するのかを見ていきましょう。</p>
<pre><code class="language-haskell">instance functorMaybe :: Functor Maybe where
  map f (Just a) = Just (f a)
  map f Nothing  = Nothing

instance applyMaybe :: Apply Maybe where
  apply (Just f) (Just x) = Just (f x)
  apply _        _        = Nothing
</code></pre>
<p>この型クラスのインスタンスが言っているのは、
任意のオプショナルな値にオプショナルな関数を適用することができ、
その両方が定義されている時に限り結果も定義される、ということです。</p>
<p>それでは、<code>map</code>と<code>apply</code>を一緒に使ってどうやって引数が任意個の関数を持ち上げるのかを見ていきましょう。</p>
<p>1引数の関数については、<code>map</code>をそのまま使うだけです。</p>
<p>2引数関数については型<code>a -&gt; b -&gt; c</code>のカリー化された関数<code>g</code>があるとします。
これは型<code>a -&gt; (b -&gt; c)</code>と同じですから、
<code>Functor</code>インスタンス付きのあらゆる型構築子<code>f</code>について、
<code>map</code>を<code>f</code>に適用すると型<code>f a -&gt; f (b -&gt; c)</code>の新たな関数を得ることになります。
持ち上げられた（型<code>f a</code>の）最初の引数にその関数を部分適用すると、
型<code>f (b -&gt; c)</code>の新たな包まれた関数が得られます。
<code>f</code>に<code>Apply</code>インスタンスもあるならば、
そこから、2番目の持ち上げられた（型<code>f b</code>の）引数へ<code>apply</code>を適用することができ、
型<code>f c</code>の最終的な値を得ます。</p>
<p>まとめると、<code>x :: f a</code>と<code>y :: f b</code>があるとき、式<code>(g &lt;$&gt; x) &lt;*&gt; y</code>の型は<code>f c</code>になります（この式は<code>apply (map g x)  y</code>と同じ意味だということを思い出しましょう）。
Preludeで定義された優先順位の規則に従うと、<code>g &lt;$&gt; x &lt;*&gt; y</code>というように括弧を外すことができます。</p>
<p>一般的にいえば、最初の引数に<code>&lt;$&gt;</code>を使い、
残りの引数に対しては<code>&lt;*&gt;</code>を使います。
<code>lift3</code>で説明すると次のようになります。</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z
</code></pre>
<p>この式の型がちゃんと整合しているかの確認は、
読者への演習として残しておきます。</p>
<p>例として、<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>をそのまま使うと、
<code>Maybe</code>上に<code>address</code>関数を持ち上げることができます。</p>
<pre><code class="language-text">&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Just &quot;Faketown&quot; &lt;*&gt; Just &quot;CA&quot;
Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })

&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;CA&quot;
Nothing
</code></pre>
<p>このように、引数が異なる他のいろいろな関数を<code>Maybe</code>上に持ち上げてみてください。</p>
<p>この代わりにお馴染の<strong>do記法</strong>に似た見た目の<strong>アプリカティブdo記法</strong>が同じ目的で使えます。
以下では<code>lift3</code>に<strong>アプリカティブdo記法</strong>を使っています。
なお<code>ado</code>が<code>do</code>の代わりに使われており、生み出された値を示すために最後の行で<code>in</code>が使われています。</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = ado
  a &lt;- x
  b &lt;- y
  c &lt;- z
  in f a b c
</code></pre>
<h2 id="アプリカティブ型クラス"><a class="header" href="#アプリカティブ型クラス">アプリカティブ型クラス</a></h2>
<p>関連する<code>Applicative</code>という型クラスが存在しており、次のように定義されています。</p>
<pre><code class="language-haskell">class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p><code>Applicative</code>は<code>Apply</code>の下位クラスであり、
<code>pure</code>関数が定義されています。
<code>pure</code>は値を取り、その型の型構築子<code>f</code>で包まれた値を返します。</p>
<p><code>Maybe</code>についての<code>Applicative</code>インスタンスは次のようになります。</p>
<pre><code class="language-haskell">instance applicativeMaybe :: Applicative Maybe where
  pure x = Just x
</code></pre>
<p>アプリカティブ関手は関数を持ち上げることを可能にする関手だと考えるとすると、
<code>pure</code>は引数のない関数の持ち上げだというように考えることができます。</p>
<h2 id="アプリカティブに対する直感的理解"><a class="header" href="#アプリカティブに対する直感的理解">アプリカティブに対する直感的理解</a></h2>
<p>PureScriptの関数は純粋であり、
副作用は持っていません。
Applicative関手は、
関手<code>f</code>によって表現されたある種の副作用を提供するような、
より大きな「プログラミング言語」を扱えるようにします。</p>
<p>たとえば、関手<code>Maybe</code>はオプショナルな値の副作用を表現しています。
その他の例としては、
型<code>err</code>のエラーの可能性の副作用を表す<code>Either err</code>や、
大域的な構成を読み取る副作用を表すArrow関手 (arrow functor) <code>r -&gt;</code>があります。
ここでは<code>Maybe</code>関手についてだけを考えることにします。</p>
<p>もし関手<code>f</code>が作用を持つより大きなプログラミング言語を表すとすると、
<code>Apply</code>と<code>Applicative</code>インスタンスは小さなプログラミング言語 (PureScript) から
新しい大きな言語へと値や関数を持ち上げることを可能にします。</p>
<p><code>pure</code>は純粋な（副作用がない）値をより大きな言語へと持ち上げますし、
関数については上で述べたとおり<code>map</code>と<code>apply</code>を使うことができます。</p>
<p>ここで疑問が生まれます。
もしPureScriptの関数と値を新たな言語へ埋め込むのに<code>Applicative</code>が使えるなら、
どうやって新たな言語は大きくなっているというのでしょうか。
この答えは関手<code>f</code>に依存します。
もしなんらかの<code>x</code>について<code>pure x</code>で表せないような型<code>f a</code>の式を見つけたなら、
その式はそのより大きな言語だけに存在する項を表しているということです。</p>
<p><code>f</code>が<code>Maybe</code>のときは、式<code>Nothing</code>がその例になっています。
どんな<code>x</code>があっても<code>Nothing</code>を<code>pure x</code>というように書くことはできません。
したがって、PureScriptは値の欠落を表す新しい項<code>Nothing</code>を含むように拡大されたと考えることができます。</p>
<h2 id="もっと作用を"><a class="header" href="#もっと作用を">もっと作用を</a></h2>
<p>様々な<code>Applicative</code>関手へと関数を持ち上げる例をもっと見ていきましょう。</p>
<p>以下は、PSCiで定義された3つの名前を結合して完全な名前を作る簡単な関数の例です。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; fullName first middle last = last &lt;&gt; &quot;, &quot; &lt;&gt; first &lt;&gt; &quot; &quot; &lt;&gt; middle

&gt; fullName &quot;Phillip&quot; &quot;A&quot; &quot;Freeman&quot;
Freeman, Phillip A
</code></pre>
<p>この関数は、クエリパラメータとして与えられた3つの引数を持つ、
（とても簡単な！）ウェブサービスの実装であるとしましょう。
使用者が3つの引数すべてを与えたことを確かめたいので、
引数が存在するかどうかを表す<code>Maybe</code>型を使うことになるでしょう。
<code>fullName</code>を<code>Maybe</code>の上へ持ち上げると、
省略された引数を確認するウェブサービスを実装することができます。</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Just &quot;A&quot; &lt;*&gt; Just &quot;Freeman&quot;
Just (&quot;Freeman, Phillip A&quot;)

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;Freeman&quot;
Nothing
</code></pre>
<p>または<strong>アプリカティブdo</strong>で</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; :paste…
… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Just &quot;A&quot;
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
(Just &quot;Freeman, Phillip A&quot;)

… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Nothing
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
Nothing
</code></pre>
<p>この持ち上げた関数は、引数のいずれかが<code>Nothing</code>なら<code>Nothing</code>返すことに注意してください。</p>
<p>これで、もし引数が不正ならWebサービスからエラー応答を送信することができるので、なかなかいい感じです。しかし、どのフィールドが間違っていたのかを応答で表示できると、もっと良くなるでしょう。</p>
<p><code>Meybe</code>上へ持ち上げる代わりに<code>Either String</code>上へ持ち上げるようにすると、
エラーメッセージを返すことができるようになります。
まずは<code>Either String</code>を使ってオプショナルな入力をエラーを発信できる計算に変換する演算子を書きましょう。</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; :paste
… withError Nothing  err = Left err
… withError (Just a) _   = Right a
… ^D
</code></pre>
<p><strong>注意</strong>：<code>Either err</code>Applicative関手において、<code>Left</code>構築子は失敗を表しており、<code>Right</code>構築子は成功を表しています。</p>
<p>これで<code>Either String</code>上へ持ち上げることで、それぞれの引数について適切なエラーメッセージを提供できるようになります。</p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last =
…   fullName &lt;$&gt; (first  `withError` &quot;First name was missing&quot;)
…            &lt;*&gt; (middle `withError` &quot;Middle name was missing&quot;)
…            &lt;*&gt; (last   `withError` &quot;Last name was missing&quot;)
… ^D
</code></pre>
<p>または<strong>アプリカティブdo</strong>で</p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last = ado
…  f &lt;- first  `withError` &quot;First name was missing&quot;
…  m &lt;- middle `withError` &quot;Middle name was missing&quot;
…  l &lt;- last   `withError` &quot;Last name was missing&quot;
…  in fullName f m l
… ^D

&gt; :type fullNameEither
Maybe String -&gt; Maybe String -&gt; Maybe String -&gt; Either String String
</code></pre>
<p>これでこの関数は<code>Maybe</code>の3つの省略可能な引数を取り、
<code>String</code>のエラーメッセージか<code>String</code>の結果のどちらかを返します。</p>
<p>いろいろな入力でこの関数を試してみましょう。</p>
<pre><code class="language-text">&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) (Just &quot;Freeman&quot;)
(Right &quot;Freeman, Phillip A&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) Nothing (Just &quot;Freeman&quot;)
(Left &quot;Middle name was missing&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) Nothing
(Left &quot;Last name was missing&quot;)
</code></pre>
<p>このとき、すべてのフィールドが与えられば成功の結果が表示され、そうでなければ省略されたフィールドのうち最初のものに対応するエラーメッセージが表示されます。しかし、もし複数の入力が省略されているとき、最初のエラーしか見ることができません。</p>
<pre><code class="language-text">&gt; fullNameEither Nothing Nothing Nothing
(Left &quot;First name was missing&quot;)
</code></pre>
<p>これでも十分なときもありますが、エラー時に<strong>すべての</strong>省略されたフィールドの一覧がほしいときは、<code>Either String</code>よりも強力なものが必要です。この章の後半でこの解決策を見ていきます。</p>
<h2 id="作用の結合"><a class="header" href="#作用の結合">作用の結合</a></h2>
<p>抽象的にApplicative関手を扱う例として、
アプリカティブ関手<code>f</code>によって表現された副作用を総称的に組み合わせる関数をどのように書くのかをこの節では示します。</p>
<p>これはどういう意味でしょうか？
何らかの<code>a</code>について型<code>f a</code>で包まれた引数のリストがあるとしましょう。
それは型<code>List (f a)</code>のリストがあるということです。
直感的には、これは<code>f</code>によって追跡される副作用を持つ、
返り値の型が<code>a</code>の計算のリストを表しています。
これらの計算のすべてを順番に実行することができれば、
<code>List a</code>型の結果のリストを得るでしょう。
しかし、まだ<code>f</code>によって追跡される副作用が残ります。
つまり、元のリストの中の作用を「結合する」ことにより、
型<code>List (f a)</code>の何かを型<code>f (List a)</code>の何かへと変換することができると考えられます。</p>
<p>任意の固定長リストの長さ<code>n</code>について、
その引数を要素に持った長さ<code>n</code>のリストを構築するような<code>n</code>引数の関数が存在します。
たとえば、もし<code>n</code>が<code>3</code>なら、
関数は<code>\x y z -&gt; x : y : z : Nil</code>です。
この関数の型は<code>a -&gt; a -&gt; a -&gt; List a</code>です。
<code>Applicative</code>インスタンスを使うと、
この関数を<code>f</code>の上へ持ち上げて関数型<code>f a -&gt; f a -&gt; f a -&gt; f (List a)</code>を得ることができます。
しかし、いかなる<code>n</code>についてもこれが可能なので、
いかなる引数の<strong>リスト</strong>についても同じように持ち上げられることが確かめられます。</p>
<p>したがって、次のような関数を書くことができるはずです。</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>この関数は副作用を持つかもしれない引数のリストをとり、
それぞれの副作用を適用することで、<code>f</code>に包まれた単一のリストを返します。</p>
<p>この関数を書くためには、
引数のリストの長さについて考えます。
リストが空の場合はどんな作用も実行する必要はありませんから、
<code>pure</code>を使用して単に空のリストを返すことができます。</p>
<pre><code class="language-haskell">combineList Nil = pure Nil
</code></pre>
<p>実際のところ、これが唯一できることです！</p>
<p>入力のリストが空でないならば、
型<code>f a</code>の包まれた引数である先頭要素と、
型<code>List (f a)</code>の尾鰭について考えます。
また、再帰的にリストの残りを結合すると、
型<code>f (List a)</code>の結果が得られます。
それから<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使うと、
<code>Cons</code>構築子を先頭と新しい尾鰭の上に持ち上げることができます。</p>
<pre><code class="language-haskell">combineList (Cons x xs) = Cons &lt;$&gt; x &lt;*&gt; combineList xs
</code></pre>
<p>繰り返しになりますが、これは与えられた型に基づいている唯一の妥当な実装です。</p>
<p><code>Maybe</code>型構築子を例にとって、PSCiでこの関数を試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.List
&gt; import Data.Maybe

&gt; combineList (fromFoldable [Just 1, Just 2, Just 3])
(Just (Cons 1 (Cons 2 (Cons 3 Nil))))

&gt; combineList (fromFoldable [Just 1, Nothing, Just 2])
Nothing
</code></pre>
<p><code>Meybe</code>へ特殊化して考えると、
リストのすべての要素が<code>Just</code>であるときに限りこの関数は<code>Just</code>を返しますし、
そうでなければ<code>Nothing</code>を返します。
これはオプショナルな値に対応するより大きな言語に取り組む上での直感と一貫したものです。
オプショナルな結果を返す計算のリストは、
全ての計算が結果を持っているならばそれ自身の結果のみを持つのです。</p>
<p>しかし<code>combineList</code>関数はどんな<code>Applicative</code>に対しても機能します！
<code>Either err</code>を使ってエラーを発信するかもしれなかったり、
<code>r -&gt;</code>を使って大域的な状態を読み取る計算を連鎖させるときにも使えるのです。</p>
<p><code>combineList</code>関数については、後ほど<code>Traversable</code>関手について考えるときに再会します。</p>
<h2 id="演習-18"><a class="header" href="#演習-18">演習</a></h2>
<ol>
<li>（普通）数値演算子<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>のオプショナル引数（つまり<code>Maybe</code>に包まれた引数）を扱って<code>Maybe</code>に包まれた値を返す版を書いてください。
これらの関数には<code>addMaybe</code>、<code>subMaybe</code>、<code>mulMaybe</code>、<code>divMaybe</code>と名前を付けます。
<strong>ヒント</strong>：<code>lift2</code>を使ってください。</li>
<li>（普通）上の演習を（<code>Maybe</code>だけでなく）全ての<code>Apply</code>型で動くように拡張してください。
これらの新しい関数には<code>addApply</code>、<code>subApply</code>、<code>mulApply</code>、<code>divApply</code>と名前を付けます。</li>
<li>（難しい）型<code>combineMaybe : forall a f. (Applicative f) =&gt; Maybe (f a) -&gt; f (Maybe a)</code>
を持つ関数<code>combineMaybe</code>を書いてください。
この関数は副作用をもつオプショナルな計算をとり、オプショナルな結果をもつ副作用のある計算を返します。</li>
</ol>
<h2 id="アプリカティブによる検証-1"><a class="header" href="#アプリカティブによる検証-1">アプリカティブによる検証</a></h2>
<p>この章のソースコードでは住所録アプリケーションで使うことのできるいろいろなデータ型が定義されています。
詳細はここでは割愛しますが、
<code>Data.AddressBook</code>モジュールからエクスポートされる重要な関数は次のような型を持っています。</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address

phoneNumber :: PhoneType -&gt; String -&gt; PhoneNumber

person :: String -&gt; String -&gt; Address -&gt; Array PhoneNumber -&gt; Person
</code></pre>
<p>ここで、<code>PhoneType</code>は次のような代数的データ型として定義されています。</p>
<pre><code class="language-haskell">data PhoneType
  = HomePhone
  | WorkPhone
  | CellPhone
  | OtherPhone
</code></pre>
<p>これらの関数は住所録の項目を表す<code>Person</code>を構築するのに使えます。
例えば、<code>Data.AddressBook</code>には次のような値が定義されています。</p>
<pre><code class="language-haskell">examplePerson :: Person
examplePerson =
  person &quot;John&quot; &quot;Smith&quot;
    (address &quot;123 Fake St.&quot; &quot;FakeTown&quot; &quot;CA&quot;)
    [ phoneNumber HomePhone &quot;555-555-5555&quot;
    , phoneNumber CellPhone &quot;555-555-0000&quot;
    ]
</code></pre>
<p>PSCiでこれらの値を試してみましょう（結果は整形されています）。</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; examplePerson
{ firstName: &quot;John&quot;
, lastName: &quot;Smith&quot;
, homeAddress:
    { street: &quot;123 Fake St.&quot;
    , city: &quot;FakeTown&quot;
    , state: &quot;CA&quot;
    }
, phones:
    [ { type: HomePhone
      , number: &quot;555-555-5555&quot;
      }
    , { type: CellPhone
      , number: &quot;555-555-0000&quot;
      }
    ]
}
</code></pre>
<p>前の章では型<code>Person</code>のデータ構造を検証するのに<code>Either String</code>関手をどのように使うかを見ました。
例えば、データ構造の2つの名前を検証する関数が与えられたとき、
データ構造全体を次のように検証することができます。</p>
<pre><code class="language-haskell">nonEmpty1 :: String -&gt; Either String String
nonEmpty1 &quot;&quot;     = Left &quot;Field cannot be empty&quot;
nonEmpty1 value  = Right value

validatePerson1 :: Person -&gt; Either String Person
validatePerson1 p =
  person &lt;$&gt; nonEmpty1 p.firstName
         &lt;*&gt; nonEmpty1 p.lastName
         &lt;*&gt; pure p.homeAddress
         &lt;*&gt; pure p.phones
</code></pre>
<p>または<strong>アプリカティブdo</strong>で</p>
<pre><code class="language-haskell">validatePerson1Ado :: Person -&gt; Either String Person
validatePerson1Ado p = ado
  f &lt;- nonEmpty1 p.firstName
  l &lt;- nonEmpty1 p.lastName
  in person f l p.homeAddress p.phones
</code></pre>
<p>最初の2行では<code>nonEmpty</code>関数を使って空文字列でないことを検証しています。
もし入力が空なら<code>nonEMpty</code>はエラーを返し（<code>Left</code>構築子で示されています）、
そうでなければ<code>Right</code>構築子を使って値を包んで返します。</p>
<p>最後の2行では何の検証も実行せず、
単に<code>address</code>フィールドと<code>phones</code>フィールドを残りの引数として<code>person</code>関数へと提供しています。</p>
<p>この関数はPSCiでうまく動作するように見えますが、以前見たような制限があります。</p>
<pre><code class="language-text">&gt; validatePerson $ person &quot;&quot; &quot;&quot; (address &quot;&quot; &quot;&quot; &quot;&quot;) []
(Left &quot;Field cannot be empty&quot;)
</code></pre>
<p><code>Either String</code>アプリカティブ関手は遭遇した最初のエラーだけを返します。
でもこの入力では、名前の不足と姓の不足という2つのエラーがわかるようにしたくなるでしょう。</p>
<p><code>validation</code>ライブラリは別のアプリカティブ関手も提供されています。
これは単に<code>V</code>と呼ばれていて、
何らかの<strong>半群</strong> (Semigroup) でエラーを返す機能があります。
たとえば、<code>V (Array String)</code>を使うと、新しいエラーを配列の最後に連結していき、
<code>String</code>の配列をエラーとして返すことができます。</p>
<p><code>Data.Validation</code>モジュールは<code>Data.AddressBook</code>モジュールの
データ構造を検証するために<code>V (Array String)</code>アプリカティブ関手を使っています。</p>
<p><code>Data.AddressBook.Validation</code>モジュールにある検証の例としては次のようになります。</p>
<pre><code class="language-haskell">type Errors
  = Array String

nonEmpty :: String -&gt; String -&gt; V Errors String
nonEmpty field &quot;&quot;     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' cannot be empty&quot; ]
nonEmpty _     value  = pure value

lengthIs :: String -&gt; Int -&gt; String -&gt; V Errors String
lengthIs field len value | length value /= len =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must have length &quot; &lt;&gt; show len ]
lengthIs _     _   value = pure value

validateAddress :: Address -&gt; V Errors Address
validateAddress a =
  address &lt;$&gt; nonEmpty &quot;Street&quot;  a.street
          &lt;*&gt; nonEmpty &quot;City&quot;    a.city
          &lt;*&gt; lengthIs &quot;State&quot; 2 a.state
</code></pre>
<p>または<strong>アプリカティブdo</strong>で</p>
<pre><code class="language-haskell">validateAddressAdo :: Address -&gt; V Errors Address
validateAddressAdo a = ado
  street &lt;- nonEmpty &quot;Street&quot;  a.street
  city   &lt;- nonEmpty &quot;City&quot;    a.city
  state  &lt;- lengthIs &quot;State&quot; 2 a.state
  in address street city state
</code></pre>
<p><code>validateAddress</code>は<code>Address</code>の構造を検証します。
<code>street</code>と<code>city</code>が空でないかどうか、<code>state</code>の文字列の長さが2であるかどうかを検証します。</p>
<p><code>nonEmpty</code>と<code>lengthIs</code>の2つの検証関数はいずれも、
<code>Data.Validation</code>モジュールで提供されている<code>invalid</code>関数を
エラーを示すために使っていることに注目してください。
<code>Array String</code>半群を扱っているので、<code>invalid</code>は引数として文字列の配列を取ります。</p>
<p>PSCiでこの関数を試しましょう。</p>
<pre><code class="language-text">&gt; import Data.AddressBook
&gt; import Data.AddressBook.Validation

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         , &quot;Field 'State' must have length 2&quot;
         ])

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;CA&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         ])
</code></pre>
<p>これで、すべての検証エラーの配列を受け取ることができるようになりました。</p>
<h2 id="正規表現検証器"><a class="header" href="#正規表現検証器">正規表現検証器</a></h2>
<p><code>validatePhoneNumber</code>関数では引数の形式を検証するために正規表現を使っています。重要なのは<code>matches</code>検証関数で、この関数は<code>Data.String.Regex</code>モジュールのて定義されている<code>Regex</code>を使って入力を検証しています。</p>
<pre><code class="language-haskell">matches :: String -&gt; Regex -&gt; String -&gt; V Errors String
matches _     regex value | test regex value
                          = pure value
matches field _     _     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' did not match the required format&quot; ]
</code></pre>
<p>繰り返しになりますが、<code>pure</code>は常に成功する検証を表しており、エラーの配列の伝達には<code>invalid</code>が使われています。</p>
<p>これまでと同じような感じで、<code>validatePhoneNumber</code>は<code>matches</code>関数から構築されています。</p>
<pre><code class="language-haskell">validatePhoneNumber :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumber pn =
  phoneNumber &lt;$&gt; pure pn.&quot;type&quot;
              &lt;*&gt; matches &quot;Number&quot; phoneNumberRegex pn.number
</code></pre>
<p>または<strong>アプリカティブdo</strong>で</p>
<pre><code class="language-haskell">validatePhoneNumberAdo :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumberAdo pn = ado
  tpe    &lt;- pure pn.&quot;type&quot;
  number &lt;- matches &quot;Number&quot; phoneNumberRegex pn.number
  in phoneNumber tpe number
</code></pre>
<p>また、PSCiでいろいろな有効な入力や無効な入力に対して、この検証器を実行してみてください。</p>
<pre><code class="language-text">&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555-555-5555&quot;
pure ({ type: HomePhone, number: &quot;555-555-5555&quot; })

&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555.555.5555&quot;
invalid ([&quot;Field 'Number' did not match the required format&quot;])
</code></pre>
<h2 id="演習-19"><a class="header" href="#演習-19">演習</a></h2>
<ol>
<li>（簡単）正規表現<code>stateRegex :: Regex</code>を書いて
文字列が2文字のアルファベットであることを確かめてください。
<strong>ヒント</strong>：<code>phoneNumberRegex</code>のソースコードを参照してみましょう。</li>
<li>（普通）文字列全体が空白でないことを検査する正規表現<code>nonEmptyRegex :: Regex</code>を書いてください。
<strong>ヒント</strong>：この正規表現を開発するのに手助けが必要なら、<a href="https://regexr.com">RegExr</a>をご確認ください。
素晴しい早見表と対話的なお試し環境があります。</li>
<li>（普通）<code>validateAddress</code>に似ていますが、
上の<code>stateRegex</code>を使って<code>state</code>フィールドを検証し、
<code>nonEmptyRegex</code>を使って<code>street</code>と<code>city</code>フィールドを検証する関数<code>validateAddressImproved</code>を書いてください。
<strong>ヒント</strong>：<code>matches</code>の用例については<code>validatePhoneNumber</code>のソースを見てください。</li>
</ol>
<h2 id="巡回可能関手"><a class="header" href="#巡回可能関手">巡回可能関手</a></h2>
<p>残った検証器は<code>validatePerson</code>です。
これはこれまで見てきた検証器と以下の新しい<code>validatePhoneNumbers</code>関数を組み合わせて
<code>Person</code>全体を検証するものです。</p>
<pre><code class="language-haskell">validatePhoneNumbers :: String -&gt; Array PhoneNumber -&gt; V Errors (Array PhoneNumber)
validatePhoneNumbers field []      =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must contain at least one value&quot; ]
validatePhoneNumbers _     phones  =
  traverse validatePhoneNumber phones

validatePerson :: Person -&gt; V Errors Person
validatePerson p =
  person &lt;$&gt; nonEmpty &quot;First Name&quot; p.firstName
         &lt;*&gt; nonEmpty &quot;Last Name&quot; p.lastName
         &lt;*&gt; validateAddress p.homeAddress
         &lt;*&gt; validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
</code></pre>
<p>または<strong>アプリカティブdo</strong>で</p>
<pre><code class="language-haskell">validatePersonAdo :: Person -&gt; V Errors Person
validatePersonAdo p = ado
  firstName &lt;- nonEmpty &quot;First Name&quot; p.firstName
  lastName  &lt;- nonEmpty &quot;Last Name&quot; p.lastName
  address   &lt;- validateAddress p.homeAddress
  numbers   &lt;- validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
  in person firstName lastName address numbers
</code></pre>
<p><code>validatePhoneNumbers</code>はこれまでに見たことのない新しい関数、<code>traverse</code>を使います。</p>
<p><code>traverse</code>は<code>Data.Traversable</code>モジュールの<code>Traversable</code>型クラスで定義されています。</p>
<pre><code class="language-haskell">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p><code>Traversable</code>は<strong>巡回可能関手</strong>の型クラスを定義します。
これらの関数の型は少し難しそうに見えるかもしれませんが、<code>validatePerson</code>は良いきっかけとなる例です。</p>
<p>すべての巡回可能関手は<code>Functor</code>と<code>Foldable</code>のどちらでもあります（<strong>畳み込み可能関手</strong>は構造をひとつの値へとまとめる、畳み込み操作を提供する型構築子であったことを思い出してください）。
それに加えて、<code>Traversable</code>関手はその構造に依存した副作用の集まりを連結する機能を提供します。</p>
<p>複雑そうに聞こえるかもしれませんが、配列の場合に特殊化して簡単に考えてみましょう。配列型構築子は<code>Traversable</code>である、つまり次のような関数が存在するということです。</p>
<pre><code class="language-haskell">traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; Array a -&gt; m (Array b)
</code></pre>
<p>直感的には、任意のアプリカティブ関手<code>m</code>と、
型<code>a</code>の値を取って型<code>b</code>の値を返す（<code>f</code>で追跡される副作用を持つ）関数が与えられたとき、
その関数を型<code>Array a</code>の配列のそれぞれの要素に適用し、
型<code>Array b</code>の（<code>f</code>で追跡される副作用を持つ）結果を得ることができます。</p>
<p>まだよくわからないでしょうか。
それでは、更に<code>f</code>を上記の<code>V Errors</code>アプリカティブ関手に特殊化して考えてみましょう。
これで次の型を持つ関数が得られます。</p>
<pre><code class="language-haskell">traverse :: forall a b. (a -&gt; V Errors b) -&gt; Array a -&gt; V Errors (Array b)
</code></pre>
<p>この型シグネチャは、
型<code>a</code>についての検証関数<code>m</code>があれば、
<code>traverse m</code>は型<code>Array a</code>の配列についての検証関数であるということを言っています。
これはまさに今必要になっている<code>Person</code>データ構造体の<code>phones</code>フィールドを検証する検証器そのものです！
それぞれの要素が成功するかどうかを検証する検証関数を作るために、
<code>validatePhoneNumber</code>を<code>traverse</code>へ渡しています。</p>
<p>一般に、<code>traverse</code>はデータ構造の要素をひとつづつ辿っていき、副作用のある計算を実行して結果を累積します。</p>
<p><code>Traversable</code>のもう1つの関数、<code>sequence</code>の型シグネチャには見覚えがあるかもしれません。</p>
<pre><code class="language-haskell">sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p>実際、先ほど書いた<code>combineList</code>関数は<code>Traversable</code>型クラスの<code>sequence</code>関数の特別な場合に過ぎません。
<code>t</code>を型構築子<code>List</code>だとすると、<code>combineList</code>関数の型が復元されます。</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>巡回可能関手は、
作用のある計算を連鎖させてその作用を結合するという、
データ構造走査の考え方を把握できるようにするものです。
実際、<code>sequence</code>と<code>traversable</code>は<code>Traversable</code>を定義する上でどちらも同じくらい重要です。
これらはお互いが互いを利用して実装することができます。
これについては興味ある読者への演習として残しておきます。</p>
<p><code>Data.List</code>で与えられているリストの<code>Traversable</code>インスタンスは次の通り。</p>
<pre><code class="language-haskell">instance traversableList :: Traversable List where
-- traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; List a -&gt; m (List b)
traverse _ Nil         = pure Nil
traverse f (Cons x xs) = Cons &lt;$&gt; f x &lt;*&gt; traverse f xs
</code></pre>
<p>（実際の定義は後にスタック安全性を向上するための変更されました。
その変更についてより詳しくは<a href="https://github.com/purescript/purescript-lists/pull/87">こちら</a>で読むことができます）</p>
<p>入力が空のリストのときには、
単に<code>pure</code>を使って空の配列を返すことができます。
配列が空でないときは、
関数<code>f</code>を使うと先頭の要素から型<code>f b</code>の計算を作成することができます。
また、配列の残りに対して<code>traverse</code>を再帰的に呼び出すことができます。
最後に、アプリカティブ関手<code>m</code>まで<code>Cons</code>構築子を持ち上げて、2つの結果を組み合わせます。</p>
<p>巡回可能関手の例はただの配列やリスト以外にもあります。
以前に見た<code>Maybe</code>型構築子も<code>Traversable</code>のインスタンスを持っています。
PSCiで試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; import Data.Traversable
&gt; import Data.AddressBook.Validation

&gt; traverse (nonEmpty &quot;Example&quot;) Nothing
pure (Nothing)

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;&quot;)
invalid ([&quot;Field 'Example' cannot be empty&quot;])

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;Testing&quot;)
pure ((Just &quot;Testing&quot;))
</code></pre>
<p>これらの例では、
<code>Nothing</code>の値の走査は検証なしで<code>Nothing</code>の値を返し、
<code>Just x</code>を走査すると<code>x</code>を検証するのに検証関数が使われるということを示しています。
要は、<code>traverse</code>は型<code>a</code>についての検証関数をとり、<code>Maybe a</code>についての検証関数、
つまり型<code>a</code>のオプショナルな値についての検証関数を返すのです。</p>
<p>他の巡回可能関手には<code>Array</code>、また任意の型<code>a</code>について<code>Tuple a</code>、<code>Either a</code>が含まれます。
一般的に、「容器」のようなデータの型構築子は大抵<code>Traversable</code>インスタンスを持っています。
例として、演習では二分木の型の<code>Traversable</code>インスタンスを書くようになっています。</p>
<h2 id="演習-20"><a class="header" href="#演習-20">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Eq</code>と<code>Show</code>インスタンスを以下の2分木データ構造に書いてください。</p>
<pre><code class="language-haskell">data Tree a = Leaf | Branch (Tree a) a (Tree a)
</code></pre>
<p>これらのインスタンスを手作業で書くこともできますし、
コンパイラに導出してもらうこともできることを前の章から思い起こしてください。</p>
<p><code>Show</code>の出力には多くの「正しい」書式の選択肢があります。
この演習のテストでは以下の空白スタイルを期待しています。
これはちょうど一般化されたshowの既定の書式と合致しているため、
このインスタンスを手作業で書くつもりであれば、
このことを念頭に置いておくだけでよいです。</p>
<pre><code class="language-haskell">(Branch (Branch Leaf 8 Leaf) 42 Leaf)
</code></pre>
</li>
<li>
<p>（普通）<code>Traversable</code>インスタンスを<code>Tree a</code>を書いてください。
これは副作用を左から右に結合するものです。
<strong>ヒント</strong>：<code>Traversable</code>に定義する必要のある追加のインスタンス依存関係がいくつかあります。</p>
</li>
<li>
<p>（普通）行き掛け順に木を巡回する関数
<code>traversePreOrder :: forall a m b. Applicative m =&gt; (a -&gt; m b) -&gt; Tree a -&gt; m (Tree b)</code>
を書いてください。
つまり作用の実行は根左右と行われ、
以前の通り掛け順の巡回の演習でしたような左根右ではありません。
<strong>ヒント</strong>：追加でインスタンスを定義する必要はありませんし、
前に定義した関数は何も呼ぶ必要はありません。
アプリカティブdo記法 (<code>ado</code>) はこの関数を書く最も簡単な方法です。</p>
</li>
<li>
<p>（普通）作用が左右根と実行される木の帰り掛け順の巡回を行う関数
<code>traversePostOrder</code>を書いてください。</p>
</li>
<li>
<p>（普通）<code>homeAddress</code>フィールドがオプショナル（<code>Maybe</code>を使用）な
新しい版の<code>Person</code>型をつくってください。
それからこの新しい<code>Person</code>を検証する新しい版の<code>validatePerson</code>（<code>validatePersonOptionalAddress</code>と改名します）を書いてください。
<strong>ヒント</strong>：<code>traverse</code>を使って型<code>Maybe a</code>のフィールドを検証してください。</p>
</li>
<li>
<p>（難しい）<code>sequence</code>のように振る舞う関数<code>sequenceUsingTraverse</code>を書いてください。
ただし<code>traverse</code>を使ってください。</p>
</li>
<li>
<p>（難しい）<code>traverse</code>のように振る舞う関数<code>traverseUsingSequence</code>を書いてください。
ただし<code>sequence</code>を使ってください。</p>
</li>
</ol>
<h2 id="アプリカティブ関手による並列処理"><a class="header" href="#アプリカティブ関手による並列処理">アプリカティブ関手による並列処理</a></h2>
<p>これまでの議論では、
アプリカティブ関手がどのように「副作用を結合」させるかを説明するときに、
「結合」(combine) という単語を選びました。
しかしながら、これらのすべての例において、
アプリカティブ関手は作用を「連鎖」(sequence) させる、
というように言っても同じく妥当です。
巡回可能関手がデータ構造に従って作用を順番に結合させる<code>sequence</code>関数を提供していることと、
この直感的理解とは一致するでしょう。</p>
<p>しかし一般には、
アプリカティブ関手はこれよりももっと一般的です。
アプリカティブ関手の規則は、
その計算を実行する副作用にどんな順序付けも強制しません。
実際、並列に副作用を実行するためのアプリカティブ関手というものは妥当になりえます。</p>
<p>たとえば、
<code>V</code>検証関手はエラーの<strong>配列</strong>を返しますが、
その代わりに<code>Set</code>半群を選んだとしてもやはり正常に動き、
このときどんな順序でそれぞれの検証器を実行しても問題はありません。
データ構造に対して並列にこれを実行することさえできるのです！</p>
<p>別の例として、<code>parallel</code>パッケージは、
<strong>並列計算</strong>をサポートする<code>Parallel</code>型クラスを与えます。
<code>Parallel</code>は関数<code>parallel</code>を提供しており、
何らかの<code>Applicative</code>関手を使って入力の計算を<strong>並列に</strong>計算することができます。</p>
<pre><code class="language-haskell">f &lt;$&gt; parallel computation1
  &lt;*&gt; parallel computation2
</code></pre>
<p>この計算は<code>computation1</code>と<code>computation2</code>を非同期に使って値を計算を始めるでしょう。
そして両方の結果の計算が終わった時に、関数<code>f</code>を使ってひとつの結果へと結合するでしょう。</p>
<p>この考え方の詳細は、
本書の後半で<strong>コールバック地獄</strong>の問題に対して
アプリカティブ関手を応用するときに見ていきます。</p>
<p>アプリカティブ関手は並列に結合されうる副作用を捕捉する自然な方法です。</p>
<h2 id="まとめ-5"><a class="header" href="#まとめ-5">まとめ</a></h2>
<p>この章では新しい考え方をたくさん扱いました。</p>
<ul>
<li>関数適用の概念を副作用の観念を捉えた型構築子へと一般化する、<strong>アプリカ
ティブ関手</strong>の概念を導入しました。</li>
<li>データ構造の検証という課題にアプリカティブ関手がどのような解決策を与え
るか、どうすれば単一のエラーの報告からデータ構造を横断するすべてのエラー
の報告へ変換できるのかを見てきました。</li>
<li><code>Traversable</code>型クラスに出会いました。<strong>巡回可能関手</strong>の考え方を内包す
るものであり、要素が副作用を持つ値の結合に使うことができる容器でした。</li>
</ul>
<p>アプリカティブ関手は多くの問題に対して優れた解決策を与える興味深い抽象化です。
本書を通じて何度も見ることになるでしょう。
今回の場合、アプリカティブ関手は宣言的な流儀で書く手段を提供していましたが、
これにより<strong>どうやって</strong>検証を行うかではなく、
<strong>何を</strong>検証器が検証すべきなのかを定義することができました。
一般に、アプリカティブ関手は<strong>領域特化言語</strong>を設計する上で便利な道具になります。</p>
<p>次の章では、これに関連する考え方である<strong>モナド</strong>クラスを見て、
アドレス帳の例をブラウザで実行させられるように拡張しましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用モナド"><a class="header" href="#作用モナド">作用モナド</a></h1>
<h2 id="この章の目標-6"><a class="header" href="#この章の目標-6">この章の目標</a></h2>
<p>前章では、オプショナルな型やエラーメッセージ、
データの検証など、<strong>副作用</strong>を扱いを抽象化するアプリカティブ関手を導入しました。
この章では、より表現力の高い方法で副作用を扱うための別の抽象化、<strong>モナド</strong>を導入します。</p>
<p>この章の目的は、なぜモナドが便利な抽象化なのかということと、
<strong>do記法</strong>との関係を説明することです。</p>
<h2 id="プロジェクトの準備-5"><a class="header" href="#プロジェクトの準備-5">プロジェクトの準備</a></h2>
<p>このプロジェクトでは、以下の依存関係が追加されています。</p>
<ul>
<li><code>effect</code>: 章の後半の主題である<code>Effect</code>モナドを定義しています。この依存
関係はあらゆるプロジェクトの始めに掲げられることがよくあるので（これま
での全ての章でも依存関係にありました）、明示的にインストールしなければ
いけないことは稀です。</li>
<li><code>react-basic-hooks</code>: アドレス帳アプリに使うWebフレームワークです。</li>
</ul>
<h2 id="モナドとdo記法"><a class="header" href="#モナドとdo記法">モナドとdo記法</a></h2>
<p>do記法は<strong>配列内包表記</strong>を扱うときに最初に導入されました。配列内包表記は <code>Data.Array</code>モジュールの
<code>concatMap</code>関数の構文糖として提供されています。</p>
<p>次の例を考えてみましょう。2つのサイコロを振って出た目を数え、出た目の合計が
<code>n</code>のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使うとこれを実現することができます。</p>
<ul>
<li>最初の投擲で値 <code>x</code>を<strong>選択</strong>します。</li>
<li>2回目の投擲で値 <code>y</code>を<strong>選択</strong>します。</li>
<li>もし <code>x</code>と <code>y</code>の和が <code>n</code>なら組 <code>[x, y]</code>を返し、そうでなければ失敗しま
す。</li>
</ul>
<p>配列内包表記を使うと、この非決定的アルゴリズムを自然に書くことができます。</p>
<pre><code class="language-hs">import Prelude

import Control.Plus (empty)
import Data.Array ((..))

countThrows :: Int -&gt; Array (Array Int)
countThrows n = do
  x &lt;- 1 .. 6
  y &lt;- 1 .. 6
  if x + y == n
    then pure [ x, y ]
    else empty
</code></pre>
<p>PSCiでこの関数の動作を見てみましょう。</p>
<pre><code class="language-text">&gt; import Test.Examples

&gt; countThrows 10
[[4,6],[5,5],[6,4]]

&gt; countThrows 12
[[6,6]]
</code></pre>
<p>前の章では、<strong>オプショナルな値</strong>に対応したより大きなプログラミング言語へと
PureScriptの関数を埋め込む、
<code>Maybe</code> アプリカティブ関手についての直感的理解を養いました。
同様に<strong>配列モナド</strong>についても、
<strong>非決定選択</strong>に対応したより大きなプログラミング言語へ
PureScriptの関数を埋め込む、というような直感的理解を得ることができます。</p>
<p>一般に、ある型構築子 <code>m</code>のモナドは、型 <code>m a</code>の値を持つdo記法を使う方法を提供します。
上の配列内包表記では、すべての行に何らかの型 <code>a</code>についての型 <code>Array a</code>の計算が含まれていることに注目してください。
一般に、do記法ブロックのすべての行は、何らかの型 <code>a</code>とモナド <code>m</code>について、型 <code>m a</code>の計算を含んでいます。
モナド <code>m</code>はすべての行で同じでなければなりません（つまり、副作用の種類は固定されます）が、型
<code>a</code>は異なることもあります（言い換えると、個々の計算は異なる型の結果を持つことができます）。</p>
<p>以下はdo記法の別の例です。
今回は型構築子 <code>Maybe</code>に適用されています。
XMLノードを表す型 <code>XML</code>と次の関数があるとします。</p>
<pre><code class="language-hs">child :: XML -&gt; String -&gt; Maybe XML
</code></pre>
<p>この関数はノードの子の要素を探し、
もしそのような要素が存在しなければ <code>Nothing</code>を返します。</p>
<p>この場合、do記法を使うと深い入れ子になった要素を検索することができます。XML文書として符号化された利用者情報から、利用者の住んでいる市町村を読み取りたいとします。</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p><code>userCity</code>関数は子の要素である <code>profile</code>を探し、 <code>profile</code>要素の中にある <code>address</code>要素、最後に
<code>address</code>要素から <code>city</code>要素を探します。これらの要素のいずれかが欠落している場合は、返り値は
<code>Nothing</code>になります。そうでなければ、返り値は <code>city</code>ノードから <code>Just</code>を使って構築されています。</p>
<p>最後の行にある<code>pure</code>関数は、すべての<code>Applicative</code>関手について定義されているのでした。<code>Maybe</code>の<code>Applicative</code>関手の<code>pure</code>関数は<code>Just</code>として定義されており、最後の行を
<code>Just city</code>へ変更しても同じように正しく動きます。</p>
<h2 id="モナド型クラス"><a class="header" href="#モナド型クラス">モナド型クラス</a></h2>
<p><code>Monad</code>型クラスは次のように定義されています。</p>
<pre><code class="language-hs">class Apply m &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

class (Applicative m, Bind m) &lt;= Monad m
</code></pre>
<p>ここで鍵となる関数は <code>Bind</code>型クラスで定義されている演算子 <code>bind</code>で、
<code>Functor</code>及び <code>Apply</code>型クラスにある <code>&lt;$&gt;</code>や <code>&lt;*&gt;</code>などの演算子と同じ様に
<code>Prelude</code>では <code>&gt;&gt;=</code>として <code>bind</code>の中置の別名が定義されています。</p>
<p><code>Monad</code>型クラスは、すでに見てきた <code>Applicative</code>型クラスの操作で <code>Bind</code>を拡張します。</p>
<p><code>Bind</code>型クラスの例をいくつか見てみるのがわかりやすいでしょう。配列についての <code>Bind</code>の妥当な定義は次のようになります。</p>
<pre><code class="language-hs">instance bindArray :: Bind Array where
  bind xs f = concatMap f xs
</code></pre>
<p>これは以前にほのめかした配列内包表記と <code>concatMap</code>関数の関係を説明しています。</p>
<p><code>Maybe</code>型構築子についての <code>Bind</code>の実装は次のようになります。</p>
<pre><code class="language-hs">instance bindMaybe :: Bind Maybe where
  bind Nothing  _ = Nothing
  bind (Just a) f = f a
</code></pre>
<p>この定義は欠落した値がdo記法ブロックを通じて伝播するという直感的理解を裏付けるものです。</p>
<p><code>Bind</code>型クラスとdo記法がどのように関係しているかを見て行きましょう。最初に何らかの計算結果からの値の束縛から始まる簡単なdo記法ブロックについて考えてみましょう。</p>
<pre><code class="language-hs">do value &lt;- someComputation
   whatToDoNext
</code></pre>
<p>PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置き換えます。</p>
<pre><code class="language-hs">bind someComputation \value -&gt; whatToDoNext
</code></pre>
<p>あるいは中置で書くと以下です。</p>
<pre><code class="language-hs">someComputation &gt;&gt;= \value -&gt; whatToDoNext
</code></pre>
<p>この計算 <code>whatToDoNext</code>は <code>value</code>に依存することができます。</p>
<p>複数の束縛が関係している場合、この規則は先頭のほうから複数回適用されます。例えば、先ほど見た <code>userCity</code>の例では次のように脱糖されます。</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root =
  child root &quot;profile&quot; &gt;&gt;= \prof -&gt;
    child prof &quot;address&quot; &gt;&gt;= \addr -&gt;
      child addr &quot;city&quot; &gt;&gt;= \city -&gt;
        pure city
</code></pre>
<p>do記法を使って表現されたコードは、
<code>&gt;&gt;=</code>演算子を使って書かれた同じ意味のコードよりしばしば読みやすくなることも特筆すべき点です。
一方で、明示的に <code>&gt;&gt;=</code>を使って束縛が書くと、
よく<strong>ポイントフリー</strong>形式でコードが書けるようになります。
ただし、読みやすさにはやはり注意がいります。</p>
<h2 id="モナド則"><a class="header" href="#モナド則">モナド則</a></h2>
<p><code>Monad</code>型クラスは<strong>モナド則</strong> (monad laws) と呼ばれる3つの規則を持っています。
これらは <code>Monad</code>型クラスの理にかなった実装から何を期待できるかを教えてくれます。</p>
<p>do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。</p>
<h3 id="単位元律"><a class="header" href="#単位元律">単位元律</a></h3>
<p><strong>右単位元則</strong> (right-identity law) が3つの規則の中で最も簡単です。
この規則はdo記法ブロックの最後の式であれば、
<code>pure</code>の呼び出しを排除することができると言っています。</p>
<pre><code class="language-hs">do
  x &lt;- expr
  pure x
</code></pre>
<p>右単位元則は、この式は単なる <code>expr</code>と同じだと言っています。</p>
<p><strong>左単位元則</strong> (left-identity law) は、もしそれがdo記法ブロックの最初の式であれば、
<code>pure</code>の呼び出しを除去することができると述べています。</p>
<pre><code class="language-hs">do
  x &lt;- pure y
  next
</code></pre>
<p>このコードは、名前<code>x</code>を式<code>y</code>で置き換えた<code>next</code>と同じです。</p>
<p>最後の規則は<strong>結合則</strong> (associativity law) です。
これは入れ子になったdo記法ブロックをどう扱うのかについて教えてくれます。
この規則が述べているのは以下のコード片のことです。</p>
<pre><code class="language-hs">c1 = do
  y &lt;- do
    x &lt;- m1
    m2
  m3
</code></pre>
<p>上記のコード片は、次のコードと同じです。</p>
<pre><code class="language-hs">c2 = do
  x &lt;- m1
  y &lt;- m2
  m3
</code></pre>
<p>これら計算にはそれぞれ、3つのモナドの式 <code>m1</code>、 <code>m2</code>、 <code>m3</code>が含まれています。どちらの場合でも <code>m1</code>の結果は名前 <code>x</code>に束縛され、
<code>m2</code>の結果は名前 <code>y</code>に束縛されます。</p>
<p><code>c1</code>では2つの式 <code>m1</code>と <code>m2</code>がそれぞれのdo記法ブロック内にグループ化されています。</p>
<p><code>c2</code>では <code>m1</code>、 <code>m2</code>、 <code>m3</code>の3つすべての式が同じdo記法ブロックに現れています。</p>
<p>結合規則は入れ子になったdo記法ブロックをこのように単純化しても
問題ないことを言っています。</p>
<p><strong>注意</strong>: do記法を<code>bind</code>の呼び出しへと脱糖する定義により、 <code>c1</code>と <code>c2</code>はいずれも次のコードと同じです。</p>
<pre><code class="language-hs">c3 = do
  x &lt;- m1
  do
    y &lt;- m2
    m3
</code></pre>
<h2 id="モナドで畳み込む"><a class="header" href="#モナドで畳み込む">モナドで畳み込む</a></h2>
<p>抽象的にモナドを扱う例として、
この節では <code>Monad</code>型クラスの何らかの型構築子に機能するある関数を示していきます。
これはモナドによるコードが副作用を伴う「より大きな言語」でのプログラミングと対応しているという直感的理解を補強しますし、モナドによるプログラミングがもたらす一般性も示しています。</p>
<p>これから <code>foldM</code>と呼ばれる関数を書いてみます。これは以前扱った
<code>foldl</code>関数をモナドの文脈へと一般化します。型シグネチャは次のようになっています。</p>
<pre><code class="language-hs">foldM :: forall m a b. Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; List b -&gt; m a
foldl :: forall   a b.            (a -&gt; b -&gt;   a) -&gt; a -&gt; List b -&gt;   a
</code></pre>
<p>モナド <code>m</code>が現れている点を除いて、 <code>foldl</code>の型と同じであることに注意しましょう。</p>
<p>直感的には、 <code>foldM</code>はさまざまな副作用の組み合わせに対応した文脈での配列の畳み込みを行うと捉えることができます。</p>
<p>例として <code>m</code>が <code>Maybe</code>であるとすると、この畳み込みはそれぞれの段階で
<code>Nothing</code>を返すことで失敗することができます。それぞれの段階ではオプショナルな結果を返しますから、それゆえ畳み込みの結果もオプショナルになります。</p>
<p>もし <code>m</code>として配列の型構築子
<code>Array</code>を選ぶとすると、畳み込みのそれぞれの段階で複数の結果を返すことができ、畳み込みは結果それぞれに対して次の手順を継続します。最後に、結果の集まりは、可能な経路すべての畳み込みから構成されることになります。これはグラフの走査と対応しています！</p>
<p><code>foldM</code>を書くには、単に入力のリストについて場合分けをするだけです。</p>
<p>リストが空なら、型 <code>a</code>の結果を生成するための選択肢はひとつしかありません。
第2引数を返します。</p>
<pre><code class="language-hs">foldM _ a Nil = pure a
</code></pre>
<p>なお<code>a</code>をモナド <code>m</code>まで持ち上げるために <code>pure</code>を使わなくてはいけません。</p>
<p>リストが空でない場合はどうでしょうか？
その場合、型 <code>a</code>の値、型 <code>b</code>の値、型 <code>a -&gt; b -&gt; m a</code>の関数があります。
もしこの関数を適用すると、型 <code>m a</code>のモナドの結果を手に入れることになります。
この計算の結果を逆向きの矢印 <code>&lt;-</code>で束縛することができます。</p>
<p>あとはリストの残りに対して再帰するだけです。実装は簡単です。</p>
<pre><code class="language-hs">foldM f a (b : bs) = do
  a' &lt;- f a b
  foldM f a' bs
</code></pre>
<p>なお、do記法を除けば、この実装は配列に対する <code>foldl</code>の実装とほとんど同じです。</p>
<p>PSCiでこれを定義し、試してみましょう。
以下では例として、除算可能かどうかを調べて、失敗を示すために <code>Maybe</code>型構築子を使う、
整数の「安全な除算」関数を定義するとしましょう。</p>
<pre><code class="language-hs">safeDivide :: Int -&gt; Int -&gt; Maybe Int
safeDivide _ 0 = Nothing
safeDivide a b = Just (a / b)
</code></pre>
<p>これで、 <code>foldM</code>で安全な除算の繰り返しを表現することができます。</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.List (fromFoldable)

&gt; foldM safeDivide 100 (fromFoldable [5, 2, 2])
(Just 5)

&gt; foldM safeDivide 100 (fromFoldable [2, 0, 4])
Nothing
</code></pre>
<p>もしいずれかの時点で整数にならない除算が行われようとしたら、
<code>foldM safeDivide</code>関数は <code>Nothing</code>を返します。
そうでなければ、除算を繰り返した累積の結果を<code>Just</code>構築子に包んで返します。</p>
<h2 id="モナドとアプリカティブ"><a class="header" href="#モナドとアプリカティブ">モナドとアプリカティブ</a></h2>
<p>クラス間に上位クラス関係の効能があるため、
<code>Monad</code>型クラスのすべてのインスタンスは <code>Apply</code>型クラスのインスタンスでもあります。</p>
<p>しかしながら、あらゆる<code>Monad</code>のインスタンスに
「無料で」ついてくる<code>Apply</code>型クラスの実装もあります。
これは<code>ap</code>関数により与えられます。</p>
<pre><code class="language-hs">ap :: forall m a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
ap mf ma = do
  f &lt;- mf
  a &lt;- ma
  pure (f a)
</code></pre>
<p>もし <code>m</code>が <code>Monad</code>型クラスに固執していれば、
<code>ap</code>で与えられる<code>m</code>について妥当な <code>Apply</code>インスタンスが存在します。</p>
<p>興味のある読者は、これまで登場した <code>Array</code>、 <code>Maybe</code>、 <code>Either e</code>といったモナドについて、この <code>ap</code>が
<code>apply</code>と一致することを確かめてみてください。</p>
<p>もしすべてのモナドがアプリカティブ関手でもあるなら、
アプリカティブ関手についての直感的理解を
すべてのモナドについても適用することができるはずです。
特に、モナドが更なる副作用の組み合わせで増強された「より大きな言語」での
プログラミングといろいろな意味で一致することを予想するのはもっともです。
<code>map</code>と <code>apply</code>を使って、
引数が任意個の関数をこの新しい言語へと持ち上げることができるはずです。</p>
<p>しかし、モナドはアプリカティブ関手でできること以上を行うことができ、
重要な違いはdo記法の構文で強調されています。
利用者情報を符号化したXML文書から利用者の都市を検索する、
<code>userCity</code>の例についてもう一度考えてみましょう。</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p>do記法では2番目の計算が最初の結果 <code>prof</code>に依存し、
3番目の計算が2番目の計算の結果
<code>addr</code>に依存するというようなことができます。
<code>Applicative</code>型クラスのインターフェイスだけを使うのでは、
このような以前の値への依存は不可能です。</p>
<p><code>pure</code>と <code>apply</code>だけを使って <code>userCity</code>を書こうとしてみれば、
これが不可能であることがわかるでしょう。
アプリカティブ関手ができるのは関数の互いに独立した引数を持ち上げることだけですが、
モナドはもっと興味深いデータ依存関係に関わる計算を書くことを可能にします。</p>
<p>前の章では <code>Applicative</code>型クラスは並列処理を表現できることを見ました。
持ち上げられた関数の引数は互いに独立していますから、
これはまさにその通りです。
<code>Monad</code>型クラスは計算が前の計算の結果に依存できるようにしますから、
同じようにはなりません。
モナドは副作用を順番に組み合わせなければいけません。</p>
<h2 id="演習-21"><a class="header" href="#演習-21">演習</a></h2>
<ol>
<li>
<p>（簡単）3つ以上の要素がある配列の3つ目の要素を返す関数<code>third</code>を書いてください。
関数は適切な<code>Maybe</code>型で返します。
<strong>ヒント</strong>：<code>arrays</code>パッケージの<code>Data.Array</code>モジュールから<code>head</code>と<code>tail</code>関数の型を見つけ出してください。
これらの関数を繋げるには<code>Maybe</code>モナドと共にdo記法を使ってください。</p>
</li>
<li>
<p>（普通）一掴みの硬貨を使ってできる可能なすべての合計を決定する関数 <code>possibleSums</code>を、
<code>foldM</code>を使って書いてみましょう。入力の硬貨は、硬貨の価値の配列として与えられます。この関数は次のような結果にならなくてはいけません。</p>
<pre><code class="language-text">&gt; possibleSums []
[0]

&gt; possibleSums [1, 2, 10]
[0,1,2,3,10,11,12,13]
</code></pre>
<p><strong>ヒント</strong>：<code>foldM</code>を使うと1行でこの関数を書くことが可能です。
重複を取り除いたり、結果を並び替えたりするのに、
<code>nub</code>関数や <code>sort</code>関数を使いたくなるかもしれません。</p>
</li>
<li>
<p>（普通）<code>Maybe</code>型構築子について、 <code>ap</code>関数と <code>apply</code>演算子が一致することを確認してください。
<strong>補足</strong>：この演習にはテストがありません。</p>
</li>
<li>
<p>（普通）<code>maybe</code>パッケージで定義されている
<code>Maybe</code>型についての <code>Monad</code>インスタンスが、
モナド則を満たしていることを検証してください。
<strong>補足</strong>：この演習にはテストがありません。</p>
</li>
<li>
<p>（普通）配列上の <code>filter</code>の関数を一般化した関数 <code>filterM</code>を書いてください。
この関数は次の型シグネチャを持ちます。</p>
<pre><code class="language-hs">filterM :: forall m a. Monad m =&gt; (a -&gt; m Boolean) -&gt; List a -&gt; m (List a)
</code></pre>
</li>
<li>
<p>（難しい）すべてのモナドには次で与えられるような既定の<code>Functor</code>インスタンスがあります。</p>
<pre><code class="language-hs">map f a = do
  x &lt;- a
  pure (f x)
</code></pre>
<p>モナド則を使って、すべてのモナドが次を満たすことを証明してください。</p>
<pre><code class="language-hs">lift2 f (pure a) (pure b) = pure (f a b)
</code></pre>
<p>ここで、 <code>Applly</code>インスタンスは上で定義された <code>ap</code>関数を使用しています。
<code>lift2</code>が次のように定義されていたことを思い出してください。</p>
<pre><code class="language-hs">lift2 :: forall f a b c. Apply f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
lift2 f a b = f &lt;$&gt; a &lt;*&gt; b
</code></pre>
<p><strong>補足</strong>：この演習にはテストがありません。</p>
</li>
</ol>
<h2 id="ネイティブな作用"><a class="header" href="#ネイティブな作用">ネイティブな作用</a></h2>
<p>ここではPureScriptの中核となる重要なモナド、 <code>Effect</code>モナドについて見ていきます。</p>
<p><code>Effect</code>モナドは <code>Effect</code>モジュールで定義されています。
かつてはいわゆる<strong>ネイティブ</strong>副作用を管理していました。
Haskellに馴染みがあれば、これは<code>IO</code>モナドと同等のものです。</p>
<p>ネイティブな副作用とは何でしょうか。
この副作用はPureScript特有の式からJavaScriptの式を区別するものです。
PureScriptの式は概して副作用とは無縁なのです。
ネイティブな作用の例を以下に示します。</p>
<ul>
<li>コンソール入出力</li>
<li>乱数生成</li>
<li>例外</li>
<li>変更可能な状態の読み書き</li>
</ul>
<p>また、ブラウザでは次のようなものがあります。</p>
<ul>
<li>DOM操作</li>
<li>XMLHttpRequest / AJAX呼び出し</li>
<li>WebSocketによる相互作用</li>
<li>Local Storageの読み書き</li>
</ul>
<p>すでに「ネイティブでない」副作用の例については数多く見てきています。</p>
<ul>
<li><code>Maybe</code>データ型で表現される省略可能な値</li>
<li><code>Either</code>データ型で表現されるエラー</li>
<li>配列やリストで表現される多価関数</li>
</ul>
<p>これらの区別はわかりにくいので注意してください。エラーメッセージは例外の形でJavaScriptの式の副作用となることがあります。その意味では例外はネイティブな副作用を表していて、
<code>Effect</code>を使用して表現することができます。しかし、
<code>Either</code>を使用して実装されたエラーメッセージはJavaScriptランタイムの副作用ではなく、
<code>Effect</code>を使うスタイルでエラーメッセージを実装するのは適切ではありません。そのため、ネイティブなのは作用自体というより、実行時にどのように実装されているかです。</p>
<h2 id="副作用と純粋性"><a class="header" href="#副作用と純粋性">副作用と純粋性</a></h2>
<p>PureScriptのような言語が純粋であるとすると、疑問が浮かんできます。副作用がないなら、どうやって役に立つ実際のコードを書くことができるというのでしょうか。</p>
<p>その答えはPureScriptの目的は副作用を排除することではないということです。これは、純粋な計算と副作用のある計算とを型システムにおいて区別することができるような方法で、副作用を表現することを目的としているのです。この意味で、言語はあくまで純粋だということです。</p>
<p>副作用のある値は、純粋な値とは異なる型を持っています。
このように、例えば副作用のある引数を関数に渡すことはできず、
予期せず副作用を持つようなことが起こらなくなります。</p>
<p><code>Effect</code>モナドで管理された副作用を実行する唯一の方法は、
型 <code>Effect a</code>の計算をJavaScriptから実行することです。</p>
<p>Spagoビルドツール（や他のツール）は早道を提供しており、
アプリケーションの起動時に<code>main</code>計算を呼び出すための追加のJavaScriptコードを生成します。
<code>main</code>は <code>Effect</code>モナドでの計算であることが要求されます。</p>
<h2 id="作用モナド-1"><a class="header" href="#作用モナド-1">作用モナド</a></h2>
<p><code>Effect</code>は副作用のある計算を充分に型付けするAPIを提供すると同時に、
効率的なJavaScriptを生成します。</p>
<p>馴染みのある<code>log</code>関数から返る型をもう少し見てみましょう。
<code>Effect</code>はこの関数がネイティブな作用を生み出すことを示しており、
この場合はコンソールIOです。
<code>Unit</code>はいかなる<em>意味のある</em>データも返らないことを示しています。
<code>Unit</code>はC、Javaなど他の言語での<code>void</code>キーワードと似たようなものとして考えられます。</p>
<pre><code class="language-hs">log :: String -&gt; Effect Unit
</code></pre>
<blockquote>
<p><em>余談</em> ：より一般的な（そしてより込み入った型の）<code>Effect.Class.Console</code>の<code>log</code>関数をIDEから提案されるかもしれません。
これは基本的な<code>Effect</code>モナドを扱う際は<code>Effect.Console</code>からの関数と交換可能です。
より一般的なバージョンがあることの理由は「モナドな冒険」章の「モナド変換子」について読んだあとにより明らかになっていることでしょう。
好奇心のある（そしてせっかちな）読者のために言うと、これは<code>Effect</code>に<code>MonadEffect</code>インスタンスがあるから機能するのです。</p>
<pre><code class="language-hs">log :: forall m. MonadEffect m =&gt; String -&gt; m Unit
</code></pre>
</blockquote>
<p>それでは意味のあるデータを返す<code>Effect</code>を考えましょう。
<code>Effect.Random</code>の<code>random</code>関数はランダムな<code>Number</code>を生み出します。</p>
<pre><code class="language-hs">random :: Effect Number
</code></pre>
<p>以下は完全なプログラムの例です（この章の演習フォルダの<code>test/Random.purs</code>にあります）。</p>
<pre><code class="language-hs">module Test.Random where

import Prelude
import Effect (Effect)
import Effect.Random (random)
import Effect.Console (logShow)

main :: Effect Unit
main = do
  n &lt;- random
  logShow n
</code></pre>
<p><code>Effect</code>はモナドなので、do記法を使って含まれるデータを開封し、
それからこのデータを作用のある<code>logShow</code>関数に渡します。
気分転換に、以下は<code>bind</code>演算子を使って書かれた同等なコードです。</p>
<pre><code class="language-hs">main :: Effect Unit
main = random &gt;&gt;= logShow
</code></pre>
<p>これを手元で走らせてみてください。</p>
<pre><code class="language-shell">spago run --main Test.Random
</code></pre>
<p>コンソールに出力 <code>0.0</code>と <code>1.0</code>の間で無作為に選ばれた数が表示されるでしょう。</p>
<blockquote>
<p>余談：<code>spago run</code>は既定で<code>Main</code>モジュールとその中の<code>main</code>関数を探索します。
<code>--main</code>フラグで代替のモジュールを入口として指定することもでき、
上の例ではそうしています。
この代替のモジュールもまた<code>main</code>関数を含んでいることには注目してください。</p>
</blockquote>
<p>なお「ランダムな」（技術的には疑似ランダムな）データを不浄な作用付きのコードに訴えることなく生成することも可能です。
この技法は「テストを生成する」章で押さえます。</p>
<p>以前言及したように<code>Effect</code>モナドはPureScriptで核心的な重要さがあります。
なぜ核心かというと、それはPureScriptの<code>外部関数インターフェース</code>とやりとりする上での常套手段だからです。
<code>外部関数インターフェース</code>はプログラムを実行したり副作用を発生させたりする仕組みを提供します。
<code>外部関数インターフェース</code>を使うことは避けるのが望ましいのですが、
どう動きどう使うのか理解することもまた極めて大事なことですので、
実際にPureScriptで何か動かす前にその章を読まれることをお勧めします。
要は<code>Effect</code>モナドは結構単純なのです。
いくつかのお助け関数がありますが、それを差し置いても副作用を内包すること以外には多くのことをしません。</p>
<h2 id="例外"><a class="header" href="#例外">例外</a></h2>
<p>2つの<strong>ネイティブな</strong>副作用が絡む<code>node-fs</code>パッケージの関数を調べましょう。
ここでの副作用は可変状態の読み取りと例外です。</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; String -&gt; Effect String
</code></pre>
<p>もし存在しないファイルを読むことを試みると……</p>
<pre><code class="language-hs">import Node.Encoding (Encoding(..))
import Node.FS.Sync (readTextFile)

main :: Effect Unit
main = do
  lines &lt;- readTextFile UTF8 &quot;iDoNotExist.md&quot;
  log lines
</code></pre>
<p>以下の例外に遭遇します。</p>
<pre><code class="language-text">    throw err;
    ^
Error: ENOENT: no such file or directory, open 'iDoNotExist.md'
...
  errno: -2,
  syscall: 'open',
  code: 'ENOENT',
  path: 'iDoNotExist.md'
</code></pre>
<p>この例外をうまく管理するには、
潜在的に問題があるコードを<code>try</code>に包めばいずれの出力も制御できます。</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  result &lt;- try $ readTextFile UTF8 &quot;iDoNotExist.md&quot;
  case result of
    Right lines -&gt; log $ &quot;Contents: \n&quot; &lt;&gt; lines
    Left  error -&gt; log $ &quot;Couldn't open file. Error was: &quot; &lt;&gt; message error
</code></pre>
<p><code>try</code>は<code>Effect</code>を走らせて起こりうる例外を<code>Left</code>値として返します。
もし計算が成功すれば結果は<code>Right</code>に包まれます。</p>
<pre><code class="language-hs">try :: forall a. Effect a -&gt; Effect (Either Error a)
</code></pre>
<p>自前の例外を生成することもできます。
以下は<code>Data.List.head</code>の代替実装で、
<code>Maybe</code>の値の<code>Nothing</code>を返す代わりにリストが空のとき例外を投げます。</p>
<pre><code class="language-hs">exceptionHead :: List Int -&gt; Effect Int
exceptionHead l = case l of
  x : _ -&gt; pure x
  Nil -&gt; throwException $ error &quot;empty list&quot;
</code></pre>
<p>ただし<code>exceptionHead</code>関数はどこかしら非実用的な例です。
というのも、PureScriptのコードで例外を生成するのは避け、
代わりに<code>Either</code>や<code>Maybe</code>のようなネイティブでない作用で
エラーや欠けた値を使うのが一番だからです。</p>
<h2 id="可変状態"><a class="header" href="#可変状態">可変状態</a></h2>
<p>中核ライブラリには <code>ST</code>作用というまた別の作用も定義されています。</p>
<p><code>ST</code>作用は変更可能な状態を操作するために使われます。純粋関数プログラミングを知っているなら、共有される変更可能な状態は問題を引き起こしやすいということも知っているでしょう。しかしながら、
<code>ST</code>作用は型システムを使って安全で<strong>局所的な</strong>状態変化を可能にし、状態の共有を制限するのです。</p>
<p><code>ST</code>作用は
<code>Control.Monad.ST</code>モジュールで定義されています。これがどのように動作するかを確認するには、そのアクションの型を見る必要があります。</p>
<pre><code class="language-hs">new :: forall a r. a -&gt; ST r (STRef r a)

read :: forall a r. STRef r a -&gt; ST r a

write :: forall a r. a -&gt; STRef r a -&gt; ST r a

modify :: forall r a. (a -&gt; a) -&gt; STRef r a -&gt; ST r a
</code></pre>
<p><code>new</code>は型 <code>STRef r a</code>の変更可能な参照区画を新しく作るのに使われます。
<code>STRef r a</code>は <code>read</code>アクションを使って状態を読み取ったり、
<code>write</code>アクションや <code>modify</code>アクションで状態を変更するのに使われます。
型 <code>a</code>は区画に格納された値の型で、
型 <code>r</code>は型システムで<strong>メモリ領域</strong>（または<strong>ヒープ</strong>）を表しています。</p>
<p>例を示します。小さな時間刻みで簡単な更新関数の実行を何度も繰り返すことによって、重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。</p>
<p>粒子の位置と速度を保持する変更可能な参照区画を作成し、
区画に格納された値を更新するのにforループを使うことでこれを実現することができます。</p>
<pre><code class="language-hs">import Prelude

import Control.Monad.ST.Ref (modify, new, read)
import Control.Monad.ST (ST, for, run)

simulate :: forall r. Number -&gt; Number -&gt; Int -&gt; ST r Number
simulate x0 v0 time = do
  ref &lt;- new { x: x0, v: v0 }
  for 0 (time * 1000) \_ -&gt;
    modify
      ( \o -&gt;
          { v: o.v - 9.81 * 0.001
          , x: o.x + o.v * 0.001
          }
      )
      ref
  final &lt;- read ref
  pure final.x
</code></pre>
<p>計算の最後では、参照区画の最終的な値を読み取り、粒子の位置を返しています。</p>
<p>この関数が変更可能な状態を使っていても、その参照区画
<code>ref</code>がプログラムの他の部分で使われるのが許されない限り、これは純粋な関数のままであることに注意してください。
<code>ST</code>作用が禁止するものが正確には何であるのかについては後ほど見ます。</p>
<p><code>ST</code>作用付きの計算を実行するには、 <code>run</code>関数を使用する必要があります。</p>
<pre><code class="language-hs">run :: forall a. (forall r. ST r a) -&gt; a
</code></pre>
<p>ここで注目して欲しいのは、
領域型 <code>r</code>が関数矢印の左辺にある<strong>括弧の内側で</strong>量化されているということです。
<code>run</code>に渡したどんなアクションでも、
<strong>任意の領域</strong><code>r</code>がなんであれ動作するということを意味しています。</p>
<p>しかしながら、
ひとたび参照区画が <code>new</code>によって作成されると、
その領域の型はすでに固定されており、
<code>run</code>によって限定されたコードの外側で参照領域を使おうとしても型エラーになるでしょう。
<code>run</code>が安全に <code>ST</code>作用を除去でき、<code>simulate</code>を純粋関数にできるのはこれが理由なのです！</p>
<pre><code class="language-hs">simulate' :: Number -&gt; Number -&gt; Int -&gt; Number
simulate' x0 v0 time = run (simulate x0 v0 time)
</code></pre>
<p>PSCiでもこの関数を実行してみることができます。</p>
<pre><code class="language-text">&gt; import Main

&gt; simulate' 100.0 0.0 0
100.00

&gt; simulate' 100.0 0.0 1
95.10

&gt; simulate' 100.0 0.0 2
80.39

&gt; simulate' 100.0 0.0 3
55.87

&gt; simulate' 100.0 0.0 4
21.54
</code></pre>
<p>実は、もし <code>simulate</code>の定義を <code>run</code>の呼び出しのところへ埋め込むとすると、次のようになります。</p>
<pre><code class="language-hs">simulate :: Number -&gt; Number -&gt; Int -&gt; Number
simulate x0 v0 time =
  run do
    ref &lt;- new { x: x0, v: v0 }
    for 0 (time * 1000) \_ -&gt;
      modify
        ( \o -&gt;
            { v: o.v - 9.81 * 0.001
            , x: o.x + o.v * 0.001
            }
        )
        ref
    final &lt;- read ref
    pure final.x
</code></pre>
<p>参照区画はそのスコープから逃れることができないことがコンパイラにわかりますし、
安全に<code>ref</code>を<code>var</code>に変換することができます。
<code>run</code>が埋め込まれた<code>simulate</code>に対して生成されたJavaScriptは次のようになります。</p>
<pre><code class="language-javascript">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return (function __do() {

        var ref = { value: { x: x0, v: v0 } };

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        return ref.value.x;

      })();
    };
  };
};
</code></pre>
<p>なおこの結果として得られたJavaScriptは最適化の余地があります。
詳細は<a href="https://github.com/purescript-contrib/purescript-book/issues/121">この課題</a>を参照してください。
上記の抜粋はその課題が解決されたら更新されるでしょう。</p>
<p>比較としてこちらが埋め込まれていない形式で生成されたJavaScriptです。</p>
<pre><code class="language-js">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return function __do() {

        var ref = Control_Monad_ST_Internal[&quot;new&quot;]({ x: x0, v: v0 })();

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        var $$final = Control_Monad_ST_Internal.read(ref)();
        return $$final.x;
      };
    };
  };
};
</code></pre>
<p>局所的な変更可能状態を扱うとき、
特に作用が絡むループを生成する
<code>for</code>、 <code>foreach</code>、 <code>while</code>のようなアクションを一緒に使うときには、
<code>ST</code>作用は短いJavaScriptを生成する良い方法となります。</p>
<h2 id="演習-22"><a class="header" href="#演習-22">演習</a></h2>
<ol>
<li>（普通）<code>safeDivide</code>関数を書き直し、
もし分母がゼロなら<code>throwException</code>を使って文言<code>&quot;div zero&quot;</code>の例外を投げるようにしたものを
<code>exceptionDivide</code>としてください。</li>
<li>（普通）関数<code>estimatePi :: Int -&gt; Number</code>を書いてください。
この関数は<code>n</code>項<a href="https://mathworld.wolfram.com/GregorySeries.html">Gregory
Series</a>を使って<code>pi</code>の近似を計算するものです。
<strong>ヒント</strong>：解答は上記の<code>simulate</code>の定義に倣うことができます。
また<code>Data.Int</code>の<code>toNumber :: Int -&gt; Number</code>を使って、
<code>Int</code>を<code>Number</code>に変換する必要があるかもしれません。</li>
<li>（普通）<code>n</code>番目のフィボナッチ数を計算する関数<code>fibonacci :: Int -&gt; Int</code>を書いてください。
<code>ST</code>を使って前の2つのフィボナッチ数の値を追跡します。
新しい<code>ST</code>に基づく実装の速度を第4章の再帰実装に対して比較してください。</li>
</ol>
<h2 id="dom作用"><a class="header" href="#dom作用">DOM作用</a></h2>
<p>この章の最後の節では、
<code>Effect</code>モナドでの作用についてこれまで学んだことを、
実際のDOM操作の問題に応用します。</p>
<p>DOMを直接扱ったり、
オープンソースのDOMライブラリを扱ったりする
PureScriptパッケージが沢山あります。
例えば以下です。</p>
<ul>
<li><a href="https://github.com/purescript-web/purescript-web-dom"><code>web-dom</code></a>はW3C
のDOM規格に向けた型定義と低水準インターフェース実装を提供します。</li>
<li><a href="https://github.com/purescript-web/purescript-web-html"><code>web-html</code></a>は
W3CのHTML5規格に向けた型定義と低水準インターフェース実装を提供します。</li>
<li><a href="http://github.com/paf31/purescript-jquery"><code>jquery</code></a>は
<a href="http://jquery.org">jQuery</a>ライブラリのバインディングの集まりです。</li>
</ul>
<p>上記のライブラリを抽象化するPureScriptライブラリもあります。
以下のようなものです。</p>
<ul>
<li><a
href="http://github.com/paf31/purescript-thermite"><code>thermite</code></a>
は<a
href="https://github.com/purescript-contrib/purescript-react"><code>react</code></a>
上で構築されるライブラリです。</li>
<li><a
href="https://github.com/megamaddu/purescript-react-basic-hooks"><code>react-basic-hooks</code></a>
は<a
href="https://github.com/lumihq/purescript-react-basic"><code>react-basic</code></a>
上で構築されるライブラリです。</li>
<li><a
href="http://github.com/purescript-halogen/purescript-halogen"><code>halogen</code></a>
は自前の仮想DOMライブラリを土台とした型安全な抽象化の集まりを提供しま
す。</li>
</ul>
<p>この章では <code>react-basic-hooks</code>ライブラリを使用し、
住所簿アプリケーションにユーザーインターフェイスを追加しますが、
興味のあるユーザは異なるアプローチで進めることをおすすめします。</p>
<h2 id="住所録のユーザーインタフェース"><a class="header" href="#住所録のユーザーインタフェース">住所録のユーザーインタフェース</a></h2>
<p><code>react-basic-hooks</code>ライブラリを使い、
アプリケーションをReact<strong>コンポーネント</strong>として定義していきます。
ReactコンポーネントはHTML要素を純粋なデータ構造としてコードで記述します。
このデータ構造はそれから効率的にDOMに描画されます。
加えてコンポーネントはボタンクリックのようなイベントに応答することができます。
<code>react-basic-hooks</code>ライブラリは<code>Effect</code>モナドを使ってこれらのイベントの制御方法を記述します。</p>
<p>Reactライブラリの完全なチュートリアルはこの章の範囲をはるかに超えていますが、
読者は必要に応じてマニュアルを参照することをお勧めします。
目的に応じて、Reactは <code>Effect</code>モナドの実用的な例を提供してくれます。</p>
<p>利用者が住所録に新しい項目を追加できるフォームを構築することにしましょう。
フォームには、さまざまなフィールド（姓、名前、都市、州など）のテキストボックス、
および検証エラーが表示される領域が含まれます。
テキストボックスに利用者がテキストを入力すると、検証エラーが更新されます。</p>
<p>シンプルさを保つために、
フォームは固定の形状とします。
電話番号は種類（自宅、携帯電話、仕事、その他）ごとに
別々のテキストボックスへ分けることにします。</p>
<p><code>exercises/chapter8</code>ディレクトリから以下のコマンドでWebアプリを立ち上げることができます。</p>
<pre><code class="language-shell">$ npm install
$ npx spago build
$ npx parcel src/index.html --open
</code></pre>
<p>もし<code>spago</code>や<code>parcel</code>のような開発ツールが大域的にインストールされていれば、
<code>npx</code>の前置は省けるでしょう。
恐らく既に<code>spago</code>を<code>npm i -g spago</code>で大域的にインストールしていますし、
<code>parcel</code>についても同じことができるでしょう。</p>
<p><code>parcel</code>は「アドレス帳」アプリのブラウザ窓を立ち上げます。
<code>parcel</code>の端末を開いたままにし、他の端末で<code>spago</code>で再構築すると、
最新の編集を含むページが自動的に再読み込みされるでしょう。
また、<a href="https://github.com/purescript/purescript/tree/master/psc-ide"><code>purs ide</code></a>をサポートしていたり<a href="https://github.com/kRITZCREEK/pscid"><code>pscid</code></a>を走らせていたりする
<a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors">エディタ</a>を使っていれば、
ファイルを保存したときに自動的にページが再構築される（そして自動的にページが再読み込みされる）ように設定できます。</p>
<p>このアドレス帳アプリでフォームフィールドにいろいろな値を入力すると、
ページ上に出力された検証エラーを見ることができるでしょう。</p>
<p>動く仕組みを散策しましょう。</p>
<p><code>src/index.html</code>ファイルは最小限です。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Address Book&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>&lt;script</code>の行はJavaScriptの入口を含んでおり、
<code>index.js</code>にはこの1行が含まれています。</p>
<pre><code class="language-js">import { main } from &quot;../output/Main/index.js&quot;;

main();
</code></pre>
<p><code>module Main</code> (<code>src/main.purs</code>) の<code>main</code>関数と等価な、
生成したJavaScriptを呼び出しています。
<code>spago build</code>は生成された全てのJavaScriptを<code>output</code>ディレクトリに置くことを思い出してください。</p>
<p><code>main</code>関数はDOMとHTML APIを使い、
<code>index.html</code>に定義した<code>container</code>要素の中にアドレス帳コンポーネントを描画します。</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  log &quot;Rendering address book component&quot;
  -- Get window object
  w &lt;- window
  -- Get window's HTML document
  doc &lt;- document w
  -- Get &quot;container&quot; element in HTML
  ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
  case ctr of
    Nothing -&gt; throw &quot;Container element not found.&quot;
    Just c -&gt; do
      -- Create AddressBook react component
      addressBookApp &lt;- mkAddressBookApp
      let
        -- Create JSX node from react component. Pass-in empty props
        app = element addressBookApp {}
      -- Render AddressBook JSX node in DOM &quot;container&quot; element
      D.render app c
</code></pre>
<p>これら3行に注目してください。</p>
<pre><code class="language-hs">w &lt;- window
doc &lt;- document w
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>これは次のように統合できます。</p>
<pre><code class="language-hs">doc &lt;- document =&lt;&lt; window
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>あるいはさらに統合することさえできます。</p>
<pre><code class="language-hs">ctr &lt;- getElementById &quot;container&quot; &lt;&lt;&lt; toNonElementParentNode =&lt;&lt; document =&lt;&lt; window
-- or, equivalently:
ctr &lt;- window &gt;&gt;= document &gt;&gt;= toNonElementParentNode &gt;&gt;&gt; getElementById &quot;container&quot;
</code></pre>
<p>途中の<code>w</code>や<code>doc</code>変数が読みやすさの助けになるかは主観的な嗜好の問題です。</p>
<p>AddressBookの<code>reactComponent</code>を深堀りしましょう。
単純化されたコンポーネントから始め、それから<code>Main.purs</code>で実際のコードに構築していきます。</p>
<p>以下の最小限のコンポーネントをご覧ください。
遠慮なく全体のコンポーネントをこれに置き換えて実行の様子を見てみましょう。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp =
  reactComponent
    &quot;AddressBookApp&quot;
    (\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;)
</code></pre>
<p><code>reactComponent</code>にはこのような威圧的なシグネチャがあります。</p>
<pre><code class="language-hs">reactComponent ::
  forall hooks props.
  Lacks &quot;children&quot; props =&gt;
  Lacks &quot;key&quot; props =&gt;
  Lacks &quot;ref&quot; props =&gt;
  String -&gt;
  ({ | props } -&gt; Render Unit hooks JSX) -&gt;
  Effect (ReactComponent { | props })
</code></pre>
<p>重要な注意点は全ての型クラス制約の後の引数にあります。
<code>String</code>（任意のコンポーネント名）、
<code>props</code>を描画された<code>JSX</code>に変換する方法を記述する関数を取り、
そして<code>Effect</code>に包まれた<code>ReactComponent</code>を返します。</p>
<p>propsからJSXへの関数は単にこうです。</p>
<pre><code class="language-hs">\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;
</code></pre>
<p><code>props</code>は無視されており、<code>D.text</code>は<code>JSX</code>を返し、
そして<code>pure</code>は描画されたJSXに持ち上げます。
これで<code>component</code>には<code>ReactComponent</code>を生成するのに必要な全てがあります。</p>
<p>次に完全なアドレス帳コンポーネントにある追加の複雑な事柄のいくつかを調べていきます。</p>
<p>これらは完全なコンポーネントの最初の数行です。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp = do
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p><code>person</code>を<code>useState</code>フックの状態の一部として追跡します。</p>
<pre><code class="language-hs">Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p>なお、複数回<code>useState</code>を呼び出すことで、
コンポーネントの状態を複数の状態の部品に分解することは自由です。
例えば<code>Person</code>のそれぞれのレコードフィールドについて分離した状態の部品を使って、
このアプリを書き直すことができるでしょう。
しかしこの場合にそれをすると僅かに利便性を損なうアーキテクチャになってしまいます。</p>
<p>他の例では<code>Tuple</code>用の<code>/\</code>中置演算子に出喰わすかもしれません。
これは上の行と等しいものです。</p>
<pre><code class="language-hs">firstName /\ setFirstName &lt;- useState p.firstName
</code></pre>
<p><code>useState</code>は既定の初期値を取り現在の値と値を更新する方法を取ります。
<code>useState</code>の型を確認すれば型<code>person</code>と<code>setPerson</code>についてより深い洞察が得られます。</p>
<pre><code class="language-hs">useState ::
  forall state.
  state -&gt;
  Hook (UseState state) (Tuple state ((state -&gt; state) -&gt; Effect Unit))
</code></pre>
<p>結果の値の<code>Hook (UseState state)</code>ラッパーを取り去ることができますが、
それは<code>useState</code>が<code>R.do</code>ブロックの中で呼ばれているからです。
<code>R.do</code>は後で詳述します。</p>
<p>さてこれで以下のシグネチャを観察できます。</p>
<pre><code class="language-hs">person :: state
setPerson :: (state -&gt; state) -&gt; Effect Unit
</code></pre>
<p><code>state</code>の限定された型は初期の既定値によって決定されます。
これは<code>examplePerson</code>の型なのでこの場合は<code>Person</code> <code>Record</code>です。</p>
<p><code>person</code>はそれぞれの再描画の時点で現在の状態にアクセスする方法です。</p>
<p><code>setPerson</code>は状態を更新する方法です。
現在の状態を新しい状態に変形する方法を記述する関数を単に提供します。
<code>state</code>の型が偶然<code>Record</code>のときは、レコード更新構文はこれにぴったりです。
例えば以下。</p>
<pre><code class="language-hs">setPerson (\currentPerson -&gt; currentPerson {firstName = &quot;NewName&quot;})

</code></pre>
<p>あるいは短かく以下です。</p>
<pre><code class="language-hs">setPerson _ {firstName = &quot;NewName&quot;}
</code></pre>
<p><code>Record</code>でない状態もまたこの更新パターンにしたがいます。
ベストプラクティスについてのより詳しいことは<a href="https://github.com/megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541">このガイド</a>を参照してください。</p>
<p><code>useState</code>が<code>R.do</code>ブロックの中で使われていることを思い出しましょう。
<code>R.do</code>は<code>do</code>の特別なreactフックの派生です。
<code>R.</code>の前置はこれが<code>React.Basic.Hooks</code>から来たものとして「限定する」もので、
<code>R.do</code>ブロックの中でフック互換版の<code>bind</code>を使うことを意味しています。
これは「限定されたdo」として知られています。
<code>Hook (UseState state)</code>のラッピングを無視し、
内部の値の<code>Tuple</code>と変数に束縛してくれます。</p>
<p>他の状態管理戦略として挙げられるのは<code>useReducer</code>ですが、
それはこの章の範疇外です。</p>
<p>以下では<code>JSX</code>の描画が行われています。</p>
<pre><code class="language-hs">pure
  $ D.div
      { className: &quot;container&quot;
      , children:
          renderValidationErrors errors
            &lt;&gt; [ D.div
                  { className: &quot;row&quot;
                  , children:
                      [ D.form_
                          $ [ D.h3_ [ D.text &quot;Basic Information&quot; ]
                            , formField &quot;First Name&quot; &quot;First Name&quot; person.firstName \s -&gt;
                                setPerson _ { firstName = s }
                            , formField &quot;Last Name&quot; &quot;Last Name&quot; person.lastName \s -&gt;
                                setPerson _ { lastName = s }
                            , D.h3_ [ D.text &quot;Address&quot; ]
                            , formField &quot;Street&quot; &quot;Street&quot; person.homeAddress.street \s -&gt;
                                setPerson _ { homeAddress { street = s } }
                            , formField &quot;City&quot; &quot;City&quot; person.homeAddress.city \s -&gt;
                                setPerson _ { homeAddress { city = s } }
                            , formField &quot;State&quot; &quot;State&quot; person.homeAddress.state \s -&gt;
                                setPerson _ { homeAddress { state = s } }
                            , D.h3_ [ D.text &quot;Contact Information&quot; ]
                            ]
                          &lt;&gt; renderPhoneNumbers
                      ]
                  }
              ]
      }
</code></pre>
<p>ここでDOMの意図した状態を表現する<code>JSX</code>を生成しています。
このJSXはHTMLタグ（例：<code>div</code>、<code>form</code>、<code>h3</code>、<code>li</code>、<code>ul</code>、<code>label</code>、<code>input</code>）に対応し単一のHTML要素を作る関数を適用することで作られるのが典型的です。
これらのHTML要素は実はReactコンポーネント自体でJSXに変換されます。
通常これらの関数にはそれぞれ3つの種類があります。</p>
<ul>
<li><code>div_</code>: 子要素の配列を受け付けます。
既定の属性を使います。</li>
<li><code>div</code>: 属性の<code>Record</code>を受け付けます。
子要素の配列をこのレコードの<code>children</code>フィールドに渡すことができます。</li>
<li><code>div'</code>: <code>div</code>と同じですが、<code>JSX</code>に変換する前に<code>ReactComponent</code>を返します。</li>
</ul>
<p>検証エラーをフォームの一番上に（もしあれば）表示するのに、
<code>Errors</code>構造体をJSXの配列に変える<code>renderValidationErrors</code>お助け関数を作ります。
この配列はフォームの残り部分の前に付けます。</p>
<pre><code class="language-hs">renderValidationErrors :: Errors -&gt; Array R.JSX
renderValidationErrors [] = []
renderValidationErrors xs =
  let
    renderError :: String -&gt; R.JSX
    renderError err = D.li_ [ D.text err ]
  in
    [ D.div
        { className: &quot;alert alert-danger row&quot;
        , children: [ D.ul_ (map renderError xs) ]
        }
    ]
</code></pre>
<p>なお、ここでは通常のデータ構造体を単純に操作しているので、
<code>map</code>のような関数を使ってより興味深い要素を構築することができます。</p>
<pre><code class="language-hs">children: [ D.ul_ (map renderError xs)]
</code></pre>
<p><code>className</code>プロパティを使ってCSSスタイルのクラスを定義します。
このプロジェクトでは<a href="https://getbootstrap.com/">Bootstrap</a>の<code>stylesheet</code>を使っており、
これは<code>index.html</code>でインポートされています。
例えばフォーム中のアイテムは<code>row</code>として配置されてほしいですし、
検証エラーは<code>alert-danger</code>の装飾で強調されていてほしいです。</p>
<pre><code class="language-hs">className: &quot;alert alert-danger row&quot;
</code></pre>
<p>2番目の補助関数は <code>formField</code>です。
これは、単一フォームフィールドのテキスト入力を作ります。</p>
<pre><code class="language-hs">formField :: String -&gt; String -&gt; String -&gt; (String -&gt; Effect Unit) -&gt; R.JSX
formField name placeholder value setValue =
  D.label
    { className: &quot;form-group row&quot;
    , children:
        [ D.div
            { className: &quot;col-sm col-form-label&quot;
            , children: [ D.text name ]
            }
        , D.div
            { className: &quot;col-sm&quot;
            , children:
                [ D.input
                    { className: &quot;form-control&quot;
                    , placeholder
                    , value
                    , onChange:
                        let
                          handleValue :: Maybe String -&gt; Effect Unit
                          handleValue (Just v) = setValue v
                          handleValue Nothing  = pure unit
                        in
                          handler targetValue handleValue
                    }
                ]
            }
        ]
    }
</code></pre>
<p><code>input</code>を置いて<code>label</code>の中に<code>text</code>を表示することは、
スクリーンリーダーのアクセシビリティの助けになります。</p>
<p><code>onChange</code>属性があれば利用者の入力に応答する方法を記述することができます。
<code>handler</code>関数を使いますが、これは以下の型を持ちます。</p>
<pre><code class="language-hs">handler :: forall a. EventFn SyntheticEvent a -&gt; (a -&gt; Effect Unit) -&gt; EventHandler
</code></pre>
<p><code>handler</code>への最初の引数には<code>targetValue</code>を使いますが、
これはHTMLの<code>input</code>要素中のテキストの値を提供します。
この場合は型変数<code>a</code>が<code>Maybe String</code>で、
<code>handler</code>が期待するシグネチャに合致しています。</p>
<pre><code class="language-hs">targetValue :: EventFn SyntheticEvent (Maybe String)
</code></pre>
<p>JavaScriptでは<code>input</code>要素の<code>onChange</code>イベントは実は<code>String</code>値と一緒になっているのですが、
JavaScriptの文字列はnullになりえるので、安全のために<code>Maybe</code>が使われています。</p>
<p><code>(a -&gt; Effect Unit)</code>の<code>handler</code>への2つ目の引数は、したがってこのシグネチャを持ちます。</p>
<pre><code class="language-hs">Maybe String -&gt; Effect Unit
</code></pre>
<p>この関数は<code>Maybe String</code>値を求める作用に変換する方法を記述します。
この目的のために以下のように自前の<code>handleValue</code>関数を定義して<code>handler</code>を渡します。</p>
<pre><code class="language-hs">onChange:
  let
    handleValue :: Maybe String -&gt; Effect Unit
    handleValue (Just v) = setValue v
    handleValue Nothing  = pure unit
  in
    handler targetValue handleValue
</code></pre>
<p><code>setValue</code>はそれぞれの<code>formField</code>の呼び出しに提供した関数で
文字列を取り<code>setPerson</code>フックに適切なレコード更新呼び出しを実施します。</p>
<p>なお<code>handleValue</code>は以下のようにも置き換えられます。</p>
<pre><code class="language-hs">onChange: handler targetValue $ traverse_ setValue
</code></pre>
<p>どうぞ<code>traverse_</code>の定義を調査して両方の形式が確かに等価であることをご確認ください。</p>
<p>これは、コンポーネント実装の基本をカバーしています。
しかし、コンポーネントの仕組みを完全に理解するためには、
この章に付随する情報をお読みください。</p>
<p>明らかに、このユーザインタフェースには改善すべき点がたくさんあります。
演習ではアプリケーションがより使いやすくなるような方法を追究していきます。</p>
<h2 id="演習-23"><a class="header" href="#演習-23">演習</a></h2>
<p>以下の演習では<code>src/Main.purs</code>を変更してください。
これらの演習には単体試験はありません。</p>
<ol>
<li>
<p>（簡単）このアプリケーションを変更し、
職場の電話番号を入力できるテキストボックスを追加してください。</p>
</li>
<li>
<p>（普通）現時点でアプリケーションは検証エラーを
単一の「pink-alert」背景に集めて表示させています。
空の線で分割することにより、
それぞれの検証エラーにpink-alert背景を持たせるように変更してください。</p>
<p><strong>ヒント</strong>：リスト中の検証エラーを表示するのに<code>ul</code>要素を使う代わりに、
コードを変更し、
それぞれのエラーに<code>alert</code>と<code>alert-danger</code>装飾を持つ<code>div</code>を作ってください。</p>
</li>
<li>
<p>（難しい、発展）このユーザーインターフェイスの問題のひとつは、
検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。
コードを変更してこの問題を解決してください。</p>
<p><strong>ヒント</strong>：検証器によって返されるエラーの型は、
エラーの原因となっているフィールドを示すために拡張する必要があります。
次のような変更されたエラー型を使用したくなるかもしれません。</p>
<pre><code class="language-hs">data Field = FirstNameField
           | LastNameField
           | StreetField
           | CityField
           | StateField
           | PhoneField PhoneType

data ValidationError = ValidationError String Field

type Errors = Array ValidationError
</code></pre>
<p><code>Error</code>構造体から特定の<code>Field</code>のための検証エラーを取り出す関数を書く必要があるでしょう。</p>
</li>
</ol>
<h2 id="まとめ-6"><a class="header" href="#まとめ-6">まとめ</a></h2>
<p>この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。</p>
<ul>
<li><code>Monad</code>型クラスと、do記法との関連に出会いました。</li>
<li>モナド則を導入し、do記法を使って書かれたコードを変換する方法を見ました。</li>
<li>異なる副作用で動作するコードを書くために、モナドを抽象的に扱う方法を見
ました。</li>
<li>モナドがアプリカティブ関手の一例であること、両者がどのように副作用のあ
る計算を可能にするのかということ、そして2つの手法の違いを説明しました。</li>
<li>ネイティブな作用の概念を定義し、ネイティブな副作用を処理するために使用
する <code>Effect</code>モナドを導入しました。</li>
<li>乱数生成、例外、コンソール入出力、変更可能な状態、およびReactを使った
DOM操作といった、さまざまな作用を扱うために <code>Effect</code>モナドを使いました。</li>
</ul>
<p><code>Effect</code>モナドは現実のPureScriptコードにおける基本的なツールです。
本書ではこのあとも、多くの場面で副作用を処理するために使っていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非同期作用"><a class="header" href="#非同期作用">非同期作用</a></h1>
<h2 id="この章の目標-7"><a class="header" href="#この章の目標-7">この章の目標</a></h2>
<p>この章では<code>Aff</code>モナドに集中します。
これは<code>Effect</code>モナドに似たものですが、<em>非同期</em>な副作用を表現するものです。
ファイルシステムとやりとりしてHTTPリクエストを作る、非同期な例を実演していきます。
また非同期作用の直列ないし並列の実行の管理方法も押さえます。</p>
<h2 id="プロジェクトの準備-6"><a class="header" href="#プロジェクトの準備-6">プロジェクトの準備</a></h2>
<p>この章で導入する新しいPureScriptライブラリは以下です。</p>
<ul>
<li><code>aff</code> - <code>Aff</code>モナドを定義します。</li>
<li><code>node-fs-aff</code> - <code>Aff</code>を使った非同期のファイルシステム操作。</li>
<li><code>affjax</code> - AJAXと<code>Aff</code>を使ったHTTPリクエスト。</li>
<li><code>parallel</code> - <code>Aff</code>の並列実行。</li>
</ul>
<p>（Node.js環境のような）ブラウザ外で実行する場合、
<code>affjax</code>ライブラリは<code>xhr2</code>NPMモジュールが必要です。
このモジュールはこの章の<code>package.json</code>中の依存関係に挙げられています。
以下を走らせてインストールします。</p>
<pre><code class="language-shell">$ npm install
</code></pre>
<h2 id="非同期なjavascript"><a class="header" href="#非同期なjavascript">非同期なJavaScript</a></h2>
<p>JavaScriptで非同期なコードに取り組む上で便利な手段は<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await"><code>async</code>と<code>await</code></a>です。
<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">非同期なJavaScriptに関するこの記事</a>を見るとより背景情報がわかります。</p>
<p>以下はこの技法を使ってあるファイルの内容を別のファイルに複製する例です。</p>
<pre><code class="language-js">import { promises as fsPromises } from 'fs'

async function copyFile(file1, file2) {
  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });
  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });
}

copyFile('file1.txt', 'file2.txt')
.catch(e =&gt; {
  console.log('There was a problem with copyFile: ' + e.message);
});
</code></pre>
<p>コールバックや同期関数を使うことも可能ですが、以下の理由から望ましくあ
りません。</p>
<ul>
<li>コールバックは過剰な入れ子に繋がります。これは「コールバック地獄」や「悪夢のピラミッド」として知られています。</li>
<li>同期関数はアプリ中の他のコードの実行を堰き止めてしまいます。</li>
</ul>
<h2 id="非同期なpurescript"><a class="header" href="#非同期なpurescript">非同期なPureScript</a></h2>
<p>PureScriptでに<code>Aff</code>モナドはJavaScriptの<code>async</code>/<code>await</code>構文に似た人間工学を供します。
以下は前と同じ<code>copyFile</code>の例ですが、<code>Aff</code>を使ってPureScriptで書き換えられています。</p>
<pre><code class="language-hs">import Prelude
import Data.Either (Either(..))
import Effect.Aff (Aff, attempt, message)
import Effect.Class.Console (log)
import Node.Encoding (Encoding(..))
import Node.FS.Aff (readTextFile, writeTextFile)
import Node.Path (FilePath)

copyFile :: FilePath -&gt; FilePath -&gt; Aff Unit
copyFile file1 file2 = do
  my_data &lt;- readTextFile UTF8 file1
  writeTextFile UTF8 file2 my_data

main :: Aff Unit
main = do
  result &lt;- attempt $ copyFile &quot;file1.txt&quot; &quot;file2.txt&quot;
  case result of
    Left e -&gt; log $ &quot;There was a problem with copyFile: &quot; &lt;&gt; message e
    _ -&gt; pure unit
</code></pre>
<p>上のコード片をコールバックや同期関数を使って書き換えることも可能ですが
（例えば<code>Node.FS.Async</code>や<code>Node.FS.Sync</code>をそれぞれ使います）、
JavaScriptで前にお話ししたように同じ短所がここでも通用するため、
それらのコーディング形式は推奨されません。</p>
<p><code>Aff</code>を扱う文法は<code>Effect</code>を扱うものと大変似ています。
どちらもモナドですし、したがってdo記法で書くことができます。</p>
<p>例えば<code>readTextFile</code>のシグネチャを見れば、
これがファイルの内容を<code>String</code>とし、<code>Aff</code>に包んで返していることがわかります。</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; FilePath -&gt; Aff String
</code></pre>
<p>do記法中では束縛矢印 (<code>&lt;-</code>) で返却された文字列を「開封」できます。</p>
<pre><code class="language-hs">my_data &lt;- readTextFile UTF8 file1
</code></pre>
<p>それから<code>writeTextFile</code>に文字列引数として渡します。</p>
<pre><code class="language-hs">writeTextFile :: Encoding -&gt; FilePath -&gt; String -&gt; Aff Unit
</code></pre>
<p>上の例で他に目を引く<code>Aff</code>固有の特徴は<code>attempt</code>のみです。
これは<code>Aff</code>のコードの実行中に遭遇したエラーや例外を補足して<code>Either</code>内に保管するものです。</p>
<pre><code class="language-hs">attempt :: forall a. Aff a -&gt; Aff (Either Error a)
</code></pre>
<p>読者ならきっと、前の章から概念の知識を引き出し、
その知識と上の<code>copyFile</code>の例で学んだ新しい<code>Aff</code>パターンを結合することで、
以下の演習に挑戦することができるでしょう。</p>
<h2 id="演習-24"><a class="header" href="#演習-24">演習</a></h2>
<ol>
<li>
<p>（簡単）2つのテキストフ​​ァイルを連結する関数<code>concatenateFiles</code>を書いてください。</p>
</li>
<li>
<p>（普通）入力ファイル名の配列と出力ファイル名が与えられたとき、
複数のテキストファイルを連結する関数 <code>concatenateMany</code>を書いてください。
<strong>ヒント</strong>：<code>traverse</code>を使ってください。</p>
</li>
<li>
<p>（普通）ファイル中の文字数を返すかエラーがあればそれを返す関数<code>countCharacters :: FilePath -&gt; Aff (Either Error Int)</code>を書いてください。</p>
</li>
</ol>
<h2 id="更なるaffの資料"><a class="header" href="#更なるaffの資料">更なるAffの資料</a></h2>
<p>もしまだ<a href="https://pursuit.purescript.org/packages/purescript-aff/">公式のAffガイド</a>を見ていなければ、今ざっと目を通してください。
この章の残りの演習を完了するための事前要件ではありませんが、
Pursuitで何らかの関数を見付けだす助けになるかもしれません。</p>
<p>これらの補足資料についてもあたってみるとよいでしょう。
しかし繰り返しになりますがこの章の演習はそれらの内容に依りません。</p>
<ul>
<li><a href="https://blog.drewolson.org/asynchronous-purescript">DrewのAffに関する投稿</a></li>
<li><a href="https://github.com/JordanMartinez/purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff">更なるAffの説明と例</a></li>
</ul>
<h2 id="httpクライアント"><a class="header" href="#httpクライアント">HTTPクライアント</a></h2>
<p><code>affjax</code>ライブラリは<code>Aff</code>で非同期AJAX HTTP要求を作る便利な手段を提供します。
対象としている環境が何であるかによって、<a href="https://github.com/purescript-contrib/purescript-affjax-web">purescript-affjax-web</a>または<a href="https://github.com/purescript-contrib/purescript-affjax-node">purescript-affjax-node</a>のどちらかのライブラリを使う必要があります。
この章の以降ではNodeを対象としていくので、<code>purescript-affjax-node</code>を使います。
より詳しい使用上の情報は<a href="https://pursuit.purescript.org/packages/purescript-affjax">affjaxのドキュメント</a>にあたってください。
以下は与えられたURLに向けたHTTPのGET要求をし、応答本文ないしエラー文言を返す例です。</p>
<pre><code class="language-hs">import Prelude
import Affjax.Node as AN
import Affjax.ResponseFormat as ResponseFormat
import Data.Either (Either(..))
import Effect.Aff (Aff)

getUrl :: String -&gt; Aff String
getUrl url = do
  result &lt;- AN.get ResponseFormat.string url
  pure case result of
    Left err -&gt; &quot;GET /api response failed to decode: &quot; &lt;&gt; AN.printError err
    Right response -&gt; response.body
</code></pre>
<p>これをREPLで呼び出す際は、<code>launchAff_</code>を<code>Aff</code>からREPLに互換性のある<code>Effect</code>へと変換する必要があります。</p>
<pre><code class="language-shell">$ spago repl

&gt; :pa
… import Prelude
… import Effect.Aff (launchAff_)
… import Effect.Class.Console (log)
… import Test.HTTP (getUrl)
…
… launchAff_ do
…   str &lt;- getUrl &quot;https://reqres.in/api/users/1&quot;
…   log str
…
unit
{&quot;data&quot;:{&quot;id&quot;:1,&quot;email&quot;:&quot;george.bluth@reqres.in&quot;,&quot;first_name&quot;:&quot;George&quot;,&quot;last_name&quot;:&quot;Bluth&quot;, ...}}
</code></pre>
<h2 id="演習-25"><a class="header" href="#演習-25">演習</a></h2>
<ol>
<li>（簡単）HTTPの<code>GET</code>要求を与えられたURLに行い、応答本文をファイルに書き込む関数<code>writeGet</code>を書いてください。</li>
</ol>
<h2 id="並列計算"><a class="header" href="#並列計算">並列計算</a></h2>
<p><code>Aff</code>モナドとdo記法を使って、非同期計算を順番に実行されるように合成する方法を見てきました。
非同期計算を<strong>並列に</strong>合成することもできたら便利でしょう。
<code>Aff</code>があれば2つの計算を次々に開始するだけで並列に計算できます。</p>
<p><code>parallel</code>パッケージは<code>Aff</code>のようなモナドのための型クラス<code>Parallel</code>を定義しており、
並列実行に対応しています。
以前に本書でアプリカティブ関手に出会ったとき、
並列計算を合成するときにアプリカティブ関手がどのように便利なのかを観察しました。
実は<code>Parallel</code>のインスタンスは、（<code>Aff</code>のような）モナド<code>m</code>と、
並列に計算を合成するために使われるアプリカティブ関手<code>f</code>との対応関係を定義しているのです。</p>
<pre><code class="language-hs">class (Monad m, Applicative f) &lt;= Parallel f m | m -&gt; f, f -&gt; m where
  sequential :: forall a. f a -&gt; m a
  parallel :: forall a. m a -&gt; f a
</code></pre>
<p>このクラスは2つの関数を定義しています。</p>
<ul>
<li><code>parallel</code>：モナド <code>m</code>中の計算を取り、アプリカティブ関手<code>f</code>中の計算に
変えます。</li>
<li><code>sequential</code>：反対方向の変換を行います。</li>
</ul>
<p><code>aff</code>ライブラリは <code>Aff</code>モナドの <code>Parallel</code>インスタンスを提供します。
これは、2つの継続 (continuation) のどちらが呼び出されたかを把握することによって、
変更可能な参照を使用して並列に <code>Aff</code>アクションを組み合わせます。
両方の結果が返されたら、最終結果を計算してメインの継続に渡すことができます。</p>
<p>アプリカティブ関手では任意個引数の関数の持ち上げができるので、
このアプリカティブコンビネータを使ってより多くの計算を並列に実行することができます。
<code>traverse</code>や<code>sequence</code>といった、アプリカティブ関手を扱う
すべての標準ライブラリ関数から恩恵を受けることもできます。</p>
<p>必要に応じて <code>parralel</code>と<code>sequential</code>を使って型構築子を変更することで、
do記法ブロック中でアプリカティブコンビネータを使い、
直列的なコードの一部で並列計算を結合したり、
またはその逆を行ったりすることができます。</p>
<p>直列実行と並列実行の間の違いを実演するために、
100個の10ミリ秒の遅延からなる配列をつくり、
それからその遅延を両方の手法で実行します。
REPLで試すと<code>seqDelay</code>が<code>parDelay</code>より遥かに遅いことに気付くでしょう。
並列実行が<code>sequence_</code>を<code>parSequence_</code>で置き換えるだけで有効になることに注目です。</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parSequence_)
import Data.Array (replicate)
import Data.Foldable (sequence_)
import Effect (Effect)
import Effect.Aff (Aff, Milliseconds(..), delay, launchAff_)

delayArray :: Array (Aff Unit)
delayArray = replicate 100 $ delay $ Milliseconds 10.0

seqDelay :: Effect Unit
seqDelay = launchAff_ $ sequence_ delayArray

parDelay :: Effect Unit
parDelay = launchAff_ $ parSequence_ delayArray
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelDelay

&gt; seqDelay -- This is slow
unit

&gt; parDelay -- This is fast
unit
</code></pre>
<p>以下は複数のHTTP要求を並列で行う、より現実味のある例です。
<code>getUrl</code>関数を再利用して2人の利用者から並列で情報を取得します。
この場合では<code>parTarverse</code>（<code>traverse</code>の並列版）が使われていますね。
この例は代わりに<code>traverse</code>でも問題なく動きますがより遅くなるでしょう。</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parTraverse)
import Effect (Effect)
import Effect.Aff (launchAff_)
import Effect.Class.Console (logShow)
import Test.HTTP (getUrl)

fetchPar :: Effect Unit
fetchPar =
  launchAff_ do
    let
      urls = map (\n -&gt; &quot;https://reqres.in/api/users/&quot; &lt;&gt; show n) [ 1, 2 ]
    res &lt;- parTraverse getUrl urls
    logShow res
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelFetch

&gt; fetchPar
unit
[&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:1,\&quot;email\&quot;:\&quot;george.bluth@reqres.in\&quot;, ... }&quot;
,&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:2,\&quot;email\&quot;:\&quot;janet.weaver@reqres.in\&quot;, ... }&quot;
]
</code></pre>
<p>利用できる並列関数の完全な一覧は<a href="https://pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel">Pursuitの<code>parallel</code>のドキュメント</a>で見付かります。
<a href="https://github.com/purescript-contrib/purescript-aff#parallel-execution">parallelのaffのドキュメントの節</a>にもより多くの例が含まれています。</p>
<h2 id="演習-26"><a class="header" href="#演習-26">演習</a></h2>
<ol>
<li>
<p>（簡単）前の<code>concatenateMany</code>関数と同じシグネチャを持つ<code>concatenateManyParallel</code>関数を書いてください。
ただし全ての入力ファイルを並列に読むようにしてください。</p>
</li>
<li>
<p>（普通）与えられたURLへHTTP <code>GET</code>要求を行い以下のいずれかを返す<code>getWithTimeout :: Number -&gt; String -&gt; Aff (Maybe String)</code>関数を書いてください。</p>
<ul>
<li><code>Nothing</code>: 要求してから与えられた時間制限（ミリ秒単位）より長く掛かった場合。</li>
<li>文字列の応答：時間制限を越える前に要求が成功した場合。</li>
</ul>
</li>
<li>
<p>（難しい）「根」のファイルを取り、そのファイルの中の全てのパスの一覧（そして一覧にあるファイルの中の一覧も）の配列を返す<code>recurseFiles</code>関数を書いてください。
一覧になったファイルを並列に読んでください。
パスはそのファイルが表れたディレクトリから相対的なものです。
<strong>ヒント</strong>：<code>node_path</code>モジュールにはディレクトリとやりとりする上で便利な関数があります。</p>
</li>
</ol>
<p>たとえば、次のような<code>root.txt</code>ファイルから始まるとします。</p>
<pre><code class="language-shell">$ cat root.txt
a.txt
b/a.txt
c/a/a.txt

$ cat a.txt
b/b.txt

$ cat b/b.txt
c/a.txt

$ cat b/c/a.txt

$ cat b/a.txt

$ cat c/a/a.txt
</code></pre>
<p>期待される出力は次の通り。</p>
<pre><code class="language-hs">[&quot;root.txt&quot;,&quot;a.txt&quot;,&quot;b/a.txt&quot;,&quot;b/b.txt&quot;,&quot;b/c/a.txt&quot;,&quot;c/a/a.txt&quot;]
</code></pre>
<h2 id="まとめ-7"><a class="header" href="#まとめ-7">まとめ</a></h2>
<p>この章では非同期エフェクトと以下の方法を押さえました。</p>
<ul>
<li><code>aff</code>ライブラリを使って<code>Aff</code>モナド中で非同期コードを走らせる。</li>
<li><code>affjax</code>ライブラリを使って非同期にHTTPリクエストを行う。</li>
<li><code>parallel</code>ライブラリを使って並列に非同期コードを走らせる。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部関数インタフェース"><a class="header" href="#外部関数インタフェース">外部関数インタフェース</a></h1>
<h2 id="この章の目標-8"><a class="header" href="#この章の目標-8">この章の目標</a></h2>
<p>この章でPureScriptの<strong>外部関数インターフェース</strong> (foreign function interface; FFI) を紹介します。
これによりPureScriptコードからJavaScriptコードへの呼び出し、およびその逆が可能になります。
これから扱うのは次のようなものです。</p>
<ul>
<li>純粋で、作用のある、非同期なJavaScript関数をPureScriptから呼び出す。</li>
<li>型付けされていないデータを扱う。</li>
<li><code>argonaut</code>パッケージを使ってJSONに符号化したりJSONを構文解析したりする。</li>
</ul>
<p>この章の終わりにかけて、住所録の例に立ち返ります。
この章の目的は、FFIを使ってアプリケーションに次の新しい機能を追加することです。</p>
<ul>
<li>利用者にポップアップ通知で警告する。</li>
<li>フォームのデータを直列化してブラウザのローカルストレージに保存し、アプ
リケーションが再起動したときにそれを再読み込みする</li>
</ul>
<p>いくつかの一般にはそこまで重用されない追加の話題を押さえた補遺もあります。
自由にこれらの節を読んで構いませんが、
学習目標にあまり関係しなければ本の残りを読み進める妨げにならないようにしてください。</p>
<ul>
<li>実行時のPureScriptの値の表現を理解する。</li>
<li>JavaScriptからPureScriptを呼び出す。</li>
</ul>
<h2 id="プロジェクトの準備-7"><a class="header" href="#プロジェクトの準備-7">プロジェクトの準備</a></h2>
<p>このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。
今回もそれぞれのディレクトリから適切なソースファイルがソースファイルに含められています。</p>
<p>この章は<code>argonaut</code>ライブラリを依存関係として導入しています。
このライブラリはJSONに符号化したりJSONを復号化したりするために使います。</p>
<p>この章の演習は<code>test/MySolutions.purs</code>に書き、
<code>spago test</code>を走らせることによって<code>test/Main.purs</code>中の単体試験に対して確認することができます。</p>
<p>住所録アプリは<code>parcel src/index.html --open</code>で立ち上げることができます。
8章と同じ作業の流れを使っているので、より詳しい説明についてはそちらの章を参照してください。</p>
<h2 id="免責事項"><a class="header" href="#免責事項">免責事項</a></h2>
<p>JavaScriptを扱う作業をできる限り簡単にするため、
PureScriptは直感的な外部関数インタフェースを提供します。
しかしながら、FFIはPureScriptの<strong>高度な</strong>機能であることには留意していただきたいと思います。
FFIを安全かつ効率的に使用するには、
扱うつもりであるデータの実行時の表現についてよく理解していなければなりません。
この章では、PureScriptの標準ライブラリのコードに付いて回る
そのような理解を与えることを目指しています。</p>
<p>PureScriptのFFIはとても柔軟に設計されています。
実際には、外部関数に最低限の型だけを与えるか、
それとも型システムを利用して外部のコードの誤った使い方を防ぐようにするか、
開発者が選ぶことができるということを意味しています。
標準ライブラリのコードは、後者の手法を好む傾向にあります。</p>
<p>簡単な例としては、
JavaScriptの関数で戻り値が <code>null</code>にならないことを保証することはできません。
実のところ、JavaScriptらしさのあるコードはかなり頻繁に <code>null</code>を返します！
しかし、大抵PureScriptの型にnull値が巣喰うことはありません。
そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するときは、
これらの特殊な場合を適切に処理するのは開発者の責任です。</p>
<h2 id="purescriptからjavascriptを呼び出す"><a class="header" href="#purescriptからjavascriptを呼び出す">PureScriptからJavaScriptを呼び出す</a></h2>
<p>PureScriptからJavaScriptコードを使用する最も簡単な方法は、
<strong>外部インポート宣言</strong> (foreign import declaration) を使用し、
既存のJavaScriptの値に型を与えることです。
外部インポート宣言には<strong>外部JavaScriptモジュール</strong> (foreign JavaScript module) から
<strong>エクスポート</strong>された対応するJavaScriptでの宣言がなくてはなりません。</p>
<p>たとえば、特殊文字をエスケープすることによりURIのコンポーネントを符号化するJavaScriptの
<code>encodeURIComponent</code>関数について考えてみます。</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p><code>null</code>でない文字列から <code>null</code>でない文字列への関数であり、副作用を持っていないので、この関数はその型 <code>String -&gt; String</code>について適切な実行時表現を持っています。</p>
<p>次のような外部インポート宣言を使うと、この関数に型を割り当てることができます。</p>
<pre><code class="language-haskell">module Test.URI where

foreign import _encodeURIComponent :: String -&gt; String
</code></pre>
<p>インポートしてくるための外部JavaScriptモジュールを書く必要もあります。
対応する外部JavaScriptモジュールは同名で拡張子が<code>.purs</code>から<code>.js</code>に変わったものです。
上のPureScriptモジュールが<code>URI.purs</code>として保存されているなら、
外部JavaScriptモジュールは<code>URI.js</code>として保存されます。
<code>encodeURIComponent</code>は既に定義されているので、<code>_encodeURIComponent</code>としてエクスポートせねばなりません。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

export const _encodeURIComponent = encodeURIComponent;
</code></pre>
<p>バージョン0.15からPureScriptはJavaScriptと通訳する際にESモジュールシステムを使います。
ESモジュールではオブジェクトに<code>export</code>キーワードを与えることで関数と値はモジュールからエクスポートされます。</p>
<p>これら2つの部品を使うことで、PureScriptで書かれた関数のように、
PureScriptから<code>encodeURIComponent</code>関数を使うことができます。
例えばPSCiで上記の計算を再現できます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; _encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>外部モジュールに自前の関数を定義することもできます。
以下は<code>Number</code>を平方する自前のJavaScript関数を作って呼び出す方法の一例です。</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

export const square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="多変数関数"><a class="header" href="#多変数関数">多変数​関数</a></h2>
<p>第2章の<code>diagonal</code>関数を外部モジュールで書き直してみましょう。
この関数は直角三角形の対角線を計算します。</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>PureScriptの関数は<strong>カリー化</strong>されていることを思い出してください。
<code>diagonal</code>は<code>Number</code>を取って<strong>関数</strong>を返す関数です。
そして返された関数は<code>Number</code>を取って<code>Number</code>を返します。</p>
<pre><code class="language-js">export const diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>もしくはES6の矢印構文ではこうです（後述するES6についての補足を査証してください）。</p>
<pre><code class="language-js">export const diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="カリー化されていない関数"><a class="header" href="#カリー化されていない関数">カリー化されていない関数</a></h2>
<p>JavaScriptでカリー化された関数を書くことは、
ただでさえJavaScriptらしいものではない上に、常に可能というわけでもありません。
よくある多変数なJavaScriptの関数は<strong>カリー化されていない</strong>形式を取るでしょう。</p>
<pre><code class="language-js">export const diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>モジュール<code>Data.Function.Uncurried</code>は<strong>ラッパー</strong>型と
カリー化されていない関数を取り扱う関数をエクスポートします。</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>型構築子<code>Fn2</code>を調べると以下です。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code>は3つの型引数を取ります。
<code>Fn2 a b c</code>は、型 <code>a</code>と <code>b</code>の2つの引数、
返り値の型 <code>c</code>をもつカリー化されていない関数の型を表現しています。
これを使って外部モジュールから<code>diagonalUncurried</code>をインポートしました。</p>
<p>カリー化されていない関数と引数を取る<code>runFn2</code>で呼び出すことができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p><code>functions</code>パッケージでは0引数から10引数までの関数について同様の型構築子が定義されています。</p>
<h2 id="カリー化されていない関数についての補足"><a class="header" href="#カリー化されていない関数についての補足">カリー化されていない関数についての補足</a></h2>
<p>PureScriptのカリー化された関数にはもちろん利点があります。
部分的に関数を適用することができ、関数型に型クラスインスタンスを与えられます。
しかし効率上の代償も付いてくるのです。
効率性が決定的に重要なコードでは多変数を受け付けるカリー化されていないJavaScript関数を定義する必要が時々あります。</p>
<p>PureScriptでカリー化されていない関数を作ることもできます。
2引数の関数については<code>mkFn2</code>関数が使えます。</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>前と同様に<code>runFn2</code>関数を使うと、カリー化されていない2引数の関数を適用することができます。</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>ここで重要なのは、引数がすべて適用されるなら、コンパイラは <code>mkFn2</code>関数や
<code>runFn2</code>関数を<strong>インライン化</strong>するということです。そのため、生成されるコードはとてもコンパクトになります。</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>対照的に、こちらがこれまでのカリー化された関数です。</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>そして生成結果のコードが以下です。
入れ子の関数のため比較的簡潔ではありません。</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="現代的なjavascriptの構文についての補足"><a class="header" href="#現代的なjavascriptの構文についての補足">現代的なJavaScriptの構文についての補足</a></h2>
<p>前に見た矢印関数構文はES6の機能であり、そのためいくつかの古いブラウザ（名指しすればIE11）と互換性がありません。
執筆時点でWebブラウザをまだ更新していない<a href="https://caniuse.com/#feat=arrow-functions">6%の利用者が矢印関数を使うことができないと推計</a>されています。</p>
<p>ほとんどの利用者にとって互換性があるようにするため、
PureScriptコンパイラによって生成されるJavaScriptコードは矢印関数を使っていません。
また、同じ理由で<strong>公開するライブラリでも矢印関数を避ける</strong>ことが推奨されます。</p>
<p>それでも自分のFFIコードで矢印関数を使うこともできますが、
デプロイの作業工程でES5に互換性のある関数に変換するために<a href="https://github.com/babel/babel#intro">Babel</a>などのツールを含めるべきです。</p>
<p>ES6の矢印関数がより読みやすく感じたら<a href="https://github.com/lebab/lebab">Lebab</a>のようなツールを使ってコンパイラの<code>output</code>ディレクトリにJavaScriptのオードを変換することができます。</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>この操作により上の<code>curriedAdd</code>関数は以下に変換されます。</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>本書の残りの例では入れ子の関数の代わりに矢印関数を使います。</p>
<h2 id="演習-27"><a class="header" href="#演習-27">演習</a></h2>
<ol>
<li>（普通）<code>Test.MySolutions</code>モジュールの中に箱の体積を求めるJavaScriptの関数<code>volumeFn</code>を書いてください。
<code>Data.Function.Uncurried</code>の<code>Fn</code>ラッパーを使ってください。</li>
<li>（普通）<code>volumeFn</code>を矢印関数を使って書き直し、<code>volumeArrow</code>としてください。</li>
</ol>
<h2 id="単純な型を渡す"><a class="header" href="#単純な型を渡す">単純な型を渡す</a></h2>
<p>以下のデータ型はPureScriptとJavaScriptの間でそのまま渡し合うことができます。</p>
<div class="table-wrapper"><table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
</div>
<p><code>String</code>と<code>Number</code>という原始型の例は既に見てきました。
ここから<code>Array</code>や<code>Record</code>（JavaScriptでは<code>Object</code>）といった構造的な型を眺めていきます。</p>
<p><code>Array</code>の受け渡しを実演するために、
以下に<code>Int</code>の<code>Array</code>を取って別の配列として累計の和を返すJavaScriptの関数の呼び出し方を示します。
JavaScriptは<code>Int</code>のための分離した型を持たないため、PureScriptでの<code>Int</code>と<code>Number</code>はJavaScriptでの<code>Number</code>に翻訳される点を思い起こしてください。</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">export const cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p><code>Record</code>の受け渡しを実演するために、以下に2つの<code>Complex</code>な数をレコードとして取り、和を別のレコードとして返すJavaScriptの呼び出し方を示します。
PureScriptでの<code>Record</code>がJavaScriptでは<code>Object</code>として表現されることに注意してください。</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">export const addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>なお、上の手法にはJavaScriptが期待通りの型を返すことへの信頼を要します。
PureScriptはJavaScriptのコードに型検査を適用することができないからです。
この型安全性の配慮について後のJSONの節でより詳しく記述していきます。
型の不整合から身を守る手法についても押さえます。</p>
<h2 id="演習-28"><a class="header" href="#演習-28">演習</a></h2>
<ol>
<li>（普通）<code>Complex</code>の数の配列を取って別の複素数の配列として累計の和を返すJavaScriptの関数<code>cumulativeSumsComplex</code>（と対応するPureScriptの外部インポート）を書いてください。</li>
</ol>
<h2 id="単純な型を越えて"><a class="header" href="#単純な型を越えて">単純な型を越えて</a></h2>
<p><code>String</code>、<code>Number</code>、<code>Array</code>、そして<code>Record</code>といったJavaScript固有の表現を持つ型をFFI越しに送ったり受け取ったりする方法を数例見てきました。
ここから<code>Maybe</code>のようなPureScriptで使えるいくつかの他の型の使い方を押さえていきます。</p>
<p>外部宣言を使用して、配列についての <code>head</code>関数を改めて作成したいとしましょう。
JavaScriptでは次のような関数を書くことになるでしょう。</p>
<pre><code class="language-javascript">export const head = arr =&gt;
  arr[0];
</code></pre>
<p>この関数をどう型付けましょうか？
型 <code>forall a. Array a -&gt; a</code>を与えようとしても、空の配列に対してこの関数は <code>undefined</code>を返します。
したがって型<code>forall a. Array a -&gt; a</code>は正しくこの実装を表現していないのです。</p>
<p>代わりにこのコーナーケースを扱うために<code>Maybe</code>値を返したいところです。</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>しかしどうやって<code>Maybe</code>を返しましょうか。
つい以下のように書きたくなります。</p>
<pre><code class="language-js">// こうしないでください
import Data_Maybe from '../Data.Maybe'

export const maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>外部モジュールで直接<code>Data.Maybe</code>モジュールをインポートして使うことはお勧めしません。
というのもコードがコード生成器の変化に対して脆くなるからです。
<code>create</code>や<code>value</code>は公開のAPIではありません。
加えて、このようにすることは不要なコードの消去のための<code>purs bundle</code>を使う際に問題を引き起こしえます。</p>
<p>推奨されるやり方はFFIで定義された関数に余剰の引数を加えて必要な関数を受け付けることです。</p>
<pre><code class="language-js">export const maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>ただし、次のように書きますが、</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>以下ではないことに注意です。</p>
<pre><code class="language-hs">forall a. ( a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>どちらの形式でも動きますが、後者は<code>Just</code>と<code>Nothing</code>の場所での招かれざる入力により晒されやすくなります。
例えばより脆弱な場合では以下のようにして呼ぶことができます。</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>これはいかなる配列についても<code>Just 1000</code>を返します。
この脆弱性は<code>a</code>が<code>Int</code>のときに（これは入力の配列に基づきます）<code>(\_ -&gt; Just 1000)</code>と<code>Just 1000</code>がシグネチャ<code>(a -&gt; Maybe a)</code>と<code>Maybe a</code>にそれぞれ合致しているために許されているのです。</p>
<p>より安全な型シグネチャでは入力の配列に基づいて<code>a</code>が<code>Int</code>に決定されたとしても、<code>forall x</code>に絡むシグネチャに合致する妥当な関数を提供する必要があります。
<code>(forall x. Maybe x)</code>の <em>唯一</em> の選択肢は<code>Nothing</code>ですが、それは<code>Just</code>値が<code>x</code>の型を前提にしてしまい、するともはや全ての<code>x</code>については妥当でなくなってしまうからです。
<code>(forall x. x -&gt; Maybe x)</code>の唯一の選択肢は<code>Just</code>（望んでいる引数）と<code>(\_ -&gt; Nothing)</code>であり、後者は唯一残っている脆弱性になるのです。</p>
<h2 id="外部型の定義"><a class="header" href="#外部型の定義">外部型の定義</a></h2>
<p><code>Maybe a</code>を返す代わりに実は<code>arr[0]</code>を返したいのだとしましょう。
型<code>a</code>ないし<code>undefined</code>値（ただ<code>null</code>ではありません）のいずれかの値を表現する型がほしいです。
この型を<code>Undefined a</code>と呼びましょう。</p>
<p><strong>外部インポート宣言</strong>を使うと、<strong>外部型</strong> (foreign type) を定義することができます。
構文は外部関数を定義するのと似ています。</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>このキーワード<code>data</code>は型を定義していることを表しています。
値ではありせん。
型シグネチャの代わりに、新しい型の<strong>種</strong>を与えます。
この場合は<code>Undefined</code>の種が <code>Type -&gt; Type</code>であると宣言しています。
言い換えれば<code>Undefined</code>は型構築子です。</p>
<p>これで元の<code>head</code>の定義を単に再利用することができます。</p>
<pre><code class="language-javascript">export const undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>PureScriptモジュールには以下を追加します。</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p><code>undefinedHead</code>関数の本体は<code>undefined</code>かもしれない<code>arr[0]</code>を返します。
そしてこの型シグネチャはその事実を正しく反映しています。</p>
<p>この関数はその型の適切な実行時表現を持っていますが、
型 <code>Undefined a</code>の値を使用する方法がありませんので、まったく役に立ちません。
いや、言い過ぎました。
別のFFIでこの型を使えますからね。</p>
<p>値が未定義かどうかを教えてくれる関数を書くことができます。</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>外部JavaScriptモジュールで次のように定義できます。</p>
<pre><code class="language-javascript">export const isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>これでPureScriptで <code>isUndefined</code>と <code>undefinedHead</code>を一緒に使用すると、
便利な関数を定義することができます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>このように、定義したこの外部関数はとても簡単です。
つまりPureScriptの型検査器を使うことによる利益が最大限得られるのです。
一般に、外部関数は可能な限り小さく保ち、できるだけアプリケーションの処理はPureScriptコードへ移動しておくことをおすすめします。</p>
<h2 id="例外-1"><a class="header" href="#例外-1">例外</a></h2>
<p>他の選択肢としては、空の配列の場合に例外を投げる方法があります。
厳密に言えば、純粋な関数は例外を投げるべきではありませんが、それをする柔軟さはあります。
安全性に欠けていることを関数名で示します。</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>JavaScriptモジュールでは、 <code>unsafeHead</code>を以下のように定義することができます。</p>
<pre><code class="language-javascript">export const unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="演習-29"><a class="header" href="#演習-29">演習</a></h2>
<ol>
<li>
<p>（普通）二次多項式<code>a*x^2 + b*x + c = 0</code>を表現するレコードが与えられているとします。</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>二次多項式を使ってこの多項式の根を求めるJavaScriptの関数<code>quadraticRootsImpl</code>とそのラッパーの<code>quadraticRoots :: Quadratic -&gt; Pair Complex</code>を書いてください。
2つの根を<code>Complex</code>の数の<code>Pair</code>として返してください。
<em>ヒント</em> ：<code>quadraticRoots</code>ラッパーを使って<code>Pair</code>の構築子を<code>quadraticRootsImpl</code>に渡してください。</p>
</li>
<li>
<p>（普通）関数<code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>を書いてください。
この関数は<code>undefined</code>を<code>Nothing</code>に、<code>a</code>の値を<code>Just a</code>に変換します。</p>
</li>
<li>
<p>（難しい）<code>toMaybe</code>が備わっていれば<code>maybeHead</code>を以下に書き換えられます。</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>これは前の実装よりも良い手法なのでしょうか。
<strong>補足</strong>：この演習のための単体試験はありません。</p>
</li>
</ol>
<h2 id="型クラスメンバー関数を使う"><a class="header" href="#型クラスメンバー関数を使う">型クラスメンバー関数を使う</a></h2>
<p>ちょうど前にFFIを越えて<code>Maybe</code>の構築子を渡す手引きをしましたが、
今回はJavaScriptを呼び出すPureScriptを書く別の場合です。
JavaScriptの呼び出しでも続けざまにPureScriptの関数を呼び出します。
ここでは型クラスのメンバー関数のFFIを越えた渡し方を探ります。</p>
<p>型<code>x</code>に合う適切な<code>show</code>のインスタンスを期待する外部JavaScript関数を書くことから始めます。</p>
<pre><code class="language-js">export const boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + &quot;!!!&quot;;
</code></pre>
<p>それから対応するシグネチャを書きます。</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>そして<code>show</code>の正しいインスタンスを渡すラッパー関数も書きます。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>代わりにポイントフリー形式だとこうです。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>そうしてラッパーを呼び出すことができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 &quot;Hat&quot;)
&quot;(TUPLE 1 \&quot;HAT\&quot;)!!!&quot;
</code></pre>
<p>以下は複数の関数を渡すことを実演する別の例です。
これらの関数には複数引数関数 (<code>eq</code>) が含まれます。</p>
<pre><code class="language-js">export const showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return &quot;Equivalent&quot;;
  } else {
    return show(a) + &quot; is not equal to &quot; + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
&quot;Nothing is not equal to (Just 5)&quot;
</code></pre>
<h2 id="作用のある関数"><a class="header" href="#作用のある関数">作用のある関数</a></h2>
<p><code>bold</code>関数を拡張してコンソールにログ出力するようにしましょう。
ログ出力は<code>Effect</code>であり、<code>Effect</code>はJavaScriptで無引数関数として表現されます。
つまり<code>()</code>と矢印記法だとこうです。</p>
<pre><code class="language-js">export const yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + &quot;!!!&quot;);
</code></pre>
<p>新しい外部インポートは返る型が<code>String</code>から<code>Effect Unit</code>に変わった点以外は以前と同じです。</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>REPLで試すと文字列が（引用符で囲まれず）直接コンソールに印字され<code>unit</code>値が返ることに気付きます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 &quot;Hat&quot;)
(TUPLE 1 &quot;HAT&quot;)!!!
unit
</code></pre>
<p><code>Effect.Uncurried</code>に<code>EffectFn</code>ラッパーというものもあります。
これらは既に見た<code>Data.Function.Uncurried</code>の<code>Fn</code>ラッパーに似ています。
これらのラッパーがあればカリー化されていない作用のある関数をPureScriptで呼び出すことができます。</p>
<p>一般的にこれらを使うのは、
こうしたAPIをカリー化された関数に包むのではなく、
既存のJavaScriptライブラリのAPIを直接呼び出したいときぐらいです。
したがってカリー化していない<code>yell</code>の例を見せてもあまり意味がありません。
というのもJavaScriptがPureScriptの型クラスのメンバーに依っているからで、
さらにそれは既存のJavaScriptの生態系にそのメンバーが見付からないためです。</p>
<p>その代わりに以前の<code>diagonal</code>の例を変更し、結果を返すことに加えてログ出力を含めるとこうなります。</p>
<pre><code class="language-js">export const diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log(&quot;Diagonal is &quot; + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="非同期関数"><a class="header" href="#非同期関数">非同期関数</a></h2>
<p>JavaScriptのプロミスは<code>aff-promise</code>ライブラリの助けを借りて直接PureScriptの非同期作用に翻訳されます。
より多くの情報についてはライブラリの<a href="https://pursuit.purescript.org/packages/purescript-aff-promise">ドキュメント</a>をあたってください。
ここではいくつかの例に触れるだけとします。</p>
<p>JavaScriptの<code>wait</code>プロミス（または非同期関数）をPureScriptのプロジェクトで使いたいとします。
<code>ms</code>ミリ秒分だけ送らせて実行させるのに使うことができます。</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>単に<code>Effect</code>（無引数関数）に包んで公開するだけでよいです。</p>
<pre><code class="language-js">export const sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>そして以下のようにインポートします。</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>そうしてこの<code>Promise</code>を<code>Aff</code>ブロック中で以下のように走らせることができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
… launchAff_ do
…   log &quot;waiting&quot;
…   sleep 300
…   log &quot;done waiting&quot;
…
waiting
unit
done waiting
</code></pre>
<p>REPLでの非同期ログ出力はブロック全体が実行を終了するまで印字するのを待つ点に注意しましょう。
このコードは<code>spago test</code>で走らせたときは、印字の <em>合間に</em> 僅かな遅延があり、より予測に近い振舞いをします。</p>
<p>プロミスから値を返す別の例を見てみましょう。
この関数は<code>async</code>と<code>await</code>を使って書かれていますが、
これはプロミスの糖衣構文に過ぎません。</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

export const diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p><code>Number</code>を返すため、この型を<code>Promise</code>と<code>Aff</code>のラッパーの中に表します。</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
… launchAff_ do
…   res &lt;- diagonalAsync 300 3.0 4.0
…   logShow res
…
unit
5.0
</code></pre>
<h2 id="演習-30"><a class="header" href="#演習-30">演習</a></h2>
<p>上の節の演習はまだやるべきこと一覧にあります。
もし何か良い演習の考えがあればご提案ください。</p>
<h2 id="json-1"><a class="header" href="#json-1">JSON</a></h2>
<p>アプリケーションでJSONを使うことには多くの理由があります。
例えばWebのAPIと疎通するよくある手段であるためです。
この節では他の用例についてもお話ししましょう。
構造的なデータをFFI越しに渡す際の型安全性を向上させる手法から始めます。</p>
<p>少し前のFFI関数<code>cumulativeSums</code>と<code>addComplex</code>を再訪し、
それぞれに1つバグを混入させてみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push(&quot;Broken&quot;); // Bug
  return sums;
};

export const addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>返る型が正しくない事実があるにも関わらず、
元の型シグネチャを使うことができ、コードはそれでもコンパイルされます。</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>コードを実行することさえ可能で、そうすると予期しない結果を生み出すか実行時エラーになります。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>例えば結果の<code>sums</code>はもはや正しい<code>Array Int</code>ではありませんが、
これは<code>String</code>が配列に含まれているからです。
そして更なる操作は即時のエラーではなく予期しない振舞いを生み出します。
というのもこれらの<code>sums</code>の<code>sum</code>は<code>10</code>ではなく<code>0</code>だからです。
これでは捜索の難しいバグになりかねませんね。</p>
<p>同様に<code>addComplexBroken</code>を呼び出すときは1つもエラーが出ません。
しかしながら<code>Complex</code>の結果の<code>imag</code>フィールドにアクセスすると予期しない振舞い（<code>7.0</code>ではなく<code>Nan</code>を返すため）やはっきりしない実行時エラーを生じることでしょう。</p>
<p>PureScriptのコードにバグ一匹通さないようにするため、JavaScriptのコードでJSONを使いましょう。</p>
<p><code>argonaut</code>ライブラリには必要としているJSONの復号化と符号化の機能が備わっています。
このライブラリには素晴らしい<a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">ドキュメント</a>があるので、本書では基本的な用法だけを押さえます。</p>
<p>返る型を<code>Json</code>として定義するようにして、代わりとなる外部インポートをつくるとこうなります。</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>単純に既存の壊れた関数を指し示しているだけである点に注意します。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSumsBroken
export const addComplexJson = addComplexBroken
</code></pre>
<p>そして返された<code>Json</code>の値を復号化するラッパーを書きます。</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>それから返る型への復号が成功しなかったどんな値も<code>Left</code>の<code>String</code>なエラーとして表れます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left &quot;Couldn't decode Array (Failed at index 3): Value is not a Number&quot;)

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left &quot;JSON was missing expected field: imag&quot;)
</code></pre>
<p>うまく動くバージョンで呼び出すと<code>Right</code>の値が返ります。</p>
<p>次のREPLブロックを走らせる前に、うまく動くバージョンを指し示すように<code>test/Examples.js</code>に以下の変更を加えて、これを手元で試してみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSums
export const addComplexJson = addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>JSONを使うことは、<code>Map</code>や<code>Set</code>のような他の構造的な型をFFI越しに渡す最も簡単な方法でもあります。
ただしJSONは真偽値、数値、文字列、配列、そして他のJSONの値からなるオブジェクトのみから構成されるため、JSONでは直接<code>Map</code>や<code>Set</code>を書くことができません。
しかしこれらの構造を配列として表現することはでき（キーとバリューもまたJSONで表現されているとします）、それから<code>Map</code>や<code>Set</code>に復号し直すことができるのです。</p>
<p>以下は<code>String</code>のキーと<code>Int</code>のバリューからなる<code>Map</code>を変更する外部関数シグネチャと、それに伴うJSONの符号化と復号化を扱うラッパー関数の例です。</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>関数合成の絶好の用例になっていますね。
これらの両方の代替案は上のものと等価です。</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>以下はJavaScriptでの実装です。
<code>Array.from</code>の工程が、復号の前にJavaScriptの<code>Map</code>をJSONに親和性のある形式に変換し、PureScriptの<code>Map</code>に変換し直すために必須である点に注意してください。</p>
<pre><code class="language-js">export const mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set(&quot;Foo&quot;, 42);
  return Array.from(m);
};
</code></pre>
<p>これで<code>Map</code>をFFI越しに送ったり受け取ったりできます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple &quot;hat&quot; 1, Tuple &quot;cat&quot; 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple &quot;Foo&quot; 42),(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)]))
</code></pre>
<h2 id="演習-31"><a class="header" href="#演習-31">演習</a></h2>
<ol>
<li>
<p>（普通）<code>Map</code>中の全ての値の<code>Set</code>を返すJavaScriptの関数とPureScriptのラッパー<code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code>を書いてください。</p>
</li>
<li>
<p>（簡単）より広い種類のマップに関して動作するよう、前のJavaScriptの関数の新しいラッパーを書いてください。シグネチャは<code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code>です。
なお<code>k</code>と<code>v</code>にいくつかの型クラス制約を加える必要があるでしょう。
コンパイラが導いてくれます。</p>
</li>
<li>
<p>（普通）少し前の<code>quadraticRoots</code>を書き換えて<code>quadraticRootSet</code>としてください。
この関数は<code>Complex</code>の根をJSONを介して（<code>Pair</code>の代わりに）<code>Set</code>として返します。</p>
</li>
<li>
<p>（難しい）少し前の<code>quadraticRoots</code>を書き換えて<code>quadraticRootsSafe</code>としてください。
この関数はJSONを使って<code>Complex</code>の根の<code>Pair</code>をFFI越しに渡します。
JavaScriptでは<code>Pair</code>構築子を使わないでください。
ただしその代わりに復号器に互換性のある形式で対を返すだけにしてください。
<strong>ヒント</strong>：<code>DecodeJson</code>インタンスを<code>Pair</code>に書く必要があるでしょう。
自前の復号インスタンスを書く上での説明については<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonautのドキュメント</a>をあたってください。
<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a>インスタンスも参考になるかもしれません。
「孤立インスタンス」を作ることを避けるために、<code>Pair</code>に<code>newtype</code>ラッパーが必要になる点に注意してください。</p>
</li>
<li>
<p>（普通）2次元配列を含むJSON文字列を構文解析して復号する<code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code>関数を書いてください。
例えば<code>&quot;[[1, 2, 3], [4, 5], [6]]&quot;</code>です。
<strong>ヒント</strong>：復号の前に<code>jsonParser</code>を使って<code>String</code>を<code>Json</code>に変換する必要があるでしょう。</p>
</li>
<li>
<p>（普通）以下のデータ型は値が葉にある二分木を表現します。</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>汎化された<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを<code>Tree</code>型に導出してください。
このやり方についての説明は<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonautのドキュメント</a>をあたってください。
なお、この演習の単体試験を有効にするには汎化された<code>Show</code>及び<code>Eq</code>インスタンスも必要になります。
しかしJSONのインスタンスと格闘したあとではこれらの実装は直感的に進むでしょう。</p>
</li>
<li>
<p>（難しい）以下の<code>data</code>型は整数か文字列かでJSONで異なって表現されます。</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>この振舞いを実装する<code>IntOrString</code>データ型に<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを書いてください。
<strong>ヒント</strong>：<code>Control.Alt</code>の<code>alt</code>演算子が役立つかもしれません。</p>
</li>
</ol>
<h2 id="住所録"><a class="header" href="#住所録">住所録</a></h2>
<p>この節では新しく獲得したFFIとJSONの知識を適用して第8章の住所録の例を構築していきたいと思います。以下の機能を加えていきます。</p>
<ul>
<li>保存ボタンをフォームの底に置き、クリックしたときにフォームの状態をJSON
に直列化してローカルストレージに保存します。</li>
<li>ページの再読み込み時にローカルストレージからJSON文書を自動的に取得しま
す。フォームのフィールドにはこの文書の内容を入れます。</li>
<li>フォームの状態を保存したり読み込んだりするのに問題があればポップアップ
の警告を出します。</li>
</ul>
<p><code>Effect.Storage</code>モジュールに以下のWebストレージAPIのためのFFIラッパーをつくることから始めていきます。</p>
<ul>
<li><code>setItem</code>はキーと値（両方とも文字列）を受け取り、指定されたキーでロー
カルストレージに値を格納する計算を返します。</li>
<li><code>getItem</code>はキーを取り、ローカルストレージから関連付けられたバリューの
取得を試みます。しかし<code>window.localStorage</code>の<code>getItem</code>メソッドは
<code>null</code>を返しうるので、返る型は<code>String</code>ではなく<code>Json</code>です。</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>以下はこれらの関数に対応するJavaScriptの実装で、<code>Effect/Storage.js</code>にあります。</p>
<pre><code class="language-js">export const setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

export const getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>以下のように保存ボタンを作ります。</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: &quot;form-group row col-form-label&quot;
    , children:
        [ D.button
            { className: &quot;btn-primary btn&quot;
            , onClick: handler_ validateAndSave
            , children: [ D.text &quot;Save&quot; ]
            }
        ]
    }
</code></pre>
<p>そして<code>validateAndSave</code>関数中では、検証された<code>person</code>をJSON文字列とし、<code>setItem</code>を使って書き込みます。</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log &quot;Running validators&quot;
  case validatePerson' person of
    Left errs -&gt; log $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;
    Right validPerson -&gt; do
      setItem &quot;person&quot; $ stringify $ encodeJson validPerson
      log &quot;Saved&quot;
</code></pre>
<p>なおこの段階でコンパイルしようとすると以下のエラーに遭遇します。</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>これはなぜかというと<code>Person</code>レコード中の<code>PhoneType</code>が<code>EncodeJson</code>インスタンスを必要としているからです。
単純に汎用符号化インスタンスと復号化インスタンスを導出すれば完了です。
この仕組みについてより詳しくはargonautのドキュメントで見られます。</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance genericPhoneType :: Generic PhoneType _

instance encodeJsonPhoneType :: EncodeJson PhoneType where encodeJson = genericEncodeJson
instance decodeJsonPhoneType :: DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>これで<code>person</code>をローカルストレージに保存できます。
しかしデータを取得できない限りあまり便利ではありません。
次はそれに取り掛かりましょう。</p>
<p>ローカルストレージから「person」文字列を取得することから始めましょう。</p>
<pre><code class="language-hs">item &lt;- getItem &quot;person&quot;
</code></pre>
<p>それからローカルストレージから<code>Person</code>レコードへの文字列の変換を扱うお助け関数をつくります。
なおこのストレージ中の文字列は<code>null</code>かもしれないので、うまく<code>String</code>として復号化されるまでは外部の<code>Json</code>として表現します。
道中には他にも多くの変換工程があり、それぞれで<code>Either</code>の値を返します。
そのためこれらを<code>do</code>ブロックの中にまとめるのは理に適っています。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>そうしてこの結果が成功しているかどうか調べます。
もし失敗していればエラーをログ出力し既定の<code>examplePerson</code>を使います。
そうでなければローカルストレージから取得した人物を使います。</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>最後にこの<code>initialPerson</code>を<code>props</code>レコードを介してコンポーネントに渡します。</p>
<pre><code class="language-hs">-- Create JSX node from react component.
app = element addressBookApp { initialPerson }
</code></pre>
<p>そして状態フックで使うために別の方から拾い上げます。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>仕上げとして、それぞれの<code>Left</code>値の<code>String</code>に<code>lmap</code>を使って前置し、エラー文言の質を向上させます。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap (&quot;No string in local storage: &quot; &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap (&quot;Cannot parse JSON string: &quot;   &lt;&gt; _) $ jsonParser jsonString
  lmap               (&quot;Cannot decode Person: &quot;       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>最初のエラーのみこのアプリの通常の操作内で起こります。
他のエラーはWebブラウザの開発ツールを開いてローカルストレージ中に保存された「person」文字列を編集し、そのページを参照することで引き起こせます。
どのようにJSON文字列を変更したかが、どのエラーの引き金になるかを決定します。
それぞれのエラーを引き起こせるかどうかやってみてください。</p>
<p>これでローカルストレージについては押さえました。
次に<code>alert</code>アクションを実装していきます。
このアクションは<code>Effect.Console</code>モジュールの<code>log</code>アクションによく似ています。
唯一の相違点は<code>alert</code>アクションが<code>window.alert</code>メソッドを使うことで、
対して<code>log</code>アクションは<code>console.log</code>メソッドを使っています。
そういうわけで<code>alert</code>は<code>window.alert</code>が定義された環境でのみ使うことができます。
例えばWebブラウザなどです。</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">export const alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>この警告が次のいずれかの場合に現れるようにしたいです。</p>
<ul>
<li>利用者が検証エラーを含むフォームを保存しようと試みている。</li>
<li>状態がローカルストレージから取得できない。</li>
</ul>
<p>以上は単に以下の行で<code>log</code>を<code>alert</code>に置き換えるだけで達成できます。</p>
<pre><code class="language-hs">Left errs -&gt; alert $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;

alert $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
</code></pre>
<h2 id="演習-32"><a class="header" href="#演習-32">演習</a></h2>
<ol>
<li>（普通）<code>localStorage</code>オブジェクトの <code>removeItem</code>メソッドのラッパーを書き、
<code>Effect.Storage</code>モジュールに外部関数を追加してください</li>
<li>（普通）「リセット」ボタンを追加してください。
このボタンをクリックすると新しく作った<code>removeItem</code>関数を呼び出して
ローカルストレージから「人物」の項目を削除します。</li>
<li>（簡単）JavaScriptの <code>Window</code>オブジェクトの <code>confirm</code>メソッドのラッパーを書き、
<code>Effect.Alert</code>モジュールにその外部関数を追加してください。</li>
<li>（普通）利用者が「リセット」ボタンをクリックしたときにこの<code>confirm</code>関数を呼び出し、
本当にアドレス帳を白紙にしたいか尋ねるようにしてください。</li>
</ol>
<h2 id="まとめ-8"><a class="header" href="#まとめ-8">まとめ</a></h2>
<p>この章では、PureScriptから外部のJavaScriptコードを扱う方法を学びました。また、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。</p>
<ul>
<li>外部関数が正しい表現を持っていることを確かめる重要性を見てきました。</li>
<li>外部型や<code>Json</code>データ型を使用することによって、null値やJavaScriptの他の
型のデータのような特殊な場合に対処する方法を学びました。</li>
<li>安全にJSONデータを直列化・直列化復元する方法を見ました。</li>
</ul>
<p>より多くの例については、Githubの <code>purescript</code>組織、<code>purescript-contrib</code>組織および
<code>purescript-node</code>組織が、FFIを使用するライブラリの例を多数提供しています。残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾つか見ていきます。</p>
<h2 id="補遺"><a class="header" href="#補遺">補遺</a></h2>
<h3 id="javascriptからpurescriptを呼び出す"><a class="header" href="#javascriptからpurescriptを呼び出す">JavaScriptからPureScriptを呼び出す</a></h3>
<p>少なくとも単純な型を持った関数については、JavaScriptからPureScript関数を呼び出すのはとても簡単です。</p>
<p>例として以下のような簡単なモジュールを見てみましょう。</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。
関数を定義するのにPureScriptを使いたくなるかもしれない良い例となっていますが、
JavaScriptからそれを呼び出すためには条件があります。
PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装する開発者は型検証器の恩恵を受けることができます。</p>
<p>この関数をJavaScriptから呼び出す方法を理解するには、PureScriptの関数は常に引数がひとつのJavaScript関数へと変換され、引数へは次のようにひとつづつ適用していかなければならないことを理解するのが重要です。</p>
<pre><code class="language-javascript">import Test from 'Test.js';
Test.gcd(15)(20);
</code></pre>
<p>ここでは、コードがPureScriptモジュールをESモジュールにコンパイルする <code>spago build</code>でコンパイルされていると仮定しています。
そのため、 <code>import</code>を使って <code>Test</code>モジュールをインポートした後、 <code>Test</code>オブジェクトの <code>gcd</code>関数を参照することができました。</p>
<p><code>pulp build -O --to file.js</code>を使用して、ブラウザ用のJavaScriptコードをバンドルすることもできます。
その場合、グローバルなPureScript名前空間から <code>Test</code>モジュールにアクセスします。デフォルトは <code>PS</code>です。</p>
<pre><code class="language-javascript">var Test = PS.Test;
Test.gcd(15)(20);
</code></pre>
<h3 id="名前の生成を理解する"><a class="header" href="#名前の生成を理解する">名前の生成を理解する</a></h3>
<p>PureScriptはコード生成時にできるだけ名前を保存することを目的としています。具体的には、少なくともトップレベルで宣言される名前については、PureScriptやJavaScriptのキーワードでなければほとんどの識別子が保存されます。</p>
<p>識別子としてJavaScriptのキーワードを使う場合は、名前はダブルダラー記号でエスケープされます。たとえば、次のPureScriptコードを考えてみます。</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープされます。たとえば、このPureScriptコードを考えます。</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図している場合、識別子は英数字のみを使用し、JavaScriptの予約語を避けることをお勧めします。
ユーザ定義演算子がPureScriptコードでの使用のために提供される場合でも、JavaScriptから使うための英数字の名前を持った代替関数を提供しておくことをお勧めします。</p>
<h3 id="実行時のデータ表現"><a class="header" href="#実行時のデータ表現">実行時のデータ表現</a></h3>
<p>型はプログラムがある意味で「正しい」ことをコンパイル時に判断できるようにします。つまり、その点については壊れることがありません。しかし、これは何を意味するのでしょうか？PureScriptでは式の型は実行時の表現と互換性がなければならないことを意味します。</p>
<p>そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行時のデータ表現について理解することが重要です。これは、与えられた任意のPureScriptの式について、その値が実行時にどのように評価されるかという挙動を理解できるべきであることを意味しています。</p>
<p>PureScriptの式は、実行時に特に単純な表現を持っているということは朗報です。型を考慮すれば式の実行時のデータ表現を把握することが常に可能です。</p>
<p>単純な型については、対応関係はほとんど自明です。たとえば、式が型 <code>Boolean</code>を持っていれば、実行時のその値 <code>v</code>は <code>typeof v === 'boolean'</code>を満たします。つまり、型 <code>Boolean</code>の式は <code>true</code>もしくは
<code>false</code>のどちらか一方の（JavaScriptの）値へと評価されます。特に<code>null</code>や <code>undefined</code>に評価される型
<code>Boolean</code>のPureScriptの式はありません。</p>
<p><code>Int</code>や<code>Number</code>や<code>String</code>の型の式についても同様のことが成り立ちます。<code>Int</code>や<code>Number</code>型の式は
<code>null</code>でないJavaScriptの数へと評価されますし、 <code>String</code>型の式は
<code>null</code>でないJavaScriptの文字列へと評価されます。たとえ<code>typeof</code>を使うことによって型<code>Number</code>の値と見分けがつかなくなっても、型<code>Int</code>の式は実行時に整数に評価されます。</p>
<p><code>Unit</code>についてはどうでしょうか？<code>Unit</code>には現住 (<code>unit</code>)
が1つのみで値が観測できないため、実のところ実行時に何で表現されるかは重要ではありません。古いコードは<code>{}</code>を使って表現する傾向がありました。しかし比較的新しいコードでは<code>undefined</code>を使う傾向にあります。なので、<code>Unit</code>を表現するのに使うものは本当に何でも問題にならないのですが、<code>undefined</code>を使うことが推奨されます（関数から何も返さないときも<code>undefined</code>を返します）。</p>
<p>もっと複雑な型についてはどうでしょうか？</p>
<p>すでに見てきたように、PureScriptの関数は引数がひとつのJavaScriptの関数に対応しています。厳密に言えば、任意の型 <code>a</code>、 <code>b</code>について、式 <code>f</code>の型が <code>a -&gt; b</code>で、式 <code>x</code>が型 <code>a</code>についての適切な実行時表現の値へと評価されるなら、 <code>f</code>はJavaScriptの関数へと評価され、 <code>x</code>を評価した結果に <code>f</code>を適用すると、それは型 <code>b</code>の適切な実行時表現を持ちます。簡単な例としては、 <code>String -&gt; String</code>型の式は、 <code>null</code>でないJavaScript文字列から <code>null</code>でないJavaScript文字列への関数へと評価されます。</p>
<p>ご想像のとおり、PureScriptの配列はJavaScriptの配列に対応しています。しかし、PureScriptの配列は均質であり、つまりすべての要素が同じ型を持っていることは覚えておいてください。具体的には、もしPureScriptの式
<code>e</code>が何らかの型 <code>a</code>について型 <code>Array a</code>を持っているなら、 <code>e</code>はすべての要素が型
<code>a</code>の適切な実行時表現を持った（<code>null</code>でない）JavaScript配列へと評価されます。</p>
<p>PureScriptのレコードがJavaScriptのオブジェクトへと評価されることはすでに見てきました。ちょうど関数と配列の場合のように、そのラベルに関連付けられている型を考慮すれば、レコードのフィールドのデータの実行時の表現についても推論することができます。もちろん、レコードのそれぞれのフィールドは、同じ型である必要はありません。</p>
<h3 id="adtの表現"><a class="header" href="#adtの表現">ADTの表現</a></h3>
<p>PureScriptコンパイラは、代数的データ型のすべての構築子についてそれぞれ関数を定義し、新たなJavaScriptオブジェクト型を作成します。これらの構築子はこれらのプロトタイプに基づいて新しいJavaScriptオブジェクトを作成する関数に対応しています。</p>
<p>たとえば、次のような単純なADTを考えてみましょう。</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>PureScriptコンパイラは、次のようなコードを生成します。</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>ここで2つのJavaScriptオブジェクト型 <code>Zero</code>と
<code>One</code>を見てください。JavaScriptのキーワード<code>new</code>を使用すると、それぞれの型の値を作成することができます。引数を持つ構築子については、コンパイラは
<code>value0</code>、 <code>value1</code>などと呼ばれるフィールドに対応するデータを格納します。</p>
<p>PureScriptコンパイラは補助関数も生成します。引数のない構築子については、コンパイラは構築子が使われるたびに
<code>new</code>演算子を使うのではなく、データを再利用できるように
<code>value</code>プロパティを生成します。ひとつ以上の引数を持つ構築子では、適切な表現を持つ引数を取り適切な構築子を適用する
<code>create</code>関数をコンパイラは生成します。</p>
<p>2引数以上の構築子についてはどうでしょうか？その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成します。しかし今回は、補助関数は2引数のカリー化された関数です。たとえば、次のような代数的データ型を考えます。</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>このコードからは、次のようなJavaScriptコードが生成されます。</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>ここで、オブジェクト型 <code>Two</code>の値はキーワード<code>new</code>または <code>Two.create</code>関数を使用すると作成することができます。</p>
<p>newtypeの場合はまた少し異なります。newtypeは単一の引数を取る単一の構築子を持つよう制限された代数的データ型であることを思い出してください。この場合には、実際はnewtypeの実行時表現は、その引数の型と同じになります。</p>
<p>例えば、電話番号を表す次のようなnewtypeを考えます。</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>これは実行時にはJavaScriptの文字列として表されます。newtypeは型安全性の追加の層を提供しますが、実行時の関数呼び出しのオーバーヘッドがないので、ライブラリを設計するのに役に立ちます。</p>
<h3 id="量化された型の表現"><a class="header" href="#量化された型の表現">量化された型の表現</a></h3>
<p>量化された型（多相型）の式は、制限された表現を実行時に持っています。実際には、所与の量化された型を持つ式が比較的少ないということですが、これによってとても効率的に解決できることを意味しています。</p>
<p>例えば、次の多相型を考えてみます。</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>この型を持っている関数にはどんなものがあるでしょうか。少なくともひとつはこの型を持つ関数が存在しています。すなわち、
<code>Prelude</code>で定義されている恒等関数 <code>id</code>です。</p>
<pre><code class="language-haskell">id :: forall a. a -&gt; a
id a = a
</code></pre>
<p>実のところ、 <code>id</code>の関数はこの型の<strong>唯一の</strong>（全）関数です！これは確かに間違いなさそうに見えますが（この型を持った
<code>id</code>とは明らかに異なる式を書こうとしてみてください）、これを確かめるにはどうしたらいいでしょうか。これは型の実行時表現を考えることによって確認することができます。</p>
<p>量化された型 <code>forall a. t</code>の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 <code>a</code>をどのように選んでも型 <code>t</code>の適切な実行時表現を持っていなければなりません。上の例では、型 <code>forall a. a -&gt; a</code>の関数は、 <code>String -&gt; String</code>、 <code>Number -&gt; Number</code>、 <code>Array Boolean -&gt; Array Boolean</code>などといった型について、適切な実行時表現を持っていなければなりません。 これらは、文字列から文字列、数から数の関数でなくてはなりません。</p>
<p>しかし、それだけでは十分ではありません。量化された型の実行時表現は、これよりも更に厳しくなります。任意の式が<strong>パラメトリック多相的</strong>でなければなりません。つまり、その実装において、引数の型についてのどんな情報も使うことができないのです。この追加の条件は、考えられる多相型のうち、以下のJavaScriptの関数のような問題のある実装を防止します。</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>確かにこの関数は文字列から文字列、数から数へというような関数ではありますが、追加の条件を満たしていません。引数の実行時の型を調べており、したがって、この関数は型 <code>forall a. a -&gt; a</code>の正しい実装だとはいえないのです。</p>
<p>関数の引数の実行時の型を検査することができなければ、唯一の選択肢は引数をそのまま返すことだけであり、したがって <code>id</code>はたしかに <code>forall a. a -&gt; a</code>の唯一の実装なのです。</p>
<p><strong>パラメトリック多相</strong> (parametric polymorphism) と<strong>パラメトリック性</strong> (parametricity)
についての詳しい議論は本書の範囲を超えています。ただ注目していただきたいことは、PureScriptの型は、実行時に<strong>消去</strong>されているので、PureScriptの多相関数は（FFIを使わない限り）引数の実行時表現を検査することが<strong>できず</strong>、そのためこの多相的なデータの表現が適切になっているということなのです。</p>
<h3 id="制約のある型の表現"><a class="header" href="#制約のある型の表現">制約のある型の表現</a></h3>
<p>型クラス制約を持つ関数は、実行時に面白い表現を持っています。関数の振る舞いはコンパイラによって選ばれた型クラスのインスタンスに依存する可能性があるため、関数には<strong>型クラス辞書</strong>
(type class dictionary)
と呼ばれる追加の引数が与えられます。この辞書には選ばれたインスタンスから提供される型クラスの関数の実装が含まれます。</p>
<p>例えば、 <code>Show</code>型クラスを使った制約のある型を持つ、次のような単純なPureScript関数について考えます。</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>生成されるJavaScriptは次のようになります。</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p><code>shout</code>は1引数ではなく、2引数の（カリー化された）関数にコンパイルされていることに注意してください。最初の引数 <code>dict</code>は
<code>Show</code>制約の型クラス辞書です。 <code>dict</code>には型 <code>a</code>の <code>show</code>関数の実装が含まれています。</p>
<p>最初の引数として明示的に<code>Data.Show</code>の型クラス辞書を渡すと、JavaScriptからこの関数を呼び出すことができます。</p>
<pre><code class="language-javascript">import { showNumber } from 'Data.Show'

shout(showNumber)(42);
</code></pre>
<h3 id="演習-33"><a class="header" href="#演習-33">演習</a></h3>
<ol>
<li>
<p>（簡単）これらの型の実行時の表現は何でしょうか。</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>これらの型を持つ式についてわかることはなんでしょうか。</p>
</li>
<li>
<p>（普通）<code>spago build</code>を使ってコンパイルし、NodeJSの <code>import</code>機能を使ってモジュールをインポートすることで、JavaScriptから <code>arrays</code>ライブラリの関数を使ってみてください。<strong>ヒント</strong>：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。</p>
</li>
</ol>
<h3 id="副作用の表現"><a class="header" href="#副作用の表現">副作用の表現</a></h3>
<p><code>Effect</code>モナドも外部型として定義されています。その実行時表現はとても簡単です。型 <code>Effect a</code>の式は引数なしのJavaScript関数へと評価されます。この関数はあらゆる副作用を実行し型 <code>a</code>の適切な実行時表現で値を返します。</p>
<p><code>Effect</code>型構築子の定義は、 <code>Effect</code>モジュールで次のように与えられています。</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>簡単な例として、 <code>random</code>パッケージで定義される <code>random</code>関数を考えてみてください。その型は次のようなものでした。</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p><code>random</code>関数の定義は次のように与えられます。</p>
<pre><code class="language-javascript">export const random = Math.random;
</code></pre>
<p><code>random</code>関数は実行時には引数なしの関数として表現されていることに注目してください。これは乱数生成という副作用を実行しそれを返しますが、返り値は
<code>Number</code>型の実行時表現と一致します。それは <code>null</code>でないJavaScriptの数です。</p>
<p>もう少し興味深い例として、<code>console</code>パッケージ中の<code>Effect.Console</code>モジュールで定義された <code>log</code>関数を考えてみましょう。
<code>log</code>関数は次の型を持っています。</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>この定義は次のようになっています。</p>
<pre><code class="language-javascript">export const log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>実行時の
<code>log</code>の表現は、単一の引数のJavaScript関数で、引数なしの関数を返します。内側の関数はコンソールにメッセージを書き込むという副作用を実行します。</p>
<p><code>Effect a</code>型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出すことができます。例えば、この
<code>main</code>関数は何らかの型 <code>a</code>について<code>Effect a</code>という型でなければならないので、次のように実行することができます。</p>
<pre><code class="language-javascript">import { main } from 'Main'

main();
</code></pre>
<p><code>spago bundle-app --to</code>または <code>spago run</code>を使用するときは、<code>Main</code>モジュールが定義されている場合は常に、この
<code>main</code>の呼び出しを自動的に生成することができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナドな冒険"><a class="header" href="#モナドな冒険">モナドな冒険</a></h1>
<h2 id="この章の目標-9"><a class="header" href="#この章の目標-9">この章の目標</a></h2>
<p>この章の目標は<strong>モナド変換子</strong> (monad transformers) について学ぶことで
す。モナド変換子は異なるモナドから提供された副作用を合成する方法を提供
します。NodeJSのコンソール上で遊ぶことができる、テキストアドベンチャー
ゲームを題材として扱います。ゲームの様々な副作用（ロギング、状態、およ
び設定）がすべてモナド変換子スタックによって提供されます。</p>
<h2 id="プロジェクトの準備-8"><a class="header" href="#プロジェクトの準備-8">プロジェクトの準備</a></h2>
<p>このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。</p>
<ul>
<li><code>ordered-collections</code> は不変のマップと集合のためのデータ型を提供します</li>
<li><code>transformers</code> は標準のモナド変換子の実装を提供します</li>
<li><code>node-readline</code> - NodeJSが提供する
<a href="http://nodejs.org/api/readline.html"><code>readline</code></a>インターフェイスへの
FFIバインディングを提供します</li>
<li><code>optparse</code> はコマンドライン引数を処理するアプリカティブ構文解析器を提
供します</li>
</ul>
<h2 id="ゲームの遊びかた"><a class="header" href="#ゲームの遊びかた">ゲームの遊びかた</a></h2>
<p>プロジェクトを走らせるには<code>spago run</code>を使います。</p>
<p>既定では使い方が表示されます。</p>
<pre><code class="language-text">Monadic Adventures! A game to learn monad transformers

Usage: run.js (-p|--player &lt;player name&gt;) [-d|--debug]
  Play the game as &lt;player name&gt;

Available options:
  -p,--player &lt;player name&gt;
                           The player's name &lt;String&gt;
  -d,--debug               Use debug mode
  -h,--help                Show this help text
</code></pre>
<p>コマンドライン引数を提供するためには、追加の引数を直接アプリケーション
に渡す<code>-a</code>オプション付きで<code>spago run</code>を呼び出すか、
<code>spago bundle-app</code>とすればよいです。2つ目の方法では<code>node</code>で直接走らせられる
index.jsファイルが作られます。
例えば<code>-p</code>オプションを使ってプレイヤー名を与えるには次のようにします。</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;
&gt;
</code></pre>
<pre><code class="language-text">$ spago bundle-app 
$ node index.js -p Phil
&gt;
</code></pre>
<p>プロンプトからは、 <code>look</code>、 <code>inventory</code>、 <code>take</code>、 <code>use</code>、 <code>north</code>、
<code>south</code>、 <code>east</code>、 <code>west</code>などのコマンドを入力することができます。
<code>debug</code>コマンドもあり、<code>--debug</code>コマンドラインオプションが与えられたと
きには、ゲームの状態を出力するのに使えます。</p>
<p>ゲームは2次元の碁盤の目の上が舞台で、コマンド <code>north</code>、 <code>south</code>、
<code>east</code>、 <code>west</code>を発行することによってプレイヤーが移動します。ゲームに
はアイテムの集まりがあり、プレイヤーの所持アイテム一覧を表したり、ゲー
ム盤上のその位置にあるアイテムの一覧を表すのに使われます。 <code>take</code>コマ
ンドを使うと、プレイヤーの位置にあるアイテムを拾い上げることができます。</p>
<p>参考までに、このゲームのひと通りの流れは次のようになります。</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre>
<p>このゲームはとても単純ですが、この章の目的は <code>transformers</code>パッケージ
を使用してこのようなゲームを素早く開発できるようにするライブラリを構築
することです。</p>
<h2 id="stateモナド"><a class="header" href="#stateモナド">Stateモナド</a></h2>
<p><code>transformers</code>パッケージで提供されているいくつかのモナドを見ることから
始めましょう。</p>
<p>最初の例は<code>State</code>モナドで、これは純粋なコードで<strong>変更可能状態</strong>をモデ
ル化する手段を提供します。すでに <code>Effect</code>モナドによって提供される変更
可能状態の手法について見てきました。<code>State</code>はその代替を提供します。</p>
<p><code>State</code>型構築子は、状態の型 <code>s</code>、および返り値の型 <code>a</code>という2種類の引数
を取ります。「<code>State</code>モナド」というように説明はしていますが、
<code>Monad</code>型クラスのインスタンスは実際には任意の型 <code>s</code>についての <code>State s</code>型構築子に対して提供されています。</p>
<p><code>Control.Monad.State</code>モジュールは以下のAPIを提供しています。</p>
<pre><code class="language-haskell">get     :: forall s.             State s s
gets    :: forall s. (s -&gt; a) -&gt; State s a
put     :: forall s. s        -&gt; State s Unit
modify  :: forall s. (s -&gt; s) -&gt; State s s
modify_ :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>なおここではこれらのAPIシグネチャは<code>State</code>型構築子を使った、単純化され
た形式で表されています。実際のAPIは本章の後にある「型クラス」節で押さ
える<code>MonadState</code>が関わってきます。ですからIDEのツールチップやPursuitで
異なるシグネチャを見たとしても心配しないでください。</p>
<p>例を見てみましょう。 <code>State</code>モナドの使いかたのひとつとしては、整数の配
列中の値を現在の状態に加えるものが考えられます。状態の型<code>s</code>として
<code>Int</code>を選択し、配列の走査に <code>traverse_</code>を使って、配列の要素それぞれに
ついて <code>modify</code>を呼び出すと、これを実現することができます。</p>
<pre><code class="language-haskell">import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class

sumArray :: Array Int -&gt; State Int Unit
sumArray = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre>
<p><code>Control.Monad.State</code>モジュールは <code>State</code>モナドでの計算を実行するための次の3つの関数を提供します。</p>
<pre><code class="language-haskell">evalState :: forall s a. State s a -&gt; s -&gt; a
execState :: forall s a. State s a -&gt; s -&gt; s
runState  :: forall s a. State s a -&gt; s -&gt; Tuple a s
</code></pre>
<p>3つの関数はそれぞれ型<code>s</code>の初期状態と型<code>State s a</code>の計算を引数にとりま
す。 <code>evalState</code>は返り値だけを返し、 <code>execState</code>は最終的な状態だけを返
し、 <code>runState</code>は <code>Tuple a s</code>型の値として表現された両方を返します。</p>
<p>先ほどの <code>sumArray</code>関数が与えられたとすると、PSCiで <code>execState</code>を使う
と次のように複数の配列内の数字を合計することができます。</p>
<pre><code class="language-text">&gt; :paste
… execState (do
…   sumArray [1, 2, 3]
…   sumArray [4, 5]
…   sumArray [6]) 0
… ^D
21
</code></pre>
<h2 id="演習-34"><a class="header" href="#演習-34">演習</a></h2>
<ol>
<li>
<p>（簡単）上の例で、<code>execState</code>を<code>runState</code>や<code>evalState</code>で置き換えると結果はどうなるでしょうか。</p>
</li>
<li>
<p>（普通）括弧からなる文字列について、次のいずれかであれば<strong>平衡して
いる</strong>とします。1つは0個以上のより短い平衡した文字列を連結したもの
で、もう1つはより短い平衡した文字列を一対の括弧で囲んだものです。</p>
<p><code>State</code>モナドと <code>traverse_</code>関数を使用して、次のような関数を書いてください。</p>
<pre><code class="language-haskell">testParens :: String -&gt; Boolean
</code></pre>
<p>これは <code>String</code>が括弧の対応が正しく付けられているかどうかを調べる
関数です。調べ方はまだ閉じられていない開括弧の数を把握しておくこと
です。この関数は次のように動作しなくてはなりません。</p>
<pre><code class="language-text">&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false
</code></pre>
<p><strong>ヒント</strong>：入力の文字列を文字の配列に変換するのに、
<code>Data.String.CodeUnits</code>モジュールの <code>toCharArray</code>関数を使うと良い
でしょう。</p>
</li>
</ol>
<h2 id="readerモナド"><a class="header" href="#readerモナド">Readerモナド</a></h2>
<p><code>transformers</code>パッケージでは <code>Reader</code>というモナドも提供されています。
このモナドは大域的な設定を読み取る機能を提供します。 <code>State</code>モナドがひ
とつの可変状態を読み書きする機能を提供するのに対し、 <code>Reader</code>モナドは
ひとつのデータの読み取りの機能だけを提供します。</p>
<p><code>Reader</code>型構築子は、設定の型を表す型 <code>r</code>、および戻り値の型 <code>a</code>の2つの
型引数を取ります。</p>
<p><code>Contro.Monad.Reader</code>モジュールは以下のAPIを提供します。</p>
<pre><code class="language-haskell">ask   :: forall r. Reader r r
local :: forall r a. (r -&gt; r) -&gt; Reader r a -&gt; Reader r a
</code></pre>
<p><code>ask</code>アクションは現在の設定を読み取るために使い、 <code>local</code>アクションは
変更された設定で計算を実行するために使います。</p>
<p>たとえば、権限で制御されたアプリケーションを開発しており、現在の利用者
の権限オブジェクトを保持するのに <code>Reader</code>モナドを使いたいとしましょう。
型 <code>r</code>を次のようなAPIを備えた型 <code>Permission</code>として選択できます。</p>
<pre><code class="language-haskell">hasPermission :: String -&gt; Permissions -&gt; Boolean
addPermission :: String -&gt; Permissions -&gt; Permissions
</code></pre>
<p>利用者が特定の権限を持っているかどうかを確認したいときは、 <code>ask</code>を使っ
て現在の権限オブジェクトを取得すればいつでも調べることができます。たと
えば、管理者だけが新しい利用者の作成を許可されているとしましょう。</p>
<pre><code class="language-haskell">createUser :: Reader Permissions (Maybe User)
createUser = do
  permissions &lt;- ask
  if hasPermission &quot;admin&quot; permissions
    then map Just newUser
    else pure Nothing
</code></pre>
<p><code>local</code>アクションを使うと、計算の実行中に <code>Permissions</code>オブジェクトを
変更し、ユーザーの権限を昇格させることもできます。</p>
<pre><code class="language-haskell">runAsAdmin :: forall a. Reader Permissions a -&gt; Reader Permissions a
runAsAdmin = local (addPermission &quot;admin&quot;)
</code></pre>
<p>こうすると、利用者が <code>admin</code>権限を持っていなかった場合であっても、新し
い利用者を作成する関数を書くことができます。</p>
<pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre>
<p><code>Reader</code>モナドの計算を実行するには、大域的な設定を与える <code>runReader</code>関
数を使います。</p>
<pre><code class="language-haskell">runReader :: forall r a. Reader r a -&gt; r -&gt; a
</code></pre>
<h2 id="演習-35"><a class="header" href="#演習-35">演習</a></h2>
<p>以下の演習では、 <code>Reader</code>モナドを使って、字下げのついた文書を出力する
ための小さなライブラリを作っていきます。「大域的な設定」は、現在の字下
げの深さを示す数になります。</p>
<pre><code class="language-haskell">type Level = Int

type Doc = Reader Level String
</code></pre>
<ol>
<li>
<p>（簡単）現在の字下げの深さで文字列を出力する関数 <code>line</code>を書いてくださ
い。関数は以下の型を持っている必要があります。</p>
<pre><code class="language-haskell">line :: String -&gt; Doc
</code></pre>
<p><strong>ヒント</strong>：現在の字下げの深さを読み取るためには <code>ask</code>関数を使用
します。<code>Data.Monoid</code>の<code>power</code>関数も役に立つかもしれません。</p>
</li>
<li>
<p>（普通）<code>local</code>関数を使用して次の関数を書いてください。</p>
<pre><code class="language-haskell">indent :: Doc -&gt; Doc
</code></pre>
<p>この関数はコードブロックの字下げの深さを大きくします。</p>
</li>
<li>
<p>（普通）<code>Data.Traversable</code>で定義された <code>sequence</code>関数を使用して、次
の関数を書いてください。</p>
<pre><code class="language-haskell">cat :: Array Doc -&gt; Doc
</code></pre>
<p>この関数は文書の集まりを改行で区切って連結します。</p>
</li>
<li>
<p>（普通）<code>runReader</code>関数を使用して次の関数を書いてください。</p>
<pre><code class="language-haskell">render :: Doc -&gt; String
</code></pre>
<p>この関数は文書を文字列として出力します。</p>
</li>
</ol>
<p>これで、このライブラリを次のように使うと、簡単な文書を書くことができ
るでしょう。</p>
<pre><code class="language-haskell">render $ cat
  [ line &quot;Here is some indented text:&quot;
  , indent $ cat
      [ line &quot;I am indented&quot;
      , line &quot;So am I&quot;
      , indent $ line &quot;I am even more indented&quot;
      ]
  ]
</code></pre>
<h2 id="writerモナド"><a class="header" href="#writerモナド">Writerモナド</a></h2>
<p><code>Writer</code>モナドは、計算の返り値に加えて、もうひとつの値を累積していく機
能を提供します。</p>
<p>よくある使い方としては型 <code>String</code>もしくは <code>Array String</code>でログを累積し
ていくというものなどがありますが、 <code>Writer</code>モナドはこれよりもっと一般
的なものです。これは累積するのに任意のモノイドの値を使うことができ、
<code>Additive Int</code>モノイドを使って、合計を追跡し続けるのに使ったり、 <code>Disj Boolean</code>モノイドを使って途中の <code>Boolean</code>値のいずれかが真であるかどうか
を追跡するのに使うことができます。</p>
<p><code>Writer</code>型の構築子は、 <code>Monoid</code>型クラスのインスタンスである型 <code>w</code>、お
よび返り値の型 <code>a</code>という2つの型引数を取ります。</p>
<p><code>Writer</code>のAPIで重要なのは <code>tell</code>関数です。</p>
<pre><code class="language-haskell">tell :: forall w a. Monoid w =&gt; w -&gt; Writer w Unit
</code></pre>
<p><code>tell</code>アクションは、与えられた値を現在の累積結果に加算します。</p>
<p>例として、 <code>Array String</code>モノイドを使用して、既存の関数にログ機能を追
加してみましょう。<strong>最大公約数</strong>関数の以前の実装を考えてみます。</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p><code>Writer (Array String) Int</code>に返り値の型を変更することで、この関数にログ機能を追加することができます。</p>
<pre><code class="language-haskell">import Control.Monad.Writer
import Control.Monad.Writer.Class

gcdLog :: Int -&gt; Int -&gt; Writer (Array String) Int
</code></pre>
<p>各手順での2つの入力を記録するためには、少し関数を変更する必要があります。</p>
<pre><code class="language-haskell">    gcdLog n 0 = pure n
    gcdLog 0 m = pure m
    gcdLog n m = do
      tell [&quot;gcdLog &quot; &lt;&gt; show n &lt;&gt; &quot; &quot; &lt;&gt; show m]
      if n &gt; m
        then gcdLog (n - m) m
        else gcdLog n (m - n)
</code></pre>
<p><code>Writer</code>モナドの計算を実行するには、 <code>execWriter</code>関数と <code>runWriter</code>関数のいずれかを使います。</p>
<pre><code class="language-haskell">execWriter :: forall w a. Writer w a -&gt; w
runWriter  :: forall w a. Writer w a -&gt; Tuple a w
</code></pre>
<p>ちょうど <code>State</code>モナドの場合と同じように、 <code>execWriter</code>が累積されたログだけを返すのに対して、
<code>runWriter</code>は累積されたログと結果の両方を返します。</p>
<p>PSCiで修正された関数を試してみましょう。</p>
<pre><code class="language-text">&gt; import Control.Monad.Writer
&gt; import Control.Monad.Writer.Class

&gt; runWriter (gcdLog 21 15)
Tuple 3 [&quot;gcdLog 21 15&quot;,&quot;gcdLog 6 15&quot;,&quot;gcdLog 6 9&quot;,&quot;gcdLog 6 3&quot;,&quot;gcdLog 3 3&quot;]
</code></pre>
<h2 id="演習-36"><a class="header" href="#演習-36">演習</a></h2>
<ol>
<li>
<p>（普通）<code>Writer</code>モナドと <code>monoid</code>パッケージの <code>Additive Int</code>モノイドを
使うように、上の <code>sumArray</code>関数を書き換えてください。</p>
</li>
<li>
<p>（普通）<strong>コラッツ関数</strong>は、自然数 <code>n</code>が偶数なら <code>n / 2</code>、 <code>n</code>が奇数な
ら <code>3 * n + 1</code>であると定義されています。たとえば、 <code>10</code>で始まるコラッ
ツ数列は次のようになります。</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的
に <code>1</code>になるということが予想されています。</p>
<p>数列が <code>1</code>に到達するまでに何回のコラッツ関数の適用が必要かを計算
する再帰的な関数を書いてください。</p>
<p><code>Writer</code>モナドを使用してコラッツ関数のそれぞれの適用の経過を記録
するように、関数を変更してください。</p>
</li>
</ol>
<h2 id="モナド変換子"><a class="header" href="#モナド変換子">モナド変換子</a></h2>
<p>上の3つのモナド、 <code>State</code>、 <code>Reader</code>、 <code>Writer</code>は、いずれもいわゆる
<strong>モナド変換子</strong>（monad transformers）の例となっています。対応するモナド変
換子はそれぞれ <code>StateT</code>、 <code>ReaderT</code>、 <code>WriterT</code>と呼ばれています。</p>
<p>モナド変換子とは何でしょうか。さて、これまで見てきたように、モナドは
PureScriptのコードを何らかの種類の副作用で拡張するものでした。このモナ
ドはPureScriptで適切なハンドラ（<code>runState</code>、 <code>runReader</code>、
<code>runWriter</code>など）を使って解釈することができます。使用する必要がある副
作用が<strong>ひとつだけ</strong>なら、これで問題ありません。しかし、同時に複数の副
作用を使用できると便利なことがよくあります。例えば、 <code>Maybe</code>と
<code>Reader</code>を一緒に使用すると、ある大域的な設定の文脈で<strong>省略可能な結果</strong>
を表現することができます。もしくは、 <code>Either</code>モナドの純粋なエラー追跡
機能と、 <code>State</code>モナドが提供する変更可能な状態が同時に欲しくなるかもし
れません。この問題を解決するのが<strong>モナド変換子</strong>です。</p>
<p>ただし<code>Effect</code>モナドがこの問題に対する部分的な解決策を提供していたこと
は既に見てきました。モナド変換子はまた異なった解決策を提供しますが、こ
れらの手法にはそれぞれ利点と限界があります。</p>
<p>モナド変換子は型だけでなく別の型構築子もパラメータに取る型構築子です。
モナド変換子はモナドをひとつ取り、独自のいろいろな副作用を追加した別の
モナドへと変換します。</p>
<p>例を見てみましょう。<code>State</code>のモナド変換子版は
<code>Control.Monad.State.Trans</code>モジュールで定義されている<code>StateT</code>です。
PSCiを使って <code>StateT</code>の種を見てみましょう。</p>
<pre><code class="language-text">&gt; import Control.Monad.State.Trans
&gt; :kind StateT
Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>とても読みにくそうに思うかもしれませんが、使い方を理解するために、
<code>StateT</code>にひとつ引数を与えてみましょう。</p>
<p><code>State</code>の場合、最初の型引数は使いたい状態の型です。それでは型
<code>String</code>を与えてみましょう。</p>
<pre><code class="language-text">&gt; :kind StateT String
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>次の引数は種 <code>Type -&gt; Type</code>の型構築子です。これは <code>StateT</code>の機能を追加
したい元のモナドを表します。例として、 <code>Either String</code>モナドを選んでみ
ます。</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String)
Type -&gt; Type
</code></pre>
<p>型構築子が残りました。最後の引数は戻り値の型を表しており、たとえばそれ
を <code>Number</code>にすることができます。</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String) Number
Type
</code></pre>
<p>最後に、種 <code>Type</code>の何かが残りましたが、これはつまりこの型の値を探して
みることができるということです。</p>
<p>構築したモナド <code>StateT String (Either String)</code>は、エラーで失敗する可能
性があり、変更可能な状態を使える計算を表しています。</p>
<p>外側の <code>StateT String (Either String)</code>モナドのアクション（<code>get</code>、<code>put</code>、<code>modify</code>）は直接使うことができますが、ラップされている内側のモナド (<code>Either String</code>)
の作用を使うためには、これらの関数をモナド変換子まで「持ち上げ」なくてはいけません。<code>Control.MonadTrans</code>モジュールでは、モナド変換子であるような型構築子を捕捉する<code>MonadTrans</code>型クラスを次のように定義しています。</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>このクラスは、基礎となる任意のモナド <code>m</code>の計算をとり、それをラップされ
たモナド <code>t m</code>へと持ち上げる、 <code>lift</code>というひとつの関数だけを持ってい
ます。今回の場合、型構築子 <code>t</code>は <code>StateT String</code>で、 <code>m</code>は <code>Either String</code>モナドとなり、 <code>lift</code>は型 <code>Either String a</code>の計算を、型 <code>State String (Either String) a</code>の計算へと持ち上げる方法を提供することになり
ます。これは、型 <code>Either String a</code>の計算を使うときは、 <code>lift</code>を使えば
いつでも作用 <code>StateT String</code>と <code>Either String</code>を一緒に使うことができる
ことを意味します。</p>
<p>たとえば、次の計算は <code>StateT</code>モナド変換子で導入されている状態を読み込
み、状態が空の文字列である場合はエラーを投げます。</p>
<pre><code class="language-haskell">import Data.String (drop, take)

split :: StateT String (Either String) String
split = do
  s &lt;- get
  case s of
    &quot;&quot; -&gt; lift $ Left &quot;Empty string&quot;
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>状態が空でなければ、この計算は <code>put</code>を使って状態を <code>drop 1 s</code>（最初の
文字を取り除いた <code>s</code>）へと更新し、 <code>take 1 s</code>（<code>s</code>の最初の文字）を返し
ます。</p>
<p>それではPSCiでこれを試してみましょう。</p>
<pre><code class="language-text">&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;
</code></pre>
<p>これは <code>StateT</code>を使わなくても実装できるので、さほど驚くようなことでは
ありません。しかし、モナドとして扱っているので、do記法やアプリカティブ
コンビネータを使って、小さな計算から大きな計算を構築していくことができ
ます。例えば、2回 <code>split</code>を適用すると、文字列から最初の2文字を読むこと
ができます。</p>
<pre><code class="language-text">&gt; runStateT ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple &quot;te&quot; &quot;st&quot;))
</code></pre>
<p>他にもアクションを沢山用意すれば、 <code>split</code>関数を使って、基本的な構文解
析ライブラリを構築することができます。これは実際に <code>parsing</code>ライブラリ
で採用されている手法です。これがモナド変換子の力なのです。必要な副作用
を選択して、do記法とアプリカティブコンビネータで表現力を維持しながら、
様々な問題のための特注のモナドを作成することができるのです。</p>
<h2 id="excepttモナド変換子"><a class="header" href="#excepttモナド変換子">ExceptTモナド変換子</a></h2>
<p><code>transformers</code>パッケージでは、 <code>Either e</code>モナドに対応する変換子である
<code>ExceptT e</code>モナド変換子も定義されています。これは次のAPIを提供します。</p>
<pre><code class="language-haskell">class MonadError e m where
  throwError :: forall a. e -&gt; m a
  catchError :: forall a. m a -&gt; (e -&gt; m a) -&gt; m a

instance monadErrorExceptT :: Monad m =&gt; MonadError e (ExceptT e m)

runExceptT :: forall e m a. ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p><code>MonadError</code>クラスは <code>e</code>型のエラーのスローとキャッチをサポートするモナ
ドを取得し、 <code>ExceptT e</code>モナド変換子のインスタンスが提供されます。
<code>Either e</code>モナドの <code>Left</code>と同じように、 <code>throwError</code>アクションは失敗を
示すために使われます。 <code>catchError</code>アクションを使うと、 <code>throwError</code>で
エラーが投げられたあとでも処理を継続することができるようになります。</p>
<p><code>runExceptT</code>ハンドラを使うと、型 <code>ExceptT e m a</code>の計算を実行することが
できます。</p>
<p>このAPIは <code>exceptions</code>パッケージの <code>Exception</code>作用によって提供されてい
るものと似ています。しかし、いくつかの重要な違いがあります。</p>
<ul>
<li><code>Exception</code>が実際のJavaScriptの例外を使っているのに対して<code>ExceptT</code>モデ
ルは代数的データ型を使っています。</li>
<li><code>Exception</code>作用がJavaScriptの <code>Error</code>型というひとつ例外の型だけを扱う
のに対して<code>ExceptT</code>は<code>Error</code>型クラスのどんな型のエラーでも扱います。つ
まり、 <code>ExceptT</code>では新たなエラー型を自由に定義できます。</li>
</ul>
<p>試しに <code>ExceptT</code>を使って <code>Writer</code>モナドを包んでみましょう。ここでもモ
ナド変換子 <code>ExceptT e</code>のアクションを自由に直接使うこともできますが、
<code>Writer</code>モナドの計算は <code>lift</code>を使って持ちあげるべきです。</p>
<pre><code class="language-haskell">import Control.Monad.Except
import Control.Monad.Writer

writerAndExceptT :: ExceptT String (Writer (Array String)) String
writerAndExceptT = do
  lift $ tell [&quot;Before the error&quot;]
  _ &lt;- throwError &quot;Error!&quot;
  lift $ tell [&quot;After the error&quot;]
  pure &quot;Return value&quot;
</code></pre>
<p>PSCiでこの関数を試すと、ログの蓄積とエラーの送出という2つの作用がどの
ように相互作用しているのかを見ることができます。まず、 <code>runExceptT</code>を
使って外側の <code>ExceptT</code>計算を実行し、型 <code>Writer (Array String) (Either String String)</code>の結果を残します。それから、 <code>runWriter</code>で内側の
<code>Writer</code>計算を実行します。</p>
<pre><code class="language-text">&gt; runWriter $ runExceptT writerAndExceptT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]
</code></pre>
<p>実際に追加されるログは、エラーが投げられる前に書かれたログメッセージだ
けであることにも注目してください。</p>
<h2 id="モナド変換子スタック"><a class="header" href="#モナド変換子スタック">モナド変換子スタック</a></h2>
<p>これまで見てきたように、モナド変換子を使うと既存のモナドの上に新しいモ
ナドを構築することができます。任意のモナド変換子 <code>t1</code>と任意のモナド
<code>m</code>について、その適用 <code>t1 m</code>もまたモナドになります。これは<strong>2つめの</strong>
モナド変換子 <code>t2</code>を先ほどの結果 <code>t1 m</code>に適用すると、3つ目のモナド <code>t2 (t1 m)</code>を作れることを意味しています。このように、構成するモナドによっ
て提供された副作用を組み合わせる、モナド変換子の<strong>スタック</strong>を構築する
ことができます。</p>
<p>実際には、基本となるモナド <code>m</code>は、ネイティブの副作用が必要なら
<code>Effect</code>モナド、さもなくば <code>Data.Identity</code>モジュールで定義されている
<code>Identity</code>モナドになります。 <code>Identity</code>モナドは何の新しい副作用も追加
しませんから、 <code>Identity</code>モナドの変換は、モナド変換子の作用だけを提供
します。実際に、 <code>State</code>モナド、 <code>Reader</code>モナド、 <code>Writer</code>モナドは、
<code>Identity</code>モナドをそれぞれ <code>StateT</code>、 <code>ReaderT</code>、 <code>WriterT</code>で変換する
ことによって実装されています。</p>
<p>それでは3つの副作用が組み合わされている例を見てみましょう。
<code>Identity</code>モナドをスタックの底にして、 <code>StateT</code>作用、 <code>WriterT</code>作用、
<code>ExceptT</code>作用を使います。このモナド変換子スタックは、可変状態、ログの
蓄積、そして純粋なエラーの副作用を提供します。</p>
<p>このモナド変換子スタックを使うと、ロギングの機能が追加された <code>split</code>ア
クションを再現させられます。</p>
<pre><code class="language-haskell">type Errors = Array String

type Log = Array String

type Parser = StateT String (WriterT Log (ExceptT Errors Identity))

split :: Parser String
split = do
  s &lt;- get
  lift $ tell [&quot;The state is &quot; &lt;&gt; s]
  case s of
    &quot;&quot; -&gt; lift $ lift $ throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>この計算をPSCiで試してみると、 <code>split</code>が実行されるたびに状態がログに追
加されることがわかります。</p>
<p>モナド変換子スタックに現れる順序に従って、副作用を取り除いていかなけれ
ばならないことに注意してください。最初に <code>StateT</code>型構築子を取り除くた
めに <code>runStateT</code>を使い、それから <code>runtWriteT</code>を使い、その後
<code>runExceptT</code>を使います。最後に <code>unwrap</code>を使用して <code>Identity</code>モナドの演
算を実行します。</p>
<pre><code class="language-text">&gt; runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
(Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;]))

&gt; runParser ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;]))
</code></pre>
<p>しかしながら状態が空であることが理由で解析が失敗した場合は、ログはまっ
たく出力されません。</p>
<pre><code class="language-text">&gt; runParser split &quot;&quot;
(Left [&quot;Empty string&quot;])
</code></pre>
<p>これは、 <code>ExceptT</code>モナド変換子が提供する副作用が、 <code>WriterT</code>モナド変換
子が提供する副作用と干渉するためです。これはモナド変換子スタックが構成
されている順序を変更することで解決することができます。スタックの最上部
に <code>ExceptT</code>変換子を移動すると、先ほど <code>Writer</code>を <code>ExceptT</code>に変換した
ときと同じように、最初のエラーまでに書かれたすべてのメッセージが含まれ
るようになります。</p>
<p>このコードの問題のひとつは、複数のモナド変換子の上まで計算を持ち上げる
ために、 <code>lift</code>関数を複数回使わなければならないということです。たとえ
ば、 <code>throwError</code>の呼び出しは、1回目は <code>WriteT</code>へ、2回目は <code>StateT</code>へ
と、2回持ちあげなければなりません。小さなモナド変換子スタックならなん
とかなりますが、そのうち不便だと感じるようになるでしょう。</p>
<p>幸いなことに、これから見るような型クラス推論によって提供されるコードの
自動生成を使うと、ほとんどの「重労働」を任せられます。</p>
<h2 id="演習-37"><a class="header" href="#演習-37">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Identity</code>関手の上の <code>ExceptT</code>モナド変換子を使って、分母がゼロ
の場合は（文字列「Divide by zero!」の）エラーを投​​げる、2つの数の商を求
める関数 <code>safeDivide</code>を書いてください。</p>
</li>
<li>
<p>（普通）次のような構文解析関数を書いてください。</p>
<pre><code class="language-haskell">string :: String -&gt; Parser String
</code></pre>
<p>これは現在の状態が接頭辞に適合するか、もしくはエラーメッセージと
ともに失敗します。</p>
<p>この構文解析器は次のように動作します。</p>
<pre><code class="language-text">&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;
(Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;]))
</code></pre>
<p><strong>ヒント</strong>：出発点として <code>split</code>の実装を使うといいでしょう。
<code>stripPrefix</code>関数も役に立ちます。</p>
</li>
<li>
<p>（難しい）以前 <code>Reader</code>モナドを使用して書いた文書表示ライブラリを、
<code>ReaderT</code>と <code>WriterT</code>モナド変換子を使用して再実装してください。</p>
<p>文字列を出力する <code>line</code>や文字列を連結する <code>cat</code>を使うのではなく、
<code>WriteT</code>モナド変換子と一緒に <code>Array String</code>モノイドを使い、結果へ
行を追加するのに <code>tell</code>を使ってください。アポストロフィ (<code>'</code>) で
終わる以外は元の実装と同じ名前を使ってください。</p>
</li>
</ol>
<h2 id="型クラスが助けに来たぞ"><a class="header" href="#型クラスが助けに来たぞ">型クラスが助けに来たぞ！</a></h2>
<p>本章の最初で扱った <code>State</code>モナドを見てみると、 <code>State</code>モナドのアクショ
ンには次のような型が与えられていました。</p>
<pre><code class="language-haskell">get    :: forall s.             State s s
put    :: forall s. s        -&gt; State s Unit
modify :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>モジュールで与えられている型は、実際にはこ
れよりもっと一般的です。</p>
<pre><code class="language-haskell">get    :: forall m s. MonadState s m =&gt;             m s
put    :: forall m s. MonadState s m =&gt; s        -&gt; m Unit
modify :: forall m s. MonadState s m =&gt; (s -&gt; s) -&gt; m Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>モジュールには<code>MonadState</code>（多変数）型クラ
スが定義されています。この型クラスは「純粋な変更可能な状態を提供するモ
ナド」への抽象化を可能にします。予想できると思いますが、 <code>State s</code>型構
築子は <code>MonadState s</code>型クラスのインスタンスになっており、このクラスに
は他にも興味深いインスタンスが数多くあります。</p>
<p>特に、 <code>transformers</code>パッケージではモナド変換子 <code>WriterT</code>、 <code>ReaderT</code>、
<code>ExceptT</code>についての <code>MonadState</code>のインスタンスが提供されています。通底
する<code>Monad</code>が<code>MonadState</code>インスタンスを持っていれば常に、これらのモナ
ド変換子にもインスタンスがあります。実践的には、 <code>StateT</code>がモナド変換
子スタックの<strong>どこか</strong>に現れ、 <code>StateT</code>より上のすべてが <code>MonadState</code>の
インスタンスであれば、 <code>get</code>、 <code>put</code>、 <code>modify</code>を直接自由に使用するこ
とができます。</p>
<p>当然ですが、これまで扱ってきた <code>ReaderT</code>、 <code>WriterT</code>、 <code>ExceptT</code>変換子
についても、同じことが成り立っています。<code>transformers</code>では主な変換子そ
れぞれについての型クラスが定義されています。これによりそれらの操作に対
応するモナドの上に抽象化することができるのです。</p>
<p>上の <code>split</code>関数の場合、構築されたこのモナドスタックは型クラス
<code>MonadState</code>、 <code>MonadWriter</code>、 <code>MonadError</code>それぞれのインスタンスです。
これはつまり、 <code>lift</code>をまったく呼び出す必要がないことを意味します！ま
るでモナドスタック自体に定義されていたかのように、アクション <code>get</code>、
<code>put</code>、 <code>tell</code>、 <code>throwError</code>をそのまま使用することができます。</p>
<pre><code class="language-haskell">split :: Parser String
split = do
  s &lt;- get
  tell [&quot;The state is &quot; &lt;&gt; show s]
  case s of
    &quot;&quot; -&gt; throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>この計算はまるで、可変状態、ロギング、エラー処理という3つの副作用に対応した、独自のプログラミング言語を拡張したかのようにみえます。しかしながら、内部的にはすべてはあくまで純粋な関数と普通のデータを使って実装されているのです。</p>
<h2 id="alternatives-1"><a class="header" href="#alternatives-1">Alternatives</a></h2>
<p><code>control</code>パッケージでは失敗しうる計算を操作するための抽象化がいくつか
定義されています。そのひとつは <code>Alternative</code>型クラスです。</p>
<pre><code class="language-haskell">class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<p><code>Alternative</code>は2つの新しいコンビネータを提供しています。1つは失敗しう
る計算のプロトタイプを提供する <code>empty</code>値で、もう1つはエラーが起きたと
きに<strong>代替</strong> (Alternative) 計算へ戻ってやり直す機能を提供する<code>alt</code>関数
（そしてその別名<code>&lt;|&gt;</code>）演算子です。</p>
<p><code>Data.Array</code>モジュールでは <code>Alternative</code>型クラスで型構築子を操作する2
つの便利な関数を提供します。</p>
<pre><code class="language-haskell">many :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
some :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
</code></pre>
<p><code>Data.List</code>にも等価な<code>many</code>と<code>some</code>があります。</p>
<p><code>many</code>コンビネータは計算を<strong>ゼロ回以上</strong>繰り返し実行するために
<code>Alternative</code>型クラスを使用しています。 <code>some</code>コンビネータも似ています
が、成功するために少なくとも1回の計算を必要とします。</p>
<p><code>Parser</code>モナド変換子スタックの場合は、<code>ExceptT</code>コンポーネントによる
<code>Alternative</code>のインスタンスがあります。このコンポーネントでは異なる分
枝のエラーに<code>Monoid</code>インスタンスを使って組み合わせることによって対応し
ています（だから<code>Errors</code>型に<code>Array String</code>を選ぶ必要があったんですね）。
これは、構文解析器を複数回実行するのに<code>many</code>関数と<code>some</code>関数を使うこと
ができることを意味します。</p>
<pre><code class="language-text">&gt; import Data.Array (many)

&gt; runParser (many split) &quot;test&quot;
(Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;)
              [ &quot;The state is \&quot;test\&quot;&quot;
              , &quot;The state is \&quot;est\&quot;&quot;
              , &quot;The state is \&quot;st\&quot;&quot;
              , &quot;The state is \&quot;t\&quot;&quot;
              ]))
</code></pre>
<p>ここでは入力文字列 <code>&quot;test&quot;</code>は、1文字からなる文字列4つの配列を返すよう
に繰り返し分割されています。残った状態は空で、ログは <code>split</code>コンビネー
タが4回適用されたことを示しています。</p>
<h2 id="モナド内包表記"><a class="header" href="#モナド内包表記">モナド内包表記</a></h2>
<p><code>Control.MonadPlus</code>モジュールには <code>MonadPlus</code>と呼ばれる
<code>Alternative</code>型クラスの副クラスが定義されています。 <code>MonadPlus</code>はモナ
ドと<code>Alternative</code>両方のインスタンスである型構築子を取ります。</p>
<pre><code class="language-haskell">class (Monad m, Alternative m) &lt;= MonadPlus m
</code></pre>
<p>実際、<code>Parser</code>モナドは <code>MonadPlus</code>のインスタンスです。</p>
<p>以前に本書中で配列内包表記を扱ったとき、不要な結果をフィルタリングする
ために使われる<code>guard</code>関数を導入しました。実際は <code>guard</code>関数はもっと一
般的で、 <code>MonadPlus</code>のインスタンスであるすべてのモナドに対して使うこと
ができます。</p>
<pre><code class="language-haskell">guard :: forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p><code>&lt;|&gt;</code>演算子は失敗時のバックトラッキングをできるようにします。これがど
のように役立つかを見るために、大文字だけに適合する <code>split</code>コンビネータ
の亜種を定義してみましょう。</p>
<pre><code class="language-haskell">upper :: Parser String
upper = do
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre>
<p>ここで、文字列が大文字でない場合に失敗するよう <code>guard</code>を使用しています。
このコードは前に見た配列内包表記とよく似ていることに注目してください。
このように<code>MonadPlus</code>を使うことは、<strong>モナド内包表記</strong> (monad
comprehensions) の構築と呼ばれることがあります。</p>
<h2 id="バックトラッキング"><a class="header" href="#バックトラッキング">バックトラッキング</a></h2>
<p><code>&lt;|&gt;</code>演算子を使うと、失敗したときに別の代替計算へとバックトラックすることができます。これを確かめるために、小文字に一致するもう1つの構文解析器を定義してみましょう。</p>
<pre><code class="language-haskell">lower :: Parser String
lower = do
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre>
<p>これにより、まずもし最初の文字が大文字なら複数の大文字に適合し、さもな
くばもし最初の文字が小文字なら複数の小文字に適合する、という構文解析器
を定義することができます。</p>
<pre><code class="language-text">&gt; upperOrLower = some upper &lt;|&gt; some lower
</code></pre>
<p>この構文解析器は、大文字と小文字が切り替わるまで、文字に適合し続けます。</p>
<pre><code class="language-text">&gt; runParser upperOrLower &quot;abcDEF&quot;
(Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;))
              [ &quot;The state is \&quot;abcDEF\&quot;&quot;
              , &quot;The state is \&quot;bcDEF\&quot;&quot;
              , &quot;The state is \&quot;cDEF\&quot;&quot;
              ]))
</code></pre>
<p><code>many</code>を使うと、文字列を小文字と大文字の要素に完全に分割することもできます。</p>
<pre><code class="language-text">&gt; components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
(Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;)
              [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;CDeFgh\&quot;&quot;
              , &quot;The state is \&quot;DeFgh\&quot;&quot;
              , &quot;The state is \&quot;eFgh\&quot;&quot;
              , &quot;The state is \&quot;Fgh\&quot;&quot;
              , &quot;The state is \&quot;gh\&quot;&quot;
              , &quot;The state is \&quot;h\&quot;&quot;
              ]))
</code></pre>
<p>繰り返しになりますが、これはモナド変換子がもたらす再利用性の威力を示し
ています。標準的な抽象化を再利用することで、宣言型スタイルのバックトラッ
ク構文解析器をわずか数行のコードで書くことができました！</p>
<h2 id="演習-38"><a class="header" href="#演習-38">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>string</code>構文解析器の実装から <code>lift</code>関数の呼び出しを取り除いて
ください。新しい実装の型が整合していることを確認し、なぜそのようになる
のかをよく納得しておきましょう。</p>
</li>
<li>
<p>（普通）<code>string</code>構文解析器と <code>many</code>コンビネータを使って、文字列
<code>&quot;a&quot;</code>の連続と、それに続く文字列 <code>&quot;b&quot;</code>の連続からなる文字列を認識する構
文解析器<code>asFollowedByBs</code>を書いてください。</p>
</li>
<li>
<p>（普通）<code>&lt;|&gt;</code>演算子を使って、文字 <code>a</code>と文字 <code>b</code>が任意の順序で現れるよ
うな文字列を認識する構文解析器<code>asOrBs</code>を書いてください。</p>
</li>
<li>
<p>（難しい）<code>Parser</code>モナドを次のように定義することもできます。</p>
<pre><code class="language-haskell">type Parser = ExceptT Errors (StateT String (WriterT Log Identity))
</code></pre>
<p>このように変更すると、構文解析関数にどのような影響を与えるでしょうか。</p>
</li>
</ol>
<h2 id="rwsモナド"><a class="header" href="#rwsモナド">RWSモナド</a></h2>
<p>モナド変換子のある特定の組み合わせは頻出なので、<code>transformers</code>パッケー
ジ内の単一のモナド変換子として提供されています。<code>Reader</code>、 <code>Writer</code>、
<code>State</code>のモナドは、<strong>Reader-Writer-State</strong>モナドに組み合わさり、より単
純に<code>RWS</code>モナドともされます。このモナドは <code>RWST</code>モナド変換子と呼ばれる、
対応するモナド変換子を持っています。</p>
<p>ここでは <code>RWS</code>モナドを使ってテキストアドベンチャーゲームの処理を設計し
ていきます。</p>
<p><code>RWS</code>モナドは（戻り値の型に加えて）3つの型変数を使って定義されています。</p>
<pre><code class="language-haskell">type RWS r w s = RWST r w s Identity
</code></pre>
<p>副作用を提供しない <code>Identity</code>に基底のモナドを設定することで、 <code>RWS</code>モ
ナドが独自のモナド変換子を用いて定義されていることに注意してください。</p>
<p>第1型引数 <code>r</code>は大域的な設定の型を表します。第2型引数 <code>w</code>はログを蓄積す
るために使用するモノイド、第3型引数 <code>s</code>は可変状態の型を表しています。</p>
<p>このゲームの場合には、大域的な設定は <code>Data.GameEnvironment</code>モジュール
の <code>GameEnvironment</code>と呼ばれる型で定義されています。</p>
<pre><code class="language-haskell">type PlayerName = String

newtype GameEnvironment = GameEnvironment
  { playerName    :: PlayerName
  , debugMode     :: Boolean
  }
</code></pre>
<p>プレイヤー名と、ゲームがデバッグモードで動作しているか否かを示すフラグ
が定義されています。これらのオプションは、モナド変換子を実行するときに
コマンドラインから設定されます。</p>
<p>可変状態は <code>Data.GameState</code>モジュールの <code>GameState</code>と呼ばれる型で定義
されています。</p>
<pre><code class="language-haskell">import Data.Map as M
import Data.Set as S

newtype GameState = GameState
  { items       :: M.Map Coords (S.Set GameItem)
  , player      :: Coords
  , inventory   :: S.Set GameItem
  }
</code></pre>
<p><code>Coords</code>データ型は2次元平面の点を表し、 <code>GameItem</code>データ型はゲーム内の
アイテムの列挙です。</p>
<pre><code class="language-haskell">data GameItem = Candle | Matches
</code></pre>
<p><code>GameState</code>型は2つの新しいデータ構造を使っています。<code>Map</code>と<code>Set</code>はそれ
ぞれ整列されたマップと整列された集合を表します。<code>items</code>属性は、そのゲー
ム平面上の座標からゲームアイテムの集合への対応付けになっています。
<code>player</code>属性はプレイヤーの現在の座標を格納しており、 <code>inventory</code>属性は
現在プレイヤーが保有するゲームアイテムの集合です。</p>
<p><code>Map</code>と <code>Set</code>のデータ構造はキーによって整列され、 <code>Ord</code>型クラスの任意
の型をキーとして使用することができます。これは今回のデータ構造のキーが
完全に順序付けできることを意味します。</p>
<p>ゲームのアクションを書く上で<code>Map</code>と <code>Set</code>構造をどのように使っていくの
かを見ていきます。</p>
<p>ログとしては <code>List String</code>モノイドを使います。<code>Game</code>モナド用の型同義語
を定義し、<code>RWS</code>を使って実装できます。</p>
<pre><code class="language-haskell">type Log = L.List String

type Game = RWS GameEnvironment Log GameState
</code></pre>
<h2 id="ゲームロジックの実装"><a class="header" href="#ゲームロジックの実装">ゲームロジックの実装</a></h2>
<p>今回は、 <code>Reader</code>モナド、 <code>Writer</code>モナド、 <code>State</code>モナドのアクションを
再利用し、 <code>Game</code>モナドで定義されている単純なアクションを組み合わせて
ゲームを構築していきます。このアプリケーションの最上位では、 <code>Game</code>モ
ナドで純粋な計算を実行しており、 <code>Effect</code>モナドはコンソールにテキスト
を出力するような観測可能な副作用へと結果を変換するために使っています。</p>
<p>このゲームで最も簡単なアクションのひとつは <code>has</code>アクションです。このア
クションはプレイヤーの持ち物に特定のゲームアイテムが含まれているかどう
かを調べます。これは次のように定義されます。</p>
<pre><code class="language-haskell">has :: GameItem -&gt; Game Boolean
has item = do
  GameState state &lt;- get
  pure $ item `S.member` state.inventory
</code></pre>
<p>この関数は、現在のゲームの状態を読み取るために <code>MonadState</code>型クラスで
定義されている <code>get</code>アクションを使っており、それから指定した
<code>GameItem</code>が持ち物アイテムの<code>Set</code>に出現するかどうかを調べるために
<code>Data.Set</code>で定義されている <code>member</code>関数を使っています。</p>
<p>他にも <code>pickUp</code>アクションがあります。現在の位置にゲームアイテムがある
場合、プレイヤーの持ち物にそのアイテムを追加します。これには
<code>MonadWriter</code>と <code>MonadState</code>型クラスのアクションを使っています。一番最
初に現在のゲームの状態を読み取ります。</p>
<pre><code class="language-haskell">pickUp :: GameItem -&gt; Game Unit
pickUp item = do
  GameState state &lt;- get
</code></pre>
<p>次に <code>pickUp</code>は現在の位置にあるアイテムの集合を検索します。これは
<code>Data.Map</code>で定義された <code>lookup</code>関数を使って行います。</p>
<pre><code class="language-haskell">  case state.player `M.lookup` state.items of
</code></pre>
<p><code>lookup</code>関数は <code>Maybe</code>型構築子で示されたオプショナルな結果を返します。
<code>lookup</code>関数は、キーがマップにない場合は <code>Nothing</code>を返し、それ以外の場
合は <code>Just</code>構築子で対応する値を返します。</p>
<p>関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含ま
れている場合です。ここでも<code>member</code>関数を使うとこれを調べることができます。</p>
<pre><code class="language-haskell">    Just items | item `S.member` items -&gt; do
</code></pre>
<p>この場合、 <code>put</code>を使ってゲームの状態を更新し、 <code>tell</code>を使ってログにメッ
セージを追加できます。</p>
<pre><code class="language-haskell">          let newItems = M.update (Just &lt;&lt;&lt; S.delete item) state.player state.items
              newInventory = S.insert item state.inventory
          put $ GameState state { items     = newItems
                                , inventory = newInventory
                                }
          tell (L.singleton (&quot;You now have the &quot; &lt;&gt; show item))
</code></pre>
<p>ここで2つの計算のどちらも<code>lift</code>が必要ないことに注意してください。なぜ
なら<code>MonadState</code>と <code>MonadWriter</code>の両方について <code>Game</code>モナド変換子スタッ
ク用の適切なインスタンスが存在するからです。</p>
<p><code>put</code>への引数では、レコード更新を使ってゲームの状態の <code>items</code>と
<code>inventory</code>フィールドを変更しています。特定のキーの値を変更する
<code>Data.Map</code>の <code>update</code>関数を使っています。この場合、プレイヤーの現在の
位置にあるアイテムの集合を変更するのに、<code>delete</code>関数を使って指定したア
イテムを集合から取り除いています。<code>insert</code>を使って新しいアイテムをプレ
イヤーの持ち物集合に加えるときにも、<code>inventory</code>は更新されます。</p>
<p>最後に、<code>pickUp</code>関数は <code>tell</code>を使ってユーザに次のように通知することに
より、残りの場合を処理します。</p>
<pre><code class="language-haskell">    _ -&gt; tell (L.singleton &quot;I don't see that item here.&quot;)
</code></pre>
<p><code>Reader</code>モナドを使う例として、 <code>debug</code>コマンドのコードを見てみましょう。
ゲームがデバッグモードで実行されている場合、このコマンドを使うとユーザ
は実行時にゲームの状態を調べることができます。</p>
<pre><code class="language-haskell">  GameEnvironment env &lt;- ask
  if env.debugMode
    then do
      state :: GameState &lt;- get
      tell (L.singleton (show state))
    else tell (L.singleton &quot;Not running in debug mode.&quot;)
</code></pre>
<p>ここでは、ゲームの設定を読み込むために <code>ask</code>アクションを使用しています。
繰り返しますが、どの計算でも<code>lift</code>は必要がなく、同じdo記法ブロック内で
<code>MonadState</code>、 <code>MonadReader</code>、 <code>MonadWriter</code>型クラスで定義されているア
クションを使うことができることに注意してください。</p>
<p><code>debugMode</code>フラグが設定されている場合、 <code>tell</code>アクションを使ってログに
状態が追加されます。そうでなければ、エラーメッセージが追加されます。</p>
<p><code>Game.purs</code>モジュールの残りの部分では、 <code>MonadState</code>型クラス、
<code>MonadReader</code>型クラス、 <code>MonadWriter</code>型クラスでそれぞれ定義されたアク
ションだけを使って、同様のアクションが定義されています。</p>
<h2 id="計算の実行"><a class="header" href="#計算の実行">計算の実行</a></h2>
<p>このゲームロジックは <code>RWS</code>モナドで動くため、ユーザのコマンドに応答する
ためには計算を実行する必要があります。</p>
<p>このゲームのフロントエンドは2つのパッケージで構成されています。アプリ
カティブなコマンドライン構文解析を提供する<code>optparse</code>と、対話的なコンソー
ルベースのアプリケーションを書くことを可能にするNodeJSの <code>readline</code>モ
ジュールをラップする <code>node-readline</code>パッケージです。</p>
<p>このゲームロジックへのインタフェースは <code>Game</code>モジュール内の関数
<code>game</code>によって提供されます。</p>
<pre><code class="language-haskell">game :: Array String -&gt; Game Unit
</code></pre>
<p>この計算を実行するには、ユーザが入力した単語のリストを文字列の配列とし
て渡してから、 <code>runRWS</code>を使って <code>RWS</code>の計算結果を実行します。</p>
<pre><code class="language-haskell">data RWSResult state result writer = RWSResult state result writer

runRWS :: forall r w s a. RWS r w s a -&gt; r -&gt; s -&gt; RWSResult s a w
</code></pre>
<p><code>runRWS</code>は <code>runReader</code>、 <code>runWriter</code>、 <code>runState</code>を組み合わせたように
見えます。これは、引数として大域的な設定および初期状態をとり、ログ、結
果、最的な終状態を含むデータ構造を返します。</p>
<p>このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数
<code>runGame</code>によって定義されます。</p>
<pre><code class="language-haskell">runGame :: GameEnvironment -&gt; Effect Unit
</code></pre>
<p>この関数は（<code>node-readline</code>と<code>console</code>パッケージを使って）コンソールを
介してユーザとやり取りします。<code>runGame</code>は関数の引数としてのゲームの設
定を取ります。</p>
<p><code>node-readline</code>パッケージでは<code>LineHandler</code>型が提供されています。これは
端末からのユーザ入力を扱う <code>Effect</code>モナドのアクションを表します。対応
するAPIは次の通りです。</p>
<pre><code class="language-haskell">type LineHandler a = String -&gt; Effect a

foreign import setLineHandler
  :: forall a
   . Interface
  -&gt; LineHandler a
  -&gt; Effect Unit
</code></pre>
<p><code>Interface</code>型はコンソールのハンドルを表しており、コンソールとやり取り
する関数への引数として渡されます。 <code>createConsoleInterface</code>関数を使用
すると <code>Interface</code>を作成することができます。</p>
<pre><code class="language-haskell">import Node.ReadLine as RL

runGame env = do
  interface &lt;- RL.createConsoleInterface RL.noCompletion
</code></pre>
<p>最初の手順はコンソールにプロンプトを設定することです。 <code>interface</code>ハン
ドルを渡し、プロンプト文字列と字下げレベルを与えます。</p>
<pre><code class="language-haskell">  RL.setPrompt &quot;&gt; &quot; interface
</code></pre>
<p>今回は行制御関数を実装することに関心があります。ここでの行制御は
<code>let</code>宣言内の補助関数を使って次のように定義されています。</p>
<pre><code class="language-haskell">    lineHandler :: GameState -&gt; String -&gt; Effect Unit
    lineHandler currentState input = do
      case runRWS (game (split (wrap &quot; &quot;) input)) env currentState of
        RWSResult state _ written -&gt; do
          for_ written log
          RL.setLineHandler (lineHandler state) $ interface
      RL.prompt interface
      pure unit
</code></pre>
<p><code>let</code>束縛が<code>env</code>という名前のゲーム構成や<code>interface</code>という名前のコンソー
ルハンドルを包み込んでいます。</p>
<p>このハンドラは追加の最初の引数としてゲームの状態を取ります。ゲームのロ
ジックを実行するために <code>runRWS</code>にゲームの状態を渡さなければならないの
で、これは必要となっています。</p>
<p>このアクションが最初に行うことは、 <code>Data.String</code>モジュールの <code>split</code>関
数を使用して、ユーザーの入力を単語に分割することです。それから、ゲーム
環境と現在のゲームの状態を渡し、 <code>runRWS</code>を使用して（<code>RWS</code>モナドで）
<code>game</code>アクションを実行しています。</p>
<p>純粋な計算であるゲームロジックを実行するには、画面にすべてのログメッセー
ジを出力して、ユーザに次のコマンドのためのプロンプトを表示する必要があ
ります。 <code>for_</code>アクションが（<code>List String</code>型の）ログを走査し、コンソー
ルにその内容を出力するために使われています。最後に<code>setLineHandler</code>を使っ
て行制御関数を更新することでゲームの状態を更新し、<code>prompt</code>アクションを
使ってプロンプトを再び表示しています。</p>
<p><code>runGame</code>関数は最終的にコンソールインターフェイスに最初の行制御子を取
り付けて、最初のプロンプトを表示します。</p>
<pre><code class="language-haskell">  RL.setLineHandler (lineHandler initialGameState) interface
  RL.prompt interface
</code></pre>
<h2 id="演習-39"><a class="header" href="#演習-39">演習</a></h2>
<ol>
<li>
<p>（普通）ゲームの格子上にある全てのゲームアイテムをユーザの持ちものに移
動する新しいコマンド <code>cheat</code>を実装してください。関数<code>cheat :: Game Unit</code>を<code>Game</code>モジュールに作り、この関数を<code>game</code>から使ってください。</p>
</li>
<li>
<p>（難しい）<code>RWS</code>モナドの <code> Writer</code>コンポーネントは、エラーメッセージと
情報メッセージの2つの種類のメッセージのために使われています。このため、
コードのいくつかの箇所では、エラーの場合を扱うためにcase式を使用してい
ます。</p>
<p>エラーメッセージを扱うのに <code>ExceptT</code>モナド変換子を使うようにし、
情報メッセージを扱うのに <code>RWS</code>を使うようにするよう、コードをリファ
クタリングしてください。<strong>補足</strong>：この演習にはテストはありません。</p>
</li>
</ol>
<h2 id="コマンドラインオプションの扱い"><a class="header" href="#コマンドラインオプションの扱い">コマンドラインオプションの扱い</a></h2>
<p>このアプリケーションの最後の部品は、コマンドラインオプションの解析と
<code>GameEnvironment</code>設定レコードを作成する役目にあります。このためには
<code>optparse</code>パッケージを使用します。</p>
<p><code>optparse</code>は<strong>アプリカティブなコマンドラインオプション構文解析器</strong>の一
例です。アプリカティブ関手を使うと、いろいろな副作用の型を表す型構築子
まで任意個数の引数の関数をを持ち上げられることを思い出してください。
<code>optparse</code>パッケージの場合には、コマンドラインオプションからの読み取り
の副作用を追加する<code>Parser</code>関手（optparseのモジュール
<code>Options.Applicative</code>からインポートされたもの。<code>Split</code>モジュールで定義
した<code>Parser</code>と混同しないように）が興味深い関手になっています。これは次
のようなハンドラを提供しています。</p>
<pre><code class="language-haskell">customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a
</code></pre>
<p>実例を見るのが一番です。このアプリケーションの <code>main</code>関数は
<code>customExecParser</code>を使って次のように定義されています。</p>
<pre><code class="language-haskell">main = OP.customExecParser prefs argParser &gt;&gt;= runGame 
</code></pre>
<p>最初の引数は<code>optparse</code>ライブラリを設定するために使用されます。今回の場
合、アプリケーションが引数なしで走らされたときは、（「missing argument」
エラーを表示する代わりに）<code>OP.prefs OP.showHelpOnEmpty</code>を使って使用方
法のメッセージを表示するように設定していますが、
<code>Options.Applicative.Builder</code>モジュールには他にもいくつかのオプション
を提供しています。</p>
<p>2つ目の引数は解析プログラムの完全な説明です。</p>
<pre><code class="language-haskell">  argParser :: OP.ParserInfo GameEnvironment
  argParser = OP.info (env &lt;**&gt; OP.helper) parserOptions

  parserOptions = fold 
    [ OP.fullDesc
    , OP.progDesc &quot;Play the game as &lt;player name&gt;&quot;
    , OP.header &quot;Monadic Adventures! A game to learn monad transformers&quot; 
    ]
</code></pre>
<p>ここで<code>OP.info</code>は使用方法のメッセージが書式化されたようにオプションの
集合と共に<code>Parser</code>を結合します。<code>env &lt;**&gt; OP.helper</code>は<code>env</code>と名付けら
れた任意のコマンドライン引数<code>Parser</code>を取り、自動的に<code>--help</code>オプション
を加えます。使用方法のメッセージ用のオプションは型が<code>InfoMod</code>であり、
これはモノイドなので<code>fold</code>関数を使って複数のオプションを一緒に追加でき
ます。</p>
<p>解析器の面白い部分は<code>GameEnvironment</code>の構築にあります。</p>
<pre><code class="language-haskell">  env :: OP.Parser GameEnvironment
  env = gameEnvironment &lt;$&gt; player &lt;*&gt; debug

  player :: OP.Parser String
  player = OP.strOption $ fold 
    [ OP.long &quot;player&quot;
    , OP.short 'p'
    , OP.metavar &quot;&lt;player name&gt;&quot;
    , OP.help &quot;The player's name &lt;String&gt;&quot;
    ]

  debug :: OP.Parser Boolean
  debug = OP.switch $ fold 
    [ OP.long &quot;debug&quot;
    , OP.short 'd'
    , OP.help &quot;Use debug mode&quot;
    ]
</code></pre>
<p><code>player</code>と<code>debug</code>は両方とも<code>Parser</code>なので、アプリカティブ演算子<code>&lt;$&gt;</code>と
<code>&lt;*&gt;</code>を使って<code>gameEnvironment</code>関数を持ち上げることができます。この関数
は<code>Parser</code>上で型<code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code>を持ちます。
<code>OP.strOption</code>は文字列値を期待するコマンドラインオプションを構築し、一
緒に畳み込まれた<code>Mod</code>の集まりを介して設定されています。<code>OP.flag</code>は似た
ような動作をしますが、関連付けられた値は期待しません。<code>optparse</code>は多種
多様なコマンドライン解析器を構築するために使える様々な修飾子について、
大部の<a href="https://pursuit.purescript.org/packages/purescript-optparse">ドキュメン
ト</a>を提供
しています。</p>
<p>アプリカティブ演算子による記法を使うことで、コマンドラインインターフェ
イスに対してコンパクトで宣言的な仕様を与えることが可能になったことに注
目です。また、<code>runGame</code>に新しい関数引数を追加し、<code>env</code>の定義中で
<code>&lt;*&gt;</code>を使って追加の引数まで <code>runGame</code>を持ち上げるだけで、簡単に新しい
コマンドライン引数を追加することができます。</p>
<h2 id="演習-40"><a class="header" href="#演習-40">演習</a></h2>
<ol>
<li>（普通）<code>GameEnvironment</code>レコードに新しい真偽値のプロパティ
<code>cheatMode</code>を追加してください。 また、 <code>optparse</code>設定に、チートモード
を有効にする新しいコマンドラインフラグ <code>-c</code>を追加してください。チート
モードが有効になっていない場合、 <code>cheat</code>コマンドは禁止されなければなり
ません。</li>
</ol>
<h2 id="まとめ-9"><a class="header" href="#まとめ-9">まとめ</a></h2>
<p>この章ではこれまで学んできた技術の実践的な実演を行いました。モナド変換
子を使用したゲームの純粋な仕様の構築、コンソールを使用したフロントエン
ドを構築するための <code>Effect</code>モナドがそれです。</p>
<p>ユーザインターフェイスからの実装を分離したので、ゲームの別のフロントエ
ンドを作成することも可能でしょう。例えば、 <code>Effect</code>モナドでCanvas API
やDOMを使用して、ブラウザでゲームを描画するようなことができるでしょう。</p>
<p>モナド変換子によって命令型のスタイルで安全なコードを書くことができるこ
とを見てきました。このスタイルでは型システムによって作用が追跡されてい
ます。また、型クラスはモナドが提供するアクションへと抽象化する強力な方
法を提供します。このモナドのお陰でコードの再利用が可能になりました。標
準的なモナド変換子を組み合わせることにより、 <code>Alternative</code>や
<code>MonadPlus</code>のような標準的な抽象化を使用して、役に立つモナドを構築する
ことができました。</p>
<p>モナド変換子は、高階多相や多変数型クラスなどの高度な型システムの機能を
利用することによって記述することができ、表現力の高いコードの優れた実演
となっています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvasグラフィックス"><a class="header" href="#canvasグラフィックス">Canvasグラフィックス</a></h1>
<h2 id="この章の目標-10"><a class="header" href="#この章の目標-10">この章の目標</a></h2>
<p>この章は<code>canvas</code>パッケージに焦点を当てる発展的な例となります。このパッ
ケージはPureScriptでHTML5のCanvas APIを使用して2Dグラフィックスを生成
する手段を提供します。</p>
<h2 id="プロジェクトの準備-9"><a class="header" href="#プロジェクトの準備-9">プロジェクトの準備</a></h2>
<p>このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。</p>
<ul>
<li><code>canvas</code>はHTML5のCanvas APIのメソッドの型を与えます。</li>
<li><code>refs</code>は<strong>大域的な変更可能領域への参照</strong>を使うための副作用を提供します。</li>
</ul>
<p>この章のソースコードは、それぞれに <code>main</code>メソッドが定義されているモジュー
ルの集合へと分割されています。この章のそれぞれの節の内容はそれぞれの異
なるファイルで実装されており、それぞれの時点での適切なファイルの
<code>main</code>メソッドを実行できるように、Spagoビルドコマンドを変更することで
<code>Main</code>モジュールが変更できるようになっています。</p>
<p>HTMLファイル <code>html/index.html</code>には、各例で使用される単一の <code>canvas</code>要
素、およびコンパイルされたPureScriptコードを読み込む <code>script</code>要素が含
まれています。ほとんどの演習はブラウザを対象にしているので、この章には
単体試験はありません。</p>
<h2 id="単純な図形"><a class="header" href="#単純な図形">単純な図形</a></h2>
<p><code>Example/Rectangle.purs</code>ファイルには簡単な導入例が含まれています。この
例ではcanvasの中心に青い四角形をひとつ描画します。このモジュールは、
<code>Effect</code>モジュールからの<code>Effect</code>型と、Canvas APIを扱うための<code>Effect</code>モ
ナドのアクションを含む<code>Graphics.Canvas</code>モジュールをインポートします。</p>
<p>他のモジュールでも同様ですが、 <code>main</code>アクションは最初に
<code>getCanvasElementById</code>アクションを使ってcanvasオブジェクトへの参照を取
得しています。また、 <code>getContext2D</code>アクションを使ってキャンバスの2D描
画コンテキストを参照しています。</p>
<p><code>void</code>関数は関手を取り値を<code>Unit</code>で置き換えます。例では<code>main</code>がシグネチャ
に沿うようにするために使われています。</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><strong>注意</strong>：この<code>unsafePartial</code>の呼び出しは必須です。これは
<code>getCanvasElementById</code>の結果のパターン照合部分的で、<code>Just</code>値構築子だけ
と照合するためです。ここではこれで問題ありませんが、実際の製品のコード
ではおそらく<code>Nothing</code>値構築子と照合させ、適切なエラーメッセージを提供
したほうがよいでしょう。</p>
<p>これらのアクションの型は、PSCiを使うかドキュメントを見ると確認できます。</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code>と <code>Context2D</code>は <code>Graphics.Canvas</code>モジュールで定義され
ている型です。このモジュールでは<code>Canvas</code>作用も定義されており、モジュー
ル内のすべてのアクションで使用されています。</p>
<p>グラフィックスコンテキスト <code>ctx</code>は、canvasの状態を管理し、原始的な図形
を描画したり、スタイルや色を設定したり、座標変換を適用するためのメソッ
ドを提供しています。</p>
<p>話を進めると、<code>setFillStyle</code>アクションを使うことで塗り潰しスタイルを濃
い青に設定できます。より長い16進数記法の<code>#0000FF</code>も青には使えますが、
略記法が単純な色についてはより簡単です。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p><code>setFillStyle</code>アクションがグラフィックスコンテキストを引数として取って
いることに注意してください。これは <code>Graphics.Canvas</code>ではよくあるパター
ンです。</p>
<p>最後に、 <code>fillPath</code>アクションを使用して矩形を塗りつぶしています。
<code>fillPath</code>は次のような型を持っています。</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code>はグラフィックスコンテキストと描画するパスを構築する別のアク
ションを引数にとります。パスは <code>rect</code>アクションを使うと構築することが
できます。 <code>rect</code>はグラフィックスコンテキストと矩形の位置及びサイズを
格納するレコードを引数にとります。</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>mainモジュールの名前として<code>Example.Rectangle</code>を与えてこの長方形のコー
ド例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>それでは <code>html/index.html</code>ファイルを開き、このコードによってcanvasの中
央に青い四角形が描画されていることを確認してみましょう。</p>
<h2 id="行多相を利用する"><a class="header" href="#行多相を利用する">行多相を利用する</a></h2>
<p>パスを描画する方法は他にもあります。 <code>arc</code>関数は円弧を描画します。
<code>moveTo</code>関数、 <code>lineTo</code>関数、 <code>closePath</code>関数は断片的な線分のパスを描
画するのに使えます。</p>
<p><code>Shapes.purs</code>ファイルでは長方形と円弧と三角形の、3つの図形を描画してい
ます。</p>
<p><code>rect</code>関数は引数としてレコードをとることを見てきました。実際には、長方
形のプロパティは型同義語で定義されています。</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p><code>x</code>と <code>y</code>プロパティは左上隅の位置を表しており、 <code>w</code>と <code>h</code>のプロパティ
はそれぞれ幅と高さを表しています。</p>
<p><code>arc</code>関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画
することができます。</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>ここで、 <code>x</code>と <code>y</code>プロパティは弧の中心、 <code>r</code>は半径、 <code>start</code>と <code>end</code>は
弧の両端の角度を弧度法で表しています。</p>
<p>例えばこのコードは中心が<code>(300, 300)</code>に中心があり半径<code>50</code>の円弧を塗り潰
します。弧は1回転のうち2/3 rds分あります。単位円が鉛直方向に反転するこ
とに注意してください。これはy軸がcanvasの下向きに増加するためです。</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p><code>Number</code>型の <code>x</code>と <code>y</code>というプロパティが <code>Rectangle</code>レコード型と
<code>Arc</code>レコード型の両方に含まれていることに注意してください。どちらの場
合でもこの組は点を表しています。これは、いずれのレコード型にも適用でき
る、行多相な関数を書くことができることを意味します。</p>
<p>たとえば、 <code>Shapes</code>モジュールでは <code>x</code>と <code>y</code>のプロパティを変更し図形を
並行移動する <code>translate</code>関数を定義されています。</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>この行多相型に注目してください。これは <code>triangle</code>が <code>x</code>と <code>y</code>というプ
ロパティと、<strong>それに加えて他の任意のプロパティ</strong>を持ったどんなレコード
でも受け入れ、同じ型のレコードを返すということを言っています。 <code>x</code>フィー
ルドと <code>y</code>フィールドは更新されますが、残りのフィールドは変更されません。</p>
<p>これは<strong>レコード更新構文</strong>の例です。 <code>shape { ... }</code>という式は、
<code>shape</code>を元にして、括弧の中で指定された値で更新されたフィールドを持つ
新たなレコードを作ります。波括弧の中の式はレコードリテラルのようなコロ
ンではなく、等号でラベルと式を区切って書くことに注意してください。</p>
<p><code>Shapes</code>の例からわかるように、 <code>translate</code>関数は <code>Rectangle</code>レコードと
<code>Arc</code>レコード双方に対して使うことができます。</p>
<p><code>Shape</code>の例で描画される3つめの型は区分からなる線分のパスです。対応する
コードは次のようになります。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>ここでは3つの関数が使われています。</p>
<ul>
<li><code>moveTo</code>はパスの現在地を指定された座標に移動します。</li>
<li><code>lineTo</code>は現在地と指定された座標の間の線分を描画し、現在地を更新します。</li>
<li><code>closePath</code>は現在地と開始地点とを結ぶ線分を描画してパスを完結します。</li>
</ul>
<p>このコード片の結果は二等辺三角形の塗り潰しです。</p>
<p>mainモジュールとして<code>Example.Shapes</code>を指定して、この例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>そしてもう一度 <code>html/index.html</code>を開き、結果を確認してください。canvas
に3つの異なる図形が描画されるはずです。</p>
<h2 id="演習-41"><a class="header" href="#演習-41">演習</a></h2>
<ol>
<li>
<p>（簡単）これまでの例のそれぞれについて、 <code>strokePath</code>関数や
<code>setStrokeStyle</code>関数を使ってみましょう。</p>
</li>
<li>
<p>（簡単）関数の引数の内部のdo記法ブロックにより、<code>fillPath</code>関数と
<code>strokePath</code>関数を使って共通のスタイルを持つ複雑なパスを描画することが
できます。同じ <code>fillPath</code>呼び出しで隣り合った2つの矩形を描画するように、
<code>Rectangle</code>のコード例を変更してみてください。線分と円弧を組み合わせて
を、円の扇形を描画してみてください。</p>
</li>
<li>
<p>（普通）次のような2次元の点を表すレコードが与えられたとします。</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>これは2次元の点を表現しています。
多数の点からなる閉じたパスを線描きする関数 <code>renderPath</code>を書いてください。</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>次のような関数を考えます。</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>この関数は引数として <code>1</code>から <code>0</code>の間の <code>Number</code>をとり、 <code>Point</code>を
返します。 <code>renderPath</code>関数を利用して関数 <code>f</code>のグラフを描くアクショ
ンを書いてください。そのアクションは有限個の点を <code>f</code>からサンプリン
グすることによって近似しなければなりません。</p>
<p>関数 <code>f</code>を変更し、様々なパスが描画されることを確かめてください。</p>
</li>
</ol>
<h2 id="無作為に円を描く"><a class="header" href="#無作為に円を描く">無作為に円を描く</a></h2>
<p><code>Example/Random.purs</code>ファイルには2種類の異なる副作用が混在した
<code>Effect</code>モナドを使う例が含まれています。1つは乱数生成で、もう1つは
canvasの操作です。この例では無作為に生成された円をキャンバスに100個描
画します。</p>
<p><code>main</code>アクションはこれまでのようにグラフィックスコンテキストへの参照を
取得し、ストロークと塗りつぶしスタイルを設定します。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>次のコードでは <code>for_</code>アクションを使って <code>0</code>から <code>100</code>までの整数につい
て繰り返しをしています。</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>それぞれの繰り返しではdo記法ブロックは<code>0</code>と<code>1</code>の間に分布する3つの乱数
を生成することから始まります。これらの数は <code>0</code>から <code>1</code>の間に無作為に分
布しており、それぞれ <code>x</code>座標、 <code>y</code>座標、半径 <code>r</code>を表しています。</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>次のコードではそれぞれの円について、これらの変数に基づいて <code>Arc</code>を作成
し、最後に現在のスタイルに従って円弧の塗りつぶしと線描が行われます。</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x                  : x * 600.0
         , y                  : y * 600.0
         , radius             : r * 50.0
         , start              : 0.0
         , end                : Number.tau
         , useCounterClockwise: false
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>mainモジュールとして<code>Example.Random</code>を指定して、この例をビルドしましょ
う。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いて、結果を確認してみましょう。</p>
<h2 id="座標変換"><a class="header" href="#座標変換">座標変換</a></h2>
<p>キャンバスは簡単な図形を描画するだけのものではありません。キャンバスは
変換行列を扱うことができ、図形は描画の前に形状を変形してから描画されま
す。図形は平行移動、回転、拡大縮小、および斜めに変形することができます。</p>
<p><code>canvas</code>ライブラリではこれらの変換を以下の関数で提供しています。</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p><code>translate</code>アクションは <code>TranslateTransform</code>レコードのプロパティで指定
した大きさだけ平行移動を行います。</p>
<p><code>rotate</code>アクションは最初の引数で指定されたラジアンの値に応じて原点を中
心とした回転を行います。</p>
<p><code>scale</code>アクションは原点を中心として拡大縮小します。 <code>ScaleTransform</code>レ
コードは <code>X</code>軸と <code>y</code>軸に沿った拡大率を指定するのに使います。</p>
<p>最後の <code>transform</code>はこの4つのうちで最も一般的なアクションです。このアクションは行列に従ってアフィン変換を行います。</p>
<p>これらのアクションが呼び出された後に描画される図形は、自動的に適切な座
標変換が適用されます。</p>
<p>実際には、これらの関数のそれぞれの作用は、コンテキストの現在の変換行列
に対して変換行列を<strong>右から乗算</strong>していきます。つまり、もしある作用の変
換をしていくと、その作用は実際には逆順に適用されていきます：</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>この一連のアクションの作用では、まずシーンが回転され、それから拡大縮小
され、最後に平行移動されます。</p>
<h2 id="コンテキストの保存"><a class="header" href="#コンテキストの保存">コンテキストの保存</a></h2>
<p>変換を適用してシーンの一部を描画し、それからその変換を元に戻す、という
使い方はよくあります。</p>
<p>Canvas APIにはキャンバスの状態の<strong>スタック</strong>を操作する <code>save</code>と
<code>restore</code>メソッドが備わっています。 <code>canvas</code>ではこの機能を次のような関
数でラップしています。</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p><code>save</code>アクションは現在のコンテキストの状態（現在の変換行列や描画スタイ
ル）をスタックにプッシュし、 <code>restore</code>アクションはスタックの一番上の状
態をポップし、コンテキストの状態を復元します。</p>
<p>これらのアクションにより、現在の状態を保存し、いろいろなスタイルや変換
を適用し、原始的な図形を描画し、最後に元の変換と状態を復元することが可
能になります。例えば、次の関数はいくつかのキャンバスアクションを実行し
ますが、その前に回転を適用し、そのあとに変換を復元します。</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>こういったよくある使いかたの高階関数を利用した抽象化として、
<code>canvas</code>ライブラリでは元のコンテキスト状態を保存しつついくつかのキャン
バスアクションを実行する <code>withContext</code>関数が提供されています。</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p><code>withContext</code>を使うと、先ほどの <code>rotated</code>関数を次のように書き換えるこ
とができます。</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="大域的な変更可能状態"><a class="header" href="#大域的な変更可能状態">大域的な変更可能状態</a></h2>
<p>この節では <code>refs</code>パッケージを使って <code>Effect</code>モナドの別の作用について実
演してみます。</p>
<p><code>Effect.Ref</code>モジュールでは大域的に変更可能な参照のための型構築子、およ
び関連する作用を提供します。</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>型<code>Ref a</code>の値は型<code>a</code>の値を含む可変参照セルであり、大域的な変更を追跡す
るのに使われます。そういったわけでこれは少しだけ使う分に留めておくべき
です。</p>
<p><code>Example/Refs.purs</code>ファイルには <code>canvas</code>要素上のマウスクリックを追跡す
るのに <code>Ref</code>作用を使用する例が含まれています。</p>
<p>このコー​​ドでは最初に <code>new</code>アクションを使って値 <code>0</code>を含む新しい参照を作
成しています。</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>クリックイベントハンドラの内部では、 <code>modify</code>アクションを使用してクリッ
ク数を更新し、更新された値が返されています。</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p><code>render</code>関数では、クリック数に応じて変換を矩形に適用しています。</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Number.sin (toNumber count * Number.tau / 8.0) + 1.5
    let scaleY = Number.sin (toNumber count * Number.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Number.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>このアクションでは元の変換を保存するために <code>withContext</code>を使用しており、
それから一連の変換を適用しています（変換が下から上に適用されることを思
い出してください）。</p>
<ul>
<li>矩形は<code>(-100, -100)</code>だけ平行移動し中心が原点に来ます。</li>
<li>矩形が原点を中心に拡大されます。</li>
<li>矩形が原点を中心に<code>10</code>の倍数分の角度で回転します。</li>
<li>矩形が<code>(300, 300)</code>だけ平行移動し中心がcanvasの中心に来ます。</li>
</ul>
<p>このコード例をビルドしてみましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>ファイルを開いてみましょう。何度かキャンバスをクリッ
クすると、キャンバスの中心の周りを回転する緑の四角形が表示されるはずで
す。</p>
<h2 id="演習-42"><a class="header" href="#演習-42">演習</a></h2>
<ol>
<li>（簡単）パスの線描と塗り潰しを同時に行う高階関数を書いてください。その
関数を使用して <code>Random.purs</code>例を書き直してください。</li>
<li>（普通）<code>Random</code>作用と <code>Dom</code>作用を使用して、マウスがクリックされたとき
に、キャンバスに無作為な位置、色、半径の円を描画するアプリケーションを
作成してください。</li>
<li>（普通）シーンを指定された座標を中心に回転する関数を書いてください。
<strong>ヒント</strong>：最初にシーンを原点まで平行移動しましょう。</li>
</ol>
<h2 id="l-system"><a class="header" href="#l-system">L-System</a></h2>
<p>この章の最後の例として、 <code>canvas</code>パッケージを使用して<strong>L-system</strong>
(Lindenmayer system) を描画する関数を記述します。</p>
<p>L-Systemは<strong>アルファベット</strong>、つまり初期状態となるアルファベットの文
字列と、<strong>生成規則</strong>の集合で定義されています。各生成規則は、アルファベッ
トの文字をとり、それを置き換える文字の配列を返します。この処理は文字の
初期配列から始まり、複数回繰り返されます。</p>
<p>もしアルファベットの各文字がcanvas上で実行される命令と対応付けられてい
れば、その指示に順番に従うことでL-Systemを描画することができます。</p>
<p>たとえば、アルファベットが文字 <code>L</code>（左回転）、 <code>R</code>（右回転）、 <code>F</code>（前
進）で構成されていたとします。また、次のような生成規則を定義します。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>配列 &quot;FRRFRRFRR&quot; から始めて処理を繰り返すと、次のような経過を辿ります。</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>この命令群に対応する線分パスをプロットすると、<strong>コッホ曲線</strong>と呼ばれる
曲線に近似します。反復回数を増やすと、曲線の解像度が増加していきます。</p>
<p>それでは型と関数の言語へとこれを翻訳してみましょう。</p>
<p>アルファベットの文字は以下のADTで表現できます。</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>このデータ型では、アルファベットの文字ごとに1つずつデータ構築子が定義されています。</p>
<p>文字の初期配列はどのように表したらいいでしょうか。単なるアルファベット
の配列でいいでしょう。これを <code>Sentence</code>と呼ぶことにします。</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>生成規則は以下のように<code>Letter</code>から <code>Sentence</code>への関数として表すことができます。</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>これはまさに上記の仕様をそのまま書き写したものです。</p>
<p>これで、この形式の仕様を受け取りcanvasに描画する関数 <code>lsystem</code>を実装す
ることができます。 <code>lsystem</code>はどのような型を持っているべきでしょうか。
この関数は初期状態 <code>initial</code>と生成規則 <code>productions</code>のような値だけでな
く、アルファベットの文字をcanvasに描画する関数を引数に取る必要があ
ります。</p>
<p><code>lsystem</code>の型の最初の大まかな設計は以下です。</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>最初の2つの引数の型は、値 <code>initial</code>と <code>productions</code>に対応しています。</p>
<p>3番目の引数は、アルファベットの文字を取り、canvas上のいくつかのアクショ
ンを実行することによって<strong>翻訳</strong>する関数を表します。この例では、文字
<code>L</code>は左回転、文字 <code>R</code>で右回転、文字 <code>F</code>は前進を意味します。</p>
<p>最後の引数は、実行したい生成規則の繰り返し回数を表す数です。</p>
<p>最初に気付くことは、この<code>lsystem</code>関数は1つの型<code>Letter</code>に対してのみ動作
するのですが、どんなアルファベットについても機能すべきですから、この型
はもっと一般化されるべきです。それでは、量子化された型変数 <code>a</code>について、
<code>Letter</code>と <code>Sentence</code>を <code>a</code>と <code>Array a</code>で置き換えましょう。</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>次に気付くこととしては、「左回転」と「右回転」のような命令を実装するた
めには、いくつかの状態を管理する必要があります。具体的に言えば、その時
点でパスが向いている方向を状態として持たなければなりません。計算を通じ
て状態を関数に渡すように変更する必要があります。ここでも <code>lsystem</code>関数
は状態がどんな型でも動作したほうがよいので、型変数 <code>s</code>を使用してそれを
表しています。</p>
<p>型 <code>s</code>を追加する必要があるのは3箇所で、次のようになります。</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>まず追加の引数の型として <code>lsystem</code>に型 <code>s</code>が追加されています。この引数
はL-Systemの初期状態を表しています。</p>
<p>型 <code>s</code>は引数にも現れますが、翻訳関数（<code>lsystem</code>の第3引数）の返り値の型と
しても現れます。翻訳関数は今のところ、引数としてL-Systemの現在の状態を
受け取り、返り値として更新された新しい状態を返します。</p>
<p>この例の場合では、次のような型を使って状態を表す型を定義することができ
ます。</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>プロパティ <code>x</code>と <code>y</code>はパスの現在の位置を表しており、プロパティ
<code>theta</code>はパスの現在の向きを表しています。これはラジアンで表された水平
線に対するパスの角度として指定されています。</p>
<p>システムの初期状態としては次のように指定されます。</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>それでは、 <code>lsystem</code>関数を実装してみます。定義はとても単純であることが
わかるでしょう。</p>
<p><code>lsystem</code>は第4引数の値（型<code>Int</code>）に応じて再帰するのが良さそうです。再帰の各ステップでは、生成規則に従って状態が更新され、現在の文が変化していきます。このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を移譲することから始めましょう。</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p><code>go</code>関数は第2引数に応じて再帰することで動きます。場合分けは2つであり、
<code>n</code>がゼロであるときと <code>n</code>がゼロでないときです。</p>
<p>1つ目の場合は再帰は完了し、翻訳関数に応じて現在の文を翻訳します。型
<code>Array a</code>の文、型 <code>s</code>の状態、型 <code>s -&gt; a -&gt; Effect s</code>の関数があります。
以前定義した <code>foldM</code>でやったことのように聞こえます。この関数は
<code>control</code>パッケージで手に入ります。</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>ゼロでない場合ではどうでしょうか。その場合は、単に生成規則を現在の文の
それぞれの文字に適用して、その結果を連結し、そして再帰的に<code>go</code>を呼び出
すことによって繰り返します。</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>これだけです！<code>foldM</code>や <code>concatMap</code>のような高階関数を使うと、このよう
にアイデアを簡潔に表現することができるのです。</p>
<p>しかし、話はこれで終わりではありません。ここで与えた型は、実際はまだ特
殊化されすぎています。この定義ではcanvasの操作が実装のどこにも使われて
いないことに注目してください。それに、まったく <code>Effecta</code>モナドの構造を
利用していません。実際には、この関数は<strong>どんな</strong>モナド <code>m</code>についても動
作するのです！</p>
<p>この章に添付されたソースコードで指定されている、 <code>lsystem</code>のもっと一般
的な型は次のようになっています。</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>この型が言っているのは、この翻訳関数はモナド <code>m</code>が持つ任意の副作用をまっ
たく自由に持つことができる、ということだと理解することができます。キャ
ンバスに描画したり、またはコンソールに情報を出力するかもしれませんし、
失敗や複数の戻り値に対応しているかもしれません。こういった様々な型の副
作用を使ったL-Systemを記述してみることを読者にお勧めします。</p>
<p>この関数は実装からデータを分離することの威力を示す良い例となっています。
この手法の利点は、複数の異なる方法でデータを解釈する自由が得られること
です。 <code>lsystem</code>は2つの小さな関数へと分解することさえできるかもしれま
せん。1つ目は <code>concatMap</code>の適用の繰り返しを使って文を構築するもので、2
つ目は <code>foldM</code>を使って文を翻訳するものです。これは読者の演習として残し
ておきます。</p>
<p>それでは翻訳関数を実装して、この章の例を完成させましょう​​。 <code>lsystem</code>の
型は型シグネチャが言っているのは、翻訳関数の型は、何らかの型 <code>a</code>と <code>s</code>、
型構築子 <code>m</code>について、 <code>s -&gt; a -&gt; m s</code>でなければならないということです。
<code>a</code>を <code>Letter</code>、 <code>s</code>を <code>State</code>、モナド <code>m</code>を <code>Effect</code>というように選び
たいということがわかっています。これにより次のような型になります。</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>この関数を実装するには、 <code>Letter</code>型の3つのデータ構築子それぞれについて
処理する必要があります。文字 <code>L</code>（左回転）と <code>R</code>（右回転）の翻訳では、
<code>theta</code>を適切な角度へ変更するように状態を更新するだけです。</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Number.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Number.tau / 6.0 }
</code></pre>
<p>文字 <code>F</code>（前進）を翻訳するには、パスの新しい位置を計算し、線分を描画し、
状態を次のように更新します。</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Number.cos state.theta * 1.5
          y = state.y + Number.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>この章のソースコードでは、名前 <code>ctx</code>がスコープ内に来るように、
<code>interpret</code>関数は <code>main</code>関数内で <code>let</code>束縛を使用して定義されていること
に注意してください。 <code>State</code>型がコンテキストを持つように変更することは
可能でしょうが、それはこのシステムの状態の変化部分ではないので不適切で
しょう。</p>
<p>このL-Systemを描画するには、次のような <code>strokePath</code>アクションを使用するだけです。</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>次のコマンドを使ってL-Systemをコンパイルします。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いてみましょう。キャンバスにコッホ曲線が描画され
るのがわかると思います。</p>
<h2 id="演習-43"><a class="header" href="#演習-43">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>strokePath</code>の代わりに <code>fillPath</code>を使用するように、上の
L-Systemの例を変更してください。<strong>ヒント</strong>：<code>closePath</code>の呼び出しを含
め、 <code>moveTo</code>の呼び出しを <code>interpret</code>関数の外側に移動する必要がありま
す。</p>
</li>
<li>
<p>（簡単）描画システムへの影響を理解するために、コード中の様々な数値の定
数を変更してみてください。</p>
</li>
<li>
<p>（普通）<code>lsystem</code>関数を2つの小さな関数に分割してください。1つ目は
<code>concatMap</code>の適用の繰り返しを使用して最終的な文を構築するもので、2つ目
は <code>foldM</code>を使用して結果を解釈するものでなくてはなりません。</p>
</li>
<li>
<p>（普通）<code>setShadowOffsetX</code>アクション、 <code>setShadowOffsetY</code>アクション、
<code>setShadowBlur</code>アクション、 <code>setShadowColor</code>アクションを使い、塗りつぶ
された図形にドロップシャドウを追加してください。<strong>ヒント</strong>：PSCiを使っ
て、これらの関数の型を調べてみましょう。</p>
</li>
<li>
<p>（普通）向きを変えるときの角度の大きさは今のところ一定 (<code>tau/6</code>) です。
その代わりに、<code>Letter</code>データ型の中に角度を移動させることで、生成規則に
よって変更するようにしてください。</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>生成規則でこの新しい情報を使うと、どんな面白い図形を作ることがで
きるでしょうか。</p>
</li>
<li>
<p>（難しい）<code>L</code>（60度左回転）、 <code>R</code>（60度右回転）、
<code>F</code>（前進）、 <code>M</code>（これも前進）という4つの文字からなるアルファベット
でL-Systemが与えられたとします。</p>
<p>このシステムの文の初期状態は、単一の文字 <code>M</code>です。</p>
<p>このシステムの生成規則は次のように指定されています。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>このL-Systemを描画してください。<strong>注意</strong>：最後の文のサイズは反復
回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を
削減することが必要になります。</p>
<p>ここで、生成規則における <code>L</code>と <code>M</code>の間の対称性に注目してください。
ふたつの「前進」命令は、次のようなアルファベット型を使用すると、
<code>Boolean</code>値を使って区別することができます。</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>このアルファベットの表現を使用して、もう一度このL-Systemを実装して
ください。</p>
</li>
<li>
<p>（難しい）翻訳関数で別のモナド <code>m</code>を使ってみましょう。
<code>Effect.Console</code>作用を利用してコンソール上にL-Systemを出力したり、
<code>Random</code>作用を利用して状態の型に無作為の「突然変異」を適用したりしてみてください。</p>
</li>
</ol>
<h2 id="まとめ-10"><a class="header" href="#まとめ-10">まとめ</a></h2>
<p>この章では、 <code>canvas</code>ライブラリを使用することにより、PureScriptから
HTML5 Canvas APIを使う方法について学びました。また、これまで学んできた
手法の多くを利用した実用的な例について見ました。マップや畳み込み、レコー
ドと行多相、副作用を扱うための <code>Effect</code>モナドなどです。</p>
<p>この章の例では、高階関数の威力を示すとともに、<strong>実装からのデータの分離</strong>
も実演してみせました。これは例えば、代数データ型を使用してこれらの概
念を次のように拡張し、描画関数からシーンの表現を完全に分離できるように
なります。</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>この手法は <code>drawing</code>パッケージでも採用されており、描画前にさまざまな方
法でデータとしてシーンを操作することができるという柔軟性をもたらしてい
ます。</p>
<p>canvasに描画されるゲームの例については
<a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>
の「Behavior」と「Signal」のレシピを見てください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="テストの自動生成"><a class="header" href="#テストの自動生成">テストの自動生成</a></h1>
<h2 id="この章の目標-11"><a class="header" href="#この章の目標-11">この章の目標</a></h2>
<p>この章では、テスティングの問題に対する、型クラスの特に洗練された応用について示します。<strong>どのように</strong>テストするのかをコンパイラに教えるのではなく、コードが<strong>どのような</strong>性質を持っているべきかを教えることでテストします。型クラスを使って無作為データ生成のための定型コードを隠し、テストケースを仕様から無作為に生成することができます。これは<strong>生成的テスティング</strong>（generative
testing、または<strong>property-based
testing</strong>）と呼ばれ、Haskellの<a href="http://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a>ライブラリによって普及した手法です。</p>
<p><code>quickcheck</code>パッケージはHaskellのQuickCheckライブラリをPureScriptにポーティングしたもので、型や構文はもとのライブラリとほとんど同じようになっています。
<code>quickcheck</code>を使って簡単なライブラリをテストし、Spagoでテストスイートを自動化されたビルドに統合する方法を見ていきます。</p>
<h2 id="プロジェクトの準備-10"><a class="header" href="#プロジェクトの準備-10">プロジェクトの準備</a></h2>
<p>この章のプロジェクトには依存関係として <code>quickcheck</code>が追加されます。</p>
<p>Spagoプロジェクトでは、テストソースは <code>test</code>ディレクトリに置かれ、テストスイートのメインモジュールは
<code>Test.Main</code>と名づけられます。 テストスイートは、 <code>spago test</code>コマンドを使用して実行できます。</p>
<h2 id="性質を書く"><a class="header" href="#性質を書く">性質を書く</a></h2>
<p><code>Merge</code>モジュールでは簡単な関数 <code>merge</code>が実装されています。
これを<code>quickcheck</code>ライブラリの機能を実演するために使っていきます。</p>
<pre><code class="language-haskell">merge :: Array Int -&gt; Array Int -&gt; Array Int
</code></pre>
<p><code>merge</code>は2つの整列された整数の配列を取って、結果が整列されるように要素を統合します。
例えば次のようになります。</p>
<pre><code class="language-text">&gt; import Merge
&gt; merge [1, 3, 5] [2, 4, 5]

[1, 2, 3, 4, 5, 5]
</code></pre>
<p>典型的なテストスイートでは、手作業でこのような小さなテストケースをいくつも作成し、結果が正しい値と等しいことを確認することでテストを実施します。
しかし、 <code>merge</code>関数について知る必要があるものはすべて、こちらの性質に要約することができます。</p>
<ul>
<li><code>xs</code>と <code>ys</code>がソート済みなら、<code>merge xs ys</code>は両方の配列が一緒に結合され整列された結果になります。</li>
</ul>
<p><code>quickcheck</code>では、無作為なテストケースを生成することで、直接この性質をテストすることができます。コードが持つべき性質を関数として述べるだけです。
この場合は1つの性質があります。</p>
<pre><code class="language-haskell">main = do
  quickCheck \xs ys -&gt;
    eq (merge (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>このコードを実行すると、 <code>quickcheck</code>は無作為な入力 <code>xs</code>と
<code>ys</code>を生成してこの関数に渡すことで、主張しようとしている性質を反証しようとします。
何らかの入力に対して関数が <code>false</code>を返した場合、性質は正しくないことが示され、ライブラリはエラーを発生させます。
幸いなことに、次のように100個の無作為なテストケースを生成しても、ライブラリはこの性質を反証することができません。</p>
<pre><code class="language-text">$ spago test

Installation complete.
Build succeeded.
100/100 test(s) passed.
...
Tests succeeded.
</code></pre>
<p>もし
<code>merge</code>関数に意図的にバグを混入した場合（例えば、大なりのチェックを小なりのチェックへと変更するなど）、最初に失敗したテストケースの後で例外が実行時に投げられます。</p>
<pre><code class="language-text">Error: Test 1 failed:
Test returned false
</code></pre>
<p>見ての通りこのエラーメッセージではあまり役に立ちませんが、少し工夫するだけで改良することができます。</p>
<h2 id="エラーメッセージの改善"><a class="header" href="#エラーメッセージの改善">エラーメッセージの改善</a></h2>
<p>テストケースが失敗した時に同時にエラーメッセージを提供する上で、
<code>quickcheck</code>は<code>&lt;?&gt;</code>演算子を提供しています。
次のように性質の定義とエラー文言を<code>&lt;?&gt;</code>で区切って書くだけです。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  let
    result = merge (sort xs) (sort ys)
    expected = sort $ xs &lt;&gt; ys
  in
    eq result expected &lt;?&gt; &quot;Result:\n&quot; &lt;&gt; show result &lt;&gt; &quot;\nnot equal to expected:\n&quot; &lt;&gt; show expected
</code></pre>
<p>このとき、もしバグを混入するようにコードを変更すると、最初のテストケースが失敗したときに改良されたエラーメッセージが表示されます。</p>
<pre><code class="language-text">Error: Test 1 (seed 534161891) failed:
Result:
[-822215,-196136,-116841,618343,887447,-888285]
not equal to expected:
[-888285,-822215,-196136,-116841,618343,887447]
</code></pre>
<p>入力 <code>xs</code>が無作為に選ばれた数の配列として生成されていることに注目してください。</p>
<h2 id="演習-44"><a class="header" href="#演習-44">演習</a></h2>
<ol>
<li>（簡単）配列に空の配列を統合しても元の配列は変更されないことを確かめる性質を書いてください。
<strong>補足</strong>：この新しい性質は冗長です。
というのもこの状況は既に既存の性質で押さえられているからです。
読者がQuickCheckを使う練習をするための簡単な方法を与えようとしているだけです。</li>
<li>（簡単）<code>merge</code>の残りの性質に対して、適切なエラーメッセージを追加してください。</li>
</ol>
<h2 id="多相的なコードのテスト"><a class="header" href="#多相的なコードのテスト">多相的なコードのテスト</a></h2>
<p><code>Merge</code>モジュールでは、数の配列だけでなく、 <code>Ord</code>型クラスに属するどんな型の配列に対しても動作する、 <code>merge</code>関数を一般化した
<code>mergePoly</code>という関数が定義されています。</p>
<pre><code class="language-haskell">mergePoly :: forall a. Ord a =&gt; Array a -&gt; Array a -&gt; Array a
</code></pre>
<p><code>merge</code>の代わりに <code>mergePoly</code>を使うように元のテストを変更すると、次のようなエラーメッセージが表示されます。</p>
<pre><code class="language-text">No type class instance was found for

  Test.QuickCheck.Arbitrary.Arbitrary t0

The instance head contains unknown type variables.
Consider adding a type annotation.
</code></pre>
<p>このエラーメッセージは、配列に持たせたい要素の型が何なのかわからないので、コンパイラが無作為なテストケースを生成できなかったということを示しています。
このような場合、型註釈を使ってコンパイラが特定の型を推論するように強制できます。
例えば<code>Array Int</code>などです。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>代替案として型を指定する補助関数を使うこともできます。
こうするとより見通しのよいコードになることがあります。
例えば同値関数の同義な関数<code>ints</code>を定義したとしましょう。</p>
<pre><code class="language-haskell">ints :: Array Int -&gt; Array Int
ints = id
</code></pre>
<p>それから、コンパイラが引数の2つの配列の型 <code>Array Int</code>を推論するように、テストを変更します。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>ここで、 <code>ints</code>関数が不明な型を解消するために使われているため、 <code>xs</code>と <code>ys</code>はどちらも型 <code>Array Int</code>を持っています。</p>
<h2 id="演習-45"><a class="header" href="#演習-45">演習</a></h2>
<ol>
<li>（簡単）<code>xs</code>と <code>ys</code>の型を <code>Array Boolean</code>に強制する関数 <code>bools</code>を書き、
<code>mergePoly</code>をその型でテストする性質を追加してください。</li>
<li>（普通）標準関数から（例えば
<code>arrays</code>パッケージから）ひとつ関数を選び、適切なエラーメッセージを含めてQuickCheckの性質を書いてください。その性質は、補助関数を使って多相型引数を
<code>Int</code>か <code>Boolean</code>のどちらかに固定しなければいけません。</li>
</ol>
<h2 id="任意のデータの生成"><a class="header" href="#任意のデータの生成">任意のデータの生成</a></h2>
<p><code>quickcheck</code>ライブラリを使って性質に対するテストケースを無作為に生成する方法について説明します。</p>
<p>無作為に値を生成することができるような型は、次のような型クラス <code>Arbitary</code>のインスタンスを持っています。</p>
<pre><code class="language-haskell">class Arbitrary t where
  arbitrary :: Gen t
</code></pre>
<p><code>Gen</code>型構築子は<strong>決定的無作為データ生成</strong>の副作用を表しています。
決定的無作為データ生成は、擬似乱数生成器を使って、シード値から決定的無作為関数の引数を生成します。
<code>Test.QuickCheck.Gen</code>モジュールは、ジェネレータを構築するためのいくつかの有用なコンビネータを定義しています。</p>
<p><code>Gen</code>はモナドでもアプリカティブ関手でもあるので、
<code>Arbitary</code>型クラスの新しいインスタンスを作成するのに、いつも使っているようなコンビネータを自由に使うことができます。</p>
<p>例えば、 <code>quickcheck</code>ライブラリで提供されている <code>Int</code>型用の
<code>Arbitrary</code>インスタンスを使い、256個のバイト値上の分布を作ることができます。
これには<code>Gen</code>用に<code>Functor</code>インスタンスを使って整数から任意の整数値のバイトまでマップします。</p>
<pre><code class="language-haskell">newtype Byte = Byte Int

instance arbitraryByte :: Arbitrary Byte where
  arbitrary = map intToByte arbitrary
    where
    intToByte n | n &gt;= 0 = Byte (n `mod` 256)
                | otherwise = intToByte (-n)
</code></pre>
<p>ここでは、0から255までの間の整数値であるような型 <code>Byte</code>を定義しています。
<code>Arbitrary</code>インスタンスは <code>map</code>演算子を使って、 <code>intToByte</code>関数を <code>arbitrary</code>アクションまで持ち上げています。
<code>arbitrary</code>アクション内部の型は <code>Gen Int</code>と推論されます。</p>
<p>この考え方を <code>merge</code>用のテストに使うこともできます。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>このテストでは、任意の配列 <code>xs</code>と <code>ys</code>を生成しますが、 <code>merge</code>はソート済みの入力を期待しているので、 <code>xs</code>と
<code>ys</code>をソートしておかなければなりません。一方で、ソートされた配列を表すnewtypeを作成し、ソートされたデータを生成する
<code>Arbitrary</code>インスタンスを書くこともできます。</p>
<pre><code class="language-haskell">newtype Sorted a = Sorted (Array a)

sorted :: forall a. Sorted a -&gt; Array a
sorted (Sorted xs) = xs

instance arbSorted :: (Arbitrary a, Ord a) =&gt; Arbitrary (Sorted a) where
  arbitrary = map (Sorted &lt;&lt;&lt; sort) arbitrary
</code></pre>
<p>この型構築子を使うと、テストを次のように変更することができます。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs &lt;&gt; sorted ys)
</code></pre>
<p>これは些細な変更に見えるかもしれませんが、 <code>xs</code>と <code>ys</code>の型はただの <code>Array Int</code>から <code>Sorted Int</code>へと変更されています。これにより、
<code>mergePoly</code>関数はソート済みの入力を取る、という<strong>意図</strong>を、わかりやすく示すことができます。理想的には、
<code>mergePoly</code>関数自体の型が <code>Sorted</code>型構築子を使うようにするといいでしょう。</p>
<p>より興味深い例として、 <code>Tree</code>モジュールでは枝の値でソートされた二分木の型が定義されています。</p>
<pre><code class="language-haskell">data Tree a
  = Leaf
  | Branch (Tree a) a (Tree a)
</code></pre>
<p><code>Tree</code>モジュールでは次のAPIが定義されています。</p>
<pre><code class="language-haskell">insert    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Tree a
member    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Boolean
fromArray :: forall a. Ord a =&gt; Array a -&gt; Tree a
toArray   :: forall a. Tree a -&gt; Array a
</code></pre>
<p><code>insert</code>関数は新しい要素をソート済みの二分木に挿入するのに使われ、
<code>member</code>関数は特定の値の有無を木に問い合わせるのに使われます。例えば次のようになります。</p>
<pre><code class="language-text">&gt; import Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false
</code></pre>
<p><code>toArray</code>関数と <code>fromArray</code>関数は、ソートされた木とソートされた配列を相互に変換するために使われます。
<code>fromArray</code>を使うと、木についての <code>Arbitrary</code>インスタンスを書くことができます。</p>
<pre><code class="language-haskell">instance arbTree :: (Arbitrary a, Ord a) =&gt; Arbitrary (Tree a) where
  arbitrary = map fromArray arbitrary
</code></pre>
<p>型 <code>a</code>についての<code>Arbitary</code>インスタンスが使えるなら、テストする性質の引数の型として <code>Tree a</code>を使うことができます。例えば、
<code>member</code>テストは値を挿入した後は常に <code>true</code>を返すことをテストできます。</p>
<pre><code class="language-haskell">quickCheck \t a -&gt;
  member a $ insert a $ treeOfInt t
</code></pre>
<p>ここでは、引数 <code>t</code>は <code>Tree Number</code>型の無作為に生成された木です。
型引数は、同値関数 <code>treeOfInt</code>によって明確化されています。</p>
<h2 id="演習-46"><a class="header" href="#演習-46">演習</a></h2>
<ol>
<li>（普通）<code>a-z</code>の範囲から無作為に選ばれた文字の集まりを生成する <code>Arbitrary</code>インスタンスを持った、
<code>String</code>のnewtypeを作ってください。<strong>ヒント</strong>：<code>Test.QuickCheck.Gen</code>モジュールから
<code>elements</code>と <code>arrayOf</code>関数を使います。</li>
<li>（難しい）木に挿入された値は、どれだけ挿入があった後でも、その木の構成要素であることを主張する性質を書いてください。</li>
</ol>
<h2 id="高階関数のテスト"><a class="header" href="#高階関数のテスト">高階関数のテスト</a></h2>
<p><code>Merge</code>モジュールは <code>merge</code>関数の別の一般化も定義します。
<code>mergeAith</code>関数は追加の関数を引数として取り、統合される要素の順序を決
定するのに使われます。つまり <code>mergeWith</code>は高階関数です。</p>
<p>例えば<code>length</code>関数を最初の引数として渡し、既に長さの昇順になっている2
つの配列を統合することができます。このとき、結果も長さの昇順になってい
なければなりません。</p>
<pre><code class="language-haskell">&gt; import Data.String

&gt; mergeWith length
    [&quot;&quot;, &quot;ab&quot;, &quot;abcd&quot;]
    [&quot;x&quot;, &quot;xyz&quot;]

[&quot;&quot;,&quot;x&quot;,&quot;ab&quot;,&quot;xyz&quot;,&quot;abcd&quot;]
</code></pre>
<p>このような関数をテストするにはどうしたらいいでしょうか。理想的には、関
数である最初の引数を含めた、3つの引数すべてについて、値を生成したいと
思うでしょう。</p>
<p>関数を無作為に生成できるようにする、もう1つの型クラスがあります。この
型クラスは <code>Coarbitrary</code>と呼ばれており、次のように定義されています。</p>
<pre><code class="language-haskell">class Coarbitrary t where
  coarbitrary :: forall r. t -&gt; Gen r -&gt; Gen r
</code></pre>
<p><code>coarbitrary</code>関数は、型 <code>t</code>と、関数の結果の型 <code>r</code>についての乱数生成器
を関数の引数としてとり、乱数生成器を<strong>かき乱す</strong>のにこの引数を使います。
つまり関数の引数を使って、乱数生成器の無作為な出力を変更しているのです。</p>
<p>また、もし関数の定義域が <code>Coarbitrary</code>で、値域が <code>Arbitrary</code>なら、
<code>Arbitrary</code>の関数を与える型クラスインスタンスが存在しています。</p>
<pre><code class="language-haskell">instance arbFunction :: (Coarbitrary a, Arbitrary b) =&gt; Arbitrary (a -&gt; b)
</code></pre>
<p>実は、これが意味しているのは、引数として関数を取るような性質を記述でき
るということです。 <code>mergeWith</code>関数の場合では、新しい引数を考慮するよう
にテストを修正すると、最初の引数を無作為に生成することができます。</p>
<p>結果が整列されているということを保証することができません。必ずしも
<code>Ord</code>インスタンスを持っているとさえ限らないのです。しかし、引数として
渡す関数 <code>f</code>にしたがって結果が整列されていることは期待されます。さらに、
2つの入力配列が <code>f</code>に従って整列されている必要がありますので、
<code>sortBy</code>関数を使って関数 <code>f</code>が適用されたあとの比較に基づいて <code>xs</code>と
<code>ys</code>を整列します。</p>
<pre><code class="language-haskell">quickCheck \xs ys f -&gt;
  let
    result =
      map f $
        mergeWith (intToBool f)
                  (sortBy (compare `on` f) xs)
                  (sortBy (compare `on` f) ys)
    expected =
      map f $
        sortBy (compare `on` f) $ xs &lt;&gt; ys
  in
    eq result expected
</code></pre>
<p>ここでは、関数 <code>f</code>の型を明確にするために、関数 <code>intToBool</code>を使用しています。</p>
<pre><code class="language-haskell">intToBool :: (Int -&gt; Boolean) -&gt; Int -&gt; Boolean
intToBool = id
</code></pre>
<p>関数は <code>Arbitrary</code>であるだけでなく <code>Coarbitrary</code>でもあります。</p>
<pre><code class="language-haskell">instance coarbFunction :: (Arbitrary a, Coarbitrary b) =&gt; Coarbitrary (a -&gt; b)
</code></pre>
<p>これは値の生成が単純な関数だけに限定されるものではないことを意味してい
ます。つまり、<strong>高階関数</strong>や、引数が高階関数であるような関数もまた無作
為に生成することができるのです。</p>
<h2 id="coarbitraryのインスタンスを書く"><a class="header" href="#coarbitraryのインスタンスを書く">Coarbitraryのインスタンスを書く</a></h2>
<p><code>Gen</code>の <code>Monad</code>や <code>Applicative</code>インスタンスを使って独自のデータ型に対
して <code>Arbitrary</code>インスタンスを書くことができるのとちょうど同じように、
独自の <code>Coarbitrary</code>インスタンスを書くこともできます。これにより、無作
為に生成される関数の定義域として、独自のデータ型を使うことができるよう
になります。</p>
<p><code>Tree</code>型の <code>Coarbitrary</code>インスタンスを書いてみましょう。枝に格納されて
いる要素の型に <code>Coarbitrary</code>インスタンスが必要になります。</p>
<pre><code class="language-haskell">instance coarbTree :: Coarbitrary a =&gt; Coarbitrary (Tree a) where
</code></pre>
<p>型 <code>Tree a</code>の値が与えられたときに、乱数発生器をかき乱す関数を記述する
必要があります。入力値が <code>Leaf</code>であれば、そのままの生成器を返します。</p>
<pre><code class="language-haskell">  coarbitrary Leaf = id
</code></pre>
<p>もし木が <code>Branch</code>なら、左の部分木、値、右の部分木を使って生成器をかき乱します。
関数合成を使って独自のかき乱し関数を作ります。</p>
<pre><code class="language-haskell">  coarbitrary (Branch l a r) =
    coarbitrary l &lt;&lt;&lt;
    coarbitrary a &lt;&lt;&lt;
    coarbitrary r
</code></pre>
<p>これで、木を引数にとるような関数を引数に含む性質を自由に書くことができ
るようになりました。たとえば、 <code>Tree</code>モジュールでは<code>anywhere</code>が定義さ
れており、これは述語が引数のどんな部分木についても成り立っているかを調
べる関数です。</p>
<pre><code class="language-haskell">anywhere :: forall a. (Tree a -&gt; Boolean) -&gt; Tree a -&gt; Boolean
</code></pre>
<p>これで、無作為にこの述語関数 <code>anywhere</code>を生成することができるようにな
りました。例えば、 <code>anywhere</code>関数は<strong>ある命題のもとで不変</strong>であること
が期待されます。</p>
<pre><code class="language-haskell">quickCheck \f g t -&gt;
  anywhere (\s -&gt; f s || g s) t ==
    anywhere f (treeOfInt t) || anywhere g t
</code></pre>
<p>ここで、 <code>treeOfInt</code>関数は木に含まれる値の型を型 <code>Int</code>に固定するために
使われています。</p>
<pre><code class="language-haskell">treeOfInt :: Tree Int -&gt; Tree Int
treeOfInt = id
</code></pre>
<h2 id="副作用のないテスト"><a class="header" href="#副作用のないテスト">副作用のないテスト</a></h2>
<p>テストの目的では通常、テストスイートの <code>main</code>アクションには
<code>quickCheck</code>関数の呼び出しが含まれています。しかし、副作用を使わない
<code>quickCheckPure</code>と呼ばれる <code>quickCheck</code>関数の亜種もあります。
<code>quickCheckPure</code>は、入力として乱数の種をとり、テスト結果の配列を返す純
粋な関数です。</p>
<p>PSCiを使用して <code>quickCheckPure</code>を試せます。ここでは <code>merge</code>操作が結合
法則を満たすことをテストします。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Merge
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.LCG (mkSeed)

&gt; :paste
… quickCheckPure (mkSeed 12345) 10 \xs ys zs -&gt;
…   ((xs `merge` ys) `merge` zs) ==
…     (xs `merge` (ys `merge` zs))
… ^D

Success : Success : ...
</code></pre>
<p><code>quickCheckPure</code>は乱数の種、生成するテストケースの数、テストする性質の
3つの引数をとります。もしすべてのテストケースに成功したら、
<code>Success</code>データ構築子の配列がコンソールに出力されます。</p>
<p><code>quickCheckPure</code>は、性能ベンチマークの入力データ生成や、ウェブアプリケー
ションのフォームデータ例を無作為に生成するというような状況で便利かもし
れません。</p>
<h2 id="演習-47"><a class="header" href="#演習-47">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Byte</code>と <code>Sorted</code>型構築子についての <code>Coarbitrary</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）任意の関数 <code>f</code>について、 <code>mergeWith f</code>関数の結合性を主張する（高階）性質を書いてください。
<code>quickCheckPure</code>を使ってPSCiでその性質をテストしてください。</p>
</li>
<li>
<p>（普通）次のデータ型の<code>Arbitrary</code>と<code>Coarbitrary</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">data OneTwoThree a = One a | Two a a | Three a a a
</code></pre>
<p><strong>ヒント</strong>：<code>Test.QuickCheck.Gen</code>で定義された <code>oneOf</code>関数を使って <code>Arbitrary</code>インスタンスを定義してください。</p>
</li>
<li>
<p>（普通）<code>all</code>を使って <code>quickCheckPure</code>関数の結果を単純化してください。
その新しい関数は型<code>List Result -&gt; Boolean</code>を持ち、全てのテストがとおえば<code>true</code>を、そうでなければ<code>false</code>を返します。</p>
</li>
<li>
<p>（普通）<code>quickCheckPure</code>の結果を単純にする別の手法として、
関数<code>squashResults :: List Result -&gt; Result</code>を書いてみてください。
<code>Data.Maybe.First</code>の<code>First</code>モノイドと共に<code>foldMap</code>関数を使うことで
失敗した場合の最初のエラーを保存することを検討してください。</p>
</li>
</ol>
<h2 id="まとめ-11"><a class="header" href="#まとめ-11">まとめ</a></h2>
<p>この章では<code>quickcheck</code>パッケージに出会いました。これを使えば<strong>生成的テ
スティング</strong>のパラダイムを使って宣言的な方法でテストを書くことができま
した。具体的には以下です。</p>
<ul>
<li><code>spago test</code>を使ってQuickCheckのテストを自動化する方法を見ました。</li>
<li>性質を関数として書く方法とエラーメッセージを改良する <code>&lt;?&gt;</code>演算子の使い方を説明しました。</li>
<li><code>Arbitrary</code>と <code>Coarbitrary</code>型クラスによって、どのように定型的なテスト
コードの自動生成を可能にし、またどのように高階性質関数が可能になるかを
見てきました。</li>
<li>独自のデータ型に対して <code>Arbitrary</code>と <code>Coarbitrary</code>インスタンスを実装す
る方法を見ました。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="領域特化言語"><a class="header" href="#領域特化言語">領域特化言語</a></h1>
<h2 id="この章の目標-12"><a class="header" href="#この章の目標-12">この章の目標</a></h2>
<p>この章では、多数の標準的な手法を使ったPureScriptにおける<strong>領域特化言語</strong>
(domain-specific language, DSL) の実装について探求していきます。</p>
<p>領域特化言語とは、特定の問題領域での開発に適した言語のことです。領域特
化言語の構文および機能は、その領域内の考え方を表現するコードの読みやす
さを最大限に発揮すべく選択されます。本書の中では、すでに領域特化言語の
例を幾つか見てきています。</p>
<ul>
<li>第11章で開発された <code>Game</code>モナドと関連するアクションは、
<strong>テキストアドベンチャーゲーム開発</strong>という領域に対しての領域特化言語を構成しています。</li>
<li>第13章で扱った <code>quickcheck</code>パッケージは、<strong>生成的テスティング</strong>の領域
の領域特化言語です。このコンビネータはテストの性質に対して特に表現力の
高い記法を可能にします。</li>
</ul>
<p>この章では、領域特化言語の実装において、いくつかの標準的な手法による構
造的な手法に迫ります。これがこの話題の完全な説明だということでは決して
ありませんが、独自の目的に対する具体的なDSLを構築するのに十分な知識を
与えてくれるでしょう。</p>
<p>この章で実行している例は、HTML文書を作成するための領域特化言語になりま
す。正しいHTML文書を記述するための型安全な言語を開発することが目的で、
素朴な実装を徐々に改善しつつ進めていきます。</p>
<h2 id="プロジェクトの準備-11"><a class="header" href="#プロジェクトの準備-11">プロジェクトの準備</a></h2>
<p>この章で使うプロジェクトには新しい依存性が1つ追加されます。これから使
う道具のひとつである<strong>Freeモナド</strong>が定義されている <code>free</code>ライブラリで
す。</p>
<p>このプロジェクトをPSCiを使って試していきます。</p>
<h2 id="htmlデータ型"><a class="header" href="#htmlデータ型">HTMLデータ型</a></h2>
<p>このHTMLライブラリの最も基本的なバージョンは
<code>Data.DOM.Simple</code>モジュールで定義されています。このモジュールには次の型定義が含まれています。</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Array Content)
  }

data Content
  = TextContent String
  | ElementContent Element

newtype Attribute = Attribute
  { key          :: String
  , value        :: String
  }
</code></pre>
<p><code>Element</code>型はHTMLの要素を表しています。各要素は要素名、属性のペア​​の配
列と、要素の内容でで構成されています。contentプロパティは、<code>Maybe</code>タイ
プを適切に使って、要素が開いている（他の要素やテキストを含む）か閉じて
いるかを示しています。</p>
<p>このライブラリの鍵となる機能は次の関数です。</p>
<pre><code class="language-haskell">render :: Element -&gt; String
</code></pre>
<p>この関数はHTML要素をHTML文字列として出力します。PSCiで明示的に適当な型
の値を構築し、ライブラリのこのバージョンを試してみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Simple
&gt; import Data.Maybe
&gt; import Effect.Console

&gt; :paste
… log $ render $ Element
…   { name: &quot;p&quot;
…   , attribs: [
…       Attribute
…         { key: &quot;class&quot;
…         , value: &quot;main&quot;
…         }
…     ]
…   , content: Just [
…       TextContent &quot;Hello World!&quot;
…     ]
…   }
… ^D

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>現状のライブラリにはいくつかの問題があります。</p>
<ul>
<li>HTML文書の作成に手がかかります。すべての新しい要素に少なくとも1つのレ
コードと1つのデータ構築子が必要です。</li>
<li>無効な文書を表現できてしまいます。
<ul>
<li>開発者が要素名の入力を間違えるかもしれません</li>
<li>開発者が属性を間違った要素に関連付けることができてしまいます</li>
<li>開発者が開いた要素が正しい場合に閉じた要素を使用することができてしまいます</li>
</ul>
</li>
</ul>
<p>残りの章ではとある手法を用いてこれらの問題を解決し、このライブラリーを
HTML文書を作成するために使える領域特化言語にしていきます。</p>
<h2 id="スマート構築子"><a class="header" href="#スマート構築子">スマート構築子</a></h2>
<p>最初に導入する手法は方法は単純なものですが、とても効果的です。モジュールの使用者にデータの表現を露出する代わりに、モジュールエクスポートリストを使ってデータ構築子
<code>Element</code>、 <code>Content</code>、 <code>Attribute</code>を隠蔽し、正しいことが明らかなデータだけ構築する、いわゆる<strong>スマート構築子</strong>
(smart constructors) だけをエクスポートします。</p>
<p>例を示しましょう。まず、HTML要素を作成するための便利な関数を提供します。</p>
<pre><code class="language-haskell">element :: String -&gt; Array Attribute -&gt; Maybe (Array Content) -&gt; Element
element name attribs content = Element
  { name:      name
  , attribs:   attribs
  , content:   content
  }
</code></pre>
<p>次に、欲しいHTML要素を利用者が作れるように、スマート構築子を作成します。
これには<code>element</code>関数を適用します。</p>
<pre><code class="language-haskell">a :: Array Attribute -&gt; Array Content -&gt; Element
a attribs content = element &quot;a&quot; attribs (Just content)

p :: Array Attribute -&gt; Array Content -&gt; Element
p attribs content = element &quot;p&quot; attribs (Just content)

img :: Array Attribute -&gt; Element
img attribs = element &quot;img&quot; attribs Nothing
</code></pre>
<p>最後に、正しいデータ構造だけを構築することがわかっているこれらの関数をエクスポートするように、モジュールエクスポートリストを更新します。</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute(..)
  , Content(..)

  , a
  , p
  , img

  , render
  ) where
</code></pre>
<p>モジュールエクスポートリストはモジュール名の直後の括弧内に書きます。各モジュールのエクスポートは次の3種類のいずれかになります。</p>
<ul>
<li>値（ないし関数）。その値の名前により指定されます。</li>
<li>型クラス。クラス名により指定されます。</li>
<li>型構築子と関連するデータ構築子。型名とそれに続くエクスポートされるデータ構築子の括弧で囲まれたリストで指定されます。</li>
</ul>
<p>ここでは、
<code>Element</code>の<strong>型</strong>をエクスポートしていますが、データ構築子はエクスポートしていません。もしデータ構築子をエクスポートすると、モジュールの使用者が不正なHTML要素を構築できてしまいます。</p>
<p><code>Attribute</code>と <code>Content</code>型についてはデータ構築子をすべてエクスポートしています（エクスポートリストの記号
<code>..</code>で示されています）。
すぐ後で、これらの型にスマート構築子の手法を適用していきます。</p>
<p>すでにライブラリにいくつかの大きな改良を加わっていることに注目です。</p>
<ul>
<li>不正な名前を持つHTML要素を表現することは不可能です（もちろん、ライブラリが提供する要素名に制限されています）。</li>
<li>閉じた要素は構築するときに内容を含められません。</li>
</ul>
<p><code>Content</code>型にとても簡単にこの手法を適用することができます。単にエクスポートリストから
<code>Content</code>型のデータ構築子を取り除き、次のスマート構築子を提供します。</p>
<pre><code class="language-haskell">text :: String -&gt; Content
text = TextContent

elem :: Element -&gt; Content
elem = ElementContent
</code></pre>
<p><code>Attribute</code>型にも同じ手法を適用してみましょう。まず、属性のための汎用のスマート構築子を用意します。
以下は最初の試みです。</p>
<pre><code class="language-haskell">attribute :: String -&gt; String -&gt; Attribute
attribute key value = Attribute
  { key: key
  , value: value
  }

infix 4 attribute as :=
</code></pre>
<p>この定義では元の <code>Element</code>型と同じ問題に直面しています。
存在しなかったり、名前が間違っているような属性を表現することが可能です。この問題を解決するために、属性名を表すnewtypeを作成します。</p>
<pre><code class="language-haskell">newtype AttributeKey = AttributeKey String
</code></pre>
<p>これを使えば演算子を次のように変更できます。</p>
<pre><code class="language-haskell">attribute :: AttributeKey -&gt; String -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: value
  }
</code></pre>
<p><code>AttributeKey</code>データ構築子をエクスポートしなければ、明示的にエクスポートされた次のような関数を使う以外に、使用者が型
<code>AttributeKey</code>の値を構築する方法はありません。
以下にいくつかの例を示します。</p>
<pre><code class="language-haskell">href :: AttributeKey
href = AttributeKey &quot;href&quot;

_class :: AttributeKey
_class = AttributeKey &quot;class&quot;

src :: AttributeKey
src = AttributeKey &quot;src&quot;

width :: AttributeKey
width = AttributeKey &quot;width&quot;

height :: AttributeKey
height = AttributeKey &quot;height&quot;
</code></pre>
<p>新しいモジュールの最終的なエクスポートリストは次のようになります。
最早どのデータ構築子も直接エクスポートしていない点に注目です。</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute
  , Content
  , AttributeKey

  , a
  , p
  , img

  , href
  , _class
  , src
  , width
  , height

  , attribute, (:=)
  , text
  , elem

  , render
  ) where
</code></pre>
<p>PSCiでこの新しいモジュールを試してみると、既にコードの簡潔さにおいて大幅な向上が見て取れます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Smart
&gt; import Effect.Console
&gt; log $ render $ p [ _class := &quot;main&quot; ] [ text &quot;Hello World!&quot; ]

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>しかし、基礎のデータ表現が変更されていないので、
<code>render</code>関数を変更する必要はなかったことにも注目してください。これはスマート構築子による手法の利点のひとつです。外部APIの使用者によって認識される表現から、モジュールの内部データ表現を分離することができるのです。</p>
<h2 id="演習-48"><a class="header" href="#演習-48">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Data.DOM.Smart</code>モジュールで <code>render</code>を使った新しいHTML文書の作成を試してみましょう。</p>
</li>
<li>
<p>（普通）<code>checked</code>と
<code>disabled</code>など、値を要求しないHTML属性がありますが、これらは次のような<strong>空の属性</strong>として表示されるかもしれません。</p>
<pre><code class="language-html">&lt;input disabled&gt;
</code></pre>
<p>空の属性を扱えるように <code>Attribute</code>の表現を変更してください。
要素に空の属性を追加するための<code>attribute</code>または<code>:=</code>の代わりに使える関数を記述してください。</p>
</li>
</ol>
<h2 id="幻影型"><a class="header" href="#幻影型">幻影型</a></h2>
<p>次の手法の動機付けとして、以下のコードを考えます。</p>
<pre><code class="language-text">&gt; log $ render $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := &quot;foo&quot;
    , height := &quot;bar&quot;
    ]

&lt;img src=&quot;cat.jpg&quot; width=&quot;foo&quot; height=&quot;bar&quot; /&gt;
unit
</code></pre>
<p>ここでの問題は、 <code>width</code>属性と<code>height</code>属性に文字列値を提供しているということです。
ここで与えることができるのはピクセル単位ないしパーセントの数値だけであるべきです。</p>
<p><code>AttributeKey</code>型にいわゆる<strong>幻影型</strong> (phantom type) 引数を導入すると、この問題を解決できます。</p>
<pre><code class="language-haskell">newtype AttributeKey a = AttributeKey String
</code></pre>
<p>定義の右辺に対応する型 <code>a</code>の値が存在しないので、この型変数 <code>a</code>は<strong>幻影型</strong>と呼ばれています。
この型 <code>a</code>はコンパイル時に追加の情報を提供するためだけに存在しています。
型 <code>AttributeKey a</code>の任意の値は実行時には単なる文字列ですが、コンパイル時にその値の型によりこのキーに関連付けられた値で求めている型がわかります。</p>
<p><code>attribute</code>関数の型を次のように変更すれば、<code>AttributeKey</code>の新しい形式を考慮するようにできます。</p>
<pre><code class="language-haskell">attribute :: forall a. IsValue a =&gt; AttributeKey a -&gt; a -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: toValue value
  }
</code></pre>
<p>ここで、幻影型の引数 <code>a</code>は、属性キーと属性値が照応する型を持っていることを確認するために使われます。
使用者は <code>AttributeKey a</code>を型の値を直接作成できないので（ライブラリで提供されている定数を介してのみ得られます）、すべての属性が構築により正しくなります。</p>
<p>なお、<code>IsValue</code>制約は、キーに関連付けられた値の型がなんであれ、その値を文字列に変換し、生成したHTML内に出力できることを保証します。
<code>IsValue</code>型クラスは次のように定義されています。</p>
<pre><code class="language-haskell">class IsValue a where
  toValue :: a -&gt; String
</code></pre>
<p><code>String</code>と <code>Int</code>型についての型クラスインスタンスも提供しておきます。</p>
<pre><code class="language-haskell">instance stringIsValue :: IsValue String where
  toValue = id

instance intIsValue :: IsValue Int where
  toValue = show
</code></pre>
<p>また、これらの型が新しい型変数を反映するように、 <code>AttributeKey</code>定数を更新しなければいけません。</p>
<pre><code class="language-haskell">href :: AttributeKey String
href = AttributeKey &quot;href&quot;

_class :: AttributeKey String
_class = AttributeKey &quot;class&quot;

src :: AttributeKey String
src = AttributeKey &quot;src&quot;

width :: AttributeKey Int
width = AttributeKey &quot;width&quot;

height :: AttributeKey Int
height = AttributeKey &quot;height&quot;
</code></pre>
<p>これで、不正なHTML文書を表現することが不可能になっていることがわかります。
また、<code>width</code>と <code>height</code>属性を表現するのに文字列ではなく数を使うことが強制されていることがわかります。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Phantom
&gt; import Effect.Console

&gt; :paste
… log $ render $ img
…   [ src    := &quot;cat.jpg&quot;
…   , width  := 100
…   , height := 200
…   ]
… ^D

&lt;img src=&quot;cat.jpg&quot; width=&quot;100&quot; height=&quot;200&quot; /&gt;
unit
</code></pre>
<h2 id="演習-49"><a class="header" href="#演習-49">演習</a></h2>
<ol>
<li>
<p>（簡単）ピクセルまたはパーセントの長さのいずれかを表すデータ型を作成してください。
その型について <code>IsValue</code>のインスタンスを書いてください。
この型を使うように <code>width</code>と <code>height</code>属性を変更してください。</p>
</li>
<li>
<p>（難しい）幻影型を使って真偽値 <code>true</code>、 <code>false</code>用の最上位の表現を定義することで、 <code>AttributeKey</code>が
<code>disabled</code>や <code>checked</code>のような<strong>空の属性</strong>を表現しているかどうかを符号化することができます。</p>
<pre><code class="language-haskell">data True
data False
</code></pre>
<p>幻影型を使って、使用者が <code>attribute</code>演算子を空の属性に対して使うことを防ぐように、前の演習の解答を変更してください。</p>
</li>
</ol>
<h2 id="freeモナド"><a class="header" href="#freeモナド">Freeモナド</a></h2>
<p>APIに施す最後の変更は、 <code>Content</code>型をモナドにしてdo記法を使えるようにするために、<strong>Freeモナド</strong>と呼ばれる構造を使うことです。
これによって入れ子になった要素がわかりやすくなるようにHTML文書を構造化できます。
以下の代わりに……</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ]
  [ elem $ img
      [ src    := &quot;cat.jpg&quot;
      , width  := 100
      , height := 200
      ]
  , text &quot;A cat&quot;
  ]
</code></pre>
<p>このように書くことができるようになります。</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ] $ do
  elem $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := 100
    , height := 200
    ]
  text &quot;A cat&quot;
</code></pre>
<p>しかし、do記法だけがFreeモナドの恩恵だというわけではありません。
Freeモナドがあれば、モナドのアクションの<strong>表現</strong>をその<strong>解釈</strong>から分離し、同じアクションに<strong>複数の解釈</strong>を持たせることさえできます。</p>
<p><code>Free</code>モナドは <code>free</code>ライブラリの <code>Control.Monad.Free</code>モジュールで定義されています。
PSCiを使うと、次のようにFreeモナドについての基本的な情報を見ることができます。</p>
<pre><code class="language-text">&gt; import Control.Monad.Free

&gt; :kind Free
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p><code>Free</code>の種は、引数として型構築子を取り、別の型構築子を返すことを示しています。
実は、 <code>Free</code>モナドを使えば任意の <code>Functor</code>を <code>Monad</code>にすることができます！</p>
<p>モナドのアクションの<strong>表現</strong>を定義することから始めます。
これを行うには、サポートする各モナドアクションそれぞれについて、ひとつのデータ構築子を持つ <code>Functor</code>を作成する必要があります。
今回の場合、2つのモナドのアクションは <code>elem</code>と <code>text</code>になります。
実際には、 <code>Content</code>型を次のように変更するだけです。</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a

instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
</code></pre>
<p>ここで、この <code>ContentF</code>型構築子は以前の <code>Content</code>データ型とよく似ています。
しかし、ここでは型引数<code>a</code>を取り、それぞれのデータ構築子は型<code>a</code>の値を追加の引数として取るように変更されています。
<code>Functor</code>インスタンスでは、単に各データ構築子で型 <code>a</code>の構成要素に関数 <code>f</code>を適用します。</p>
<p>これにより、新しい<code>Content</code>モナドを<code>Free</code>モナド用の型シノニムとして定義することができます。
これは最初の型引数として <code>ContentF</code>型構築子を使うことで構築されています。</p>
<pre><code class="language-haskell">type Content = Free ContentF
</code></pre>
<p>型シノニムの代わりにnewtypeを使用して、使用者に対してライブラリの内部表現を露出することを避けられます。
<code>Content</code>データ構築子を隠すことで、提供しているモナドのアクションだけを使うことを使用者に制限しています。</p>
<p><code>ContentF</code>は <code>Functor</code>なので、 <code>Free ContentF</code>用の<code>Monad</code>インスタンスが自動的に手に入ります。</p>
<p><code>Content</code>の新しい型引数を考慮するように<code>Element</code>データ型を僅かに変更する必要があります。
モナドの計算の戻り値の型が <code>Unit</code>であることだけが必要です。</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Content Unit)
  }
</code></pre>
<p>また、 <code>Content</code>モナドについての新しいモナドのアクションになる <code>elem</code>と <code>text</code>関数を変更する必要があります。
これには<code>Control.Monad.Free</code>モジュールで提供されている <code>liftF</code>関数が使えます。
この関数の型は次のようになっています。</p>
<pre><code class="language-haskell">liftF :: forall f a. f a -&gt; Free f a
</code></pre>
<p><code>liftF</code>により、何らかの型 <code>a</code>について、型 <code>f a</code>の値からFreeモナドのアクションを構築できるようになります。
今回の場合、 <code>ContentF</code>型構築子のデータ構築子をそのまま使うだけです。</p>
<pre><code class="language-haskell">text :: String -&gt; Content Unit
text s = liftF $ TextContent s unit

elem :: Element -&gt; Content Unit
elem e = liftF $ ElementContent e unit
</code></pre>
<p>他にも同じようなコードの変更はありますが、興味深い変更は <code>render</code>関数にあります。
ここでは、このFreeモナドを<strong>解釈</strong>しなければいけません。</p>
<h2 id="モナドの解釈"><a class="header" href="#モナドの解釈">モナドの解釈</a></h2>
<p><code>Control.Monad.Free</code>モジュールでは、Freeモナドで計算を解釈するための多数の関数が提供されています。</p>
<pre><code class="language-haskell">runFree
  :: forall f a
   . Functor f
  =&gt; (f (Free f a) -&gt; Free f a)
  -&gt; Free f a
  -&gt; a

runFreeM
  :: forall f m a
   . (Functor f, MonadRec m)
  =&gt; (f (Free f a) -&gt; m (Free f a))
  -&gt; Free f a
  -&gt; m a
</code></pre>
<p><code>runFree</code>関数は、<strong>純粋な</strong>結果を計算するために使用されます。
<code>runFreeM</code>関数があればFreeモナドのアクションを解釈するためにモナドが使えます。</p>
<p><strong>補足</strong>：厳密には、より強い<code>MonadRec</code>制約を満たすモナド <code>m</code>を使用するよう制限されています。
実際には、これはスタックオーバーフローを心配する必要がないことを意味します。
なぜなら <code>m</code>は安全な<strong>末尾再帰モナド</strong> (monadic tail recursion) をサポートするからです。</p>
<p>まず、アクションを解釈することができるモナドを選ばなければなりません。
<code>Writer String</code>モナドを使って、結果のHTML文字列を累積することにします。</p>
<p>新しい <code>render</code>メソッドは補助関数
<code>renderElement</code>に移譲して開始し、<code>execWriter</code>を使って<code>Writer</code>モナドで計算を走らせます。</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render = execWriter &lt;&lt;&lt; renderElement
</code></pre>
<p><code>renderElement</code>はwhereブロックで定義されています。</p>
<pre><code class="language-haskell">  where
    renderElement :: Element -&gt; Writer String Unit
    renderElement (Element e) = do
</code></pre>
<p><code>renderElement</code>の定義は直感的で、複数の小さな文字列を累積するために <code>Writer</code>モナドの <code>tell</code>アクションを使っています。</p>
<pre><code class="language-haskell">      tell &quot;&lt;&quot;
      tell e.name
      for_ e.attribs $ \x -&gt; do
        tell &quot; &quot;
        renderAttribute x
      renderContent e.content
</code></pre>
<p>次に、<code>renderAttribute</code>関数を定義します。
こちらも同じくらい単純です。</p>
<pre><code class="language-haskell">    where
      renderAttribute :: Attribute -&gt; Writer String Unit
      renderAttribute (Attribute x) = do
        tell x.key
        tell &quot;=\&quot;&quot;
        tell x.value
        tell &quot;\&quot;&quot;
</code></pre>
<p><code>renderContent</code>関数は、もっと興味深いものです。
ここでは<code>runFreeM</code>関数を使い、Freeモナドの内部で計算を解釈しています。
計算は補助関数 <code>renderContentItem</code>に移譲しています。</p>
<pre><code class="language-haskell">      renderContent :: Maybe (Content Unit) -&gt; Writer String Unit
      renderContent Nothing = tell &quot; /&gt;&quot;
      renderContent (Just content) = do
        tell &quot;&gt;&quot;
        runFreeM renderContentItem content
        tell &quot;&lt;/&quot;
        tell e.name
        tell &quot;&gt;&quot;
</code></pre>
<p><code>renderContentItem</code>の型は <code>runFreeM</code>の型シグネチャから推測することができます。
関手 <code>f</code>は型構築子 <code>ContentF</code>で、モナド <code>m</code>は解釈している計算のモナド、つまり <code>Writer String</code>です。
これにより <code>renderContentItem</code>について次の型シグネチャがわかります。</p>
<pre><code class="language-haskell">      renderContentItem :: ContentF (Content Unit) -&gt; Writer String (Content Unit)
</code></pre>
<p><code>ContentF</code>の2つのデータ構築子でパターン照合するだけで、この関数を実装することができます。</p>
<pre><code class="language-haskell">      renderContentItem (TextContent s rest) = do
        tell s
        pure rest
      renderContentItem (ElementContent e rest) = do
        renderElement e
        pure rest
</code></pre>
<p>それぞれの場合において、式 <code>rest</code>は型 <code>Content Unit</code>を持っており、解釈計算の残りを表しています。
<code>rest</code>アクションを呼び出すことによって、それぞれの場合を完了することができます。</p>
<p>これで完了です！
PSCiで、次のようにすれば新しいモナドのAPIを試すことができます。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Free
&gt; import Effect.Console

&gt; :paste
… log $ render $ p [] $ do
…   elem $ img [ src := &quot;cat.jpg&quot; ]
…   text &quot;A cat&quot;
… ^D

&lt;p&gt;&lt;img src=&quot;cat.jpg&quot; /&gt;A cat&lt;/p&gt;
unit
</code></pre>
<h2 id="演習-50"><a class="header" href="#演習-50">演習</a></h2>
<ol>
<li>（普通）<code>ContentF</code>型に新しいデータ構築子を追加して、生成されたHTMLにコメントを出力する新しいアクション
<code>comment</code>に対応してください。
<code>liftF</code>を使ってこの新しいアクションを実装してください。
新しい構築子を適切に解釈するように、解釈 <code>renderContentItem</code>を更新してください。</li>
</ol>
<h2 id="言語の拡張"><a class="header" href="#言語の拡張">言語の拡張</a></h2>
<p>すべてのアクションが型 <code>Unit</code>の何かを返すようなモナドは、さほど興味深いものではありません。
実際のところ、概ね良くなったと思われる構文は別として、このモナドは <code>Monoid</code>以上の機能を何ら追加していません。</p>
<p>非自明な結果を返す新しいモナドアクションでこの言語を拡張することで、Freeモナド構造の威力をお見せしましょう​​。</p>
<p><strong>アンカー</strong>を使用して文書のさまざまな節へのハイパーリンクが含まれているHTML文書を生成するとします。
これは既に達成できています。
手作業でアンカーの名前を生成して文書中で少なくとも2回それらを含めればよいのです。
1つはアンカーの定義自身に、もう1つはそれぞれのハイパーリンクにあります。
しかし、この方法には根本的な問題がいくつかあります。</p>
<ul>
<li>開発者が一意なアンカー名の生成をし損なうかもしれません。</li>
<li>開発者がアンカー名を1つ以上の箇所で打ち間違うかもしれません。</li>
</ul>
<p>開発者が誤ちを犯すことを防ぐために、アンカー名を表す新しい型を導入し、新しい一意な名前を生成するためのモナドアクションを提供することができます。</p>
<p>最初の手順は、名前の型を新しく追加することです。</p>
<pre><code class="language-haskell">newtype Name = Name String

runName :: Name -&gt; String
runName (Name n) = n
</code></pre>
<p>繰り返しになりますが、<code>Name</code>は
<code>String</code>のnewtypeとして定義しているものの、モジュールのエクスポートリスト内でデータ構築子をエクスポートしないように注意する必要があります。</p>
<p>次に、属性値として <code>Name</code>を使うことができるように、新しい型に<code>IsValue</code>型クラスのインスタンスを定義します。</p>
<pre><code class="language-haskell">instance nameIsValue :: IsValue Name where
  toValue (Name n) = n
</code></pre>
<p>また、次のように <code>a</code>要素に現れるハイパーリンク用の新しいデータ型を定義します。</p>
<pre><code class="language-haskell">data Href
  = URLHref String
  | AnchorHref Name

instance hrefIsValue :: IsValue Href where
  toValue (URLHref url) = url
  toValue (AnchorHref (Name nm)) = &quot;#&quot; &lt;&gt; nm
</code></pre>
<p>この新しい型により、<code>href</code>属性の型の値を変更して、利用者にこの新しい <code>Href</code>型の使用を強制することができます。
また、新しい <code>name</code>属性を作成することもでき、要素をアンカーに変換するのに使えます。</p>
<pre><code class="language-haskell">href :: AttributeKey Href
href = AttributeKey &quot;href&quot;

name :: AttributeKey Name
name = AttributeKey &quot;name&quot;
</code></pre>
<p>残っている問題は、現在モジュールの使用者が新しい名前を生成する方法がないということです。
<code>Content</code>モナドでこの機能を提供することができます。まず、 <code>ContentF</code>型構築子に新しいデータ構築子を追加する必要があります。</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a
  | NewName (Name -&gt; a)
</code></pre>
<p><code>NewName</code>データ構築子は型 <code>Name</code>の値を返すアクションに対応しています。
データ構築子の引数として <code>Name</code>を要求するのではなく、型 <code>Name -&gt; a</code>の<strong>関数</strong>を提供するように使用者に要求していることに注意してください。
型 <code>a</code>は<strong>計算の残り</strong>を表していることを思い出すと、この関数は、型 <code>Name</code>の値が返されたあとで、計算を継続する方法を提供しているのだとわかります。</p>
<p>新しいデータ構築子を考慮するように、次のように<code>ContentF</code>用の<code>Functor</code>インスタンスを更新する必要もあります。</p>
<pre><code class="language-haskell">instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
  map f (NewName k) = NewName (f &lt;&lt;&lt; k)
</code></pre>
<p>これで、以前と同じように<code>liftF</code>関数を使って新しいアクションを構築することができます。</p>
<pre><code class="language-haskell">newName :: Content Name
newName = liftF $ NewName id
</code></pre>
<p><code>id</code>関数を継続として提供していることに注意してください。
これは型 <code>Name</code>の結果を変更せずに返すということを意味しています。</p>
<p>最後に、新しいアクションを解釈するために、解釈関数を更新する必要があります。
以前は計算を解釈するために <code>Writer String</code>モナドを使っていましたが、このモナドは新しい名前を生成する能力を持っていないので、何か他のものに切り替えなければなりません。
<code>WriterT</code>モナド変換子を<code>State</code>モナドと一緒に使うと、必要な作用を組み合わせることができます。
型注釈を短く保てるように、この解釈モナドを型同義語として定義しておきます。</p>
<pre><code class="language-haskell">type Interp = WriterT String (State Int)
</code></pre>
<p>ここで、<code>Int</code>型の状態は増加していくカウンタとして振る舞い、一意な名前を生成するのに使われます。</p>
<p><code>Writer</code>と <code>WriterT</code>モナドはそれらのアクションを抽象化するのに同じ型クラスメンバを使うので、どのアクションも変更する必要がありません。
必要なのは、 <code>Writer String</code>への参照すべてを <code>Interp</code>で置き換えることだけです。
しかし、この計算を実行するために使われるハンドラを変更しなければいけません。
単なる<code>execWriter</code>の代わりに、今やここでも<code>evalState</code>を使う必要があります。</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render e = evalState (execWriterT (renderElement e)) 0
</code></pre>
<p>また、新しい <code>NewName</code>データ構築子を解釈するために、 <code>renderContentItem</code>に新しい場合を追加しなければいけません。</p>
<pre><code class="language-haskell">renderContentItem (NewName k) = do
  n &lt;- get
  let fresh = Name $ &quot;name&quot; &lt;&gt; show n
  put $ n + 1
  pure (k fresh)
</code></pre>
<p>ここで、型 <code>Name -&gt; Content a</code>の継続 <code>k</code>が与えられているので、型 <code>Content a</code>の解釈を構築しなければいけません。
この解釈は単純です。
<code>get</code>を使って状態を読み、その状態を使って一意な名前を生成し、それから <code>put</code>で状態をインクリメントするのです。
最後に、継続にこの新しい名前を渡して、計算を完了します。</p>
<p>以上をもって、この新しい機能をPSCiで試すことができます。
これには<code>Content</code>モナドの内部で一意な名前を生成し、要素の名前とハイパーリンクのリンク先の両方として使います。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Name
&gt; import Effect.Console

&gt; :paste
… render $ p [ ] $ do
…   top &lt;- newName
…   elem $ a [ name := top ] $
…     text &quot;Top&quot;
…   elem $ a [ href := AnchorHref top ] $
…     text &quot;Back to top&quot;
… ^D

&lt;p&gt;&lt;a name=&quot;name0&quot;&gt;Top&lt;/a&gt;&lt;a href=&quot;#name0&quot;&gt;Back to top&lt;/a&gt;&lt;/p&gt;
unit
</code></pre>
<p>複数回の <code>newName</code>の呼び出しの結果が、実際に一意な名前になっていることを確かめられます。</p>
<h2 id="演習-51"><a class="header" href="#演習-51">演習</a></h2>
<ol>
<li>
<p>（普通）使用者から <code>Element</code>型を隠蔽すると、さらにAPIを簡素化することができます。
次の手順に従って、この変更を加えてください。</p>
<ul>
<li><code>p</code>や <code>img</code>のような（返る型が <code>Element</code>の）関数を <code>elem</code>アクションと結合して、型 <code>Content Unit</code>を返す新しいアクションを作ってください。</li>
<li><code>Element</code>の代わりに型<code>Content Unit</code>の引数を受け付けるように<code>render</code>関数を変更してください。</li>
</ul>
</li>
<li>
<p>（普通）型同義語の代わりに<code>newtype</code>を使うことによって<code>Content</code>モナドの実装を隠してください。
<code>newtype</code>用のデータ構築子はエクスポートすべきではありません。</p>
</li>
<li>
<p>（難しい）<code>ContentF</code>型を変更して以下の新しいアクションに対応してください。</p>
<pre><code class="language-haskell">isMobile :: Content Boolean
</code></pre>
<p>このアクションは、この文書がモバイルデバイス上での表示のためにレンダリングされているかどうかを示す真偽値を返します。</p>
<p><strong>ヒント</strong>：<code>ask</code>アクションと<code>ReaderT</code>モナド変換子を使って、このアクションを解釈してください。
あるいは、<code>RWS</code>モナドを使うほうが好みの人もいるかもしれません。</p>
</li>
</ol>
<h2 id="まとめ-12"><a class="header" href="#まとめ-12">まとめ</a></h2>
<p>この章では、いくつかの標準的な技術を使って、素朴な実装を段階的に改善することにより、HTML文書を作成するための領域特化言語を開発しました。</p>
<ul>
<li><strong>スマート構築子</strong>を使ってデータ表現の詳細を隠し、利用者には<strong>構築により正しい</strong>文書だけを作ることを許しました。</li>
<li><strong>独自に定義された中置2引数演算子</strong>を使い言語の構文を改善しました。</li>
<li><strong>幻影型</strong>を使ってデータの型の中に追加の情報を折り込みました。
これにより利用者が誤った型の属性値を与えることを防いでいます。</li>
<li><strong>Freeモナド</strong>を使って内容の集まりの配列表現をdo記法に対応したモナドな表現に変えました。
それからこの表現を新しいモナドアクションに対応するよう拡張し、標準モナド変換子を使ってモナドの計算を解釈しました。</li>
</ul>
<p>これらの手法はすべて、使用者が間違いを犯すのを防いだり領域特化言語の構文を改良したりするために、PureScriptのモジュールと型システムを活用しています。</p>
<p>関数型プログラミング言語による領域特化言語の実装は活発に研究されている分野ですが、いくつかの簡単な技法に対して役に立つ導入を提供し、表現力豊かな型を持つ言語で作業することの威力を示すことができていれば幸いです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>

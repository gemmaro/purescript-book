<!DOCTYPE HTML>
<html lang="ja" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>実例によるPureScript</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">序文</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">実例によるPureScript</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gemmaro/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="実例によるpurescript"><a class="header" href="#実例によるpurescript">実例によるPureScript</a></h1>
<p>このリポジトリには、Phil Freemanによる<em>PureScript by
Example</em>の<a href="https://github.com/purescript-contrib/purescript-book/">コミュニティフォーク</a>が含まれます。
同書は &quot;The PureScript book&quot; としても知られています。
このバージョンはコードと演習が最近のバージョンのコンパイラ、ライブラリ、ツールで動くように更新されています。
PureScriptのエコシステムの最新の機能を紹介すべく書き直された章もあります。</p>
<p>本書をお楽しみいただき、お役立ちいただけましたら、<a href="https://leanpub.com/purescript">Leanpubの原書</a>の購入をご検討ください。</p>
<p>翻訳：<a href="https://gemmaro.github.io/purescript-book/">日本語（本訳）</a></p>
<h2 id="現状"><a class="header" href="#現状">現状</a></h2>
<p>本書は言語の進化に伴って継続的に更新されているため、内容に関して発見したどんな<a href="https://github.com/purescript-contrib/purescript-book/issues">問題</a>でもご報告ください。
より初心者にやさしくできそうな分かりづらい節を指摘するような単純なものであれ、共有いただいたどんなフィードバックにも感謝します。</p>
<p>各章には単体テストも加えられているので、演習への自分の回答が正しいかどうか確かめることができます。
テストの最新の状態については<a href="https://github.com/purescript-contrib/purescript-book/issues/79">#79</a>を見てください。</p>
<h2 id="本書について"><a class="header" href="#本書について">本書について</a></h2>
<p>PureScriptは、表現力のある型を持つ、小さくて強力で静的に型付けされたプログラミング言語です。
Haskellで書かれ、またこの言語から着想を得ています。
そしてJavaScriptにコンパイルされます。</p>
<p>JavaScriptでの関数型プログラミングは最近かなりの人気を誇るようになりましたが、コードを書く上で統制された環境が欠けていることが大規模なアプリケーション開発の妨げとなっています。
PureScriptは、強力に型付けされた関数型プログラミングの力をJavaScriptでの開発の世界に持ち込むことにより、この問題の解決を目指しています。</p>
<p>本書は、基礎（開発環境の立ち上げ）から応用に至るまでの、PureScriptプログラミング言語の始め方を示します。</p>
<p>各章は特定の課題により動機付けられており、その問題を解いていく過程において、新しい関数型プログラミングの道具と技法が導入されていきます。
以下は本書で解いていく課題の幾つかの例です。</p>
<ul>
<li>マップと畳み込みを使ったデータ構造の変換</li>
<li>アプリカティブ関手を使ったフォームフィールドの検証</li>
<li>QuickCheckによるコードの検査</li>
<li>Canvasの使用</li>
<li>領域特化言語の実装</li>
<li>DOMの取り回し</li>
<li>JavaScriptの相互運用性</li>
<li>並列非同期実行</li>
</ul>
<h2 id="使用許諾"><a class="header" href="#使用許諾">使用許諾</a></h2>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons
Attribution-NonCommercial-ShareAlike 3.0 Unported License:
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation
Repo</a>, which uses the same
license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various
contributors</a>.</p>
<p>The exercises are licensed under the MIT license.</p>
<hr />
<small>
<p>Copyright (C) 2015-2018 aratama.<br>
Copyright (C) 2022, 2023 gemmaro.</p>
<p>この翻訳は<a href="https://github.com/aratama">aratama</a>氏による翻訳を元に改変を加えています。
同氏の翻訳リポジトリは<a href="https://github.com/aratama/purescript-book-ja"><code>aratama/purescript-book-ja</code></a>に、Webサイトは<a href="http://aratama.github.io/purescript/">実例によるPureScript</a>にあります。
<a href="http://aratama.github.io/purescript/">aratama氏訳の使用許諾</a>は以下の通りです。</p>
<blockquote>
<p>This book is licensed under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</p>
<p>本書は<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">クリエイティブコモンズ 表示 - 非営利 - 継承 3.0 非移植ライセンス</a>でライセンスされています。</p>
</blockquote>
<p>本翻訳も原文と原翻訳にしたがい、
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>の下に使用が許諾されます。</p>
</small><div style="break-before: page; page-break-before: always;"></div><h1 id="導入"><a class="header" href="#導入">導入</a></h1>
<h2 id="関数型javascript"><a class="header" href="#関数型javascript">関数型JavaScript</a></h2>
<p>関数型プログラミングの手法がJavaScriptに姿を現しはじめてからしばらく経ちます。</p>
<ul>
<li>
<p><a href="https://underscorejs.org">UnderscoreJS</a>などのライブラリがあれば、開発者は<code>map</code>や
<code>filter</code>、<code>reduce</code>といった実績のある関数を活用して、小さいプログラムを組み合わせることで大きなプログラムを作ることができます。</p>
<pre><code class="language-javascript">var sumOfPrimes =
    _.chain(_.range(1000))
     .filter(isPrime)
     .reduce(function(x, y) {
         return x + y;
     })
     .value();
</code></pre>
</li>
<li>
<p>NodeJSにおける非同期プログラミングでは、第一級の値としての関数をコールバックを定義するために多用しています。</p>
<pre><code class="language-javascript">import { readFile, writeFile } from 'fs'

readFile(sourceFile, function (error, data) {
  if (!error) {
    writeFile(destFile, data, function (error) {
      if (!error) {
        console.log(&quot;File copied&quot;);
      }
    });
  }
});
</code></pre>
</li>
<li>
<p><a href="https://reactjs.org">React</a>や<a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a>などのライブラリは、アプリケーションの状態についての純粋な関数としてその外観をモデル化しています</p>
</li>
</ul>
<p>関数は大幅な生産性の向上を齎しうる単純な抽象化を可能にします。
しかし、JavaScriptでの関数型プログラミングには欠点があります。
JavaScriptは冗長で、型付けされず、強力な抽象化の形式を欠いているのです。
また、野放図なJavaScriptコードは等式推論がとても困難です。</p>
<p>PureScriptはこうした課題への対処を目指すプログラミング言語です。
PureScriptは軽量な構文を備えていますが、この構文によりとても表現力豊かでありながら分かりやすく読みやすいコードが書けるのです。
強力な抽象化を支援する豊かな型システムも採用しています。
また、JavaScriptやJavaScriptへとコンパイルされる他の言語と相互運用するときに重要な、高速で理解しやすいコードを生成します。
概してPureScriptとは、純粋関数型プログラミングの理論的な強力さと、JavaScriptのお手軽で緩いプログラミングスタイルとの、とても現実的なバランスを狙った言語だということを理解して頂けたらと思います。</p>
<blockquote>
<p>なお、PureScriptはJavaScriptのみならず他のバックエンドを対象にできますが、本書ではwebブラウザとnode環境に焦点を絞ります。</p>
</blockquote>
<h2 id="型と型推論"><a class="header" href="#型と型推論">型と型推論</a></h2>
<p>動的型付けの言語と静的型付けの言語をめぐる議論については充分に文書化されています。
PureScriptは<em>静的型付け</em>の言語、つまり正しいプログラムはコンパイラによって<em>型</em>を与えられる言語です。
またこの型は、その動作を示すものです。
逆に言えば、型を与えることができないプログラムは<em>誤ったプログラム</em>であり、コンパイラによって拒否されます。
動的型付けの言語とは異なり、PureScriptでは型は<em>コンパイル時</em>にのみ存在し、実行時には一切その表現がありません。</p>
<p>多くの点で、PureScriptの型とこれまでJavaやC#のような他の言語で見てきたであろう型が異なっていることにも、注意することが大切です。
大まかに言えばPureScriptの型はJavaやC#と同じ目的を持っているものの、PureScriptの型はMLやHaskellのような言語に影響を受けています。
PureScriptの型は表現力豊かであり、開発者はプログラムについての強い主張を表明できます。
最も重要なのはPureScriptの型システムが<em>型推論</em>に対応していることです。
型推論があれば他の言語より明示的な型注釈が遥かに少なく済み、型システムを厄介者ではなく<em>道具</em>にしてくれます。
単純な一例として、次のコードは<em>数</em>を定義していますが、<code>Number</code>型への言及はコードのどこにもありません。</p>
<pre><code class="language-haskell">iAmANumber =
  let square x = x * x
  in square 42.0
</code></pre>
<p>より込み入った次の例では、<em>コンパイラにとって未知</em>の型が存在します。
それでも、型注釈なく型の正しさを確かめられていることを示しています。</p>
<pre><code class="language-haskell">iterate f 0 x = x
iterate f n x = iterate f (n - 1) (f x)
</code></pre>
<p>ここで
<code>x</code>の型は不明ですが、<code>x</code>がどんな型を持っているかにかかわらず、<code>iterate</code>が型システムの規則に従っていることをコンパイラは検証できます。</p>
<p>本書で納得していただきたい（または既にお持ちの信条に寄り添って改めて断言したい）ことは、静的型が単にプログラムの正しさに自信を持つためだけのものではなく、それ自体の正しさによって開発の手助けになるものでもあるということです。JavaScriptではごく単純な抽象化を施すのでも大規模なコードのリファクタリングをすることは難しいですが、型検証器のある表現力豊かな型システムは、リファクタリングさえ楽しく対話的な体験にしてくれます。</p>
<p>加えて、型システムによって提供されるこの安全網は、より高度な抽象化を可能にします。
実際に、根本的に型駆動な抽象化の強力な形式である型クラスをPureScriptは提供しています。
この型クラスとは、関数型プログラミング言語Haskellによって有名になりました。</p>
<h2 id="多言語webプログラミング"><a class="header" href="#多言語webプログラミング">多言語webプログラミング</a></h2>
<p>関数型プログラミングは成功を収めてきました。
特に成功している応用例を挙げると、データ解析、構文解析、コンパイラの実装、ジェネリックプログラミング、並列処理といった具合に、枚挙に暇がありません。</p>
<p>PureScriptのような関数型言語でアプリケーション開発の最初から最後までを実施できるでしょう。
値や関数の型を提供することで既存のJavaScriptコードをインポートし、通常のPureScriptコードからこれらの関数を使用する機能をPureScriptは提供しています。
この手法については本書の後半で見ていくことになります。</p>
<p>しかし、PureScriptの強みの1つは、JavaScriptを対象とする他の言語との相互運用性にあります。
アプリケーションの開発の一部にだけPureScriptを使用し、JavaScriptの残りの部分を記述するのに1つ以上の他の言語を使用するという方法もあります。</p>
<p>幾つかの例を示します。</p>
<ul>
<li>中核となる処理はPureScriptで記述し、ユーザーインターフェイスはJavaScriptで記述する</li>
<li>JavaScriptや、他のJavaScriptにコンパイルする言語でアプリケーションを書き、PureScriptでそのテストを書く</li>
<li>既存のアプリケーションのユーザインターフェースのテストを自動化するためにPureScriptを使用する</li>
</ul>
<p>本書では小規模な課題をPureScriptで解決することに焦点を当てます。
ここで学ぶ手法は大規模なアプリケーションに組み込むこともできますが、JavaScriptからPureScriptコードを呼び出す方法、及びその逆についても見ていきます。</p>
<h2 id="ソフトウェア要件"><a class="header" href="#ソフトウェア要件">ソフトウェア要件</a></h2>
<p>本書のソフトウェア要件は最小限です。
第1章では開発環境の構築を一から案内します。
これから使用するツールは、ほとんどの現代のオペレーティングシステムの標準リポジトリで使用できるものです。</p>
<p>PureScriptコンパイラ自体はバイナリの配布物としてもダウンロードできますし、最新のGHC
Haskellコンパイラが動く任意のシステム上でソースからのビルドもできます。
次の章ではこの手順を進めていきます。</p>
<p>本書のこのバージョンのコードは<code>0.15.*</code>バージョンのPureScriptコンパイラと互換性があります。</p>
<h2 id="読者について"><a class="header" href="#読者について">読者について</a></h2>
<p>読者はJavaScriptの基本を既に理解しているものと仮定します。
既にNPMやBowerのようなJavaScriptのエコシステムでの経験があれば、自身の好みに応じて標準設定をカスタマイズしたい場合などに役に立ちます。
ですがそのような知識は必要ありません。</p>
<p>関数型プログラミングの事前知識は必要ありませんが、あっても決して害にはならないでしょう。
新しい考えかたは実例と共に登場するため、これから使っていく関数型プログラミングからこうした概念に対する直感が形成されることでしょう。</p>
<p>PureScriptはプログラミング言語Haskellに強く影響を受けているため、Haskellに通じている読者は本書で提示された概念や構文の多くに見覚えがあるでしょう。
しかし、PureScriptとHaskellの間には数多くの重要な違いがあることも理解しておくと良いでしょう。
ここで紹介する概念の多くはHaskellでも同じように解釈できるとはいえ、どちらかの言語での考え方を他方の言語でそのまま応用しようとすることは、必ずしも適切ではありません。</p>
<h2 id="本書の読み進めかた"><a class="header" href="#本書の読み進めかた">本書の読み進めかた</a></h2>
<p>本書のほとんどの章が各章毎に完結しています。
しかし、関数型プログラミングの経験がほとんどない初心者の方は、各章を順番に進めていくのが賢明です。
最初の数章は本書の後半の内容を理解するのに必要な下地作りです。
関数型プログラミングの考え方に充分通じた読者（特にMLやHaskellのような強く型付けされた言語での経験を持つ読者）なら、本書の前半の章を読まなくても、後半の章のコードの大まかな理解を得ることが恐らく可能でしょう。</p>
<p>各章では1つの実用的な例に焦点を当て、新しい考え方を導入するための動機を与えます。
各章のコードは本書の<a href="https://github.com/purescript-contrib/purescript-book">GitHubのリポジトリ</a>から入手できます。
該当の章のソースコードから抜粋したコード片が含まれる章もありますが、本書の内容に沿ってリポジトリのソースコードを読まれると良いでしょう。
長めの節には、理解を確かめられるように対話式モードのPSCiで実行できる短めのコード片が含まれます。</p>
<p>コード例は次のように等幅フォントで示されます。</p>
<pre><code class="language-haskell">module Example where

import Effect.Console (log)

main = log &quot;Hello, World!&quot;
</code></pre>
<p>先頭にドル記号がついた行は、コマンドラインに入力されたコマンドです。</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>通常、これらのコマンドはLinuxやMac OSの利用者に合わせたものになっています。
そのためWindowsの利用者は小さな変更を加える必要があるかもしれません。
ファイル区切り文字を変更したり、シェルの組み込み機能をWindowsの相当するものに置き換えるなどです。</p>
<p>PSCi対話式モードプロンプトに入力するコマンドは、行の先頭に山括弧が付けられています。</p>
<pre><code class="language-text">&gt; 1 + 2
3
</code></pre>
<p>各章には演習が含まれており、難易度も示されています。
内容を完全に理解するために、各章の演習に取り組むことを強くお勧めします。</p>
<p>本書は初心者にPureScriptへの導入を提供することを目的としており、課題に対するお決まりの解決策の一覧を提供するような類の本ではありません。
初心者にとっては楽しい挑戦になるはずです。
内容を読んで演習に挑戦すれば得るものがあることでしょう。
そして何よりも大切なのは、自分自身でコードを書いてみることです。</p>
<h2 id="困ったときには"><a class="header" href="#困ったときには">困ったときには</a></h2>
<p>もしどこかでつまずいたときには、PureScriptを学べるオンラインで利用可能な資料が沢山あります。</p>
<ul>
<li><a href="https://discord.gg/vKn9up84bp">PureScriptのDiscordサーバ</a>は抱えている問題についてチャットするのに良い場所です。
こちらのサーバはPureScriptについてのチャット専用です。</li>
<li><a href="https://discourse.purescript.org/">PureScriptのDiscourseフォーラム</a>もよくある問題への解決策を探すのに良い場所です。</li>
<li><a href="https://github.com/jordanmartinez/purescript-jordans-reference">PureScript: Jordan's
Reference</a>は別のかなり深く踏み込んだ学習資料です。
本書中の概念で理解しにくいものがあったら、そちらの参考書の対応する節を読むとよいでしょう。</li>
<li><a href="https://pursuit.purescript.org">Pursuit</a>はPureScriptの型と関数を検索できるデータベースです。
Pursuitのヘルプページを読むと<a href="https://pursuit.purescript.org/help/users">どのような種類の検索ができるのかがわかります</a>。</li>
<li>非公式の<a href="https://github.com/JordanMartinez/purescript-cookbook">PureScript
Cookbook</a>は「Xするにはどうするの」といった類の質問にコードを混じえて答えを提供します。</li>
<li><a href="https://github.com/purescript/documentation">PureScriptドキュメントリポジトリ</a>には、PureScriptの開発者や利用者が書いた幅広い話題の記事と例が集まっています。</li>
<li><a href="https://www.purescript.org">PureScriptのwebサイト</a>には幾つかの学習資料へのリンクがあります。
コード例、映像、他の初心者向け資料などです。</li>
<li><a href="https://try.purescript.org">Try
PureScript!</a>は利用者がwebブラウザでPureScriptのコードをコンパイルできるwebサイトです。
幾つかの簡単なコードの例もあります。</li>
</ul>
<p>もし例を読んで学ぶ方が好きでしたら、GitHubの<a href="https://github.com/purescript">purescript</a>、<a href="https://github.com/purescript-node">purescript-node</a>、<a href="https://github.com/purescript-contrib">purescript-contrib</a>組織にはPureScriptコードの例が沢山あります。</p>
<h2 id="著者について"><a class="header" href="#著者について">著者について</a></h2>
<p>私はPureScriptコンパイラの最初の開発者です。
カリフォルニア州ロサンゼルスを拠点にしており、8ビットパーソナルコンピュータであるAmstrad
CPC上のBASICでまだ幼い時にプログラミングを始めました。
それ以来、私は幾つものプログラミング言語（JavaやScala、C#、F#、Haskell、そしてPureScript）で専門的に業務に携わってきました。</p>
<p>プロとしての経歴が始まって間もなく、私は関数型プログラミングと数学の関係を理解するようになり、そしてプログラミング言語Haskellを使って関数型の概念の学習を楽しみました。</p>
<p>JavaScriptでの経験をもとに、私はPureScriptコンパイラの開発を始めることにしました。
気が付くとHaskellのような言語から取り上げた関数型プログラミングの手法を使っていましたが、それを応用するためのもっと理に適った環境を求めていました。
そのとき検討した案のなかには、Haskellからその意味論を維持しながらJavaScriptへとコンパイルするいろいろな試み（Fay、Haste、GHCJS）もありました。
しかし私が興味を持っていたのは、この問題へ別の切り口からアプローチすると、どの程度うまくいくのかということでした。
そのアプローチとは、JavaScriptの意味論を維持しつつ、Haskellのような言語の構文と型システムを楽しむことなのです。</p>
<p>私は<a href="http://blog.functorial.com">ブログ</a>を運営しており、<a href="http://twitter.com/paf31">Twitterで連絡をとる</a>こともできます。</p>
<h2 id="謝辞"><a class="header" href="#謝辞">謝辞</a></h2>
<p>現在に至るまでPureScriptに手を貸してくださった多くの協力者に感謝したいと思います。
コンパイラ、ツール、ライブラリ、ドキュメント、テストでの、巨大で組織的な尽力なくしては、プロジェクトは間違いなく失敗していたことでしょう。</p>
<p>本書の表紙に示されたPureScriptのロゴはGareth Hughesによって作成されたもので、<a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons
Attribution 4.0
license</a>の条件の下で再利用させて頂いています 。</p>
<p>最後に、本書の内容に関する反応や訂正をくださった全ての方に、心より感謝したいと思います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="はじめよう"><a class="header" href="#はじめよう">はじめよう</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>本章では実際のPureScriptの開発環境を立ち上げ、幾つかの演習を解き、本書で提供されているテストを使って答えを確認します。
もし映像を見る学習の仕方が合っているようでしたら、<a href="https://www.youtube.com/watch?v=GPjPwb6d-70">本章を通しで進めるビデオ</a>が役に立つでしょう。</p>
<h2 id="環境構築"><a class="header" href="#環境構築">環境構築</a></h2>
<p>最初にドキュメンテーションリポジトリにあるこの<a href="https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md">はじめの手引き</a>を通しで進め、環境の構築と言語の基礎を学んでください。<a href="http://projecteuler.net/problem=1">Project
Euler</a>の解答例にあるコードがわかりにくかったり見慣れない構文を含んでいたとしても心配要りません。来たる章でこの全ての内容をとても丁寧に押さえていきます。</p>
<h3 id="エディタの対応"><a class="header" href="#エディタの対応">エディタの対応</a></h3>
<p>PureScriptを書く上で（例えば本書の演習を解くなど）お好みのエディタを使えます。
<a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editor-support">エディタの対応についてのドキュメント</a>を参照してください。</p>
<blockquote>
<p>なお、完全なIDE対応のため、開いたプロジェクトのルートに<code>spago.dhall</code>があることを期待するエディタもあります。
例えば本章の演習に取り組む場合、<code>chapter2</code>ディレクトリを開くとよいでしょう。</p>
<p>VS Codeを使っている場合、提供されているワークスペースを使って全ての章を同時に開くことができます。</p>
</blockquote>
<h2 id="演習を解く"><a class="header" href="#演習を解く">演習を解く</a></h2>
<p>ここまでで必要な開発ツールをインストールできているので、本書のリポジトリをクローンしてください。</p>
<pre><code class="language-sh">git clone https://github.com/purescript-contrib/purescript-book.git
</code></pre>
<p>本書のリポジトリには各章に付属してPureScriptのコード例と演習のための単体テストが含まれます。
演習の解法を白紙に戻すために必要な初期設定があり、この設定をすることで解く準備ができます。
この工程は<code>prepareExercises.sh</code>スクリプトを使えば簡単にできます。</p>
<pre><code class="language-sh">cd purescript-book
./scripts/prepareExercises.sh
git add .
git commit --all --message &quot;Exercises ready to be solved&quot;
</code></pre>
<p>それではこの章のテストを走らせましょう。</p>
<pre><code class="language-sh">cd exercises/chapter2
spago test
</code></pre>
<p>以下の成功した旨のテスト出力が出るでしょう。</p>
<pre><code class="language-sh">→ Suite: Euler - Sum of Multiples
  ✓ Passed: below 10
  ✓ Passed: below 1000

All 2 tests passed! 🎉
</code></pre>
<p>なお、（<code>src/Euler.purs</code>にある）<code>answer</code>関数は任意の整数以下の3と5の倍数を見付けるように変更されています。
（<code>test/Main.purs</code>にある）この<code>answer</code>関数のためのテストスートははじめの手引きの冒頭にあるテストよりも網羅的です。
前の方の章を読んでいる間はこのテストフレームワークの仕組みを理解しようと思い詰めなくて大丈夫です。</p>
<p>本書の残りの部分には多くの演習が含まれます。
<code>Test.MySolutions</code>モジュール (<code>test/MySolutions.purs</code>)
に自分の解法を書けば、提供されているテストスートを使って確認できます。</p>
<p>テスト駆動開発でこの次の演習を一緒に進めてみましょう。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>（普通）直角三角形の対角線（あるいは斜辺）の長さを他の2つの辺の長さを使って計算する<code>diagonal</code>関数を書いてください。</li>
</ol>
<h2 id="解法"><a class="header" href="#解法">解法</a></h2>
<p>この演習のテストを有効にするところから始めます。
以下に示すようにブロックコメントの開始を数行下に下げてください。
ブロックコメントは<code>{-</code>から始まり<code>-}</code>で終わります。</p>
<pre><code class="language-hs">    suite &quot;diagonal&quot; do
      test &quot;3 4 5&quot; do
        Assert.equal 5.0 (diagonal 3.0 4.0)
      test &quot;5 12 13&quot; do
        Assert.equal 13.0 (diagonal 5.0 12.0)
    {-  Move this block comment starting point to enable more tests
</code></pre>
<p>ここでテストを走らせようとすると、コンパイルエラーに直面します。
なぜなら<code>diagonal</code>関数をまだ実装していないからです。</p>
<pre><code class="language-sh">$ spago test

Error found:
in module Test.Main
at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)

  Unknown value diagonal
</code></pre>
<p>まずはこの関数に欠陥があるときに何が起こるのか見てみましょう。
以下のコードを<code>test/MySolutions.purs</code>に追加してください。</p>
<pre><code class="language-hs">import Data.Number (sqrt)

diagonal w h = sqrt (w * w + h)
</code></pre>
<p>そして<code>spago test</code>を走らせて確認してください。</p>
<pre><code class="language-hs">→ Suite: diagonal
  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989
  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219

2 tests failed:
</code></pre>
<p>あーあ、全然正しくありませんでした。
ピタゴラスの定理を正しく適用して修正しましょう。
関数を以下のように変えます。</p>
<pre><code class="language-hs">diagonal w h = sqrt (w * w + h * h)
</code></pre>
<p>ここでもう一度<code>spago test</code>としてみると全てのテストが通っています。</p>
<pre><code class="language-hs">→ Suite: Euler - Sum of Multiples
  ✓ Passed: below 10
  ✓ Passed: below 1000
→ Suite: diagonal
  ✓ Passed: 3 4 5
  ✓ Passed: 5 12 13

All 4 tests passed! 🎉
</code></pre>
<p>成功です。
これで次の演習を自力で解くための準備ができました。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（簡単）指定された半径の円の面積を計算する関数<code>circleArea</code>を書いてみましょう。
<code>Numbers</code>モジュールで定義されている <code>pi</code>定数を使用してください。
<em>手掛かり</em>： <code>import Data.Number</code>文を修正して、 <code>pi</code>をインポートすることを忘れないようにしましょう。</li>
<li>（普通）<code>Int</code>を取って<code>100</code>で割ったあとの余りを返す関数<code>leftoverCents</code>を書いてみましょう。<code>rem</code>関数を使ってください。<a href="https://pursuit.purescript.org/">Pursuit</a>でこの関数を検索して、使用法とどのモジュールからインポートしてくるか調べましょう。<em>補足</em>：自動補完の提案を有効にしていたら、IDE側でこの関数の自動的なインポートに対応しているかもしれません。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章ではPureScriptコンパイラとSpagoツールをインストールしました。
演習の解答の書き方と正しさの確認方法も学びました。</p>
<p>この先の章にはもっと沢山の演習があり、それらに取り組むうちに内容を学ぶ助けになっているでしょう。
演習のどこかでお手上げになったら、本書の<a href="chapter1.ja.html#getting-help">困ったときは</a>の節に挙げられているコミュニティの資料のどれかに手を伸ばしたり、<a href="https://github.com/purescript-contrib/purescript-book/issues">本書のリポジトリ</a>でイシューを報告したりできます。
こうした演習の敷居を下げることに繋がる読者のフィードバックのお陰で本書が改善されています。</p>
<p>章の全ての演習を解いたら、<code>no-peeking/Solutions.purs</code>にあるものと解答とを比べられます。
カンニングはせず、演習を誠実に自力で解く労力を割いてください。
そしてたとえ行き詰まったにしても、まずはコミュニティメンバーに尋ねてみるようにしてください。
ネタバレをするよりも小さな手掛かりをあげたいからです。
もっとエレガントな解法（とはいえ本書で押さえられている知識のみで済むもの）を見つけたときはPRを送ってください。</p>
<p>リポジトリは継続して改訂されているため、それぞれの新しい章を始める前に更新を確認するようにしてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="関数とレコード"><a class="header" href="#関数とレコード">関数とレコード</a></h1>
<h2 id="この章の目標-1"><a class="header" href="#この章の目標-1">この章の目標</a></h2>
<p>この章では、関数及びレコードというPureScriptプログラムの2つの構成要素を導入します。更に、どのようにPureScriptプログラムを構造化するのか、どのように型をプログラム開発に役立てるかを見ていきます。</p>
<p>連絡先のリストを管理する簡単な住所録アプリケーションを作成していきます。
このコード例により、PureScriptの構文から幾つかの新しい概念を導入します。</p>
<p>このアプリケーションのフロントエンドは対話式モードであるPSCiを使うようにしていますが、このコードを土台にJavaScriptでフロントエンドを書くこともできるでしょう。
実際に後の章で、フォームの検証と保存及び復元の機能を追加します。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>この章のソースコードは <code>src/Data/AddressBook.purs</code>というファイルに含まれています。
このファイルは次のようなモジュール宣言とインポート一覧から始まります。</p>
<pre><code class="language-haskell">module Data.AddressBook where

import Prelude

import Control.Plus (empty)
import Data.List (List(..), filter, head)
import Data.Maybe (Maybe)
</code></pre>
<p>ここでは、幾つかのモジュールをインポートします。</p>
<ul>
<li><code>Prelude</code>モジュールには標準的な定義と関数の小さな集合が含まれます。
<code>purescript-prelude</code>ライブラリから多くの基礎的なモジュールを再エクスポートしているのです。</li>
<li><code>Control.Plus</code>モジュールには<code>empty</code>値が定義されています。</li>
<li><code>Data.List</code>モジュールは<code>lists</code>パッケージで提供されています。
またこのパッケージはSpagoを使ってインストールできます。
モジュールには連結リストを使うために必要な幾つかの関数が含まれています。</li>
<li><code>Data.Maybe</code>モジュールは、省略可能な値を扱うためのデータ型と関数を定義しています。</li>
</ul>
<p>訳者注：2つのドット (<code>..</code>) を使用すると、
指定された型構築子の全てのデータ構築子をインポートできます。</p>
<p>これらのモジュールのインポート内容が括弧内で明示的に列挙されていることに注目してください（<code>Prelude</code>は除きます。これは一括インポートされるのが普通です）。
明示的な列挙はインポート内容の衝突を避けるのに役に立つので、一般に良い習慣です。</p>
<p>ソースコードリポジトリをクローンしたと仮定すると、この章のプロジェクトは次のコマンドでSpagoを使用して構築できます。</p>
<pre><code class="language-text">$ cd chapter3
$ spago build
</code></pre>
<h2 id="単純な型"><a class="header" href="#単純な型">単純な型</a></h2>
<p>JavaScriptの原始型に対応する組み込みデータ型として、PureScriptでは数値型と文字列型、真偽型の3つが定義されています。
これらは<code>Prim</code>モジュールで定義されており、全てのモジュールに暗黙にインポートされます。
それぞれ<code>Number</code>、<code>String</code>、<code>Boolean</code>と呼ばれており、PSCiで<code>:type</code>コマンドを使うと簡単な値の型を表示させて確認できます。</p>
<pre><code class="language-text">$ spago repl

&gt; :type 1.0
Number

&gt; :type &quot;test&quot;
String

&gt; :type true
Boolean
</code></pre>
<p>PureScriptには他にも、整数、文字、配列、レコード、関数といった組み込み型が定義されています。</p>
<p>小数点以下を省くと整数になり、型 <code>Number</code>の浮動小数点数の値と区別されます。</p>
<pre><code class="language-text">&gt; :type 1
Int
</code></pre>
<p>二重引用符を使用する文字列直値とは異なり、文字直値は一重引用符で囲みます。</p>
<pre><code class="language-text">&gt; :type 'a'
Char
</code></pre>
<p>配列はJavaScriptの配列に対応していますが、JavaScriptの配列とは異なり、PureScriptの配列の全ての要素は同じ型を持つ必要があります。</p>
<pre><code class="language-text">&gt; :type [1, 2, 3]
Array Int

&gt; :type [true, false]
Array Boolean

&gt; :type [1, false]
Could not match type Int with type Boolean.
</code></pre>
<p>最後の例は型検証器によるエラーを示しています。
配列の2つの要素の型を<em>単一化</em>（つまり等価にする意）するのに失敗したのです。</p>
<p>レコードはJavaScriptのオブジェクトに対応しており、レコード直値はJavaScriptのオブジェクト直値と同じ構文になっています。</p>
<pre><code class="language-text">&gt; author = { name: &quot;Phil&quot;, interests: [&quot;Functional Programming&quot;, &quot;JavaScript&quot;] }

&gt; :type author
{ name :: String
, interests :: Array String
}
</code></pre>
<p>この型が示しているのは指定されたオブジェクトが2つの<em>フィールド</em>を持っているということです。
<code>String</code>型のフィールド<code>name</code>と<code>Array String</code>型のフィールド<code>interests</code>です。
後者はつまり<code>String</code>の配列です。</p>
<p>ドットに続けて参照したいフィールドのラベルを書くとレコードのフィールドを参照できます。</p>
<pre><code class="language-text">&gt; author.name
&quot;Phil&quot;

&gt; author.interests
[&quot;Functional Programming&quot;,&quot;JavaScript&quot;]
</code></pre>
<p>PureScriptの関数はJavaScriptの関数に対応します。
関数はファイルの最上位で定義でき、等号の前に引数を指定します。</p>
<pre><code class="language-haskell">import Prelude -- (+) 演算子をスコープに持ち込みます

add :: Int -&gt; Int -&gt; Int
add x y = x + y
</code></pre>
<p>代えて、バックスラッシュ文字に続けて空白文字で区切られた引数名のリストを書くことで、関数をインラインでも定義できます。
PSCiで複数行の宣言を入力するには、<code>:paste</code>コマンドを使用して「貼り付けモード」に入ります。
このモードでは、<em>Control-D</em>キーシーケンスを使って宣言を終了します。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; :paste
… add :: Int -&gt; Int -&gt; Int
… add = \x y -&gt; x + y
… ^D
</code></pre>
<p>PSCiでこの関数が定義されていると、次のように関数の隣に2つの引数を空白で区切って書くことで、関数をこれらの引数に<em>適用</em> (apply) できます。</p>
<pre><code class="language-text">&gt; add 10 20
30
</code></pre>
<h2 id="字下げについての注意"><a class="header" href="#字下げについての注意">字下げについての注意</a></h2>
<p>PureScriptのコードは字下げの大きさに意味があります。ちょうどHaskellと同じで、JavaScriptとは異なります。コード内の空白の多寡は無意味ではなく、Cのような言語で中括弧によってコードのまとまりを示しているように、PureScriptでは空白がコードのまとまりを示すために使われているということです。</p>
<p>宣言が複数行に亙る場合、最初の行以外は最初の行の字下げより深くしなければなりません。</p>
<p>したがって、次は正しいPureScriptコードです。</p>
<pre><code class="language-haskell">add x y z = x +
  y + z
</code></pre>
<p>しかし、次は正しいコードではありません。</p>
<pre><code class="language-haskell">add x y z = x +
y + z
</code></pre>
<p>後者では、PureScriptコンパイラはそれぞれの行毎に1つ、つまり<em>2つ</em>の宣言であると構文解析します。</p>
<p>一般に、同じブロック内で定義された宣言は同じ深さで字下げする必要があります。
例えばPSCiでlet文の宣言は同じ深さで字下げしなければなりません。
次は正しいコードです。</p>
<pre><code class="language-text">&gt; :paste
… x = 1
… y = 2
… ^D
</code></pre>
<p>しかし、これは正しくありません。</p>
<pre><code class="language-text">&gt; :paste
… x = 1
…  y = 2
… ^D
</code></pre>
<p>PureScriptの幾つかのキーワードは新たなコードのまとまりを導入します。
その中での宣言はそれより深く字下げされなければなりません。</p>
<pre><code class="language-haskell">example x y z =
  let
    foo = x * y
    bar = y * z
  in
    foo + bar
</code></pre>
<p>これはコンパイルされません。</p>
<pre><code class="language-haskell">example x y z =
  let
    foo = x * y
  bar = y * z
  in
    foo + bar
</code></pre>
<p>より多くを学びたければ（あるいは何か問題に遭遇したら）<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#syntax">構文</a>のドキュメントを参照してください。</p>
<h2 id="独自の型の定義"><a class="header" href="#独自の型の定義">独自の型の定義</a></h2>
<p>PureScriptで新たな問題に取り組むときは、まずはこれから扱おうとする値の型の定義を書くことから始めるのがよいでしょう。最初に、住所録に含まれるレコードの型を定義してみます。</p>
<pre><code class="language-haskell">type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }
</code></pre>
<p>これは<code>Entry</code>という<em>型同義語</em>を定義しています。
型<code>Entry</code>は等号の右辺と等価ということです。
レコードの型は<code>firstName</code>、<code>lastName</code>、<code>phone</code>という3つのフィールドからなります。
2つの名前のフィールドは型<code>String</code>を持ち、<code>address</code>は以下で定義された型<code>Address</code>を持ちます。</p>
<pre><code class="language-haskell">type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }
</code></pre>
<p>なお、レコードには他のレコードを含めることができます。</p>
<p>それでは、住所録のデータ構造として3つめの型同義語も定義してみましょう。
単に項目の連結リストとして表すことにします。</p>
<pre><code class="language-haskell">type AddressBook = List Entry
</code></pre>
<p>なお、<code>List Entry</code>は <code>Array Entry</code>とは同じではありません。
後者は項目の<em>配列</em>を表しています。</p>
<h2 id="型構築子と種"><a class="header" href="#型構築子と種">型構築子と種</a></h2>
<p><code>List</code>は<em>型構築子</em>の一例になっています。
<code>List</code>そのものは型ではなく、何らかの型 <code>a</code>があるとき <code>List a</code>が型になっています。
つまり、 <code>List</code>は<em>型引数</em><code>a</code>を取り、新たな型 <code>List a</code>を<em>構築</em>するのです。</p>
<p>なお、ちょうど関数適用と同じように、型構築子は他の型に並置するだけで適用されます。
実際、型<code>List Entry</code>は型構築子<code>List</code>が型<code>Entry</code>に<em>適用</em>されたもので、項目のリストを表しています。</p>
<p>もし間違って（型注釈演算子 <code>::</code>を使って）型 <code>List</code>の値を定義しようとすると、今まで見たことのない種類のエラーが表示されるでしょう。</p>
<pre><code class="language-text">&gt; import Data.List
&gt; Nil :: List
In a type-annotated expression x :: t, the type t must have kind Type
</code></pre>
<p>これは<em>種エラー</em>です。値がその<em>型</em>で区別されるのと同じように、型はその<em>種</em>によって区別されます。間違った型の値が<em>型エラー</em>になるように、<em>間違った種</em>の型は<em>種エラー</em>を引き起こします。</p>
<p><code>Number</code>や <code>String</code>のような、値を持つ全ての型の種を表す <code>Type</code>と呼ばれる特別な種があります。</p>
<p>型構築子にも種があります。
例えば種 <code>Type -&gt; Type</code>はちょうど <code>List</code>のような型から型への関数を表しています。
ここでエラーが発生したのは、値が種 <code>Type</code>であるような型を持つと期待されていたのに、 <code>List</code>は種 <code>Type -&gt; Type</code>を持っているためです。</p>
<p>PSCiで型の種を調べるには、 <code>:kind</code>命令を使用します。例えば次のようになります。</p>
<pre><code class="language-text">&gt; :kind Number
Type

&gt; import Data.List
&gt; :kind List
Type -&gt; Type

&gt; :kind List String
Type
</code></pre>
<p>PureScriptの <em>種システム</em> は他にも面白い種に対応していますが、それらについては本書の他の部分で見ていくことになるでしょう。</p>
<h2 id="量化された型"><a class="header" href="#量化された型">量化された型</a></h2>
<p>説明しやすくするため、任意の2つの引数を取り最初のものを返す原始的な関数を定義しましょう。</p>
<pre><code class="language-text">&gt; :paste
… constantlyFirst :: forall a b. a -&gt; b -&gt; a
… constantlyFirst = \a b -&gt; a
… ^D
</code></pre>
<blockquote>
<p>なお、<code>:type</code>を使って<code>constantlyFirst</code>の型について尋ねた場合、もっと冗長になります。</p>
<pre><code class="language-text">: type constantlyFirst
forall (a :: Type) (b :: Type). a -&gt; b -&gt; a
</code></pre>
<p>型シグネチャには追加で種の情報が含まれます。
<code>a</code>と<code>b</code>が具体的な型であることが明記されています。</p>
</blockquote>
<p>この<code>forall</code>キーワードは、<code>constantlyFirst</code>が<em>全称量化された型</em>を持つことを示しています。
つまり<code>a</code>や<code>b</code>をどの型に置き換えても良く、<code>constantlyFirst</code>はその型で動作するのです。</p>
<p>例えば、<code>a</code>を<code>Int</code>、<code>b</code>を<code>String</code>と選んだとします。
その場合、<code>constantlyFirst</code>の型を次のように<em>特殊化</em>できます。</p>
<pre><code class="language-text">Int -&gt; String -&gt; Int
</code></pre>
<p>量化された型を特殊化したいということをコードで示す必要はありません。
特殊化は自動的に行われます。
例えば、あたかも既にその型に備わっていたかの如く<code>constantlyFirst</code>を使えます。</p>
<pre><code class="language-text">&gt; constantlyFirst 3 &quot;ignored&quot;

3
</code></pre>
<p><code>a</code>と<code>b</code>にはどんな型でも選べますが、<code>constantlyFirst</code>が返す型は最初の引数の型と同じでなければなりません（両方とも同じ<code>a</code>に「紐付く」からです）。</p>
<pre><code class="language-text">:type constantlyFirst true &quot;ignored&quot;
Boolean

:type constantlyFirst &quot;keep&quot; 3
String
</code></pre>
<h2 id="住所録の項目の表示"><a class="header" href="#住所録の項目の表示">住所録の項目の表示</a></h2>
<p>それでは最初に、文字列で住所録の項目を表現する関数を書いてみましょう。
まずは関数に型を与えることから始めます。
型の定義は省略できますが、ドキュメントとしても役立つので型を書いておくようにすると良いでしょう。
実際、最上位の宣言に型註釈が含まれていないと、PureScriptコンパイラが警告を出します。
型宣言は関数の名前とその型を <code>::</code>記号で区切るようにして書きます。</p>
<pre><code class="language-haskell">showEntry :: Entry -&gt; String
</code></pre>
<p>この型シグネチャが言っているのは、<code>showEntry</code>は引数として<code>Entry</code>を取り<code>String</code>を返す関数であるということです。
以下は<code>showEntry</code>のコードです。</p>
<pre><code class="language-haskell">showEntry entry = entry.lastName &lt;&gt; &quot;, &quot; &lt;&gt;
                  entry.firstName &lt;&gt; &quot;: &quot; &lt;&gt;
                  showAddress entry.address
</code></pre>
<p>この関数は<code>Entry</code>レコードの3つのフィールドを連結し、単一の文字列にします。
ここで使用される<code>showAddress</code>関数は<code>address</code>フィールド中のレコードを文字列に変えます。
<code>showAddress</code>の定義は次の通りです。</p>
<pre><code class="language-haskell">showAddress :: Address -&gt; String
showAddress addr = addr.street &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.city &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.state
</code></pre>
<p>関数定義は関数の名前で始まり、引数名のリストが続きます。関数の結果は等号の後ろに定義します。フィールドはドットに続けてフィールド名を書くことで参照できます。PureScriptでは、文字列連結はJavaScriptのような単一のプラス記号ではなく、ダイアモンド演算子（<code>&lt;&gt;</code>）を使用します。</p>
<h2 id="はやめにテストたびたびテスト"><a class="header" href="#はやめにテストたびたびテスト">はやめにテスト、たびたびテスト</a></h2>
<p>PSCi対話式モードでは反応を即座に得られるので、素早い試作開発に向いています。
それではこの最初の関数が正しく動作するかをPSCiを使用して確認してみましょう。</p>
<p>まず、これまでに書いたコードをビルドします。</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>次に、PSCiを起動し、この新しいモジュールをインポートするために <code>import</code>命令を使います。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.AddressBook
</code></pre>
<p>レコード直値を使うと、住所録の項目を作成できます。レコード直値はJavaScriptの無名オブジェクトと同じような構文で名前に束縛します。</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>それでは、この例に関数を適用してみてください。</p>
<pre><code class="language-text">&gt; showAddress address

&quot;123 Fake St., Faketown, CA&quot;
</code></pre>
<p><code>showEntry</code>も、住所の例を含む住所録項目レコードを作って試しましょう。</p>
<pre><code class="language-text">&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; showEntry entry

&quot;Smith, John: 123 Fake St., Faketown, CA&quot;
</code></pre>
<h2 id="住所録の作成"><a class="header" href="#住所録の作成">住所録の作成</a></h2>
<p>今度は住所録を扱う補助関数を幾つか書いてみましょう。
空の住所録を表す値が必要ですが、これは空のリストです。</p>
<pre><code class="language-haskell">emptyBook :: AddressBook
emptyBook = empty
</code></pre>
<p>既存の住所録に値を挿入する関数も必要でしょう。この関数を <code>insertEntry</code>と呼ぶことにします。関数の型を与えることから始めましょう。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>この型シグネチャに書かれているのは、最初の引数として<code>Entry</code>、第2引数として<code>AddressBook</code>を取り、新しい<code>AddressBook</code>を返すということです。</p>
<p>既存の<code>AddressBook</code>を直接変更することはしません。
代わりに、同じデータが含まれている新しい<code>AddressBook</code>を返します。
このように<code>AddressBook</code>は<em>不変データ構造</em>の一例となっています。
これはPureScriptにおける重要な考え方です。
変更はコードの副作用であり、効率良く挙動を探る上で妨げになります。
そのため可能な限り純粋関数や不変なデータにする方が好ましいのです。</p>
<p><code>insertEntry</code>を実装するのに<code>Data.List</code>の<code>Cons</code>関数が使えます。
この関数の型を見るには、PSCiを起動し <code>:type</code>コマンドを使います。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type Cons

forall (a :: Type). a -&gt; List a -&gt; List a
</code></pre>
<p>この型シグネチャで書かれているのは、<code>Cons</code>が何らかの型<code>a</code>の値と型<code>a</code>の要素のリストを取り、同じ型の項目を持つ新しいリストを返すということです。
<code>a</code>を<code>Entry</code>型として特殊化してみましょう。</p>
<pre><code class="language-haskell">Entry -&gt; List Entry -&gt; List Entry
</code></pre>
<p>しかし、 <code>List Entry</code>はまさに <code>AddressBook</code>ですから、次と同じになります。</p>
<pre><code class="language-haskell">Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>今回の場合、既に適切な入力があります。
<code>Entry</code>と <code>AddressBook</code>に <code>Cons</code>を適用すると、新しい <code>AddressBook</code>を得ることができます。
これこそがまさに求めていた関数です。</p>
<p><code>insertEntry</code>の実装は次のようになります。</p>
<pre><code class="language-haskell">insertEntry entry book = Cons entry book
</code></pre>
<p>こうすると、等号の左側にある2つの引数<code>entry</code>と<code>book</code>がスコープに導入されます。
それから<code>Cons</code>関数を適用し、結果を作成しています。</p>
<h2 id="カリー化された関数"><a class="header" href="#カリー化された関数">カリー化された関数</a></h2>
<p>PureScriptの関数はきっかり1つの引数を取ります。
<code>insertEntry</code>関数は2つの引数を取るように見えますが、<em>カリー化された関数</em>の一例なのです。
PureScriptでは全ての関数はカリー化されたものと見做されます。</p>
<p>カリー化が意味するのは複数の引数を取る関数を1度に1つ取る関数に変換することです。
関数を呼ぶときに1つの引数を渡し、これまた1つの引数を取る別の関数を返し、といったことを全ての引数が渡されるまで続けます。</p>
<p>例えば<code>add</code>に<code>5</code>に渡すと別の関数が得られます。
その関数は整数を取り、5を足し、合計を結果として返します。</p>
<pre><code class="language-haskell">add :: Int -&gt; Int -&gt; Int
add x y = x + y

addFive :: Int -&gt; Int
addFive = add 5
</code></pre>
<p><code>addFive</code>は<em>部分適用</em>の結果です。
つまり複数の引数を取る関数に、引数の全個数より少ない数だけ渡すのです。
試してみましょう。</p>
<blockquote>
<p>なお、お済みでなければ<code>add</code>関数を定義しなくてはなりません。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; :paste
… add :: Int -&gt; Int -&gt; Int
… add x y = x + y
… ^D
</code></pre>
</blockquote>
<pre><code class="language-text">&gt; :paste
… addFive :: Int -&gt; Int
… addFive = add 5
… ^D

&gt; addFive 1
6

&gt; add 5 1
6
</code></pre>
<p>カリー化と部分適用をもっと理解するには、例にあった<code>add</code>とは別の関数を2、3作ってみてください。
そしてそれができたら<code>insertEntry</code>に戻りましょう。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>（型シグネチャ中の）<code>-&gt;</code>演算子は右結合です。
つまりコンパイラは型を次のように解釈します。</p>
<pre><code class="language-haskell">Entry -&gt; (AddressBook -&gt; AddressBook)
</code></pre>
<p><code>insertEntry</code>は単一の引数<code>Entry</code>を取り、新しい関数を返します。
そして今度はその関数が単一の引数<code>AddressBook</code>を取り、新しい<code>AddressBook</code>を返します。</p>
<p>これはつまり、最初の引数だけを与えて<code>insertEntry</code>を<em>部分適用</em>できたりするということです。
PSCiで結果の型が見られます。</p>
<pre><code class="language-text">&gt; :type insertEntry entry

AddressBook -&gt; AddressBook
</code></pre>
<p>期待した通り、戻り値の型は関数になっていました。
この結果の関数に2つ目の引数も適用できます。</p>
<pre><code class="language-text">&gt; :type (insertEntry entry) emptyBook
AddressBook
</code></pre>
<p>ただし、ここでの括弧は不要です。
以下は等価です。</p>
<pre><code class="language-text">&gt; :type insertEntry entry emptyBook
AddressBook
</code></pre>
<p>これは関数適用が左に結合するためで、空白で区切った引数を次々に関数に指定するだけでいい理由もこれで分かります。</p>
<p>関数の型の<code>-&gt;</code>演算子は関数の<em>型構築子</em>です。
この演算子は2つの型引数を取ります。
左右の被演算子はそれぞれ関数の引数の型と返り値の型です。</p>
<p>本書では今後、「2引数の関数」というように表現することがあることに注意してください。
しかしそれはカリー化された関数を意味していると考えるべきで、その関数は最初の引数を取り2つ目の引数を取る別の関数を返すのです。</p>
<p>今度は <code>insertEntry</code>の定義について考えてみます。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry book = Cons entry book
</code></pre>
<p>もし式の右辺に明示的に括弧をつけるなら、<code>(Cons entry) book</code>となります。
つまり<code>insertEntry entry</code>はその引数が単に関数<code>(Cons entry)</code>に渡されるような関数だということです。
ところがこの2つの関数はどんな入力についても同じ結果を返すので、となると同じ関数ではないですか。
よって、両辺から引数<code>book</code>を削除できます。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry = Cons entry
</code></pre>
<p>しかし今や同様の議論により、両辺から <code>entry</code>も削除できます。</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry = Cons
</code></pre>
<p>この処理は<em>イータ変換</em>と呼ばれ、（その他の技法を併用して）<em>ポイントフリー形式</em>へと関数を書き換えるのに使えます。
つまり、引数を参照せずに関数を定義できるのです。</p>
<p><code>insertEntry</code>の場合、イータ変換によって「<code>insertEntry</code>は単にリストにおけるconsだ」となり、とても明快な関数の定義になりました。
しかし、一般にポイントフリー形式のほうがいいのかどうかには議論の余地があります。</p>
<h2 id="プロパティ取得子"><a class="header" href="#プロパティ取得子">プロパティ取得子</a></h2>
<p>よくあるパターンの1つとして、レコード中の個別のフィールド（または「プロパティ」）を取得することがあります。
<code>Entry</code>から<code>Address</code>を取り出すインライン関数は次のように書けます。</p>
<pre><code class="language-haskell">\entry -&gt; entry.address
</code></pre>
<p>PureScriptでは<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#property-accessors"><em>プロパティ取得子</em></a>という略記が使えます。この略記では下線文字は無名関数の引数として振舞うため、上記のインライン関数は次と等価です。</p>
<pre><code class="language-haskell">_.address
</code></pre>
<p>これは何段階のプロパティでも動くため、<code>Entry</code>に関連する街を取り出す関数は次のように書けます。</p>
<pre><code class="language-haskell">_.address.city
</code></pre>
<p>以下は一例です。</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; _.lastName entry
&quot;Smith&quot;

&gt; _.address.city entry
&quot;Faketown&quot;
</code></pre>
<h2 id="住所録に問い合わせる"><a class="header" href="#住所録に問い合わせる">住所録に問い合わせる</a></h2>
<p>最小限の住所録アプリケーションの実装で必要になる最後の関数は、名前で人を検索し適切な<code>Entry</code>を返すものです。
これは小さな関数を組み合わせることでプログラムを構築するという、関数型プログラミングで鍵となる考え方のよい応用例になるでしょう。</p>
<p>住所録を絞り込めば該当する姓名を持つ項目だけを保持するようにできます。
そうすれば結果のリストの先頭（つまり最初）の要素を返せます。</p>
<p>この大まかな道筋の仕様があれば関数の型を計算できます。
まずPSCiを開いて<code>filter</code>関数と<code>head</code>関数の型を探してみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type filter

forall (a :: Type). (a -&gt; Boolean) -&gt; List a -&gt; List a

&gt; :type head

forall (a :: Type). List a -&gt; Maybe a
</code></pre>
<p>型の意味を理解するために、これらの2つの型の一部を取り出してみましょう。</p>
<p><code>filter</code>は2引数のカリー化された関数です。
最初の引数は関数で、リストの要素を取り<code>Boolean</code>値を返します。
第2引数は要素のリストで、返り値は別のリストです。</p>
<p><code>head</code>は引数としてリストを取り、 <code>Maybe a</code>という今までに見たことがない型を返します。
<code>Maybe a</code>は型<code>a</code>の省略可能な値を表しており、JavaScriptのような言語で値がないことを示すための<code>null</code>を使う代わりとなる、型安全な代替を提供します。
後の章で改めて詳しく見ていきます。</p>
<p><code>filter</code>と <code>head</code>の全称量化された型は、PureScriptコンパイラによって次のように <em>特殊化</em> (specialized)
されます。</p>
<pre><code class="language-haskell">filter :: (Entry -&gt; Boolean) -&gt; AddressBook -&gt; AddressBook

head :: AddressBook -&gt; Maybe Entry
</code></pre>
<p>関数の引数として姓名を渡す必要があるだろうということは分かっています。</p>
<p><code>filter</code>に渡す関数も必要になることもわかります。この関数を <code>filterEntry</code>と呼ぶことにしましょう。 <code>filterEntry</code>は <code>Entry -&gt; Boolean</code>という型を持っています。 <code>filter filterEntry</code>という関数適用の式は、 <code>AddressBook -&gt; AddressBook</code>という型を持つでしょう。もしこの関数の結果を <code>head</code>関数に渡すと、型 <code>Maybe Entry</code>の結果を得ることになります。</p>
<p>これまでのことを纏めると、関数の妥当な型シグネチャは次のようになります。<code>findEntry</code>と呼ぶことにしましょう。</p>
<pre><code class="language-haskell">findEntry :: String -&gt; String -&gt; AddressBook -&gt; Maybe Entry
</code></pre>
<p>この型シグネチャで書かれているのは、<code>findEntry</code>が姓と名前の2つの文字列及び<code>AddressBook</code>を引数に取り、省略可能な<code>Entry</code>を返すということです。
省略可能な結果は名前が住所録に見付かった場合にのみ値を持ちます。</p>
<p>そして、 <code>findEntry</code>の定義は次のようになります。</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -&gt; Boolean
    filterEntry entry = entry.firstName == firstName &amp;&amp; entry.lastName == lastName
</code></pre>
<p>一歩ずつこのコードを調べてみましょう。</p>
<p><code>findEntry</code>は、どちらも文字列型である <code>firstName</code>と <code>lastName</code>、<code>AddressBook</code>型の
<code>book</code>という3つの名前をスコープに導入します。</p>
<p>定義の右辺では<code>filter</code>関数と<code>head</code>関数が組み合わさっています。
まず項目のリストを絞り込み、その結果に<code>head</code>関数を適用しています。</p>
<p>真偽型を返す関数 <code>filterEntry</code>は <code>where</code>節の内部で補助的な関数として定義されています。
このため、 <code>filterEntry</code>関数はこの定義の内部では使用できますが、外部では使用できません。
また、<code>filterEntry</code>はそれを包む関数の引数に依存でき、 <code>filterEntry</code>は指定された <code>Entry</code>を絞り込むために引数
<code>firstName</code>と <code>lastName</code>を使用しているので、 <code>filterEntry</code>が
<code>findEntry</code>の内部にあることは必須になっています。</p>
<p>なお、最上位での宣言と同じように、必ずしも<code>filterEntry</code>の型シグネチャを指定しなくても構いません。
ただし、ドキュメントの一形態として指定しておくことが推奨されます。</p>
<h2 id="中置の関数適用"><a class="header" href="#中置の関数適用">中置の関数適用</a></h2>
<p>これまでお話しした関数のほとんどは<em>前置</em>関数適用でした。
関数名が引数の<em>前</em>に置かれていたということです。
例えば<code>insertEntry</code>関数を使って<code>Entry</code> (<code>john</code>) を空の<code>AddressBook</code>に追加する場合、以下のように書けます。</p>
<pre><code class="language-haskell">&gt; book1 = insertEntry john emptyBook
</code></pre>
<p>しかし本章には<em>中置</em><a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#binary-operators">2引数演算子</a>の例も含まれています。
<code>filterEntry</code>の定義中の<code>==</code>演算子がそうで、2つの引数の<em>間</em>に置かれています。
PureScriptのソースコードでこうした中置演算子は隠れた<em>前置</em>の実装への中置別称として定義されています。
例えば<code>==</code>は以下の行により前置の<code>eq</code>関数の中置別称として定義されています。</p>
<pre><code class="language-haskell">infix 4 eq as ==
</code></pre>
<p>したがって<code>filterEntry</code>中の<code>entry.firstName == firstName</code>は<code>eq entry.firstName firstName</code>で置き換えられます。
この節の後のほうで中置演算子を定義する例にもう少し触れます。</p>
<p>前置関数を演算子としての中置の位置に置くと、より読みやすいコードになる場面があります。
その一例が<code>mod</code>関数です。</p>
<pre><code class="language-text">&gt; mod 8 3
2
</code></pre>
<p>上の用例でも充分動作しますが、読みにくいです。
より馴染みのある表現の仕方は「8 mod 3」です。
バックスラッシュ (`) の中に前置関数を包むとそのように書けます。</p>
<pre><code class="language-text">&gt; 8 `mod` 3
2
</code></pre>
<p>同様に、<code>insertEntry</code>をバックスラッシュで包むと中置演算子に変わります。
例えば以下の<code>book1</code>と<code>book2</code>は等価です。</p>
<pre><code class="language-haskell">book1 = insertEntry john emptyBook
book2 = john `insertEntry` emptyBook
</code></pre>
<p>複数回<code>insertEntry</code>を適用することで複数の項目がある<code>AddressBook</code>を作ることができますが、以下のように前置関数
(<code>book3</code>) として適用するか中置演算子 (<code>book4</code>) として適用するかの2択があります。</p>
<pre><code class="language-haskell">book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))
book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))
</code></pre>
<p><code>insertEntry</code>には中置演算子別称（または同義語）も定義できます。
この演算子の名前に適当に<code>++</code>を選び、<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#precedence">優先度</a>を<code>5</code>にし、そして<code>infixr</code>を使って右<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#associativity">結合</a>とします。</p>
<pre><code class="language-haskell">infixr 5 insertEntry as ++
</code></pre>
<p>この新しい演算子で上の<code>book4</code>の例を次のように書き直せます。</p>
<pre><code class="language-haskell">book5 = john ++ (peggy ++ (ned ++ emptyBook))
</code></pre>
<p>新しい<code>++</code>演算子の右結合性により、意味を変えずに括弧を除去できます。</p>
<pre><code class="language-haskell">book6 = john ++ peggy ++ ned ++ emptyBook
</code></pre>
<p>括弧を消去する他のよくある技法は、いつもの前置関数と一緒に<code>apply</code>の中置演算子<code>$</code>を使うというものです。</p>
<p>例えば前の<code>book3</code>の例は以下のように書き直せます。</p>
<pre><code class="language-haskell">book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook
</code></pre>
<p>括弧を<code>$</code>で置き換えるのは大抵入力しやすくなりますし（議論の余地がありますが）読みやすくなります。
この記号の意味を覚えるための記憶術として、ドル記号を2つの括弧に打ち消し線が引かれたものと見ることで、これで括弧が不必要になったのだと推測できるという方法があります。</p>
<p>なお、<code>($)</code>は言語にハードコードされた特別な構文ではありません。
単に<code>apply</code>という名前の普通の関数のための中置演算子であって、<code>Data.Function</code>で以下のように定義されています。</p>
<pre><code class="language-haskell">apply :: forall a b. (a -&gt; b) -&gt; a -&gt; b
apply f x = f x

infixr 0 apply as $
</code></pre>
<p><code>apply</code>関数は、他の関数（型は<code>(a -&gt; b)</code>）を最初の引数に、値（型は<code>a</code>）を2つ目の引数に取って、その値に対して関数を呼びます。
この関数が何ら意味のあることをしていないようだと思ったら、全くもって正しいです。
この関数がなくてもプログラムは論理的に同一です（<a href="https://en.wikipedia.org/wiki/Referential_transparency">参照透過性</a>も見てください）。
この関数の構文的な利便性はその中置演算子に割り当てられた特別な性質からきています。
<code>$</code>は右結合 (<code>infixr</code>) で低い優先度 (<code>0</code>) の演算子ですが、これにより深い入れ子になった適用から括弧の束を削除できるのです。</p>
<p>さらなる<code>$</code>演算子を使った括弧退治のチャンスは以前の<code>findEntry</code>関数にあります。</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head $ filter filterEntry book
</code></pre>
<p>この行をより簡潔に書き換える方法を次節の「関数合成」で見ていきます。</p>
<p>名前の短い中置演算子を前置関数として使いたければ括弧で囲むことができます。</p>
<pre><code class="language-text">&gt; 8 + 3
11

&gt; (+) 8 3
11
</code></pre>
<p>その代わりの手段として演算子は部分適用でき、これには式を括弧で囲んで<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#operator-sections">演算子節</a>中の引数として<code>_</code>を使います。これは簡単な無名関数を作るより便利な方法として考えることができます（以下の例ではそこから無名関数を名前に束縛しているので、もはや別に無名とも言えなくなっていますが）。</p>
<pre><code class="language-text">&gt; add3 = (3 + _)
&gt; add3 2
5
</code></pre>
<p>纏めると、以下は引数に<code>5</code>を加える関数の等価な定義です。</p>
<pre><code class="language-haskell">add5 x = 5 + x
add5 x = add 5 x
add5 x = (+) 5 x
add5 x = 5 `add` x
add5   = add 5
add5   = \x -&gt; 5 + x
add5   = (5 + _)
add5 x = 5 `(+)` x  -- よおポチ、中置に目がないっていうから、中置の中に中置を入れといたぜ
</code></pre>
<h2 id="関数合成"><a class="header" href="#関数合成">関数合成</a></h2>
<p>イータ変換を使うと <code>insertEntry</code>関数を簡略化できたのと同じように、引数をよく考察すると <code>findEntry</code>の定義を簡略化できます。</p>
<p>なお、引数 <code>book</code>は関数 <code>filter filterEntry</code>に渡され、この適用の結果が <code>head</code>に渡されます。これは言いかたを変えれば、
<code>filter filterEntry</code>と <code>head</code>の <em>合成</em> (composition) に <code>book</code>が渡されるということです。</p>
<p>PureScriptの関数合成演算子は <code>&lt;&lt;&lt;</code>と <code>&gt;&gt;&gt;</code>です。前者は「逆方向の合成」であり、後者は「順方向の合成」です。</p>
<p>何れかの演算子を使用して <code>findEntry</code>の右辺を書き換えることができます。
逆順の合成を使用すると、右辺は次のようになります。</p>
<pre><code class="language-haskell">(head &lt;&lt;&lt; filter filterEntry) book
</code></pre>
<p>この形式なら最初の定義にイータ変換の技を適用でき、 <code>findEntry</code>は最終的に次のような形式に到達します。</p>
<pre><code class="language-haskell">findEntry firstName lastName = head &lt;&lt;&lt; filter filterEntry
  where
    ...
</code></pre>
<p>右辺を次のようにしても同じく妥当です。</p>
<pre><code class="language-haskell">filter filterEntry &gt;&gt;&gt; head
</code></pre>
<p>どちらにしても、これは「<code>findEntry</code>は絞り込み関数と<code>head</code>関数の合成である」という
<code>findEntry</code>関数のわかりやすい定義を与えます。</p>
<p>どちらの定義のほうが分かりやすいかの判断はお任せしますが、このように関数を部品として捉えるとしばしば有用です。
各関数は1つの役目をこなすようにし、解法を関数合成を使って組み立てるのです。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>（簡単）<code>findEntry</code>関数の定義の主な部分式の型を書き下し、 <code>findEntry</code>関数についてよく理解しているか試してみましょう。
例えば<code>findEntry</code>の定義の中にある <code>head</code>関数の型は <code>AddressBook -&gt; Maybe Entry</code>と特殊化されています。
<em>補足</em>：この問題にはテストがありません。</li>
<li>（普通）関数<code>findEntryByStreet :: String -&gt; AddressBook -&gt; Maybe Entry</code>を書いてください。
この関数は与えられた通りの住所から<code>Entry</code>を見付け出します。
<em>手掛かり</em>：<code>findEntry</code>にある既存のコードを再利用してください。
実装した関数をPSCiと<code>spago test</code>を走らせてテストしてください。</li>
<li>（普通）<code>filterEntry</code>を（<code>&lt;&lt;&lt;</code>や<code>&gt;&gt;&gt;</code>を使った）合成で置き換えて、<code>findEntryByStreet</code>を書き直してください。
合成の対象は、プロパティ取得子（<code>_.</code>記法を使います）と、与えられた文字列引数が与えられた通りの住所に等しいかを判定する関数です。</li>
<li>（普通）名前が<code>AddressBook</code>に存在するかどうかを調べて真偽値で返す関数<code>isInBook</code>を書いてみましょう。
<em>手掛かり</em>：PSCiを使って<code>Data.List.null</code>関数の型を見付けてください。
この関数はリストが空かどうかを調べます。</li>
<li>（難しい）「重複」している住所録の項目を削除する関数<code>removeDuplicates</code>を書いてみましょう。
項目が同じ姓名を共有していれば<code>address</code>フィールドに関係なく、項目が重複していると考えます。
<em>手掛かり</em>：<code>Data.List.nubByEq</code>関数の型をPSCiを使って調べましょう。
この関数は等価性の述語に基づいてリストから重複要素を削除します。
なお、それぞれの重複する項目の集合において最初の要素（リストの先頭に最も近い）が保持する項目です。</li>
</ol>
<h2 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h2>
<p>この章では関数型プログラミングの新しい概念を幾つか押さえ、以下の方法を学びました。</p>
<ul>
<li>対話的モードのPSCiを使用して、関数で実験したり思いついたことを試したりする。</li>
<li>正確さのための道具として、また実装のための道具として型を使う。</li>
<li>多引数の関数を表現するためにカリー化された関数を使う。</li>
<li>合成により小さな部品からプログラムを作る。</li>
<li><code>where</code>式を使ってコードを手際良く構造化する。</li>
<li><code>Maybe</code>型を使用してnull値を回避する。</li>
<li>イータ変換や関数合成のような技法を使ってより分かりやすい仕様にリファクタする。</li>
</ul>
<p>次の章からは、これらの考えかたに基づいて進めていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パターン照合"><a class="header" href="#パターン照合">パターン照合</a></h1>
<blockquote>
<p>一時的な注意事項：本章に取り組まれているようでしたら、2023年11月に第4章と第5章とが入れ替わっていることにお気を付けください。</p>
</blockquote>
<h2 id="この章の目標-2"><a class="header" href="#この章の目標-2">この章の目標</a></h2>
<p>この章では、代数的データ型とパターン照合という、2つの新しい概念を導入します。
また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱います。</p>
<p>パターン照合は関数型プログラミングにおける一般的な手法であり、開発者が簡潔に関数を書けるようになります。
関数の実装を複数の場合に分解することにより、水面下の複雑なアイディアが表現されるのです。</p>
<p>代数的データ型はPureScriptの型システムの機能であり、型のある言語において同等の水準の表現力を可能にしています。
パターン照合とも密接に関連しています。</p>
<p>この章の目的は、代数的データ型やパターン照合を使用して、単純なベクターグラフィックスを記述し操作するためのライブラリを書くことです。</p>
<h2 id="プロジェクトの準備-1"><a class="header" href="#プロジェクトの準備-1">プロジェクトの準備</a></h2>
<p>この章のソースコードはファイル <code>src/Data/Picture.purs</code>で定義されています。</p>
<p><code>Data.Picture</code>モジュールは簡単な図形を表すデータ型<code>Shape</code>やその図形の集合である型<code>Picture</code>を定義します。
また、これらの型を扱うための関数もあります。</p>
<p>このモジュールでは、データ構造を畳込む関数を提供する<code>Data.Foldable</code>モジュールもインポートします。</p>
<pre><code class="language-haskell">module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
</code></pre>
<p><code>Data.Picture</code>モジュールは<code>Number</code>モジュールもインポートしますが、こちらは<code>as</code>キーワードを使います。</p>
<pre><code class="language-haskell">import Data.Number as Number
</code></pre>
<p>こうすると型や関数をモジュール内で使用できるようになりますが、
<code>Number.max</code>のように<em>修飾名</em>を使ったときに限定されます。
重複したインポートを避けたり、どのモジュールからインポートされたのかを明らかにするのに役立ちます。</p>
<blockquote>
<p><em>補足</em>：元のモジュールと同じモジュール名を修飾名に使用する必要はありません。
<code>import Math as M</code>などのより短い名前にできますし、かなりよく見掛けます。</p>
</blockquote>
<h2 id="単純なパターン照合"><a class="header" href="#単純なパターン照合">単純なパターン照合</a></h2>
<p>例を見ることから始めましょう。
パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになります。</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>このアルゴリズムはユークリッドの互除法と呼ばれています。
その定義をオンラインで検索すると、恐らく上記のコードによく似た数学の方程式が見つかるでしょう。
パターン照合の利点の1つは、コードを場合分けして定義でき、数学関数の仕様に似た単純で宣言型なコードを定義できることです。</p>
<p>パターン照合を使用して書かれた関数は、条件と結果の組み合わせによって動作します。
この定義の各行は<em>選択肢</em>や<em>場合</em>と呼ばれています。
等号の左辺の式は<em>パターン</em>と呼ばれており、それぞれの場合は空白で区切られた1つ以上のパターンで構成されています。
場合の集まりは、等号の右側の式が評価され値が返される前に、引数が満たさなければならない条件を表現しています。
それぞれの場合は上からこの順番に試されていき、最初にパターンが入力に照合した場合が返り値を決定します。</p>
<p>例えば<code>gcd</code>関数は次の手順で評価されます。</p>
<ul>
<li>まず最初の場合が試されます。
第2引数がゼロの場合、関数は <code>n</code>（最初の引数）を返します。</li>
<li>そうでなければ、2番目の場合が試されます。
最初の引数がゼロの場合、関数は <code>m</code>（第2引数）を返します。</li>
<li>それ以外の場合、関数は最後の行の式を評価して返します。</li>
</ul>
<p>なお、パターンでは値を名前に束縛できます。
この例の各行では <code>n</code>や<code>m</code>という名前の何れかまたは両方に入力された値を束縛しています。
様々な種類のパターンについて学んでいくうちに、それぞれの種類のパターンが入力の引数から名前を選ぶ様々な方法に対応することがわかるでしょう。</p>
<h2 id="単純なパターン"><a class="header" href="#単純なパターン">単純なパターン</a></h2>
<p>上記のコード例では、2種類のパターンを示しました。</p>
<ul>
<li><code>Int</code>型の値が正確に一致する場合にのみ照合する、整数直値パターン</li>
<li>引数を名前に束縛する、変数パターン</li>
</ul>
<p>単純なパターンには他にも種類があります。</p>
<ul>
<li><code>Number</code>、<code>String</code>、<code>Char</code>、そして<code>Boolean</code>といった直値</li>
<li>どんな引数とも照合するが名前に束縛はしない、アンダースコア (<code>_</code>) で表されるワイルドカードパターン</li>
</ul>
<p>これらの単純なパターンを使用する実演として、もう2つの例が以下です。</p>
<pre><code class="language-haskell">fromString :: String -&gt; Boolean
fromString &quot;true&quot; = true
fromString _      = false

toString :: Boolean -&gt; String
toString true  = &quot;true&quot;
toString false = &quot;false&quot;
</code></pre>
<p>PSCiでこれらの関数を試してみてください。</p>
<h2 id="ガード"><a class="header" href="#ガード">ガード</a></h2>
<p>ユークリッドの互除法の例では、<code>m &gt; n</code>のときと<code>m &lt;= n</code>のときの2つの選択肢の間を切り替えるために<code>if .. then .. else</code>式を使いました。
こういうときには<em>ガード</em>を使うという他の選択肢もあります。</p>
<p>ガードとは、パターンにより課された制約に加えて満たされなくてはいけない真偽値の式です。
ガードを使用してユークリッドのアルゴリズムを書き直すと、次のようになります。</p>
<pre><code class="language-haskell">gcdV2 :: Int -&gt; Int -&gt; Int
gcdV2 n 0 = n
gcdV2 0 n = n
gcdV2 n m | n &gt; m     = gcdV2 (n - m) m
          | otherwise = gcdV2 n (m - n)
</code></pre>
<p>この場合、3行目ではガードを使用して、最初の引数が第2引数よりも厳密に大きいという条件を課しています。
最後の行でのガードは式<code>otherwise</code>を使っています。
これはキーワードのようにも見えますが、実際はただの<code>Prelude</code>にある普通の束縛です。</p>
<pre><code class="language-text">&gt; :type otherwise
Boolean

&gt; otherwise
true
</code></pre>
<p>この例が示すように、ガードは等号の左側に現れ、パイプ文字 (<code>|</code>) でパターンのリストと区切られています。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>（簡単）パターン照合を使用して、階乗関数<code>factorial</code>を書いてみましょう。
<em>手掛かり</em>：入力がゼロのときとゼロでないときの、2つの特殊な場合を考えてみてください。
<em>補足</em>：これは前の章の例の反復ですが、ここでは自力で書き直せるかやってみてください。</li>
<li>（普通）\( (1 + x) ^ n \)を多項式展開した式にある\( x ^ k
\)の項の係数を求める関数<code>binomial</code>を書いてください。
これは<code>n</code>要素の集合から<code>k</code>要素の部分集合を選ぶ方法の数と同じです。
数式\( n! / k! (n - k)! \)を使ってください。
ここで \( ! \) は前に書いた階乗関数です。
<em>手掛かり</em>：パターン照合を使って特殊な場合を取り扱ってください。
長い時間が掛かったりコールスタックのエラーでクラッシュしたりしたら、特殊な場合を更に追加してみてください。</li>
<li>（普通）<a href="https://en.wikipedia.org/wiki/Pascal%27s_rule"><em>パスカルの法則</em></a>を使って前の演習と同じ2項係数を計算する関数<code>pascal</code>を書いてください。</li>
</ol>
<h2 id="配列パターン"><a class="header" href="#配列パターン">配列パターン</a></h2>
<p><em>配列直値パターン</em>は、固定長の配列に対して照合する方法を提供します。
例えば空の配列であるか判定する関数<code>isEmpty</code>を書きたいとします。
最初の選択肢に空の配列パターン (<code>[]</code>) を用いるとこれを実現できます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty [] = true
isEmpty _ = false
</code></pre>
<p>次の関数では、長さ5の配列と照合し、配列の5つの要素をそれぞれ違った方法で束縛しています。</p>
<pre><code class="language-haskell">takeFive :: Array Int -&gt; Int
takeFive [0, 1, a, b, _] = a * b
takeFive _ = 0
</code></pre>
<p>最初のパターンは、第1要素と第2要素がそれぞれ0と1であるような、5要素の配列にのみ照合します。
その場合、関数は第3要素と第4要素の積を返します。
それ以外の場合は、関数は0を返します。
例えばPSCiで試してみると次のようになります。</p>
<pre><code class="language-text">&gt; :paste
… takeFive [0, 1, a, b, _] = a * b
… takeFive _ = 0
… ^D

&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0
</code></pre>
<p>配列の直値パターンでは、固定長の配列と一致させることはできます。
しかしPureScriptは不特定の長さの配列を照合させる手段は全く提供して<em>いません</em>。
そのような類の方法で不変な配列を分解すると、実行速度が低下する可能性があるためです。
このように照合できるデータ構造が必要な場合は、<code>Data.List</code>を使うことをお勧めします。
その他の操作について、より優れた漸近性能を提供するデータ構造も存在します。</p>
<h2 id="レコードパターンと行多相"><a class="header" href="#レコードパターンと行多相">レコードパターンと行多相</a></h2>
<p><em>レコードパターン</em>は（ご想像の通り）レコードに照合します。</p>
<p>レコードパターンはレコード直値にほぼ見た目が似ていますが、コロンの右に値を置くのではなく、それぞれのフィールドで束縛子を指定します。</p>
<p>例えば次のパターンは<code>first</code>と<code>last</code>という名前のフィールドが含まれた任意のレコードに照合し、これらのフィールドの値はそれぞれ <code>x</code>と
<code>y</code>という名前に束縛されます。</p>
<pre><code class="language-haskell">showPerson :: { first :: String, last :: String } -&gt; String
showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x
</code></pre>
<p>レコードパターンはPureScriptの型システムの興味深い機能である<em>行多相</em>の良い例となっています。
もし上の<code>showPerson</code>を型シグネチャなしで定義していたとすると、この型はどのように推論されるのでしょうか。
面白いことに、推論される型は上で与えた型とは同じではありません。</p>
<pre><code class="language-text">&gt; showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x

&gt; :type showPerson
forall (r :: Row Type). { first :: String, last :: String | r } -&gt; String
</code></pre>
<p>この型変数 <code>r</code>は何でしょうか。
PSCiで<code>showPerson</code>を使ってみると、面白いことがわかります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;
</code></pre>
<p>レコードにそれ以外のフィールドが追加されていても、<code>showPerson</code>関数はそのまま動作するのです。
レコードに少なくとも型が<code>String</code>であるようなフィールド<code>first</code>と<code>last</code>が含まれていれば、関数適用は正しく型付けされます。
しかし、フィールドが<em>不足</em>していると、<code>showPerson</code>の呼び出しは<em>不正</em>となります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot; }

Type of expression lacks required label &quot;last&quot;
</code></pre>
<p><code>showPerson</code>の新しい型シグネチャを読むと、「<code>String</code>な<code>first</code>と<code>last</code>フィールド <em>と他のフィールドを何でも</em>
持つあらゆるレコードを取り、<code>String</code>を返す」となります。なお、この挙動は元の<code>showPerson</code>のものとは異なります。行変数<code>r</code>がなければ<code>showPerson</code>は
<em>厳密に</em> <code>first</code>と<code>last</code>フィールドしかないレコードのみを受け付けます。</p>
<p>なお、次のように書くこともできます。</p>
<pre><code class="language-haskell">&gt; showPerson p = p.last &lt;&gt; &quot;, &quot; &lt;&gt; p.first
</code></pre>
<p>そしてPSCiは同じ型を推論することでしょう。</p>
<h2 id="レコード同名利用"><a class="header" href="#レコード同名利用">レコード同名利用</a></h2>
<p><code>showPerson</code>関数は引数内のレコードと照合し、<code>first</code>と<code>last</code>フィールドを<code>x</code>と<code>y</code>という名前の値に束縛していたのでした。
別の方法として、フィールド名自体を再利用してこのような類のパターン照合を次のように単純化できます。</p>
<pre><code class="language-haskell">showPersonV2 :: { first :: String, last :: String } -&gt; String
showPersonV2 { first, last } = last &lt;&gt; &quot;, &quot; &lt;&gt; first
</code></pre>
<p>ここでは、プロパティの名前のみを指定し、名前に導入したい値を指定する必要はありません。これは <em>レコード同名利用</em> (record pun)
と呼ばれます。</p>
<p>レコード同名利用はレコードの<em>構築</em>にも使用できます。
例えば、スコープに <code>first</code>と <code>last</code>という名前の値があれば、<code>{ first, last }</code>を使って人物レコードを作ることができます。</p>
<pre><code class="language-haskell">unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = &quot;Jane&quot;
    last  = &quot;Doe&quot;
</code></pre>
<p>こうすると、状況によってはコードの可読性が向上します。</p>
<h2 id="入れ子になったパターン"><a class="header" href="#入れ子になったパターン">入れ子になったパターン</a></h2>
<p>配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大きなパターンを構築しています。
これまでのほとんどの例では配列パターンとレコードパターンの内部で単純なパターンを使用していました。
しかし特筆すべきこととして、パターンは自由に<em>入れ子</em>にできます。
これにより潜在的に複雑なデータ型についての条件を使って関数を定義できます。</p>
<p>例えばこのコードは2つのレコードパターンを組み合わせています。</p>
<pre><code class="language-haskell">type Address = { street :: String, city :: String }

type Person = { name :: String, address :: Address }

livesInLA :: Person -&gt; Boolean
livesInLA { address: { city: &quot;Los Angeles&quot; } } = true
livesInLA _ = false
</code></pre>
<h2 id="名前付きパターン"><a class="header" href="#名前付きパターン">名前付きパターン</a></h2>
<p>入れ子のパターンを使う場合、パターンには<em>名前を付け</em>てスコープに名前を追加で持ち込むことができます。
任意のパターンに名前を付けるには、 <code>@</code>記号を使います。</p>
<p>例えば次の関数は2要素配列を整列するもので、2つの要素に名前を付けていますが、配列自身にも名前を付けています。</p>
<pre><code class="language-haskell">sortPair :: Array Int -&gt; Array Int
sortPair arr@[x, y]
  | x &lt;= y = arr
  | otherwise = [y, x]
sortPair arr = arr
</code></pre>
<p>このようにすれば対が既に整列されているときに新しい配列を割り当てなくて済みます。
なお、もし入力の配列が<em>厳密に</em>2つの要素を含んでいなければ、たとえ整列されていなかったとしても、この関数は単に元のまま変えずに返します。</p>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>（簡単）レコードパターンを使って、2つの <code>Person</code>レコードが同じ都市にいるか調べる関数 <code>sameCity</code>を定義してみましょう。</li>
<li>（普通）行多相を考慮すると、 <code>sameCity</code>関数の最も一般的な型は何でしょうか。
先ほど定義した<code>livesInLA</code>関数についてはどうでしょうか。
<em>補足</em>：この演習にテストはありません。</li>
<li>（普通）配列直値パターンを使って、1要素の配列の唯一のメンバーを抽出する関数<code>fromSingleton</code>を書いてみましょう。
1要素だけを持つ配列でない場合、関数は与えられた既定値を返します。
この関数は<code>forall a. a -&gt; Array a -&gt; a</code>という型を持ちます。</li>
</ol>
<h2 id="case式"><a class="header" href="#case式">case式</a></h2>
<p>パターンが現れるのは最上位にある関数宣言だけではありません。
<code>case</code>式を使う計算中の途中の値に対してパターン照合を使えます。
case式には無名関数に似た便利さがあります。
関数に名前を与えることがいつも望ましいわけではないように、パターンを使いたいためだけに関数に名前をつけるようなことを避けられるようになります。</p>
<p>例を示しましょう。
次の関数は、配列の「最長ゼロ末尾」（和がゼロであるような、最も長い配列の末尾）を計算します。</p>
<pre><code class="language-haskell">import Data.Array (tail)
import Data.Foldable (sum)
import Data.Maybe (fromMaybe)

lzs :: Array Int -&gt; Array Int
lzs [] = []
lzs xs = case sum xs of
           0 -&gt; xs
           _ -&gt; lzs (fromMaybe [] $ tail xs)
</code></pre>
<p>以下は一例です。</p>
<pre><code class="language-text">&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]
</code></pre>
<p>この関数は場合毎の分析によって動作します。
もし配列が空なら、唯一の選択肢は空の配列を返すことです。
配列が空でない場合は、更に2つの場合に分けるためにまず<code>case</code>式を使用します。
配列の合計がゼロであれば、配列全体を返します。
そうでなければ、配列の残りに対して再帰します。</p>
<h2 id="パターン照合の失敗と部分関数"><a class="header" href="#パターン照合の失敗と部分関数">パターン照合の失敗と部分関数</a></h2>
<p>case式のパターンを順番に照合していって、どの選択肢の場合も入力が照合しなかった時はどうなるのでしょう。
この場合、<em>パターン照合失敗</em>によって、case式は実行時に失敗します。</p>
<p>簡単な例でこの動作を見てみましょう。</p>
<pre><code class="language-haskell">import Partial.Unsafe (unsafePartial)

partialFunction :: Boolean -&gt; Boolean
partialFunction = unsafePartial \true -&gt; true
</code></pre>
<p>この関数は単一の場合しか含んでいません。
そしてその場合は単一の入力である<code>true</code>にのみ照合します。
このファイルをコンパイルしてPSCiでそれ以外の値を与えて試すと実行時エラーが発生します。</p>
<pre><code class="language-text">&gt; partialFunction false

Failed pattern match
</code></pre>
<p>どんな入力の組み合わせに対しても値を返すような関数は<em>全関数</em>と呼ばれ、そうでない関数は<em>部分的</em>であると呼ばれます。</p>
<p>一般的には、可能な限り全関数として定義したほうが良いと考えられています。
もし関数が何らかの妥当な入力の集合について結果を返さないことがわかっているなら、大抵は失敗であることを示すことができる値を返すほうがよいでしょう。
例えば何らかの<code>a</code>についての型<code>Maybe a</code>で、妥当な結果を返せないときは<code>Nothing</code>を使います。
この方法なら、型安全な方法で値の有無を示すことができます。</p>
<p>PureScriptコンパイラは、パターン照合が不完全であるために関数が全関数ではないことが検出されると、エラーを出します。
<code>unsafePartial</code>関数を使うとこうしたエラーを抑制できます（ただしその部分関数が安全だと言い切れるなら）。
もし上記の<code>unsafePartial</code>関数の呼び出しを取り除くと、コンパイラは次のエラーを出します。</p>
<pre><code class="language-text">A case expression could not be determined to cover all inputs.
The following additional cases are required to cover all inputs:

  false
</code></pre>
<p>これは値<code>false</code>が、定義されたどのパターンとも一致しないことを示しています。
一般にこれらの警告には、複数の不一致な場合が含まれることがあります。</p>
<p>上記の型シグネチャも省略した場合は、次のようになります。</p>
<pre><code class="language-haskell">partialFunction true = true
</code></pre>
<p>このとき、PSCiは興味深い型を推論します。</p>
<pre><code class="language-text">&gt; :type partialFunction

Partial =&gt; Boolean -&gt; Boolean
</code></pre>
<p>本書では以降、<code>=&gt;</code>記号が絡む（<em>型クラス</em>に関連する）型をもっと見ていきます。
しかし現時点では、PureScriptは型システムを使って部分関数を把握していることと、安全な場合に型検証器に明示する必要があることを確認すれば充分です。</p>
<p>コンパイラは、<em>冗長</em>な場合を検出したとき（つまり、その場合より前の方に定義された場合にのみ一致するとき）などにも警告を出します。</p>
<pre><code class="language-haskell">redundantCase :: Boolean -&gt; Boolean
redundantCase true = true
redundantCase false = false
redundantCase false = false
</code></pre>
<p>このとき、最後の場合は冗長であると正しく検出されます。</p>
<pre><code class="language-text">A case expression contains unreachable cases:

  false
</code></pre>
<blockquote>
<p><em>補足</em>：PSCiは警告を表示しません。
そのため、この例を再現するには、この関数をファイルとして保存し、<code>spago build</code>を使ってコンパイルします。</p>
</blockquote>
<h2 id="代数的データ型"><a class="header" href="#代数的データ型">代数的データ型</a></h2>
<p>この節では <em>代数的データ型</em> (algebraic data type, <em>ADT</em>)
と呼ばれる、PureScriptの型システムの機能を導入します。この機能はパターン照合と地続きの関係があります。</p>
<p>しかしまずは切り口となる例について考えていきます。この例では単純なベクターグラフィックスライブラリの実装というこの章の課題を解決する基礎を与えます。</p>
<p>直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとします。
オブジェクト指向言語では、恐らくインターフェースもしくは抽象クラス
<code>Shape</code>を定義し、使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。</p>
<p>しかし、この方針は大きな欠点を1つ抱えています。
<code>Shape</code>を抽象的に扱うためには、実行したいと思う可能性のある全ての操作を事前に把握し、<code>Shape</code>インターフェースに定義する必要があるのです。
モジュール性を壊さずに新しい操作を追加することが難しくなります。</p>
<p>もし図形の種類が事前にわかっているなら、代数的データ型はこうした問題を解決する型安全な方法を提供します。
モジュール性のある方法で <code>Shape</code>に新たな操作を定義しつつ、型安全性を維持できます。</p>
<p>代数的データ型としてどのように<code>Shape</code>が表現されるかを次に示します。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String

type Point =
  { x :: Number
  , y :: Number
  }
</code></pre>
<p>この宣言では<code>Shape</code>をそれぞれの構築子の直和として定義しており、各構築子では含まれるデータを指定します。
<code>Shape</code>は、中央 <code>Point</code>と半径（数値）を持つ <code>Circle</code>か、<code>Rectangle</code>、 <code>Line</code>、 <code>Text</code>の何れかです。
他に<code>Shape</code>型の値を構築する方法はありません。</p>
<p>代数的データ型 (algebraic data type; ADT)
の定義はキーワード<code>data</code>から始まり、それに新しい型の名前と任意個の型引数が続きます。
その型の構築子（これを<em>データ構築子</em>と言います）は等号の後に定義され、パイプ文字 (<code>|</code>) で区切られます。
ADTの構築子が持つデータは原始型に限りません。
構築子にはレコード、配列、また他のADTさえも含められます。</p>
<p>それではPureScriptの標準ライブラリから別の例を見てみましょう。
省略可能な値を定義するのに使われる <code>Maybe</code>型を本書の冒頭で扱いました。
<code>maybe</code>パッケージでは <code>Maybe</code>を次のように定義しています。</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>この例では型引数 <code>a</code>の使用方法を示しています。パイプ文字を「または」と読むことにすると、この定義は「<code>Maybe a</code>型の値は、無い
(<code>Nothing</code>) か、ただの (<code>Just</code>) 型 <code>a</code>の値だ」とほぼ英語のように読むことができます。</p>
<p>なお、データ定義のどこにも構文<code>forall a</code>を使っていません。
<code>forall</code>構文は関数には必須ですが、<code>data</code>によるADTや<code>type</code>での型別称を定義するときは使われません。</p>
<p>データ構築子は再帰的なデータ構造を定義するためにも使用できます。更に例を挙げると、要素が型
<code>a</code>の単方向連結リストのデータ型の定義はこのようになります。</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
</code></pre>
<p>この例は <code>lists</code>パッケージから持ってきました。
ここで <code>Nil</code>構築子は空のリストを表しており、<code>Cons</code>は先頭となる要素と尾鰭から空でないリストを作成するために使われます。
<code>Cons</code>の2つ目のフィールドでデータ型 <code>List a</code>を使用しており、再帰的なデータ型になっていることに注目してください。</p>
<h2 id="adtの使用"><a class="header" href="#adtの使用">ADTの使用</a></h2>
<p>代数的データ型の構築子を使用して値を構築するのはとても簡単です。
対応する構築子に含まれるデータに応じた引数を用意し、その構築子を単に関数のように適用するだけです。</p>
<p>例えば、上で定義した <code>Line</code>構築子は2つの <code>Point</code>を必要としていますので、<code>Line</code>構築子を使って <code>Shape</code>を構築するには、型
<code>Point</code>の2つの引数を与えなければなりません。</p>
<pre><code class="language-haskell">exampleLine :: Shape
exampleLine = Line p1 p2
  where
    p1 :: Point
    p1 = { x: 0.0, y: 0.0 }

    p2 :: Point
    p2 = { x: 100.0, y: 50.0 }
</code></pre>
<p>さて、代数的データ型で値を構築することは簡単ですが、これをどうやって使ったらよいのでしょうか。
ここで代数的データ型とパターン照合との重要な接点が見えてきます。
代数的データ型の値を消費する唯一の方法は構築子に照合するパターンを使うことです。</p>
<p>例を見てみましょう。
<code>Shape</code>を <code>String</code>に変換したいとします。
<code>Shape</code>を構築するのにどの構築子が使用されたかを調べるには、パターン照合を使用しなければなりません。
これには次のようにします。</p>
<pre><code class="language-haskell">showShape :: Shape -&gt; String
showShape (Circle c r) =
  &quot;Circle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, radius: &quot; &lt;&gt; show r &lt;&gt; &quot;]&quot;
showShape (Rectangle c w h) =
  &quot;Rectangle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, width: &quot; &lt;&gt; show w &lt;&gt; &quot;, height: &quot; &lt;&gt; show h &lt;&gt; &quot;]&quot;
showShape (Line start end) =
  &quot;Line [start: &quot; &lt;&gt; showPoint start &lt;&gt; &quot;, end: &quot; &lt;&gt; showPoint end &lt;&gt; &quot;]&quot;
showShape (Text loc text) =
  &quot;Text [location: &quot; &lt;&gt; showPoint loc &lt;&gt; &quot;, text: &quot; &lt;&gt; show text &lt;&gt; &quot;]&quot;

showPoint :: Point -&gt; String
showPoint { x, y } =
  &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot;, &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>各構築子はパターンとして使用でき、構築子への引数はそのパターンで束縛できます。
<code>showShape</code>の最初の場合を考えてみましょう。
もし <code>Shape</code>が <code>Circle</code>構築子に照合した場合、2つの変数パターン <code>c</code>と
<code>r</code>を使って<code>Circle</code>の引数（中心と半径）がスコープに導入されます。
その他の場合も同様です。</p>
<h2 id="演習-5"><a class="header" href="#演習-5">演習</a></h2>
<ol>
<li>（簡単）<code>Circle</code>（型は<code>Shape</code>）を構築する関数<code>circleAtOrigin</code>を書いてください。
中心は原点にあり、半径は<code>10.0</code>です。</li>
<li>（普通）原点を中心として<code>Shape</code>の大きさを<code>2.0</code>倍に拡大する関数<code>doubleScaleAndCenter</code>を書いてみましょう。</li>
<li>（普通）<code>Shape</code>からテキストを抽出する関数<code>shapeText</code>を書いてください。
この関数は<code>Maybe String</code>を返しますが、もし入力が<code>Text</code>を使用して構築されたのでなければ、返り値には<code>Nothing</code>構築子を使ってください。</li>
</ol>
<h2 id="newtype"><a class="header" href="#newtype">newtype</a></h2>
<p>代数的データ型の特殊な場合として、 <em>newtype</em> と呼ばれるものがあります。newtypeはキーワード <code>data</code>の代わりにキーワード
<code>newtype</code>を使用して導入します。</p>
<p>newtype宣言では<em>過不足なく1つだけの</em>構築子を定義しなければならず、その構築子は<em>過不足なく1つだけの</em>引数を取る必要があります。
つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。
実際、newtypeの値は、元の型と同じ実行時表現を持ってるので、実行時性能のオーバーヘッドがありません。
しかし、これらは型システムの観点から区別されます。
型安全性に追加の層を与えるのです。</p>
<p>例として、ボルト、アンペア、オームのような単位を表現するために、<code>Number</code>の型レベルの別名を定義したくなる場合があるかもしれません。</p>
<pre><code class="language-haskell">newtype Volt = Volt Number
newtype Ohm = Ohm Number
newtype Amp = Amp Number
</code></pre>
<p>それからこれらの型を使う関数と値を定義します。</p>
<pre><code class="language-haskell">calculateCurrent :: Volt -&gt; Ohm -&gt; Amp
calculateCurrent (Volt v) (Ohm r) = Amp (v / r)

battery :: Volt
battery = Volt 1.5

lightbulb :: Ohm
lightbulb = Ohm 500.0

current :: Amp
current = calculateCurrent battery lightbulb
</code></pre>
<p>これによりつまらないミスを防ぐことができます。
例えば電源<em>なし</em>に<em>2つ</em>の電球により生み出される電流を計算しようとするなどです。</p>
<pre><code class="language-haskell">current :: Amp
current = calculateCurrent lightbulb lightbulb
{-
TypesDoNotUnify:
  current = calculateCurrent lightbulb lightbulb
                             ^^^^^^^^^
  Could not match type
    Ohm
  with type
    Volt
-}
</code></pre>
<p>もし<code>newtype</code>なしに単なる<code>Number</code>を使っていたら、コンパイラはこのミスを捕捉できません。</p>
<pre><code class="language-haskell">-- これもコンパイルできますが、型安全ではありません。
calculateCurrent :: Number -&gt; Number -&gt; Number
calculateCurrent v r = v / r

battery :: Number
battery = 1.5

lightbulb :: Number
lightbulb = 500.0

current :: Number
current = calculateCurrent lightbulb lightbulb -- 捕捉されないミス
</code></pre>
<p>なお、newtypeは単一の構築子しかとれず、構築子は単一の値でなくてはなりませんが、newtypeは任意の数の型変数を取ることが<em>できます</em>。
例えば以下のnewtypeは妥当な定義です（<code>err</code>と<code>a</code>は型変数で、<code>CouldError</code>構築子は型<code>Either err a</code>の<em>単一</em>の値を期待します）。</p>
<pre><code class="language-Haskell">newtype CouldError err a = CouldError (Either err a)
</code></pre>
<p>また、newtypeの構築子はよくnewtype自身と同じ名前を持つことがあります。
ただこれは必須ではありません。
例えば別個の名前であっても正しいものです。</p>
<pre><code class="language-haskell">newtype Coulomb = MakeCoulomb Number
</code></pre>
<p>この場合<code>Coulomb</code>は（引数ゼロの）<em>型構築子</em>で、<code>MakeCoulomb</code>は<em>データ構築子</em>です。
これらの構築子は異なる名前空間に属しており、<code>Volt</code>の例でそうだったように、名前には一意性があります。
これは全てのADTについて言えることです。
なお、型構築子とデータ構築子には異なる名前を付けられますが、実際には同じ名前を共有するのが普通です。
前述の<code>Amp</code>と<code>Volt</code>の場合がこれです。</p>
<p>newtypeの別の応用は、実行時表現を変えることなく、既存の型に異なる <em>挙動</em> を加えることです。その利用例については次章で <em>型クラス</em>
をお話しするときに押さえます。</p>
<h2 id="演習-6"><a class="header" href="#演習-6">演習</a></h2>
<ol>
<li>（簡単）<code>Watt</code>を<code>Number</code>の<code>newtype</code>として定義してください。それからこの新しい<code>Watt</code>型と前述の<code>Amp</code>と<code>Volt</code>の定義を使って<code>calculateWattage</code>関数を定義してください。</li>
</ol>
<pre><code class="language-haskell">calculateWattage :: Amp -&gt; Volt -&gt; Watt
</code></pre>
<p><code>Watt</code>中のワット数は与えられた<code>Amp</code>中の電流と与えられた<code>Volt</code>の電圧の積で計算できます。</p>
<h2 id="ベクターグラフィックスライブラリ"><a class="header" href="#ベクターグラフィックスライブラリ">ベクターグラフィックスライブラリ</a></h2>
<p>これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライブラリを作成していきましょう。</p>
<p><code>Picture</code>という型同義語を定義しておきます。
これはただの<code>Shape</code>の配列です。</p>
<pre><code class="language-haskell">type Picture = Array Shape
</code></pre>
<p>不具合を修正していると<code>Picture</code>を<code>String</code>として表示できるようにしたくなることもあるでしょう。
これはパターン照合を使用して定義された<code>showPicture</code>関数でできます。</p>
<pre><code class="language-haskell">showPicture :: Picture -&gt; Array String
showPicture = map showShape
</code></pre>
<p>試してみましょう。
モジュールを <code>spago build</code>でコンパイルし、 <code>spago repl</code>でPSCiを開きます。</p>
<pre><code class="language-text">$ spago build
$ spago repl

&gt; import Data.Picture

&gt; showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]

[&quot;Line [start: (0.0, 0.0), end: (1.0, 1.0)]&quot;]
</code></pre>
<h2 id="外接矩形の算出"><a class="header" href="#外接矩形の算出">外接矩形の算出</a></h2>
<p>このモジュールのコード例には、 <code>Picture</code>の最小外接矩形を計算する関数 <code>bounds</code>が含まれています。</p>
<p><code>Bounds</code>型は外接矩形を定義します。</p>
<pre><code class="language-haskell">type Bounds =
  { top    :: Number
  , left   :: Number
  , bottom :: Number
  , right  :: Number
  }
</code></pre>
<p><code>Picture</code>内の <code>Shape</code>の配列を走査し、最小の外接矩形を累算するため、<code>bounds</code>には <code>Data.Foldable</code>の
<code>foldl</code>関数を使用しています。</p>
<pre><code class="language-haskell">bounds :: Picture -&gt; Bounds
bounds = foldl combine emptyBounds
  where
  combine :: Bounds -&gt; Shape -&gt; Bounds
  combine b shape = union (shapeBounds shape) b
</code></pre>
<p>基底の場合では、空の
<code>Picture</code>の最小外接矩形を求める必要がありますが、<code>emptyBounds</code>で定義される空の外接矩形がその条件を満たしています。</p>
<p>累算関数<code>combine</code>は<code>where</code>ブロックで定義されています。
<code>combine</code>は<code>foldl</code>の再帰呼び出しで計算された外接矩形と、配列内の次の
<code>Shape</code>を引数に取り、ユーザ定義の演算子<code>union</code>を使って2つの外接矩形の和を計算しています。
<code>shapeBounds</code>関数は、パターン照合を使用して、単一の図形の外接矩形を計算します。</p>
<h2 id="演習-7"><a class="header" href="#演習-7">演習</a></h2>
<ol>
<li>（普通）ベクターグラフィックライブラリを拡張し、<code>Shape</code>の面積を計算する新しい操作 <code>area</code>を追加してください。
この演習の目的上は、線分やテキストの面積は0であるものとしてください。</li>
<li>（難しい）<code>Shape</code>型を新しいデータ構築子 <code>Clipped</code>で拡張してください。
<code>Clipped</code>は他の <code>Picture</code>を矩形に切り抜きます。
切り抜かれた図形の境界を計算できるよう、<code>shapeBounds</code>関数を拡張してください。
なお、これにより<code>Shape</code>は再帰的なデータ型になります。
<em>手掛かり</em> ：コンパイラは必要に応じて他の関数を拡張するのに付き添ってくれるでしょう。</li>
</ol>
<h2 id="まとめ-2"><a class="header" href="#まとめ-2">まとめ</a></h2>
<p>この章では、関数型プログラミングから基本的ながら強力なテクニックであるパターン照合を扱いました。複雑なデータ構造の一部分と照合するために、簡単なパターンの使い方だけではなく、配列パターンやレコードパターンを使った深さのあるデータ構造の一部分との照合方法を見てきました。</p>
<p>また、この章ではパターン照合に密接に関連する代数的データ型も紹介しました。
代数的データ型のおかげでデータ構造を簡潔に記述でき、新たな操作でデータ型を拡張する上で、モジュール性のある方法が得られるのでした。</p>
<p>最後に<em>行多相</em>を扱いました。
これは強力な抽象化をする型であり、これにより多くの既存のJavaScript関数に型を与えられます。</p>
<p>本書では今後も代数的データ型とパターン照合をいろんなところで使用するので、今のうちにこれらに習熟しておくと後で実を結ぶことでしょう。これ以外にも独自の代数的データ型を作成し、パターン照合を使用してそれらの型を使う関数を書いてみてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="再帰マップ畳み込み"><a class="header" href="#再帰マップ畳み込み">再帰、マップ、畳み込み</a></h1>
<blockquote>
<p>一時的な注意事項：本章に取り組まれているようでしたら、2023年11月に第4章と第5章とが入れ替わっていることにお気を付けください。</p>
</blockquote>
<h2 id="この章の目標-3"><a class="header" href="#この章の目標-3">この章の目標</a></h2>
<p>この章では、アルゴリズムを構造化するときに再帰関数をどのように使うかについて見ていきましょう。
再帰は関数型プログラミングの基本的な手法であり、本書全体に亙って使われます。</p>
<p>また、PureScriptの標準ライブラリから標準的な関数を幾つか取り扱います。
<code>map</code>や<code>fold</code>といった関数だけでなく、<code>filter</code>や<code>concatMap</code>といった特別な場合において便利なものについても見ていきます。</p>
<p>この章では、仮想的なファイルシステムを操作する関数のライブラリを動機付けに用います。
この章で学ぶ技術を応用し、ファイルシステムのモデルにより表現されるファイルのプロパティを計算する関数を書きます。</p>
<h2 id="プロジェクトの準備-2"><a class="header" href="#プロジェクトの準備-2">プロジェクトの準備</a></h2>
<p>この章のソースコードは<code>src/Data/Path.purs</code>と<code>test/Examples.purs</code>に含まれています。
<code>Data.Path</code>モジュールは仮想ファイルシステムのモデルを含みます。
このモジュールの内容を変更する必要はありません。
演習への解答は<code>Test.MySolutions</code>モジュールに実装してください。
それぞれの演習を完了させつつ都度<code>Test.Main</code>モジュールにある対応するテストを有効にし、<code>spago test</code>を走らせることで解答を確認してください。</p>
<p>このプロジェクトには以下の依存関係があります。</p>
<ul>
<li><code>maybe</code>: <code>Maybe</code>型構築子が定義されています。</li>
<li><code>arrays</code>: 配列を扱うための関数が定義されています。</li>
<li><code>strings</code>: JavaScriptの文字列を扱うための関数が定義されています。</li>
<li><code>foldable-traversable</code>: 配列やその他のデータ構造を畳み込む関数が定義されています。</li>
<li><code>console</code>: コンソールへの出力を扱うための関数が定義されています。</li>
</ul>
<h2 id="導入-1"><a class="header" href="#導入-1">導入</a></h2>
<p>再帰は一般のプログラミングでも重要な手法ですが、特に純粋関数型プログラミングでは当たり前のように用いられます。この章で見ていくように、再帰はプログラムの変更可能な状態を減らすために役立つからです。</p>
<p>再帰は<em>分割統治</em>戦略と密接な関係があります。
分割統治とはすなわち、何らかの入力としての問題を解くにあたり、入力を小さな部分に分割してそれぞれの部分について問題を解き、部分毎の答えから最終的な答えを組み立てるということです。</p>
<p>それでは、PureScriptにおける再帰の簡単な例を幾つか見てみましょう。</p>
<p>次に示すのは<em>階乗関数</em>のありふれた例です。</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
</code></pre>
<p>このように、問題を部分問題へ分割することによって階乗関数の計算方法が見てとれます。
より小さい数の階乗を計算していくということです。
ゼロに到達すると、答えは直ちに求まります。</p>
<p>次は、<em>フィボナッチ関数</em>を計算するという、これまたよくある例です。</p>
<pre><code class="language-haskell">fib :: Int -&gt; Int
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)
</code></pre>
<p>やはり、部分問題の解決策を考えることで全体を解決していることがわかります。
このとき、<code>fib (n - 1)</code>と<code>fib (n - 2)</code>という式に対応した、2つの部分問題があります。
これらの2つの部分問題が解決されていれば、この部分的な答えを加算することで、全体の答えを組み立てることができます。</p>
<h2 id="配列上での再帰"><a class="header" href="#配列上での再帰">配列上での再帰</a></h2>
<p>再帰関数の定義は<code>Int</code>型だけに限定されるものではありません。
本書の後半で<em>パターン照合</em>を扱うときに、いろいろなデータ型の上での再帰関数について見ていきますが、ここでは数と配列に限っておきます。</p>
<p>入力がゼロでないかどうかについて分岐するのと同じように、配列の場合も、配列が空でないかどうかについて分岐していきます。再帰を使用して配列の長さを計算する次の関数を考えてみます。</p>
<pre><code class="language-haskell">import Prelude

import Data.Array (null, tail)
import Data.Maybe (fromMaybe)

length :: forall a. Array a -&gt; Int
length [] = 0
length arr = 1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>この関数では、配列が空かどうかに基づいて分岐しています。
<code>null</code>関数は、空配列については<code>true</code>を返します。
空配列は長さ0を、非空配列は尾鰭の長さより1大きい長さを持ちます。</p>
<p><code>tail</code>関数は与えられた配列から最初の要素を除いたものを<code>Maybe</code>に包んで返します。
配列が空であれば（つまり尾鰭がなければ）<code>Nothing</code>が返ります。
<code>fromMaybe</code>関数は既定値と<code>Maybe</code>値を取ります。
後者が<code>Nothing</code>であれば既定値を返し、そうでなければ<code>Just</code>に包まれた値を返します。</p>
<p>JavaScriptで配列の長さを調べるのには、この例はどう見ても実用的な方法とはいえませんが、次の演習を完遂するための手掛かりとしては充分でしょう。</p>
<h2 id="演習-8"><a class="header" href="#演習-8">演習</a></h2>
<ol>
<li>（簡単）入力が偶数であるとき、かつそのときに限り<code>true</code>に返す再帰関数<code>isEven</code>を書いてみましょう。</li>
<li>（普通）配列内の偶数の整数を数える再帰関数<code>countEven</code>を書いてみましょう。
<em>手掛かり</em>：<code>head</code>関数（これも<code>Data.Array</code>モジュールから手に入ります）を使うと、空でない配列の最初の要素を見つけられます。</li>
</ol>
<h2 id="マップ"><a class="header" href="#マップ">マップ</a></h2>
<p><code>map</code>関数は配列に対する再帰関数の一例です。
配列の各要素に順番に関数を適用し、配列の要素を変換するのに使われます。
そのため、配列の<em>内容</em>は変更されますが、その<em>形状</em>（ここでは「長さ」）は保存されます。</p>
<p>本書の後半で<em>型クラス</em>の内容を押さえるとき、<code>map</code>関数が形状を保存する関数のより一般的な様式の一例であることを見ていきます。
この関数は<em>関手</em>と呼ばれる型構築子のクラスを変換するものです。</p>
<p>それでは、PSCiで<code>map</code>関数を試してみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; map (\n -&gt; n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p><code>map</code>がどのように使われているかに注目してください。
最初の引数には配列上で「写す」関数、第2引数には配列そのものを渡します。</p>
<h2 id="中置演算子"><a class="header" href="#中置演算子">中置演算子</a></h2>
<p>バッククォートで関数名を囲むと、写す関数と配列の間に、<code>map</code>関数を書くことができます。</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) `map` [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>この構文は <em>中置関数適用</em> と呼ばれ、どんな関数でもこのように中置できます。普通は2引数の関数に対して使うのが最適でしょう。</p>
<p>配列を扱う際は<code>map</code>関数と等価な<code>&lt;$&gt;</code>という演算子が存在します。</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) &lt;$&gt; [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>それでは<code>map</code>の型を見てみましょう。</p>
<pre><code class="language-text">&gt; :type map
forall (f :: Type -&gt; Type) (a :: Type) (b :: Type). Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>実は<code>map</code>の型は、この章で必要とされているものよりも一般的な型になっています。今回の目的では、<code>map</code>は次のようなもっと具体的な型であるかのように考えるとよいでしょう。</p>
<pre><code class="language-text">forall (a :: Type) (b :: Type). (a -&gt; b) -&gt; Array a -&gt; Array b
</code></pre>
<p>この型では、<code>map</code>関数に適用するときには<code>a</code>と<code>b</code>という2つの型を自由に選ぶことができる、ということも示されています。
<code>a</code>は元の配列の要素の型で、<code>b</code>は目的の配列の要素の型です。
もっと言えば、<code>map</code>が配列の要素の型を保存する必要があるわけではありません。
例えば<code>map</code>を使用すると数値を文字列に変換できます。</p>
<pre><code class="language-text">&gt; show &lt;$&gt; [1, 2, 3, 4, 5]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>中置演算子<code>&lt;$&gt;</code>は特別な構文のように見えるかもしれませんが、実はPureScriptの普通の関数の別称です。
中置構文を使用した単なる<em>適用</em>にすぎません。
実際、括弧でその名前を囲むと、この関数を通常の関数のように使用できます。
これは、<code>map</code>代わりに、括弧で囲まれた<code>(&lt;$&gt;)</code>という名前が使えるということです。</p>
<pre><code class="language-text">&gt; (&lt;$&gt;) show [1, 2, 3, 4, 5]
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>中置関数は既存の関数名の別称として定義されます。
例えば<code>Data.Array</code>モジュールでは次のように<code>range</code>関数の同義語として中置演算子<code>(..)</code>を定義しています。</p>
<pre><code class="language-haskell">infix 8 range as ..
</code></pre>
<p>この演算子は次のように使うことができます。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; 1 .. 5
[1, 2, 3, 4, 5]

&gt; show &lt;$&gt; (1 .. 5)
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p><em>補足</em>：独自の中置演算子は、自然な構文を備える領域特化言語を定義する上で優れた手段になりえます。ただし、乱用すると初心者が読めないコードになることがありますから、新たな演算子の定義には慎重になるのが賢明です。</p>
<p>上記の例では、<code>1 .. 5</code>という式は括弧で囲まれていましたが、実際にはこれは必要ありません。
なぜなら、<code>Data.Array</code>モジュールは、<code>&lt;$&gt;</code>に割り当てられた優先順位より高い優先順位を<code>..</code>演算子に割り当てているからです。
上の例では、<code>..</code>の優先順位は、キーワード<code>infix</code>のあとに書かれた数の<code>8</code> と定義されていました。
ここでは<code>&lt;$&gt;</code>の優先順位よりも高い優先順位を<code>..</code>に割り当てており、このため括弧を付け加える必要がないということです。</p>
<pre><code class="language-text">&gt; show &lt;$&gt; 1 .. 5
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>中置演算子に（左または右の）<em>結合性</em>を与えたい場合は、代わりにキーワード<code>infixl</code>と<code>infixr</code>を使います。
<code>infix</code>を使うと何ら結合性は割り当てられず、同じ演算子を複数回使ったり複数の同じ優先度の演算子を使ったりするときに、式を括弧で囲まなければいけなくなります。</p>
<h2 id="配列の絞り込み"><a class="header" href="#配列の絞り込み">配列の絞り込み</a></h2>
<p><code>Data.Array</code>モジュールでは他にも、よく<code>map</code>と一緒に使われる関数<code>filter</code>も提供しています。
この関数は、述語関数に照合する要素のみを残し、既存の配列から新しい配列を作成する機能を提供します。</p>
<p>例えば1から10までの数で、偶数であるような数の配列を計算したいとします。
これは次のようにできます。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; filter (\n -&gt; n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
</code></pre>
<h2 id="演習-9"><a class="header" href="#演習-9">演習</a></h2>
<ol>
<li>（簡単）<code>map</code>関数や<code>&lt;$&gt;</code>関数を使用して、 配列に格納された数のそれぞれの平方を計算する関数<code>squared</code>を書いてみましょう。
<em>手掛かり</em>：<code>map</code>や<code>&lt;$&gt;</code>といった関数を使ってください。</li>
<li>（簡単）<code>filter</code>関数を使用して、数の配列から負の数を取り除く関数<code>keepNonNegative</code>を書いてみましょう。
<em>手掛かり</em>：<code>filter</code>関数を使ってください。</li>
<li>（普通）
<ul>
<li><code>filter</code>の中置同義語<code>&lt;$?&gt;</code>を定義してください。
<em>補足</em>：中置同義語はREPLでは定義できないかもしれませんが、ファイルでは定義できます。</li>
<li>関数<code>keepNonNegativeRewrite</code>を書いてください。この関数は<code>filter</code>を独自の新しい中置演算子<code>&lt;$?&gt;</code>で置き換えたところ以外、<code>keepNonNegative</code>と同じです。</li>
<li>PSCiで独自の演算子の優先度合いと結合性を試してください。
<em>補足</em>：この問題のための単体試験はありません。</li>
</ul>
</li>
</ol>
<h2 id="配列の平坦化"><a class="header" href="#配列の平坦化">配列の平坦化</a></h2>
<p>配列に関する標準的な関数として<code>Data.Array</code>で定義されているものには、<code>concat</code>関数もあります。<code>concat</code>は配列の配列を1つの配列へと平坦化します。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concat
forall (a :: Type). Array (Array a) -&gt; Array a

&gt; concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>関連する関数として、<code>concat</code>と<code>map</code>を組み合わせた<code>concatMap</code>と呼ばれる関数もあります。
<code>map</code>は（相異なる型の可能性がある）値からの値への関数を引数に取りますが、それに対して<code>concatMap</code>は値から値の配列への関数を取ります。</p>
<p>実際に動かして見てみましょう。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concatMap
forall (a :: Type) (b :: Type). (a -&gt; Array b) -&gt; Array a -&gt; Array b

&gt; concatMap (\n -&gt; [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
</code></pre>
<p>ここでは、数をその数とその数の平方の2つの要素からなる配列に写す関数<code>\n -&gt; [n, n * n]</code>を引数に<code>concatMap</code>を呼び出しています。
結果は10個の整数の配列です。
配列は1から5の数とそのそれぞれの数の平方からなります。</p>
<p><code>concatMap</code>がどのように結果を連結しているのかに注目してください。渡された関数を元の配列のそれぞれの要素について一度ずつ呼び出し、その関数はそれぞれ配列を生成します。最後にそれらの配列を単一の配列に押し潰したものが結果となります。</p>
<p><code>map</code>と<code>filter</code>、<code>concatMap</code>は、「配列内包表記」(array comprehensions)
と呼ばれる、配列に関するあらゆる関数の基盤を形成します。</p>
<h2 id="配列内包表記"><a class="header" href="#配列内包表記">配列内包表記</a></h2>
<p>数<code>n</code>の2つの因数を見つけたいとしましょう。
こうするための簡単な方法としては、総当りで調べる方法があります。
つまり、<code>1</code>から<code>n</code>の数の全ての組み合わせを生成し、それを乗算してみるわけです。
もしその積が<code>n</code>なら、<code>n</code>の因数の組み合わせを見つけたということになります。</p>
<p>配列内包表記を使用するとこれを計算できます。
PSCiを対話式の開発環境として使用し、1つずつこの手順を進めていきましょう。</p>
<p>最初の工程では<code>n</code>以下の数の組み合わせの配列を生成しますが、これには<code>concatMap</code>を使えばよいです。</p>
<p><code>1 .. n</code>のそれぞれの数を配列<code>1 .. n</code>へと対応付けるところから始めましょう。</p>
<pre><code class="language-text">&gt; pairs n = concatMap (\i -&gt; 1 .. n) (1 .. n)
</code></pre>
<p>この関数をテストしてみましょう。</p>
<pre><code class="language-text">&gt; pairs 3
[1,2,3,1,2,3,1,2,3]
</code></pre>
<p>これは求めているものとは全然違います。
単にそれぞれの組み合わせの2つ目の要素を返すのではなく、対全体を保持できるように、内側の<code>1 .. n</code>の複製について関数を対応付ける必要があります。</p>
<pre><code class="language-text">&gt; :paste
… pairs' n =
…   concatMap (\i -&gt;
…     map (\j -&gt; [i, j]) (1 .. n)
…   ) (1 .. n)
… ^D

&gt; pairs' 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
</code></pre>
<p>いい感じになってきました。
しかし、<code>[1, 2]</code>と<code>[2, 1]</code>の両方があるように、重複した組み合わせが生成されています。
<code>j</code>を<code>i</code>から<code>n</code>の範囲に限定することで、2つ目の場合を取り除くことができます。</p>
<pre><code class="language-text">&gt; :paste
… pairs'' n =
…   concatMap (\i -&gt;
…     map (\j -&gt; [i, j]) (i .. n)
…   ) (1 .. n)
… ^D
&gt; pairs'' 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
</code></pre>
<p>すばらしいです。
因数の候補の全ての組み合わせを手に入れたので、<code>filter</code>を使えば、その積が<code>n</code>であるような組み合わせを選び出すことができます。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; factors n = filter (\pair -&gt; product pair == n) (pairs'' n)

&gt; factors 10
[[1,10],[2,5]]
</code></pre>
<p>このコードでは、<code>foldable-traversable</code>ライブラリの<code>Data.Foldable</code>モジュールにある<code>product</code>関数を使っています。</p>
<p>うまくいきました。
因数の組み合わせの正しい集合を重複なく見つけることができました。</p>
<h2 id="do記法"><a class="header" href="#do記法">do記法</a></h2>
<p>しかし、このコードの可読性は大幅に向上できます。<code>map</code>や<code>concatMap</code>は基本的な関数であり、 <em>do記法</em> (do notation)
と呼ばれる特別な構文の基礎になっています（もっと厳密にいえば、それらの一般化である<code>map</code>と<code>bind</code>が基礎をなしています）。</p>
<blockquote>
<p><em>補足</em>：<code>map</code>と<code>concatMap</code>があることで<em>配列内包表記</em>を書けるように、もっと一般的な演算子である<code>map</code>と<code>bind</code>があることで<em>モナド内包表記</em>と呼ばれているものが書けます。
本書の後半では<em>モナド</em>の例をたっぷり見ていくことになりますが、この章では配列のみを考えます。</p>
</blockquote>
<p>do記法を使うと、先ほどの<code>factors</code>関数を次のように書き直すことができます。</p>
<pre><code class="language-haskell">factors :: Int -&gt; Array (Array Int)
factors n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  pure [ i, j ]
</code></pre>
<p>キーワード<code>do</code>はdo記法を使うコードのブロックを導入します。
このブロックは幾つかの種類の式で構成されています。</p>
<ul>
<li>配列の要素を名前に束縛する式。
これは後ろ向きの矢印<code>&lt;-</code>で示されており、左側には名前が、右側には配列の型を持つ式があります。</li>
<li>名前に配列の要素を束縛しない式。
<code>do</code>の<em>結果</em>はこの種類の式の一例であり、最後の行の<code>pure [i, j]</code>に示されています。</li>
<li><code>let</code>キーワードを使用し、式に名前を与える式。</li>
</ul>
<p>この新しい記法を使うと、アルゴリズムの構造がわかりやすくなることがあります。
頭の中で<code>&lt;-</code>を「選ぶ」という単語に置き換えるとすると、「1からnの間の要素<code>i</code>を選び、それからiからnの間の要素<code>j</code>を選び、<code>[i, j]</code>を返す」というように読むことができるでしょう。</p>
<p>最後の行では、<code>pure</code>関数を使っています。この関数はPSCiで評価できますが、型を明示する必要があります。</p>
<pre><code class="language-text">&gt; pure [1, 2] :: Array (Array Int)
[[1, 2]]
</code></pre>
<p>配列の場合、<code>pure</code>は単に1要素の配列を作成します。
<code>factors</code>関数を変更して、<code>pure</code>の代わりにこの形式も使うようにできます。</p>
<pre><code class="language-haskell">factorsV2 :: Int -&gt; Array (Array Int)
factorsV2 n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  [ [ i, j ] ]
</code></pre>
<p>そして、結果は同じになります。</p>
<h2 id="ガード-1"><a class="header" href="#ガード-1">ガード</a></h2>
<p><code>factors</code>関数を更に改良する方法としては、このフィルタを配列内包表記の内側に移動するというものがあります。
これは<code>control</code>ライブラリにある<code>Control.Alternative</code>モジュールの<code>guard</code>関数を使用することで可能になります。</p>
<pre><code class="language-haskell">import Control.Alternative (guard)

factorsV3 :: Int -&gt; Array (Array Int)
factorsV3 n = do
  i &lt;- 1 .. n
  j &lt;- i .. n
  guard $ i * j == n
  pure [ i, j ]
</code></pre>
<p><code>pure</code>と同じように、どのように動作するかを理解するために、PSCiで<code>guard</code>関数を適用して調べてみましょう。
<code>guard</code>関数の型は、ここで必要とされるものよりもっと一般的な型になっています。</p>
<pre><code class="language-text">&gt; import Control.Alternative

&gt; :type guard
forall (m :: Type -&gt; Type). Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<blockquote>
<p><code>Unit</code>型は何ら計算する内容の無い値を表現します。
すなわち具体的で意味のある値が存在しないということです。</p>
<p><code>Unit</code>はよく型構築子に「包んで」計算の返却型として使います。
その計算は具体的な値のためではなく、計算の<em>作用</em>（ないし結果の「形状」）のみに関心があるのです。</p>
<p>例えば、<code>main</code>関数は型<code>Effect Unit</code>を持ちます。
この関数はプロジェクトへの入口であり、直接呼ぶものではありません。</p>
<p>型シグネチャ中の<code>m</code>の意味については第6章で説明します。</p>
</blockquote>
<p>今回の場合は、PSCiは次の型を報告するものと考えてください。</p>
<pre><code class="language-haskell">Boolean -&gt; Array Unit
</code></pre>
<p>目的からすると、次の計算の結果から配列における<code>guard</code>関数について今知りたいことは全てわかります。</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; length $ guard true
1

&gt; length $ guard false
0
</code></pre>
<p>つまり、<code>guard</code>が<code>true</code>に評価される式を渡された場合、単一の要素を持つ配列を返すのです。
もし式が<code>false</code>と評価された場合は、その結果は空です。</p>
<p>ガードが失敗した場合、配列内包表記の現在の分岐は、結果なしで早めに終了されることを意味します。
これは、<code>guard</code>の呼び出しが、途中の配列に対して<code>filter</code>を使用するのと同じだということです。
実践での場面にもよりますが、<code>filter</code>の代わりに<code>guard</code>を使いたいことは多いでしょう。
これらが同じ結果になることを確認するために、<code>factors</code>の2つの定義を試してみてください。</p>
<h2 id="演習-10"><a class="header" href="#演習-10">演習</a></h2>
<ol>
<li>（簡単）関数<code>isPrime</code>を書いてください。
この関数は整数の引数が素数であるかを調べます。
<em>手掛かり</em>：<code>factors</code>関数を使ってください。</li>
<li>（普通）do記法を使い、2つの配列の<em>直積集合</em>を見つけるための関数<code>cartesianProduct</code>を書いてみましょう。
直積集合とは、要素<code>a</code>、<code>b</code>の全ての組み合わせの集合のことです。
ここで<code>a</code>は最初の配列の要素、<code>b</code>は2つ目の配列の要素です。</li>
<li>（普通）関数<code>triples :: Int -&gt; Array (Array Int)</code>を書いてください。
この関数は数値 \( n \) を取り、構成要素（値 \( a \)、 \( b \)、 \( c \)）がそれぞれ \( n
\) 以下であるような全てのピタゴラスの3つ組 (pythagorean triples) を返します。
<em>ピタゴラスの3つ組</em>は \( a ^ 2 + b ^ 2 = c ^ 2 \) であるような数値の配列 \( [ a, b, c ]
\) です。
<em>手掛かり</em>：配列内包表記で<code>guard</code>関数を使ってください。</li>
<li>（難しい）<code>factors</code>関数を使用して、<code>n</code>の<a href="https://www.mathsisfun.com/prime-factorization.html">素因数分解</a>を求める関数<code>primeFactors</code>を定義してみましょう。
<code>n</code>の素因数分解とは、積が<code>n</code>であるような素数の配列のことです。
<em>手掛かり</em>：1より大きい整数について、問題を2つの部分問題に分解してください。
最初の因数を探し、それから残りの因数を探すのです。</li>
</ol>
<h2 id="畳み込み"><a class="header" href="#畳み込み">畳み込み</a></h2>
<p>配列における左右の畳み込みは、再帰を用いて実装できる別の興味深い一揃いの関数を提供します。</p>
<p>PSCiを使って、<code>Data.Foldable</code>モジュールをインポートし、<code>foldl</code>と<code>foldr</code>関数の型を調べることから始めましょう。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :type foldl
forall (f :: Type -&gt; Type) (a :: Type) (b :: Type). Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b

&gt; :type foldr
forall (f :: Type -&gt; Type) (a :: Type) (b :: Type). Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
</code></pre>
<p>これらの型は、現在興味があるものよりも一般化されています。
この章では単純化して以下の（より具体的な）型シグネチャと見て構いません。</p>
<pre><code class="language-text">-- foldl
forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Array a -&gt; b

-- foldr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Array a -&gt; b
</code></pre>
<p>どちらの場合でも、型<code>a</code>は配列の要素の型に対応しています。
型<code>b</code>は「累算器」の型として考えることができます。
累算器とは配列を走査しつつ結果を累算するものです。</p>
<p><code>foldl</code>関数と<code>foldr</code>関数の違いは走査の方向です。
<code>foldr</code>が「右から」配列を畳み込むのに対して、<code>foldl</code>は「左から」配列を畳み込みます。</p>
<p>実際にこれらの関数の動きを見てみましょう。
<code>foldl</code>を使用して数の配列の和を求めてみます。
型<code>a</code>は<code>Int</code>になり、結果の型<code>b</code>も<code>Int</code>として選択できます。
ここでは3つの引数を与える必要があります。
1つ目は次の要素を累算器に加算する<code>Int -&gt; Int -&gt; Int</code>という型の関数です。
2つ目は累算器の<code>Int</code>型の初期値です。
3つ目は和を求めたい<code>Int</code>の配列です。
最初の引数としては、加算演算子を使用できますし、累算器の初期値はゼロになります。</p>
<pre><code class="language-text">&gt; foldl (+) 0 (1 .. 5)
15
</code></pre>
<p>この場合では、引数が逆になっていても<code>(+)</code>関数は同じ結果を返すので、<code>foldl</code>と<code>foldr</code>のどちらでも問題ありません。</p>
<pre><code class="language-text">&gt; foldr (+) 0 (1 .. 5)
15
</code></pre>
<p>違いを説明するために、畳み込み関数の選択が大事になってくる例も書きましょう。
加算関数の代わりに、文字列連結を使用して文字列を構築しましょう。</p>
<pre><code class="language-text">&gt; foldl (\acc n -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;12345&quot;

&gt; foldr (\n acc -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;54321&quot;
</code></pre>
<p>これは、2つの関数の違いを示しています。左畳み込み式は、以下の関数適用と同等です。</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 1) &lt;&gt; show 2) &lt;&gt; show 3) &lt;&gt; show 4) &lt;&gt; show 5)
</code></pre>
<p>それに対し、右畳み込みは以下と等価です。</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 5) &lt;&gt; show 4) &lt;&gt; show 3) &lt;&gt; show 2) &lt;&gt; show 1)
</code></pre>
<h2 id="末尾再帰"><a class="header" href="#末尾再帰">末尾再帰</a></h2>
<p>再帰はアルゴリズムを指定する強力な手法ですが、問題も抱えています。
JavaScriptで再帰関数を評価するとき、入力が大き過ぎるとスタックオーバーフローでエラーを起こす可能性があるのです。</p>
<p>PSCiで次のコードを入力すると、この問題を簡単に検証できます。</p>
<pre><code class="language-text">&gt; :paste
… f n =
…   if n == 0
…     then 0
…     else 1 + f (n - 1)
… ^D

&gt; f 10
10

&gt; f 100000
RangeError: Maximum call stack size exceeded
</code></pre>
<p>これは問題です。
関数型プログラミングの標準的な手法として再帰を採用しようとするなら、境界がない再帰がありうるときでも扱える方法が必要です。</p>
<p>PureScriptは<em>末尾再帰最適化</em>の形でこの問題に対する部分的な解決策を提供しています。</p>
<blockquote>
<p><em>補足</em>：この問題へのより完全な解決策としては、いわゆる<em>トランポリン</em>を使用するライブラリで実装できますが、それはこの章で扱う範囲を超えています。
興味のある読者は<a href="https://pursuit.purescript.org/packages/purescript-free"><code>free</code></a>や<a href="https://pursuit.purescript.org/packages/purescript-tailrec"><code>tailrec</code></a>パッケージのドキュメントをあたると良いでしょう。</p>
</blockquote>
<p>末尾再帰最適化を可能にする上で鍵となる観点は以下となります。
<em>末尾位置</em>にある関数の再帰的な呼び出しは<em>ジャンプ</em>に置き換えられます。
このジャンプではスタックフレームが確保されません。
関数が戻るより前の最後の呼び出しであるとき、呼び出しが<em>末尾位置</em>にあるといいます。
先の例でスタックオーバーフローが見られたのはこれが理由です。
<code>f</code>の再帰呼び出しが末尾位置<em>でなかった</em>からです。</p>
<p>実際には、PureScriptコンパイラは再帰呼び出しをジャンプに置き換えるのではなく、再帰的な関数全体を <em>whileループ</em> に置き換えます。</p>
<p>以下は全ての再帰呼び出しが末尾位置にある再帰関数の例です。</p>
<pre><code class="language-haskell">factorialTailRec :: Int -&gt; Int -&gt; Int
factorialTailRec 0 acc = acc
factorialTailRec n acc = factorialTailRec (n - 1) (acc * n)
</code></pre>
<p><code>factorialTailRec</code>への再帰呼び出しがこの関数の最後にある点に注目してください。
つまり末尾位置にあるのです。</p>
<h2 id="累算器"><a class="header" href="#累算器">累算器</a></h2>
<p>末尾再帰ではない関数を末尾再帰関数に変える一般的な方法は、<em>累算器引数</em>を使用することです。
累算器引数は関数に追加される余剰の引数で、返り値を<em>累算</em>するものです。
これは結果を累算するために返り値を使うのとは対照的です。</p>
<p>例えば章の初めに示した<code>length</code>関数を再考しましょう。</p>
<pre><code class="language-haskell">length :: forall a. Array a -&gt; Int
length [] = 0
length arr = 1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>この実装は末尾再帰ではないので、大きな入力配列に対して実行されると、生成されたJavaScriptはスタックオーバーフローを発生させるでしょう。
しかし代わりに、結果を蓄積するための2つ目の引数を関数に導入することで、これを末尾再帰に変えることができます。</p>
<pre><code class="language-haskell">lengthTailRec :: forall a. Array a -&gt; Int
lengthTailRec arr = length' arr 0
  where
  length' :: Array a -&gt; Int -&gt; Int
  length' [] acc = acc
  length' arr' acc = length' (fromMaybe [] $ tail arr') (acc + 1)
</code></pre>
<p>ここでは補助関数<code>length'</code>に委譲しています。
この関数は末尾再帰です。
その唯一の再帰呼び出しは、最後の場合の末尾位置にあります。
つまり、生成されるコードは<em>whileループ</em>となり、大きな入力でもスタックが溢れません。</p>
<p><code>lengthTailRec</code>の実装を理解する上では、補助関数<code>length'</code>が基本的に累算器引数を使って追加の状態を保持していることに注目してください。
追加の状態とは、部分的な結果です。
0から始まり、入力の配列中の全ての各要素について1ずつ足されて大きくなっていきます。</p>
<p>なお、累算器を「状態」と考えることもできますが、直接には変更されていません。</p>
<h2 id="明示的な再帰より畳み込みを選ぼう"><a class="header" href="#明示的な再帰より畳み込みを選ぼう">明示的な再帰より畳み込みを選ぼう</a></h2>
<p>末尾再帰を使用して再帰関数を記述できれば末尾再帰最適化の恩恵を受けられるので、全ての関数をこの形で書こうとする誘惑に駆られます。
しかし、多くの関数は配列やそれに似たデータ構造に対する折り畳みとして直接書くことができることを忘れがちです。
<code>map</code>や<code>fold</code>のような組み合わせの部品を使って直接アルゴリズムを書くことには、コードの単純さという利点があります。
これらの部品はよく知られており、だからこそ明示的な再帰よりもアルゴリズムの<em>意図</em>がより良く伝わるのです。</p>
<p>例えば<code>foldr</code>を使って配列を反転できます。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :paste
… reverse :: forall a. Array a -&gt; Array a
… reverse = foldr (\x xs -&gt; xs &lt;&gt; [x]) []
… ^D

&gt; reverse [1, 2, 3]
[3,2,1]
</code></pre>
<p><code>foldl</code>を使って<code>reverse</code>を書くことは、読者への課題として残しておきます。</p>
<h2 id="演習-11"><a class="header" href="#演習-11">演習</a></h2>
<ol>
<li>（簡単）<code>foldl</code>を使って真偽値配列の値が全て真か検査する関数<code>allTrue</code>を書いてください。</li>
<li>（普通。テストなし）関数<code>foldl (==) false xs</code>が真を返すような配列<code>xs</code>とはどのようなものか説明してください。
言い換えると、「関数は<code>xs</code>が……を含むときに<code>true</code>を返す」という文を完成させることになります。</li>
<li>（普通）末尾再帰の形式を取っていること以外は<code>fib</code>と同じような関数<code>fibTailRec</code>を書いてください。
<em>手掛かり</em>：累算器引数を使ってください。</li>
<li>（普通）<code>foldl</code>を使って<code>reverse</code>を書いてみましょう。</li>
</ol>
<h2 id="仮想ファイルシステム"><a class="header" href="#仮想ファイルシステム">仮想ファイルシステム</a></h2>
<p>この節ではこれまで学んだことを応用してファイルシステムのモデルを扱う関数を書きます。
事前に定義されたAPIを扱う上でマップ、畳み込み、及びフィルタを使用します。</p>
<p><code>Data.Path</code>モジュールでは、次のように仮想ファイルシステムのAPIが定義されています。</p>
<ul>
<li>ファイルシステム内のパスを表す型<code>Path</code>があります。</li>
<li>ルートディレクトリを表すパス<code>root</code>があります。</li>
<li><code>ls</code>関数はディレクトリ内のファイルを列挙します。</li>
<li><code>filename</code>関数は<code>Path</code>のファイル名を返します。</li>
<li><code>size</code>関数はファイルを表す<code>Path</code>のファイルの大きさを返します。</li>
<li><code>isDirectory</code>関数はファイルかディレクトリかを調べます。</li>
</ul>
<p>型について言うと、次のような型定義があります。</p>
<pre><code class="language-haskell">root :: Path

ls :: Path -&gt; Array Path

filename :: Path -&gt; String

size :: Path -&gt; Maybe Int

isDirectory :: Path -&gt; Boolean
</code></pre>
<p>PSCiでこのAPIを試してみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Path

&gt; root
/

&gt; isDirectory root
true

&gt; ls root
[/bin/,/etc/,/home/]
</code></pre>
<p><code>Test.Examples</code>モジュールでは<code>Data.Path</code> APIを使用する関数を定義しています。
<code>Data.Path</code>モジュールを変更したり定義を理解したりする必要はありません。
全て<code>Test.Examples</code>モジュールだけで作業します。</p>
<h2 id="全てのファイルの一覧"><a class="header" href="#全てのファイルの一覧">全てのファイルの一覧</a></h2>
<p>それでは、ディレクトリの中身を含めた全てのファイルを深く列挙する関数を書いてみましょう。
この関数は以下のような型を持つでしょう。</p>
<pre><code class="language-haskell">allFiles :: Path -&gt; Array Path
</code></pre>
<p>再帰を使ってこの関数を定義できます。
<code>ls</code>を使うとディレクトリ直下の子が列挙されます。
それぞれの子について再帰的に<code>allFiles</code>を適用すると、それぞれパスの配列が返ります。
<code>concatMap</code>を使うと、<code>allFiles</code>を適用して平坦化するまでを一度にできます。</p>
<p>最後に、cons演算子<code>:</code>を使って現在のファイルも含めます。</p>
<pre><code class="language-haskell">allFiles file = file : concatMap allFiles (ls file)
</code></pre>
<blockquote>
<p><em>補足</em>：実はcons演算子<code>:</code>は、不変な配列に対して効率性が悪いので、一般的には推奨されません。
連結リストやシーケンスなどの他のデータ構造を使用すると、効率性を向上させられます。</p>
</blockquote>
<p>それではPSCiでこの関数を試してみましょう。</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.Path

&gt; allFiles root

[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]
</code></pre>
<p>すばらしいです。
do記法で配列内包表記を使ってもこの関数を書くことができるので見ていきましょう。</p>
<p>逆向きの矢印は配列から要素を選択するのに相当することを思い出してください。
最初の工程は引数の直接の子から要素を選択することです。
それからそのファイルに対して再帰関数を呼び出します。
do記法を使用しているので<code>concatMap</code>が暗黙に呼び出されています。
この関数は再帰的な結果を全て連結します。</p>
<p>新しいバージョンは次のようになります。</p>
<pre><code class="language-haskell">allFiles' :: Path -&gt; Array Path
allFiles' file = file : do
  child &lt;- ls file
  allFiles' child
</code></pre>
<p>PSCiで新しいコードを試してみてください。
同じ結果が返ってくるはずです。
どちらのほうがわかりやすいかの選定はお任せします。</p>
<h2 id="演習-12"><a class="header" href="#演習-12">演習</a></h2>
<ol>
<li>
<p>（簡単）ディレクトリの全てのサブディレクトリの中にある（ディレクトリを除く）全てのファイルを返すような関数<code>onlyFiles</code>を書いてみてください。</p>
</li>
<li>
<p>（普通）ファイルを名前で検索する関数<code>whereIs</code>を書いてください。
この関数は型<code>Maybe Path</code>の値を返すものとします。
この値が存在するなら、そのファイルがそのディレクトリに含まれているということを表します。
この関数は次のように振る舞う必要があります。</p>
<pre><code class="language-text">&gt; whereIs root &quot;ls&quot;
Just (/bin/)

&gt; whereIs root &quot;cat&quot;
Nothing
</code></pre>
<p><em>手掛かり</em>：この関数をdo記法を使った配列内包表記で書いてみましょう。</p>
</li>
<li>
<p>（難しい）<code>Path</code>中の最大のファイルと最小のファイルを1つずつ含む配列を返す関数<code>largestSmallest</code>を書いてください。
<em>補足</em>：空配列や1要素の配列を返すことで、<code>Path</code>にそれぞれゼロか1個のファイルがある場合についても考慮してください。</p>
</li>
</ol>
<h2 id="まとめ-3"><a class="header" href="#まとめ-3">まとめ</a></h2>
<p>この章ではアルゴリズムを簡潔に表現するためにPureScriptでの再帰の基本を押さえました。
また、独自の中置演算子や、マップ、絞り込みや畳み込みなどの配列に対する標準関数、及びこれらの概念を組み合わせた配列内包表記を導入しました。
最後に、スタックオーバーフローエラーを回避するために末尾再帰を使用することの重要性、累算器引数を使用して末尾再帰形に関数を変換する方法を示しました。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型クラス"><a class="header" href="#型クラス">型クラス</a></h1>
<h2 id="この章の目標-4"><a class="header" href="#この章の目標-4">この章の目標</a></h2>
<p>この章では、PureScriptの型システムにより可能になっている強力な抽象化の形式を導入します。
そう、型クラスです。</p>
<p>データ構造をハッシュ化するためのライブラリを本章の動機付けの例とします。
データ自体の構造について直接考えることなく複雑な構造のデータのハッシュ値を求める上で、型クラスの仕組みがどのように働くかを見ていきます。</p>
<p>また、PureScriptのPreludeや標準ライブラリに含まれる、標準的な型クラスも見ていきます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大きく依存しているので、これらのクラスに慣れておくと役に立つでしょう。</p>
<p>オブジェクト指向の方面から入って来た方は、「クラス」という単語がそれまで馴染みのあるものとこの文脈とでは <em>かなり</em>
異なるものを意味していることに注意してください。</p>
<h2 id="プロジェクトの準備-3"><a class="header" href="#プロジェクトの準備-3">プロジェクトの準備</a></h2>
<p>この章のソースコードは、ファイル <code>src/data/Hashable.purs</code>で定義されています。</p>
<p>このプロジェクトには以下の依存関係があります。</p>
<ul>
<li><code>maybe</code>: 省略可能な値を表す <code>Maybe</code>データ型が定義されています。</li>
<li><code>tuples</code>: 値の組を表す <code>Tuple</code>データ型が定義されています。</li>
<li><code>either</code>: 非交和を表す <code>Either</code>データ型が定義されています。</li>
<li><code>strings</code>: 文字列を操作する関数が定義されています。</li>
<li><code>functions</code>: PureScriptの関数を定義するための補助関数が定義されています。</li>
</ul>
<p>モジュール <code>Data.Hashable</code>では、これらのパッケージによって提供されるモジュールの幾つかをインポートしています。</p>
<h2 id="見せて"><a class="header" href="#見せて">見せて！</a></h2>
<p>型クラスの最初の簡単な例は、既に何回か見たことがある関数で提供されています。
<code>show</code>は何らかの値を取り、文字列として表示する関数です。</p>
<p><code>show</code>は <code>Prelude</code>モジュールの <code>Show</code>と呼ばれる型クラスで次のように定義されています。</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String
</code></pre>
<p>このコードでは、型変数<code>a</code>を引数に取る<code>Show</code>という新しい<em>型クラス</em>を宣言しています。</p>
<p>型クラス <em>インスタンス</em> には、型クラスで定義された関数の、その型に特殊化された実装が含まれています。</p>
<p>例えば、Preludeにある <code>Boolean</code>値に対する <code>Show</code>型クラスインスタンスの定義は次の通りです。</p>
<pre><code class="language-haskell">instance Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<p>このコードは型クラスのインスタンスを宣言します。
<code>Boolean</code>型は <em><code>Show</code>型クラスに属すもの</em> としています。</p>
<blockquote>
<p>ピンとこなければ、生成されるJSのコードは以下のようになります。</p>
<pre><code class="language-javascript">var showBoolean = {
    show: function (v) {
        if (v) {
            return &quot;true&quot;;
        };
       if (!v) {
            return &quot;false&quot;;
        };
        throw new Error(&quot;Failed pattern match at ...&quot;);
    }
};
</code></pre>
<p>生成される名前が気に入らなければ、型クラスインスタンスに名前を与えられます。
例えば次のようにします。</p>
<pre><code class="language-haskell">instance myShowBoolean :: Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<pre><code class="language-javascript">var myShowBoolean = {
    show: function (v) {
        if (v) {
            return &quot;true&quot;;
        };
       if (!v) {
            return &quot;false&quot;;
        };
        throw new Error(&quot;Failed pattern match at ...&quot;);
    }
};
</code></pre>
</blockquote>
<p>PSCiでいろいろな型の値を<code>Show</code>型クラスを使って表示してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; show true
&quot;true&quot;

&gt; show 1.0
&quot;1.0&quot;

&gt; show &quot;Hello World&quot;
&quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>この例では様々な原始型の値を <code>show</code>しましたが、もっと複雑な型を持つ値も<code>show</code>できます。</p>
<pre><code class="language-text">&gt; import Data.Tuple

&gt; show (Tuple 1 true)
&quot;(Tuple 1 true)&quot;

&gt; import Data.Maybe

&gt; show (Just &quot;testing&quot;)
&quot;(Just \&quot;testing\&quot;)&quot;
</code></pre>
<p><code>show</code>の出力は、REPLに（あるいは<code>.purs</code>ファイルに）貼り戻せば、表示されたものを再作成できるような文字列であるべきです。
以下では<code>logShow</code>を使っていますが、これは単に<code>show</code>と<code>log</code>を順に呼び出すものであり、引用符なしに文字列が表示されます。
<code>unit</code>の表示は無視してください。
第8章で<code>log</code>のような<code>Effect</code>を調べるときに押さえます。</p>
<pre><code class="language-text">&gt; import Effect.Console

&gt; logShow (Tuple 1 true)
(Tuple 1 true)
unit

&gt; logShow (Just &quot;testing&quot;)
(Just &quot;testing&quot;)
unit
</code></pre>
<p>型 <code>Data.Either</code>の値を表示しようとすると、興味深いエラー文言が表示されます。</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; show (Left 10)

The inferred type

    forall a. Show a =&gt; String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでの問題は <code>show</code>しようとしている型に対する
<code>Show</code>インスタンスが存在しないということではなく、PSCiがこの型を推論できなかったということです。
これは推論された型で<em>未知の型</em><code>a</code>とされていることが示しています。</p>
<p><code>::</code>演算子を使って式に註釈を付けてPSCiが正しい型クラスインスタンスを選べるようにできます。</p>
<pre><code class="language-text">&gt; show (Left 10 :: Either Int String)
&quot;(Left 10)&quot;
</code></pre>
<p><code>Show</code>インスタンスを全く持っていない型もあります。
関数の型 <code>-&gt;</code>がその一例です。
<code>Int</code>から <code>Int</code>への関数を <code>show</code>しようとすると、型検証器によってその旨のエラー文言が表示されます。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; show $ \n -&gt; n + 1

No type class instance was found for

  Data.Show.Show (Int -&gt; Int)
</code></pre>
<p>型クラスインスタンスは次の2つのうち何れかの形で定義されます。
型クラスが定義されている同じモジュールで定義するか、型クラスに「属して」いる型と同じモジュールで定義するかです。
これらとは別の場所で定義されるインスタンスは<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">「孤立インスタンス」</a>と呼ばれ、PureScriptコンパイラでは許されていません。
この章の演習の幾つかでは、その型の型クラスインスタンスを定義できるように、型の定義を自分の<code>MySolutions</code>モジュールに複製する必要があります。</p>
<h2 id="演習-13"><a class="header" href="#演習-13">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Show</code>インスタンスを<code>Point</code>に定義してください。
前の章の<code>showPoint</code>関数と同じ出力に一致するようにしてください。
<em>補足</em>：<code>Point</code>はここでは（<code>type</code>同義語ではなく）<code>newtype</code>です。
そのため<code>show</code>の仕方を変えられます。
こうでもしないとレコードへの既定の<code>Show</code>インスタンスから逃れられません。</p>
<pre><code class="language-haskell">newtype Point
  = Point
  { x :: Number
  , y :: Number
  }
</code></pre>
</li>
</ol>
<h2 id="よく見かける型クラス"><a class="header" href="#よく見かける型クラス">よく見かける型クラス</a></h2>
<p>この節では、Preludeや標準ライブラリで定義されている標準的な型クラスを幾つか見ていきましょう。
これらの型クラスはPureScript特有の抽象化をする上で多くのよくあるパターンの基礎を形成しています。
そのため、これらの関数の基本についてよく理解しておくことを強くお勧めします。</p>
<h3 id="eq"><a class="header" href="#eq">Eq</a></h3>
<p><code>Eq</code>型クラスは<code>eq</code>関数を定義しています。
この関数は2つの値について等値性を調べます。
実は<code>==</code>演算子は<code>eq</code>の別名です。</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>何れにせよ、2つの引数は同じ型を持つ必要があります。
異なる型の2つの値を等値性に関して比較しても意味がありません。</p>
<p>PSCiで <code>Eq</code>型クラスを試してみましょう。</p>
<pre><code class="language-text">&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true
</code></pre>
<h3 id="ord"><a class="header" href="#ord">Ord</a></h3>
<p><code>Ord</code>型クラスは<code>compare</code>関数を定義します。
この関数は2つの値を比較するのに使えるもので、その値の型は順序付けに対応したものです。
比較演算子<code>&lt;</code>、<code>&gt;</code>と厳密な大小比較ではない<code>&lt;=</code>、<code>&gt;=</code>は<code>compare</code>を用いて定義されます。</p>
<p><em>補足</em>：
以下の例ではクラスシグネチャに<code>&lt;=</code>が含まれています。
この文脈での<code>&lt;=</code>の使われ方は、<code>Eq</code>が<code>Ord</code>の上位クラスであり、比較演算子としての<code>&lt;=</code>の用途を表す意図はありません。
後述の<a href="chapter6.html#%E4%B8%8A%E4%BD%8D%E3%82%AF%E3%83%A9%E3%82%B9">上位クラス</a>の節を参照してください。</p>
<pre><code class="language-haskell">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p><code>compare</code>関数は2つの値を比較して<code>Ordering</code>を返します。
これには3つ選択肢があります。</p>
<ul>
<li><code>LT</code>- 最初の引数が2番目の値より小さいとき。</li>
<li><code>EQ</code>- 最初の引数が2番目の値と等しいとき。</li>
<li><code>GT</code>- 最初の引数が2番目の値より大きいとき。</li>
</ul>
<p>ここでも<code>compare</code>関数についてPSCiで試してみましょう。</p>
<pre><code class="language-text">&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<p><code>Field</code>型クラスは加算、減算、乗算、除算などの数値演算子に対応した型を示します。
これらの演算子を抽象化して提供されているので、適切な場合に再利用できるのです。</p>
<blockquote>
<p><em>補足</em>：型クラス<code>Eq</code>ないし<code>Ord</code>とちょうど同じように、<code>Field</code>型クラスはPureScriptコンパイラで特別に扱われ、<code>1 + 2 * 3</code>のような単純な式は単純なJavaScriptへと変換されます。
型クラスの実装に基いて呼び出される関数呼び出しとは対照的です。</p>
</blockquote>
<pre><code class="language-haskell">class EuclideanRing a &lt;= Field a
</code></pre>
<p><code>Field</code>型クラスは、幾つかのより抽象的な<em>上位クラス</em>が組み合わさってできています。
このため、<code>Field</code>の操作の全てを提供しているわけではないが、その一部を提供する型について抽象的に説明できます。
例えば、自然数の型は加算及び乗算については閉じていますが、減算については必ずしも閉じていません。
そのため、この型は<code>Semiring</code>クラス（これは<code>Num</code>の上位クラスです）のインスタンスですが、<code>Ring</code>や<code>Field</code>のインスタンスではありません。</p>
<p>上位クラスについては、この章の後半で詳しく説明します。
しかし、全ての<a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">数値型クラスの階層</a>（<a href="https://harry.garrood.me/numeric-hierarchy-overview/">チートシート</a>）について述べるのはこの章の目的から外れています。
この内容に興味のある読者は<code>prelude</code>内の <code>Field</code>に関するドキュメントを参照してください。</p>
<h3 id="半群とモノイド"><a class="header" href="#半群とモノイド">半群とモノイド</a></h3>
<p><code>Semigroup</code>（半群）型クラスは、2つの値を連結する演算子 <code>append</code>を提供する型を示します。</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a
</code></pre>
<p>文字列は普通の文字列連結について半群をなし、配列も同様です。
その他の標準的なインスタンスは<code>prelude</code>パッケージで提供されています。</p>
<p>以前に見た <code>&lt;&gt;</code>連結演算子は、 <code>append</code>の別名として提供されています。</p>
<p>（<code>prelude</code>パッケージで提供されている）<code>Monoid</code>型クラスには<code>mempty</code>という名前の空の値の概念があり、<code>Semigroup</code>型クラスを拡張します。</p>
<pre><code class="language-haskell">class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>ここでも文字列や配列はモノイドの簡単な例になっています。</p>
<p>ある型にとっての<code>Monoid</code>型クラスインスタンスとは、「空」の値から始めて新たな結果に組み合わせ、その型を持つ結果を<em>累算</em>する方法を記述するものです。
例えば、畳み込みを使って何らかのモノイドの値の配列を連結する関数を書けます。
PSCiで以下の通りです。</p>
<pre><code class="language-haskell">&gt; import Prelude
&gt; import Data.Monoid
&gt; import Data.Foldable

&gt; foldl append mempty [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&quot;Hello World&quot;

&gt; foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
</code></pre>
<p><code>prelude</code>パッケージにはモノイドと半群の多くの例を提供しており、以降もこれらを本書で扱っていきます。</p>
<h3 id="foldable"><a class="header" href="#foldable">Foldable</a></h3>
<p><code>Monoid</code>型クラスが畳み込みの結果になるような型を示す一方、<code>Foldable</code>型クラスは畳み込みの元のデータとして使えるような型構築子を示しています。</p>
<p>また、 <code>Foldable</code>型クラスは配列や
<code>Maybe</code>などの幾つかの標準的なコンテナのインスタンスを含む<code>foldable-traversable</code>パッケージで提供されています。</p>
<p><code>Foldable</code>クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し複雑です。</p>
<pre><code class="language-haskell">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p><code>f</code>を配列の型構築子として特殊化すると分かりやすいです。
この場合、任意の<code>a</code>について<code>f a</code>を<code>Array a</code>に置き換えられますが、そうすると<code>foldl</code>と<code>foldr</code>の型が、最初に配列に対する畳み込みで見た型になると気付きます。</p>
<p><code>foldMap</code>についてはどうでしょうか。
これは <code>forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Array a -&gt; m</code>になります。
この型シグネチャでは、型<code>m</code>が<code>Monoid</code>型クラスのインスタンスであれば、返り値の型として任意に選べると書かれています。
配列の要素をそのモノイドの値へと変える関数を与えられれば、そのモノイドの構造を利用して配列上で累算し、1つの値にして返せます。</p>
<p>それではPSCiで <code>foldMap</code>を試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;
</code></pre>
<p>ここでは文字列用のモノイドと<code>show</code>関数を選んでいます。
前者は文字列を連結するもので、後者は<code>Int</code>を文字列として書き出すものです。
そうして数の配列を渡すと、それぞれの数を<code>show</code>して1つの文字列へと連結した結果を得ました。</p>
<p>しかし畳み込み可能な型は配列だけではありません。
<code>foldable-traversable</code>では<code>Maybe</code>や<code>Tuple</code>のような型にも<code>Foldable</code>インスタンスが定義されており、<code>lists</code>のような他のライブラリでは、各々のデータ型に対して<code>Foldable</code>インスタンスが定義されています。
<code>Foldable</code>は<em>順序付きコンテナ</em>の概念を見据えたものなのです。</p>
<h3 id="関手と型クラス則"><a class="header" href="#関手と型クラス則">関手と型クラス則</a></h3>
<p>PureScriptでは、副作用を伴う関数型プログラミングのスタイルを可能にするための型クラスの集まりも定義されています。
<code>Functor</code>や<code>Applicative</code>、<code>Monad</code>といったものです。
これらの抽象化については後ほど本書で扱いますが、ここでは<code>Functor</code>型クラスの定義を見てみましょう。
既に<code>map</code>関数の形で見たものです。</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>map</code>関数（別名<code>&lt;$&gt;</code>）は関数をそのデータ構造まで「持ち上げる」(lift) ことができます。
ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、既に幾つかの単純な型についてその動作を見てきました。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; map (\n -&gt; n &lt; 3) [1, 2, 3, 4, 5]
[true, true, false, false, false]

&gt; import Data.Maybe
&gt; import Data.String (length)

&gt; map length (Just &quot;testing&quot;)
(Just 7)
</code></pre>
<p><code>map</code>演算子は様々な構造の上でそれぞれ異なる挙動をしますが、 <code>map</code>演算子の意味はどのように理解すればいいのでしょうか。</p>
<p>直感的には、 <code>map</code>演算子はコンテナのそれぞれの要素へ関数を適用し、その結果から元のデータと同じ形状を持った新しいコンテナを構築するものとできます。
しかし、この着想を精密にするにはどうしたらいいでしょうか。</p>
<p><code>Functor</code>の型クラスのインスタンスは、<em>関手則</em>と呼ばれる法則を順守するものと期待されています。</p>
<ul>
<li><code>map identity xs = xs</code></li>
<li><code>map g (map f xs) = map (g &lt;&lt;&lt; f) xs</code></li>
</ul>
<p>最初の法則は <em>恒等射律</em> (identity law)
です。これは、恒等関数（引数を変えずに返す関数）をその構造まで持ち上げると、元の構造をそのまま返すという意味です。恒等関数は入力を変更しませんから、これは理にかなっています。</p>
<p>第2の法則は<em>合成律</em>です。
構造を1つの関数で写してから2つめの関数で写すのは、2つの関数の合成で構造を写すのと同じだ、と言っています。</p>
<p>「持ち上げ」の一般的な意味が何であれ、データ構造に対する持ち上げ関数の正しい定義はこれらの法則に従っていなければなりません。</p>
<p>標準の型クラスの多くには、このような法則が付随しています。
一般に、型クラスに与えられた法則は、型クラスの関数に構造を与え、普遍的にインスタンスについて調べられるようにします。
興味のある読者は、既に見てきた標準の型クラスに属する法則について調べてみてもよいでしょう。</p>
<h3 id="インスタンスの導出"><a class="header" href="#インスタンスの導出">インスタンスの導出</a></h3>
<p>インスタンスを手作業で描く代わりに、ほとんどの作業をコンパイラにさせることができます。
この<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出手引き</a>を見てください。
そちらの情報が以下の演習を解く手助けになることでしょう。</p>
<h2 id="演習-14"><a class="header" href="#演習-14">演習</a></h2>
<p>（簡単）次のnewtypeは複素数を表します。</p>
<pre><code class="language-haskell">newtype Complex
  = Complex
  { real :: Number
  , imaginary :: Number
  }
</code></pre>
<ol>
<li>
<p>（簡単）<code>Complex</code>に<code>Show</code>インスタンスを定義してください。
出力の形式はテストで期待される形式と一致させてください（例：<code>1.2+3.4i</code>、<code>5.6-7.7i</code>など）。</p>
</li>
<li>
<p>（簡単）<code>Eq</code>インスタンスを<code>Complex</code>に導出してください。
<em>補足</em>：代わりにこのインスタンスを手作業で書いてもよいですが、しなくていいのになぜすることがありましょう。</p>
</li>
<li>
<p>（普通）<code>Semiring</code>インタンスを<code>Complex</code>に定義してください。
<em>補足</em>：<a href="https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype"><code>Data.Newtype</code></a>の<code>wrap</code>と<code>over2</code>を使ってより簡潔な解答を作れます。
もしそうするのでしたら、<code>Data.Newtype</code>から<code>class Newtype</code>をインポートしたり、<code>Newtype</code>インスタンスを<code>Complex</code>に導出したりする必要も出てくるでしょう。</p>
</li>
<li>
<p>（簡単）（<code>newtype</code>を介して）<code>Ring</code>インスタンスを<code>Complex</code>に導出してください。
<em>補足</em>：代わりにこのインスタンスを手作業で書くこともできますが、そう手軽にはできません。</p>
<p>以下は前章からの<code>Shape</code>のADTです。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String
</code></pre>
</li>
<li>
<p>（普通）（<code>Generic</code>を介して）<code>Show</code>インスタンスを<code>Shape</code>に導出してください。
コードの量はどのくらいになりましたか。
また、前の章の<code>showShape</code>と比較して<code>String</code>の出力はどうなりましたか。
<em>手掛かり</em>：<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出</a>手引きの<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic"><code>Generic</code>から導出する</a>節を見てください。</p>
</li>
</ol>
<h2 id="型クラス制約"><a class="header" href="#型クラス制約">型クラス制約</a></h2>
<p>型クラスを使うと、関数の型に制約を加えられます。
例を示しましょう。
<code>Eq</code>型クラスインスタンスを使って定義された等値性を使って、3つの値が等しいかどうかを調べる関数を書きたいとします。</p>
<pre><code class="language-haskell">threeAreEqual :: forall a. Eq a =&gt; a -&gt; a -&gt; a -&gt; Boolean
threeAreEqual a1 a2 a3 = a1 == a2 &amp;&amp; a2 == a3
</code></pre>
<p>この型宣言は <code>forall</code>を使って定義された通常の多相型のようにも見えます。
しかし、二重線矢印 <code>=&gt;</code>で型の残りの部分から区切られた、型クラス制約 (type class constraint) <code>Eq a</code>があります。</p>
<p>インポートされたモジュールのどれかに <code>a</code>に対する <code>Eq</code>インスタンスが存在するなら、どんな型 <code>a</code>を選んでも
<code>threeAsEqual</code>を呼び出すことができる、とこの型は言っています。</p>
<p>制約された型には複数の型クラスインスタンスを含めることができますし、インスタンスの型は単純な型変数に限定されません。 <code>Ord</code>と
<code>Show</code>のインスタンスを使って2つの値を比較する例を次に示します。</p>
<pre><code class="language-haskell">showCompare :: forall a. Ord a =&gt; Show a =&gt; a -&gt; a -&gt; String
showCompare a1 a2 | a1 &lt; a2 =
  show a1 &lt;&gt; &quot; is less than &quot; &lt;&gt; show a2
showCompare a1 a2 | a1 &gt; a2 =
  show a1 &lt;&gt; &quot; is greater than &quot; &lt;&gt; show a2
showCompare a1 a2 =
  show a1 &lt;&gt; &quot; is equal to &quot; &lt;&gt; show a2
</code></pre>
<p><code>=&gt;</code>シンボルを複数回使って複数の制約を指定できることに注意してください。
複数の引数のカリー化された関数を定義するのと同様です。
しかし、2つの記号を混同しないように注意してください。</p>
<ul>
<li><code>a -&gt; b</code>は <em>型</em> <code>a</code>から <em>型</em> <code>b</code>への関数の型を表します。</li>
<li>一方で、<code>a =&gt; b</code>は <em>制約</em> <code>a</code>を型<code>b</code>に適用します。</li>
</ul>
<p>PureScriptコンパイラは、型の注釈が提供されていない場合、制約付きの型を推論しようとします。これは、関数に対してできる限り最も一般的な型を使用したい場合に便利です。</p>
<p>PSCiで <code>Semiring</code>のような標準の型クラスの何れかを使って、このことを試してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; :type \x -&gt; x + x
forall (a :: Type). Semiring a =&gt; a -&gt; a
</code></pre>
<p>ここで、この関数に<code>Int -&gt; Int</code>または<code>Number -&gt; Number</code>と註釈を付けることはできます。
しかし、PSCiでは最も一般的な型が<code>Semiring</code>で動作することが示されています。
こうすると<code>Int</code>と<code>Number</code>の両方で関数を使えます。</p>
<h2 id="インスタンスの依存関係"><a class="header" href="#インスタンスの依存関係">インスタンスの依存関係</a></h2>
<p>制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、型クラスインスタンスの実装は他の型クラスインスタンスに依存できます。これにより、型を使ってプログラムの実装を推論するという、プログラム推論の強力な形式を提供します。</p>
<p><code>Show</code>型クラスを例に考えてみましょう。
それぞれの要素を <code>show</code>する方法がある限り、その要素の配列を <code>show</code>する型クラスインスタンスを書くことができます。</p>
<pre><code class="language-haskell">instance Show a =&gt; Show (Array a) where
  ...
</code></pre>
<p>型クラスインスタンスが複数の他のインスタンスに依存する場合、括弧で囲んでそれらのインスタンスをコンマで区切り、それを<code>=&gt;</code>シンボルの左側に置くことになります。</p>
<pre><code class="language-haskell">instance (Show a, Show b) =&gt; Show (Either a b) where
  ...
</code></pre>
<p>これらの2つの型クラスインスタンスは <code>prelude</code>ライブラリにあります。</p>
<p>プログラムがコンパイルされると、<code>Show</code>の正しい型クラスのインスタンスは <code>show</code>の引数の推論された型に基づいて選ばれます。
選択されたインスタンスが沢山のそうしたインスタンスの関係に依存しているかもしれませんが、このあたりの複雑さに開発者が関与することはありません。</p>
<h2 id="演習-15"><a class="header" href="#演習-15">演習</a></h2>
<ol>
<li>
<p>（簡単）以下の宣言では型 <code>a</code>の要素の空でない配列の型を定義しています。</p>
<pre><code class="language-haskell">data NonEmpty a = NonEmpty a (Array a)
</code></pre>
<p><code>Eq a</code>と<code>Eq (Array a)</code>のインスタンスを再利用し、型<code>NonEmpty</code>に<code>Eq</code>インスタンスを書いてください。
<em>補足</em>：代わりに<code>Eq</code>インスタンスを導出できます。</p>
</li>
<li>
<p>（普通）<code>Array</code>の<code>Semigroup</code>インスタンスを再利用して、<code>NonEmpty</code>への<code>Semigroup</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>NonEmpty</code>に<code>Functor</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>Ord</code>のインスタンス付きの任意の型<code>a</code>が与えられているとすると、新しくそれ以外のどんな値よりも大きい「無限の」値を付け加えられます。</p>
<pre><code class="language-haskell">data Extended a = Infinite | Finite a 
</code></pre>
<p><code>a</code>への<code>Ord</code>インスタンスを再利用して、<code>Extended a</code>に<code>Ord</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（難しい）<code>NonEmpty</code>に<code>Foldable</code>インスタンスを書いてください。
<em>手掛かり</em>：配列への<code>Foldable</code>インスタンスを再利用してください。</p>
</li>
<li>
<p>（難しい）順序付きコンテナを定義する（そして <code>Foldable</code>のインスタンスを持っている）ような型構築子
<code>f</code>が与えられたとき、追加の要素を先頭に含める新たなコンテナ型を作れます。</p>
<pre><code class="language-haskell">data OneMore f a = OneMore a (f a)
</code></pre>
<p>このコンテナ <code>OneMore f</code>もまた順序を持っています。
ここで、新しい要素は任意の <code>f</code>の要素よりも前にきます。
この <code>OneMore f</code>の <code>Foldable</code>インスタンスを書いてみましょう。</p>
<pre><code class="language-haskell">instance Foldable f =&gt; Foldable (OneMore f) where
  ...
</code></pre>
</li>
<li>
<p>（普通）<code>nubEq</code>関数を使い、配列から重複する<code>Shape</code>を削除する<code>dedupShapes :: Array Shape -&gt; Array Shape</code>関数を書いてください。</p>
</li>
<li>
<p>（普通）<code>dedupShapesFast</code>関数を書いてください。
<code>dedupShapes</code>とほぼ同じですが、より効率の良い<code>nub</code>関数を使います。</p>
</li>
</ol>
<h2 id="多変数型クラス"><a class="header" href="#多変数型クラス">多変数型クラス</a></h2>
<p>型クラスが引数として1つの型だけを取れるのかというと、そうではありません。
その場合がほとんどですが、型クラスは<em>ゼロ個以上の</em>型変数を持てます。</p>
<p>それでは2つの型引数を持つ型クラスの例を見てみましょう。</p>
<pre><code class="language-haskell">module Stream where

import Data.Array as Array
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String

class Stream stream element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }

instance Stream (Array a) a where
  uncons = Array.uncons

instance Stream String Char where
  uncons = String.uncons
</code></pre>
<p>この <code>Stream</code>モジュールでは、要素のストリームのような型を示すクラス <code>Stream</code>が定義されています。
<code>uncons</code>関数を使ってストリームの先頭から要素を取り出すことができます。</p>
<p><code>Stream</code>型クラスは、ストリーム自身の型だけでなくその要素の型も型変数として持っていることに注意してください。これによって、ストリームの型が同じでも要素の型について異なる型クラスインスタンスを定義できます。</p>
<p>このモジュールでは2つの型クラスインスタンスが定義されています。
<code>uncons</code>がパターン照合で配列の先頭の要素を取り除くような配列のインスタンスと、文字列から最初の文字を取り除くような文字列のインスタンスです。</p>
<p>任意のストリーム上で動作する関数を記述できます。
例えば、ストリームの要素に基づいて <code>Monoid</code>に結果を累算する関数は次のようになります。</p>
<pre><code class="language-haskell">import Prelude
import Data.Monoid (class Monoid, mempty)

foldStream :: forall l e m. Stream l e =&gt; Monoid m =&gt; (e -&gt; m) -&gt; l -&gt; m
foldStream f list =
  case uncons list of
    Nothing -&gt; mempty
    Just cons -&gt; f cons.head &lt;&gt; foldStream f cons.tail
</code></pre>
<p>PSCiで使って、異なる <code>Stream</code>の型や異なる <code>Monoid</code>の型について <code>foldStream</code>を呼び出してみましょう。</p>
<h2 id="関数従属性"><a class="header" href="#関数従属性">関数従属性</a></h2>
<p>多変数型クラスは非常に便利ですが、紛らわしい型や型推論の問題にも繋がります。
単純な例として、上記で与えられた<code>Stream</code>クラスを使い、ストリームに対して汎用的な<code>tail</code>関数を書くことを考えてみましょう。</p>
<pre><code class="language-haskell">genericTail xs = map _.tail (uncons xs)
</code></pre>
<p>これはやや複雑なエラー文言を出力します。</p>
<pre><code class="language-text">The inferred type

  forall stream a. Stream stream a =&gt; stream -&gt; Maybe stream

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>エラーは、 <code>genericTail</code>関数が <code>Stream</code>型クラスの定義で言及された
<code>element</code>型を使用しないので、その型は未解決のままであることを指しています。</p>
<p>更に残念なことに、特定の型のストリームに<code>genericTail</code>を適用できません。</p>
<pre><code class="language-text">&gt; map _.tail (uncons &quot;testing&quot;)

The inferred type

  forall a. Stream String a =&gt; Maybe String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでは、コンパイラが <code>streamString</code>インスタンスを選択することを期待しています。
結局のところ、 <code>String</code>は <code>Char</code>のストリームであり、他の型のストリームであってはなりません。</p>
<p>コンパイラは自動的にそう推論できず、<code>streamString</code>インスタンスに目が向きません。
しかし、型クラス定義に手掛かりを追加すると、コンパイラを補助できます。</p>
<pre><code class="language-haskell">class Stream stream element | stream -&gt; element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }
</code></pre>
<p>ここで、 <code>stream -&gt; element</code>は <em>関数従属性</em> (functional dependency) と呼ばれます。関数従属性は、多変数型クラスの型引数間の関数関係を宣言します。この関数の依存関係は、ストリーム型から（一意の）要素型への関数があることをコンパイラに伝えるので、コンパイラがストリーム型を知っていれば要素の型を割り当てられます。</p>
<p>この手掛かりがあれば、コンパイラが上記の汎用的な尾鰭関数の正しい型を推論するのに充分です。</p>
<pre><code class="language-text">&gt; :type genericTail
forall (stream :: Type) (element :: Type). Stream stream element =&gt; stream -&gt; Maybe stream

&gt; genericTail &quot;testing&quot;
(Just &quot;esting&quot;)
</code></pre>
<p>多変数の型クラスを使用して何らかのAPIを設計する場合、関数従属性が便利なことがあります。</p>
<h2 id="型変数のない型クラス"><a class="header" href="#型変数のない型クラス">型変数のない型クラス</a></h2>
<p>ゼロ個の型変数を持つ型クラスさえも定義できます。
これらは関数に対するコンパイル時の表明に対応しており、型システム内においてそのコードの大域的な性質を把握できます。</p>
<p>重要な一例として、前に部分関数についてお話しした際に見た<code>Partial</code>クラスがあります。
<code>Data.Array.Partial</code>に定義されている関数<code>head</code>と<code>tail</code>を例に取りましょう。
この関数は配列の先頭と尾鰭を<code>Maybe</code>に包むことなく取得できます。
そのため配列が空のときに失敗する可能性があります。</p>
<pre><code class="language-haskell">head :: forall a. Partial =&gt; Array a -&gt; a

tail :: forall a. Partial =&gt; Array a -&gt; Array a
</code></pre>
<p><code>Partial</code>モジュールの <code>Partial</code>型クラスのインスタンスを定義していないことに注意してください。
こうすると目的を達成できます。
このままの定義では <code>head</code>関数を使用しようとすると型エラーになるのです。</p>
<pre><code class="language-text">&gt; head [1, 2, 3]

No type class instance was found for

  Prim.Partial
</code></pre>
<p>代わりに、これらの部分関数を利用する全ての関数で <code>Partial</code>制約を再発行できます。</p>
<pre><code class="language-haskell">secondElement :: forall a. Partial =&gt; Array a -&gt; a
secondElement xs = head (tail xs)
</code></pre>
<p>前章で見た<code>unsafePartial</code>関数を使用し、部分関数を通常の関数として（不用心に）扱うことができます。この関数は
<code>Partial.Unsafe</code>モジュールで定義されています。</p>
<pre><code class="language-haskell">unsafePartial :: forall a. (Partial =&gt; a) -&gt; a
</code></pre>
<p><code>Partial</code>制約は関数の矢印の左側の括弧の中に現れますが、外側の <code>forall</code>では現れません。
つまり、 <code>unsafePartial</code>は部分的な値から通常の値への関数です。</p>
<pre><code class="language-text">&gt; unsafePartial head [1, 2, 3]
1

&gt; unsafePartial secondElement [1, 2, 3]
2
</code></pre>
<h2 id="上位クラス"><a class="header" href="#上位クラス">上位クラス</a></h2>
<p>インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス間の関係を表現できるように、いわゆる<em>上位クラス</em>を使って型クラス間の関係を表現できます。</p>
<p>あるクラスのどんなインスタンスも、別のクラスのインスタンスである必要があるとき、後者の型クラスは前者の型クラスの上位クラスであるといいます。
そしてクラス定義で逆向きの太い矢印 (<code>&lt;=</code>) を使って上位クラス関係を示します。</p>
<p><a href="chapter6.html#ord">既に上位クラスの関係の例を目にしました</a>。
<code>Eq</code>クラスは<code>Ord</code>の上位クラスですし、<code>Semigroup</code>クラスは<code>Monoid</code>の上位クラスです。
<code>Ord</code>クラスの全ての型クラスインスタンスについて、その同じ型に対応する <code>Eq</code>インスタンスが存在しなければなりません。
これは理に適っています。
多くの場合、<code>compare</code>関数が2つの値の大小を付けられないと報告した時は、同値であるかを判定するために<code>Eq</code>クラスを使うことでしょう。</p>
<p>一般に、下位クラスの法則が上位クラスの構成要素に言及しているとき、上位クラス関係を定義するのは筋が通っています。
例えば、任意の<code>Ord</code>と<code>Eq</code>のインスタンスの対について、もし2つの値が<code>Eq</code>インスタンスの下で同値であるなら、<code>compare</code>関数は<code>EQ</code>を返すはずだと推定するのは理に適っています。
言い換えれば、<code>a == b</code>が真であるのは<code>compare a b</code>が厳密に<code>EQ</code>に評価されるときなのです。
法則のレベルでのこの関係は、<code>Eq</code>と<code>Ord</code>の間の上位クラス関係の正当性を示します。</p>
<p>上位クラス関係を定義する別の理由となるのは、この2つのクラスの間に明白な &quot;is-a&quot; の関係があることです。
下位クラスの全ての構成要素は、上位クラスの構成要素でもあるということです。</p>
<h2 id="演習-16"><a class="header" href="#演習-16">演習</a></h2>
<ol>
<li>
<p>（普通）部分関数<code>unsafeMaximum :: Partial =&gt; Array Int -&gt; Int</code>を定義してください。
この関数は空でない整数の配列の最大値を求めます。
<code>unsafePartial</code>を使ってPSCiで関数を試してください。
<em>手掛かり</em>：<code>Data.Foldable</code>の<code>maximum</code>関数を使います。</p>
</li>
<li>
<p>（普通）次の <code>Action</code>クラスは、ある型の別の型での動作を定義する、多変数型クラスです。</p>
<pre><code class="language-haskell">class Monoid m &lt;= Action m a where
  act :: m -&gt; a -&gt; a
</code></pre>
<p><em>動作</em>とは、他の型の値を変更する方法を決めるために使われるモノイドな値を記述する関数です。
<code>Action</code>型クラスには2つの法則があります。</p>
<ul>
<li><code>act mempty a = a</code></li>
<li><code>act (m1 &lt;&gt; m2) a = act m1 (act m2 a)</code></li>
</ul>
<p>空の動作を提供しても何も起こりません。
そして2つの動作を連続で適用することは結合した動作を適用することと同じです。
つまり、動作は<code>Monoid</code>クラスで定義される操作に倣っています。</p>
<p>例えば自然数は乗算のもとでモノイドを形成します。</p>
<pre><code class="language-haskell">newtype Multiply = Multiply Int

instance Semigroup Multiply where
  append (Multiply n) (Multiply m) = Multiply (n * m)

instance Monoid Multiply where
  mempty = Multiply 1
</code></pre>
<p>この動作を実装するインスタンスを書いてください。</p>
<pre><code class="language-haskell">instance Action Multiply Int where
  ...
</code></pre>
<p>インスタンスが上で挙げた法則を見たさなくてはならないことを思い出してください。</p>
</li>
<li>
<p>（難しい）<code>Action Multiply Int</code>のインスタンスを実装するには複数の方法があります。
どれだけ思い付きますか。
PureScriptは同じインスタンスの複数の実装を許さないため、元の実装を置き換える必要があるでしょう。
<em>補足</em>：テストでは4つの実装を押さえています。</p>
</li>
<li>
<p>（普通）入力の文字列を何回か繰り返す<code>Action</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">instance Action Multiply String where
  ...
</code></pre>
<p><em>手掛かり</em>：Pursuitでシグネチャが<a href="https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String"><code>String -&gt; Int -&gt; String</code></a>の補助関数を検索してください。
なお、<code>String</code>は（<code>Monoid</code>のような）より汎用的な型として現れます。</p>
<p>このインスタンスは上に挙げた法則を満たすでしょうか。</p>
</li>
<li>
<p>（普通）インスタンス <code>Action m a =&gt; Action m (Array a)</code>を書いてみましょう。
ここで、 配列上の動作はそれぞれの要素を独立に実行するものとして定義されます。</p>
</li>
<li>
<p>（難しい）以下のnewtypeが与えらえているとき、<code>Action m (Self m)</code>のインスタンスを書いてください。
ここでモノイド<code>m</code>はそれ自体が持つ<code>append</code>を用いて動作します。</p>
<pre><code class="language-haskell">newtype Self m = Self m
</code></pre>
<p><em>補足</em>：テストフレームワークでは<code>Self</code>と<code>Multiply</code>型に<code>Show</code>と<code>Eq</code>インスタンスが必要になります。
手作業でこれらのインスタンスを書いてもよいですし、<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype"><code>derive newtype instance</code></a>と書くだけでコンパイラに取り仕切ってもらうこともできます。</p>
</li>
<li>
<p>（難しい）多変数型のクラス <code>Action</code>の引数は、何らかの関数従属性によって関連づけられるべきですか。
なぜそうすべき、あるいはそうすべきでないでしょうか。
<em>補足</em>：この演習にはテストがありません。</p>
</li>
</ol>
<h2 id="ハッシュの型クラス"><a class="header" href="#ハッシュの型クラス">ハッシュの型クラス</a></h2>
<p>この最後の節では、章の残りを使ってデータ構造をハッシュ化するライブラリを作ります。</p>
<blockquote>
<p>なお、このライブラリは説明だけを目的としており、堅牢なハッシュ化の仕組みの提供は意図していません。</p>
</blockquote>
<p>ハッシュ関数に期待される性質とはどのようなものでしょうか。</p>
<ul>
<li>ハッシュ関数は決定的でなくてはなりません。
つまり、同じ値は同じハッシュコードに写さなければなりません。</li>
<li>ハッシュ関数はいろいろなハッシュ値の集合で結果が一様に分布しなければなりません。</li>
</ul>
<p>最初の性質はちゃんとした型クラスの法則のように見えます。
その一方で、2番目の性質はよりくだけた規約の条項のようなもので、PureScriptの型システムによって確実に強制できるようなものではなさそうです。
しかし、これは型クラスから次のような直感が得られるでしょう。</p>
<pre><code class="language-haskell">newtype HashCode = HashCode Int

instance Eq HashCode where
  eq (HashCode a) (HashCode b) = a == b

hashCode :: Int -&gt; HashCode
hashCode h = HashCode (h `mod` 65535)

class Eq a &lt;= Hashable a where
  hash :: a -&gt; HashCode
</code></pre>
<p>これに、 <code>a == b</code>ならば <code>hash a == hash b</code>を示唆するという関係性の法則が付随しています。</p>
<p>この節の残りの部分を費やして、<code>Hashable</code>型クラスに関連付けられているインスタンスと関数のライブラリを構築していきます。</p>
<p>決定的な方法でハッシュ値を結合する方法が必要になります。</p>
<pre><code class="language-haskell">combineHashes :: HashCode -&gt; HashCode -&gt; HashCode
combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)
</code></pre>
<p><code>combineHashes</code>関数は2つのハッシュ値を混ぜて結果を0-65535の間に分布します。</p>
<p>それでは、<code>Hashable</code>制約を使って入力の種類を制限する関数を書いてみましょう。
ハッシュ関数を必要とするよくある目的としては、2つの値が同じハッシュコードにハッシュ化されるかどうかを判定することです。
<code>hashEqual</code>関係はそのような機能を提供します。</p>
<pre><code class="language-haskell">hashEqual :: forall a. Hashable a =&gt; a -&gt; a -&gt; Boolean
hashEqual = eq `on` hash
</code></pre>
<p>この関数はハッシュコードの等値性を利用したハッシュ同値性を定義するために<code>Data.Function</code>の
<code>on</code>関数を使っていますが、これはハッシュ同値性の宣言的な定義として読めるはずです。
つまり、それぞれの値が <code>hash</code>関数に渡されたあとで2つの値が等しいなら、それらの値は「ハッシュ同値」です。</p>
<p>原始型の <code>Hashable</code>インスタンスを幾つか書いてみましょう。
まずは整数のインスタンスです。
<code>HashCode</code>は実際には単なる梱包された整数なので、単純です。
<code>hashCode</code>補助関数を使えます。</p>
<pre><code class="language-haskell">instance Hashable Int where
  hash = hashCode
</code></pre>
<p>パターン照合を使うと、<code>Boolean</code>値の単純なインスタンスも定義できます。</p>
<pre><code class="language-haskell">instance Hashable Boolean where
  hash false = hashCode 0
  hash true  = hashCode 1
</code></pre>
<p>整数のインスタンスでは、<code>Data.Char</code>の <code>toCharCode</code>関数を使うと<code>Char</code>をハッシュ化するインスタンスを作成できます。</p>
<pre><code class="language-haskell">instance Hashable Char where
  hash = hash &lt;&lt;&lt; toCharCode
</code></pre>
<p>（要素型が <code>Hashable</code>のインスタンスでもあるならば）配列の要素に <code>hash</code>関数を
<code>map</code>してから、<code>combineHashes</code>関数を使って結果のハッシュを左側に畳み込むことで、配列のインスタンスを定義します。</p>
<pre><code class="language-haskell">instance Hashable a =&gt; Hashable (Array a) where
  hash = foldl combineHashes (hashCode 0) &lt;&lt;&lt; map hash
</code></pre>
<p>既に書いたものより単純なインスタンスを使用して、新たなインスタンスを構築しているやり方に注目してください。
<code>String</code>を<code>Char</code>の配列に変換し、この新たな<code>Array</code>インスタンスを使って<code>String</code>のインスタンスを定義しましょう。</p>
<pre><code class="language-haskell">instance Hashable String where
  hash = hash &lt;&lt;&lt; toCharArray
</code></pre>
<p>これらの <code>Hashable</code>インスタンスが先ほどの型クラスの法則を満たしていることを証明するにはどうしたらいいでしょうか。
同じ値が等しいハッシュコードを持っていることを確認する必要があります。
<code>Int</code>、<code>Char</code>、<code>String</code>、<code>Boolean</code>のような場合は単純です。
<code>Eq</code>の意味では同じ値でも厳密には同じではない、というような型の値は存在しないからです。</p>
<p>もっと面白い型についてはどうでしょうか。
<code>Array</code>インスタンスの型クラスの法則を証明するにあたっては、配列の長さに関する帰納を使えます。
長さゼロの唯一の配列は <code>[]</code>です。
配列の <code>Eq</code>の定義により、任意の2つの空でない配列は、それらの先頭の要素が同じで配列の残りの部分が等しいとき、またその時に限り等しくなります。
この帰納的な仮定により、配列の残りの部分は同じハッシュ値を持ちますし、もし <code>Hashable a</code>インスタンスがこの法則を満たすなら、先頭の要素も同じハッシュ値を持つことがわかります。
したがって、2つの配列は同じハッシュ値を持ち、<code>Hashable (Array a)</code>も同様に型クラス法則に従います。</p>
<p>この章のソースコードには、 <code>Maybe</code>と <code>Tuple</code>型のインスタンスなど、他にも <code>Hashable</code>インスタンスの例が含まれています。</p>
<h2 id="演習-17"><a class="header" href="#演習-17">演習</a></h2>
<ol>
<li>
<p>（簡単）PSCiを使って、定義した各インスタンスのハッシュ関数をテストしてください。
<em>補足</em>：この演習には単体試験がありません。</p>
</li>
<li>
<p>（普通）関数<code>arrayHasDuplicates</code>を書いてください。
この関数はハッシュと値の同値性に基づいて配列が重複する要素を持っているかどうかを調べます。
まずハッシュ同値性を<code>hashEqual</code>関数で確認し、それからもし重複するハッシュの対が見付かったら<code>==</code>で値の同値性を確認してください。
<em>手掛かり</em>：<code>Data.Array</code>の <code>nubByEq</code>関数はこの問題をずっと簡単にしてくれるでしょう。</p>
</li>
<li>
<p>（普通）型クラスの法則を満たす、次のnewtypeの <code>Hashable</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">newtype Hour = Hour Int

instance Eq Hour where
  eq (Hour n) (Hour m) = mod n 12 == mod m 12
</code></pre>
</li>
</ol>
<p>newtypeの <code>Hour</code>とその <code>Eq</code>インスタンスは、12を法とする整数の型を表します。
したがって、例えば1と13は等しいと見なされます。
そのインスタンスが型クラスの法則を満たしていることを証明してください。</p>
<ol>
<li>（難しい）<code>Maybe</code>、<code>Either</code>そして<code>Tuple</code>への<code>Hashable</code>インスタンスについて型クラスの法則を証明してください。
<em>補足</em>：この演習にテストはありません。</li>
</ol>
<h2 id="まとめ-4"><a class="header" href="#まとめ-4">まとめ</a></h2>
<p>この章では<em>型クラス</em>を導入しました。
型クラスは型に基づく抽象化で、コードの再利用のために強力な形式化ができます。
PureScriptの標準ライブラリから標準の型クラスを幾つか見てきました。
また、ハッシュ値を計算するための型クラスに基づく独自のライブラリを定義しました。</p>
<p>この章では型クラス法則も導入しましたが、これは抽象化に型クラスを使うコードについての性質を証明する手法でした。
型クラス法則は<em>等式推論</em>と呼ばれる、より大きな分野の一部です。
そちらではプログラミング言語の性質と型システムがプログラムを論理的に追究するために使われています。
これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話題となるでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アプリカティブによる検証"><a class="header" href="#アプリカティブによる検証">アプリカティブによる検証</a></h1>
<h2 id="この章の目標-5"><a class="header" href="#この章の目標-5">この章の目標</a></h2>
<p>この章では重要な抽象化と新たに出会うことになります。
<code>Applicative</code>型クラスによって表現される<em>アプリカティブ関手</em>です。
名前が難しそうに思えても心配しないでください。
フォームデータの検証という実用的な例を使ってこの概念の動機付けをします。
アプリカティブ関手の技法があることにより、通常であれば大量の決まり文句の検証を伴うようなコードを、簡潔で宣言的なフォームの記述へと変えられます。</p>
<p>また、<em>巡回可能関手</em>を表現する<code>Traversable</code>という別の型クラスにも出会います。現実の問題への解決策からこの概念が自然に生じることがわかるでしょう。</p>
<p>この章のコードでは第3章に引き続き住所録を例とします。
今回は住所録のデータ型を拡張し、これらの型の値を検証する関数を書きます。
これらの関数は、例えばwebユーザインターフェースで使えることが分かります。
データ入力フォームの一部として、使用者へエラーを表示するのに使われます。</p>
<h2 id="プロジェクトの準備-4"><a class="header" href="#プロジェクトの準備-4">プロジェクトの準備</a></h2>
<p>この章のソースコードは、2つのファイル<code>src/Data/AddressBook.purs</code>、及び<code>src/Data/AddressBook/Validation.purs</code>で定義されています。</p>
<p>このプロジェクトには多くの依存関係がありますが、その大半は既に見てきたものです。
新しい依存関係は2つです。</p>
<ul>
<li><code>control</code> - <code>Applicative</code>のような、型クラスを使用して制御フローを抽象化する関数が定義されています。</li>
<li><code>validation</code> - この章の主題である <em>アプリカティブによる検証</em> のための関手が定義されています。</li>
</ul>
<p><code>Data.AddressBook</code>モジュールにはこのプロジェクトのデータ型とそれらの型に対する<code>Show</code>インスタンスが定義されています。
また、<code>Data.AddressBook.Validation</code>モジュールにはそれらの型の検証規則が含まれています。</p>
<h2 id="関数適用の一般化"><a class="header" href="#関数適用の一般化">関数適用の一般化</a></h2>
<p><em>アプリカティブ関手</em> の概念を理解するために、以前扱った型構築子<code>Maybe</code>について考えてみましょう。</p>
<p>このモジュールのソースコードでは、次の型を持つ<code>address</code>関数が定義されています。</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address
</code></pre>
<p>この関数は、通りの名前、市、州という3つの文字列から型<code>Address</code>の値を構築するために使います。</p>
<p>この関数は簡単に適用できますので、PSCiでどうなるか見てみましょう。</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; address &quot;123 Fake St.&quot; &quot;Faketown&quot; &quot;CA&quot;
{ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>しかし、通り、市、州の3つ全てが必ずしも入力されないものとすると、3つの場合がそれぞれ省略可能であることを示すために<code>Maybe</code>型を使用したくなります。</p>
<p>考えられる場合としては、市が省略されている場合があるでしょう。
もし<code>address</code>関数を直接適用しようとすると、型検証器からエラーが表示されます。</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Could not match type

  Maybe String

with type

  String
</code></pre>
<p>勿論、これは期待通り型エラーになります。
<code>address</code>は<code>Maybe String</code>型の値ではなく、文字列を引数として取るためです。</p>
<p>しかし、もし<code>address</code>関数を「持ち上げる」ことができれば、<code>Maybe</code>型で示される省略可能な値を扱うことができるはずだという予想は理に適っています。実際それは可能で、<code>Control.Apply</code>で提供されている関数<code>lift3</code>が、まさに求めているものです。</p>
<pre><code class="language-text">&gt; import Control.Apply
&gt; lift3 address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Nothing
</code></pre>
<p>このとき、引数の1つ（市）が欠落していたので、結果は<code>Nothing</code>になります。
もし3つの引数全てに<code>Just</code>構築子を使ったものが与えられたら、結果は値を含むことになります。</p>
<pre><code class="language-text">&gt; lift3 address (Just &quot;123 Fake St.&quot;) (Just &quot;Faketown&quot;) (Just &quot;CA&quot;)

Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })
</code></pre>
<p><code>lift3</code>という関数の名前は、3引数の関数を持ち上げるために使えることを示しています。関数を持ち上げる同様の関数で、引数の数が異なるものが<code>Control.Apply</code>で定義されています。</p>
<h2 id="任意個の引数を持つ関数の持ち上げ"><a class="header" href="#任意個の引数を持つ関数の持ち上げ">任意個の引数を持つ関数の持ち上げ</a></h2>
<p>これで、<code>lift2</code>や<code>lift3</code>のような関数を使えば、引数が2個や3個の関数を持ち上げることができるのはわかりました。
でも、これを任意個の引数の関数へと一般化できるのでしょうか。</p>
<p><code>lift3</code>の型を見てみるとわかりやすいでしょう。</p>
<pre><code class="language-text">&gt; :type lift3
forall (a :: Type) (b :: Type) (c :: Type) (d :: Type) (f :: Type -&gt; Type). Apply f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d
</code></pre>
<p>上の<code>Maybe</code>の例では型構築子<code>f</code>は<code>Maybe</code>ですから、<code>lift3</code>は次のように特殊化されます。</p>
<pre><code class="language-haskell">forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; Maybe a -&gt; Maybe b -&gt; Maybe c -&gt; Maybe d
</code></pre>
<p>この型で書かれているのは、3引数の任意の関数を取り、その関数を引数と返り値が<code>Maybe</code>で包まれた新しい関数へと持ち上げられる、ということです。</p>
<p>勿論、どんな型構築子<code>f</code>についても持ち上げができるわけではないのですが、それでは<code>Maybe</code>型を持ち上げができるようにしているものは何なのでしょうか。
さて、先ほどの型の特殊化では、<code>f</code>に対する型クラス制約から<code>Apply</code>型クラスを取り除いていました。
<code>Apply</code>はPreludeで次のように定義されています。</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>Apply</code>型クラスは<code>Functor</code>の下位クラスであり、追加の関数<code>apply</code>を定義しています。<code>&lt;$&gt;</code>が<code>map</code>の別名として定義されているように、<code>Prelude</code>モジュールでは<code>&lt;*&gt;</code>を<code>apply</code>の別名として定義しています。これから見ていきますが、これら2つの演算子はよく一緒に使われます。</p>
<p>なお、この<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Apply#v:apply"><code>apply</code></a>は<code>Data.Function</code>の<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:apply"><code>apply</code></a>（中置で<code>$</code>）とは異なります。
幸いにも後者はほぼ常に中置記法として使われるので、名前の衝突については心配ご無用です。</p>
<p><code>apply</code>の型は<code>map</code>の型と実によく似ています。
<code>map</code>と<code>apply</code>の違いは、<code>map</code>がただの関数を引数に取るのに対し、<code>apply</code>の最初の引数は型構築子<code>f</code>で包まれているという点です。
これをどのように使うのかはこれからすぐに見ていきますが、その前にまず<code>Maybe</code>型について<code>Apply</code>型クラスをどう実装するのかを見ていきましょう。</p>
<pre><code class="language-haskell">instance Functor Maybe where
  map f (Just a) = Just (f a)
  map f Nothing  = Nothing

instance Apply Maybe where
  apply (Just f) (Just x) = Just (f x)
  apply _        _        = Nothing
</code></pre>
<p>この型クラスのインスタンスで書かれているのは、任意の省略可能な値に省略可能な関数を適用でき、その両方が定義されている時に限り結果も定義される、ということです。</p>
<p>それでは、<code>map</code>と<code>apply</code>を一緒に使い、引数が任意個の関数を持ち上げる方法を見ていきましょう。</p>
<p>1引数の関数については、<code>map</code>をそのまま使うだけです。</p>
<p>2引数関数については、型<code>a -&gt; b -&gt; c</code>のカリー化された関数<code>g</code>があるとします。これは型<code>a -&gt; (b -&gt; c)</code>と同じですから、<code>Functor</code>インスタンス付きのあらゆる型構築子<code>f</code>について、<code>map</code>を<code>f</code>に適用すると型<code>f a -&gt; f (b -&gt; c)</code>の新たな関数を得ることになります。持ち上げられた（型<code>f a</code>の）最初の引数にその関数を部分適用すると、型<code>f (b -&gt; c)</code>の新たな包まれた関数が得られます。<code>f</code>に<code>Apply</code>インスタンスもあるなら、そこから、2番目の持ち上げられた（型<code>f b</code>の）引数へ<code>apply</code>を適用でき、型<code>f c</code>の最終的な値を得ます。</p>
<p>纏めると、<code>x :: f a</code>と<code>y :: f b</code>があるとき、式<code>(g &lt;$&gt; x) &lt;*&gt; y</code>の型は<code>f c</code>になります（この式は<code>apply (map g x)  y</code>と同じ意味だということを思い出しましょう）。Preludeで定義された優先順位の規則に従うと、<code>g &lt;$&gt; x &lt;*&gt; y</code>というように括弧を外すことができます。</p>
<p>一般的には、最初の引数に<code>&lt;$&gt;</code>を使い、残りの引数に対しては<code>&lt;*&gt;</code>を使います。<code>lift3</code>で説明すると次のようになります。</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z
</code></pre>
<blockquote>
<p>この式に関する型の検証は、読者への演習として残しておきます。</p>
</blockquote>
<p>例として、<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>をそのまま使うと、<code>Maybe</code>上に<code>address</code>関数を持ち上げることができます。</p>
<pre><code class="language-text">&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Just &quot;Faketown&quot; &lt;*&gt; Just &quot;CA&quot;
Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })

&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;CA&quot;
Nothing
</code></pre>
<p>同様にして、引数が異なる他のいろいろな関数を<code>Maybe</code>上に持ち上げてみてください。</p>
<p>この代わりに、お馴染の<em>do記法</em>に似た見た目の<em>アプリカティブdo記法</em>が同じ目的で使えます。
以下では<code>lift3</code>に<em>アプリカティブdo記法</em>を使っています。
なお、<code>ado</code>が<code>do</code>の代わりに使われており、生み出された値を示すために最後の行で<code>in</code>が使われています。</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = ado
  a &lt;- x
  b &lt;- y
  c &lt;- z
  in f a b c
</code></pre>
<h2 id="アプリカティブ型クラス"><a class="header" href="#アプリカティブ型クラス">アプリカティブ型クラス</a></h2>
<p>関連する<code>Applicative</code>という型クラスが存在しており、次のように定義されています。</p>
<pre><code class="language-haskell">class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p><code>Applicative</code>は<code>Apply</code>の下位クラスであり、<code>pure</code>関数が定義されています。
<code>pure</code>は値を取り、その型の型構築子<code>f</code>で包まれた値を返します。</p>
<p><code>Maybe</code>についての<code>Applicative</code>インスタンスは次のようになります。</p>
<pre><code class="language-haskell">instance Applicative Maybe where
  pure x = Just x
</code></pre>
<p>アプリカティブ関手は関数を持ち上げることを可能にする関手だと考えるとすると、<code>pure</code>は引数のない関数の持ち上げだというように考えられます。</p>
<h2 id="アプリカティブに対する直感的理解"><a class="header" href="#アプリカティブに対する直感的理解">アプリカティブに対する直感的理解</a></h2>
<p>PureScriptの関数は純粋であり、副作用は持っていません。Applicative関手は、関手<code>f</code>によって表現されるある種の副作用を提供するような、より大きな「プログラミング言語」を扱えるようにします。</p>
<p>例えば関手<code>Maybe</code>は欠けている可能性がある値の副作用を表現しています。
その他の例としては、型<code>err</code>のエラーの可能性の副作用を表す<code>Either err</code>や、大域的な構成を読み取る副作用を表すArrow関手 (arrow functor) <code>r -&gt;</code>があります。
ここでは<code>Maybe</code>関手についてのみ考えることにします。</p>
<p>もし関手<code>f</code>が作用を持つ、より大きなプログラミング言語を表すとすると、<code>Apply</code>と<code>Applicative</code>インスタンスは小さなプログラミング言語
(PureScript) から新しい大きな言語へと値や関数を持ち上げることを可能にします。</p>
<p><code>pure</code>は純粋な（副作用がない）値をより大きな言語へと持ち上げますし、関数については上で述べた通り<code>map</code>と<code>apply</code>を使えます。</p>
<p>ここで疑問が生まれます。
もしPureScriptの関数と値を新たな言語へ埋め込むのに<code>Applicative</code>が使えるなら、どうやって新たな言語は大きくなっているというのでしょうか。
この答えは関手<code>f</code>に依存します。
もしなんらかの<code>x</code>について<code>pure x</code>で表せないような型<code>f a</code>の式を見つけたなら、その式はそのより大きな言語だけに存在する項を表しているということです。</p>
<p><code>f</code>が<code>Maybe</code>のときは、式<code>Nothing</code>がその例になっています。
どんな<code>x</code>があっても<code>Nothing</code>を<code>pure x</code>というように書くことはできません。
したがって、PureScriptは値の欠落を表す新しい項<code>Nothing</code>を含むように拡大されたと考えることができます。</p>
<h2 id="もっと作用を"><a class="header" href="#もっと作用を">もっと作用を</a></h2>
<p>様々な<code>Applicative</code>関手へと関数を持ち上げる例をもっと見ていきましょう。</p>
<p>以下は、PSCiで定義された3つの名前を結合して完全な名前を作る簡単な関数の例です。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; fullName first middle last = last &lt;&gt; &quot;, &quot; &lt;&gt; first &lt;&gt; &quot; &quot; &lt;&gt; middle

&gt; fullName &quot;Phillip&quot; &quot;A&quot; &quot;Freeman&quot;
Freeman, Phillip A
</code></pre>
<p>この関数が、クエリ引数として与えられた3つの引数を持つ、（とっても簡単な）webサービスの実装を形成しているとしましょう。
使用者が3つの各引数を与えたことを確かめたいので、引数が存在するかどうかを表す<code>Maybe</code>型を使うことになるでしょう。
<code>fullName</code>を<code>Maybe</code>の上へ持ち上げると、欠けている引数を検査するwebサービスの実装を作成できます。</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Just &quot;A&quot; &lt;*&gt; Just &quot;Freeman&quot;
Just (&quot;Freeman, Phillip A&quot;)

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;Freeman&quot;
Nothing
</code></pre>
<p>または<em>アプリカティブdo</em>で次のようにします。</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; :paste…
… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Just &quot;A&quot;
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
(Just &quot;Freeman, Phillip A&quot;)

… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Nothing
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
Nothing
</code></pre>
<p>この持ち上げた関数は、引数の何れかが<code>Nothing</code>なら<code>Nothing</code>を返すことに注意してください。</p>
<p>引数が不正のときにwebサービスからエラー応答を送り返せるのは良いことです。
しかし、どのフィールドが不正確なのかを応答で示せると、もっと良くなるでしょう。</p>
<p><code>Meybe</code>上へ持ち上げる代わりに<code>Either String</code>上へ持ち上げるようにすると、エラー文言を返せるようになります。
まずは<code>Either String</code>を使い、省略可能な入力からエラーを発信できる計算に変換する演算子を書きましょう。</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; :paste
… withError Nothing  err = Left err
… withError (Just a) _   = Right a
… ^D
</code></pre>
<p><em>補足</em>：<code>Either err</code>アプリカティブ関手において、<code>Left</code>構築子は失敗を表しており、<code>Right</code>構築子は成功を表しています。</p>
<p>これで<code>Either String</code>上へ持ち上げることで、それぞれの引数について適切なエラー文言を提供できるようになります。</p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last =
…   fullName &lt;$&gt; (first  `withError` &quot;First name was missing&quot;)
…            &lt;*&gt; (middle `withError` &quot;Middle name was missing&quot;)
…            &lt;*&gt; (last   `withError` &quot;Last name was missing&quot;)
… ^D
</code></pre>
<p>または<em>アプリカティブdo</em>で次のようにします。</p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last = ado
…  f &lt;- first  `withError` &quot;First name was missing&quot;
…  m &lt;- middle `withError` &quot;Middle name was missing&quot;
…  l &lt;- last   `withError` &quot;Last name was missing&quot;
…  in fullName f m l
… ^D

&gt; :type fullNameEither
Maybe String -&gt; Maybe String -&gt; Maybe String -&gt; Either String String
</code></pre>
<p>これでこの関数は<code>Maybe</code>を使う3つの省略可能な引数を取り、<code>String</code>のエラー文言か<code>String</code>の結果のどちらかを返します。</p>
<p>いろいろな入力でこの関数を試してみましょう。</p>
<pre><code class="language-text">&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) (Just &quot;Freeman&quot;)
(Right &quot;Freeman, Phillip A&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) Nothing (Just &quot;Freeman&quot;)
(Left &quot;Middle name was missing&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) Nothing
(Left &quot;Last name was missing&quot;)
</code></pre>
<p>このとき、全てのフィールドが与えられば成功の結果が表示され、そうでなければ省略されたフィールドのうち最初のものに対応するエラー文言が表示されます。
しかし、もし複数の入力が省略されているとき、最初のエラーしか見られません。</p>
<pre><code class="language-text">&gt; fullNameEither Nothing Nothing Nothing
(Left &quot;First name was missing&quot;)
</code></pre>
<p>これでも充分なときもありますが、エラー時に<em>全ての</em>省略されたフィールドの一覧がほしいときは、<code>Either String</code>よりも強力なものが必要です。この章の後半で解決策を見ていきます。</p>
<h2 id="作用の結合"><a class="header" href="#作用の結合">作用の結合</a></h2>
<p>抽象的にアプリカティブ関手を扱う例として、この節ではアプリカティブ関手<code>f</code>によって表現された副作用を一般的に組み合わせる関数を書く方法を示します。</p>
<p>これはどういう意味でしょうか。
何らかの<code>a</code>について型<code>f a</code>で包まれた引数のリストがあるとしましょう。
それは型<code>List (f a)</code>のリストがあるということです。
直感的には、これは<code>f</code>によって追跡される副作用を持つ、返り値の型が<code>a</code>の計算のリストを表しています。
これらの計算の全てを順番に実行できれば、<code>List a</code>型の結果のリストを得るでしょう。
しかし、まだ<code>f</code>によって追跡される副作用が残ります。
つまり、元のリストの中の作用を「結合する」ことにより、型<code>List (f a)</code>の何かを型<code>f (List a)</code>の何かへと変換できると考えられます。</p>
<p>任意の固定長リストの長さ<code>n</code>について、<code>n</code>引数からその引数を要素に持つ長さ<code>n</code>のリストを構築する関数が存在します。
例えばもし<code>n</code>が<code>3</code>なら、関数は<code>\x y z -&gt; x : y : z : Nil</code>です。
この関数は型<code>a -&gt; a -&gt; a -&gt; List a</code>を持ちます。
<code>Applicative</code>インスタンスを使うと、この関数を<code>f</code>の上へ持ち上げられ、関数型<code>f a -&gt; f a -&gt; f a -&gt; f (List a)</code>が得られます。
しかし、いかなる<code>n</code>についてもこれが可能なので、いかなる引数の<em>リスト</em>についても同じように持ち上げられることが確かめられます。</p>
<p>したがって、次のような関数を書くことができるはずです。</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>この関数は副作用を持つかもしれない引数のリストを取り、それぞれの副作用を適用することで、<code>f</code>に包まれた単一のリストを返します。</p>
<p>この関数を書くためには、引数のリストの長さについて考えます。
リストが空の場合はどんな作用も実行する必要がありませんから、<code>pure</code>を使用して単に空のリストを返すことができます。</p>
<pre><code class="language-haskell">combineList Nil = pure Nil
</code></pre>
<p>実際のところ、これが唯一できることです。</p>
<p>入力のリストが空でないならば、型<code>f a</code>の包まれた引数である先頭要素と、型<code>List (f a)</code>の尾鰭について考えます。
また、再帰的にリストの残りを結合すると、型<code>f (List a)</code>の結果が得られます。
それから<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使うと、<code>Cons</code>構築子を先頭と新しい尾鰭の上に持ち上げることができます。</p>
<pre><code class="language-haskell">combineList (Cons x xs) = Cons &lt;$&gt; x &lt;*&gt; combineList xs
</code></pre>
<p>繰り返しになりますが、これは与えられた型に基づいている唯一の妥当な実装です。</p>
<p><code>Maybe</code>型構築子を例にとって、PSCiでこの関数を試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.List
&gt; import Data.Maybe

&gt; combineList (fromFoldable [Just 1, Just 2, Just 3])
(Just (Cons 1 (Cons 2 (Cons 3 Nil))))

&gt; combineList (fromFoldable [Just 1, Nothing, Just 2])
Nothing
</code></pre>
<p><code>Meybe</code>へ特殊化すると、リストの全ての要素が<code>Just</code>であるときに限りこの関数は<code>Just</code>を返しますし、そうでなければ<code>Nothing</code>を返します。
これは省略可能な値に対応する、より大きな言語に取り組む上での直感と一貫しています。
省略可能な結果を生む計算のリストは、全ての計算が結果を持っているならばそれ自身の結果のみを持つのです。</p>
<p>ところが<code>combineList</code>関数はどんな<code>Applicative</code>に対しても機能するのです。
<code>Either err</code>を使ってエラーを発信する可能性を持たせたり、<code>r -&gt;</code>を使って大域的な構成を読み取る計算を組み合わせるためにも使えます。</p>
<p><code>combineList</code>関数については、後ほど<code>Traversable</code>関手について考えるときに再訪します。</p>
<h2 id="演習-18"><a class="header" href="#演習-18">演習</a></h2>
<ol>
<li>（普通）数値演算子<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>の別のバージョンを書いてください。
ただし省略可能な引数（つまり<code>Maybe</code>に包まれた引数）を扱って<code>Maybe</code>に包まれた値を返します。
これらの関数には<code>addMaybe</code>、<code>subMaybe</code>、<code>mulMaybe</code>、<code>divMaybe</code>と名前を付けてください。
<em>手掛かり</em>：<code>lift2</code>を使ってください。</li>
<li>（普通）上の演習を（<code>Maybe</code>だけでなく）全ての<code>Apply</code>型で動くように拡張してください。
これらの新しい関数には<code>addApply</code>、<code>subApply</code>、<code>mulApply</code>、<code>divApply</code>と名前を付けます。</li>
<li>（難しい）型<code>forall a f. Applicative f =&gt; Maybe (f a) -&gt; f (Maybe a)</code>を持つ関数<code>combineMaybe</code>を書いてください。
この関数は副作用を持つ省略可能な計算を取り、省略可能な結果を持つ副作用のある計算を返します。</li>
</ol>
<h2 id="アプリカティブによる検証-1"><a class="header" href="#アプリカティブによる検証-1">アプリカティブによる検証</a></h2>
<p>この章のソースコードでは住所録アプリケーションで使うであろう幾つかのデータ型が定義されています。
詳細はここでは割愛しますが、<code>Data.AddressBook</code>モジュールからエクスポートされる鍵となる関数は次のような型を持ちます。</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address

phoneNumber :: PhoneType -&gt; String -&gt; PhoneNumber

person :: String -&gt; String -&gt; Address -&gt; Array PhoneNumber -&gt; Person
</code></pre>
<p>ここで、<code>PhoneType</code>は次のような代数的データ型として定義されています。</p>
<pre><code class="language-haskell">data PhoneType
  = HomePhone
  | WorkPhone
  | CellPhone
  | OtherPhone
</code></pre>
<p>これらの関数は住所録の項目を表す<code>Person</code>を構築できます。
例えば、<code>Data.AddressBook</code>では以下の値が定義されています。</p>
<pre><code class="language-haskell">examplePerson :: Person
examplePerson =
  person &quot;John&quot; &quot;Smith&quot;
    (address &quot;123 Fake St.&quot; &quot;FakeTown&quot; &quot;CA&quot;)
    [ phoneNumber HomePhone &quot;555-555-5555&quot;
    , phoneNumber CellPhone &quot;555-555-0000&quot;
    ]
</code></pre>
<p>PSCiでこれらの値を試してみましょう（結果は整形されています）。</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; examplePerson
{ firstName: &quot;John&quot;
, lastName: &quot;Smith&quot;
, homeAddress:
    { street: &quot;123 Fake St.&quot;
    , city: &quot;FakeTown&quot;
    , state: &quot;CA&quot;
    }
, phones:
    [ { type: HomePhone
      , number: &quot;555-555-5555&quot;
      }
    , { type: CellPhone
      , number: &quot;555-555-0000&quot;
      }
    ]
}
</code></pre>
<p>前の章では型<code>Person</code>のデータ構造を検証する上で<code>Either String</code>関手の使い方を見ました。例えば、データ構造の2つの名前を検証する関数が与えられたとき、データ構造全体を次のように検証できます。</p>
<pre><code class="language-haskell">nonEmpty1 :: String -&gt; Either String String
nonEmpty1 &quot;&quot;     = Left &quot;Field cannot be empty&quot;
nonEmpty1 value  = Right value

validatePerson1 :: Person -&gt; Either String Person
validatePerson1 p =
  person &lt;$&gt; nonEmpty1 p.firstName
         &lt;*&gt; nonEmpty1 p.lastName
         &lt;*&gt; pure p.homeAddress
         &lt;*&gt; pure p.phones
</code></pre>
<p>または<em>アプリカティブdo</em>で次のようにします。</p>
<pre><code class="language-haskell">validatePerson1Ado :: Person -&gt; Either String Person
validatePerson1Ado p = ado
  f &lt;- nonEmpty1 p.firstName
  l &lt;- nonEmpty1 p.lastName
  in person f l p.homeAddress p.phones
</code></pre>
<p>最初の2行では<code>nonEmpty1</code>関数を使って空文字列でないことを検証しています。
もし入力が空なら<code>nonEmpty1</code>は<code>Left</code>構築子で示されるエラーを返します。
そうでなければ<code>Right</code>構築子で包まれた値を返します。</p>
<p>最後の2行では何の検証も実行せず、単に<code>address</code>フィールドと<code>phones</code>フィールドを残りの引数として<code>person</code>関数へと提供しています。</p>
<p>この関数はPSCiでうまく動作するように見えますが、以前見たような制限があります。</p>
<pre><code class="language-text">&gt; validatePerson $ person &quot;&quot; &quot;&quot; (address &quot;&quot; &quot;&quot; &quot;&quot;) []
(Left &quot;Field cannot be empty&quot;)
</code></pre>
<p><code>Either String</code>アプリカティブ関手は最初に遭遇したエラーだけを返します。
仮にこの入力だったとすると、2つのエラーが分かったほうが良いでしょう。
1つは名前の不足で、2つ目は姓の不足です。</p>
<p><code>validation</code>ライブラリでは別のアプリカティブ関手も提供されています。
これは<code>V</code>という名前で、何らかの<em>半群</em>でエラーを返せます。
例えば<code>V (Array String)</code>を使うと、新しいエラーを配列の最後に連結していき、<code>String</code>の配列をエラーとして返せます。</p>
<p><code>Data.Validation</code>モジュールは<code>Data.AddressBook</code>モジュールのデータ構造を検証するために<code>V (Array String)</code>アプリカティブ関手を使っています。</p>
<p><code>Data.AddressBook.Validation</code>モジュールから取材した検証器の例は次のようになります。</p>
<pre><code class="language-haskell">type Errors
  = Array String

nonEmpty :: String -&gt; String -&gt; V Errors String
nonEmpty field &quot;&quot;     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' cannot be empty&quot; ]
nonEmpty _     value  = pure value

lengthIs :: String -&gt; Int -&gt; String -&gt; V Errors String
lengthIs field len value | length value /= len =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must have length &quot; &lt;&gt; show len ]
lengthIs _     _   value = pure value

validateAddress :: Address -&gt; V Errors Address
validateAddress a =
  address &lt;$&gt; nonEmpty &quot;Street&quot;  a.street
          &lt;*&gt; nonEmpty &quot;City&quot;    a.city
          &lt;*&gt; lengthIs &quot;State&quot; 2 a.state
</code></pre>
<p>または<em>アプリカティブdo</em>で次のようにします。</p>
<pre><code class="language-haskell">validateAddressAdo :: Address -&gt; V Errors Address
validateAddressAdo a = ado
  street &lt;- nonEmpty &quot;Street&quot;  a.street
  city   &lt;- nonEmpty &quot;City&quot;    a.city
  state  &lt;- lengthIs &quot;State&quot; 2 a.state
  in address street city state
</code></pre>
<p><code>validateAddress</code>は<code>Address</code>の構造を検証します。
<code>street</code>と<code>city</code>が空でないかどうか、<code>state</code>の文字列の長さが2であるかどうかを検証します。</p>
<p><code>nonEmpty</code>と<code>lengthIs</code>の2つの検証関数が何れも、<code>Data.Validation</code>モジュールで提供されている<code>invalid</code>関数をエラーを示すために使っているところに注目してください。
<code>Array String</code>半群を扱っているので、<code>invalid</code>は引数として文字列の配列を取ります。</p>
<p>PSCiでこの関数を試しましょう。</p>
<pre><code class="language-text">&gt; import Data.AddressBook
&gt; import Data.AddressBook.Validation

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         , &quot;Field 'State' must have length 2&quot;
         ])

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;CA&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         ])
</code></pre>
<p>これで、全ての検証エラーの配列を受け取ることができるようになりました。</p>
<h2 id="正規表現検証器"><a class="header" href="#正規表現検証器">正規表現検証器</a></h2>
<p><code>validatePhoneNumber</code>関数では引数の形式を検証するために正規表現を使っています。重要なのは<code>matches</code>検証関数で、この関数は<code>Data.String.Regex</code>モジュールで定義されている<code>Regex</code>を使って入力を検証しています。</p>
<pre><code class="language-haskell">matches :: String -&gt; Regex -&gt; String -&gt; V Errors String
matches _     regex value | test regex value
                          = pure value
matches field _     _     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' did not match the required format&quot; ]
</code></pre>
<p>繰り返しになりますが、<code>pure</code>は常に成功する検証を表しており、エラーの配列の伝達には<code>invalid</code>が使われています。</p>
<p>これまでと同様に、<code>validatePhoneNumber</code>は<code>matches</code>関数から構築されています。</p>
<pre><code class="language-haskell">validatePhoneNumber :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumber pn =
  phoneNumber &lt;$&gt; pure pn.&quot;type&quot;
              &lt;*&gt; matches &quot;Number&quot; phoneNumberRegex pn.number
</code></pre>
<p>または<em>アプリカティブdo</em>で次のようにします。</p>
<pre><code class="language-haskell">validatePhoneNumberAdo :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumberAdo pn = ado
  tpe    &lt;- pure pn.&quot;type&quot;
  number &lt;- matches &quot;Number&quot; phoneNumberRegex pn.number
  in phoneNumber tpe number
</code></pre>
<p>また、PSCiでいろいろな有効な入力や無効な入力に対して、この検証器を実行してみてください。</p>
<pre><code class="language-text">&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555-555-5555&quot;
pure ({ type: HomePhone, number: &quot;555-555-5555&quot; })

&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555.555.5555&quot;
invalid ([&quot;Field 'Number' did not match the required format&quot;])
</code></pre>
<h2 id="演習-19"><a class="header" href="#演習-19">演習</a></h2>
<ol>
<li>（簡単）正規表現<code>stateRegex :: Regex</code>を書いて文字列が2文字のアルファベットであることを確かめてください。
<em>手掛かり</em>：<code>phoneNumberRegex</code>のソースコードを参照してみましょう。</li>
<li>（普通）文字列全体が空白でないことを検査する正規表現<code>nonEmptyRegex :: Regex</code>を書いてください。
<em>手掛かり</em>：この正規表現を開発するのに手助けが必要なら、<a href="https://regexr.com">RegExr</a>をご確認ください。
素晴しい早見表と対話的なお試し環境があります。</li>
<li>（普通）<code>validateAddress</code>に似ていますが、上の<code>stateRegex</code>を使って<code>state</code>フィールドを検証し、<code>nonEmptyRegex</code>を使って<code>street</code>と<code>city</code>フィールドを検証する関数<code>validateAddressImproved</code>を書いてください。
<em>手掛かり</em>：<code>matches</code>の用例については<code>validatePhoneNumber</code>のソースを見てください。</li>
</ol>
<h2 id="巡回可能関手"><a class="header" href="#巡回可能関手">巡回可能関手</a></h2>
<p>残った検証器は<code>validatePerson</code>です。
これはこれまで見てきた検証器と以下の新しい<code>validatePhoneNumbers</code>関数を組み合わせて<code>Person</code>全体を検証するものです。</p>
<pre><code class="language-haskell">validatePhoneNumbers :: String -&gt; Array PhoneNumber -&gt; V Errors (Array PhoneNumber)
validatePhoneNumbers field []      =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must contain at least one value&quot; ]
validatePhoneNumbers _     phones  =
  traverse validatePhoneNumber phones

validatePerson :: Person -&gt; V Errors Person
validatePerson p =
  person &lt;$&gt; nonEmpty &quot;First Name&quot; p.firstName
         &lt;*&gt; nonEmpty &quot;Last Name&quot; p.lastName
         &lt;*&gt; validateAddress p.homeAddress
         &lt;*&gt; validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
</code></pre>
<p>または<em>アプリカティブdo</em>で次のようにします。</p>
<pre><code class="language-haskell">validatePersonAdo :: Person -&gt; V Errors Person
validatePersonAdo p = ado
  firstName &lt;- nonEmpty &quot;First Name&quot; p.firstName
  lastName  &lt;- nonEmpty &quot;Last Name&quot; p.lastName
  address   &lt;- validateAddress p.homeAddress
  numbers   &lt;- validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
  in person firstName lastName address numbers
</code></pre>
<p><code>validatePhoneNumbers</code>はこれまでに見たことのない新しい関数である<code>traverse</code>を使っています。</p>
<p><code>traverse</code>は<code>Data.Traversable</code>モジュールの<code>Traversable</code>型クラスで定義されています。</p>
<pre><code class="language-haskell">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p><code>Traversable</code>は <em>巡回可能関手</em>
の型クラスを定義します。これらの関数の型は少し難しそうに見えるかもしれませんが、<code>validatePerson</code>は良いきっかけとなる例です。</p>
<p>全ての巡回可能関手は<code>Functor</code>と<code>Foldable</code>のどちらでもあります（<em>畳み込み可能関手</em>は畳み込み操作に対応する型構築子であったことを思い出してください。
畳み込みとは構造を1つの値へと簡約するものでした）。
それに加えて、巡回可能関手はその構造に依存した副作用の集まりを組み合わせられます。</p>
<p>複雑そうに聞こえるかもしれませんが、配列の場合に特殊化して簡単にした上で考えてみましょう。配列型構築子は<code>Traversable</code>であり、つまりは次のような関数が存在するということです。</p>
<pre><code class="language-haskell">traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; Array a -&gt; m (Array b)
</code></pre>
<p>直感的にはこうです。
任意のアプリカティブ関手<code>m</code>と、型<code>a</code>の値を取って型<code>b</code>の値を返す（<code>f</code>で追跡される副作用を持つ）関数が与えられたとします。
このとき、その関数を型<code>Array a</code>の配列のそれぞれの要素に適用して型<code>Array b</code>の（<code>f</code>で追跡される副作用を持つ）結果を得ることができます。</p>
<p>まだよくわからないでしょうか。それでは更に、<code>f</code>を上記の<code>V Errors</code>アプリカティブ関手に特殊化して考えてみましょう。これで次の型を持つ関数が得られます。</p>
<pre><code class="language-haskell">traverse :: forall a b. (a -&gt; V Errors b) -&gt; Array a -&gt; V Errors (Array b)
</code></pre>
<p>この型シグネチャでは、型<code>a</code>についての検証関数<code>m</code>があれば、<code>traverse m</code>は型<code>Array a</code>の配列についての検証関数であると書かれています。
ところがこれは正に<code>Person</code>データ構造体の<code>phones</code>フィールドを検証できるようにするのに必要なものです。
各要素が成功するかを検証する検証関数を作るために、<code>validatePhoneNumber</code>を<code>traverse</code>へ渡しています。</p>
<p>一般に、<code>traverse</code>はデータ構造の要素を1つずつ辿っていき、副作用を伴いつつ計算し、結果を累算します。</p>
<p><code>Traversable</code>のもう1つの関数、<code>sequence</code>の型シグネチャには見覚えがあるかもしれません。</p>
<pre><code class="language-haskell">sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p>実際、先ほど書いた<code>combineList</code>関数は<code>Traversable</code>型クラスの<code>sequence</code>関数の特別な場合に過ぎません。
<code>t</code>を型構築子<code>List</code>だとすると、<code>combineList</code>関数の型が復元されます。</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>巡回可能関手はデータ構造走査の考え方を見据えたものです。
これにより作用のある計算の集合を集めてその作用を結合します。
実際、<code>sequence</code>と<code>traversable</code>は<code>Traversable</code>を定義する上でどちらも同じくらい重要です。
これらはお互いがお互いを利用して実装できます。
これについては興味ある読者への演習として残しておきます。</p>
<p><code>Data.List</code>で与えられているリストの<code>Traversable</code>インスタンスは次の通り。</p>
<pre><code class="language-haskell">instance Traversable List where
-- traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; List a -&gt; m (List b)
traverse _ Nil         = pure Nil
traverse f (Cons x xs) = Cons &lt;$&gt; f x &lt;*&gt; traverse f xs
</code></pre>
<p>（実際の定義は後にスタック安全性を向上するために変更されました。その変更についてより詳しくは<a href="https://github.com/purescript/purescript-lists/pull/87">こちら</a>で読むことができます）</p>
<p>入力が空のリストのときには、<code>pure</code>を使って空のリストを返せます。
リストが空でないときは、関数<code>f</code>を使うと先頭の要素から型<code>f b</code>の計算を作成できます。
また、尾鰭に対して<code>traverse</code>を再帰的に呼び出せます。
最後に、アプリカティブ関手<code>m</code>まで<code>Cons</code>構築子を持ち上げて、2つの結果を組み合わせられます。</p>
<p>巡回可能関手の例はただの配列やリスト以外にもあります。
以前に見た<code>Maybe</code>型構築子も<code>Traversable</code>のインスタンスを持っています。
PSCiで試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; import Data.Traversable
&gt; import Data.AddressBook.Validation

&gt; traverse (nonEmpty &quot;Example&quot;) Nothing
pure (Nothing)

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;&quot;)
invalid ([&quot;Field 'Example' cannot be empty&quot;])

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;Testing&quot;)
pure ((Just &quot;Testing&quot;))
</code></pre>
<p>これらの例では、<code>Nothing</code>の値の走査は検証なしで<code>Nothing</code>の値を返し、<code>Just x</code>を走査すると<code>x</code>を検証するのに検証関数が使われるということを示しています。
要は、<code>traverse</code>は型<code>a</code>についての検証関数を取り、<code>Maybe a</code>についての検証関数、つまり型<code>a</code>の省略可能な値についての検証関数を返すのです。</p>
<p>他の巡回可能関手には、任意の型<code>a</code>についての<code>Array a</code>、<code>Tuple a</code>、<code>Either a</code>が含まれます。
一般に、「容器」のようなほとんどのデータ型構築子は<code>Traversable</code>インスタンスを持っています。
一例として、演習には二分木の型の<code>Traversable</code>インスタンスを書くことが含まれます。</p>
<h2 id="演習-20"><a class="header" href="#演習-20">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Eq</code>と<code>Show</code>インスタンスを以下の2分木データ構造に対して書いてください。</p>
<pre><code class="language-haskell">data Tree a = Leaf | Branch (Tree a) a (Tree a)
</code></pre>
<p>これらのインスタンスを手作業で書くこともできますし、コンパイラに導出してもらうこともできることを前の章から思い起こしてください。</p>
<p><code>Show</code>の出力には多くの「正しい」書式の選択肢があります。
この演習のテストでは以下の空白スタイルを期待しています。
これは一般化されたshowの既定の書式と合致しているため、このインスタンスを手作業で書くつもりのときだけ、このことを念頭に置いておいてください。</p>
<pre><code class="language-haskell">(Branch (Branch Leaf 8 Leaf) 42 Leaf)
</code></pre>
</li>
<li>
<p>（普通）<code>Traversable</code>インスタンスを<code>Tree a</code>に対して書いてください。
これは副作用を左から右に結合するものです。
<em>手掛かり</em>：<code>Traversable</code>に定義する必要のある追加のインスタンス依存関係が幾つかあります。</p>
</li>
<li>
<p>（普通）行き掛け順に木を巡回する関数<code>traversePreOrder :: forall a m b. Applicative m =&gt; (a -&gt; m b) -&gt; Tree a -&gt; m (Tree b)</code>を書いてください。
つまり作用の実行は根左右と行われ、以前の通り掛け順の巡回の演習でしたような左根右ではありません。
<em>手掛かり</em>：追加でインスタンスを定義する必要はありませんし、前に定義した関数は何も呼ぶ必要はありません。
アプリカティブdo記法 (<code>ado</code>) はこの関数を書く最も簡単な方法です。</p>
</li>
<li>
<p>（普通）木を帰り掛け順に巡回する関数<code>traversePostOrder</code>を書いてください。作用は左右根と実行されます。</p>
</li>
<li>
<p>（普通）<code>homeAddress</code>フィールドが省略可能（<code>Maybe</code>を使用）な新しい版の<code>Person</code>型をつくってください。
それからこの新しい<code>Person</code>を検証する新しい版の<code>validatePerson</code>（<code>validatePersonOptionalAddress</code>と改名します）を書いてください。
<em>手掛かり</em>：<code>traverse</code>を使って型<code>Maybe a</code>のフィールドを検証してください。</p>
</li>
<li>
<p>（難しい）<code>sequence</code>のように振る舞う関数<code>sequenceUsingTraverse</code>を書いてください。
ただし<code>traverse</code>を使ってください。</p>
</li>
<li>
<p>（難しい）<code>traverse</code>のように振る舞う関数<code>traverseUsingSequence</code>を書いてください。
ただし<code>sequence</code>を使ってください。</p>
</li>
</ol>
<h2 id="アプリカティブ関手による並列処理"><a class="header" href="#アプリカティブ関手による並列処理">アプリカティブ関手による並列処理</a></h2>
<p>これまでの議論では、アプリカティブ関手がどのように「副作用を結合」させるかを説明するときに、「結合」(combine) という単語を選びました。
しかし、これらの全ての例において、アプリカティブ関手は作用を「連鎖」(sequence) させる、というように言っても同じく妥当です。
巡回可能関手がデータ構造に従って作用を順番に結合させる<code>sequence</code>関数を提供していることと、この直感的理解とは一致するでしょう。</p>
<p>しかし一般には、アプリカティブ関手はこれよりももっと一般的です。
アプリカティブ関手の規則は、その計算の副作用にどんな順序付けも強制しません。
実際、並列に副作用を実行するアプリカティブ関手は妥当でしょう。</p>
<p>例えば<code>V</code>検証関手はエラーの<em>配列</em>を返しますが、その代わりに<code>Set</code>半群を選んだとしてもやはり正常に動き、このときどんな順序で各検証器を実行しても問題はありません。
データ構造に対して並列にこれの実行さえできるのです。</p>
<p>2つ目の例として、<code>parallel</code>パッケージは<em>並列計算</em>に対応する<code>Parallel</code>型クラスを提供します。
<code>Parallel</code>は関数<code>parallel</code>を提供しており、何らかの<code>Applicative</code>関手を使って入力の計算の結果を<em>並列に</em>計算します。</p>
<pre><code class="language-haskell">f &lt;$&gt; parallel computation1
  &lt;*&gt; parallel computation2
</code></pre>
<p>この計算は<code>computation1</code>と<code>computation2</code>を非同期に使って値の計算を始めるでしょう。そして両方の結果の計算が終わった時に、関数<code>f</code>を使って1つの結果へと結合するでしょう。</p>
<p>この考え方の詳細は、本書の後半で <em>コールバック地獄</em> の問題に対してアプリカティブ関手を応用するときに見ていきます。</p>
<p>アプリカティブ関手は並列に結合できる副作用を捉える自然な方法です。</p>
<h2 id="まとめ-5"><a class="header" href="#まとめ-5">まとめ</a></h2>
<p>この章では新しい考え方を沢山扱いました。</p>
<ul>
<li><em>アプリカティブ関手</em>の概念を導入しました。
これは、関数適用の概念から副作用の観念を捉えた型構築子へと一般化するものです。</li>
<li>データ構造の検証という課題をアプリカティブ関手やその切り替えで解く方法を見てきました。
単一のエラーの報告からデータ構造を横断する全てのエラーの報告へ変更できました。</li>
<li><code>Traversable</code>型クラスに出会いました。<em>巡回可能関手</em>の考え方を内包するものであり、要素が副作用を持つ値の結合に使うことができる容れ物でした。</li>
</ul>
<p>アプリカティブ関手は多くの問題に対して優れた解決策を与える興味深い抽象化です。
本書を通じて何度も見ることになるでしょう。
今回の場合、アプリカティブ関手は宣言的な流儀で書く手段を提供していましたが、これにより検証器が<em>どうやって</em>検証を実施するかではなく、<em>何を</em>検証すべきなのかを定義できました。
一般にアプリカティブ関手が<em>領域特化言語</em>を設計する上で便利な道具になることを見ていきます。</p>
<p>次の章では、これに関連する考え方である<em>モナド</em>クラスを見て、住所録の例をブラウザで実行させられるように拡張しましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用モナド"><a class="header" href="#作用モナド">作用モナド</a></h1>
<h2 id="この章の目標-6"><a class="header" href="#この章の目標-6">この章の目標</a></h2>
<p>前章では、<em>副作用</em>を扱うのに使う抽象化であるアプリカティブ関手を導入しました。
副作用とは省略可能な値、エラー文言、検証などです。
この章では、副作用を扱うためのより表現力の高い別の抽象化である<em>モナド</em>を導入します。</p>
<p>この章の目的は、なぜモナドが便利な抽象化なのかということと、<em>do記法</em>との関係を説明することです。</p>
<h2 id="プロジェクトの準備-5"><a class="header" href="#プロジェクトの準備-5">プロジェクトの準備</a></h2>
<p>このプロジェクトでは、以下の依存関係が追加されています。</p>
<ul>
<li><code>effect</code>: 章の後半の主題である<code>Effect</code>モナドを定義しています。
この依存関係は全てのプロジェクトで始めから入っているものなので（これまでの全ての章でも依存関係にありました）、明示的にインストールしなければいけないことは稀です。</li>
<li><code>react-basic-hooks</code>: 住所録アプリに使うwebフレームワークです。</li>
</ul>
<h2 id="モナドとdo記法"><a class="header" href="#モナドとdo記法">モナドとdo記法</a></h2>
<p>do記法は<em>配列内包表記</em>を扱うときに初めて導入されました。
配列内包表記は<code>Data.Array</code>モジュールの<code>concatMap</code>関数の構文糖として提供されています。</p>
<p>次の例を考えてみましょう。2つのサイコロを振って出た目を数え、出た目の合計が
<code>n</code>のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使うとこれを実現できます。</p>
<ul>
<li>最初の投擲で値 <code>x</code>を <em>選択</em> します。</li>
<li>2回目の投擲で値 <code>y</code>を <em>選択</em> します。</li>
<li>もし<code>x</code>と<code>y</code>の和が<code>n</code>なら組<code>[x, y]</code>を返し、そうでなければ失敗します。</li>
</ul>
<p>配列内包表記を使うと、この非決定的アルゴリズムを自然に書けます。</p>
<pre><code class="language-hs">import Prelude

import Control.Plus (empty)
import Data.Array ((..))

countThrows :: Int -&gt; Array (Array Int)
countThrows n = do
  x &lt;- 1 .. 6
  y &lt;- 1 .. 6
  if x + y == n
    then pure [ x, y ]
    else empty
</code></pre>
<p>PSCiでこの関数の動作を見てみましょう。</p>
<pre><code class="language-text">&gt; import Test.Examples

&gt; countThrows 10
[[4,6],[5,5],[6,4]]

&gt; countThrows 12
[[6,6]]
</code></pre>
<p>前の章では、<em>省略可能な値</em>に対応したより大きなプログラミング言語へとPureScriptの関数を埋め込む、<code>Maybe</code>アプリカティブ関手についての直感的理解を養いました。
同様に<em>配列モナド</em>についても、<em>非決定選択</em>に対応したより大きなプログラミング言語へPureScriptの関数を埋め込む、というような直感的理解を得ることができます。</p>
<p>一般に、ある型構築子<code>m</code>のモナドは、型<code>m a</code>の値を持つdo記法を使う手段を提供します。
上の配列内包表記に注意すると、何らかの型<code>a</code>について全行に型<code>Array a</code>の計算が含まれています。
一般に、do記法ブロックの全行は、何らかの型<code>a</code>とモナド<code>m</code>について、型<code>m a</code>の計算を含みます。
モナド<code>m</code>は全行で同じでなければなりません（つまり副作用は固定）が、型<code>a</code>は異なることもあります（つまり個々の計算は異なる型の結果にできる）。</p>
<p>以下はdo記法の別の例です。
今回は型構築子 <code>Maybe</code>に適用されています。
XMLノードを表す型 <code>XML</code>と次の関数があるとします。</p>
<pre><code class="language-hs">child :: XML -&gt; String -&gt; Maybe XML
</code></pre>
<p>この関数はノードの子の要素を探し、もしそのような要素が存在しなければ <code>Nothing</code>を返します。</p>
<p>この場合、do記法を使うと深い入れ子になった要素を検索できます。
XML文書としてエンコードされた利用者情報から、利用者の住んでいる市町村を読み取りたいとします。</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p><code>userCity</code>関数は子の<code>profile</code>要素、<code>profile</code>要素の中にある<code>address</code>要素、最後に<code>address</code>要素の中にある<code>city</code>要素を探します。
これらの要素の何れかが欠落している場合、返り値は<code>Nothing</code>になります。
そうでなければ、返り値は<code>city</code>ノードから<code>Just</code>を使って構築されます。</p>
<p>最後の行にある<code>pure</code>関数は、全ての<code>Applicative</code>関手について定義されているのでした。
<code>Maybe</code>の<code>Applicative</code>関手の<code>pure</code>関数は<code>Just</code>として定義されており、最後の行を <code>Just city</code>へ変更しても同じように正しく動きます。</p>
<h2 id="モナド型クラス"><a class="header" href="#モナド型クラス">モナド型クラス</a></h2>
<p><code>Monad</code>型クラスは次のように定義されています。</p>
<pre><code class="language-hs">class Apply m &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

class (Applicative m, Bind m) &lt;= Monad m
</code></pre>
<p>ここで鍵となる関数は <code>Bind</code>型クラスで定義されている演算子 <code>bind</code>で、<code>Functor</code>及び <code>Apply</code>型クラスにある <code>&lt;$&gt;</code>や <code>&lt;*&gt;</code>などの演算子と同様に、<code>Prelude</code>では <code>&gt;&gt;=</code>として <code>bind</code>の中置の別名が定義されています。</p>
<p><code>Monad</code>型クラスは、既に見てきた<code>Applicative</code>型クラスの操作で<code>Bind</code>を拡張します。</p>
<p><code>Bind</code>型クラスの例を幾つか見てみるのがわかりやすいでしょう。
配列についての <code>Bind</code>の妥当な定義は次のようになります。</p>
<pre><code class="language-hs">instance Bind Array where
  bind xs f = concatMap f xs
</code></pre>
<p>これは以前に仄めかした、配列内包表記と <code>concatMap</code>関数の関係を説明しています。</p>
<p><code>Maybe</code>型構築子についての <code>Bind</code>の実装は次のようになります。</p>
<pre><code class="language-hs">instance Bind Maybe where
  bind Nothing  _ = Nothing
  bind (Just a) f = f a
</code></pre>
<p>この定義は欠落した値がdo記法ブロックを通じて伝播するという直感的理解を裏付けるものです。</p>
<p><code>Bind</code>型クラスとdo記法がどのように関係しているかを見て行きましょう。
最初に、何らかの計算結果からの値の束縛から始まる、単純なdo記法ブロックについて考えてみましょう。</p>
<pre><code class="language-hs">do value &lt;- someComputation
   whatToDoNext
</code></pre>
<p>PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置き換えます。</p>
<pre><code class="language-hs">bind someComputation \value -&gt; whatToDoNext
</code></pre>
<p>あるいは中置で書くと以下です。</p>
<pre><code class="language-hs">someComputation &gt;&gt;= \value -&gt; whatToDoNext
</code></pre>
<p>この計算 <code>whatToDoNext</code>は <code>value</code>に依存できます。</p>
<p>複数の束縛が関係している場合、この規則は先頭のほうから複数回適用されます。例えば、先ほど見た <code>userCity</code>の例では次のように脱糖されます。</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root =
  child root &quot;profile&quot; &gt;&gt;= \prof -&gt;
    child prof &quot;address&quot; &gt;&gt;= \addr -&gt;
      child addr &quot;city&quot; &gt;&gt;= \city -&gt;
        pure city
</code></pre>
<p>do記法を使って表現されたコードは、<code>&gt;&gt;=</code>演算子を使う等価なコードより遥かに読みやすくなることがよくあることも特筆すべき点です。
しかしながら、明示的に<code>&gt;&gt;=</code>を使って束縛を書くと、<em>ポイントフリー</em>形式でコードが書けるようになることがよくあります。
ただし、読みやすさにはやはり注意が要ります。</p>
<h2 id="モナド則"><a class="header" href="#モナド則">モナド則</a></h2>
<p><code>Monad</code>型クラスは<em>モナド則</em>と呼ばれる3つの規則を持っています。これらは
<code>Monad</code>型クラスの合理的な実装から何を期待できるかを教えてくれます。</p>
<p>do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。</p>
<h3 id="単位元律"><a class="header" href="#単位元律">単位元律</a></h3>
<p><em>右単位元則</em> (right-identity law)
が3つの規則の中で最も簡単です。この規則はdo記法ブロックの最後の式であれば、<code>pure</code>の呼び出しを排除できると言っています。</p>
<pre><code class="language-hs">do
  x &lt;- expr
  pure x
</code></pre>
<p>右単位元則は、この式は単なる <code>expr</code>と同じだと言っています。</p>
<p><em>左単位元則</em> (left-identity law)
は、もしそれがdo記法ブロックの最初の式であれば、<code>pure</code>の呼び出しを除去できると述べています。</p>
<pre><code class="language-hs">do
  x &lt;- pure y
  next
</code></pre>
<p>このコードは<code>next</code>の名前<code>x</code>を式<code>y</code>で置き換えたものと同じです。</p>
<p>最後の規則は <em>結合則</em> (associativity law)
です。これは入れ子になったdo記法ブロックをどう扱うのかについて教えてくれます。この規則が述べているのは以下のコード片のことです。</p>
<pre><code class="language-hs">c1 = do
  y &lt;- do
    x &lt;- m1
    m2
  m3
</code></pre>
<p>上記のコード片は、次のコードと同じです。</p>
<pre><code class="language-hs">c2 = do
  x &lt;- m1
  y &lt;- m2
  m3
</code></pre>
<p>これらの各計算には3つのモナドの式<code>m1</code>、<code>m2</code>、<code>m3</code>が含まれています。
どちらの場合でも<code>m1</code>の結果は結局は名前<code>x</code>に束縛され、<code>m2</code>の結果は名前<code>y</code>に束縛されます。</p>
<p><code>c1</code>では2つの式<code>m1</code>と<code>m2</code>が各do記法ブロック内にグループ化されています。</p>
<p><code>c2</code>では<code>m1</code>、<code>m2</code>、<code>m3</code>の3つ全ての式が同じdo記法ブロックに現れています。</p>
<p>結合法則は入れ子になったdo記法ブロックをこのように単純化しても問題ないことを言っています。</p>
<p><em>補足</em>：do記法を<code>bind</code>の呼び出しへと脱糖する定義により、 <code>c1</code>と <code>c2</code>は何れも次のコードと同じです。</p>
<pre><code class="language-hs">c3 = do
  x &lt;- m1
  do
    y &lt;- m2
    m3
</code></pre>
<h2 id="モナドで畳み込む"><a class="header" href="#モナドで畳み込む">モナドで畳み込む</a></h2>
<p>抽象的にモナドを扱う例として、この節では <code>Monad</code>型クラス中の任意の型構築子で機能する関数を紹介していきます。
これはモナドによるコードが副作用を伴う「より大きな言語」でのプログラミングと対応しているという直感的理解を補強しますし、モナドによるプログラミングが齎す一般性も示しています。</p>
<p>これから書いていく関数は<code>foldM</code>という名前です。
以前見た<code>foldl</code>関数をモナドの文脈へと一般化するものです。
型シグネチャは以下です。</p>
<pre><code class="language-hs">foldM :: forall m a b. Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; List b -&gt; m a
foldl :: forall   a b.            (a -&gt; b -&gt;   a) -&gt; a -&gt; List b -&gt;   a
</code></pre>
<p>モナド <code>m</code>が現れている点を除いて、 <code>foldl</code>の型と同じであることに注意しましょう。</p>
<p>直感的には、<code>foldM</code>は様々な副作用の組み合わせに対応した文脈で配列を畳み込むものと捉えられます。</p>
<p>例として<code>m</code>として<code>Maybe</code>を選ぶとすると、各段階で<code>Nothing</code>を返すことでこの畳み込みを失敗させられます。
各段階では省略可能な結果を返しますから、それ故畳み込みの結果も省略可能になります。</p>
<p>もし<code>m</code>として型構築子<code>Array</code>を選ぶとすると、畳み込みの各段階で0以上の結果を返せるため、畳み込みは各結果に対して独立に次の手順を継続します。
最後に、結果の集まりは可能な経路の全ての畳み込みから構成されることになります。
これはグラフの走査と対応していますね。</p>
<p><code>foldM</code>を書くには、単に入力のリストについて場合分けをするだけです。</p>
<p>リストが空なら、型 <code>a</code>の結果を生成するための選択肢は1つしかありません。第2引数を返します。</p>
<pre><code class="language-hs">foldM _ a Nil = pure a
</code></pre>
<p>なお、<code>a</code>をモナド <code>m</code>まで持ち上げるために <code>pure</code>を使わなくてはいけません。</p>
<p>リストが空でない場合はどうでしょうか。
その場合、型 <code>a</code>の値、型 <code>b</code>の値、型 <code>a -&gt; b -&gt; m a</code>の関数があります。
もしこの関数を適用すると、型 <code>m a</code>のモナドの結果を手に入れることになります。
この計算の結果を逆向きの矢印 <code>&lt;-</code>で束縛できます。</p>
<p>あとはリストの残りに対して再帰するだけです。実装は簡単です。</p>
<pre><code class="language-hs">foldM f a (b : bs) = do
  a' &lt;- f a b
  foldM f a' bs
</code></pre>
<p>なお、この実装はリストに対する<code>foldl</code>の実装とほとんど同じです。
ただしdo記法である点を除きます。</p>
<p>PSCiでこの関数を定義して試せます。
以下は一例です。
整数の「安全な除算」関数を定義するとします。
0による除算かを確認し、失敗を示すために <code>Maybe</code>型構築子を使うのです。</p>
<pre><code class="language-hs">safeDivide :: Int -&gt; Int -&gt; Maybe Int
safeDivide _ 0 = Nothing
safeDivide a b = Just (a / b)
</code></pre>
<p>これで、 <code>foldM</code>で安全な除算の繰り返しを表現できます。</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.List (fromFoldable)

&gt; foldM safeDivide 100 (fromFoldable [5, 2, 2])
(Just 5)

&gt; foldM safeDivide 100 (fromFoldable [2, 0, 4])
Nothing
</code></pre>
<p>もし何れかの時点で0による除算が試みられたら、<code>foldM safeDivide</code>関数は<code>Nothing</code>を返します。
そうでなければ、累算値を繰り返し除算した結果を<code>Just</code>構築子に包んで返します。</p>
<h2 id="モナドとアプリカティブ"><a class="header" href="#モナドとアプリカティブ">モナドとアプリカティブ</a></h2>
<p>クラス間に上位クラス関係の効能があるため、<code>Monad</code>型クラスの全てのインスタンスは <code>Apply</code>型クラスのインスタンスでもあります。</p>
<p>しかし、あらゆる<code>Monad</code>のインスタンスに「無料で」ついてくる<code>Apply</code>型クラスの実装もあります。これは<code>ap</code>関数により与えられます。</p>
<pre><code class="language-hs">ap :: forall m a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
ap mf ma = do
  f &lt;- mf
  a &lt;- ma
  pure (f a)
</code></pre>
<p>もし<code>m</code>に<code>Monad</code>型クラスの法則の縛りがあれば、<code>ap</code>で与えられる<code>m</code>について妥当な <code>Apply</code>インスタンスが存在します。</p>
<p>興味のある読者はこれまで登場したモナドについてこの<code>ap</code>が<code>apply</code>として充足することを確かめてみてください。
モナドは<code>Array</code>、<code>Maybe</code>、<code>Either e</code>といったものです。</p>
<p>もし全てのモナドがアプリカティブ関手でもあるなら、アプリカティブ関手についての直感的理解を全てのモナドについても適用できるはずです。
特に、モナドが更なる副作用の組み合わせで増強された「より大きな言語」でのプログラミングといろいろな意味で一致することを予想するのはもっともです。
<code>map</code>と <code>apply</code>を使って、引数が任意個の関数をこの新しい言語へと持ち上げることができるはずです。</p>
<p>しかし、モナドはアプリカティブ関手でできること以上ができ、重要な違いはdo記法の構文で強調されています。
<code>userCity</code>の例についてもう一度考えてみましょう。
利用者情報をエンコードしたXML文書から利用者の市町村を検索するものでした。</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p>do記法では2番目の計算が最初の結果 <code>prof</code>に依存し、3番目の計算が2番目の計算の結果<code>addr</code>に依存するというようなことができます。
<code>Applicative</code>型クラスのインターフェイスだけを使うのでは、このように以前の値へ依存できません。</p>
<p><code>pure</code>と <code>apply</code>だけを使って <code>userCity</code>を書こうとしてみれば、これが不可能であることがわかるでしょう。
アプリカティブ関手ができるのは関数の互いに独立した引数を持ち上げることだけですが、モナドはもっと興味深いデータの依存関係に関わる計算を書くことを可能にします。</p>
<p>前の章では<code>Applicative</code>型クラスは並列処理を表現できることを見ました。
持ち上げられた関数の引数は互いに独立していますから、これはまさにその通りです。
<code>Monad</code>型クラスは計算が前の計算の結果に依存できるようになっており、同じようにはなりません。
つまりモナドは副作用を順番に組み合わせなければならないのです。</p>
<h2 id="演習-21"><a class="header" href="#演習-21">演習</a></h2>
<ol>
<li>
<p>（簡単）3つ以上の要素がある配列の3つ目の要素を返す関数<code>third</code>を書いてください。
関数は適切な<code>Maybe</code>型で返します。
<em>手掛かり</em>：<code>arrays</code>パッケージの<code>Data.Array</code>モジュールから<code>head</code>と<code>tail</code>関数の型を見つけ出してください。
これらの関数を組み合わせるには<code>Maybe</code>モナドと共にdo記法を使ってください。</p>
</li>
<li>
<p>（普通）一掴みの硬貨を使ってできる可能な全ての合計を決定する関数 <code>possibleSums</code>を、 <code>foldM</code>を使って書いてみましょう。
入力の硬貨は、硬貨の価値の配列として与えられます。この関数は次のような結果にならなくてはいけません。</p>
<pre><code class="language-text">&gt; possibleSums []
[0]

&gt; possibleSums [1, 2, 10]
[0,1,2,3,10,11,12,13]
</code></pre>
<p><em>手掛かり</em>：<code>foldM</code>を使うと1行でこの関数を書けます。
重複を取り除いたり、結果を並び替えたりするのに、<code>nub</code>関数や<code>sort</code>関数を使うことでしょう。</p>
</li>
<li>
<p>（普通）<code>ap</code>関数と<code>apply</code>演算子が<code>Maybe</code>モナドを充足することを確かめてください。
<em>補足</em>：この演習にはテストがありません。</p>
</li>
<li>
<p>（普通）<code>Maybe</code>型についての<code>Monad</code>インスタンスが、モナド則を満たしていることを検証してください。
このインスタンスは<code>maybe</code>パッケージで定義されています。
<em>補足</em>：この演習にはテストがありません。</p>
</li>
<li>
<p>（普通）リスト上の<code>filter</code>の関数を一般化した関数<code>filterM</code>を書いてください。
この関数は次の型シグネチャを持ちます。</p>
<pre><code class="language-hs">filterM :: forall m a. Monad m =&gt; (a -&gt; m Boolean) -&gt; List a -&gt; m (List a)
</code></pre>
</li>
<li>
<p>（難しい）全てのモナドには次で与えられるような既定の<code>Functor</code>インスタンスがあります。</p>
<pre><code class="language-hs">map f a = do
  x &lt;- a
  pure (f x)
</code></pre>
<p>モナド則を使って、全てのモナドが次を満たすことを証明してください。</p>
<pre><code class="language-hs">lift2 f (pure a) (pure b) = pure (f a b)
</code></pre>
<p>ここで、<code>Applly</code>インスタンスは上で定義された<code>ap</code>関数を使用しています。
<code>lift2</code>が次のように定義されていたことを思い出してください。</p>
<pre><code class="language-hs">lift2 :: forall f a b c. Apply f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
lift2 f a b = f &lt;$&gt; a &lt;*&gt; b
</code></pre>
<p><em>補足</em>：この演習にはテストがありません。</p>
</li>
</ol>
<h2 id="ネイティブな作用"><a class="header" href="#ネイティブな作用">ネイティブな作用</a></h2>
<p>ここではPureScriptで中心的な重要性のあるモナドの1つ、<code>Effect</code>モナドについて見ていきます。</p>
<p><code>Effect</code>モナドは <code>Effect</code>モジュールで定義されています。かつてはいわゆる <em>ネイティブ</em>
副作用を管理していました。Haskellに馴染みがあれば、これは<code>IO</code>モナドと同等のものです。</p>
<p>ネイティブな副作用とは何でしょうか。
この副作用はPureScript特有の式とJavaScriptの式とを2分するものです。
PureScriptの式は概して副作用とは無縁なのです。
ネイティブな作用の例を以下に示します。</p>
<ul>
<li>コンソール入出力</li>
<li>乱数生成</li>
<li>例外</li>
<li>変更可能な状態の読み書き</li>
</ul>
<p>また、ブラウザでは次のようなものがあります。</p>
<ul>
<li>DOM操作</li>
<li>XMLHttpRequest / AJAX呼び出し</li>
<li>WebSocketによる相互作用</li>
<li>Local Storageの読み書き</li>
</ul>
<p>既に「ネイティブでない」副作用の例については数多く見てきています。</p>
<ul>
<li><code>Maybe</code>データ型で表現される省略可能な値</li>
<li><code>Either</code>データ型で表現されるエラー</li>
<li>配列やリストで表現される多値関数</li>
</ul>
<p>これらの区別はわかりにくいので注意してください。
例えば、エラー文言は例外の形でJavaScriptの式の副作用となることがあると言えます。
その意味では例外はネイティブな副作用を表していて、<code>Effect</code>を使用して表現できます。
しかし、<code>Either</code>を使用して実装されたエラー文言はJavaScript実行時の副作用ではなく、<code>Effect</code>を使うスタイルでエラー文言を実装するのは不適切です。
そのため、ネイティブなのは作用自体というより、実行時にどのように実装されているかです。</p>
<h2 id="副作用と純粋性"><a class="header" href="#副作用と純粋性">副作用と純粋性</a></h2>
<p>PureScriptのような純粋な言語では、ある疑問が浮かんできます。
副作用がないなら、どうやって役に立つ実際のコードを書くことができるのでしょうか。</p>
<p>その答えはPureScriptの目的は副作用を排除することではないということです。
純粋な計算と副作用のある計算とを、型システムにおいて区別できるような方法で表現します。
この意味で、言語はあくまで純粋なのです。</p>
<p>副作用のある値は、純粋な値とは異なる型を持っています。
そういうわけで、例えば副作用のある引数を関数に渡すことはできず、予期せず副作用を持つようなことが起こらなくなります。</p>
<p><code>Effect</code>モナドで管理された副作用を現す手段は、型<code>Effect a</code>の計算をJavaScriptから実行することです。</p>
<p>Spagoビルドツール（や他のツール）は早道を用意しており、アプリケーションの起動時に<code>main</code>計算を呼び出すための追加のJavaScriptコードを生成します。
<code>main</code>は<code>Effect</code>モナドでの計算であることが要求されます。</p>
<h2 id="作用モナド-1"><a class="header" href="#作用モナド-1">作用モナド</a></h2>
<p><code>Effect</code>は副作用のある計算を充分に型付けするAPIを提供すると同時に、効率的なJavaScriptを生成します。</p>
<p>馴染みのある<code>log</code>関数から返る型を見てみましょう。
<code>Effect</code>はこの関数がネイティブな作用を生み出すことを示しており、この場合はコンソールIOです。</p>
<p><code>Unit</code>はいかなる<em>意味のある</em>データも返らないことを示しています。
<code>Unit</code>はC、Javaなど他の言語での<code>void</code>キーワードと似たものとして考えられます。</p>
<pre><code class="language-hs">log :: String -&gt; Effect Unit
</code></pre>
<blockquote>
<p><em>余談</em> ：より一般的な（そしてより込み入った型を持つ）<code>Effect.Class.Console</code>の<code>log</code>関数をIDEから提案されるかもしれません。
これは基本的な<code>Effect</code>モナドを扱う際は<code>Effect.Console</code>からの関数と交換可能です。
より一般的なバージョンがあることの理由は「モナドな冒険」章の「モナド変換子」について読んだあとにより明らかになっていることでしょう。
好奇心のある（そしてせっかちな）読者のために言うと、これは<code>Effect</code>に<code>MonadEffect</code>インスタンスがあるから機能するのです。</p>
<pre><code class="language-hs">log :: forall m. MonadEffect m =&gt; String -&gt; m Unit
</code></pre>
</blockquote>
<p>それでは意味のあるデータを返す<code>Effect</code>を考えましょう。
<code>Effect.Random</code>の<code>random</code>関数は乱択された<code>Number</code>を生み出します。</p>
<pre><code class="language-hs">random :: Effect Number
</code></pre>
<p>以下は完全なプログラムの例です（この章の演習フォルダの<code>test/Random.purs</code>にあります）。</p>
<pre><code class="language-hs">module Test.Random where

import Prelude
import Effect (Effect)
import Effect.Random (random)
import Effect.Console (logShow)

main :: Effect Unit
main = do
  n &lt;- random
  logShow n
</code></pre>
<p><code>Effect</code>はモナドなので、do記法を使って含まれるデータを開封し、それからこのデータを作用のある<code>logShow</code>関数に渡します。
気分転換に、以下は<code>bind</code>演算子を使って書かれた同等なコードです。</p>
<pre><code class="language-hs">main :: Effect Unit
main = random &gt;&gt;= logShow
</code></pre>
<p>これを手元で走らせてみてください。</p>
<pre><code class="language-shell">spago run --main Test.Random
</code></pre>
<p>コンソールに出力 <code>0.0</code>と <code>1.0</code>の間で無作為に選ばれた数が表示されるでしょう。</p>
<blockquote>
<p>余談：<code>spago run</code>は既定で<code>main</code>関数を<code>Main</code>モジュールの中から探索します。
<code>--main</code>フラグで代替のモジュールを入口として指定することも可能で、上の例ではそうしています。
この代替のモジュールにも<code>main</code>関数が含まれているようにはしてください。</p>
</blockquote>
<p>なお、不浄な作用付きのコードに訴えることなく、「乱択された」（技術的には疑似乱択された）データも生成できます。
この技法は「テストを生成する」章で押さえます。</p>
<p>以前言及したように<code>Effect</code>モナドはPureScriptで核心的な重要さがあります。
なぜ核心かというと、それはPureScriptの<code>外部関数インターフェース</code>とやり取りする上での常套手段だからです。
<code>外部関数インターフェース</code>はプログラムを実行したり副作用を発生させたりする仕組みを提供します。
<code>外部関数インターフェース</code>を使うことは避けるのが望ましいのですが、どのように動作しどう使うのか理解することもまた極めて大事なことですので、実際にPureScriptで何か動かす前にその章を読まれることをお勧めします。
要は<code>Effect</code>モナドは結構単純なのです。
幾つかの補助関数がありますが、副作用を内包すること以外には大したことはしません。</p>
<h2 id="例外"><a class="header" href="#例外">例外</a></h2>
<p>2つの<em>ネイティブな</em>副作用が絡む<code>node-fs</code>パッケージの関数を調べましょう。
ここでの副作用は可変状態の読み取りと例外です。</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; String -&gt; Effect String
</code></pre>
<p>もし存在しないファイルを読もうとすると……</p>
<pre><code class="language-hs">import Node.Encoding (Encoding(..))
import Node.FS.Sync (readTextFile)

main :: Effect Unit
main = do
  lines &lt;- readTextFile UTF8 &quot;iDoNotExist.md&quot;
  log lines
</code></pre>
<p>以下の例外に遭遇します。</p>
<pre><code class="language-text">    throw err;
    ^
Error: ENOENT: no such file or directory, open 'iDoNotExist.md'
...
  errno: -2,
  syscall: 'open',
  code: 'ENOENT',
  path: 'iDoNotExist.md'
</code></pre>
<p>この例外をうまく管理するには、潜在的に問題があるコードを<code>try</code>に包めばどのような出力でも制御できます。</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  result &lt;- try $ readTextFile UTF8 &quot;iDoNotExist.md&quot;
  case result of
    Right lines -&gt; log $ &quot;Contents: \n&quot; &lt;&gt; lines
    Left  error -&gt; log $ &quot;Couldn't open file. Error was: &quot; &lt;&gt; message error
</code></pre>
<p><code>try</code>は<code>Effect</code>を走らせて起こりうる例外を<code>Left</code>値として返します。
もし計算が成功すれば結果は<code>Right</code>に包まれます。</p>
<pre><code class="language-hs">try :: forall a. Effect a -&gt; Effect (Either Error a)
</code></pre>
<p>独自の例外も生成できます。
以下は<code>Data.List.head</code>の代替実装で、<code>Maybe</code>の値の<code>Nothing</code>を返す代わりにリストが空のとき例外を投げます。</p>
<pre><code class="language-hs">exceptionHead :: List Int -&gt; Effect Int
exceptionHead l = case l of
  x : _ -&gt; pure x
  Nil -&gt; throwException $ error &quot;empty list&quot;
</code></pre>
<p>ただし<code>exceptionHead</code>関数はどこかしら非実用的な例です。
というのも、PureScriptのコードで例外を生成するのは避け、代わりに<code>Either</code>や<code>Maybe</code>のようなネイティブでない作用でエラーや欠けた値を使うのが一番だからです。</p>
<h2 id="可変状態"><a class="header" href="#可変状態">可変状態</a></h2>
<p>中核ライブラリには <code>ST</code>作用という、これまた別の作用も定義されています。</p>
<p><code>ST</code>作用は変更可能な状態を操作するために使われます。
純粋関数プログラミングを知っているなら、共有される変更可能な状態は問題を引き起こしやすいということも知っているでしょう。
しかし、<code>ST</code>作用は型システムを使って安全で<em>局所的な</em>状態変化を可能にし、状態の共有を制限するのです。</p>
<p><code>ST</code>作用は <code>Control.Monad.ST</code>モジュールで定義されています。
この挙動を確認するには、その動作の型を見る必要があります。</p>
<pre><code class="language-hs">new :: forall a r. a -&gt; ST r (STRef r a)

read :: forall a r. STRef r a -&gt; ST r a

write :: forall a r. a -&gt; STRef r a -&gt; ST r a

modify :: forall r a. (a -&gt; a) -&gt; STRef r a -&gt; ST r a
</code></pre>
<p><code>new</code>は型<code>STRef r a</code>の可変参照領域を新規作成するのに使われます。
この領域は<code>read</code>動作を使って読み取ったり、<code>write</code>動作や<code>modify</code>動作で状態を変更するのに使えます。
型<code>a</code>は領域に格納された値の型を、型<code>r</code>は<em>メモリ領域</em>（または<em>ヒープ</em>）を、それぞれ型システムで表しています。</p>
<p>例を示します。
重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。
これには小さな時間刻みで簡単な更新関数の実行を何度も繰り返します。</p>
<p>粒子の位置と速度を保持する変更可能な参照領域を作成し、領域に格納された値を更新するのにforループを使うことでこれを実現できます。</p>
<pre><code class="language-hs">import Prelude

import Control.Monad.ST.Ref (modify, new, read)
import Control.Monad.ST (ST, for, run)

simulate :: forall r. Number -&gt; Number -&gt; Int -&gt; ST r Number
simulate x0 v0 time = do
  ref &lt;- new { x: x0, v: v0 }
  for 0 (time * 1000) \_ -&gt;
    modify
      ( \o -&gt;
          { v: o.v - 9.81 * 0.001
          , x: o.x + o.v * 0.001
          }
      )
      ref
  final &lt;- read ref
  pure final.x
</code></pre>
<p>計算の最後では、参照領域の最終的な値を読み取り、粒子の位置を返しています。</p>
<p>なお、この関数が変更可能な状態を使っていても、その参照領域<code>ref</code>がプログラムの他の部分での使用が許されない限り、これは純粋な関数のままです。
このことが正に<code>ST</code>作用が禁止するものであることを見ていきます。</p>
<p><code>ST</code>作用付きで計算するには、<code>run</code>関数を使用する必要があります。</p>
<pre><code class="language-hs">run :: forall a. (forall r. ST r a) -&gt; a
</code></pre>
<p>ここで注目して欲しいのは、領域型 <code>r</code>が関数矢印の左辺にある<em>括弧の内側で</em>量化されているということです。
<code>run</code>に渡したどんな動作でも、<em>任意の領域</em><code>r</code>が何であれ動作するということを意味しています。</p>
<p>しかし、ひとたび参照領域が<code>new</code>によって作成されると、その領域の型は既に固定されており、<code>run</code>によって限定されたコードの外側で参照領域を使おうとしても型エラーになるでしょう。
<code>run</code>が安全に<code>ST</code>作用を除去でき、<code>simulate</code>を純粋関数にできるのはこれが理由なのです。</p>
<pre><code class="language-hs">simulate' :: Number -&gt; Number -&gt; Int -&gt; Number
simulate' x0 v0 time = run (simulate x0 v0 time)
</code></pre>
<p>PSCiでもこの関数を実行してみることができます。</p>
<pre><code class="language-text">&gt; import Main

&gt; simulate' 100.0 0.0 0
100.00

&gt; simulate' 100.0 0.0 1
95.10

&gt; simulate' 100.0 0.0 2
80.39

&gt; simulate' 100.0 0.0 3
55.87

&gt; simulate' 100.0 0.0 4
21.54
</code></pre>
<p>実は、もし <code>simulate</code>の定義を <code>run</code>の呼び出しのところへ埋め込むとすると、次のようになります。</p>
<pre><code class="language-hs">simulate :: Number -&gt; Number -&gt; Int -&gt; Number
simulate x0 v0 time =
  run do
    ref &lt;- new { x: x0, v: v0 }
    for 0 (time * 1000) \_ -&gt;
      modify
        ( \o -&gt;
            { v: o.v - 9.81 * 0.001
            , x: o.x + o.v * 0.001
            }
        )
        ref
    final &lt;- read ref
    pure final.x
</code></pre>
<p>そうして、参照領域はそのスコープから逃れられないことと、安全に<code>ref</code>を<code>var</code>に変換できることにコンパイラが気付きます。
<code>run</code>が埋め込まれた<code>simulate</code>に対して生成されたJavaScriptは次のようになります。</p>
<pre><code class="language-javascript">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return (function __do() {

        var ref = { value: { x: x0, v: v0 } };

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        return ref.value.x;

      })();
    };
  };
};
</code></pre>
<blockquote>
<p>なお、この結果として得られたJavaScriptは最適化の余地があります。
詳細は<a href="https://github.com/purescript-contrib/purescript-book/issues/121">こちらの課題</a>を参照してください。
上記の抜粋はそちらの課題が解決されたら更新されるでしょう。</p>
</blockquote>
<p>比較としてこちらが埋め込まれていない形式で生成されたJavaScriptです。</p>
<pre><code class="language-js">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return function __do() {

        var ref = Control_Monad_ST_Internal[&quot;new&quot;]({ x: x0, v: v0 })();

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        var $$final = Control_Monad_ST_Internal.read(ref)();
        return $$final.x;
      };
    };
  };
};
</code></pre>
<p>局所的な変更可能状態を扱うとき、<code>ST</code>作用は短いJavaScriptを生成する良い方法となります。
作用を持つ繰り返しを生成する<code>for</code>、<code>foreach</code>、<code>while</code>のような動作を一緒に使うときは特にそうです。</p>
<h2 id="演習-22"><a class="header" href="#演習-22">演習</a></h2>
<ol>
<li>（普通）<code>safeDivide</code>関数を書き直し、もし分母がゼロなら<code>throwException</code>を使って文言<code>&quot;div zero&quot;</code>の例外を投げるようにしたものを<code>exceptionDivide</code>としてください。</li>
<li>（普通）関数<code>estimatePi :: Int -&gt; Number</code>を書いてください。
この関数は<code>n</code>項<a href="https://mathworld.wolfram.com/GregorySeries.html">Gregory
Series</a>を使って<code>pi</code>の近似を計算するものです。
<em>手掛かり</em>：解答は上記の<code>simulate</code>の定義に倣うことができます。
また<code>Data.Int</code>の<code>toNumber :: Int -&gt; Number</code>を使って、<code>Int</code>を<code>Number</code>に変換する必要があるかもしれません。</li>
<li>（普通）<code>n</code>番目のフィボナッチ数を計算する関数<code>fibonacci :: Int -&gt; Int</code>を書いてください。
<code>ST</code>を使って前2つのフィボナッチ数の値を把握します。
PSCiを使い、<code>ST</code>に基づく新しい実装の実行速度を第5章の再帰による実装と比較してください。</li>
</ol>
<h2 id="dom作用"><a class="header" href="#dom作用">DOM作用</a></h2>
<p>この章の最後の節では、<code>Effect</code>モナドでの作用についてこれまで学んだことを、実際のDOM操作の問題に応用します。</p>
<p>DOMを直接扱ったり、オープンソースのDOMライブラリを扱ったりするPureScriptパッケージが沢山あります。
例えば以下です。</p>
<ul>
<li><a href="https://github.com/purescript-web/purescript-web-dom"><code>web-dom</code></a>はW3CのDOM規格に向けた型定義と低水準インターフェース実装を提供します。</li>
<li><a href="https://github.com/purescript-web/purescript-web-html"><code>web-html</code></a>はW3CのHTML5規格に向けた型定義と低水準インターフェース実装を提供します。</li>
<li><a href="http://github.com/paf31/purescript-jquery"><code>jquery</code></a>は<a href="http://jquery.org">jQuery</a>ライブラリのバインディングの集まりです。</li>
</ul>
<p>上記のライブラリを土台に抽象化を進めたPureScriptライブラリもあります。
以下のようなものです。</p>
<ul>
<li><a href="https://github.com/paf31/purescript-thermite"><code>thermite</code></a>は<a href="https://github.com/purescript-contrib/purescript-react"><code>react</code></a>を土台に構築されています。</li>
<li><a href="https://github.com/megamaddu/purescript-react-basic-hooks"><code>react-basic-hooks</code></a>は<a href="https://github.com/lumihq/purescript-react-basic"><code>react-basic</code></a>を土台に構築されています。</li>
<li><a href="https://github.com/purescript-halogen/purescript-halogen"><code>halogen</code></a>は独自の仮想DOMライブラリを土台とする型安全な一揃いの抽象化を提供します。</li>
</ul>
<p>この章では
<code>react-basic-hooks</code>ライブラリを使用し、住所簿アプリケーションにユーザーインターフェイスを追加しますが、興味のあるユーザは異なるアプローチで進めることをお勧めします。</p>
<h2 id="住所録のユーザーインターフェース"><a class="header" href="#住所録のユーザーインターフェース">住所録のユーザーインターフェース</a></h2>
<p><code>react-basic-hooks</code>ライブラリを使い、アプリケーションをReact<em>コンポーネント</em>として定義していきます。ReactコンポーネントはHTML要素を純粋なデータ構造としてコードで記述します。それからこのデータ構造は効率的にDOMへ描画されます。加えてコンポーネントはボタンクリックのようなイベントに応答できます。<code>react-basic-hooks</code>ライブラリは<code>Effect</code>モナドを使ってこれらのイベントの制御方法を記述します。</p>
<p>Reactライブラリの完全な入門はこの章の範囲をはるかに超えていますが、読者は必要に応じて説明書を参照することをお勧めします。
目的に応じて、Reactは <code>Effect</code>モナドの実用的な例を提供してくれます。</p>
<p>利用者が住所録に新しい項目を追加できるフォームを構築することにしましょう。
フォームには、様々なフィールド（姓、名、市町村、州など）のテキストボックス、及び検証エラーが表示される領域が含まれます。
テキストボックスに利用者がテキストを入力する度に、検証エラーが更新されます。</p>
<p>簡潔さを保つために、フォームは固定の形状とします。電話番号は種類（自宅、携帯電話、仕事、その他）ごとに別々のテキストボックスへ分けることにします。</p>
<p><code>exercises/chapter8</code>ディレクトリから以下のコマンドでwebアプリを立ち上げることができます。</p>
<pre><code class="language-shell">$ npm install
$ npx spago build
$ npx parcel src/index.html --open
</code></pre>
<p>もし<code>spago</code>や<code>parcel</code>のような開発ツールが大域的にインストールされていれば、<code>npx</code>の前置は省けるでしょう。
恐らく既に<code>spago</code>を<code>npm i -g spago</code>で大域的にインストールしていますし、<code>parcel</code>についても同じことができるでしょう。</p>
<p><code>parcel</code>は「住所録」アプリのブラウザ窓を立ち上げます。
<code>parcel</code>の端末を開いたままにし、他の端末で<code>spago</code>で再構築すると、最新の編集を含むページが自動的に再読み込みされるでしょう。
また、<a href="https://github.com/purescript/purescript/tree/master/psc-ide"><code>purs ide</code></a>に対応していたり<a href="https://github.com/kRITZCREEK/pscid"><code>pscid</code></a>を走らせていたりする<a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors">エディタ</a>を使っていれば、ファイルを保存したときに自動的にページが再構築される（そして自動的にページが再読み込みされる）ように設定できます。</p>
<p>この住所録アプリでフォームフィールドにいろいろな値を入力すると、ページ上で出力された検証エラーが見られます。</p>
<p>動作の仕組みを散策しましょう。</p>
<p><code>src/index.html</code>ファイルは最小限です。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Address Book&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>&lt;script</code>の行にJavaScriptの入口が含まれており、<code>index.js</code>にはこの実質1行だけが含まれています。</p>
<pre><code class="language-js">import { main } from &quot;../output/Main/index.js&quot;;

main();
</code></pre>
<p><code>module Main</code> (<code>src/main.purs</code>) の<code>main</code>関数と等価な、生成したJavaScriptを呼び出しています。
<code>spago build</code>は生成された全てのJavaScriptを<code>output</code>ディレクトリに置くことを思い出してください。</p>
<p><code>main</code>関数はDOMとHTML APIを使い、<code>index.html</code>に定義した<code>container</code>要素の中に住所録コンポーネントを描画します。</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  log &quot;Rendering address book component&quot;
  -- Get window object
  w &lt;- window
  -- Get window's HTML document
  doc &lt;- document w
  -- Get &quot;container&quot; element in HTML
  ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
  case ctr of
    Nothing -&gt; throw &quot;Container element not found.&quot;
    Just c -&gt; do
      -- Create AddressBook react component
      addressBookApp &lt;- mkAddressBookApp
      let
        -- Create JSX node from react component. Pass-in empty props
        app = element addressBookApp {}
      -- Render AddressBook JSX node in DOM &quot;container&quot; element
      D.render app c
</code></pre>
<p>これら3行に注目してください。</p>
<pre><code class="language-hs">w &lt;- window
doc &lt;- document w
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>これは次のように統合できます。</p>
<pre><code class="language-hs">doc &lt;- document =&lt;&lt; window
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>あるいは更なる統合さえできます。</p>
<pre><code class="language-hs">ctr &lt;- getElementById &quot;container&quot; &lt;&lt;&lt; toNonElementParentNode =&lt;&lt; document =&lt;&lt; window
-- or, equivalently:
ctr &lt;- window &gt;&gt;= document &gt;&gt;= toNonElementParentNode &gt;&gt;&gt; getElementById &quot;container&quot;
</code></pre>
<p>途中の<code>w</code>や<code>doc</code>変数が読みやすさの助けになるかは主観的な好みの問題です。</p>
<p>AddressBookの<code>reactComponent</code>を深堀りしましょう。
単純化されたコンポーネントから始め、それから<code>Main.purs</code>で実際のコードに構築していきます。</p>
<p>以下の最小限のコンポーネントをご覧ください。
遠慮なく全体のコンポーネントをこれに置き換えて実行の様子を見てみましょう。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp =
  reactComponent
    &quot;AddressBookApp&quot;
    (\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;)
</code></pre>
<p><code>reactComponent</code>にはこのような威圧的なシグネチャがあります。</p>
<pre><code class="language-hs">reactComponent ::
  forall hooks props.
  Lacks &quot;children&quot; props =&gt;
  Lacks &quot;key&quot; props =&gt;
  Lacks &quot;ref&quot; props =&gt;
  String -&gt;
  ({ | props } -&gt; Render Unit hooks JSX) -&gt;
  Effect (ReactComponent { | props })
</code></pre>
<p>重要な注意点は全ての型クラス制約の後の引数にあります。
<code>String</code>（任意のコンポーネント名）、<code>props</code>を描画された<code>JSX</code>に変換する方法を記述する関数を取り、そして<code>Effect</code>に包まれた<code>ReactComponent</code>を返します。</p>
<p>propsからJSXへの関数は単にこうです。</p>
<pre><code class="language-hs">\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;
</code></pre>
<p><code>props</code>は無視されており、<code>D.text</code>は<code>JSX</code>を返し、そして<code>pure</code>は描画されたJSXに持ち上げます。
これで<code>component</code>には<code>ReactComponent</code>を生成するのに必要な全てがあります。</p>
<p>次に、完全な住所録コンポーネントにある幾つかの複雑な事柄を調べていきます。</p>
<p>これらは完全なコンポーネントの最初の数行です。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp = do
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p><code>person</code>を<code>useState</code>フックの状態の一部として追跡します。</p>
<pre><code class="language-hs">Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p>なお、複数回<code>useState</code>を呼び出すことで、コンポーネントの状態を複数の状態の部品に分解することが自在にできます。
例えば<code>Person</code>の各レコードフィールドについて分離した状態の部品を使って、このアプリを書き直すことができるでしょう。
しかしこの場合にそうすると僅かに利便性を損なうアーキテクチャになってしまいます。</p>
<p>他の例では<code>Tuple</code>用の<code>/\</code>中置演算子に出喰わすかもしれません。
これは先の行と等しいものです。</p>
<pre><code class="language-hs">firstName /\ setFirstName &lt;- useState p.firstName
</code></pre>
<p><code>useState</code>は、既定の初期値を取って現在の値と値を更新する方法を取ります。
<code>useState</code>の型を確認すれば型<code>person</code>と<code>setPerson</code>についてより深い洞察が得られます。</p>
<pre><code class="language-hs">useState ::
  forall state.
  state -&gt;
  Hook (UseState state) (Tuple state ((state -&gt; state) -&gt; Effect Unit))
</code></pre>
<p>結果の値の梱包<code>Hook (UseState state)</code>は取り去ることができますが、それは<code>useState</code>が<code>R.do</code>ブロックの中で呼ばれているからです。
<code>R.do</code>は後で詳述します。</p>
<p>さてこれで以下のシグネチャを観察できます。</p>
<pre><code class="language-hs">person :: state
setPerson :: (state -&gt; state) -&gt; Effect Unit
</code></pre>
<p><code>state</code>の限定された型は初期の既定値によって決定されます。
これは<code>examplePerson</code>の型なのでこの場合は<code>Person</code> <code>Record</code>です。</p>
<p><code>person</code>は各再描画の時点で現在の状態にアクセスする方法です。</p>
<p><code>setPerson</code>は状態を更新する方法です。
単に現在の状態を新しい状態に変形する方法を記述する関数を提供します。
<code>state</code>の型が偶然<code>Record</code>のときは、レコード更新構文がこれにぴったり合います。
例えば以下。</p>
<pre><code class="language-hs">setPerson (\currentPerson -&gt; currentPerson {firstName = &quot;NewName&quot;})

</code></pre>
<p>あるいは短かく以下です。</p>
<pre><code class="language-hs">setPerson _ {firstName = &quot;NewName&quot;}
</code></pre>
<p><code>Record</code>でない状態もまた、この更新パターンに従います。
ベストプラクティスについて、より詳しいことは<a href="https://github.com/megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541">この手引き</a>を参照してください。</p>
<p><code>useState</code>が<code>R.do</code>ブロックの中で使われていることを思い出しましょう。
<code>R.do</code>は<code>do</code>の特別なreactフックの派生です。
<code>R.</code>の前置はこれが<code>React.Basic.Hooks</code>から来たものとして「限定する」もので、<code>R.do</code>ブロックの中でフック互換版の<code>bind</code>を使うことを意味しています。
これは「限定されたdo」として知られています。
<code>Hook (UseState state)</code>の梱包を無視し、内部の値の<code>Tuple</code>と変数に束縛してくれます。</p>
<p>他の状態管理戦略として挙げられるのは<code>useReducer</code>ですが、それはこの章の範疇外です。</p>
<p>以下では<code>JSX</code>の描画が行われています。</p>
<pre><code class="language-hs">pure
  $ D.div
      { className: &quot;container&quot;
      , children:
          renderValidationErrors errors
            &lt;&gt; [ D.div
                  { className: &quot;row&quot;
                  , children:
                      [ D.form_
                          $ [ D.h3_ [ D.text &quot;Basic Information&quot; ]
                            , formField &quot;First Name&quot; &quot;First Name&quot; person.firstName \s -&gt;
                                setPerson _ { firstName = s }
                            , formField &quot;Last Name&quot; &quot;Last Name&quot; person.lastName \s -&gt;
                                setPerson _ { lastName = s }
                            , D.h3_ [ D.text &quot;Address&quot; ]
                            , formField &quot;Street&quot; &quot;Street&quot; person.homeAddress.street \s -&gt;
                                setPerson _ { homeAddress { street = s } }
                            , formField &quot;City&quot; &quot;City&quot; person.homeAddress.city \s -&gt;
                                setPerson _ { homeAddress { city = s } }
                            , formField &quot;State&quot; &quot;State&quot; person.homeAddress.state \s -&gt;
                                setPerson _ { homeAddress { state = s } }
                            , D.h3_ [ D.text &quot;Contact Information&quot; ]
                            ]
                          &lt;&gt; renderPhoneNumbers
                      ]
                  }
              ]
      }
</code></pre>
<p>ここでDOMの意図した状態を表現する<code>JSX</code>を生成しています。
このJSXは単一のHTML要素を作るHTMLタグ（例：<code>div</code>、<code>form</code>、<code>h3</code>、<code>li</code>、<code>ul</code>、<code>label</code>、<code>input</code>）に対応する関数を適用することで作られるのが普通です。
これらのHTML要素はそれ自体がReactコンポーネントであり、JSXに変換されます。
通常これらの関数にはそれぞれ3つの種類があります。</p>
<ul>
<li><code>div_</code>: 子要素の配列を受け付けます。
既定の属性を使います。</li>
<li><code>div</code>: 属性の<code>Record</code>を受け付けます。
子要素の配列をこのレコードの<code>children</code>フィールドに渡すことができます。</li>
<li><code>div'</code>: <code>div</code>と同じですが、<code>JSX</code>に変換する前に<code>ReactComponent</code>を返します。</li>
</ul>
<p>検証エラーをフォームの一番上に（もしあれば）表示するため、<code>Errors</code>構造体をJSXの配列に変える<code>renderValidationErrors</code>補助関数を作ります。この配列はフォームの残り部分の手前に付けます。</p>
<pre><code class="language-hs">renderValidationErrors :: Errors -&gt; Array R.JSX
renderValidationErrors [] = []
renderValidationErrors xs =
  let
    renderError :: String -&gt; R.JSX
    renderError err = D.li_ [ D.text err ]
  in
    [ D.div
        { className: &quot;alert alert-danger row&quot;
        , children: [ D.ul_ (map renderError xs) ]
        }
    ]
</code></pre>
<p>なお、ここでは単に通常のデータ構造体を操作しているので、<code>map</code>のような関数を使ってもっと面白い要素を構築できます。</p>
<pre><code class="language-hs">children: [ D.ul_ (map renderError xs)]
</code></pre>
<p><code>className</code>プロパティを使ってCSSスタイルのクラスを定義します。
このプロジェクトでは<a href="https://getbootstrap.com/">Bootstrap</a>の<code>stylesheet</code>を使っており、これは<code>index.html</code>でインポートされています。
例えばフォーム中のアイテムは<code>row</code>として配置されてほしいですし、検証エラーは<code>alert-danger</code>の装飾で強調されていてほしいです。</p>
<pre><code class="language-hs">className: &quot;alert alert-danger row&quot;
</code></pre>
<p>2番目の補助関数は <code>formField</code>です。
これは、単一フォームフィールドのテキスト入力を作ります。</p>
<pre><code class="language-hs">formField :: String -&gt; String -&gt; String -&gt; (String -&gt; Effect Unit) -&gt; R.JSX
formField name placeholder value setValue =
  D.div
    { className: &quot;form-group row&quot;
    , children:
        [ D.label
            { className: &quot;col-sm col-form-label&quot;
            , htmlFor: name
            , children: [ D.text name ]
            }
        , D.div
            { className: &quot;col-sm&quot;
            , children:
                [ D.input
                    { className: &quot;form-control&quot;
                    , id: name
                    , placeholder
                    , value
                    , onChange:
                        let
                          handleValue :: Maybe String -&gt; Effect Unit
                          handleValue (Just v) = setValue v
                          handleValue Nothing  = pure unit
                        in
                          handler targetValue handleValue
                    }
                ]
            }
        ]
    }
</code></pre>
<p><code>input</code>を置いて<code>label</code>の中に<code>text</code>を表示すると、スクリーンリーダーのアクセシビリティの助けになります。</p>
<p><code>onChange</code>属性があれば利用者の入力に応答する方法を記述できます。<code>handler</code>関数を使いますが、これは以下の型を持ちます。</p>
<pre><code class="language-hs">handler :: forall a. EventFn SyntheticEvent a -&gt; (a -&gt; Effect Unit) -&gt; EventHandler
</code></pre>
<p><code>handler</code>への最初の引数には<code>targetValue</code>を使いますが、これはHTMLの<code>input</code>要素中のテキストの値を提供します。
この場合は型変数<code>a</code>が<code>Maybe String</code>で、<code>handler</code>が期待するシグネチャに合致しています。</p>
<pre><code class="language-hs">targetValue :: EventFn SyntheticEvent (Maybe String)
</code></pre>
<p>JavaScriptでは<code>input</code>要素の<code>onChange</code>イベントには<code>String</code>値が伴います。
しかし、JavaScriptの文字列はnullになり得るので、安全のために<code>Maybe</code>が使われています。</p>
<p>したがって<code>(a -&gt; Effect Unit)</code>の<code>handler</code>への2つ目の引数は、このシグネチャを持ちます。</p>
<pre><code class="language-hs">Maybe String -&gt; Effect Unit
</code></pre>
<p>この関数は<code>Maybe String</code>値を求める作用に変換する方法を記述します。
この目的のために以下のように独自の<code>handleValue</code>関数を定義して<code>handler</code>を渡します。</p>
<pre><code class="language-hs">onChange:
  let
    handleValue :: Maybe String -&gt; Effect Unit
    handleValue (Just v) = setValue v
    handleValue Nothing  = pure unit
  in
    handler targetValue handleValue
</code></pre>
<p><code>setValue</code>は<code>formField</code>の各呼び出しに与えた関数で、文字列を取り<code>setPerson</code>フックに適切なレコード更新呼び出しを実施します。</p>
<p>なお、<code>handleValue</code>は以下のようにも置き換えられます。</p>
<pre><code class="language-hs">onChange: handler targetValue $ traverse_ setValue
</code></pre>
<p><code>traverse_</code>の定義を調査して、両方の形式が確かに等価であることをご確認ください。</p>
<p>これでコンポーネント実装の基本を押さえました。
しかし、コンポーネントの仕組みを完全に理解するためには、この章に付随するソースをお読みください。</p>
<p>明らかに、このユーザーインターフェースには改善すべき点が沢山あります。
演習ではアプリケーションがより使いやすくなるような方法を追究していきます。</p>
<h2 id="演習-23"><a class="header" href="#演習-23">演習</a></h2>
<p>以下の演習では<code>src/Main.purs</code>を変更してください。
これらの演習には単体試験はありません。</p>
<ol>
<li>
<p>（簡単）このアプリケーションを変更し、職場の電話番号を入力できるテキストボックスを追加してください。</p>
</li>
<li>
<p>（普通）現時点でアプリケーションは検証エラーを単一の「pink-alert」背景に集めて表示させています。
空行で分離することにより、各検証エラーにpink-alert背景を持たせるように変更してください。</p>
<p><em>手掛かり</em>：リスト中の検証エラーを表示するのに<code>ul</code>要素を使う代わりに、コードを変更し、各エラーに<code>alert</code>と<code>alert-danger</code>装飾を持つ<code>div</code>を作ってください。</p>
</li>
<li>
<p>（難しい、発展）このユーザーインターフェイスの問題の1つは、検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。
コードを変更してこの問題を解決してください。</p>
<p><em>手掛かり</em>：検証器によって返されるエラーの型を、エラーの原因となっているフィールドを示すために拡張するべきです。
以下の変更されたエラー型を使うと良いでしょう。</p>
<pre><code class="language-hs">data Field = FirstNameField
           | LastNameField
           | StreetField
           | CityField
           | StateField
           | PhoneField PhoneType

data ValidationError = ValidationError String Field

type Errors = Array ValidationError
</code></pre>
<p><code>Error</code>構造体から特定の<code>Field</code>のための検証エラーを取り出す関数を書く必要があるでしょう。</p>
</li>
</ol>
<h2 id="まとめ-6"><a class="header" href="#まとめ-6">まとめ</a></h2>
<p>この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。</p>
<ul>
<li><code>Monad</code>型クラスとdo記法との関係性を見ました。</li>
<li>モナド則を導入し、do記法を使って書かれたコードを変換する方法を見ました。</li>
<li>異なる副作用を扱うコードを書く上で、モナドを抽象的に使う方法を見ました。</li>
<li>モナドがアプリカティブ関手の一例であること、両者がどのように副作用のある計算を可能にするのかということ、そして2つの手法の違いを説明しました。</li>
<li>ネイティブな作用の概念を定義し、<code>Effect</code>モナドを見ました。
これはネイティブな副作用を扱うものでした。</li>
<li>乱数生成、例外、コンソール入出力、変更可能な状態、及びReactを使ったDOM操作といった、様々な作用を扱うために
<code>Effect</code>モナドを使いました。</li>
</ul>
<p><code>Effect</code>モナドは実際のPureScriptコードにおける基本的なツールです。本書ではこのあとも、多くの場面で副作用を処理するために使っていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非同期作用"><a class="header" href="#非同期作用">非同期作用</a></h1>
<h2 id="この章の目標-7"><a class="header" href="#この章の目標-7">この章の目標</a></h2>
<p>この章では<code>Aff</code>モナドに集中します。
これは<code>Effect</code>モナドに似ていますが、<em>非同期</em>な副作用を表現するものです。
非同期にファイルシステムとやり取りしたりHTTPリクエストしたりする例を実演していきます。
また非同期作用の直列ないし並列な実行の管理方法も押さえます。</p>
<h2 id="プロジェクトの準備-6"><a class="header" href="#プロジェクトの準備-6">プロジェクトの準備</a></h2>
<p>この章で導入する新しいPureScriptライブラリは以下です。</p>
<ul>
<li><code>aff</code> - <code>Aff</code>モナドを定義します。</li>
<li><code>node-fs-aff</code> - <code>Aff</code>を使った非同期のファイルシステム操作。</li>
<li><code>affjax</code> - AJAXと<code>Aff</code>を使ったHTTPリクエスト。</li>
<li><code>parallel</code> - <code>Aff</code>の並列実行。</li>
</ul>
<p>（Node.js環境のような）ブラウザ外で実行する場合、<code>affjax</code>ライブラリには<code>xhr2</code>NPMモジュールが必要です。
このモジュールはこの章の<code>package.json</code>中の依存関係に挙げられています。
以下を走らせてインストールします。</p>
<pre><code class="language-shell">$ npm install
</code></pre>
<h2 id="非同期なjavascript"><a class="header" href="#非同期なjavascript">非同期なJavaScript</a></h2>
<p>JavaScriptで非同期なコードに取り組む上で便利な手段は<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await"><code>async</code>と<code>await</code></a>です。
<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">非同期なJavaScriptに関するこの記事</a>を見るとより背景情報がわかります。</p>
<p>以下は、この技法を使ってあるファイルの内容を別のファイルに複製する例です。</p>
<pre><code class="language-js">import { promises as fsPromises } from 'fs'

async function copyFile(file1, file2) {
  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });
  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });
}

copyFile('file1.txt', 'file2.txt')
.catch(e =&gt; {
  console.log('There was a problem with copyFile: ' + e.message);
});
</code></pre>
<p>コールバックや同期関数を使うことも可能ですが、以下の理由から望ましくありません。</p>
<ul>
<li>コールバックは過剰な入れ子に繋がります。これは「コールバック地獄」や「悪夢のピラミッド」として知られています。</li>
<li>同期関数はアプリ中の他のコードの実行を堰き止めてしまいます。</li>
</ul>
<h2 id="非同期なpurescript"><a class="header" href="#非同期なpurescript">非同期なPureScript</a></h2>
<p>PureScriptでの<code>Aff</code>モナドはJavaScriptの<code>async</code>/<code>await</code>構文に似た人間工学を供します。以下は前と同じ<code>copyFile</code>の例ですが、<code>Aff</code>を使ってPureScriptで書き換えられています。</p>
<pre><code class="language-hs">import Prelude
import Data.Either (Either(..))
import Effect.Aff (Aff, attempt, message, launchAff_)
import Effect (Effect)
import Effect.Class.Console (log)
import Node.Encoding (Encoding(..))
import Node.FS.Aff (readTextFile, writeTextFile)
import Node.Path (FilePath)

main :: Effect Unit
main = launchAff_ program

program :: Aff Unit
program = do
  result &lt;- attempt $ copyFile &quot;file1.txt&quot; &quot;file2.txt&quot;
  case result of
    Left e -&gt; log $ &quot;There was a problem with copyFile: &quot; &lt;&gt; message e
    _ -&gt; pure unit

copyFile :: FilePath -&gt; FilePath -&gt; Aff Unit
copyFile file1 file2 = do
  my_data &lt;- readTextFile UTF8 file1
  writeTextFile UTF8 file2 my_data
</code></pre>
<p>なお、<code>main</code>は<code>Effect Unit</code>でなければならないので、<code>launchAff_</code>を使って<code>Aff</code>から<code>Effect</code>へと変換せねばなりません。</p>
<p>上のコード片をコールバックや同期関数を使って書き換えることも可能です（例えば<code>Node.FS.Async</code>や<code>Node.FS.Sync</code>をそれぞれ使います）。
しかし、JavaScriptで前にお話ししたのと同じ短所がここでも通用するため、それらのコーディング形式は推奨されません。</p>
<p><code>Aff</code>を扱う文法は<code>Effect</code>を扱うものと大変似ています。
どちらもモナドですし、したがってdo記法で書けます。</p>
<p>例えば<code>readTextFile</code>のシグネチャを見れば、これがファイルの内容を<code>String</code>とし、<code>Aff</code>に包んで返していることがわかります。</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; FilePath -&gt; Aff String
</code></pre>
<p>do記法中では束縛矢印 (<code>&lt;-</code>) で返却された文字列を「開封」できます。</p>
<pre><code class="language-hs">my_data &lt;- readTextFile UTF8 file1
</code></pre>
<p>それから<code>writeTextFile</code>に文字列引数として渡します。</p>
<pre><code class="language-hs">writeTextFile :: Encoding -&gt; FilePath -&gt; String -&gt; Aff Unit
</code></pre>
<p>上の例で他に目を引く<code>Aff</code>固有の特徴は<code>attempt</code>のみです。これは<code>Aff</code>のコードの実行中に遭遇したエラーや例外を捕捉して<code>Either</code>内に保管するものです。</p>
<pre><code class="language-hs">attempt :: forall a. Aff a -&gt; Aff (Either Error a)
</code></pre>
<p>読者ならきっと、前の章から概念の知識を引き出し、その知識と上の<code>copyFile</code>の例で学んだ新しい<code>Aff</code>パターンを組み合わせることで、以下の演習に挑戦できるでしょう。</p>
<h2 id="演習-24"><a class="header" href="#演習-24">演習</a></h2>
<ol>
<li>
<p>（簡単）2つのテキストファイルを連結する関数<code>concatenateFiles</code>を書いてください。</p>
</li>
<li>
<p>（普通）複数のテキストファイルを連結する関数<code>concatenateMany</code>を書いてください。
入力ファイル名の配列と出力ファイル名が与えられます。
<em>手掛かり</em>：<code>traverse</code>を使ってください。</p>
</li>
<li>
<p>（普通）ファイル中の文字数を返すか、エラーがあればそれを返す関数<code>countCharacters :: FilePath -&gt; Aff (Either Error Int)</code>を書いてください。</p>
</li>
</ol>
<h2 id="更なるaffの資料"><a class="header" href="#更なるaffの資料">更なるAffの資料</a></h2>
<p>もしまだ<a href="https://pursuit.purescript.org/packages/purescript-aff/">公式のAffの手引き</a>を見ていなければ、今ざっと目を通してください。
この章の残りの演習を完了する上で事前に直接必要なことではありませんが、Pursuitで何らかの関数を見付けだす助けになるかもしれません。</p>
<p>以下の補足資料についてもあたってみるとよいでしょう。しかし繰り返しになりますがこの章の演習はこれらの内容に依りません。</p>
<ul>
<li><a href="https://blog.drewolson.org/asynchronous-purescript">DrewのAffに関する投稿</a></li>
<li><a href="https://github.com/JordanMartinez/purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff">更なるAffの説明と例</a></li>
</ul>
<h2 id="httpクライアント"><a class="header" href="#httpクライアント">HTTPクライアント</a></h2>
<p><code>affjax</code>ライブラリは<code>Aff</code>で非同期なAJAXのHTTP要求をする上での便利な手段を提供します。
対象としている環境が何であるかによって、<a href="https://github.com/purescript-contrib/purescript-affjax-web">purescript-affjax-web</a>または<a href="https://github.com/purescript-contrib/purescript-affjax-node">purescript-affjax-node</a>のどちらかのライブラリを使う必要があります。</p>
<p>この章の以降ではnodeを対象としていくので、<code>purescript-affjax-node</code>を使います。
より詳しい使用上の情報は<a href="https://pursuit.purescript.org/packages/purescript-affjax">affjaxのドキュメント</a>にあたってください。
以下は与えられたURLに向けてHTTPのGET要求をして、応答本文ないしエラー文言を返す例です。</p>
<pre><code class="language-hs">import Prelude
import Affjax.Node as AN
import Affjax.ResponseFormat as ResponseFormat
import Data.Either (Either(..))
import Effect.Aff (Aff)

getUrl :: String -&gt; Aff String
getUrl url = do
  result &lt;- AN.get ResponseFormat.string url
  pure case result of
    Left err -&gt; &quot;GET /api response failed to decode: &quot; &lt;&gt; AN.printError err
    Right response -&gt; response.body
</code></pre>
<p>これをREPLで呼び出す際は、<code>launchAff_</code>で<code>Aff</code>からREPLに互換性のある<code>Effect</code>へと変換する必要があります。</p>
<pre><code class="language-shell">$ spago repl

&gt; :pa
… import Prelude
… import Effect.Aff (launchAff_)
… import Effect.Class.Console (log)
… import Test.HTTP (getUrl)
…
… launchAff_ do
…   str &lt;- getUrl &quot;https://reqres.in/api/users/1&quot;
…   log str
…
unit
{&quot;data&quot;:{&quot;id&quot;:1,&quot;email&quot;:&quot;george.bluth@reqres.in&quot;,&quot;first_name&quot;:&quot;George&quot;,&quot;last_name&quot;:&quot;Bluth&quot;, ...}}
</code></pre>
<h2 id="演習-25"><a class="header" href="#演習-25">演習</a></h2>
<ol>
<li>（簡単）与えられたURLにHTTPの<code>GET</code>を要求し、応答本文をファイルに書き込む関数<code>writeGet</code>を書いてください。</li>
</ol>
<h2 id="並列計算"><a class="header" href="#並列計算">並列計算</a></h2>
<p><code>Aff</code>モナドとdo記法を使って、非同期計算を順番に実行されるように合成する方法を見てきました。
非同期計算を<em>並列にも</em>合成できたら便利でしょう。
<code>Aff</code>があれば2つの計算を次々に開始するだけで並列に計算できます。</p>
<p><code>parallel</code>パッケージは<code>Aff</code>のようなモナドのための型クラス<code>Parallel</code>を定義しており、並列実行に対応しています。
以前に本書でアプリカティブ関手に出会ったとき、並列計算を合成するときにアプリカティブ関手がどれほど便利なのかを見ました。
実は<code>Parallel</code>のインスタンスは、（<code>Aff</code>のような）モナド<code>m</code>と、並列に計算を組み合わせるために使えるアプリカティブ関手<code>f</code>との対応関係を定義しているのです。</p>
<pre><code class="language-hs">class (Monad m, Applicative f) &lt;= Parallel f m | m -&gt; f, f -&gt; m where
  sequential :: forall a. f a -&gt; m a
  parallel :: forall a. m a -&gt; f a
</code></pre>
<p>このクラスは2つの関数を定義しています。</p>
<ul>
<li><code>parallel</code>：モナド<code>m</code>中の計算を取り、アプリカティブ関手<code>f</code>中の計算に変えます。</li>
<li><code>sequential</code>：反対方向に変換します。</li>
</ul>
<p><code>aff</code>ライブラリは<code>Aff</code>モナドの<code>Parallel</code>インスタンスを提供します。
これは、2つの継続のどちらが呼び出されたかを把握することによって、変更可能な参照を使用して並列に<code>Aff</code>動作を組み合わせます。
両方の結果が返されたら、最終結果を計算してメインの継続に渡せます。</p>
<p>アプリカティブ関手では任意個の引数の関数の持ち上げができるので、このアプリカティブコンビネータを使ってより多くの計算を並列に実行できます。
<code>traverse</code>や<code>sequence</code>といった、アプリカティブ関手を扱う全ての標準ライブラリ関数から恩恵を受けることもできます。</p>
<p>直列的なコードの一部と並列計算を組み合わせることもできます。
それにはdo記法ブロック中でアプリカティブコンビネータを使います。
その逆も然りで、必要に応じて<code>parralel</code>と<code>sequential</code>を使って型構築子を変更すれば良いのです。</p>
<p>直列実行と並列実行の間の違いを実演するために、100個の10ミリ秒の遅延からなる配列をつくり、それからその遅延を両方の手法で実行します。REPLで試すと<code>seqDelay</code>が<code>parDelay</code>より遥かに遅いことに気付くでしょう。並列実行が<code>sequence_</code>を<code>parSequence_</code>で置き換えるだけで有効になるところに注目です。</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parSequence_)
import Data.Array (replicate)
import Data.Foldable (sequence_)
import Effect (Effect)
import Effect.Aff (Aff, Milliseconds(..), delay, launchAff_)

delayArray :: Array (Aff Unit)
delayArray = replicate 100 $ delay $ Milliseconds 10.0

seqDelay :: Effect Unit
seqDelay = launchAff_ $ sequence_ delayArray

parDelay :: Effect Unit
parDelay = launchAff_ $ parSequence_ delayArray
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelDelay

&gt; seqDelay -- This is slow
unit

&gt; parDelay -- This is fast
unit
</code></pre>
<p>以下は並列で複数回HTTP要求する、より現実味のある例です。
<code>getUrl</code>関数を再利用して2人の利用者から並列で情報を取得します。
この場合では<code>parTarverse</code>（<code>traverse</code>の並列版）が使われていますね。
この例は代わりに<code>traverse</code>でも問題なく動きますがより遅くなるでしょう。</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parTraverse)
import Effect (Effect)
import Effect.Aff (launchAff_)
import Effect.Class.Console (logShow)
import Test.HTTP (getUrl)

fetchPar :: Effect Unit
fetchPar =
  launchAff_ do
    let
      urls = map (\n -&gt; &quot;https://reqres.in/api/users/&quot; &lt;&gt; show n) [ 1, 2 ]
    res &lt;- parTraverse getUrl urls
    logShow res
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelFetch

&gt; fetchPar
unit
[&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:1,\&quot;email\&quot;:\&quot;george.bluth@reqres.in\&quot;, ... }&quot;
,&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:2,\&quot;email\&quot;:\&quot;janet.weaver@reqres.in\&quot;, ... }&quot;
]
</code></pre>
<p>利用できる並列関数の完全な一覧は<a href="https://pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel">Pursuitの<code>parallel</code>のドキュメント</a>にあります。<a href="https://github.com/purescript-contrib/purescript-aff#parallel-execution">parallelのaffのドキュメントの節</a>にもより多くの例が含まれています。</p>
<h2 id="演習-26"><a class="header" href="#演習-26">演習</a></h2>
<ol>
<li>
<p>（簡単）前の<code>concatenateMany</code>関数と同じシグネチャを持つ<code>concatenateManyParallel</code>関数を書いてください。
ただし全ての入力ファイルを並列に読むようにしてください。</p>
</li>
<li>
<p>（普通）与えられたURLへHTTP <code>GET</code>を要求して以下の何れかを返す<code>getWithTimeout :: Number -&gt; String -&gt; Aff (Maybe String)</code>関数を書いてください。</p>
<ul>
<li><code>Nothing</code>: 要求してから与えられた時間制限（ミリ秒単位）より長く掛かった場合。</li>
<li>文字列の応答：時間制限を越える前に要求が成功した場合。</li>
</ul>
</li>
<li>
<p>（難しい）「根」のファイルを取り、そのファイルの中の全てのパスの一覧（そして一覧にあるファイルの中の一覧も）の配列を返す<code>recurseFiles</code>関数を書いてください。
一覧にあるファイルを並列に読んでください。
パスはそのファイルが現れたディレクトリから相対的なものです。
<em>手掛かり</em>：<code>node-path</code>モジュールにはディレクトリを扱う上で便利な関数があります。</p>
</li>
</ol>
<p>例えば次のような<code>root.txt</code>ファイルから始まるとします。</p>
<pre><code class="language-shell">$ cat root.txt
a.txt
b/a.txt
c/a/a.txt

$ cat a.txt
b/b.txt

$ cat b/b.txt
c/a.txt

$ cat b/c/a.txt

$ cat b/a.txt

$ cat c/a/a.txt
</code></pre>
<p>期待される出力は次の通り。</p>
<pre><code class="language-hs">[&quot;root.txt&quot;,&quot;a.txt&quot;,&quot;b/a.txt&quot;,&quot;b/b.txt&quot;,&quot;b/c/a.txt&quot;,&quot;c/a/a.txt&quot;]
</code></pre>
<h2 id="まとめ-7"><a class="header" href="#まとめ-7">まとめ</a></h2>
<p>この章では非同期作用と以下の方法を押さえました。</p>
<ul>
<li><code>aff</code>ライブラリを使って<code>Aff</code>モナド中で非同期コードを走らせる。</li>
<li><code>affjax</code>ライブラリを使って非同期にHTTPリクエストする。</li>
<li><code>parallel</code>ライブラリを使って並列に非同期コードを走らせる。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外部関数インターフェース"><a class="header" href="#外部関数インターフェース">外部関数インターフェース</a></h1>
<h2 id="この章の目標-8"><a class="header" href="#この章の目標-8">この章の目標</a></h2>
<p>本章ではPureScriptの<em>外部関数インターフェース</em> (foreign function interface; <em>FFI</em>) を紹介します。
これによりPureScriptコードからJavaScriptコードへの呼び出し、及びその逆が可能になります。
以下の方法を押さえていきます。</p>
<ul>
<li>純粋で、作用のある、非同期なJavaScript関数をPureScriptから呼び出す。</li>
<li>型付けされていないデータを扱う。</li>
<li><code>argonaut</code>パッケージを使ってJSONにエンコードしたりJSONを構文解析したりする。</li>
</ul>
<p>この章の終わりにかけて、住所録の例に立ち返ります。
この章の目的は、FFIを使ってアプリケーションに次の新しい機能を追加することです。</p>
<ul>
<li>利用者にポップアップ通知で警告する。</li>
<li>フォームのデータを直列化してブラウザのローカルストレージに保存し、アプリケーションが再起動したときにそれを再読み込みする</li>
</ul>
<p>さらに一般にはそこまで重用されない幾つかの追加の話題を押さえた補遺もあります。
ご自由にこれらの節を読んで構いませんが、学習目標にあまり関係しなければ、本書の残りを読み進める妨げにならないようにしてください。</p>
<ul>
<li>実行時のPureScriptの値の表現を理解する。</li>
<li>JavaScriptからPureScriptを呼び出す。</li>
</ul>
<h2 id="プロジェクトの準備-7"><a class="header" href="#プロジェクトの準備-7">プロジェクトの準備</a></h2>
<p>このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。
そうしたわけでソースツリーにはこれらの章からの適切なソースファイルが含まれています。</p>
<p>この章は<code>argonaut</code>ライブラリを依存関係として導入しています。
このライブラリはJSONにエンコードしたりJSONをデコードしたりするために使います。</p>
<p>この章の演習は<code>test/MySolutions.purs</code>に書き、<code>spago test</code>を走らせることによって<code>test/Main.purs</code>中の単体試験について確認できます。</p>
<p>住所録アプリは<code>parcel src/index.html --open</code>で立ち上げることができます。8章と同じ作業の流れになっているので、より詳しい説明についてはそちらの章を参照してください。</p>
<h2 id="免責事項"><a class="header" href="#免責事項">免責事項</a></h2>
<p>JavaScriptの扱いをできる限り単純にするため、PureScriptは直感的な外部関数インターフェースを提供しています。
しかし、FFIはこの言語の<em>応用的な</em>機能であることには心に留めておかれると良いでしょう。
安全かつ効率的に使用するには、扱うつもりであるデータの実行時の表現について理解していなければなりません。
この章では、PureScriptの標準ライブラリのコードに付いて回るそのような理解を伝授することを目指します。</p>
<p>PureScriptのFFIはとても柔軟に設計されています。
実際には、外部関数にとても単純な型を与えるか、型システムを利用して外部のコードの誤った使い方を防ぐようにするか、開発者が選べるようになっています。
標準ライブラリのコードは、後者の手法を採る傾向にあります。</p>
<p>簡単な例としては、JavaScriptの関数で戻り値が <code>null</code>にならないことは保証できません。
実のところ、JavaScriptらしさのあるコードはかなり頻繁に <code>null</code>を返します。
しかし、大抵PureScriptの型にnull値が巣喰うことはありません。
そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するとき、これらの特殊な場合を適切に処理するのは開発者の責任です。</p>
<h2 id="purescriptからjavascriptを呼び出す"><a class="header" href="#purescriptからjavascriptを呼び出す">PureScriptからJavaScriptを呼び出す</a></h2>
<p>PureScriptからJavaScriptコードを使用する最も簡単な方法は、 <em>外部インポート宣言</em> (foreign import
declaration) を使用し、既存のJavaScriptの値に型を与えることです。
外部インポート宣言には <em>外部JavaScriptモジュール</em> (foreign JavaScript module) から <em>エクスポートされた</em>
対応するJavaScriptでの宣言がなくてはなりません。</p>
<p>例えば特殊文字をエスケープすることによりURIのコンポーネントをエンコードするJavaScriptの
<code>encodeURIComponent</code>関数について考えてみます。</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p>この関数は関数の型<code>String -&gt; String</code>について適切な実行時表現を持っています。
<code>null</code>でない文字列を取って<code>null</code>でない文字列にするもので、副作用を持たないからです。</p>
<p>次のような外部インポート宣言を使うと、この関数に型を割り当てることができます。</p>
<pre><code class="language-haskell">module Test.URI where

foreign import _encodeURIComponent :: String -&gt; String
</code></pre>
<p>インポートしてくるための外部JavaScriptモジュールを書く必要もあります。
対応する外部JavaScriptモジュールは、同名で拡張子が<code>.purs</code>から<code>.js</code>に変わったものです。
上のPureScriptモジュールが<code>URI.purs</code>として保存されているなら、外部JavaScriptモジュールを<code>URI.js</code>として保存します。
<code>encodeURIComponent</code>は既に定義されているので、<code>_encodeURIComponent</code>としてエクスポートせねばなりません。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

export const _encodeURIComponent = encodeURIComponent;
</code></pre>
<p>バージョン0.15からPureScriptはJavaScriptと通訳する際にESモジュールシステムを使います。
ESモジュールではオブジェクトに<code>export</code>キーワードを与えることで関数と値がモジュールからエクスポートされます。</p>
<p>これら2つの部品を使うことで、PureScriptで書かれた関数のように、PureScriptから<code>encodeURIComponent</code>関数を使うことができます。
例えばPSCiで上記の計算を再現できます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; _encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>外部モジュールには独自の関数も定義できます。
以下は<code>Number</code>を平方する独自のJavaScript関数を作って呼び出す方法の一例です。</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

export const square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="多変数関数"><a class="header" href="#多変数関数">多変数関数</a></h2>
<p>第2章の<code>diagonal</code>関数を外部モジュールで書き直してみましょう。
この関数は直角三角形の対角線を計算します。</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>PureScriptの関数は<em>カリー化</em>されていることを思い出してください。
<code>diagonal</code>は<code>Number</code>を取って<em>関数</em>を返す関数です。
そして返された関数は<code>Number</code>を取って<code>Number</code>を返します。</p>
<pre><code class="language-js">export const diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>もしくはES6の矢印構文ではこうです（後述するES6についての補足を参照してください）。</p>
<pre><code class="language-js">export const diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="カリー化されていない関数"><a class="header" href="#カリー化されていない関数">カリー化されていない関数</a></h2>
<p>JavaScriptでカリー化された関数を書くことは、ただでさえJavaScriptらしいものではない上に、常に可能というわけでもありません。
よくある多変数なJavaScriptの関数は <em>カリー化されていない</em> 形式を取るでしょう。</p>
<pre><code class="language-js">export const diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>モジュール<code>Data.Function.Uncurried</code>は<em>梱包</em>型とカリー化されていない関数を取り扱う関数をエクスポートします。</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>型構築子<code>Fn2</code>を調べると以下です。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code>は3つの型引数を取ります。
<code>Fn2 a b c</code>は、型<code>a</code>と<code>b</code>の2つの引数、返り値の型<code>c</code>を持つカリー化されていない関数の型を表現しています。
これを使って外部モジュールから<code>diagonalUncurried</code>をインポートしました。</p>
<p>そうして<code>runFn2</code>を使って呼び出せます。
これはカリー化されていない関数と引数を取るものです。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p><code>functions</code>パッケージでは0引数から10引数までの関数について同様の型構築子が定義されています。</p>
<h2 id="カリー化されていない関数についての補足"><a class="header" href="#カリー化されていない関数についての補足">カリー化されていない関数についての補足</a></h2>
<p>PureScriptのカリー化された関数には勿論利点があります。
部分的に関数を適用でき、関数型に型クラスインスタンスを与えられるのです。
しかし効率上の代償も付いてきます。
効率性が決定的に重要なコードでは時々、多変数を受け付けるカリー化されていないJavaScript関数を定義する必要があります。</p>
<p>PureScriptでカリー化されていない関数を作ることもできます。
2引数の関数については<code>mkFn2</code>関数が使えます。</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>前と同様に<code>runFn2</code>関数を使うと、カリー化されていない2引数の関数を適用できます。</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>ここで重要なのは、引数が全て適用されるなら、コンパイラは <code>mkFn2</code>関数や <code>runFn2</code>関数を<em>インライン化</em>するということです。
そのため、生成されるコードはとても簡潔になります。</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>対照的に、こちらがこれまでのカリー化された関数です。</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>そして生成結果のコードが以下です。
入れ子の関数のため比較的簡潔ではありません。</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="現代的なjavascriptの構文についての補足"><a class="header" href="#現代的なjavascriptの構文についての補足">現代的なJavaScriptの構文についての補足</a></h2>
<p>前に見た矢印関数構文はES6の機能であり、そのため幾つかの古いブラウザ（名指しすればIE11）と互換性がありません。
執筆時点でwebブラウザをまだ更新していない<a href="https://caniuse.com/#feat=arrow-functions">6%の利用者が矢印関数を使うことができないと推計</a>されています。</p>
<p>ほとんどの利用者にとって互換性があるようにするため、PureScriptコンパイラによって生成されるJavaScriptコードは矢印関数を使っていません。
また、同じ理由で<strong>公開するライブラリでも矢印関数を避ける</strong>ことが推奨されます。</p>
<p>それでも自分のFFIコードで矢印関数を使うこともできますが、デプロイの作業工程でES5に互換性のある関数へ変換するために<a href="https://github.com/babel/babel#intro">Babel</a>などのツールを含めると良いでしょう。</p>
<p>ES6の矢印関数がより読みやすく感じたら<a href="https://github.com/lebab/lebab">Lebab</a>のようなツールを使ってコンパイラの<code>output</code>ディレクトリにJavaScriptのコードを変換できます。</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>この操作により上の<code>curriedAdd</code>関数は以下に変換されます。</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>本書の残りの例では入れ子の関数の代わりに矢印関数を使います。</p>
<h2 id="演習-27"><a class="header" href="#演習-27">演習</a></h2>
<ol>
<li>（普通）<code>Test.MySolutions</code>モジュールの中に箱の体積を求めるJavaScriptの関数<code>volumeFn</code>を書いてください。
<code>Data.Function.Uncurried</code>の梱包<code>Fn</code>を使ってください。</li>
<li>（普通）<code>volumeFn</code>を矢印関数を使って書き直し、<code>volumeArrow</code>としてください。</li>
</ol>
<h2 id="単純な型を渡す"><a class="header" href="#単純な型を渡す">単純な型を渡す</a></h2>
<p>以下のデータ型はPureScriptとJavaScriptの間でそのまま渡し合うことができます。</p>
<div class="table-wrapper"><table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
</div>
<p><code>String</code>と<code>Number</code>という原始型の例は既に見てきました。
ここから<code>Array</code>や<code>Record</code>（JavaScriptでは<code>Object</code>）といった構造的な型を眺めていきます。</p>
<p><code>Array</code>を渡すところを実演するために、以下に<code>Int</code>の<code>Array</code>を取って別の配列として累計の和を返すJavaScriptの関数の呼び出し方を示します。
前にありましたが、JavaScriptは<code>Int</code>のための分離した型を持たないため、PureScriptでの<code>Int</code>と<code>Number</code>は両方共JavaScriptでの<code>Number</code>に翻訳されます。</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">export const cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p><code>Record</code>を渡すところを実演するために、以下に2つの<code>Complex</code>な数をレコードとして取り、和を別のレコードとして返すJavaScriptの呼び出し方を示します。
PureScriptでの<code>Record</code>がJavaScriptでは<code>Object</code>として表現されることに注意してください。</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">export const addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>なお、上の手法にはJavaScriptが期待通りの型を返すことを信用する必要があります。
PureScriptはJavaScriptのコードに型検査を適用できないからです。
この型安全性の配慮について後のJSONの節でより詳しく解説していきます。
型の不整合から身を守る手法についても押さえます。</p>
<h2 id="演習-28"><a class="header" href="#演習-28">演習</a></h2>
<ol>
<li>（普通）<code>Complex</code>な数の配列を取って別の複素数の配列として累計の和を返すJavaScriptの関数<code>cumulativeSumsComplex</code>（と対応するPureScriptの外部インポート）を書いてください。</li>
</ol>
<h2 id="単純な型を越えて"><a class="header" href="#単純な型を越えて">単純な型を越えて</a></h2>
<p><code>String</code>、<code>Number</code>、<code>Array</code>、そして<code>Record</code>といった、JavaScript固有の表現を持つ型をFFI越しに送ったり受け取ったりする方法を数例見てきました。
ここから<code>Maybe</code>のようなPureScriptで使える幾つかの他の型の使い方を押さえていきます。</p>
<p>外部宣言を使用して、配列についての <code>head</code>関数を改めて作成したいとしましょう。
JavaScriptでは次のような関数を書くことになるでしょう。</p>
<pre><code class="language-javascript">export const head = arr =&gt;
  arr[0];
</code></pre>
<p>この関数をどう型付けましょうか。
型 <code>forall a. Array a -&gt; a</code>を与えようとしても、空の配列に対してこの関数は <code>undefined</code>を返します。
したがって型<code>forall a. Array a -&gt; a</code>は正しくこの実装を表現していないのです。</p>
<p>代わりにこの特殊な場合を扱うために<code>Maybe</code>値を返したいところです。</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>しかしどうやって<code>Maybe</code>を返しましょうか。
つい以下のように書きたくなります。</p>
<pre><code class="language-js">// こうしないでください
import Data_Maybe from '../Data.Maybe'

export const maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>外部モジュールで直接<code>Data.Maybe</code>モジュールをインポートして使うことはお勧めしません。というのもコードがコード生成器の変化に対して脆くなるからです。<code>create</code>や<code>value</code>は公開のAPIではありません。加えて、このようにすると、不要なコードを消去する<code>purs bundle</code>を使う際に問題を引き起こす可能性があります。</p>
<p>推奨されるやり方はFFIで定義された関数に余剰の引数を加えて必要な関数を受け付けることです。</p>
<pre><code class="language-js">export const maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>ただし、次のように書きますが、</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>以下ではないことに注意です。</p>
<pre><code class="language-hs">forall a. (a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>どちらの形式でも動きますが、後者は<code>Just</code>と<code>Nothing</code>の場所での招かれざる入力に対してより脆弱です。</p>
<p>例えば、比較的脆い方では、以下のように呼び出せるでしょう。</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>これは如何なる配列の入力に対しても<code>Just 1000</code>を返します。</p>
<p>この脆弱性では、<code>a</code>が<code>Int</code>のときに（これは入力の配列に基づきます）<code>(\_ -&gt; Just 1000)</code>と<code>Just 1000</code>がシグネチャ<code>(a -&gt; Maybe a)</code>と<code>Maybe a</code>にそれぞれ照合するために許容されてしまっています。</p>
<p>より安全な型シグネチャでは、入力の配列に基づいて<code>a</code>が<code>Int</code>に決定されたとしても、<code>forall x</code>に絡むシグネチャに合致する妥当な関数を提供する必要があります。<code>(forall x. Maybe x)</code>の <em>唯一</em> の選択肢は<code>Nothing</code>ですが、それは<code>Just</code>値が<code>x</code>の型を前提にしてしまうと、もはや全ての<code>x</code>については妥当でなくなってしまうからです。<code>(forall x. x -&gt; Maybe x)</code>の唯一の選択肢は<code>Just</code>（望まれている引数）と<code>(\_ -&gt; Nothing)</code>であり、後者は唯一残っている脆弱性になるのです。</p>
<h2 id="外部型の定義"><a class="header" href="#外部型の定義">外部型の定義</a></h2>
<p><code>Maybe a</code>を返す代わりに<code>arr[0]</code>を返したいのだとしましょう。
型<code>a</code>ないし<code>undefined</code>値（ただし<code>null</code>ではありません）の何れかの値を表現する型がほしいです。
この型を<code>Undefined a</code>と呼びましょう。</p>
<p><em>外部インポート宣言</em> を使うと、<em>外部型</em> (foreign type) を定義できます。構文は外部関数を定義するのと似ています。</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>このキーワード<code>data</code>は<em>型</em>を定義していることを表しています。
値ではありせん。
型シグネチャの代わりに、新しい型の<em>種</em>を与えます。
この場合は<code>Undefined</code>の種が <code>Type -&gt; Type</code>であると宣言しています。
言い換えれば<code>Undefined</code>は型構築子です。</p>
<p>これで元の<code>head</code>の定義を再利用できます。</p>
<pre><code class="language-javascript">export const undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>PureScriptモジュールには以下を追加します。</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p><code>undefinedHead</code>関数の本体は<code>undefined</code>かもしれない<code>arr[0]</code>を返します。
そしてこの型シグネチャはその事実を正しく反映しています。</p>
<p>この関数はその型の適切な実行時表現を持っていますが、型<code>Undefined a</code>の値を使用する方法がないので、全く役に立ちません。
いや、言い過ぎました。
別のFFIでこの型を使えますからね。</p>
<p>値が未定義かどうかを教えてくれる関数を書くことができます。</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>外部JavaScriptモジュールで次のように定義できます。</p>
<pre><code class="language-javascript">export const isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>これでPureScriptで <code>isUndefined</code>と <code>undefinedHead</code>を一緒に使用すると、便利な関数を定義できます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>このように、定義したこの外部関数はとても単純です。
つまりPureScriptの型検査器を使うことによる利益が最大限得られるのです。
一般に、外部関数は可能な限り小さく保ち、できるだけアプリケーションの処理はPureScriptコードへ移動しておくことをお勧めします。</p>
<h2 id="例外-1"><a class="header" href="#例外-1">例外</a></h2>
<p>他の選択肢としては、空の配列の場合に例外を投げる方法があります。
厳密に言えば、純粋な関数は例外を投げるべきではありませんが、そうする柔軟さはあります。
安全性に欠けていることを関数名で示します。</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>JavaScriptモジュールでは、<code>unsafeHead</code>を以下のように定義できます。</p>
<pre><code class="language-javascript">export const unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="演習-29"><a class="header" href="#演習-29">演習</a></h2>
<ol>
<li>
<p>（普通）二次多項式 \( a x ^ 2 + b x + c = 0 \) を表現するレコードが与えられているとします。</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>二次多項式を使ってこの多項式の根を求めるJavaScriptの関数<code>quadraticRootsImpl</code>とその梱包の<code>quadraticRoots :: Quadratic -&gt; Pair Complex</code>を書いてください。
2つの根を<code>Complex</code>の数の<code>Pair</code>として返してください。
<em>手掛かり</em>：梱包<code>quadraticRoots</code>を使って<code>Pair</code>の構築子を<code>quadraticRootsImpl</code>に渡してください。</p>
</li>
<li>
<p>（普通）関数<code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>を書いてください。
この関数は<code>undefined</code>を<code>Nothing</code>に、<code>a</code>の値を<code>Just a</code>に変換します。</p>
</li>
<li>
<p>（難しい）<code>toMaybe</code>が準備できたら、<code>maybeHead</code>を以下に書き換えられます。</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>これは前の実装よりも良いやり方なのでしょうか。
<em>補足</em>：この演習のための単体試験はありません。</p>
</li>
</ol>
<h2 id="型クラスメンバー関数を使う"><a class="header" href="#型クラスメンバー関数を使う">型クラスメンバー関数を使う</a></h2>
<p>つい先程までFFI越しに<code>Maybe</code>の構築子を渡す手引きをしましたが、今回はJavaScriptを呼び出すPureScriptを書く別の場合です。
JavaScriptの呼び出しでも続けざまにPureScriptの関数を呼び出します。
ここでは型クラスのメンバー関数をFFI越しに渡す方法を探ります。</p>
<p>型<code>x</code>に合う適切な<code>show</code>のインスタンスを期待する外部JavaScript関数を書くことから始めます。</p>
<pre><code class="language-js">export const boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + &quot;!!!&quot;;
</code></pre>
<p>それから対応するシグネチャを書きます。</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>そして<code>show</code>の正しいインスタンスを渡す梱包関数も書きます。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>代えてポイントフリー形式だとこうです。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>そうして梱包を呼び出すことができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 &quot;Hat&quot;)
&quot;(TUPLE 1 \&quot;HAT\&quot;)!!!&quot;
</code></pre>
<p>以下は複数の関数を渡す別の実演例です。
これらの関数には複数引数の関数 (<code>eq</code>) が含まれます。</p>
<pre><code class="language-js">export const showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return &quot;Equivalent&quot;;
  } else {
    return show(a) + &quot; is not equal to &quot; + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
&quot;Nothing is not equal to (Just 5)&quot;
</code></pre>
<h2 id="作用のある関数"><a class="header" href="#作用のある関数">作用のある関数</a></h2>
<p><code>bold</code>関数を拡張してコンソールにログ出力するようにしましょう。
ログ出力は<code>Effect</code>であり、<code>Effect</code>はJavaScriptにおいて無引数関数として表現されます。
つまり<code>()</code>と矢印記法だとこうです。</p>
<pre><code class="language-js">export const yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + &quot;!!!&quot;);
</code></pre>
<p>新しくなった外部インポートは、返る型が<code>String</code>から<code>Effect Unit</code>に変わった点以外は以前と同じです。</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>REPLで試すと文字列が（引用符で囲まれず）直接コンソールに印字され<code>unit</code>値が返ることがわかります。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 &quot;Hat&quot;)
(TUPLE 1 &quot;HAT&quot;)!!!
unit
</code></pre>
<p><code>Effect.Uncurried</code>に梱包<code>EffectFn</code>というものもあります。
これらは既に見た<code>Data.Function.Uncurried</code>の梱包<code>Fn</code>に似ています。
これらの梱包があればカリー化されていない作用のある関数をPureScriptで呼び出すことができます。</p>
<p>一般的にこれらを使うのは、こうしたAPIをカリー化された関数に包むのではなく、既存のJavaScriptライブラリのAPIを直接呼び出したいときぐらいです。
したがってカリー化していない<code>yell</code>の例を見せてもあまり意味がありません。
というのもJavaScriptがPureScriptの型クラスのメンバーに依っているからで、更にそれは既存のJavaScriptのエコシステムにそのメンバーが見付からないためです。</p>
<p>翻って以前の<code>diagonal</code>の例を変更し、結果を返すことに加えてログ出力を含めるとこうなります。</p>
<pre><code class="language-js">export const diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log(&quot;Diagonal is &quot; + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="非同期関数"><a class="header" href="#非同期関数">非同期関数</a></h2>
<p><code>aff-promise</code>ライブラリの助けを借りるとJavaScriptのプロミスは直接PureScriptの非同期作用に翻訳されます。
詳細についてはライブラリの<a href="https://pursuit.purescript.org/packages/purescript-aff-promise">ドキュメント</a>をあたってください。
ここでは幾つかの例に触れるだけとします。</p>
<p>JavaScriptの<code>wait</code>プロミス（または非同期関数）をPureScriptのプロジェクトで使いたいとします。
<code>ms</code>ミリ秒分だけ送らせて実行させるのに使うことができます。</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>単に<code>Effect</code>（無引数関数）に包んで公開するだけで大丈夫です。</p>
<pre><code class="language-js">export const sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>そして以下のようにインポートします。</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>そうして<code>Aff</code>ブロック中でこの<code>Promise</code>を以下のように走らせることができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
… launchAff_ do
…   log &quot;waiting&quot;
…   sleep 300
…   log &quot;done waiting&quot;
…
waiting
unit
done waiting
</code></pre>
<p>REPLでの非同期ログ出力はブロック全体が実行を終了するまで印字を待機する点に注意しましょう。
このコードを<code>spago test</code>で走らせた場合、印字の<em>合間に</em>僅かな遅延があり、より予測に近い挙動をします。</p>
<p>他にプロミスから値を返す例を見てみましょう。
この関数は<code>async</code>と<code>await</code>を使って書かれていますが、これはプロミスの糖衣構文に過ぎません。</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

export const diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p><code>Number</code>を返すため、この型を<code>Promise</code>と<code>Aff</code>の梱包の中で表現します。</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
… launchAff_ do
…   res &lt;- diagonalAsync 300 3.0 4.0
…   logShow res
…
unit
5.0
</code></pre>
<h2 id="演習-30"><a class="header" href="#演習-30">演習</a></h2>
<p>上の節の演習はまだやるべきことの一覧にあります。
もし何か良い演習の考えがあればご提案ください。</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>アプリケーションでJSONを使うことには多くの理由があります。
例えばwebのAPIと疎通するよくある手段であるためです。
この節では他の用例についてもお話ししましょう。
構造的なデータをFFI越しに渡す場合に型安全性を向上させる手法から始めます。</p>
<p>少し前のFFI関数<code>cumulativeSums</code>と<code>addComplex</code>を再訪し、それぞれに1つバグを混入させてみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push(&quot;Broken&quot;); // Bug
  return sums;
};

export const addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>実際は返る型が正しくないのですが、元々の型シグネチャを使うことができ、依然としてコードはコンパイルされます。</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>コードの実行さえ可能で、そうすると予期しない結果を生み出すか実行時エラーになります。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>例えば結果の<code>sums</code>はもはや正しい<code>Array Int</code>ではありませんが、それは<code>String</code>が配列に含まれているからです。
そして更なる操作は即時のエラーではなく予期しない挙動を生み出します。
というのもこれらの<code>sums</code>の<code>sum</code>は<code>10</code>ではなく<code>0</code>だからです。
これでは捜索の難しいバグになりかねませんね。</p>
<p>同様に<code>addComplexBroken</code>を呼び出すときは1つもエラーが出ません。
しかし、<code>Complex</code>の結果の<code>imag</code>フィールドにアクセスすると予期しない挙動（<code>7.0</code>ではなく<code>Nan</code>を返すため）やはっきりしない実行時エラーを生じることでしょう。</p>
<p>PureScriptのコードにバグ一匹通さないようにするため、JavaScriptのコードでJSONを使いましょう。</p>
<p><code>argonaut</code>ライブラリにはこのために必要なJSONのデコードとエンコードの機能が備わっています。
このライブラリには素晴らしい<a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">ドキュメント</a>があるので、本書では基本的な用法だけを押さえます。</p>
<p>返る型を<code>Json</code>として定義するようにして、代わりとなる外部インポートを作るとこうなります。</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>単純に既存の壊れた関数を指している点に注意します。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSumsBroken
export const addComplexJson = addComplexBroken
</code></pre>
<p>そして返された<code>Json</code>の値をデコードする梱包を書きます。</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>そうすると返る型へのデコードが成功しなかったどんな値も<code>Left</code>の<code>String</code>なエラーとして表れます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left &quot;Couldn't decode Array (Failed at index 3): Value is not a Number&quot;)

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left &quot;JSON was missing expected field: imag&quot;)
</code></pre>
<p>正常に動作するバージョンで呼び出すと<code>Right</code>の値が返ります。</p>
<p>次のREPLブロックを走らせる前に、正常に動作するバージョンを指すように、<code>test/Examples.js</code>へ以下の変更を加えて、手元で試してみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSums
export const addComplexJson = addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>JSONを使うのは、<code>Map</code>や<code>Set</code>のようなその他の構造的な型をFFI越しに渡す、最も簡単な方法でもあります。
JSONは真偽値、数値、文字列、配列、そして他のJSONの値からなるオブジェクトのみから構成されるため、JSONでは直接<code>Map</code>や<code>Set</code>を書けません。
しかしこれらの構造を配列としては表現でき（キーとバリューもまたJSONで表現されているとします）、それから<code>Map</code>や<code>Set</code>に復元できるのです。</p>
<p>以下は<code>String</code>のキーと<code>Int</code>のバリューからなる<code>Map</code>を変更する外部関数シグネチャと、それに伴うJSONのエンコードとデコードを扱う梱包関数の例です。</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo json = decodeJson $ mapSetFooJson $ encodeJson json
</code></pre>
<p>関数合成の絶好の用例になっていますね。
以下の代案は両方とも上のものと等価です。</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>以下はJavaScriptでの実装です。
なお、<code>Array.from</code>の工程は、JavaScriptの<code>Map</code>をJSONに親和性のある形式に変換し、デコードでPureScriptの<code>Map</code>に変換し直すために必須です。</p>
<pre><code class="language-js">export const mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set(&quot;Foo&quot;, 42);
  return Array.from(m);
};
</code></pre>
<p>これで<code>Map</code>をFFI越しに送ったり受け取ったりできます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple &quot;hat&quot; 1, Tuple &quot;cat&quot; 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple &quot;Foo&quot; 42),(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)]))
</code></pre>
<h2 id="演習-31"><a class="header" href="#演習-31">演習</a></h2>
<ol>
<li>
<p>（普通）<code>Map</code>中の全てのバリューの<code>Set</code>を返すJavaScriptの関数とPureScriptの梱包<code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code>を書いてください。</p>
</li>
<li>
<p>（簡単）より広い種類のマップに関して動作するよう、前のJavaScriptの関数の新しい梱包を書いてください。
シグネチャは<code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code>です。
なお、<code>k</code>と<code>v</code>に幾つかの型クラス制約を加える必要があるでしょう。
コンパイラが導いてくれます。</p>
</li>
<li>
<p>（普通）少し前の<code>quadraticRoots</code>関数を書き換えて<code>quadraticRootSet</code>としてください。
この関数は<code>Complex</code>の根をJSONを介して（<code>Pair</code>の代わりに）<code>Set</code>として返します。</p>
</li>
<li>
<p>（難しい）少し前の<code>quadraticRoots</code>関数を書き換えて<code>quadraticRootsSafe</code>としてください。
この関数はJSONを使って<code>Complex</code>の根の<code>Pair</code>をFFI越しに渡します。
JavaScriptでは<code>Pair</code>構築子を使わないでください。
その代わり、デコーダーに互換性のある形式で対を返すだけにしてください。
<em>手掛かり</em>：<code>DecodeJson</code>インタンスを<code>Pair</code>用に書く必要があるでしょう。
独自のデコードインスタンスを書く上での説明については<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonautのドキュメント</a>をあたってください。
<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a>インスタンスも参考になるかもしれません。
「孤立インスタンス」を作ることを避けるために、<code>Pair</code>に<code>newtype</code>の梱包が必要になる点に注意してください。</p>
</li>
<li>
<p>（普通）2次元配列を含むJSON文字列を構文解析してデコードする<code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code>関数を書いてください。
例えば<code>&quot;[[1, 2, 3], [4, 5], [6]]&quot;</code>です。
<em>手掛かり</em>：デコードの前に<code>jsonParser</code>を使って<code>String</code>を<code>Json</code>に変換する必要があるでしょう。</p>
</li>
<li>
<p>（普通）以下のデータ型は値が葉にある二分木を表現します。</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>汎化された<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを<code>Tree</code>型用に導出してください。
このやり方についての説明は<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonautのドキュメント</a>をあたってください。
なお、この演習の単体試験を有効にするには、汎化された<code>Show</code>及び<code>Eq</code>インスタンスも必要になります。
しかしJSONのインスタンスと格闘したあとでは、これらの実装は直感的に進むことでしょう。</p>
</li>
<li>
<p>（難しい）以下の<code>data</code>型は整数か文字列かによってJSONで異なって表現されます。</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>この挙動を実装する<code>IntOrString</code>データ型に、<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを書いてください。
<em>手掛かり</em>：<code>Control.Alt</code>の<code>alt</code>演算子が役立つかもしれません。</p>
</li>
</ol>
<h2 id="住所録"><a class="header" href="#住所録">住所録</a></h2>
<p>この節では新しく獲得したFFIとJSONの知識を応用して、第8章の住所録の例を構築していきたいと思います。
以下の機能を加えていきます。</p>
<ul>
<li>保存ボタンをフォームの一番下に配置し、クリックしたときにフォームの状態をJSONに直列化してローカルストレージに保存します。</li>
<li>ページの再読み込み時にローカルストレージからJSON文書を自動的に取得します。
フォームのフィールドにはこの文書の内容を入れます。</li>
<li>フォームの状態を保存したり読み込んだりするのに問題があればポップアップの警告を出します。</li>
</ul>
<p><code>Effect.Storage</code>モジュールに以下のwebストレージAPIのためのFFIの梱包を作ることから始めていきます。</p>
<ul>
<li><code>setItem</code>はキーと値（両方とも文字列）を受け取り、指定されたキーでローカルストレージに値を格納する計算を返します。</li>
<li><code>getItem</code>はキーを取り、ローカルストレージから関連付けられたバリューの取得を試みます。
しかし<code>window.localStorage</code>の<code>getItem</code>メソッドは<code>null</code>を返しうるので、返る型は<code>String</code>ではなく<code>Json</code>です。</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>以下はこれらの関数に対応するJavaScriptの実装で、<code>Effect/Storage.js</code>にあります。</p>
<pre><code class="language-js">export const setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

export const getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>以下のように保存ボタンを作ります。</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: &quot;form-group row col-form-label&quot;
    , children:
        [ D.button
            { className: &quot;btn-primary btn&quot;
            , onClick: handler_ validateAndSave
            , children: [ D.text &quot;Save&quot; ]
            }
        ]
    }
</code></pre>
<p>そして<code>validateAndSave</code>関数中では、検証された<code>person</code>をJSON文字列とし、<code>setItem</code>を使って書き込みます。</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log &quot;Running validators&quot;
  case validatePerson' person of
    Left errs -&gt; log $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;
    Right validPerson -&gt; do
      setItem &quot;person&quot; $ stringify $ encodeJson validPerson
      log &quot;Saved&quot;
</code></pre>
<p>なお、この段階でコンパイルしようとすると以下のエラーに遭遇します。</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>これはなぜかというと<code>Person</code>レコード中の<code>PhoneType</code>が<code>EncodeJson</code>インスタンスを必要としているからです。
また、ついでに汎用のエンコードインスタンスとデコードインスタンスを導出していきます。
この仕組みについての詳細情報はargonautのドキュメントにあります。</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance Generic PhoneType _

instance EncodeJson PhoneType where encodeJson = genericEncodeJson
instance DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>これで<code>person</code>をローカルストレージに保存できます。
しかしデータを取得できない限りあまり便利ではありません。
次はそれに取り掛かりましょう。</p>
<p>ローカルストレージから「person」文字列で取得することから始めましょう。</p>
<pre><code class="language-hs">item &lt;- getItem &quot;person&quot;
</code></pre>
<p>そうしてローカルストレージ由来の文字列から<code>Person</code>レコードへ変換する補助関数を作ります。
なお、このストレージ中の文字列は<code>null</code>かもしれないので、正常に<code>String</code>としてデコードされるまでは外部の<code>Json</code>として表現します。
道中には他にも多くの変換工程があり、それぞれで<code>Either</code>の値を返します。
そのためこれらをまとめて<code>do</code>ブロックの中に纏めるのは理に適っています。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>そうしてこの結果が成功しているかどうか調べます。
もし失敗していればエラーをログ出力し、既定の<code>examplePerson</code>を使います。
そうでなければローカルストレージから取得した人物を使います。</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>最後にこの<code>initialPerson</code>を<code>props</code>レコードを介してコンポーネントに渡します。</p>
<pre><code class="language-hs">-- reactコンポーネントからJSXノードを作成します。
app = element addressBookApp { initialPerson }
</code></pre>
<p>そして状態フックで使うために別の箇所で拾い上げます。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>仕上げとして、各<code>Left</code>値の<code>String</code>に<code>lmap</code>を使って前置し、エラー文言の質を向上させます。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap (&quot;No string in local storage: &quot; &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap (&quot;Cannot parse JSON string: &quot;   &lt;&gt; _) $ jsonParser jsonString
  lmap               (&quot;Cannot decode Person: &quot;       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>最初のエラーのみがこのアプリの通常の操作内で起こります。
他のエラーはwebブラウザの開発ツールを開いてローカルストレージ中に保存された「person」文字列を編集し、そのページを参照することで引き起こせます。
どのようにJSON文字列を変更したかが、どのエラーを引き起こすかを決定します。
各エラーを引き起こせるかご確認ください。</p>
<p>これでローカルストレージについては押さえました。
次に<code>alert</code>動作を実装していきます。
この動作は<code>Effect.Console</code>モジュールの<code>log</code>動作に似ています。
唯一の相違点は<code>alert</code>動作が<code>window.alert</code>メソッドを使うことで、対して<code>log</code>動作は<code>console.log</code>メソッドを使っています。
そういうわけで<code>alert</code>は<code>window.alert</code>が定義された環境でのみ使うことができます。
webブラウザなどです。</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">export const alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>この警告が次の何れかの場合に現れるようにしたいです。</p>
<ul>
<li>利用者が検証エラーを含むフォームを保存しようと試みている。</li>
<li>状態がローカルストレージから取得できない。</li>
</ul>
<p>以上は単に以下の行で<code>log</code>を<code>alert</code>に置き換えるだけで達成できます。</p>
<pre><code class="language-hs">Left errs -&gt; alert $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;

alert $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
</code></pre>
<h2 id="演習-32"><a class="header" href="#演習-32">演習</a></h2>
<ol>
<li>（普通）<code>localStorage</code>オブジェクトの <code>removeItem</code>メソッドの梱包を書き、
<code>Effect.Storage</code>モジュールに外部関数を追加してください</li>
<li>（普通）「リセット」ボタンを追加してください。
このボタンをクリックすると新しく作った<code>removeItem</code>関数を呼び出してローカルストレージから「人物」の項目を削除します。</li>
<li>（簡単）JavaScriptの <code>Window</code>オブジェクトの <code>confirm</code>メソッドの梱包を書き、
<code>Effect.Alert</code>モジュールにその外部関数を追加してください。</li>
<li>（普通）利用者が「リセット」ボタンをクリックしたときにこの<code>confirm</code>関数を呼び出し、本当に住所録を白紙にしたいか尋ねるようにしてください。</li>
</ol>
<h2 id="まとめ-8"><a class="header" href="#まとめ-8">まとめ</a></h2>
<p>この章では、PureScriptから外部のJavaScriptコードを扱う方法を学びました。
また、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。</p>
<ul>
<li>外部関数が正しい表現を持っていることを確かめる重要性を見てきました。</li>
<li>外部型や<code>Json</code>データ型を使用することによって、null値やJavaScriptの他の型のデータのような特殊な場合に対処する方法を学びました。</li>
<li>安全にJSONデータを直列化・直列化復元する方法を見ました。</li>
</ul>
<p>より多くの例については、GitHubの<code>purescript</code>組織、<code>purescript-contrib</code>組織、及び<code>purescript-node</code>組織が、FFIを使用するライブラリの例を多数提供しています。
残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾つか見ていきます。</p>
<h2 id="補遺"><a class="header" href="#補遺">補遺</a></h2>
<h3 id="javascriptからpurescriptを呼び出す"><a class="header" href="#javascriptからpurescriptを呼び出す">JavaScriptからPureScriptを呼び出す</a></h3>
<p>少なくとも単純な型を持つ関数については、JavaScriptからPureScript関数を呼び出すのはとても簡単です。</p>
<p>例として以下のような簡単なモジュールを見てみましょう。</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m – n) n
</code></pre>
<p>この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。
PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装する開発者は型検証器の恩恵を受けることができます。
そういうわけで関数を定義するのにPureScriptを使いたくなるかもしれない良い例となっていますが、JavaScriptからそれを呼び出すためには条件があります。</p>
<p>この関数をJavaScriptから呼び出す方法を理解する上で重要なのは、PureScriptの関数は常に引数が1つのJavaScript関数へと変換され、引数へは次のように1つずつ適用していかなければならないということです。</p>
<pre><code class="language-javascript">import Test from 'Test.js';
Test.gcd(15)(20);
</code></pre>
<p>ここでは<code>spago build</code>でコンパイルされていることを前提としています。
SpagoはPureScriptモジュールをESモジュールにコンパイルするものです。
そのため、<code>import</code>を使って<code>Test</code>モジュールをインポートした後、<code>Test</code>オブジェクトの<code>gcd</code>関数を参照できました。</p>
<p><code>spago bundle-app</code>や<code>spago bundle-module</code>コマンドを使って生成されたJavaScriptを単一のファイルにまとめることもできます。
詳細な情報については<a href="https://github.com/purescript/spago#bundle-a-project-into-a-single-js-file">ドキュメント</a>をあたってください。</p>
<h3 id="名前の生成を理解する"><a class="header" href="#名前の生成を理解する">名前の生成を理解する</a></h3>
<p>PureScriptはコード生成時にできるだけ名前を保持することを目指します。
とりわけ、PureScriptやJavaScriptのキーワードでなければほとんどの識別子が保存されることが期待できます。
少なくとも最上位で宣言される名前についてはそうです。</p>
<p>識別子としてJavaScriptのキーワードを使う場合は、名前は2重のドル記号でエスケープされます。
例えば次のPureScriptコードを考えてみます。</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープされます。
例えばこのPureScriptコードを考えます。</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図している場合、識別子は英数字のみを使用し、JavaScriptのキーワードを避けることをお勧めします。
ユーザ定義演算子がPureScriptコードでの使用のために提供される場合、JavaScriptから使うための英数字の名前を持つ代替関数を提供しておくことをお勧めします。</p>
<h3 id="実行時のデータ表現"><a class="header" href="#実行時のデータ表現">実行時のデータ表現</a></h3>
<p>型はプログラムがある意味で「正しい」ことをコンパイル時に論証できるようにします。
つまり、その点については壊れることがありません。
しかし、これは何を意味するのでしょうか。
PureScriptでは、式の型は実行時の表現と互換性があることを意味します。</p>
<p>そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行時のデータ表現について理解することが重要です。
これはつまり、与えられた任意のPureScriptの式について、その値が実行時にどのように評価されるかという挙動を理解できるべきだということです。</p>
<p>幸いにもPureScriptの式はとりわけ実行時に単純な表現を持っています。
型を考慮すれば式の実行時のデータ表現を把握することが常に可能です。</p>
<p>単純な型については、対応関係はほとんど自明です。
例えば式が型 <code>Boolean</code>を持っていれば、実行時のその値 <code>v</code>は <code>typeof v === 'boolean'</code>を満たします。
つまり、型 <code>Boolean</code>の式は <code>true</code>もしくは <code>false</code>のどちらか一方の（JavaScriptの）値へと評価されます。
特に<code>null</code>や <code>undefined</code>に評価される型<code>Boolean</code>なPureScriptの式はありません。</p>
<p><code>Int</code>や<code>Number</code>や<code>String</code>の型の式についても似た法則が成り立ちます。
<code>Int</code>や<code>Number</code>型の式はnullでないJavaScriptの数へと評価されますし、<code>String</code>型の式はnullでないJavaScriptの文字列へと評価されます。
<code>typeof</code>を使った場合に型<code>Number</code>の値と見分けがつかなくなるにせよ、型<code>Int</code>の式は実行時に整数に評価されます。</p>
<p><code>Unit</code>についてはどうでしょうか。
<code>Unit</code>には現住 (<code>unit</code>) が1つのみで値が観測できないため、実のところ実行時に何で表現されるかは重要ではありません。
古いコードは<code>{}</code>を使って表現する傾向がありました。
しかし比較的新しいコードでは<code>undefined</code>を使う傾向にあります。
なので、<code>Unit</code>を表現するのに使うものは何であれ差し支えありませんが、<code>undefined</code>を使うことが推奨されます（関数から何も返さないときも<code>undefined</code>を返します）。</p>
<p>もっと複雑な型についてはどうでしょうか。</p>
<p>既に見てきたように、PureScriptの関数は引数が1つのJavaScriptの関数に対応しています。
厳密に言えばこうなります。
ある型<code>a</code>と<code>b</code>について、式<code>f</code>の型が<code>a -&gt; b</code>で、式<code>x</code>が型<code>a</code>についての適切な実行時表現の値へと評価されるとします。
このとき<code>f</code>はJavaScriptの関数へと評価されますが、この関数は<code>x</code>を評価した結果に<code>f</code>を適用すると型<code>b</code>の適切な実行時表現を持ちます。
単純な例としては、<code>String -&gt; String</code>型の式は、nullでないJavaScript文字列からnullでないJavaScript文字列への関数へと評価されます。</p>
<p>ご想像の通り、PureScriptの配列はJavaScriptの配列に対応しています。
しかし、PureScriptの配列は均質である、つまり全ての要素が同じ型を持っていることは覚えておいてください。
具体的には、もしPureScriptの式<code>e</code>が何らかの型<code>a</code>について型<code>Array a</code>を持つなら、<code>e</code>は（nullでない）JavaScript配列へと評価されます。
この配列の全ての要素は型<code>a</code>の適切な実行時表現を持ちます。</p>
<p>PureScriptのレコードがJavaScriptのオブジェクトへと評価されることは既に見てきました。
関数や配列の場合のように、そのラベルに関連付けられている型を考慮すれば、レコードのフィールド中のデータの実行時の表現について論証できます。
勿論、レコードのフィールドは、同じ型である必要はありません。</p>
<h3 id="adtの表現"><a class="header" href="#adtの表現">ADTの表現</a></h3>
<p>代数的データ型の全ての構築子について、PureScriptコンパイラは関数を定義することで新たなJavaScriptオブジェクト型を作成します。
これらの構築子はプロトタイプに基づいて新しいJavaScriptオブジェクトを作成する関数に対応しています。</p>
<p>例えば次のような単純なADTを考えてみましょう。</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>PureScriptコンパイラは、次のようなコードを生成します。</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>ここで2つのJavaScriptオブジェクト型<code>Zero</code>と<code>One</code>を見てください。
JavaScriptのキーワード<code>new</code>を使用すると、各型の値を作成できます。
引数を持つ構築子については、コンパイラは<code>value0</code>、<code>value1</code>などという名前のフィールドに、対応するデータを格納します。</p>
<p>PureScriptコンパイラは補助関数も生成します。
引数のない構築子については、コンパイラは構築子が使われるたびに <code>new</code>演算子を使うのではなく、データを再利用できるように
<code>value</code>プロパティを生成します。
1つ以上の引数を持つ構築子では、コンパイラは適切な表現を持つ引数を取り適切な構築子を適用する <code>create</code>関数を生成します。</p>
<p>1引数より多く取る構築子についてはどうでしょうか。
その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成します。
ただしこの場合、補助関数は2引数のカリー化された関数です。
例えば次のような代数的データ型を考えます。</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>このコードからは、次のようなJavaScriptコードが生成されます。</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>ここで、オブジェクト型<code>Two</code>の値はキーワード<code>new</code>または<code>Two.create</code>関数を使用すると作成できます。</p>
<p>newtypeの場合はまた少し異なります。
newtypeは代数的データ型のようなもので、単一の引数を取る単一の構築子を持つよう制限されていたことを思い出してください。
この場合、newtypeの実行時表現は、その引数の型と同じになります。</p>
<p>例えば、以下の電話番号を表すnewtypeは実行時にJavaScriptの文字列として表現されます。</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>newtypeは、関数呼び出しによる実行時のオーバーヘッドなく更なる型安全性のための層を提供するため、ライブラリを設計するのに便利です。</p>
<h3 id="量化された型の表現"><a class="header" href="#量化された型の表現">量化された型の表現</a></h3>
<p>量化された型（多相型）の式は、実行時は制限された表現になっています。
実際、所与の量化された型を持つ式がより少なくなりますが、それによりかなり効率的に推論できるのです。</p>
<p>例えば、次の多相型を考えてみます。</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>この型を持っている関数にはどんなものがあるでしょうか。
実は少なくとも1つ、この型を持つ関数が存在します。</p>
<pre><code class="language-haskell">identity :: forall a. a -&gt; a
identity a = a
</code></pre>
<blockquote>
<p>なお、<code>Prelude</code>に定義された実際の<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Category#v:identity"><code>identity</code></a>関数は僅かに違った型を持ちます。</p>
</blockquote>
<p>実のところ、<code>identity</code>関数はこの型の<em>唯一の</em>（全）関数です。
これは確かに間違いなさそうに思えますが（この型を持った <code>id</code>とは明らかに異なる式を書こうとしてみてください）、確かめるにはどうしたらいいでしょうか。
型の実行時表現を考えることによって確かめられます。</p>
<p>量化された型 <code>forall a. t</code>の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 <code>a</code>をどのように選んでも型 <code>t</code>の適切な実行時表現を持っていなければなりません。上の例では、型 <code>forall a. a -&gt; a</code>の関数は、 <code>String -&gt; String</code>、 <code>Number -&gt; Number</code>、 <code>Array Boolean -&gt; Array Boolean</code>などといった型について、適切な実行時表現を持っていなければなりません。 これらは、文字列から文字列、数から数の関数でなくてはなりません。</p>
<p>しかし、それだけでは充分ではありません。
量化された型の実行時表現は、これよりも更に厳しいものです。
任意の式が<em>パラメトリック多相的</em>であることを要求しています。
つまり、その実装において、引数の型についてのどんな情報も使うことができないのです。
この追加の条件は、以下のJavaScriptの関数のような問題のある実装が多相型に現住することを防止します。</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>確かにこの関数は文字列を取って文字列を返し、数を取って数を返す、といったものです。
しかしこの関数は追加条件を満たしていません。
引数の実行時の型を調べており、型<code>forall a. a -&gt; a</code>の正しい現住にはならないからです。</p>
<p>関数の引数の実行時の型を検査できなければ、唯一の選択肢は引数をそのまま返すことだけです。
したがって<code>id</code>は確かに<code>forall a. a -&gt; a</code>の唯一の現住なのです。</p>
<p><em>パラメトリック多相</em>と<em>パラメトリック性</em>についての詳しい議論は本書の範囲を超えています。
ただ、PureScriptの型は実行時に<em>消去</em>されており、PureScriptの多相関数は（FFIを使わない限り）引数の実行時表現を検査<em>できない</em>ため、この多相的なデータの表現が適切になっているという点にはご留意ください。</p>
<h3 id="制約のある型の表現"><a class="header" href="#制約のある型の表現">制約のある型の表現</a></h3>
<p>型クラス制約を持つ関数は、実行時に面白い表現を持っています。
関数の挙動はコンパイラによって選ばれた型クラスのインスタンスに依存する可能性があるため、関数には<em>型クラス辞書</em>と呼ばれる追加の引数が与えられます。
この辞書には選ばれたインスタンスから提供される型クラスの関数の実装が含まれます。</p>
<p>例えば以下は、<code>Show</code>型クラスを使う制約付きの型を持つ、単純なPureScript関数です。</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>生成されるJavaScriptは次のようになります。</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p><code>shout</code>は1引数ではなく、2引数の（カリー化された）関数にコンパイルされていることに注意してください。最初の引数 <code>dict</code>は
<code>Show</code>制約の型クラス辞書です。 <code>dict</code>には型 <code>a</code>の <code>show</code>関数の実装が含まれています。</p>
<p>最初の引数として明示的に<code>Data.Show</code>の型クラス辞書を渡すと、JavaScriptからこの関数を呼び出すことができます。</p>
<pre><code class="language-javascript">import { showNumber } from 'Data.Show'

shout(showNumber)(42);
</code></pre>
<h3 id="演習-33"><a class="header" href="#演習-33">演習</a></h3>
<ol>
<li>
<p>（簡単）これらの型の実行時の表現は何でしょうか。</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>これらの型を持つ式についてわかることは何でしょうか。</p>
</li>
<li>
<p>（普通）<code>spago build</code>を使ってコンパイルし、NodeJSの <code>import</code>機能を使ってモジュールをインポートすることで、JavaScriptから <code>arrays</code>ライブラリの関数を使ってみてください。
<em>手掛かり</em>：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。</p>
</li>
</ol>
<h3 id="副作用の表現"><a class="header" href="#副作用の表現">副作用の表現</a></h3>
<p><code>Effect</code>モナドも外部型として定義されています。
その実行時表現はとても単純です。
型<code>Effect a</code>の式は<strong>引数なしの</strong>JavaScript関数へと評価されます。
この関数はあらゆる副作用を実行し、型<code>a</code>の適切な実行時表現を持つ値を返します。</p>
<p><code>Effect</code>型構築子の定義は、 <code>Effect</code>モジュールで次のように与えられています。</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>簡単な例として、 <code>random</code>パッケージで定義される <code>random</code>関数を考えてみてください。その型は次のようなものでした。</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p><code>random</code>関数の定義は次のように与えられます。</p>
<pre><code class="language-javascript">export const random = Math.random;
</code></pre>
<p><code>random</code>関数は実行時には引数なしの関数として表現されていることに注目してください。
この関数は乱数生成という副作用を実行して返しますが、返り値は<code>Number</code>型の実行時表現と一致します。
<code>Number</code>型はnullでないJavaScriptの数です。</p>
<p>もう少し興味深い例として、<code>console</code>パッケージ中の<code>Effect.Console</code>モジュールで定義された <code>log</code>関数を考えてみましょう。
<code>log</code>関数は次の型を持っています。</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>この定義は次のようになっています。</p>
<pre><code class="language-javascript">export const log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>実行時の <code>log</code>の表現は、単一の引数のJavaScript関数で、引数なしの関数を返します。
内側の関数はコンソールに文言を書き込むという副作用を実行します。</p>
<p><code>Effect a</code>型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出すことができます。例えば、この
<code>main</code>関数は何らかの型<code>a</code>について<code>Effect a</code>という型でなければならないので、次のように実行できます。</p>
<pre><code class="language-javascript">import { main } from 'Main'

main();
</code></pre>
<p><code>spago bundle-app --to</code>または<code>spago run</code>を使用する場合、<code>Main</code>モジュールが定義されている場合は常に、この<code>main</code>の呼び出しを自動的に生成できます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モナドな冒険"><a class="header" href="#モナドな冒険">モナドな冒険</a></h1>
<h2 id="この章の目標-9"><a class="header" href="#この章の目標-9">この章の目標</a></h2>
<p>この章の目標は<em>モナド変換子</em>について学ぶことです。
モナド変換子は異なるモナドから提供された副作用を合成する方法を提供します。
動機付けとする例は、NodeJSのコンソール上で遊ぶことができるテキストアドベンチャーゲームです。
ゲームの様々な副作用（ロギング、状態、及び構成）が全てモナド変換子スタックによって提供されます。</p>
<h2 id="プロジェクトの準備-8"><a class="header" href="#プロジェクトの準備-8">プロジェクトの準備</a></h2>
<p>このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。</p>
<ul>
<li><code>ordered-collections</code> は不変のマップと集合のためのデータ型を提供します</li>
<li><code>transformers</code> は標準的なモナド変換子の実装を提供します</li>
<li><code>node-readline</code>はNodeJSが提供する<a href="http://nodejs.org/api/readline.html"><code>readline</code></a>インターフェイスへのFFIバインディングを提供します</li>
<li><code>optparse</code>はコマンドライン引数を処理するアプリカティブ構文解析器を提供します</li>
</ul>
<h2 id="ゲームの遊びかた"><a class="header" href="#ゲームの遊びかた">ゲームの遊びかた</a></h2>
<p>プロジェクトを走らせるには<code>spago run</code>を使います。</p>
<p>既定では使い方の文言が表示されます。</p>
<pre><code class="language-text">Monadic Adventures! A game to learn monad transformers

Usage: run.js (-p|--player &lt;player name&gt;) [-d|--debug]
  Play the game as &lt;player name&gt;

Available options:
  -p,--player &lt;player name&gt;
                           The player's name &lt;String&gt;
  -d,--debug               Use debug mode
  -h,--help                Show this help text
</code></pre>
<p>コマンドライン引数を与えるためには、追加の引数を直接アプリケーションに渡す<code>-a</code>オプション付きで<code>spago run</code>を呼び出すか、<code>spago bundle-app</code>とすればよいです。
2つ目の方法では<code>node</code>で直接走らせられるindex.jsファイルが作られます。</p>
<p>例えば<code>-p</code>オプションを使ってプレイヤー名を与えるには次のようにします。</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;
&gt;
</code></pre>
<pre><code class="language-text">$ spago bundle-app 
$ node index.js -p Phil
&gt;
</code></pre>
<p>プロンプトからは、<code>look</code>、<code>inventory</code>、<code>take</code>、<code>use</code>、<code>north</code>、<code>south</code>、<code>east</code>、<code>west</code>などのコマンドを入力できます。
<code>debug</code>コマンドもあり、<code>--debug</code>コマンドラインオプションを与えられていた場合に、ゲームの状態を出力できます。</p>
<p>ゲームは2次元の碁盤の目の上が舞台で、コマンド<code>north</code>、<code>south</code>、<code>east</code>、<code>west</code>を発行することによってプレイヤーが移動します。
ゲームにはアイテムの集まりがあり、プレイヤーの所有物であったり、ゲームの盤上の特定の位置にあったりします。
<code>take</code>コマンドを使うと、プレイヤーはアイテムを拾い上げられます。</p>
<p>参考までに、このゲームのひと通りの流れは次のようになります。</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre>
<p>このゲームはとても単純ですが、この章の目的は<code>transformers</code>パッケージを使用してこのような種類のゲームを素早く開発できるようにするライブラリを構築することです。</p>
<h2 id="stateモナド"><a class="header" href="#stateモナド">Stateモナド</a></h2>
<p><code>transformers</code>パッケージで提供されている幾つかのモナドを眺めることから始めましょう。</p>
<p>最初の例は<code>State</code>モナドです。
これは純粋なコードで<em>変更可能状態</em>をモデル化する手段を提供します。
既に<code>Effect</code>モナドによって提供される変更可能状態の手法について見てきました。
<code>State</code>はその代替を提供します。</p>
<p><code>State</code>型構築子は、状態の型<code>s</code>、及び返り値の型<code>a</code>という2種類の引数を取ります。
「<code>State</code>モナド」というように説明はしていますが、実際には<code>Monad</code>型クラスのインスタンスが任意の型<code>s</code>についての<code>State s</code>型構築子に対して提供されています。</p>
<p><code>Control.Monad.State</code>モジュールは以下のAPIを提供しています。</p>
<pre><code class="language-haskell">get     :: forall s.             State s s
gets    :: forall s. (s -&gt; a) -&gt; State s a
put     :: forall s. s        -&gt; State s Unit
modify  :: forall s. (s -&gt; s) -&gt; State s s
modify_ :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>なお、ここではこれらのAPIシグネチャは<code>State</code>型構築子を使った、単純化された形式で表されています。
実際のAPIは本章の後にある「型クラス」節で押さえる<code>MonadState</code>が関わってきます。
ですからIDEのツールチップやPursuitで違うシグネチャを見たとしても心配しないでください。</p>
<p>例を見てみましょう。
<code>State</code>モナドの使い方の1つとしては、整数の配列中の値を現在の状態に加えるものが考えられます。
状態の型<code>s</code>として<code>Int</code>を選択し、配列の走査に<code>traverse_</code>を使い、配列の各要素について<code>modify</code>を呼び出すと、これを実現できます。</p>
<pre><code class="language-haskell">import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class

sumArray :: Array Int -&gt; State Int Unit
sumArray = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre>
<p><code>Control.Monad.State</code>モジュールは、<code>State</code>モナドで計算するための次の3つの関数を提供します。</p>
<pre><code class="language-haskell">evalState :: forall s a. State s a -&gt; s -&gt; a
execState :: forall s a. State s a -&gt; s -&gt; s
runState  :: forall s a. State s a -&gt; s -&gt; Tuple a s
</code></pre>
<p>3つの各関数は型<code>s</code>の初期状態と型<code>State s a</code>の計算を引数に取ります。
<code>evalState</code>は返り値だけを返し、<code>execState</code>は最終的な状態だけを返し、<code>runState</code>は<code>Tuple a s</code>型の値として表現された両方を返します。</p>
<p>先ほどの <code>sumArray</code>関数が与えられているとき、PSCiで <code>execState</code>を使うと次のように複数の配列内の数字を合計できます。</p>
<pre><code class="language-text">&gt; :paste
… execState (do
…   sumArray [1, 2, 3]
…   sumArray [4, 5]
…   sumArray [6]) 0
… ^D
21
</code></pre>
<h2 id="演習-34"><a class="header" href="#演習-34">演習</a></h2>
<ol>
<li>
<p>（簡単）上の例で、<code>execState</code>を<code>runState</code>や<code>evalState</code>で置き換えると結果はどうなるでしょうか。</p>
</li>
<li>
<p>（普通）括弧からなる文字列が<em>平衡している</em>のは、0個以上のより短い平衡した文字列を連結したものか、より短い平衡した文字列を一対の括弧で囲んだものかの何れかです。</p>
<p><code>State</code>モナドと <code>traverse_</code>関数を使用して、次のような関数を書いてください。</p>
<pre><code class="language-haskell">testParens :: String -&gt; Boolean
</code></pre>
<p>これは、まだ閉じられていない開括弧の数を把握することで、括弧の<code>String</code>が平衡しているかどうかを調べる関数です。
この関数は次のように動作します。</p>
<pre><code class="language-text">&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false
</code></pre>
<p><em>手掛かり</em>：入力の文字列を文字の配列に変換するのに、<code>Data.String.CodeUnits</code>モジュールの <code>toCharArray</code>関数を使うと良いでしょう。</p>
</li>
</ol>
<h2 id="readerモナド"><a class="header" href="#readerモナド">Readerモナド</a></h2>
<p><code>transformers</code>パッケージでは <code>Reader</code>というモナドも提供されています。
このモナドは大域的な設定を読み取る機能を提供します。
<code>State</code>モナドが1つの可変状態を読み書きする機能を提供するのに対し、 <code>Reader</code>モナドは1つのデータの読み取り機能だけを提供します。</p>
<p><code>Reader</code>型構築子は、設定の型を表す型 <code>r</code>、及び戻り値の型 <code>a</code>の2つの型引数を取ります。</p>
<p><code>Control.Monad.Reader</code>モジュールは以下のAPIを提供します。</p>
<pre><code class="language-haskell">ask   :: forall r. Reader r r
local :: forall r a. (r -&gt; r) -&gt; Reader r a -&gt; Reader r a
</code></pre>
<p><code>ask</code>動作は現在の設定を読み取るために使い、<code>local</code>動作は変更された設定で計算するために使います。</p>
<p>例えば、権限で制御するアプリケーションを開発しており、現在の利用者の権限オブジェクトを保持するのに <code>Reader</code>モナドを使いたいとしましょう。
型 <code>r</code>を次のようなAPIを備えた型 <code>Permission</code>として選択できます。</p>
<pre><code class="language-haskell">hasPermission :: String -&gt; Permissions -&gt; Boolean
addPermission :: String -&gt; Permissions -&gt; Permissions
</code></pre>
<p>利用者が特定の権限を持っているかどうかを確認したいときは、 <code>ask</code>を使って現在の権限オブジェクトを取得すればいつでも調べることができます。
例えば管理者だけが新しい利用者の作成を許可されているとしましょう。</p>
<pre><code class="language-haskell">createUser :: Reader Permissions (Maybe User)
createUser = do
  permissions &lt;- ask
  if hasPermission &quot;admin&quot; permissions
    then map Just newUser
    else pure Nothing
</code></pre>
<p><code>local</code>動作を使うと、計算の実行中に <code>Permissions</code>オブジェクトを変更し、ユーザーの権限を昇格させることもできます。</p>
<pre><code class="language-haskell">runAsAdmin :: forall a. Reader Permissions a -&gt; Reader Permissions a
runAsAdmin = local (addPermission &quot;admin&quot;)
</code></pre>
<p>こうすると、利用者が <code>admin</code>権限を持っていなかった場合であっても新しい利用者を作成できるような関数を書くことができます。</p>
<pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre>
<p><code>Reader</code>モナドを計算するには、大域的な設定を与える<code>runReader</code>関数を使います。</p>
<pre><code class="language-haskell">runReader :: forall r a. Reader r a -&gt; r -&gt; a
</code></pre>
<h2 id="演習-35"><a class="header" href="#演習-35">演習</a></h2>
<p>以下の演習では、 <code>Reader</code>モナドを使って、字下げのついた文書を出力するための小さなライブラリを作っていきます。
「大域的な設定」は、現在の字下げの深さを示す数になります。</p>
<pre><code class="language-haskell">type Level = Int

type Doc = Reader Level String
</code></pre>
<ol>
<li>
<p>（簡単）現在の字下げの深さで関数を書き出す関数<code>line</code>を書いてください。
関数は以下の型を持ちます。</p>
<pre><code class="language-haskell">line :: String -&gt; Doc
</code></pre>
<p><em>手掛かり</em>：現在の字下げの深さを読み取るためには <code>ask</code>関数を使用します。
<code>Data.Monoid</code>の<code>power</code>関数も役に立つかもしれません。</p>
</li>
<li>
<p>（普通）<code>local</code>関数を使用して次の関数を書いてください。</p>
<pre><code class="language-haskell">indent :: Doc -&gt; Doc
</code></pre>
<p>この関数はコードブロックの字下げを深くします。</p>
</li>
<li>
<p>（普通）<code>Data.Traversable</code>で定義された <code>sequence</code>関数を使用して、次の関数を書いてください。</p>
<pre><code class="language-haskell">cat :: Array Doc -&gt; Doc
</code></pre>
<p>この関数は文書の集まりを改行で区切って連結します。</p>
</li>
<li>
<p>（普通）<code>runReader</code>関数を使用して次の関数を書いてください。</p>
<pre><code class="language-haskell">render :: Doc -&gt; String
</code></pre>
<p>この関数は文書を文字列として出力します。</p>
</li>
</ol>
<p>これでライブラリを使って以下のような単純な文書を書けるようになりました。</p>
<pre><code class="language-haskell">render $ cat
  [ line &quot;Here is some indented text:&quot;
  , indent $ cat
      [ line &quot;I am indented&quot;
      , line &quot;So am I&quot;
      , indent $ line &quot;I am even more indented&quot;
      ]
  ]
</code></pre>
<h2 id="writerモナド"><a class="header" href="#writerモナド">Writerモナド</a></h2>
<p><code>Writer</code>モナドでは、計算の返り値に加えてもう1つの値を累算できます。</p>
<p>よくある使い方としては型<code>String</code>もしくは<code>Array String</code>でログを累算していくというものなどがありますが、<code>Writer</code>モナドはこれよりもっと一般的なものです。
累算するのに任意のモノイドの値を使うことができるので、<code>Additive Int</code>モノイドを使って整数の合計を追跡するのに使ったり、<code>Disj Boolean</code>モノイドを使って途中の<code>Boolean</code>値の何れかが真であるかどうかを追跡するのに使えます。</p>
<p><code>Writer</code>型構築子は2つの型引数を取ります。
<code>Monoid</code>型クラスのインスタンスである型<code>w</code>と返り値の型<code>a</code>です。</p>
<p><code>Writer</code>のAPIで重要なのは <code>tell</code>関数です。</p>
<pre><code class="language-haskell">tell :: forall w a. Monoid w =&gt; w -&gt; Writer w Unit
</code></pre>
<p><code>tell</code>動作は与えられた値を現在の累算結果に付け加えます。</p>
<p>例として、<code>Array String</code>モノイドを使用して、既存の関数にログを追加してみましょう。
<em>最大公約数</em>関数の以前の実装を考えてみます。</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p><code>Writer (Array String) Int</code>へと返り値の型を変更することで、この関数にログ機能を追加できます。</p>
<pre><code class="language-haskell">import Control.Monad.Writer
import Control.Monad.Writer.Class

gcdLog :: Int -&gt; Int -&gt; Writer (Array String) Int
</code></pre>
<p>各手順での2つの入力を記録するためには、少し関数を変更する必要があります。</p>
<pre><code class="language-haskell">    gcdLog n 0 = pure n
    gcdLog 0 m = pure m
    gcdLog n m = do
      tell [&quot;gcdLog &quot; &lt;&gt; show n &lt;&gt; &quot; &quot; &lt;&gt; show m]
      if n &gt; m
        then gcdLog (n - m) m
        else gcdLog n (m - n)
</code></pre>
<p><code>Writer</code>モナドを計算するには、<code>execWriter</code>関数または<code>runWriter</code>関数の何れかを使います。</p>
<pre><code class="language-haskell">execWriter :: forall w a. Writer w a -&gt; w
runWriter  :: forall w a. Writer w a -&gt; Tuple a w
</code></pre>
<p>ちょうど <code>State</code>モナドの場合と同じように、 <code>execWriter</code>が累算されたログだけを返すのに対して、
<code>runWriter</code>は累算されたログと結果の両方を返します。</p>
<p>PSCiで改変した関数を試してみましょう。</p>
<pre><code class="language-text">&gt; import Control.Monad.Writer
&gt; import Control.Monad.Writer.Class

&gt; runWriter (gcdLog 21 15)
Tuple 3 [&quot;gcdLog 21 15&quot;,&quot;gcdLog 6 15&quot;,&quot;gcdLog 6 9&quot;,&quot;gcdLog 6 3&quot;,&quot;gcdLog 3 3&quot;]
</code></pre>
<h2 id="演習-36"><a class="header" href="#演習-36">演習</a></h2>
<ol>
<li>
<p>（普通）<code>Writer</code>モナドと <code>monoid</code>パッケージの <code>Additive Int</code>モノイドを使うように、上の
<code>sumArray</code>関数を書き換えてください。</p>
</li>
<li>
<p>（普通）<em>コラッツ</em>関数は自然数 \( n \) 上で定義され、 \( n \) が偶数なら \( n / 2 \)、 \( n
\) が奇数なら \( 3 n + 1 \)です。
例えば \( 10 \) で始まるコラッツ数列は以下です。</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的に  \( 1 \) になるということが予想されています。</p>
<p>再帰を使い、数列が \( 1 \) に到達するまでに何回のコラッツ関数の適用が必要かを計算する関数を書いてください。</p>
<p><code>Writer</code>モナドを使用してコラッツ関数の各適用の経過を記録するように、関数を変更してください。</p>
</li>
</ol>
<h2 id="モナド変換子"><a class="header" href="#モナド変換子">モナド変換子</a></h2>
<p>上の3つのモナド、<code>State</code>、<code>Reader</code>、<code>Writer</code>は、何れもいわゆる<em>モナド変換子</em>の例となっています。
対応する各モナド変換子はそれぞれ<code>StateT</code>、<code>ReaderT</code>、<code>WriterT</code>という名前です。</p>
<p>モナド変換子とは何でしょうか。
さて、これまで見てきたように、モナドはPureScriptのコードを何らかの種類の副作用で拡張するものでした。
このモナドはPureScriptで適切な制御子（<code>runState</code>、 <code>runReader</code>、<code>runWriter</code>など）を使って解釈できます。
使用する必要がある副作用が<em>1つだけ</em>なら、これで問題ありません。
しかし、同時に複数の副作用を使用できると便利なことがよくあります。
例えば、 <code>Maybe</code>と<code>Reader</code>を一緒に使用すると、ある大域的な設定の文脈で<em>省略可能な結果</em>を表現できます。
もしくは、 <code>Either</code>モナドの純粋なエラー追跡機能と、 <code>State</code>モナドが提供する変更可能な状態が同時に欲しくなるかもしれません。
この問題を解決するのが<em>モナド変換子</em>です。</p>
<p>ただし<code>Effect</code>モナドがこの問題を部分的に解決することは既に見ました。
モナド変換子はまた違った解決策を提供しますが、これらの各手法には利点と制約があります。</p>
<p>モナド変換子は型と別の型構築子を引数に取る型構築子です。
モナドを1つ取り、独自の様々な副作用を追加した別のモナドへと変換します。</p>
<p>例を見てみましょう。<code>State</code>のモナド変換子版は<code>Control.Monad.State.Trans</code>モジュールで定義されている<code>StateT</code>です。
PSCiを使って <code>StateT</code>の種を見てみましょう。</p>
<pre><code class="language-text">&gt; import Control.Monad.State.Trans
&gt; :kind StateT
Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>とても読みにくそうに見えるかもしれませんが、使い方を理解するために、<code>StateT</code>に1つ引数を与えてみましょう。</p>
<p><code>State</code>の場合、最初の型引数は使いたい状態の型です。
それでは型<code>String</code>を与えてみましょう。</p>
<pre><code class="language-text">&gt; :kind StateT String
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>次の引数は種 <code>Type -&gt; Type</code>の型構築子です。
これは <code>StateT</code>の機能を追加したい元のモナドを表します。
例として、 <code>Either String</code>モナドを選んでみます。</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String)
Type -&gt; Type
</code></pre>
<p>型構築子が残りました。
最後の引数は戻り値の型を表しており、例えばそれを<code>Number</code>にできます。</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String) Number
Type
</code></pre>
<p>最後に種<code>Type</code>の何かが残りました。
つまりこの型の値を探してみることができます。</p>
<p>構築したモナド<code>StateT String (Either String)</code>は、エラーで失敗する可能性があり、変更可能な状態を使える計算を表しています。</p>
<p>外側の<code>StateT String</code>モナドの動作（<code>get</code>、<code>put</code>、<code>modify</code>）は直接使えますが、梱包されているモナド (<code>Either String</code>) の作用を使うためには、これらの関数をモナド変換子まで「持ち上げ」る必要があります。
<code>Control.Monad.Trans</code>モジュールは<code>MonadTrans</code>型クラスを定義しています。
これはモナド変換子であるそうした型構築子を捕捉します。</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>このクラスは単一のメンバー<code>lift</code>を含みます。
これは通底する任意のモナド<code>m</code>の計算を取り、梱包されたモナド<code>t m</code>へと持ち上げるものです。
今回の場合、型構築子<code>t</code>は<code>StateT String</code>で、<code>m</code>は<code>Either String</code>モナドとなるので、<code>lift</code>は型<code>Either String a</code>の計算を、型<code>StateT String (Either String) a</code>の計算へと持ち上げる方法を提供することになります。
つまり、型<code>Either String a</code>の計算を使う場合に毎回<code>lift</code>を使うのであれば、<code>StateT String</code>と<code>Either String</code>の作用を使えます。</p>
<p>例えば、次の計算は通底する状態を読み、状態が空文字列であればエラーを投げます。</p>
<pre><code class="language-haskell">import Data.String (drop, take)

split :: StateT String (Either String) String
split = do
  s &lt;- get
  case s of
    &quot;&quot; -&gt; lift $ Left &quot;Empty string&quot;
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>状態が空でなければ、この計算は<code>put</code>を使って状態を<code>drop 1 s</code>（つまり<code>s</code>から最初の文字を取り除いたもの）へと更新し、<code>take 1 s</code>（<code>s</code>の最初の文字）を返します。</p>
<p>それではPSCiでこれを試してみましょう。</p>
<pre><code class="language-text">&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;
</code></pre>
<p>これは<code>StateT</code>を使わなくても実装できるので、さほど驚くようなことはありません。
しかし、モナドの中で扱っているので、do記法やアプリカティブコンビネータを使って、小さな計算から大きな計算を構築できます。
例えば、2回<code>split</code>を適用すると、文字列から最初の2文字を読めます。</p>
<pre><code class="language-text">&gt; runStateT ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple &quot;te&quot; &quot;st&quot;))
</code></pre>
<p><code>split</code>関数とその他沢山の動作を使えば基本的な構文解析ライブラリを構築できます。
実際、これは<code>parsing</code>ライブラリで採用されている手法です。
これがモナド変換子の力なのです。
必要な副作用を選択し、do記法とアプリカティブコンビネータで表現力を維持しながら、様々な問題のための特注のモナドを作成できるのです。</p>
<h2 id="excepttモナド変換子"><a class="header" href="#excepttモナド変換子">ExceptTモナド変換子</a></h2>
<p><code>transformers</code>パッケージでは<code>ExceptT e</code>モナド変換子も定義されています。
これは<code>Either e</code>モナドに対応するもので、以下のAPIを提供します。</p>
<pre><code class="language-haskell">class MonadError e m where
  throwError :: forall a. e -&gt; m a
  catchError :: forall a. m a -&gt; (e -&gt; m a) -&gt; m a

instance Monad m =&gt; MonadError e (ExceptT e m)

runExceptT :: forall e m a. ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p><code>MonadError</code>クラスは<code>e</code>型のエラーを投げたり捕えたりに対応するモナドを捕捉し、<code>ExceptT e</code>モナド変換子のインスタンスが提供されます。
<code>Either e</code>モナドの<code>Left</code>と同じように、<code>throwError</code>動作では失敗を示せます。
<code>catchError</code>動作では<code>throwError</code>を使ってエラーが投げられた後に処理を継続できます。</p>
<p><code>runExceptT</code>制御子を使うと、型 <code>ExceptT e m a</code>を計算できます。</p>
<p>このAPIは <code>exceptions</code>パッケージの <code>Exception</code>作用によって提供されているものと似ています。
しかし、幾つかの重要な違いがあります。</p>
<ul>
<li><code>Exception</code>が実際のJavaScriptの例外を使っているのに対して<code>ExceptT</code>モデルは代数的データ型を使っています。</li>
<li><code>Exception</code>作用がJavaScriptの<code>Error</code>型という1つの例外の型だけを扱うのに対して、<code>ExceptT</code>は<code>Error</code>型クラスのどんな型のエラーでも扱います。つまり、
<code>ExceptT</code>では新たなエラー型を自由に定義できます。</li>
</ul>
<p>試しに<code>ExceptT</code>を使って<code>Writer</code>モナドを包んでみましょう。
ここでもモナド変換子<code>ExceptT e</code>の動作を直接使うことも自由にできますが、<code>Writer</code>モナドの計算は<code>lift</code>を使って持ち上げるべきです。</p>
<pre><code class="language-haskell">import Control.Monad.Except
import Control.Monad.Writer

writerAndExceptT :: ExceptT String (Writer (Array String)) String
writerAndExceptT = do
  lift $ tell [&quot;Before the error&quot;]
  _ &lt;- throwError &quot;Error!&quot;
  lift $ tell [&quot;After the error&quot;]
  pure &quot;Return value&quot;
</code></pre>
<p>PSCiでこの関数を試すと、ログの蓄積とエラーの送出という2つの作用がどのように相互作用しているのかを見ることができます。
まず、 <code>runExceptT</code>を使って外側の<code>ExceptT</code>を計算し、型 <code>Writer (Array String) (Either String String)</code>の結果を残します。
それから、 <code>runWriter</code>で内側の<code>Writer</code>を計算します。</p>
<pre><code class="language-text">&gt; runWriter $ runExceptT writerAndExceptT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]
</code></pre>
<p>なお、エラーが投げられる前に書き出されるログ文言だけがログに追記されます。</p>
<h2 id="モナド変換子スタック"><a class="header" href="#モナド変換子スタック">モナド変換子スタック</a></h2>
<p>これまで見てきたように、モナド変換子を使って既存のモナドを土台に新しいモナドを構築できます。
何かのモナド変換子<code>t1</code>とモナド<code>m</code>について、その適用<code>t1 m</code>もまたモナドになります。
つまり、<em>2つめの</em>モナド変換子<code>t2</code>を結果<code>t1 m</code>に適用すると、3つ目のモナド<code>t2 (t1 m)</code>を作れます。
このようにしてモナド変換子の<em>スタック</em>を構築できます。
これは構成されるモナドによって提供される副作用を組み合わせるものです。</p>
<p>実際には、通底するモナド<code>m</code>は、ネイティブの副作用が必要なら<code>Effect</code>モナド、さもなくば<code>Data.Identity</code>モジュールで定義されている<code>Identity</code>モナドになります。
<code>Identity</code>モナドは何の新しい副作用も追加しませんから、<code>Identity</code>モナドの変換はモナド変換子の作用だけを提供します。
<code>State</code>、<code>Reader</code>、<code>Writer</code>モナドは、<code>Identity</code>モナドをそれぞれ<code>StateT</code>、<code>ReaderT</code>、<code>WriterT</code>で変換することによって実装されています。</p>
<p>3つの副作用が組み合わっている例を見てみましょう。
<code>Identity</code>モナドをスタックの底にして、<code>StateT</code>、<code>WriterT</code>、<code>ExceptT</code>作用を使います。
このモナド変換子スタックは、可変状態、ログの蓄積、そして純粋なエラーの副作用を提供します。</p>
<p>このモナド変換子スタックを使うと、ロギングの機能が追加された <code>split</code>アクションに作り変えられます。</p>
<pre><code class="language-haskell">type Errors = Array String

type Log = Array String

type Parser = StateT String (WriterT Log (ExceptT Errors Identity))

split :: Parser String
split = do
  s &lt;- get
  lift $ tell [&quot;The state is &quot; &lt;&gt; s]
  case s of
    &quot;&quot; -&gt; lift $ lift $ throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>この計算をPSCiで試してみると、 <code>split</code>が実行されるたびに状態がログに追加されることがわかります。</p>
<p>なお、モナド変換子スタックに現れる順序で副作用を取り除いていかなければなりません。
最初に<code>StateT</code>型構築子を取り除くために<code>runStateT</code>を、それから<code>runtWriteT</code>、<code>runExceptT</code>を使います。
最後に<code>unwrap</code>を使用して<code>Identity</code>モナド中で計算します。</p>
<pre><code class="language-text">&gt; runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
(Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;]))

&gt; runParser ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;]))
</code></pre>
<p>しかし、状態が空であることが理由で解析が失敗した場合、ログは全く出力されません。</p>
<pre><code class="language-text">&gt; runParser split &quot;&quot;
(Left [&quot;Empty string&quot;])
</code></pre>
<p>これは、<code>ExceptT</code>モナド変換子が提供する副作用と<code>WriterT</code>モナド変換子が提供する副作用との関係によるものです。
これはモナド変換子スタックが構成されている順序を変更することで対処できます。
スタックの最上部に<code>ExceptT</code>変換子を移動すると、先ほど<code>Writer</code>を<code>ExceptT</code>に変換したときに見たように、最初のエラーまでに書かれた全ての文言がログに含まれるようになります。</p>
<p>このコードの問題の1つは、複数のモナド変換子の上まで計算を持ち上げるために、<code>lift</code>関数を複数回使わなければならないということです。
例えば<code>throwError</code>の呼び出しは、1回目は<code>WriteT</code>へ、2回目は<code>StateT</code>へ、と2回持ちあげなければなりません。
小さなモナド変換子スタックならなんとかなりますが、そのうちすぐに不便になるでしょう。</p>
<p>幸いなことに、これから見るような型クラス推論によって提供されるコードの自動生成を使うと、ほとんどの「重労働」を任せられます。</p>
<h2 id="演習-37"><a class="header" href="#演習-37">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Identity</code>関手を土台とする<code>ExceptT</code>モナド変換子を使って、2つの数の商を求める関数
<code>safeDivide</code>を書いてください。
この関数は分母がゼロの場合に（文字列「Divide by zero!」の）エラーを投げます。</p>
</li>
<li>
<p>（普通）次のような構文解析関数を書いてください。</p>
<pre><code class="language-haskell">string :: String -&gt; Parser String
</code></pre>
<p>これは現在の状態が接頭辞に照合するか、もしくはエラー文言とともに失敗します。</p>
<p>この構文解析器は次のように動作します。</p>
<pre><code class="language-text">&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;
(Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;]))
</code></pre>
<p><em>手掛かり</em>：出発点として<code>split</code>の実装が使えます。
<code>stripPrefix</code>関数も役に立つかもしれません。</p>
</li>
<li>
<p>（難しい）文書表示ライブラリを、<code>ReaderT</code>と<code>WriterT</code>モナド変換子を使用して再実装してください。
以前<code>Reader</code>モナドを使用して書いたものです。</p>
<p>文字列を出力する <code>line</code>や文字列を連結する <code>cat</code>を使うのではなく、<code>WriteT</code>モナド変換子と一緒に <code>Array String</code>モノイドを使い、結果へ行を追加するのに <code>tell</code>を使ってください。
アポストロフィ (<code>'</code>) を付ける以外は元の実装と同じ名前を使ってください。</p>
</li>
</ol>
<h2 id="型クラスが助けに来たぞっ"><a class="header" href="#型クラスが助けに来たぞっ">型クラスが助けに来たぞっ</a></h2>
<p>本章の最初で扱った <code>State</code>モナドを見てみると、 <code>State</code>モナドの動作には次のような型が与えられていました。</p>
<pre><code class="language-haskell">get    :: forall s.             State s s
put    :: forall s. s        -&gt; State s Unit
modify :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>モジュールで与えられている型は、実際にはこれよりもっと一般的です。</p>
<pre><code class="language-haskell">get    :: forall m s. MonadState s m =&gt;             m s
put    :: forall m s. MonadState s m =&gt; s        -&gt; m Unit
modify :: forall m s. MonadState s m =&gt; (s -&gt; s) -&gt; m Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>モジュールには<code>MonadState</code>（多変数）型クラスが定義されています。
この型クラスは「変更可能な状態を提供する純粋なモナド」への抽象化を可能にします。
予想できると思いますが、 <code>State s</code>型構築子は <code>MonadState s</code>型クラスのインスタンスになっており、このクラスには他にも興味深いインスタンスが数多くあります。</p>
<p>特に、<code>transformers</code>パッケージではモナド変換子<code>WriterT</code>、<code>ReaderT</code>、<code>ExceptT</code>についての<code>MonadState</code>のインスタンスがあります。
通底する<code>Monad</code>が<code>MonadState</code>インスタンスを持つなら常に、これらもインスタンスを持ちます。
つまり実際には、<code>StateT</code>がモナド変換子スタックの<em>どこか</em>に現れ、<code>StateT</code>より上の全てが<code>MonadState</code>のインスタンスであれば、<code>lift</code>を使う必要なく<code>get</code>や<code>put</code>や<code>modify</code>を直接自由に使用できます。</p>
<p>当然ですが、これまで扱ってきた<code>ReaderT</code>、<code>WriterT</code>、<code>ExceptT</code>変換子についても、同じことが言えます。
<code>transformers</code>では主な各変換子について型クラスが定義されています。
これによりそれらの操作に対応するモナドの上に抽象化できるのです。</p>
<p>上の<code>split</code>関数の場合、構築したモナドスタックは各型クラス<code>MonadState</code>、<code>MonadWriter</code>、<code>MonadError</code>のインスタンスです。
つまり<code>lift</code>は全く呼び出す必要がないのです。
まるでモナドスタック自体に定義されていたかのように、動作<code>get</code>、<code>put</code>、<code>tell</code>、<code>throwError</code>をそのまま使用できます。</p>
<pre><code class="language-haskell">split :: Parser String
split = do
  s &lt;- get
  tell [&quot;The state is &quot; &lt;&gt; show s]
  case s of
    &quot;&quot; -&gt; throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>この計算は、独自のプログラミング言語を拡張し、可変状態、ロギング、エラー処理という3つの新しい副作用に対応したように見えます。
しかし、内部的には全てはあくまで純粋な関数と不変のデータを使って実装されているのです。</p>
<h2 id="代替"><a class="header" href="#代替">代替</a></h2>
<p><code>control</code>パッケージでは失敗しうる計算を扱う抽象化が数多く定義されています。
その1つは<code>Alternative</code>型クラスです。</p>
<pre><code class="language-haskell">class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<p><code>Alternative</code>は2つの新しいコンビネータを提供しています。
1つは失敗しうる計算の雛形を提供する<code>empty</code>値で、もう1つはエラーが起きたときに<em>代替の</em>計算へ戻ってやり直す機能を提供する<code>alt</code>関数（そしてその別名<code>&lt;|&gt;</code>）です。</p>
<p><code>Data.Array</code>モジュールでは <code>Alternative</code>型クラスで型構築子を操作する2
つの便利な関数を提供します。</p>
<pre><code class="language-haskell">many :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
some :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
</code></pre>
<p><code>Data.List</code>にも等価な<code>many</code>と<code>some</code>があります。</p>
<p><code>many</code>コンビネータは計算を<em>ゼロ回以上</em>繰り返し実行するために<code>Alternative</code>型クラスを使います。
<code>some</code>コンビネータも似ていますが、最低1回は計算が成功する必要があります。</p>
<p><code>Parser</code>モナド変換子スタックの場合は、<code>ExceptT</code>コンポーネントによる<code>Alternative</code>のインスタンスがあります。
このコンポーネントでは異なる分枝のエラーに<code>Monoid</code>インスタンスを使って組み合わせることによって対応しています（だから<code>Errors</code>型に<code>Array String</code>を選ぶ必要があったんですね）。
これは、構文解析器を複数回実行するのに<code>many</code>関数と<code>some</code>関数を使うことができることを意味します。</p>
<pre><code class="language-text">&gt; import Data.Array (many)

&gt; runParser (many split) &quot;test&quot;
(Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;)
              [ &quot;The state is \&quot;test\&quot;&quot;
              , &quot;The state is \&quot;est\&quot;&quot;
              , &quot;The state is \&quot;st\&quot;&quot;
              , &quot;The state is \&quot;t\&quot;&quot;
              ]))
</code></pre>
<p>ここでは入力文字列 <code>&quot;test&quot;</code>は、1文字からなる文字列4つの配列を返すように繰り返し分割されています。
残った状態は空で、ログは <code>split</code>コンビネータが4回適用されたことを示しています。</p>
<h2 id="モナド内包表記"><a class="header" href="#モナド内包表記">モナド内包表記</a></h2>
<p><code>Control.MonadPlus</code>モジュールには <code>MonadPlus</code>と呼ばれる<code>Alternative</code>型クラスの副クラスが定義されています。
<code>MonadPlus</code>はモナドと<code>Alternative</code>両方のインスタンスである型構築子を取ります。</p>
<pre><code class="language-haskell">class (Monad m, Alternative m) &lt;= MonadPlus m
</code></pre>
<p>実際、<code>Parser</code>モナドは <code>MonadPlus</code>のインスタンスです。</p>
<p>以前本書中で配列内包表記を押さえたとき、<code>guard</code>関数を導入しました。
これは欲しくない結果を取り除けるのに使えました。
実際には<code>guard</code>関数はもっと一般的で、<code>MonadPlus</code>のインスタンスである任意のモナドに対して使えます。</p>
<pre><code class="language-haskell">guard :: forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p><code>&lt;|&gt;</code>演算子は失敗時にバックトラッキングできるようにします。
これがどのように役立つかを見るために、大文字だけに照合する<code>split</code>コンビネータの亜種を定義してみましょう。</p>
<pre><code class="language-haskell">upper :: Parser String
upper = do
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre>
<p>ここで、文字列が大文字でない場合に失敗するよう、<code>guard</code>を使用しています。
なお、このコードは前に見た配列内包表記とよく似ています。
このように<code>MonadPlus</code>を使うことは、<em>モナド内包表記</em>の構築と呼ばれることがあります。</p>
<h2 id="バックトラッキング"><a class="header" href="#バックトラッキング">バックトラッキング</a></h2>
<p><code>&lt;|&gt;</code>演算子を使うと、失敗したときに別の代替計算へとバックトラックできます。
これを確かめるために、小文字に一致するもう1つの構文解析器を定義してみましょう。</p>
<pre><code class="language-haskell">lower :: Parser String
lower = do
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre>
<p>これにより、まずもし最初の文字が大文字なら複数の大文字に照合し、さもなくばもし最初の文字が小文字なら複数の小文字に照合する、という構文解析器を定義できます。</p>
<pre><code class="language-text">&gt; upperOrLower = some upper &lt;|&gt; some lower
</code></pre>
<p>この構文解析器は、大文字と小文字が切り替わるまで、文字に照合し続けます。</p>
<pre><code class="language-text">&gt; runParser upperOrLower &quot;abcDEF&quot;
(Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;))
              [ &quot;The state is \&quot;abcDEF\&quot;&quot;
              , &quot;The state is \&quot;bcDEF\&quot;&quot;
              , &quot;The state is \&quot;cDEF\&quot;&quot;
              ]))
</code></pre>
<p>また、<code>many</code>を使うと文字列を小文字と大文字の要素に完全に分割できます。</p>
<pre><code class="language-text">&gt; components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
(Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;)
              [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;CDeFgh\&quot;&quot;
              , &quot;The state is \&quot;DeFgh\&quot;&quot;
              , &quot;The state is \&quot;eFgh\&quot;&quot;
              , &quot;The state is \&quot;Fgh\&quot;&quot;
              , &quot;The state is \&quot;gh\&quot;&quot;
              , &quot;The state is \&quot;h\&quot;&quot;
              ]))
</code></pre>
<p>繰り返しになりますが、これはモナド変換子が齎す再利用性の威力を示しています。
標準的な抽象化を再利用することで、宣言型スタイルのバックトラック構文解析器を、ほんの数行のコードで書くことができました。</p>
<h2 id="演習-38"><a class="header" href="#演習-38">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>string</code>構文解析器の実装から<code>lift</code>関数の呼び出しを取り除いてください。
新しい実装の型検査が通ることを確認し、そうなることを納得するまで確かめましょう。</p>
</li>
<li>
<p>（普通）<code>string</code>構文解析器と<code>some</code>コンビネータを使って構文解析器<code>asFollowedByBs</code>を書いてください。
これは文字列<code>&quot;a&quot;</code>の連続と、それに続く文字列<code>&quot;b&quot;</code>の連続からなる文字列を認識するものです。</p>
</li>
<li>
<p>（普通）<code>&lt;|&gt;</code>演算子を使って構文解析器<code>asOrBs</code>を書いてください。
これは文字<code>a</code>と文字<code>b</code>が任意の順序で現れる文字列を認識します。</p>
</li>
<li>
<p>（難しい）<code>Parser</code>モナドを次のようにも定義できます。</p>
<pre><code class="language-haskell">type Parser = ExceptT Errors (StateT String (WriterT Log Identity))
</code></pre>
<p>このように変更すると、構文解析関数にどのような影響を与えるでしょうか。</p>
</li>
</ol>
<h2 id="rwsモナド"><a class="header" href="#rwsモナド">RWSモナド</a></h2>
<p>モナド変換子のとある特定の組み合わせは頻出なので、<code>transformers</code>パッケージ内の単一のモナド変換子として提供されています。
<code>Reader</code>、<code>Writer</code>、<code>State</code>のモナドは、<em>Reader-Writer-State</em>モナドに組み合わさり、より単純に<code>RWS</code>モナドともされます。
このモナドは<code>RWST</code>モナド変換子という名前の、対応するモナド変換子を持ちます。</p>
<p>ここでは <code>RWS</code>モナドを使ってテキストアドベンチャーゲームの処理を設計していきます。</p>
<p><code>RWS</code>モナドは（戻り値の型に加えて）3つの型変数を使って定義されています。</p>
<pre><code class="language-haskell">type RWS r w s = RWST r w s Identity
</code></pre>
<p>なお、<code>RWS</code>モナドは基底のモナドを<code>Identity</code>に設定することで独自のモナド変換子として定義されています。
<code>Identity</code>は副作用を提供しないのでした。</p>
<p>最初の型引数<code>r</code>は大域的な構成の型を表します。
2つ目の<code>w</code>はログを蓄積するために使用するモノイドを表します。
3つ目の<code>s</code>は可変状態の型です。</p>
<p>このゲームの場合には、大域的な設定は
<code>Data.GameEnvironment</code>モジュールの<code>GameEnvironment</code>という名前の型で定義されています。</p>
<pre><code class="language-haskell">type PlayerName = String

newtype GameEnvironment = GameEnvironment
  { playerName    :: PlayerName
  , debugMode     :: Boolean
  }
</code></pre>
<p>プレイヤー名と、ゲームがデバッグモードで動作しているか否かを示すフラグが定義されています。
モナド変換子を実行するとなると、これらのオプションがコマンドラインから設定されます。</p>
<p>可変状態は <code>Data.GameState</code>モジュールの <code>GameState</code>と呼ばれる型で定義されています。</p>
<pre><code class="language-haskell">import Data.Map as M
import Data.Set as S

newtype GameState = GameState
  { items       :: M.Map Coords (S.Set GameItem)
  , player      :: Coords
  , inventory   :: S.Set GameItem
  }
</code></pre>
<p><code>Coords</code>データ型は2次元平面の点を表し、 <code>GameItem</code>データ型はゲーム内のアイテムの列挙です。</p>
<pre><code class="language-haskell">data GameItem = Candle | Matches
</code></pre>
<p><code>GameState</code>型は2つの新しいデータ構造を使っています。
<code>Map</code>と<code>Set</code>はそれぞれ整列されたマップと整列された集合を表します。
<code>items</code>属性は、ゲーム平面上の座標からその位置にあるゲームアイテムの集合への対応付けです。
<code>player</code>属性はプレイヤーの現在の座標を格納し、<code>inventory</code>属性は現在プレイヤーが保有するゲームアイテムの集合を格納します。</p>
<p><code>Map</code>と<code>Set</code>のデータ構造はキーによって整列され、このキーには<code>Ord</code>型クラスの任意の型を使えます。
つまりデータ構造中のキーは完全に順序付けされます。</p>
<p>ゲームの動作を書く上で<code>Map</code>と<code>Set</code>構造をどのように使っていくのかを見ていきます。</p>
<p>ログとしては <code>List String</code>モノイドを使います。
<code>Game</code>モナド用の型同義語を定義し、<code>RWS</code>を使って実装できます。</p>
<pre><code class="language-haskell">type Log = L.List String

type Game = RWS GameEnvironment Log GameState
</code></pre>
<h2 id="ゲームロジックの実装"><a class="header" href="#ゲームロジックの実装">ゲームロジックの実装</a></h2>
<p><code>Reader</code>、<code>Writer</code>、<code>State</code>モナドの動作を再利用することで、<code>Game</code>モナドで定義されている単純な動作を組み合わせてゲームを構築していきます。
このアプリケーションの最上位では<code>Game</code>モナドで純粋に計算しており、<code>Effect</code>モナドは結果からコンソールにテキストを出力するような観測可能な副作用へと変換するために使っています。</p>
<p>このゲームで最も簡単な動作の1つは <code>has</code>動作です。
この動作はプレイヤーの持ち物に特定のゲームアイテムが含まれているかどうかを調べます。
これは次のように定義されます。</p>
<pre><code class="language-haskell">has :: GameItem -&gt; Game Boolean
has item = do
  GameState state &lt;- get
  pure $ item `S.member` state.inventory
</code></pre>
<p>この関数は、現在のゲームの状態を読み取るために<code>MonadState</code>型クラスで定義されている<code>get</code>動作を使っています。
それから指定した<code>GameItem</code>が持ち物のアイテムの<code>Set</code>に出現するかどうかを調べるために<code>Data.Set</code>で定義されている<code>member</code>関数を使っています。</p>
<p>他にも<code>pickUp</code>動作があります。
現在の位置にゲームアイテムがある場合、プレイヤーの持ち物にそのアイテムを追加します。
これには<code>MonadWriter</code>と<code>MonadState</code>型クラスの動作を使っています。
一番最初に現在のゲームの状態を読み取ります。</p>
<pre><code class="language-haskell">pickUp :: GameItem -&gt; Game Unit
pickUp item = do
  GameState state &lt;- get
</code></pre>
<p>次に <code>pickUp</code>は現在の位置にあるアイテムの集合を検索します。
これは<code>Data.Map</code>で定義された <code>lookup</code>関数を使って行います。</p>
<pre><code class="language-haskell">  case state.player `M.lookup` state.items of
</code></pre>
<p><code>lookup</code>関数は<code>Maybe</code>型構築子で示される省略可能な結果を返します。
<code>lookup</code>関数は、キーがマップにない場合は<code>Nothing</code>を返します。
それ以外の場合は<code>Just</code>構築子で対応する値を返します。</p>
<p>関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含まれている場合です。
ここでも<code>member</code>関数を使うとこれを調べることができます。</p>
<pre><code class="language-haskell">    Just items | item `S.member` items -&gt; do
</code></pre>
<p>この場合、<code>put</code>を使ってゲームの状態を更新し、<code>tell</code>を使ってログに文言を追加できます。</p>
<pre><code class="language-haskell">          let newItems = M.update (Just &lt;&lt;&lt; S.delete item) state.player state.items
              newInventory = S.insert item state.inventory
          put $ GameState state { items     = newItems
                                , inventory = newInventory
                                }
          tell (L.singleton (&quot;You now have the &quot; &lt;&gt; show item))
</code></pre>
<p>ここで2つの計算のどちらも<code>lift</code>が必要ないことに注意してください。
なぜなら<code>MonadState</code>と<code>MonadWriter</code>の両方について<code>Game</code>モナド変換子スタック用の適切なインスタンスが存在するからです。</p>
<p><code>put</code>への引数では、レコード更新を使ってゲームの状態の<code>items</code>及び<code>inventory</code>フィールドを変更しています。
また、特定のキーの値を変更する<code>Data.Map</code>の<code>update</code>関数を使っています。
今回の場合、プレイヤーの現在の位置にあるアイテムの集合を変更するのに、<code>delete</code>関数を使って指定したアイテムを集合から取り除いています。
<code>insert</code>を使って新しいアイテムをプレイヤーの持ち物の集合に加えるときにも、<code>inventory</code>は更新されます。</p>
<p>最後に、<code>pickUp</code>関数は<code>tell</code>を使ってユーザに通知することにより、残りの場合を処理します。</p>
<pre><code class="language-haskell">    _ -&gt; tell (L.singleton &quot;I don't see that item here.&quot;)
</code></pre>
<p><code>Reader</code>モナドを使う例として、 <code>debug</code>コマンドのコードを見てみましょう。
ゲームがデバッグモードで実行されている場合、このコマンドを使うとユーザは実行時にゲームの状態を調べることができます。</p>
<pre><code class="language-haskell">  GameEnvironment env &lt;- ask
  if env.debugMode
    then do
      state :: GameState &lt;- get
      tell (L.singleton (show state))
    else tell (L.singleton &quot;Not running in debug mode.&quot;)
</code></pre>
<p>ここでは、ゲームの構成を読み込むために<code>ask</code>動作を使用しています。
繰り返しますが、どの計算でも<code>lift</code>する必要がなく、同じdo記法ブロック内で<code>MonadState</code>、<code>MonadReader</code>、<code>MonadWriter</code>型クラスで定義されている動作を使える点に注意してください。</p>
<p><code>debugMode</code>フラグが設定されている場合、<code>tell</code>動作を使うとログに状態が書き込まれます。
そうでなければ、エラー文言が追加されます。</p>
<p><code>Game</code>モジュールの残りの部分では同様の動作の集合が定義されています。
各動作は<code>MonadState</code>、<code>MonadReader</code>、<code>MonadWriter</code>型クラスにより定義された動作のみを使っています。</p>
<h2 id="計算の実行"><a class="header" href="#計算の実行">計算の実行</a></h2>
<p>このゲームロジックは<code>RWS</code>モナドで動くため、ユーザのコマンドに応答するために計算する必要があります。</p>
<p>このゲームのフロントエンドは2つのパッケージで構成されています。
アプリカティブなコマンドライン構文解析を提供する<code>optparse</code>と、対話的なコンソールベースのアプリケーションを書くことを可能にする、NodeJSの
<code>readline</code>モジュールを梱包する <code>node-readline</code>パッケージです。</p>
<p>このゲームロジックへのインターフェースは <code>Game</code>モジュール内の関数<code>game</code>によって提供されます。</p>
<pre><code class="language-haskell">game :: Array String -&gt; Game Unit
</code></pre>
<p>これを計算するには、ユーザが入力した単語のリストを文字列の配列として渡してから、<code>runRWS</code>を使って結果の<code>RWS</code>を計算します。</p>
<pre><code class="language-haskell">data RWSResult state result writer = RWSResult state result writer

runRWS :: forall r w s a. RWS r w s a -&gt; r -&gt; s -&gt; RWSResult s a w
</code></pre>
<p><code>runRWS</code>は<code>runReader</code>、<code>runWriter</code>、<code>runState</code>を組み合わせたように見えます。
引数として大域的な構成及び初期状態を取り、ログ、結果、最終的な状態を含むデータ構造を返します。</p>
<p>このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数<code>runGame</code>によって定義されます。</p>
<pre><code class="language-haskell">runGame :: GameEnvironment -&gt; Effect Unit
</code></pre>
<p>この関数は（<code>node-readline</code>と<code>console</code>パッケージを使って）コンソールを介してユーザとやり取りします。
<code>runGame</code>は関数の引数としてのゲームの設定を取ります。</p>
<p><code>node-readline</code>パッケージでは<code>LineHandler</code>型が提供されています。
これは端末からのユーザ入力を扱う<code>Effect</code>モナドの動作を表します。
対応するAPIは次の通りです。</p>
<pre><code class="language-haskell">type LineHandler a = String -&gt; Effect a

foreign import setLineHandler
  :: forall a
   . Interface
  -&gt; LineHandler a
  -&gt; Effect Unit
</code></pre>
<p><code>Interface</code>型はコンソールの制御子を表しており、コンソールとやり取りする関数への引数として渡されます。
<code>createConsoleInterface</code>関数を使用すると<code>Interface</code>を作成できます。</p>
<pre><code class="language-haskell">import Node.ReadLine as RL

runGame env = do
  interface &lt;- RL.createConsoleInterface RL.noCompletion
</code></pre>
<p>最初の工程はコンソールにプロンプトを設定することです。
<code>interface</code>制御対象を渡し、プロンプト文字列と字下げレベルを与えます。</p>
<pre><code class="language-haskell">  RL.setPrompt &quot;&gt; &quot; interface
</code></pre>
<p>今回は行制御関数を実装することに関心があります。
ここでの行制御は<code>let</code>宣言内の補助関数を使って次のように定義されています。</p>
<pre><code class="language-haskell">    lineHandler :: GameState -&gt; String -&gt; Effect Unit
    lineHandler currentState input = do
      case runRWS (game (split (wrap &quot; &quot;) input)) env currentState of
        RWSResult state _ written -&gt; do
          for_ written log
          RL.setLineHandler (lineHandler state) $ interface
      RL.prompt interface
      pure unit
</code></pre>
<p><code>let</code>束縛が<code>env</code>という名前のゲーム構成や<code>interface</code>という名前のコンソール制御対象を包み込んでいます。</p>
<p>この制御子は追加の最初の引数としてゲームの状態を取ります。
ゲームのロジックを実行するために<code>runRWS</code>にゲームの状態を渡さなければならないので、これは必要となっています。</p>
<p>この動作が最初に行うことは、<code>Data.String</code>モジュールの <code>split</code>関数を使用して、ユーザーの入力を単語に分割することです。
それから、ゲームの環境と現在のゲームの状態を渡し、 <code>runRWS</code>を使用して（<code>RWS</code>モナドで）<code>game</code>動作を実行しています。</p>
<p>純粋な計算であるゲームロジックを実行するには、画面に全てのログ文言を出力して、ユーザに次のコマンドのためのプロンプトを表示する必要があります。
<code>for_</code>動作が（<code>List String</code>型の）ログを走査し、コンソールにその内容を出力するために使われています。
最後に<code>setLineHandler</code>を使って行制御関数を更新することでゲームの状態を更新し、<code>prompt</code>動作を使ってプロンプトを再び表示しています。</p>
<p><code>runGame</code>関数は最終的にコンソールインターフェイスに最初の行制御子を取り付けて、初期プロンプトを表示します。</p>
<pre><code class="language-haskell">  RL.setLineHandler (lineHandler initialGameState) interface
  RL.prompt interface
</code></pre>
<h2 id="演習-39"><a class="header" href="#演習-39">演習</a></h2>
<ol>
<li>
<p>（普通）ゲームの格子上にある全てのゲームアイテムをユーザの持ちものに移動する新しいコマンド <code>cheat</code>を実装してください。
関数<code>cheat :: Game Unit</code>を<code>Game</code>モジュールに作り、この関数を<code>game</code>から使ってください。</p>
</li>
<li>
<p>（難しい）<code>RWS</code>モナドの <code> Writer</code>コンポーネントは、エラー文言とお知らせ文言の2つの種類の文言のために使われています。
このため、コードの幾つかの箇所では、エラーの場合を扱うためにcase式を使用しています。</p>
<p>コードをリファクタリングしてください。
エラー文言を扱うのに<code>ExceptT</code>モナド変換子を使い、お知らせ文言を扱うのに<code>RWS</code>を使います。
<em>補足</em>：この演習にはテストがありません。</p>
</li>
</ol>
<h2 id="コマンドラインオプションの扱い"><a class="header" href="#コマンドラインオプションの扱い">コマンドラインオプションの扱い</a></h2>
<p>このアプリケーションの最後の部品には、コマンドラインオプションの解析と<code>GameEnvironment</code>設定レコードを作成する役目があります。
このためには<code>optparse</code>パッケージを使用します。</p>
<p><code>optparse</code>は<em>アプリカティブなコマンドラインオプション構文解析器</em>の一例です。
アプリカティブ関手を使うと、いろいろな副作用の型を表す型構築子まで任意個数の引数の関数を持ち上げられることを思い出してください。
<code>optparse</code>パッケージの場合には、コマンドラインオプションからの読み取りの副作用を追加する<code>Parser</code>関手（optparseのモジュール<code>Options.Applicative</code>からインポートされたもの。<code>Split</code>モジュールで定義した<code>Parser</code>と混同しないように）が興味深い関手になっています。
これは次のような制御子を提供しています。</p>
<pre><code class="language-haskell">customExecParser :: forall a. ParserPrefs -&gt; ParserInfo a -&gt; Effect a
</code></pre>
<p>実例を見るのが一番です。
このアプリケーションの <code>main</code>関数は<code>customExecParser</code>を使って次のように定義されています。</p>
<pre><code class="language-haskell">main = OP.customExecParser prefs argParser &gt;&gt;= runGame 
</code></pre>
<p>最初の引数は<code>optparse</code>ライブラリを設定するために使用されます。
今回の場合、アプリケーションが引数なしで走らされたときは、（「missing argument」エラーを表示する代わりに）<code>OP.prefs OP.showHelpOnEmpty</code>を使って使用方法の文言を表示するように設定していますが、<code>Options.Applicative.Builder</code>モジュールには他にも幾つかの選択肢を提供しています。</p>
<p>2つ目の引数は解析プログラムの完全な説明です。</p>
<pre><code class="language-haskell">  argParser :: OP.ParserInfo GameEnvironment
  argParser = OP.info (env &lt;**&gt; OP.helper) parserOptions

  parserOptions = fold 
    [ OP.fullDesc
    , OP.progDesc &quot;Play the game as &lt;player name&gt;&quot;
    , OP.header &quot;Monadic Adventures! A game to learn monad transformers&quot; 
    ]
</code></pre>
<p>ここで<code>OP.info</code>は、<code>Parser</code>をヘルプ文言の書式方法のためのオプションの集合と組み合わせます。
<code>env &lt;**&gt; OP.helper</code>は<code>env</code>と名付けられた任意のコマンドライン引数<code>Parser</code>を取り、自動的に<code>--help</code>オプションを加えます。
ヘルプ文言用のオプションは型が<code>InfoMod</code>であり、これはモノイドなので、<code>fold</code>関数を使って複数のオプションを一緒に追加できます。</p>
<p>解析器の面白い部分は<code>GameEnvironment</code>の構築にあります。</p>
<pre><code class="language-haskell">  env :: OP.Parser GameEnvironment
  env = gameEnvironment &lt;$&gt; player &lt;*&gt; debug

  player :: OP.Parser String
  player = OP.strOption $ fold 
    [ OP.long &quot;player&quot;
    , OP.short 'p'
    , OP.metavar &quot;&lt;player name&gt;&quot;
    , OP.help &quot;The player's name &lt;String&gt;&quot;
    ]

  debug :: OP.Parser Boolean
  debug = OP.switch $ fold 
    [ OP.long &quot;debug&quot;
    , OP.short 'd'
    , OP.help &quot;Use debug mode&quot;
    ]
</code></pre>
<p><code>player</code>と<code>debug</code>は両方とも<code>Parser</code>なので、アプリカティブ演算子<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使って<code>gameEnvironment</code>関数を持ち上げられます。
この関数は<code>Parser</code>上で型<code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code>を持ちます。
<code>OP.strOption</code>は文字列値を期待するコマンドラインオプションを構築し、一緒に畳み込まれた<code>Mod</code>の集まりを介して構成されています。
<code>OP.flag</code>は似たような動作をしますが、関連付けられた値は期待しません。
<code>optparse</code>は多様なコマンドライン解析器を構築するために使える様々な修飾子について、大部の<a href="https://pursuit.purescript.org/packages/purescript-optparse">ドキュメント</a>を提供しています。</p>
<p>アプリカティブ演算子による記法を使うことで、コマンドラインインターフェイスの簡潔で宣言的な仕様を与えられた点に注目です。
加えて、新しいコマンドライン引数を追加するのは単純で、<code>runGame</code>に新しい関数引数を追加し、<code>env</code>の定義中で<code>&lt;*&gt;</code>を使って追加の引数まで<code>runGame</code>を持ち上げるだけでできます。</p>
<h2 id="演習-40"><a class="header" href="#演習-40">演習</a></h2>
<ol>
<li>（普通）<code>GameEnvironment</code>レコードに新しい真偽値のプロパティ<code>cheatMode</code>を追加してください。
また、<code>optparse</code>の構成に、チートモードを有効にする新しいコマンドラインフラグ<code>-c</code>を追加してください。
チートモードが有効になっていない場合、前の演習の<code>cheat</code>コマンドは禁止されます。</li>
</ol>
<h2 id="まとめ-9"><a class="header" href="#まとめ-9">まとめ</a></h2>
<p>この章ではこれまで学んできた技術を実践的に実演しました。
モナド変換子を使用したゲームの純粋な仕様の構築、コンソールを使用したフロントエンドを構築するための<code>Effect</code>モナドがそれです。</p>
<p>ユーザインターフェイスからの実装を分離したので、ゲームの別のフロントエンドも作成できるでしょう。
例えば、<code>Effect</code>モナドでCanvas APIやDOMを使用して、ブラウザでゲームを描画するようなことができるでしょう。</p>
<p>モナド変換子によって命令型のスタイルで安全なコードを書けることが分かりました。
このスタイルでは型システムによって作用が追跡されています。
加えて、型クラスはモナドが提供する動作へと抽象化する強力な方法を提供し、これによりコードの再利用が可能になりました。
標準的なモナド変換子を組み合わせることにより、<code>Alternative</code>や<code>MonadPlus</code>のような標準的な抽象化を使用して、役に立つモナドを構築できました。</p>
<p>モナド変換子は表現力の高いコードの優れた実演となっています。
これは高階多相や多変数型クラスなどの高度な型システムの機能を利用することによって記述できるものです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvasグラフィックス"><a class="header" href="#canvasグラフィックス">Canvasグラフィックス</a></h1>
<h2 id="この章の目標-10"><a class="header" href="#この章の目標-10">この章の目標</a></h2>
<p>この章は<code>canvas</code>パッケージに焦点を当てる発展的な例となります。
このパッケージはPureScriptでHTML5のCanvas APIを使用して2Dグラフィックスを生成する手段を提供します。</p>
<h2 id="プロジェクトの準備-9"><a class="header" href="#プロジェクトの準備-9">プロジェクトの準備</a></h2>
<p>このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。</p>
<ul>
<li><code>canvas</code>はHTML5のCanvas APIメソッドの型を与えます。</li>
<li><code>refs</code>は <em>大域的な変更可能領域への参照</em> を使うための副作用を提供します。</li>
</ul>
<p>この章の各ソースコードは、<code>main</code>メソッドが定義されているモジュールの集合へと分割されています。
この章の各節の内容は個別のファイルで実装されており、各時点での適切なファイルの<code>main</code>メソッドを実行できるように、Spagoビルドコマンドを変更することで、<code>Main</code>モジュールを合わせられるようになっています。</p>
<p>HTMLファイル<code>html/index.html</code>には、各例で使用される単一の<code>canvas</code>要素、及びコンパイルされたPureScriptコードを読み込む<code>script</code>要素が含まれています。
各節のコードを試すにはブラウザでHTMLファイルを開きます。
ほとんどの演習はブラウザを対象にしているので、この章には単体試験はありません。</p>
<h2 id="単純な図形"><a class="header" href="#単純な図形">単純な図形</a></h2>
<p><code>Example/Rectangle.purs</code>ファイルには簡単な導入例が含まれています。
この例ではキャンバスの中心に青い四角形を1つ描画します。
このモジュールへは、<code>Effect</code>モジュールからの<code>Effect</code>型と、Canvas
APIを扱うための<code>Effect</code>モナドの動作を含む<code>Graphics.Canvas</code>モジュールをインポートします。</p>
<p>他のモジュールでも同様ですが、<code>main</code>動作は最初に<code>getCanvasElementById</code>動作を使ってキャンバスオブジェクトへの参照を取得し、<code>getContext2D</code>動作を使ってキャンバスの2D描画文脈にアクセスします。</p>
<p><code>void</code>関数は関手を取り値を<code>Unit</code>で置き換えます。
例では<code>main</code>がシグネチャに沿うようにするために使われています。</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><em>補足</em>：この<code>unsafePartial</code>の呼び出しは必須です。
これは<code>getCanvasElementById</code>の結果のパターン照合部分で、<code>Just</code>値構築子のみと照合するためです。
ここではこれで問題ありませんが、恐らく実際の製品のコードでは<code>Nothing</code>値構築子と照合させ、適切なエラー文言を提供したほうがよいでしょう。</p>
<p>これらの動作の型はPSCiを使うかドキュメントを見ると確認できます。</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code>と <code>Context2D</code>は <code>Graphics.Canvas</code>モジュールで定義されている型です。
このモジュールでは<code>Canvas</code>作用も定義されており、モジュール内の全てのアクションで使用されています。</p>
<p>グラフィックス文脈<code>ctx</code>はキャンバスの状態を管理し、原始的な図形を描画したり、スタイルや色を設定したり、座標変換を適用したりするための手段を提供します。</p>
<p>話を進めると、<code>setFillStyle</code>動作を使うことで塗り潰しスタイルを濃い青に設定できます。
より長い16進数記法の<code>#0000FF</code>も青には使えますが、単純な色については略記法がより簡単です。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p><code>setFillStyle</code>動作がグラフィックス文脈を引数として取っていることに注意してください。
これは<code>Graphics.Canvas</code>ではよくあるパターンです。</p>
<p>最後に、<code>fillPath</code>動作を使用して矩形を塗り潰しています。
<code>fillPath</code>は次のような型を持っています。</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code>はグラフィックスの文脈と描画するパスを構築する他の動作を引数に取ります。
<code>rect</code>動作を使うとパスを構築できます。
<code>rect</code>はグラフィックスの文脈と矩形の位置及びサイズを格納するレコードを取ります。</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>mainモジュールの名前として<code>Example.Rectangle</code>を与えてこの長方形のコード例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>それでは <code>html/index.html</code>ファイルを開き、このコードによってキャンバスの中央に青い四角形が描画されていることを確認してみましょう。</p>
<h2 id="行多相を利用する"><a class="header" href="#行多相を利用する">行多相を利用する</a></h2>
<p>パスを描画する方法は他にもあります。
<code>arc</code>関数は円弧を描画します。
<code>moveTo</code>関数、<code>lineTo</code>関数、<code>closePath</code>関数は断片的な線分のパスを描画できます。</p>
<p><code>Shapes.purs</code>ファイルでは長方形と円弧と三角形の、3つの図形を描画しています。</p>
<p><code>rect</code>関数は引数としてレコードをとることを見てきました。
実際には、長方形のプロパティは型同義語で定義されています。</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p><code>x</code>と<code>y</code>プロパティは左上隅の位置を表しており、<code>width</code>と<code>height</code>のプロパティはそれぞれ幅と高さを表しています。</p>
<p><code>arc</code>関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画できます。</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>ここで、<code>x</code>と<code>y</code>プロパティは弧の中心、<code>radius</code>は半径、<code>start</code>と<code>end</code>は弧の両端の角度を弧度法で表しています。</p>
<p>例えばこのコードは中心が<code>(300, 300)</code>に中心があり半径<code>50</code>の円弧を塗り潰します。
弧は1回転のうち2/3ラジアン分あります。
単位円が上下逆様になっている点に注意してください。
これはy軸がキャンバスの下向きに伸びるためです。</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p><code>Rectangle</code>レコード型と<code>Arc</code>レコード型の両方共、<code>Number</code>型の<code>x</code>と<code>y</code>というプロパティを含んでいますね。
どちらの場合でもこの組は点を表しています。
つまり、何れのレコード型にも作用する行多相な関数を書けます。</p>
<p>例えば<code>Shapes</code>モジュールでは<code>x</code>と<code>y</code>のプロパティを変更し図形を並行移動する<code>translate</code>関数が定義されています。</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>この行多相型に注目してください。
<code>translate</code>が <code>x</code>と
<code>y</code>というプロパティと、<em>それに加えて他の任意のプロパティ</em>を持つどんなレコードでも受け入れ、同じ型のレコードを返すと書かれています。
<code>x</code>フィールドと <code>y</code>フィールドは更新されますが、残りのフィールドは変更されません。</p>
<p>これは<em>レコード更新構文</em>の例です。
<code>shape { ... }</code>という式は、<code>shape</code>を元にして、括弧の中で指定された値で更新されたフィールドを持つ新たなレコードを作ります。
なお、波括弧の中の式はレコード直値のようなコロンではなく、等号でラベルと式を区切って書きます。</p>
<p><code>Shapes</code>の例からわかるように、<code>translate</code>関数は<code>Rectangle</code>レコードと<code>Arc</code>レコード双方に対して使えます。</p>
<p><code>Shape</code>の例で描画される3つ目の型は線分の断片からなるパスです。
対応するコードは次のようになります。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>ここでは3つの関数が使われています。</p>
<ul>
<li><code>moveTo</code>はパスの現在地を指定された座標に移動します。</li>
<li><code>lineTo</code>は現在地と指定された座標の間の線分を描画し、現在地を更新します。</li>
<li><code>closePath</code>は現在地と開始地点とを結ぶ線分を描画してパスを完結します。</li>
</ul>
<p>このコード片の結果は二等辺三角形の塗り潰しになります。</p>
<p>mainモジュールとして<code>Example.Shapes</code>を指定して、この例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>そしてもう一度<code>html/index.html</code>を開き、結果を確認してください。
キャンバスに3つの異なる図形が描画されるはずです。</p>
<h2 id="演習-41"><a class="header" href="#演習-41">演習</a></h2>
<ol>
<li>
<p>（簡単）これまでの各例について、<code>strokePath</code>関数や<code>setStrokeStyle</code>関数を使ってみましょう。</p>
</li>
<li>
<p>（簡単）関数の引数の内部でdo記法ブロックを使うと、<code>fillPath</code>関数と<code>strokePath</code>関数は共通のスタイルを持つ複雑なパスを描画できます。
同じ<code>fillPath</code>呼び出しを使って隣り合う2つの矩形を描画するように、<code>Rectangle</code>の例を変更してみてください。
線分と円弧の組み合わせを使って、扇形を描画してみてください。</p>
</li>
<li>
<p>（普通）次のような2次元の点を表すレコードが与えられたとします。</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>これは2次元の点を表現しています。
多数の点からなる閉じたパスを線描きする関数 <code>renderPath</code>を書いてください。</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>次のような関数を考えます。</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>この関数は引数として<code>1</code>から<code>0</code>の間の<code>Number</code>を取り、<code>Point</code>を返します。
<code>renderPath</code>関数を使い、関数<code>f</code>のグラフを描く動作を書いてください。
その動作では有限個の点で<code>f</code>を標本化することによって近似しなければなりません。</p>
<p>関数 <code>f</code>を変更し、様々なパスが描画されることを確かめてください。</p>
</li>
</ol>
<h2 id="無作為に円を描く"><a class="header" href="#無作為に円を描く">無作為に円を描く</a></h2>
<p><code>Example/Random.purs</code>ファイルには、<code>Effect</code>モナドを使って2種類の副作用を綴じ合わせる例が含まれています。
1つの副作用は乱数生成で、もう1つはキャンバスの操作です。
この例では無作為に生成された円をキャンバスに100個描画します。</p>
<p><code>main</code>動作ではこれまでのようにグラフィックス文脈への参照を取得し、線描きと塗り潰しのスタイルを設定します。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>次のコードでは<code>for_</code>動作を使って<code>0</code>から<code>100</code>までの整数について反復しています。</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>各繰り返しで、do記法ブロックは<code>0</code>と<code>1</code>の間に分布する3つの乱数を生成することから始まります。
これらの数はそれぞれ<code>x</code>座標、<code>y</code>座標、半径<code>r</code>を表しています。</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>次のコードでは各円について、これらの変数に基づいて<code>Arc</code>を作成し、最後に現在のスタイルに従って円弧を塗り潰し、線描きします。</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x                  : x * 600.0
         , y                  : y * 600.0
         , radius             : r * 50.0
         , start              : 0.0
         , end                : Number.tau
         , useCounterClockwise: false
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>mainモジュールとして<code>Example.Random</code>を指定して、この例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いて、結果を確認してみましょう。</p>
<h2 id="座標変換"><a class="header" href="#座標変換">座標変換</a></h2>
<p>キャンバスは簡単な図形を描画するだけのものではありません。
キャンバスは座標変換を管理しており、描画の前に図形を変形するのに使えます。
図形は平行移動、回転、拡大縮小、及び斜めに変形できます。</p>
<p><code>canvas</code>ライブラリではこれらの変換を以下の関数で提供しています。</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p><code>translate</code>動作は<code>TranslateTransform</code>レコードのプロパティで指定した大きさだけ平行移動します。</p>
<p><code>rotate</code>動作は最初の引数で指定されたラジアンの数値に応じて、原点を中心として回転します。</p>
<p><code>scale</code>動作は原点を中心として拡大縮小します。
<code>ScaleTransform</code>レコードは<code>x</code>軸と<code>y</code>軸に沿った拡大率を指定するのに使います。</p>
<p>最後の <code>transform</code>はこの4つのうちで最も一般化された動作です。
この動作では行列に従ってアフィン変換します。</p>
<p>これらの動作が呼び出された後に描画される図形は、自動的に適切な座標変換が適用されます。</p>
<p>実際には、これらの関数の各作用は、文脈の現在の変換行列に対して変換行列を<em>右から乗算</em>していきます。
つまり、もしある作用の変換をしていくと、その作用は実際には逆順に適用されていきます。</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>この一連の動作の作用では、まずシーンが回転され、それから拡大縮小され、最後に平行移動されます。</p>
<h2 id="文脈の保存"><a class="header" href="#文脈の保存">文脈の保存</a></h2>
<p>座標変換を使ってシーンの一部を描画し、それからその変換を元に戻す、という使い方はよくあります。</p>
<p>Canvas APIにはキャンバスの状態の<em>スタック</em>を操作する<code>save</code>と<code>restore</code>メソッドが備わっています。
<code>canvas</code>ではこの機能を次のような関数で梱包しています。</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p><code>save</code>動作は現在の文脈の状態（現在の変換行列や描画スタイル）をスタックにプッシュし、<code>restore</code>動作はスタックの一番上の状態をポップし、文脈の状態を復元します。</p>
<p>これらの動作により、現在の状態を保存し、いろいろなスタイルや変換を適用してから原始的な図形を描画し、最後に元の変換と状態を復元できます。
例えば次の関数は幾つかのキャンバス動作を実行しますが、その前に回転を適用し、その後に変換を復元します。</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>こういったよくある高階関数の使われ方の抽象化として、<code>canvas</code>ライブラリでは元の文脈状態を保存しつつ幾つかのキャンバス動作を実行する<code>withContext</code>関数が提供されています。</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p><code>withContext</code>を使うと、先ほどの <code>rotated</code>関数を次のように書き換えることができます。</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="大域的な変更可能状態"><a class="header" href="#大域的な変更可能状態">大域的な変更可能状態</a></h2>
<p>この節では <code>refs</code>パッケージを使って <code>Effect</code>モナドの別の作用について実演してみます。</p>
<p><code>Effect.Ref</code>モジュールでは、大域的に変更可能な参照のための型構築子、及びそれに紐付く作用を提供します。</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>型<code>Ref a</code>の値は型<code>a</code>の値を含む可変参照セルであり、大域的な変更を追跡するのに使われます。
そういったわけでこれは少しだけ使う分に留めておくべきです。</p>
<p><code>Example/Refs.purs</code>ファイルには <code>canvas</code>要素上のマウスクリックを追跡するのに <code>Ref</code>を使う例が含まれます。</p>
<p>このコードでは最初に<code>new</code>動作を使って値<code>0</code>を含む新しい参照を作成しています。</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>クリックイベント制御子の内部では、<code>modify</code>動作を使用してクリック数を更新し、更新された値が返されています。</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p><code>render</code>関数ではクリック数に応じた変換を矩形に適用しています。</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Number.sin (toNumber count * Number.tau / 8.0) + 1.5
    let scaleY = Number.sin (toNumber count * Number.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Number.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>この動作では元の変換を保存するために<code>withContext</code>を使用しており、それから一連の変換を適用しています（変換が下から上に適用されることを思い出してください）。</p>
<ul>
<li>矩形が<code>(-100, -100)</code>だけ平行移動し、中心が原点に来ます。</li>
<li>矩形が原点を中心に拡大されます。</li>
<li>矩形が原点を中心に<code>10</code>の倍数分の角度で回転します。</li>
<li>矩形が<code>(300, 300)</code>だけ平行移動し、中心がキャンバスの中心に来ます。</li>
</ul>
<p>このコード例をビルドしてみましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>ファイルを開いてみましょう。
緑の四角形が表示され、何度かキャンバスをクリックするとキャンバスの中心の周りで回転するはずです。</p>
<h2 id="演習-42"><a class="header" href="#演習-42">演習</a></h2>
<ol>
<li>（簡単）パスの線描と塗り潰しを同時に行う高階関数を書いてください。
その関数を使用して<code>Random.purs</code>の例を書き直してください。</li>
<li>（普通）<code>Random</code>作用と<code>Dom</code>作用を使用して、マウスがクリックされたときに、キャンバスに無作為な位置、色、半径の円を描画するアプリケーションを作成してください。</li>
<li>（普通）指定された座標の点を中心として回転させることでシーンを変換する関数を書いてください。
<em>手掛かり</em>：変換を使い、最初にシーンを原点まで平行移動しましょう。</li>
</ol>
<h2 id="l-system"><a class="header" href="#l-system">L-System</a></h2>
<p>この章の最後の例として、 <code>canvas</code>パッケージを使用して<em>L-system</em>（またの名を<em>Lindenmayer
system</em>）を描画する関数を記述します。</p>
<p>1つのL-Systemは<em>アルファベット</em>、つまりアルファベット由来の文字の初期の並びと、<em>生成規則</em>の集合で定義されます。
各生成規則は、アルファベットの文字を取り、それを置き換える文字の並びを返します。
この処理は文字の初期の並びから始まり、複数回繰り返されます。</p>
<p>もしアルファベットの各文字がキャンバス上で実行される命令と対応付けられていれば、その指示に順番に従うことでL-Systemを描画できます。</p>
<p>例えばアルファベットが文字<code>L</code>（左回転）、<code>R</code>（右回転）、<code>F</code>（前進）で構成されているとします。
次のような生成規則を定義できます。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>配列 &quot;FRRFRRFRR&quot; から始めて処理を繰り返すと、次のような経過を辿ります。</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>というように続きます。
この命令群に対応する線分パスをプロットすると、<em>コッホ曲線</em>に近似されます。
反復回数を増やすと、曲線の解像度が増していきます。</p>
<p>それでは型と関数のある言語へとこれを翻訳してみましょう。</p>
<p>アルファベットの文字は以下のADTで表現できます。</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>このデータ型では、アルファベットの文字ごとに1つずつデータ構築子が定義されています。</p>
<p>文字の初期配列はどのように表したらいいでしょうか。
単なるアルファベットの配列でいいでしょう。
これを <code>Sentence</code>と呼ぶことにします。</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>生成規則は以下のように<code>Letter</code>から <code>Sentence</code>への関数として表すことができます。</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>これはまさに上記の仕様をそのまま書き写したものです。</p>
<p>これで、この形式の仕様を受け取ってキャンバスに描画する関数<code>lsystem</code>を実装できます。
<code>lsystem</code>はどのような型を持っているべきでしょうか。
<code>initial</code>や<code>productions</code>のような値だけでなく、アルファベットの文字をキャンバスに描画できる関数を引数に取る必要があります。</p>
<p><code>lsystem</code>の型の最初の大まかな設計は以下です。</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>最初の2つの引数の型は、値 <code>initial</code>と <code>productions</code>に対応しています。</p>
<p>3番目の引数は、アルファベットの文字を取り、キャンバス上の幾つかの動作を実行することによって<em>解釈</em>する関数を表します。
この例では、文字<code>L</code>は左回転、文字<code>R</code>で右回転、文字<code>F</code>は前進を意味します。</p>
<p>最後の引数は、実行したい生成規則の繰り返し回数を表す数です。</p>
<p>最初に気付くことは、この<code>lsystem</code>関数は1つの型<code>Letter</code>に対してのみ動作するのですが、どんなアルファベットについても機能すべきですから、この型はもっと一般化されるべきです。
それでは、量子化された型変数 <code>a</code>について、<code>Letter</code>と <code>Sentence</code>を <code>a</code>と <code>Array a</code>で置き換えましょう。</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>次に気付くこととしては、「左回転」と「右回転」のような命令を実装するためには、幾つかの状態を管理する必要があります。
具体的に言えば、その時点でパスが動いている方向を状態として持たなければなりません。
計算を通じて状態を渡すように関数を変更する必要があります。
ここでも<code>lsystem</code>関数は状態がどんな型でも動作したほうがよいので、型変数<code>s</code>を使用してそれを表しています。</p>
<p>型 <code>s</code>を追加する必要があるのは3箇所で、次のようになります。</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>まず追加の引数の型として <code>lsystem</code>に型 <code>s</code>が追加されています。
この引数はL-Systemの初期状態を表しています。</p>
<p>型
<code>s</code>は引数にも現れますが、解釈関数（<code>lsystem</code>の第3引数）の返り値の型としても現れます。解釈関数は今のところ、引数としてL-Systemの現在の状態を受け取り、返り値として更新された新しい状態を返します。</p>
<p>この例の場合では、次のような型を使って状態を表す型を定義できます。</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>プロパティ <code>x</code>と <code>y</code>はパスの現在の位置を表しています。
プロパティ<code>theta</code>はパスの現在の向きを表しており、ラジアンで表された水平線に対するパスの角度として指定されています。</p>
<p>システムの初期状態は次のように指定されます。</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>それでは、 <code>lsystem</code>関数を実装してみます。定義はとても単純であることがわかるでしょう。</p>
<p><code>lsystem</code>は第4引数の値（型は<code>Int</code>）に応じて再帰するのが良さそうです。
再帰の各ステップでは、生成規則に従って状態が更新され、現在の文が変化していきます。
このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を移譲することから始めましょう。</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p><code>go</code>関数は第2引数について再帰することで動作します。
場合分けは2つであり、<code>n</code>がゼロであるときと<code>n</code>がゼロでないときです。</p>
<p>1つ目の場合は再帰は完了し、解釈関数に応じて現在の文を解釈します。
型<code>Array a</code>の文、型<code>s</code>の状態、型<code>s -&gt; a -&gt; Effect s</code>の関数があります。
以前定義した<code>foldM</code>の出番のようです。
この関数は<code>control</code>パッケージで手に入ります。</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>ゼロでない場合ではどうでしょうか。
その場合は、単に生成規則を現在の文のそれぞれの文字に適用して、その結果を連結し、そして再帰的に<code>go</code>を呼び出すことによって繰り返します。</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>これだけです。
<code>foldM</code>や<code>concatMap</code>のような高階関数を使うと、アイデアを簡潔に表現できるのです。</p>
<p>しかし、話はこれで終わりではありません。
ここで与えた型は、実際はまだ特殊化されすぎています。
この定義ではキャンバスの操作が実装のどこにも使われていないことに注目してください。
それに、全く<code>Effecta</code>モナドの構造を利用していません。
実際には、この関数は<em>どんな</em>モナド<code>m</code>についても動作します。</p>
<p>この章に添付されたソースコードで指定されている<code>lsystem</code>の型はもっと一般的になっています。</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>この型で書かれていることは、この解釈関数はモナド<code>m</code>が持つ任意の副作用を完全に自由に持つことができる、ということだと理解できます。
キャンバスに描画したり、またはコンソールに情報を出力したりするかもしれませんし、失敗や複数の戻り値に対応しているかもしれません。
こういった様々な型の副作用を使ったL-Systemを記述してみることを読者にお勧めします。</p>
<p>この関数は実装からデータを分離することの威力を示す良い例となっています。
この手法の利点は、複数の異なる方法でデータを解釈できることです。
さらに<code>lsystem</code>を2つの小さな関数へと分解できます。
1つ目は<code>concatMap</code>の適用の繰り返しを使って文を構築するもの、2つ目は<code>foldM</code>を使って文を解釈するものです。
これは読者の演習として残しておきます。</p>
<p>それでは解釈関数を実装して、この章の例を完成させましょう。
<code>lsystem</code>の型が教えてくれているのは、型シグネチャが、何らかの型 <code>a</code>と <code>s</code>、型構築子 <code>m</code>について、 <code>s -&gt; a -&gt; m s</code>でなければならないということです。
<code>a</code>を <code>Letter</code>、 <code>s</code>を <code>State</code>、モナド <code>m</code>を <code>Effect</code>というように選びたいということがわかっています。
これにより次のような型になります。</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>この関数を実装するには、 <code>Letter</code>型の3つのデータ構築子それぞれについて処理する必要があります。文字 <code>L</code>（左回転）と
<code>R</code>（右回転）の解釈では、<code>theta</code>を適切な角度へ変更するように状態を更新するだけです。</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Number.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Number.tau / 6.0 }
</code></pre>
<p>文字<code>F</code>（前進）を解釈するには、次のようにパスの新しい位置を計算し、線分を描画し、状態を更新します。</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Number.cos state.theta * 1.5
          y = state.y + Number.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>なお、この章のソースコードでは、名前 <code>ctx</code>がスコープに入るように、<code>interpret</code>関数は <code>main</code>関数内で
<code>let</code>束縛を使用して定義されています。
<code>State</code>型が文脈を持つように変更できるでしょうが、それはこのシステムの状態の変化する部分ではないので不適切でしょう。</p>
<p>このL-Systemを描画するには、次のような<code>strokePath</code>動作を使用するだけです。</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>次のコマンドを使ってL-Systemをコンパイルします。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いてみましょう。
キャンバスにコッホ曲線が描画されるのがわかると思います。</p>
<h2 id="演習-43"><a class="header" href="#演習-43">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>strokePath</code>の代わりに <code>fillPath</code>を使用するように、上のL-Systemの例を変更してください。
<em>手掛かり</em>：<code>closePath</code>の呼び出しを含め、 <code>moveTo</code>の呼び出しを <code>interpret</code>関数の外側に移動する必要があります。</p>
</li>
<li>
<p>（簡単）描画システムへの影響を理解するために、コード中の様々な数値の定数を変更してみてください。</p>
</li>
<li>
<p>（普通）<code>lsystem</code>関数を2つの小さな関数に分割してください。
1つ目は<code>concatMap</code>の適用の繰り返しを使用して最終的な文を構築するもので、2つ目は
<code>foldM</code>を使用して結果を解釈するものでなくてはなりません。</p>
</li>
<li>
<p>（普通）<code>setShadowOffsetX</code>、<code>setShadowOffsetY</code>、<code>setShadowBlur</code>、<code>setShadowColor</code>動作を使い、塗りつぶされた図形にドロップシャドウを追加してください。
<em>手掛かり</em>：PSCiを使って、これらの関数の型を調べてみましょう。</p>
</li>
<li>
<p>（普通）向きを変えるときの角度の大きさは今のところ一定 \( tau / 6 \) です。
これに代えて、<code>Letter</code>データ型の中に角度を移動させ、生成規則によって変更できるようにしてください。</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>この新しい情報を生成規則でどう使うと、面白い図形を作ることができるでしょうか。</p>
</li>
<li>
<p>（難しい）4つの文字からなるアルファベットでL-Systemが与えられたとします。
それぞれ<code>L</code>（60度左回転）、<code>R</code>（60度右回転）、<code>F</code>（前進）、<code>M</code>（これも前進）です。</p>
<p>このシステムの文の初期状態は、単一の文字 <code>M</code>です。</p>
<p>このシステムの生成規則は次のように指定されています。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>このL-Systemを描画してください。
<em>補足</em>：最後の文のサイズは反復回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を削減する必要があります。</p>
<p>ここで、生成規則における <code>L</code>と <code>M</code>の間の対称性に注目してください。2つの「前進」命令は、次のようなアルファベット型を使用すると、<code>Boolean</code>値を使って区別できます。</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>このアルファベットの表現を使用して、もう一度このL-Systemを実装してください。</p>
</li>
<li>
<p>（難しい）解釈関数で別のモナド <code>m</code>を使ってみましょう。<code>Effect.Console</code>作用を利用してコンソール上にL-Systemを出力したり、<code>Random</code>作用を利用して状態の型に無作為の「突然変異」を適用したりしてみてください。</p>
</li>
</ol>
<h2 id="まとめ-10"><a class="header" href="#まとめ-10">まとめ</a></h2>
<p>この章では、<code>canvas</code>ライブラリを使用することにより、PureScriptからHTML5 Canvas APIを使う方法について学びました。
また、これまで学んできた多くの手法からなる実用的な実演を見ました。
マップや畳み込み、レコードと行多相、副作用を扱うための<code>Effect</code>モナドです。</p>
<p>この章の例では、高階関数の威力を示すとともに、 <em>実装からのデータの分離</em>
も実演してみせました。これは例えば、代数データ型を使用してこれらの概念を次のように拡張し、描画関数からシーンの表現を完全に分離できるようになります。</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>この手法は<code>drawing</code>パッケージで採られており、描画前に様々な方法でシーンをデータとして操作できる柔軟性を齎しています。</p>
<p>キャンバスに描画されるゲームの例については<a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>の「Behavior」と「Signal」のレシピを見てください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="テストの自動生成"><a class="header" href="#テストの自動生成">テストの自動生成</a></h1>
<h2 id="この章の目標-11"><a class="header" href="#この章の目標-11">この章の目標</a></h2>
<p>この章では、テスティングの問題に対する、型クラスの特に洗練された応用について示します。
<em>どのように</em>テストするのかをコンパイラに教えるのではなく、コードが<em>どのような</em>性質を持っているべきかを教えることでテストします。
型クラスを使って無作為データ生成のための紋切り型なコードを書かずして、テスト項目を仕様から無作為に生成できます。
これは<em>生成的テスティング</em>（generative testing、または<em>property-based
testing</em>）と呼ばれ、Haskellの<a href="http://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a>ライブラリによって普及した手法です。</p>
<p><code>quickcheck</code>パッケージはHaskellのQuickCheckライブラリをPureScriptにポーティングしたもので、型や構文はもとのライブラリとほとんど同じようになっています。
<code>quickcheck</code>を使って簡単なライブラリをテストし、Spagoでテストスイートを自動化されたビルドに統合する方法を見ていきます。</p>
<h2 id="プロジェクトの準備-10"><a class="header" href="#プロジェクトの準備-10">プロジェクトの準備</a></h2>
<p>この章のプロジェクトには依存関係として <code>quickcheck</code>が追加されます。</p>
<p>Spagoプロジェクトでは、テストソースは <code>test</code>ディレクトリに置かれ、テストスイートのメインモジュールは
<code>Test.Main</code>と名づけられます。 テストスイートは、 <code>spago test</code>コマンドを使用して実行できます。</p>
<h2 id="性質を書く"><a class="header" href="#性質を書く">性質を書く</a></h2>
<p><code>Merge</code>モジュールでは簡単な関数 <code>merge</code>が実装されています。
これを<code>quickcheck</code>ライブラリの機能を実演するために使っていきます。</p>
<pre><code class="language-haskell">merge :: Array Int -&gt; Array Int -&gt; Array Int
</code></pre>
<p><code>merge</code>は2つの整列された整数の配列を取って、結果が整列されるように要素を統合します。
例えば次のようになります。</p>
<pre><code class="language-text">&gt; import Merge
&gt; merge [1, 3, 5] [2, 4, 5]

[1, 2, 3, 4, 5, 5]
</code></pre>
<p>典型的なテストスイートでは、手作業でこのような小さなテスト項目を幾つも作成し、結果が正しい値と等しいことを確認することでテストを実施します。
しかし、<code>merge</code>関数について知る必要があるものは全て、この性質に要約できます。</p>
<ul>
<li><code>xs</code>と<code>ys</code>が整列済みなら、<code>merge xs ys</code>は両方の配列が一緒に結合されて整列された結果になります。</li>
</ul>
<p><code>quickcheck</code>では、無作為なテスト項目を生成することで、直接この性質をテストできます。
コードが持つべき性質を関数として述べるだけです。
この場合は1つの性質があります。</p>
<pre><code class="language-haskell">main = do
  quickCheck \xs ys -&gt;
    eq (merge (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>このコードを実行すると、<code>quickcheck</code>は無作為な入力<code>xs</code>と<code>ys</code>を生成してこの関数に渡すことで、主張した性質を反証しようとします。
何らかの入力に対して関数が<code>false</code>を返した場合、性質は正しくなく、ライブラリはエラーを発生させます。
幸いなことに、次のように100個の無作為なテスト項目を生成しても、ライブラリはこの性質を反証できません。</p>
<pre><code class="language-text">$ spago test

Installation complete.
Build succeeded.
100/100 test(s) passed.
...
Tests succeeded.
</code></pre>
<p>もし
<code>merge</code>関数に意図的にバグを混入した場合（例えば、大なりのチェックを小なりのチェックへと変更するなど）、最初に失敗したテスト項目の後で例外が実行時に投げられます。</p>
<pre><code class="language-text">Error: Test 1 failed:
Test returned false
</code></pre>
<p>見ての通りこのエラー文言ではあまり役に立ちませんが、少し工夫するだけで改良できます。</p>
<h2 id="エラー文言の改善"><a class="header" href="#エラー文言の改善">エラー文言の改善</a></h2>
<p>テスト項目が失敗した時に同時にエラー文言を提供する上で、<code>quickcheck</code>は<code>&lt;?&gt;</code>演算子を提供しています。
次のように性質の定義とエラー文言を<code>&lt;?&gt;</code>で区切って書くだけです。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  let
    result = merge (sort xs) (sort ys)
    expected = sort $ xs &lt;&gt; ys
  in
    eq result expected &lt;?&gt; &quot;Result:\n&quot; &lt;&gt; show result &lt;&gt; &quot;\nnot equal to expected:\n&quot; &lt;&gt; show expected
</code></pre>
<p>このとき、もしバグを混入するようにコードを変更すると、最初のテスト項目が失敗したときに改良されたエラー文言が表示されます。</p>
<pre><code class="language-text">Error: Test 1 (seed 534161891) failed:
Result:
[-822215,-196136,-116841,618343,887447,-888285]
not equal to expected:
[-888285,-822215,-196136,-116841,618343,887447]
</code></pre>
<p>入力 <code>xs</code>が無作為に選ばれた数の配列として生成されていることに注目してください。</p>
<h2 id="演習-44"><a class="header" href="#演習-44">演習</a></h2>
<ol>
<li>（簡単）配列に空の配列を統合しても元の配列は変更されないことを確かめる性質を書いてください。
<em>補足</em>：この新しい性質は冗長です。
というのもこの状況は既に既存の性質で押さえられているからです。
ここでは読者がQuickCheckを使う練習のための簡単なやり方を示そうとしているだけです。</li>
<li>（簡単）<code>merge</code>の残りの性質に対して、適切なエラー文言を追加してください。</li>
</ol>
<h2 id="多相的なコードのテスト"><a class="header" href="#多相的なコードのテスト">多相的なコードのテスト</a></h2>
<p><code>Merge</code>モジュールでは、数の配列だけでなく、 <code>Ord</code>型クラスに属するどんな型の配列に対しても動作する、 <code>merge</code>関数を一般化した
<code>mergePoly</code>という関数が定義されています。</p>
<pre><code class="language-haskell">mergePoly :: forall a. Ord a =&gt; Array a -&gt; Array a -&gt; Array a
</code></pre>
<p><code>merge</code>の代わりに <code>mergePoly</code>を使うように元のテストを変更すると、次のようなエラー文言が表示されます。</p>
<pre><code class="language-text">No type class instance was found for

  Test.QuickCheck.Arbitrary.Arbitrary t0

The instance head contains unknown type variables.
Consider adding a type annotation.
</code></pre>
<p>このエラー文言は、配列に持たせたい要素の型が何なのかわからないので、コンパイラが無作為なテスト項目を生成できなかったということを示しています。
このような場合、型註釈を使ってコンパイラが特定の型を推論するように強制できます。
例えば<code>Array Int</code>などです。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>代替案として型を指定する補助関数を使うこともできます。
こうするとより見通しのよいコードになることがあります。
例えば同値関数の同義語として関数<code>ints</code>を定義したとしましょう。</p>
<pre><code class="language-haskell">ints :: Array Int -&gt; Array Int
ints = id
</code></pre>
<p>それから、コンパイラが引数の2つの配列の型 <code>Array Int</code>を推論するように、テストを変更します。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>ここで、<code>ints</code>関数が不明な型の曖昧さを解消するために使われているため、<code>xs</code>と<code>ys</code>は型<code>Array Int</code>を持っています。</p>
<h2 id="演習-45"><a class="header" href="#演習-45">演習</a></h2>
<ol>
<li>（簡単）<code>xs</code>と<code>ys</code>の型を<code>Array Boolean</code>に強制する関数<code>bools</code>を書き、<code>mergePoly</code>をその型でテストする性質を追加してください。</li>
<li>（普通）標準関数から（例えば<code>arrays</code>パッケージから）1つ関数を選び、適切なエラー文言を含めてQuickCheckの性質を書いてください。
その性質は、補助関数を使って多相型引数を <code>Int</code>か <code>Boolean</code>のどちらかに固定しなければいけません。</li>
</ol>
<h2 id="任意のデータの生成"><a class="header" href="#任意のデータの生成">任意のデータの生成</a></h2>
<p>それでは<code>quickcheck</code>ライブラリが性質に対するテスト項目をどのように無作為に生成できているのかを見ていきます。</p>
<p>無作為に値を生成できるような型は、次のような型クラス <code>Arbitary</code>のインスタンスを持っています。</p>
<pre><code class="language-haskell">class Arbitrary t where
  arbitrary :: Gen t
</code></pre>
<p><code>Gen</code>型構築子は<em>決定的無作為データ生成</em>の副作用を表しています。
決定的無作為データ生成は、擬似乱数生成器を使って、シード値から決定的無作為関数の引数を生成します。
<code>Test.QuickCheck.Gen</code>モジュールは、生成器を構築するための幾つかの有用なコンビネータを定義しています。</p>
<p><code>Gen</code>はモナドでもアプリカティブ関手でもあるので、
<code>Arbitary</code>型クラスの新しいインスタンスを作成するのに、いつも使っているようなコンビネータを自由に使うことができます。</p>
<p>例えば、<code>quickcheck</code>ライブラリで提供されている<code>Int</code>型用の<code>Arbitrary</code>インスタンスを使い、256個のバイト値上の分布を作れます。
これには<code>Gen</code>用の<code>Functor</code>インスタンスを使い、整数からバイトへの関数を任意の整数値に写します。</p>
<pre><code class="language-haskell">newtype Byte = Byte Int

instance Arbitrary Byte where
  arbitrary = map intToByte arbitrary
    where
    intToByte n | n &gt;= 0 = Byte (n `mod` 256)
                | otherwise = intToByte (-n)
</code></pre>
<p>ここでは、0から255までの間の整数値であるような型<code>Byte</code>を定義しています。
<code>Arbitrary</code>インスタンスは<code>map</code>演算子を使って、<code>intToByte</code>関数を<code>arbitrary</code>動作まで持ち上げています。
<code>arbitrary</code>動作内部の型は<code>Gen Int</code>と推論されます。</p>
<p>この考え方を <code>merge</code>用のテストに使うこともできます。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>このテストでは、任意の配列<code>xs</code>と<code>ys</code>を生成しますが、<code>merge</code>は整列済みの入力を期待しているので、これらを整列しておかなければなりません。
一方で、整列された配列を表すnewtypeを作成し、整列されたデータを生成する<code>Arbitrary</code>インスタンスを書くこともできます。</p>
<pre><code class="language-haskell">newtype Sorted a = Sorted (Array a)

sorted :: forall a. Sorted a -&gt; Array a
sorted (Sorted xs) = xs

instance (Arbitrary a, Ord a) =&gt; Arbitrary (Sorted a) where
  arbitrary = map (Sorted &lt;&lt;&lt; sort) arbitrary
</code></pre>
<p>この型構築子を使うと、テストを次のように変更できます。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs &lt;&gt; sorted ys)
</code></pre>
<p>これは些細な変更に見えるかもしれませんが、<code>xs</code>と<code>ys</code>の型はただの<code>Array Int</code>から<code>Sorted Int</code>へと変更されています。
これにより、<code>mergePoly</code>関数は整列済みの入力を取る、という<em>意図</em>をわかりやすく示すことができます。
理想的には、<code>mergePoly</code>関数自体の型が<code>Sorted</code>型構築子を使うようにするといいでしょう。</p>
<p>より興味深い例として、 <code>Tree</code>モジュールでは枝の値で整列された二分木の型が定義されています。</p>
<pre><code class="language-haskell">data Tree a
  = Leaf
  | Branch (Tree a) a (Tree a)
</code></pre>
<p><code>Tree</code>モジュールでは次のAPIが定義されています。</p>
<pre><code class="language-haskell">insert    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Tree a
member    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Boolean
fromArray :: forall a. Ord a =&gt; Array a -&gt; Tree a
toArray   :: forall a. Tree a -&gt; Array a
</code></pre>
<p><code>insert</code>関数は新しい要素を整列済みの木に挿入し、<code>member</code>関数は特定の値について木に問い合わせます。
例えば次のようになります。</p>
<pre><code class="language-text">&gt; import Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false
</code></pre>
<p><code>toArray</code>関数と<code>fromArray</code>関数は、整列された木と配列を相互に変換できます。
<code>fromArray</code>を使うと、木についての<code>Arbitrary</code>インスタンスを書けます。</p>
<pre><code class="language-haskell">instance (Arbitrary a, Ord a) =&gt; Arbitrary (Tree a) where
  arbitrary = map fromArray arbitrary
</code></pre>
<p>型<code>a</code>用に使える<code>Arbitary</code>インスタンスがあるなら、テストする性質の引数の型として<code>Tree a</code>を使えます。
例えば、<code>member</code>による木の確認については、値を挿入した後は常に<code>true</code>を返すことをテストできます。</p>
<pre><code class="language-haskell">quickCheck \t a -&gt;
  member a $ insert a $ treeOfInt t
</code></pre>
<p>ここでは、引数 <code>t</code>は <code>Tree Number</code>型の無作為に生成された木です。
型引数は、同値関数 <code>treeOfInt</code>によって明確にされています。</p>
<h2 id="演習-46"><a class="header" href="#演習-46">演習</a></h2>
<ol>
<li>（普通）<code>a-z</code>の範囲から無作為に選ばれた文字の集まりを生成する
<code>Arbitrary</code>インスタンスを持つ、<code>String</code>のnewtypeを作ってください。
<em>手掛かり</em>：<code>Test.QuickCheck.Gen</code>モジュールから <code>elements</code>と <code>arrayOf</code>関数を使います。</li>
<li>（難しい）木に挿入された値は、どれだけ沢山の挿入があった後でも、その木の構成要素であることを主張する性質を書いてください。</li>
</ol>
<h2 id="高階関数のテスト"><a class="header" href="#高階関数のテスト">高階関数のテスト</a></h2>
<p><code>Merge</code>モジュールは<code>merge</code>関数の別の一般化も定義しています。
<code>mergeWith</code>関数は追加の関数を引数として取り、統合される要素の順序を判定します。
つまり<code>mergeWith</code>は高階関数です。</p>
<p>例えば<code>length</code>関数を最初の引数として渡し、既に長さの昇順になっている2つの配列を統合できます。
その結果もまた長さの昇順になっているでしょう。</p>
<pre><code class="language-haskell">&gt; import Data.String

&gt; mergeWith length
    [&quot;&quot;, &quot;ab&quot;, &quot;abcd&quot;]
    [&quot;x&quot;, &quot;xyz&quot;]

[&quot;&quot;,&quot;x&quot;,&quot;ab&quot;,&quot;xyz&quot;,&quot;abcd&quot;]
</code></pre>
<p>このような関数をテストするにはどうしたらいいでしょうか。
理想的には、関数である最初の引数を含めた3つの引数全てについて、値を生成したいところです。</p>
<p>無作為に生成された関数を作れるようにする、2つ目の型クラスがあります。
<code>Coarbitrary</code>という名前で次のように定義されています。</p>
<pre><code class="language-haskell">class Coarbitrary t where
  coarbitrary :: forall r. t -&gt; Gen r -&gt; Gen r
</code></pre>
<p><code>coarbitrary</code>関数は、型<code>t</code>の関数の引数と、型<code>r</code>の関数の結果の乱数生成器を取ります。
この関数引数を使って乱数生成器を<em>かき乱し</em>ます。
つまり、関数の引数を使って乱数生成器の無作為な出力を変更し、結果としているのです。</p>
<p>また、もし関数の定義域が<code>Coarbitrary</code>で値域が<code>Arbitrary</code>なら、<code>Arbitrary</code>の関数を与える型クラスインスタンスが存在します。</p>
<pre><code class="language-haskell">instance (Coarbitrary a, Arbitrary b) =&gt; Arbitrary (a -&gt; b)
</code></pre>
<p>実際のところ、引数として関数を取るような性質を記述できます。
<code>mergeWith</code>関数の場合では、新しい引数を考慮するようにテストを修正すると、最初の引数を無作為に生成できます。</p>
<p>結果が整列されていることは保証できません。
<code>Ord</code>インスタンスを持っているとさえ限らないのです。
しかし、引数として渡す関数<code>f</code>に従って結果が整列されていることは期待されます。
更に、2つの入力配列が<code>f</code>に従って整列されている必要がありますので、<code>sortBy</code>関数を使って関数<code>f</code>が適用されたあとの比較に基づいて<code>xs</code>と<code>ys</code>を整列します。</p>
<pre><code class="language-haskell">quickCheck \xs ys f -&gt;
  let
    result =
      map f $
        mergeWith (intToBool f)
                  (sortBy (compare `on` f) xs)
                  (sortBy (compare `on` f) ys)
    expected =
      map f $
        sortBy (compare `on` f) $ xs &lt;&gt; ys
  in
    eq result expected
</code></pre>
<p>ここでは、関数 <code>f</code>の型を明確にするために、関数 <code>intToBool</code>を使用しています。</p>
<pre><code class="language-haskell">intToBool :: (Int -&gt; Boolean) -&gt; Int -&gt; Boolean
intToBool = id
</code></pre>
<p>関数は <code>Arbitrary</code>であるだけでなく <code>Coarbitrary</code>でもあります。</p>
<pre><code class="language-haskell">instance (Arbitrary a, Coarbitrary b) =&gt; Coarbitrary (a -&gt; b)
</code></pre>
<p>つまり値や関数だけに制限されません。
<em>高階関数</em>や、引数が高階関数であるような関数やその他諸々もまた、無作為に生成できるのです。</p>
<h2 id="coarbitraryのインスタンスを書く"><a class="header" href="#coarbitraryのインスタンスを書く">Coarbitraryのインスタンスを書く</a></h2>
<p><code>Gen</code>の <code>Monad</code>や <code>Applicative</code>インスタンスを使って独自のデータ型に対して
<code>Arbitrary</code>インスタンスを書くことができるのとちょうど同じように、独自の <code>Coarbitrary</code>インスタンスを書くこともできます。
これにより、無作為に生成される関数の定義域として、独自のデータ型を使うことができるようになります。</p>
<p><code>Tree</code>型の <code>Coarbitrary</code>インスタンスを書いてみましょう。
枝に格納されている要素の型に <code>Coarbitrary</code>インスタンスが必要になります。</p>
<pre><code class="language-haskell">instance Coarbitrary a =&gt; Coarbitrary (Tree a) where
</code></pre>
<p>型<code>Tree a</code>の値が与えられたときに、乱数発生器をかき乱す関数を記述する必要があります。
入力値が<code>Leaf</code>であれば、そのままにしておく生成器を返します。</p>
<pre><code class="language-haskell">  coarbitrary Leaf = id
</code></pre>
<p>もし木が <code>Branch</code>なら、左の部分木、値、右の部分木を使って生成器をかき乱します。
関数合成を使って独自のかき乱し関数を作ります。</p>
<pre><code class="language-haskell">  coarbitrary (Branch l a r) =
    coarbitrary l &lt;&lt;&lt;
    coarbitrary a &lt;&lt;&lt;
    coarbitrary r
</code></pre>
<p>これで、木を引数にとるような関数を引数に含む性質を自由に書くことができるようになりました。
例えば<code>Tree</code>モジュールでは関数<code>anywhere</code>が定義されています。
これは述語が引数のどんな部分木についても満たされるかを調べます。</p>
<pre><code class="language-haskell">anywhere :: forall a. (Tree a -&gt; Boolean) -&gt; Tree a -&gt; Boolean
</code></pre>
<p>今や述語関数を無作為に生成できます。
例えば、<code>anywhere</code>関数は<em>選言の法則を満たす</em>ことが期待されます。</p>
<pre><code class="language-haskell">quickCheck \f g t -&gt;
  anywhere (\s -&gt; f s || g s) t ==
    anywhere f (treeOfInt t) || anywhere g t
</code></pre>
<p>ここで、 <code>treeOfInt</code>関数は木に含まれる値の型を型 <code>Int</code>に固定するために使われています。</p>
<pre><code class="language-haskell">treeOfInt :: Tree Int -&gt; Tree Int
treeOfInt = id
</code></pre>
<h2 id="副作用のないテスト"><a class="header" href="#副作用のないテスト">副作用のないテスト</a></h2>
<p>通常、テストの目的ではテストスイートの<code>main</code>動作に<code>quickCheck</code>関数の呼び出しが含まれています。
しかし<code>quickCheck</code>関数には亜種があり、<code>quickCheckPure</code>という名前です。
副作用を使わない代わりに、入力として乱数の種を取ってテスト結果の配列を返す純粋な関数です。</p>
<p>PSCiを使用して <code>quickCheckPure</code>を試せます。
ここでは <code>merge</code>操作が結合法則を満たすことをテストします。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Merge
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.LCG (mkSeed)

&gt; :paste
… quickCheckPure (mkSeed 12345) 10 \xs ys zs -&gt;
…   ((xs `merge` ys) `merge` zs) ==
…     (xs `merge` (ys `merge` zs))
… ^D

Success : Success : ...
</code></pre>
<p><code>quickCheckPure</code>は乱数の種、生成するテスト項目数、テストする性質の3つの引数を取ります。
もし全てのテスト項目が成功したら、<code>Success</code>データ構築子の配列がコンソールに出力されます。</p>
<p><code>quickCheckPure</code>は、性能ベンチマークの入力データ生成や、webアプリケーションのフォームデータ例を無作為に生成するというような状況で便利かもしれません。</p>
<h2 id="演習-47"><a class="header" href="#演習-47">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Byte</code>と <code>Sorted</code>型構築子についての <code>Coarbitrary</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）任意の関数 <code>f</code>について、 <code>mergeWith f</code>関数の結合性を主張する（高階）性質を書いてください。
<code>quickCheckPure</code>を使ってPSCiでその性質をテストしてください。</p>
</li>
<li>
<p>（普通）次のデータ型の<code>Arbitrary</code>と<code>Coarbitrary</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">data OneTwoThree a = One a | Two a a | Three a a a
</code></pre>
<p><em>手掛かり</em>：<code>Test.QuickCheck.Gen</code>で定義された<code>oneOf</code>関数を使って<code>Arbitrary</code>インスタンスを定義してください。</p>
</li>
<li>
<p>（普通）<code>all</code>を使って<code>quickCheckPure</code>関数の結果を単純化してください。
この新しい関数は型<code>List Result -&gt; Boolean</code>を持ち、全てのテストが通れば<code>true</code>を、そうでなければ<code>false</code>を返します。</p>
</li>
<li>
<p>（普通）<code>quickCheckPure</code>の結果を単純にする別の手法として、関数<code>squashResults :: List Result -&gt; Result</code>を書いてみてください。
<code>Data.Maybe.First</code>の<code>First</code>モノイドと共に<code>foldMap</code>関数を使うことで、失敗した場合の最初のエラーを保持することを検討してください。</p>
</li>
</ol>
<h2 id="まとめ-11"><a class="header" href="#まとめ-11">まとめ</a></h2>
<p>この章では<code>quickcheck</code>パッケージに出会いました。
これを使うと<em>生成的テスティング</em>のパラダイムを使って、宣言的な方法でテストを書くことができました。具体的には以下です。</p>
<ul>
<li><code>spago test</code>を使ってQuickCheckのテストを自動化する方法を見ました。</li>
<li>性質を関数として書く方法とエラー文言を改良する<code>&lt;?&gt;</code>演算子の使い方を説明しました。</li>
<li><code>Arbitrary</code>と<code>Coarbitrary</code>型クラスによって定型的なテストコードの自動生成を可能にする方法や、高階な性質のテストを可能にする方法を見ました。</li>
<li>独自のデータ型に対して <code>Arbitrary</code>と <code>Coarbitrary</code>インスタンスを実装する方法を見ました。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="領域特化言語"><a class="header" href="#領域特化言語">領域特化言語</a></h1>
<h2 id="この章の目標-12"><a class="header" href="#この章の目標-12">この章の目標</a></h2>
<p>この章では多数の標準的な手法を使い、PureScriptにおける<em>領域特化言語</em>（または<em>DSL</em>）の実装について探求していきます。</p>
<p>領域特化言語とは、特定の問題領域での開発に適した言語のことです。
構文及び機能は、その領域内の考え方を表現するに使われるコードの読みやすさを最大化すべく選択されます。
本書の中では、既に領域特化言語の例を幾つか見てきています。</p>
<ul>
<li>第11章で開発された<code>Game</code>モナドと関連する動作は、<em>テキストアドベンチャーゲーム開発</em>という領域に対しての領域特化言語を構成しています。</li>
<li>第13章で扱った<code>quickcheck</code>パッケージは、<em>生成的テスティング</em>の領域に向けた領域特化言語です。
このコンビネータはテストの性質に対して特に表現力の高い記法を可能にします。</li>
</ul>
<p>この章では、領域特化言語の実装において、幾つかの標準的な技法にについて構造的な手法を取ります。
この話題の完全な解説では決してありませんが、目的に合う実践的なDSLを構築するのに充分な知識は得られるでしょう。</p>
<p>ここでの実行例はHTML文書を作成するための領域特化言語です。
正しいHTML文書を記述するための型安全な言語を開発することが目的で、素朴な実装を徐々に改善しつつ進めていきます。</p>
<h2 id="プロジェクトの準備-11"><a class="header" href="#プロジェクトの準備-11">プロジェクトの準備</a></h2>
<p>この章に付随するプロジェクトには新しい依存性が1つ追加されます。
これから使う道具の1つである<em>Freeモナド</em>が定義されている<code>free</code>ライブラリです。</p>
<p>このプロジェクトをPSCiを使って試していきます。</p>
<h2 id="htmlデータ型"><a class="header" href="#htmlデータ型">HTMLデータ型</a></h2>
<p>このHTMLライブラリの最も基本的なバージョンは
<code>Data.DOM.Simple</code>モジュールで定義されています。このモジュールには次の型定義が含まれています。</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Array Content)
  }

data Content
  = TextContent String
  | ElementContent Element

newtype Attribute = Attribute
  { key          :: String
  , value        :: String
  }
</code></pre>
<p><code>Element</code>型はHTMLの要素を表します。
各要素は要素名、属性の対の配列と、内容で構成されます。
内容のプロパティには<code>Maybe</code>型を適切に使い、要素が開いている（他の要素やテキストを含む）か閉じているかを示します。</p>
<p>このライブラリの鍵となる機能は次の関数です。</p>
<pre><code class="language-haskell">render :: Element -&gt; String
</code></pre>
<p>この関数はHTML要素をHTML文字列として出力します。
PSCiで明示的に適当な型の値を構築し、ライブラリのこのバージョンを試してみましょう。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Simple
&gt; import Data.Maybe
&gt; import Effect.Console

&gt; :paste
… log $ render $ Element
…   { name: &quot;p&quot;
…   , attribs: [
…       Attribute
…         { key: &quot;class&quot;
…         , value: &quot;main&quot;
…         }
…     ]
…   , content: Just [
…       TextContent &quot;Hello World!&quot;
…     ]
…   }
… ^D

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>現状のライブラリには幾つもの問題があります。</p>
<ul>
<li>HTML文書の作成に手が掛かります。
全ての新しい要素に少なくとも1つのレコードと1つのデータ構築子が必要です。</li>
<li>無効な文書を表現できてしまいます。
<ul>
<li>開発者が要素名の入力を間違えるかもしれません</li>
<li>開発者が属性を間違った要素に関連付けることができてしまいます</li>
<li>開いた要素が正しい場合に開発者が閉じた要素を使えてしまいます</li>
</ul>
</li>
</ul>
<p>残りの章ではとある手法を用いてこれらの問題を解決し、このライブラリーをHTML文書を作成するために使える領域特化言語にしていきます。</p>
<h2 id="スマート構築子"><a class="header" href="#スマート構築子">スマート構築子</a></h2>
<p>最初に導入する手法は単純ですがとても効果的です。
モジュールの使用者にデータの表現を露出する代わりに、モジュールエクスポートリストを使ってデータ構築子<code>Element</code>、<code>Content</code>、<code>Attribute</code>を隠蔽します。
そして正しいことが分かっているデータを構築する、いわゆる<em>スマート構築子</em>だけをエクスポートします。</p>
<p>例を示しましょう。まず、HTML要素を作成するための便利な関数を提供します。</p>
<pre><code class="language-haskell">element :: String -&gt; Array Attribute -&gt; Maybe (Array Content) -&gt; Element
element name attribs content = Element
  { name:      name
  , attribs:   attribs
  , content:   content
  }
</code></pre>
<p>次にHTML要素のためのスマート構築子を作成します。
この要素は利用者が<code>element</code>関数を適用して作成できるようになってほしいものです。</p>
<pre><code class="language-haskell">a :: Array Attribute -&gt; Array Content -&gt; Element
a attribs content = element &quot;a&quot; attribs (Just content)

p :: Array Attribute -&gt; Array Content -&gt; Element
p attribs content = element &quot;p&quot; attribs (Just content)

img :: Array Attribute -&gt; Element
img attribs = element &quot;img&quot; attribs Nothing
</code></pre>
<p>最後に、正しいデータ構造だけが構築されることがわかっているこれらの関数をエクスポートするように、モジュールエクスポートリストを更新します。</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute(..)
  , Content(..)

  , a
  , p
  , img

  , render
  ) where
</code></pre>
<p>モジュールエクスポートリストはモジュール名の直後の括弧内に書きます。
各モジュールのエクスポートは次の3種類の何れかになります。</p>
<ul>
<li>値（ないし関数）。その値の名前により指定されます。</li>
<li>型クラス。クラス名により指定されます。</li>
<li>型構築子とそれに紐付くデータ構築子。
型名とそれに続くエクスポートされるデータ構築子の括弧で囲まれたリストで指定されます。</li>
</ul>
<p>ここでは、<code>Element</code>の<em>型</em>をエクスポートしていますが、データ構築子はエクスポートしていません。
もしデータ構築子をエクスポートすると、使用者が不正なHTML要素を構築できてしまいます。</p>
<p><code>Attribute</code>と <code>Content</code>型についてはデータ構築子を全てエクスポートしています（エクスポートリストの記号 <code>..</code>で示されています）。
すぐ後で、これらの型にもスマート構築子の手法を適用していきます。</p>
<p>既にライブラリに幾つもの大きな改良が加わっていることに注目です。</p>
<ul>
<li>不正な名前を持つHTML要素は表現できません（勿論ライブラリが提供する要素名に制限されています）。</li>
<li>閉じた要素は構築するときに内容を含められません。</li>
</ul>
<p><code>Content</code>型にとても簡単にこの手法を適用できます。
単にエクスポートリストから<code>Content</code>型のデータ構築子を取り除き、次のスマート構築子を提供します。</p>
<pre><code class="language-haskell">text :: String -&gt; Content
text = TextContent

elem :: Element -&gt; Content
elem = ElementContent
</code></pre>
<p><code>Attribute</code>型にも同じ手法を適用してみましょう。
まず、属性のための汎用のスマート構築子を用意します。
以下は最初の試行です。</p>
<pre><code class="language-haskell">attribute :: String -&gt; String -&gt; Attribute
attribute key value = Attribute
  { key: key
  , value: value
  }

infix 4 attribute as :=
</code></pre>
<p>この定義では元の<code>Element</code>型と同じ問題に直面しています。
存在しなかったり、名前が間違って入力された属性を表現できます。
この問題を解決するために、属性名を表すnewtypeを作成します。</p>
<pre><code class="language-haskell">newtype AttributeKey = AttributeKey String
</code></pre>
<p>これを使えば演算子を次のように変更できます。</p>
<pre><code class="language-haskell">attribute :: AttributeKey -&gt; String -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: value
  }
</code></pre>
<p><code>AttributeKey</code>データ構築子をエクスポートしなければ、明示的にエクスポートされた次のような関数を使う以外に、使用者が型
<code>AttributeKey</code>の値を構築する方法はありません。
以下に幾つかの例を示します。</p>
<pre><code class="language-haskell">href :: AttributeKey
href = AttributeKey &quot;href&quot;

_class :: AttributeKey
_class = AttributeKey &quot;class&quot;

src :: AttributeKey
src = AttributeKey &quot;src&quot;

width :: AttributeKey
width = AttributeKey &quot;width&quot;

height :: AttributeKey
height = AttributeKey &quot;height&quot;
</code></pre>
<p>新しいモジュールの最終的なエクスポートリストは次のようになります。
最早どのデータ構築子も直接エクスポートしていない点に注目です。</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute
  , Content
  , AttributeKey

  , a
  , p
  , img

  , href
  , _class
  , src
  , width
  , height

  , attribute, (:=)
  , text
  , elem

  , render
  ) where
</code></pre>
<p>PSCiでこの新しいモジュールを試してみると、既にコードの簡潔さにおいて大幅な向上が見て取れます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Smart
&gt; import Effect.Console
&gt; log $ render $ p [ _class := &quot;main&quot; ] [ text &quot;Hello World!&quot; ]

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>しかし、基盤をなすデータ表現は全く変更されなかったので、<code>render</code>関数を変更する必要はなかったことにも注目してください。
これはスマート構築子による手法の利点のひとつです。
外部APIの使用者によって認識される表現から、モジュールの内部データ表現を分離できるのです。</p>
<h2 id="演習-48"><a class="header" href="#演習-48">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Data.DOM.Smart</code>モジュールで <code>render</code>を使った新しいHTML文書の作成を試してみましょう。</p>
</li>
<li>
<p>（普通）<code>checked</code>や<code>disabled</code>といったHTML属性は値を要求せず、<em>空の属性</em>として書き出せます。</p>
<pre><code class="language-html">&lt;input disabled&gt;
</code></pre>
<p>空の属性を扱えるように <code>Attribute</code>の表現を変更してください。
要素に空の属性を追加するための<code>attribute</code>または<code>:=</code>の代わりに使える関数を記述してください。</p>
</li>
</ol>
<h2 id="幻影型"><a class="header" href="#幻影型">幻影型</a></h2>
<p>次の手法の動機付けとして、以下のコードを考えます。</p>
<pre><code class="language-text">&gt; log $ render $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := &quot;foo&quot;
    , height := &quot;bar&quot;
    ]

&lt;img src=&quot;cat.jpg&quot; width=&quot;foo&quot; height=&quot;bar&quot; /&gt;
unit
</code></pre>
<p>ここでの問題は、 <code>width</code>属性と<code>height</code>属性に文字列値を提供しているということです。
ここで与えることができるのはピクセル単位ないしパーセントの数値だけであるべきです。</p>
<p><code>AttributeKey</code>型にいわゆる <em>幻影型</em> (phantom type) 引数を導入すると、この問題を解決できます。</p>
<pre><code class="language-haskell">newtype AttributeKey a = AttributeKey String
</code></pre>
<p>定義の右辺に対応する型 <code>a</code>の値が存在しないので、この型変数 <code>a</code>は<em>幻影型</em>と呼ばれています。
この型 <code>a</code>はコンパイル時に追加の情報を提供するためだけに存在しています。
型<code>AttributeKey a</code>の任意の値は実行時には単なる文字列ですが、コンパイル時はその値の型により、このキーに関連する値で求められる型がわかります。</p>
<p><code>attribute</code>関数の型を次のように変更すれば、<code>AttributeKey</code>の新しい形式を考慮するようにできます。</p>
<pre><code class="language-haskell">attribute :: forall a. IsValue a =&gt; AttributeKey a -&gt; a -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: toValue value
  }
</code></pre>
<p>ここで、幻影型の引数 <code>a</code>は、属性キーと属性値が照応する型を持っていることを確認するために使われます。
使用者は <code>AttributeKey a</code>の型の値を直接作成できないので（ライブラリで提供されている定数を介してのみ得られます）、全ての属性が構築により正しくなります。</p>
<p>なお、<code>IsValue</code>制約はキーに関連付けられた値の型が何であれその値を文字列に変換し、生成したHTML内に出力できることを保証します。
<code>IsValue</code>型クラスは次のように定義されています。</p>
<pre><code class="language-haskell">class IsValue a where
  toValue :: a -&gt; String
</code></pre>
<p><code>String</code>と <code>Int</code>型についての型クラスインスタンスも提供しておきます。</p>
<pre><code class="language-haskell">instance IsValue String where
  toValue = id

instance IsValue Int where
  toValue = show
</code></pre>
<p>また、これらの型が新しい型変数を反映するように、 <code>AttributeKey</code>定数を更新しなければいけません。</p>
<pre><code class="language-haskell">href :: AttributeKey String
href = AttributeKey &quot;href&quot;

_class :: AttributeKey String
_class = AttributeKey &quot;class&quot;

src :: AttributeKey String
src = AttributeKey &quot;src&quot;

width :: AttributeKey Int
width = AttributeKey &quot;width&quot;

height :: AttributeKey Int
height = AttributeKey &quot;height&quot;
</code></pre>
<p>これで、不正なHTML文書を表現することが不可能になっていることがわかります。
また、<code>width</code>と <code>height</code>属性を表現するのに文字列ではなく数を使うことが強制されていることがわかります。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Phantom
&gt; import Effect.Console

&gt; :paste
… log $ render $ img
…   [ src    := &quot;cat.jpg&quot;
…   , width  := 100
…   , height := 200
…   ]
… ^D

&lt;img src=&quot;cat.jpg&quot; width=&quot;100&quot; height=&quot;200&quot; /&gt;
unit
</code></pre>
<h2 id="演習-49"><a class="header" href="#演習-49">演習</a></h2>
<ol>
<li>
<p>（簡単）ピクセルまたはパーセントの何れかの長さを表すデータ型を作成してください。
その型について<code>IsValue</code>のインスタンスを書いてください。
この新しい型を使うように<code>width</code>と<code>height</code>属性を変更してください。</p>
</li>
<li>
<p>（難しい）真偽値<code>true</code>、<code>false</code>用の最上位の表現を定義することで、幻影型を使って<code>AttributeKey</code>が<code>disabled</code>や<code>checked</code>のような<em>空の属性</em>を表現しているかどうかをエンコードできます。</p>
<pre><code class="language-haskell">data True
data False
</code></pre>
<p>幻影型を使って、使用者が <code>attribute</code>演算子を空の属性に対して使うことを防ぐように、前の演習の解答を変更してください。</p>
</li>
</ol>
<h2 id="freeモナド"><a class="header" href="#freeモナド">Freeモナド</a></h2>
<p>APIに施す最後の変更では、<code>Content</code>型をモナドにしてdo記法を使えるようにするために、<em>Freeモナド</em>と呼ばれる構造を使っていきます。
これによって入れ子になった要素がわかりやすくなるような形式でHTML文書を構造化できます。
以下の代わりに……</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ]
  [ elem $ img
      [ src    := &quot;cat.jpg&quot;
      , width  := 100
      , height := 200
      ]
  , text &quot;A cat&quot;
  ]
</code></pre>
<p>このように書くことができるようになります。</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ] $ do
  elem $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := 100
    , height := 200
    ]
  text &quot;A cat&quot;
</code></pre>
<p>しかし、do記法だけがFreeモナドの恩恵ではありません。
Freeモナドがあれば、モナドの動作の<em>表現</em>をその<em>解釈</em>から分離し、同じ動作に<em>複数の解釈</em>を持たせることさえできます。</p>
<p><code>Free</code>モナドは<code>free</code>ライブラリの<code>Control.Monad.Free</code>モジュールで定義されています。
PSCiを使うと、次のようにFreeモナドについての基本的な情報を見ることができます。</p>
<pre><code class="language-text">&gt; import Control.Monad.Free

&gt; :kind Free
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p><code>Free</code>の種は、引数として型構築子を取り、別の型構築子を返すことを示しています。
実はなんと、<code>Free</code>モナドを使えば任意の<code>Functor</code>を<code>Monad</code>にできるのです。</p>
<p>モナドの動作の<em>表現</em>の定義から始めます。
これには対応したい各モナド動作について、1つのデータ構築子を持つ<code>Functor</code>を作成する必要があります。
今回の場合、2つのモナドの動作は<code>elem</code>と<code>text</code>になります。
<code>Content</code>型を次のように変更するだけでできます。</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a

instance Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
</code></pre>
<p>ここで、この<code>ContentF</code>型構築子は以前の<code>Content</code>データ型とよく似ています。
しかし、ここでは型引数<code>a</code>を取り、それぞれのデータ構築子は型<code>a</code>の値を追加の引数として取るように変更されています。
<code>Functor</code>インスタンスでは、単に各データ構築子で型<code>a</code>の値に関数<code>f</code>を適用します。</p>
<p>これにより、新しい<code>Content</code>モナドを<code>Free</code>モナド用の型同義語として定義できます。
これは最初の型引数として <code>ContentF</code>型構築子を使うことで構築されます。</p>
<pre><code class="language-haskell">type Content = Free ContentF
</code></pre>
<p>型同義語の代わりに<code>newtype</code>を使用して、使用者に対してライブラリの内部表現を露出することを避けられます。
<code>Content</code>データ構築子を隠すことで、提供しているモナドの動作だけを使うことを使用者に制限しています。</p>
<p><code>ContentF</code>は <code>Functor</code>なので、 <code>Free ContentF</code>用の<code>Monad</code>インスタンスが自動的に手に入ります。</p>
<p><code>Content</code>の新しい型引数を考慮するように<code>Element</code>データ型を僅かに変更する必要があります。
モナドの計算の戻り値の型が <code>Unit</code>であることだけが必要です。</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Content Unit)
  }
</code></pre>
<p>また、<code>Content</code>モナドについての新しいモナドの動作になるよう、<code>elem</code>と<code>text</code>関数を変更する必要があります。
これには<code>Control.Monad.Free</code>モジュールで提供されている <code>liftF</code>関数が使えます。
以下がその型です。</p>
<pre><code class="language-haskell">liftF :: forall f a. f a -&gt; Free f a
</code></pre>
<p><code>liftF</code>により、何らかの型<code>a</code>について、型<code>f a</code>の値からFreeモナドの動作を構築できるようになります。
今回の場合、<code>ContentF</code>型構築子のデータ構築子をそのまま使えます。</p>
<pre><code class="language-haskell">text :: String -&gt; Content Unit
text s = liftF $ TextContent s unit

elem :: Element -&gt; Content Unit
elem e = liftF $ ElementContent e unit
</code></pre>
<p>他にも同じようなコードの変更はありますが、興味深い変更は <code>render</code>関数にあります。ここでは、このFreeモナドを <em>解釈</em>
しなければいけません。</p>
<h2 id="モナドの解釈"><a class="header" href="#モナドの解釈">モナドの解釈</a></h2>
<p><code>Control.Monad.Free</code>モジュールでは、Freeモナドで計算を解釈するための多数の関数が提供されています。</p>
<pre><code class="language-haskell">runFree
  :: forall f a
   . Functor f
  =&gt; (f (Free f a) -&gt; Free f a)
  -&gt; Free f a
  -&gt; a

runFreeM
  :: forall f m a
   . (Functor f, MonadRec m)
  =&gt; (f (Free f a) -&gt; m (Free f a))
  -&gt; Free f a
  -&gt; m a
</code></pre>
<p><code>runFree</code>関数は、<em>純粋な</em>結果を計算するために使用されます。
<code>runFreeM</code>関数があればFreeモナドの動作を解釈するためにモナドが使えます。</p>
<p><em>補足</em>：厳密には、より強い<code>MonadRec</code>制約を満たすモナド<code>m</code>に制限されています。
実際、ら<code>m</code>は安全な<em>末尾再帰モナド</em>に対応してため、スタックオーバーフローを心配する必要はありません。</p>
<p>まず、動作を解釈できるモナドを選ばなければなりません。
<code>Writer String</code>モナドを使って、結果のHTML文字列を累算することにします。</p>
<p>新しい<code>render</code>メソッドが開始すると、補助関数
<code>renderElement</code>に移譲し、<code>execWriter</code>を使って<code>Writer</code>モナドで計算します。</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render = execWriter &lt;&lt;&lt; renderElement
</code></pre>
<p><code>renderElement</code>はwhereブロックで定義されます。</p>
<pre><code class="language-haskell">  where
    renderElement :: Element -&gt; Writer String Unit
    renderElement (Element e) = do
</code></pre>
<p><code>renderElement</code>の定義は直感的で、複数の小さな文字列を累算するために<code>Writer</code>モナドの<code>tell</code>動作を使っています。</p>
<pre><code class="language-haskell">      tell &quot;&lt;&quot;
      tell e.name
      for_ e.attribs $ \x -&gt; do
        tell &quot; &quot;
        renderAttribute x
      renderContent e.content
</code></pre>
<p>次に、<code>renderAttribute</code>関数を定義します。
こちらも同じくらい単純です。</p>
<pre><code class="language-haskell">    where
      renderAttribute :: Attribute -&gt; Writer String Unit
      renderAttribute (Attribute x) = do
        tell x.key
        tell &quot;=\&quot;&quot;
        tell x.value
        tell &quot;\&quot;&quot;
</code></pre>
<p><code>renderContent</code>関数は、もっと興味深いものです。
ここでは<code>runFreeM</code>関数を使い、Freeモナドの内部で計算を解釈しています。
計算は補助関数 <code>renderContentItem</code>に移譲しています。</p>
<pre><code class="language-haskell">      renderContent :: Maybe (Content Unit) -&gt; Writer String Unit
      renderContent Nothing = tell &quot; /&gt;&quot;
      renderContent (Just content) = do
        tell &quot;&gt;&quot;
        runFreeM renderContentItem content
        tell &quot;&lt;/&quot;
        tell e.name
        tell &quot;&gt;&quot;
</code></pre>
<p><code>renderContentItem</code>の型は <code>runFreeM</code>の型シグネチャから推測できます。
関手 <code>f</code>は型構築子 <code>ContentF</code>で、モナド <code>m</code>は解釈している計算のモナド、つまり <code>Writer String</code>です。
これにより <code>renderContentItem</code>は次の型シグネチャだとわかります。</p>
<pre><code class="language-haskell">      renderContentItem :: ContentF (Content Unit) -&gt; Writer String (Content Unit)
</code></pre>
<p><code>ContentF</code>の2つのデータ構築子でパターン照合すればこの関数を実装できます。</p>
<pre><code class="language-haskell">      renderContentItem (TextContent s rest) = do
        tell s
        pure rest
      renderContentItem (ElementContent e rest) = do
        renderElement e
        pure rest
</code></pre>
<p>それぞれの場合において、式<code>rest</code>は型<code>Content Unit</code>を持っており、解釈された計算の残りを表しています。
<code>rest</code>動作を返すことでそれぞれの場合を完成できます。</p>
<p>できました。
PSCiで、次のようにすれば新しいモナドのAPIを試すことができます。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Free
&gt; import Effect.Console

&gt; :paste
… log $ render $ p [] $ do
…   elem $ img [ src := &quot;cat.jpg&quot; ]
…   text &quot;A cat&quot;
… ^D

&lt;p&gt;&lt;img src=&quot;cat.jpg&quot; /&gt;A cat&lt;/p&gt;
unit
</code></pre>
<h2 id="演習-50"><a class="header" href="#演習-50">演習</a></h2>
<ol>
<li>（普通）<code>ContentF</code>型に新しいデータ構築子を追加して、生成されたHTMLにコメントを出力する新しい動作<code>comment</code>に対応してください。
<code>liftF</code>を使ってこの新しい動作を実装してください。
新しい構築子を適切に解釈するように、解釈<code>renderContentItem</code>を更新してください。</li>
</ol>
<h2 id="言語の拡張"><a class="header" href="#言語の拡張">言語の拡張</a></h2>
<p>全動作が型<code>Unit</code>の何かを返すようなモナドは、さほど興味深いものではありません。
実際のところ、概ね良くなったと思われる構文は別として、このモナドは<code>Monoid</code>以上の機能を何ら追加していません。</p>
<p>非自明な結果を返す新しいモナド動作でこの言語を拡張することで、Freeモナドを構築する威力をお見せしましょう。</p>
<p><em>アンカー</em>を使用して文書の様々な節へのハイパーリンクが含まれているHTML文書を生成したいとします。
手作業でアンカーの名前を生成して文書中で少なくとも2回それらを含めれば、これは達成できます。
1つはアンカーの定義自身に、もう1つは各ハイパーリンクにあります。
しかし、この手法には基本的な問題が幾つかあります。</p>
<ul>
<li>開発者が一意なアンカー名の生成をし損なうかもしれません。</li>
<li>開発者がアンカー名を1つ以上の箇所で打ち間違うかもしれません。</li>
</ul>
<p>開発者が誤ちを犯すことを防ぐために、アンカー名を表す新しい型を導入し、新しい一意な名前を生成するためのモナド動作を提供できます。</p>
<p>最初の工程は名前の型を新しく追加することです。</p>
<pre><code class="language-haskell">newtype Name = Name String

runName :: Name -&gt; String
runName (Name n) = n
</code></pre>
<p>繰り返しになりますが、<code>Name</code>は
<code>String</code>のnewtypeとして定義しているものの、モジュールのエクスポートリスト内でデータ構築子をエクスポートしないように注意する必要があります。</p>
<p>次に、属性値に<code>Name</code>を使えるよう、新しい型に<code>IsValue</code>型クラスのインスタンスを定義します。</p>
<pre><code class="language-haskell">instance IsValue Name where
  toValue (Name n) = n
</code></pre>
<p>また、次のように <code>a</code>要素に現れるハイパーリンク用の新しいデータ型を定義します。</p>
<pre><code class="language-haskell">data Href
  = URLHref String
  | AnchorHref Name

instance IsValue Href where
  toValue (URLHref url) = url
  toValue (AnchorHref (Name nm)) = &quot;#&quot; &lt;&gt; nm
</code></pre>
<p>この新しい型により、<code>href</code>属性の型の値を変更して、利用者にこの新しい <code>Href</code>型の使用を強制できます。
また、新しい<code>name</code>属性も作成でき、要素をアンカーに変換するのに使えます。</p>
<pre><code class="language-haskell">href :: AttributeKey Href
href = AttributeKey &quot;href&quot;

name :: AttributeKey Name
name = AttributeKey &quot;name&quot;
</code></pre>
<p>残っている問題は、現在モジュールの使用者が新しい名前を生成する方法がないということです。
<code>Content</code>モナドでこの機能を提供できます。まず、 <code>ContentF</code>型構築子に新しいデータ構築子を追加する必要があります。</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a
  | NewName (Name -&gt; a)
</code></pre>
<p><code>NewName</code>データ構築子は型<code>Name</code>の値を返す動作に対応しています。
データ構築子の引数として<code>Name</code>を要求するのではなく、型<code>Name -&gt; a</code>の<em>関数</em>を提供するように使用者に要求していることに注意してください。
型<code>a</code>は<em>計算の残り</em>を表していることを思い出すと、この関数は、型<code>Name</code>の値が返されたあとで、計算を継続する方法を提供しているのだとわかります。</p>
<p>新しいデータ構築子を考慮するよう、次のように<code>ContentF</code>用の<code>Functor</code>インスタンスを更新する必要もあります。</p>
<pre><code class="language-haskell">instance Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
  map f (NewName k) = NewName (f &lt;&lt;&lt; k)
</code></pre>
<p>これで、以前と同じように<code>liftF</code>関数を使って新しい動作を構築できます。</p>
<pre><code class="language-haskell">newName :: Content Name
newName = liftF $ NewName id
</code></pre>
<p><code>id</code>関数を継続として提供していることに注意してください。
つまり型<code>Name</code>の結果を変更せずに返しています。</p>
<p>最後に、新しい動作を解釈させるように解釈関数を更新する必要があります。
以前は計算を解釈するために<code>Writer String</code>モナドを使っていましたが、このモナドは新しい名前を生成できないので、何か他のものに切り替えなければなりません。
<code>WriterT</code>モナド変換子を<code>State</code>モナドと一緒に使うと、必要な作用を組み合わせられます。
型注釈が短く保たれるよう、この解釈モナドを型同義語として定義できます。</p>
<pre><code class="language-haskell">type Interp = WriterT String (State Int)
</code></pre>
<p>ここで、<code>Int</code>型の状態は増加していくカウンタとして振舞い、一意な名前を生成するのに使われます。</p>
<p><code>Writer</code>と<code>WriterT</code>モナドはそれらの動作を抽象化するのに同じ型クラスの構成要素を使うので、どの動作も変更する必要がありません。
必要なのは、<code>Writer String</code>への参照全てを<code>Interp</code>で置き換えることだけです。
しかし、計算に使われる制御子は変更する必要があります。
単なる<code>execWriter</code>の代わりに、<code>evalState</code>も使う必要があります。</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render e = evalState (execWriterT (renderElement e)) 0
</code></pre>
<p>また、新しい <code>NewName</code>データ構築子を解釈するために、 <code>renderContentItem</code>に新しい場合を追加しなければいけません。</p>
<pre><code class="language-haskell">renderContentItem (NewName k) = do
  n &lt;- get
  let fresh = Name $ &quot;name&quot; &lt;&gt; show n
  put $ n + 1
  pure (k fresh)
</code></pre>
<p>ここで、型 <code>Name -&gt; Content a</code>の継続 <code>k</code>が与えられているので、型 <code>Content a</code>の解釈を構築しなければいけません。
この解釈は単純です。
<code>get</code>を使って状態を読み、その状態を使って一意な名前を生成し、それから <code>put</code>で状態に1だけ足すのです。
最後に、継続にこの新しい名前を渡して、計算を完了します。</p>
<p>以上をもって、この新しい機能をPSCiで試せます。
これには<code>Content</code>モナドの内部で一意な名前を生成し、要素の名前とハイパーリンクのリンク先の両方として使います。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Name
&gt; import Effect.Console

&gt; :paste
… render $ p [ ] $ do
…   top &lt;- newName
…   elem $ a [ name := top ] $
…     text &quot;Top&quot;
…   elem $ a [ href := AnchorHref top ] $
…     text &quot;Back to top&quot;
… ^D

&lt;p&gt;&lt;a name=&quot;name0&quot;&gt;Top&lt;/a&gt;&lt;a href=&quot;#name0&quot;&gt;Back to top&lt;/a&gt;&lt;/p&gt;
unit
</code></pre>
<p>複数回の<code>newName</code>の呼び出しの結果が、実際に一意な名前になっていることも確かめられます。</p>
<h2 id="演習-51"><a class="header" href="#演習-51">演習</a></h2>
<ol>
<li>
<p>（普通）使用者から <code>Element</code>型を隠蔽すると、更にAPIを簡素にできます。
次の手順に従って、これらの変更を加えてください。</p>
<ul>
<li><code>p</code>や<code>img</code>のような（返る型が<code>Element</code>の）関数を<code>elem</code>動作と結合して、型<code>Content Unit</code>を返す新しい動作を作ってください。</li>
<li><code>Element</code>の代わりに型<code>Content Unit</code>の引数を受け付けるように<code>render</code>関数を変更してください。</li>
</ul>
</li>
<li>
<p>（普通）型同義語の代わりに<code>newtype</code>を使って<code>Content</code>モナドの実装を隠してください。
<code>newtype</code>用のデータ構築子はエクスポートすべきではありません。</p>
</li>
<li>
<p>（難しい）<code>ContentF</code>型を変更して以下の新しい動作に対応してください。</p>
<pre><code class="language-haskell">isMobile :: Content Boolean
</code></pre>
<p>この動作は、この文書がモバイルデバイス上での表示のために描画されているかどうかを示す真偽値を返します。</p>
<p><em>手掛かり</em>：<code>ask</code>動作と<code>ReaderT</code>モナド変換子を使って、この動作を解釈してください。
あるいは、<code>RWS</code>モナドを使うほうが好みの人もいるかもしれません。</p>
</li>
</ol>
<h2 id="まとめ-12"><a class="header" href="#まとめ-12">まとめ</a></h2>
<p>この章では、幾つかの標準的な技術を使って、素朴な実装を段階的に改善することにより、HTML文書を作成するための領域特化言語を開発しました。</p>
<ul>
<li><em>スマート構築子</em>を使ってデータ表現の詳細を隠し、利用者には<em>構築により正しい</em>文書だけを作ることを許しました。</li>
<li><em>独自に定義された中置2引数演算子</em>を使い、言語の構文を改善しました。</li>
<li><em>幻影型</em>を使ってデータの型の中に追加の情報を折り込みました。
これにより利用者が誤った型の属性値を与えることを防いでいます。</li>
<li><em>Freeモナド</em>を使って内容の集まりの配列表現をdo記法に対応したモナドな表現に変えました。
それからこの表現を新しいモナド動作に対応するよう拡張し、標準的なモナド変換子を使ってモナドの計算を解釈しました。</li>
</ul>
<p>これらの手法は全て、使用者が間違いを犯すのを防いだり領域特化言語の構文を改良したりするために、PureScriptのモジュールと型システムを活用しています。</p>
<p>関数型プログラミング言語による領域特化言語の実装は活発に研究されている分野です。
それでも、幾つかの単純な技法に対して役に立つ導入を提供し、表現力豊かな型を持つ言語で作業することの威力を示すことができていれば幸いです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>

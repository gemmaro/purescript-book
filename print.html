<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PureScript by Example</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.ja.html"><strong aria-hidden="true">15.</strong> Â∫èÊñá (Foreword)</a></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">16.</strong> Â∞éÂÖ•</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">17.</strong> „ÅØ„Åò„ÇÅ„Çà„ÅÜ</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">18.</strong> Èñ¢Êï∞„Å®„É¨„Ç≥„Éº„Éâ</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">19.</strong> ÂÜçÂ∏∞„ÄÅ„Éû„ÉÉ„Éó„ÄÅÁï≥„ÅøËæº„Åø</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html"><strong aria-hidden="true">20.</strong> „Éë„Çø„Éº„É≥ÁÖßÂêà</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html"><strong aria-hidden="true">21.</strong> Âûã„ÇØ„É©„Çπ</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">22.</strong> „Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">23.</strong> ‰ΩúÁî®„É¢„Éä„Éâ</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">24.</strong> ÈùûÂêåÊúü‰ΩúÁî®</a></li><li class="chapter-item expanded "><a href="chapter10.ja.html"><strong aria-hidden="true">25.</strong> Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ</a></li><li class="chapter-item expanded "><a href="chapter11.ja.html"><strong aria-hidden="true">26.</strong> „É¢„Éä„Éâ„Å™ÂÜíÈô∫</a></li><li class="chapter-item expanded "><a href="chapter12.ja.html"><strong aria-hidden="true">27.</strong> Canvas„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ</a></li><li class="chapter-item expanded "><a href="chapter13.ja.html"><strong aria-hidden="true">28.</strong> „ÉÜ„Çπ„Éà„ÅÆËá™ÂãïÁîüÊàê</a></li><li class="chapter-item expanded "><a href="chapter14.ja.html"><strong aria-hidden="true">29.</strong> È†òÂüüÁâπÂåñË®ÄË™û</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="purescript-by-example"><a class="header" href="#purescript-by-example">PureScript by Example</a></h1>
<p>This repository contains a <a href="https://github.com/purescript-contrib/purescript-book/">community fork</a> of <em>PureScript by Example</em> by Phil Freeman, also known as &quot;the PureScript book&quot;. This version differs from the original in that it has been updated so that the code and exercises work with up-to-date versions of the compiler, libraries, and tools. Some chapters have also been rewritten to showcase the latest features of the PureScript ecosystem.</p>
<p>If you enjoyed the book or found it useful, please consider buying a copy of <a href="https://leanpub.com/purescript">the original on Leanpub</a>.</p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<p>This book is being continuously updated as the language evolves, so please report any <a href="https://github.com/purescript-contrib/purescript-book/issues">issues</a> you discover with the material. We appreciate any feedback you have to share, even if it's as simple as pointing out a confusing section that we could make more beginner-friendly.</p>
<p>Unit tests are also being added to each chapter so you can check if your answers to the exercises are correct. See <a href="https://github.com/purescript-contrib/purescript-book/issues/79">#79</a> for the latest status on tests.</p>
<h2 id="about-the-book"><a class="header" href="#about-the-book">About the Book</a></h2>
<p>PureScript is a small, strongly, statically typed programming language with expressive types, written in and inspired by Haskell, and compiling to Javascript.</p>
<p>Functional programming in JavaScript has seen quite a lot of popularity recently, but large-scale application development is hindered by the lack of a disciplined environment in which to write code. PureScript aims to solve that problem by bringing the power of strongly-typed functional programming to the world of JavaScript development.</p>
<p>This book will show you how to get started with the PureScript programming language, from the basics (setting up a development environment) to the advanced.</p>
<p>Each chapter will be motivated by a particular problem, and in the course of solving that problem, new functional programming tools and techniques will be introduced. Here are some examples of problems that will be solved in this book:</p>
<ul>
<li>Transforming data structures with maps and folds</li>
<li>Form field validation using applicative functors</li>
<li>Testing code with QuickCheck</li>
<li>Using the canvas</li>
<li>Domain specific language implementation</li>
<li>Working with the DOM</li>
<li>JavaScript interoperability</li>
<li>Parallel asynchronous execution</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation Repo</a>, which uses the same license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various contributors</a>.</p>
<p>The exercises are licensed under the MIT license.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="functional-javascript"><a class="header" href="#functional-javascript">Functional JavaScript</a></h2>
<p>Functional programming techniques have been making appearances in JavaScript for some time now:</p>
<ul>
<li>
<p>Libraries such as <a href="https://underscorejs.org">UnderscoreJS</a> allow the developer to leverage tried-and-trusted functions such as <code>map</code>, <code>filter</code> and <code>reduce</code> to create larger programs from smaller programs by composition:</p>
<pre><code class="language-javascript">var sumOfPrimes =
    _.chain(_.range(1000))
     .filter(isPrime)
     .reduce(function(x, y) {
         return x + y;
     })
     .value();
</code></pre>
</li>
<li>
<p>Asynchronous programming in NodeJS leans heavily on functions as first-class values to define callbacks.</p>
<pre><code class="language-javascript">import { readFile, writeFile } from 'fs'

readFile(sourceFile, function (error, data) {
  if (!error) {
    writeFile(destFile, data, function (error) {
      if (!error) {
        console.log(&quot;File copied&quot;);
      }
    });
  }
});
</code></pre>
</li>
<li>
<p>Libraries such as <a href="https://reactjs.org">React</a> and <a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a> model views as pure functions of application state.</p>
</li>
</ul>
<p>Functions enable a simple form of abstraction which can yield great productivity gains. However, functional programming in JavaScript has its own disadvantages: JavaScript is verbose, untyped, and lacks powerful forms of abstraction. Unrestricted JavaScript code also makes equational reasoning very difficult.</p>
<p>PureScript is a programming language which aims to address these issues. It features lightweight syntax, which allows us to write very expressive code which is still clear and readable. It uses a rich type system to support powerful abstractions. It also generates fast, understandable code, which is important when interoperating with JavaScript, or other languages which compile to JavaScript. All in all, I hope to convince you that PureScript strikes a very practical balance between the theoretical power of purely functional programming, and the fast-and-loose programming style of JavaScript.</p>
<h2 id="types-and-type-inference"><a class="header" href="#types-and-type-inference">Types and Type Inference</a></h2>
<p>The debate over statically typed languages versus dynamically typed languages is well-documented. PureScript is a <em>statically typed</em> language, meaning that a correct program can be given a <em>type</em> by the compiler which indicates its behavior. Conversely, programs which cannot be given a type are <em>incorrect programs</em>, and will be rejected by the compiler. In PureScript, unlike in dynamically typed languages, types exist only at <em>compile-time</em>, and have no representation at runtime.</p>
<p>It is important to note that in many ways, the types in PureScript are unlike the types that you might have seen in other languages like Java or C#. While they serve the same purpose at a high level, the types in PureScript are inspired by languages like ML and Haskell. PureScript's types are expressive, allowing the developer to assert strong claims about their programs. Most importantly, PureScript's type system supports <em>type inference</em> - it requires far fewer explicit type annotations than other languages, making the type system a <em>tool</em> rather than a hindrance. As a simple example, the following code defines a <em>number</em>, but there is no mention of the <code>Number</code> type anywhere in the code:</p>
<pre><code class="language-haskell">iAmANumber =
  let square x = x * x
  in square 42.0
</code></pre>
<p>A more involved example shows that type-correctness can be confirmed without type annotations, even when there exist types which are <em>unknown to the compiler</em>:</p>
<pre><code class="language-haskell">iterate f 0 x = x
iterate f n x = iterate f (n - 1) (f x)
</code></pre>
<p>Here, the type of <code>x</code> is unknown, but the compiler can still verify that <code>iterate</code> obeys the rules of the type system, no matter what type <code>x</code> might have.</p>
<p>In this book, I will try to convince you (or reaffirm your belief) that static types are not only a means of gaining confidence in the correctness of your programs, but also an aid to development in their own right. Refactoring a large body of code in JavaScript can be difficult when using any but the simplest of abstractions, but an expressive type system together with a type checker can even make refactoring into an enjoyable, interactive experience.</p>
<p>In addition, the safety net provided by a type system enables more advanced forms of abstraction. In fact, PureScript provides a powerful form of abstraction which is fundamentally type-driven: type classes, made popular in the functional programming language Haskell.</p>
<h2 id="polyglot-web-programming"><a class="header" href="#polyglot-web-programming">Polyglot Web Programming</a></h2>
<p>Functional programming has its success stories - applications where it has been particularly successful: data analysis, parsing, compiler implementation, generic programming, parallelism, to name a few.</p>
<p>It would be possible to practice end-to-end application development in a functional language like PureScript. PureScript provides the ability to import existing JavaScript code, by providing types for its values and functions, and then to use those functions in regular PureScript code. We'll see this approach later in the book.</p>
<p>However, one of PureScript's strengths is its interoperability with other languages which target JavaScript. Another approach would be to use PureScript for a subset of your application's development, and to use one or more other languages to write the rest of the JavaScript.</p>
<p>Here are some examples:</p>
<ul>
<li>Core logic written in PureScript, with the user interface written in JavaScript.</li>
<li>Application written in JavaScript or another compile-to-JS language, with tests written in PureScript.</li>
<li>PureScript used to automate user interface tests for an existing application.</li>
</ul>
<p>In this book, we'll focus on solving small problems with PureScript. The solutions could be integrated into a larger application, but we will also look at how to call PureScript code from JavaScript, and vice versa.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>The software requirements for this book are minimal: the first chapter will guide you through setting up a development environment from scratch, and the tools we will use are available in the standard repositories of most modern operating systems.</p>
<p>The PureScript compiler itself can be downloaded as a binary distribution, or built from source on any system running an up-to-date installation of the GHC Haskell compiler, and we will walk through this process in the next chapter.</p>
<p>The code in this version of the book is compatible with versions <code>0.15.*</code> of
the PureScript compiler.</p>
<h2 id="about-you"><a class="header" href="#about-you">About You</a></h2>
<p>I will assume that you are familiar with the basics of JavaScript. Any prior familiarity with common tools from the JavaScript ecosystem, such as NPM and Gulp, will be beneficial if you wish to customize the standard setup to your own needs, but such knowledge is not necessary.</p>
<p>No prior knowledge of functional programming is required, but it certainly won't hurt. New ideas will be accompanied by practical examples, so you should be able to form an intuition for the concepts from functional programming that we will use.</p>
<p>Readers who are familiar with the Haskell programming language will recognize a lot of the ideas and syntax presented in this book, because PureScript is heavily influenced by Haskell. However, those readers should understand that there are a number of important differences between PureScript and Haskell. It is not necessarily always appropriate to try to apply ideas from one language in the other, although many of the concepts presented here will have some interpretation in Haskell.</p>
<h2 id="how-to-read-this-book"><a class="header" href="#how-to-read-this-book">How to Read This Book</a></h2>
<p>The chapters in this book are largely self contained. A beginner with little functional programming experience would be well-advised, however, to work through the chapters in order. The first few chapters lay the groundwork required to understand the material later on in the book. A reader who is comfortable with the ideas of functional programming (especially one with experience in a strongly-typed language like ML or Haskell) will probably be able to gain a general understanding of the code in the later chapters of the book without reading the preceding chapters.</p>
<p>Each chapter will focus on a single practical example, providing the motivation for any new ideas introduced. Code for each chapter are available from the book's <a href="https://github.com/purescript-contrib/purescript-book">GitHub repository</a>. Some chapters will include code snippets taken from the chapter's source code, but for a full understanding, you should read the source code from the repository alongside the material from the book. Longer sections will contain shorter snippets which you can execute in the interactive mode PSCi to test your understanding.</p>
<p>Code samples will appear in a monospaced font, as follows:</p>
<pre><code class="language-haskell">module Example where

import Effect.Console (log)

main = log &quot;Hello, World!&quot;
</code></pre>
<p>Commands which should be typed at the command line will be preceded by a dollar symbol:</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>Usually, these commands will be tailored to Linux/Mac OS users, so Windows users may need to make small changes such as modifying the file separator, or replacing shell built-ins with their Windows equivalents.</p>
<p>Commands which should be typed at the PSCi interactive mode prompt will be preceded by an angle bracket:</p>
<pre><code class="language-text">&gt; 1 + 2
3
</code></pre>
<p>Each chapter will contain exercises, labelled with their difficulty level. It is strongly recommended that you attempt the exercises in each chapter to fully understand the material.</p>
<p>This book aims to provide an introduction to the PureScript language for beginners, but it is not the sort of book that provides a list of template solutions to problems. For beginners, this book should be a fun challenge, and you will get the most benefit if you read the material, attempt the exercises, and most importantly of all, try to write some code of your own.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you get stuck at any point, there are a number of resources available online for learning PureScript:</p>
<ul>
<li>The <a href="https://discord.gg/vKn9up84bp">PureScript Discord server</a> is a great place to chat about issues you may be having. The server is dedicated to chat about PureScript</li>
<li>The <a href="https://discourse.purescript.org/">Purescript Discourse Forum</a> is another good place to search for solutions to common problems. Questions you ask here will be available to help future readers, whereas on Slack, message history is only kept for approximately 2 weeks.</li>
<li><a href="https://github.com/jordanmartinez/purescript-jordans-reference">PureScript: Jordan's Reference</a>  is an alternative learning resource that goes into great depth. If a concept in this book is difficult to understand, consider reading the corresponding section in that reference.</li>
<li><a href="https://pursuit.purescript.org">Pursuit</a> is a searchable database of PureScript types and functions. Read Pursuit's help page to <a href="https://pursuit.purescript.org/help/users">learn what kinds of searches you can do</a>.</li>
<li>The unofficial <a href="https://github.com/JordanMartinez/purescript-cookbook">PureScript Cookbook</a> provides answers via code to &quot;How do I do X?&quot;-type questions.</li>
<li>The <a href="https://github.com/purescript/documentation">PureScript documentation repository</a> collects articles and examples on a wide variety of topics, written by PureScript developers and users.</li>
<li>The <a href="https://www.purescript.org">PureScript website</a> contains links to several learning resources, including code samples, videos and other resources for beginners.</li>
<li><a href="https://try.purescript.org">Try PureScript!</a> is a website which allows users to compile PureScript code in the web browser, and contains several simple examples of code.</li>
</ul>
<p>If you prefer to learn by reading examples, the <code>purescript</code>, <code>purescript-node</code> and <code>purescript-contrib</code> GitHub organizations contain plenty of examples of PureScript code.</p>
<h2 id="about-the-author"><a class="header" href="#about-the-author">About the Author</a></h2>
<p>I am the original developer of the PureScript compiler. I'm based in Los Angeles, California, and started programming at an early age in BASIC on an 8-bit personal computer, the Amstrad CPC. Since then I have worked professionally in a variety of programming languages (including Java, Scala, C#, F#, Haskell and PureScript).</p>
<p>Not long into my professional career, I began to appreciate functional programming and its connections with mathematics, and enjoyed learning functional concepts using the Haskell programming language.</p>
<p>I started working on the PureScript compiler in response to my experience with JavaScript. I found myself using functional programming techniques that I had picked up in languages like Haskell, but wanted a more principled environment in which to apply them. Solutions at the time included various attempts to compile Haskell to JavaScript while preserving its semantics (Fay, Haste, GHCJS), but I was interested to see how successful I could be by approaching the problem from the other side - attempting to keep the semantics of JavaScript, while enjoying the syntax and type system of a language like Haskell.</p>
<p>I maintain <a href="https://blog.functorial.com">a blog</a>, and can be <a href="https://twitter.com/paf31">reached on Twitter</a>.</p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>I would like to thank the many contributors who helped PureScript to reach its current state. Without the huge collective effort which has been made on the compiler, tools, libraries, documentation and tests, the project would certainly have failed.</p>
<p>The PureScript logo which appears on the cover of this book was created by Gareth Hughes, and is gratefully reused here under the terms of the <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 license</a>.</p>
<p>Finally, I would like to thank everyone who has given me feedback and corrections on the contents of this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="chapter-goals"><a class="header" href="#chapter-goals">Chapter Goals</a></h2>
<p>In this chapter, we'll set up a working PureScript development environment, solve some exercises, and use the tests provided with this book to check our answers. You may also find a <a href="https://www.youtube.com/watch?v=GPjPwb6d-70">video walkthrough of this chapter</a> helpful if that better suits your learning style.</p>
<h2 id="environment-setup"><a class="header" href="#environment-setup">Environment Setup</a></h2>
<p>First, work through this <a href="https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md">Getting Started Guide</a> in the Documentation Repo to setup your environment and learn a few basics about the language. Don't worry if the code in the example solution to the <a href="http://projecteuler.net/problem=1">Project Euler</a> problem is confusing or contains unfamiliar syntax. We'll cover all of this in great detail in the upcoming chapters.</p>
<h2 id="solving-exercises"><a class="header" href="#solving-exercises">Solving Exercises</a></h2>
<p>Now that you've installed the necessary development tools, clone this book's repo.</p>
<pre><code class="language-sh">git clone https://github.com/purescript-contrib/purescript-book.git
</code></pre>
<p>The book repo contains PureScript example code and unit tests for the exercises that accompany each chapter. There's some initial setup required to reset the exercise solutions so they are ready to be solved by you. Use the <code>resetSolutions.sh</code> script to simplify this process. While you're at it, you should also strip out all the anchor comments with the <code>removeAnchors.sh</code> script (these anchors are used for copying code snippets into the book's rendered markdown, and you probably don't need this clutter in your local repo):</p>
<pre><code class="language-sh">cd purescript-book
./scripts/resetSolutions.sh
./scripts/removeAnchors.sh
git add .
git commit --all --message &quot;Exercises ready to be solved&quot;
</code></pre>
<p>Now run the tests for this chapter:</p>
<pre><code class="language-sh">cd exercises/chapter2
spago test
</code></pre>
<p>You should see the following successful test output:</p>
<pre><code class="language-sh">‚Üí Suite: Euler - Sum of Multiples
  ‚úì Passed: below 10
  ‚úì Passed: below 1000

All 2 tests passed! üéâ
</code></pre>
<p>Note that the <code>answer</code> function (found in <code>src/Euler.purs</code>) has been modified to find the multiples of 3 and 5 below any integer. The test suite (found in <code>test/Main.purs</code>) for this <code>answer</code> function is more comprehensive than the test in the earlier getting-started guide. Don't worry about understanding how this test framework code works while reading these early chapters.</p>
<p>The remainder of the book contains lots of exercises. If you write your solutions in the <code>Test.MySolutions</code> module (<code>test/MySolutions.purs</code>), you can check your work against the provided test suite.</p>
<p>Let's work through this next exercise together in test-driven-development style.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<ol>
<li>(Medium) Write a <code>diagonal</code> function to compute the length of the diagonal (or hypotenuse) of a right-angled triangle when given the lengths of the two other sides.</li>
</ol>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>We'll start by enabling the tests for this exercise. Move the start of the block-comment down a few lines as shown below. Block comments start with <code>{-</code> and end with <code>-}</code>:</p>
<pre><code class="language-hs">    suite &quot;diagonal&quot; do
      test &quot;3 4 5&quot; do
        Assert.equal 5.0 (diagonal 3.0 4.0)
      test &quot;5 12 13&quot; do
        Assert.equal 13.0 (diagonal 5.0 12.0)
    {-  Move this block comment starting point to enable more tests
</code></pre>
<p>If we attempt to run the test now, we'll encounter a compilation error because we have not yet implemented our <code>diagonal</code> function.</p>
<pre><code class="language-sh">$ spago test

Error found:
in module Test.Main
at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)

  Unknown value diagonal
</code></pre>
<p>Let's first take a look at what happens with a faulty version of this function. Add the following code to <code>test/MySolutions.purs</code>:</p>
<pre><code class="language-hs">import Data.Number (sqrt)

diagonal w h = sqrt (w * w + h)
</code></pre>
<p>And check our work by running <code>spago test</code>:</p>
<pre><code class="language-hs">‚Üí Suite: diagonal
  ‚ò† Failed: 3 4 5 because expected 5.0, got 3.605551275463989
  ‚ò† Failed: 5 12 13 because expected 13.0, got 6.082762530298219

2 tests failed:
</code></pre>
<p>Uh-oh, that's not quite right. Let's fix this with the correct application of the Pythagorean formula by changing the function to:</p>
<pre><code class="language-hs">diagonal w h = sqrt (w * w + h * h)
</code></pre>
<p>Trying <code>spago test</code> again now shows all tests are passing:</p>
<pre><code class="language-hs">‚Üí Suite: Euler - Sum of Multiples
  ‚úì Passed: below 10
  ‚úì Passed: below 1000
‚Üí Suite: diagonal
  ‚úì Passed: 3 4 5
  ‚úì Passed: 5 12 13

All 4 tests passed! üéâ
</code></pre>
<p>Success! Now you're ready to try these next exercises on your own.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>circleArea</code> which computes the area of a circle with a given radius. Use the <code>pi</code> constant, which is defined in the <code>Numbers</code> module. <em>Hint</em>: don't forget to import <code>pi</code> by modifying the <code>import Data.Number</code> statement.</li>
<li>(Medium) Write a function <code>leftoverCents</code> which takes an <code>Int</code> and returns what's leftover after dividing by <code>100</code>. Use the <code>rem</code> function. Search <a href="https://pursuit.purescript.org/">Pursuit</a> for this function to learn about usage and which module to import it from. <em>Note:</em> Your IDE may support auto-importing of this function if you accept the auto-completion suggestion.</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this chapter, we installed the PureScript compiler and the Spago tool. We also learned how to write solutions to exercises and check these for correctness.</p>
<p>There will be many more exercises in the chapters ahead, and working through those really helps with learning the material. If you're stumped by any of the exercises, please reach out to any of the community resources listed in the <a href="https://book.purescript.org/chapter1.html#getting-help">Getting Help</a> section of this book, or even file an issue in this <a href="https://github.com/purescript-contrib/purescript-book/issues">book's repo</a>. This reader feedback on which exercises could be made more approachable helps us improve the book.</p>
<p>Once you solve all the exercises in a chapter, you may compare your answers against those in the <code>no-peeking/Solutions.purs</code>. No peeking please without putting in an honest effort to solve these yourself though. And even if you are stuck, try asking a community member for help first, as we would prefer to give you a small hint rather than spoil the exercise. If you found a more elegant solution (that still only requires knowledge of covered content), please send us a PR.</p>
<p>The repo is continuously being revised, so be sure to check for updates before starting each new chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-and-records"><a class="header" href="#functions-and-records">Functions and Records</a></h1>
<h2 id="chapter-goals-1"><a class="header" href="#chapter-goals-1">Chapter Goals</a></h2>
<p>This chapter will introduce two building blocks of PureScript programs: functions and records. In addition, we'll see how to structure PureScript programs, and how to use types as an aid to program development.</p>
<p>We will build a simple address book application to manage a list of contacts. This code will introduce some new ideas from the syntax of PureScript.</p>
<p>The front-end of our application will be the interactive mode PSCi, but it would be possible to build on this code to write a front-end in JavaScript. In fact, we will do exactly that in later chapters, adding form validation and save/restore functionality.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The source code for this chapter is contained in the file <code>src/Data/AddressBook.purs</code>. This file starts with a module declaration and its import list:</p>
<pre><code class="language-haskell">module Data.AddressBook where

import Prelude

import Control.Plus (empty)
import Data.List (List(..), filter, head)
import Data.Maybe (Maybe)
</code></pre>
<p>Here, we import several modules:</p>
<ul>
<li>The <code>Control.Plus</code> module, which defines the <code>empty</code> value.</li>
<li>The <code>Data.List</code> module, which is provided by the <code>lists</code> package which can be installed using Spago. It contains a few functions which we will need for working with linked lists.</li>
<li>The <code>Data.Maybe</code> module, which defines data types and functions for working with optional values.</li>
</ul>
<p>Notice that the imports for these modules are listed explicitly in parentheses. This is generally a good practice, as it helps to avoid conflicting imports.</p>
<p>Assuming you have cloned the book's source code repository, the project for this chapter can be built using Spago, with the following commands:</p>
<pre><code class="language-text">$ cd chapter3
$ spago build
</code></pre>
<h2 id="simple-types"><a class="header" href="#simple-types">Simple Types</a></h2>
<p>PureScript defines three built-in types which correspond to JavaScript's primitive types: numbers, strings and booleans. These are defined in the <code>Prim</code> module, which is implicitly imported by every module. They are called <code>Number</code>, <code>String</code>, and <code>Boolean</code>, respectively, and you can see them in PSCi by using the <code>:type</code> command to print the types of some simple values:</p>
<pre><code class="language-text">$ spago repl

&gt; :type 1.0
Number

&gt; :type &quot;test&quot;
String

&gt; :type true
Boolean
</code></pre>
<p>PureScript defines some other built-in types: integers, characters, arrays, records, and functions.</p>
<p>Integers are differentiated from floating point values of type <code>Number</code> by the lack of a decimal point:</p>
<pre><code class="language-text">&gt; :type 1
Int
</code></pre>
<p>Character literals are wrapped in single quotes, unlike string literals which use double quotes:</p>
<pre><code class="language-text">&gt; :type 'a'
Char
</code></pre>
<p>Arrays correspond to JavaScript arrays, but unlike in JavaScript, all elements of a PureScript array must have the same type:</p>
<pre><code class="language-text">&gt; :type [1, 2, 3]
Array Int

&gt; :type [true, false]
Array Boolean

&gt; :type [1, false]
Could not match type Int with type Boolean.
</code></pre>
<p>The error in the last example is an error from the type checker, which unsuccessfully attempted to <em>unify</em> (i.e. make equal) the types of the two elements.</p>
<p>Records correspond to JavaScript's objects, and record literals have the same syntax as JavaScript's object literals:</p>
<pre><code class="language-text">&gt; author = { name: &quot;Phil&quot;, interests: [&quot;Functional Programming&quot;, &quot;JavaScript&quot;] }

&gt; :type author
{ name :: String
, interests :: Array String
}
</code></pre>
<p>This type indicates that the specified object has two <em>fields</em>, a <code>name</code> field which has type <code>String</code>, and an <code>interests</code> field, which has type <code>Array String</code>, i.e. an array of <code>String</code>s.</p>
<p>Fields of records can be accessed using a dot, followed by the label of the field to access:</p>
<pre><code class="language-text">&gt; author.name
&quot;Phil&quot;

&gt; author.interests
[&quot;Functional Programming&quot;,&quot;JavaScript&quot;]
</code></pre>
<p>PureScript's functions correspond to JavaScript's functions. The PureScript standard libraries provide plenty of examples of functions, and we will see more in this chapter:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c

&gt; :type const
forall a b. a -&gt; b -&gt; a
</code></pre>
<p>Functions can be defined at the top-level of a file by specifying arguments before the equals sign:</p>
<pre><code class="language-haskell">add :: Int -&gt; Int -&gt; Int
add x y = x + y
</code></pre>
<p>Alternatively, functions can be defined inline, by using a backslash character followed by a space-delimited list of argument names. To enter a multi-line declaration in PSCi, we can enter &quot;paste mode&quot; by using the <code>:paste</code> command. In this mode, declarations are terminated using the <em>Control-D</em> key sequence:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ add :: Int -&gt; Int -&gt; Int
‚Ä¶ add = \x y -&gt; x + y
‚Ä¶ ^D
</code></pre>
<p>Having defined this function in PSCi, we can <em>apply</em> it to its arguments by separating the two arguments from the function name by whitespace:</p>
<pre><code class="language-text">&gt; add 10 20
30
</code></pre>
<h2 id="quantified-types"><a class="header" href="#quantified-types">Quantified Types</a></h2>
<p>In the previous section, we saw the types of some functions defined in the Prelude. For example, the <code>flip</code> function had the following type:</p>
<pre><code class="language-text">&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</code></pre>
<p>The keyword <code>forall</code> here indicates that <code>flip</code> has a <em>universally quantified type</em>. It means that we can substitute any types for <code>a</code>, <code>b</code> and <code>c</code>, and <code>flip</code> will work with those types.</p>
<p>For example, we might choose the type <code>a</code> to be <code>Int</code>, <code>b</code> to be <code>String</code> and <code>c</code> to be <code>String</code>. In that case we could <em>specialize</em> the type of <code>flip</code> to</p>
<pre><code class="language-text">(Int -&gt; String -&gt; String) -&gt; String -&gt; Int -&gt; String
</code></pre>
<p>We don't have to indicate in code that we want to specialize a quantified type - it happens automatically. For example, we can just use <code>flip</code> as if it had this type already:</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) &quot;Ten&quot; 10

&quot;10Ten&quot;
</code></pre>
<p>While we can choose any types for <code>a</code>, <code>b</code> and <code>c</code>, we have to be consistent. The type of the function we passed to <code>flip</code> had to be consistent with the types of the other arguments. That is why we passed the string <code>&quot;Ten&quot;</code> as the second argument, and the number <code>10</code> as the third. It would not work if the arguments were reversed:</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) 10 &quot;Ten&quot;

Could not match type Int with type String
</code></pre>
<h2 id="notes-on-indentation"><a class="header" href="#notes-on-indentation">Notes On Indentation</a></h2>
<p>PureScript code is <em>indentation-sensitive</em>, just like Haskell, but unlike JavaScript. This means that the whitespace in your code is not meaningless, but rather is used to group regions of code, just like curly braces in C-like languages.</p>
<p>If a declaration spans multiple lines, then any lines except the first must be indented past the indentation level of the first line.</p>
<p>Therefore, the following is valid PureScript code:</p>
<pre><code class="language-haskell">add x y z = x +
  y + z
</code></pre>
<p>But this is not valid code:</p>
<pre><code class="language-haskell">add x y z = x +
y + z
</code></pre>
<p>In the second case, the PureScript compiler will try to parse <em>two</em> declarations, one for each line.</p>
<p>Generally, any declarations defined in the same block should be indented at the same level. For example, in PSCi, declarations in a let statement must be indented equally. This is valid:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ x = 1
‚Ä¶ y = 2
‚Ä¶ ^D
</code></pre>
<p>but this is not:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ x = 1
‚Ä¶  y = 2
‚Ä¶ ^D
</code></pre>
<p>Certain PureScript keywords (such as <code>where</code>, <code>of</code> and <code>let</code>) introduce a new block of code, in which declarations must be further-indented:</p>
<pre><code class="language-haskell">example x y z = foo + bar
  where
    foo = x * y
    bar = y * z
</code></pre>
<p>Note how the declarations for <code>foo</code> and <code>bar</code> are indented past the declaration of <code>example</code>.</p>
<p>The only exception to this rule is the <code>where</code> keyword in the initial <code>module</code> declaration at the top of a source file.</p>
<h2 id="defining-our-types"><a class="header" href="#defining-our-types">Defining Our Types</a></h2>
<p>A good first step when tackling a new problem in PureScript is to write out type definitions for any values you will be working with. First, let's define a type for records in our address book:</p>
<pre><code class="language-haskell">type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }
</code></pre>
<p>This defines a <em>type synonym</em> called <code>Entry</code> - the type <code>Entry</code> is equivalent to the type on the right of the equals symbol: a record type with three fields - <code>firstName</code>, <code>lastName</code> and <code>address</code>. The two name fields will have type <code>String</code>, and the <code>address</code> field will have type <code>Address</code>, defined as follows:</p>
<pre><code class="language-haskell">type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }
</code></pre>
<p>Note that records can contain other records.</p>
<p>Now let's define a third type synonym, for our address book data structure, which will be represented simply as a linked list of entries:</p>
<pre><code class="language-haskell">type AddressBook = List Entry
</code></pre>
<p>Note that <code>List Entry</code> is not the same as <code>Array Entry</code>, which represents an <em>array</em> of entries.</p>
<h2 id="type-constructors-and-kinds"><a class="header" href="#type-constructors-and-kinds">Type Constructors and Kinds</a></h2>
<p><code>List</code> is an example of a <em>type constructor</em>. Values do not have the type <code>List</code> directly, but rather <code>List a</code> for some type <code>a</code>. That is, <code>List</code> takes a <em>type argument</em> <code>a</code> and <em>constructs</em> a new type <code>List a</code>.</p>
<p>Note that just like function application, type constructors are applied to other types simply by juxtaposition: the type <code>List Entry</code> is in fact the type constructor <code>List</code> <em>applied</em> to the type <code>Entry</code> - it represents a list of entries.</p>
<p>If we try to incorrectly define a value of type <code>List</code> (by using the type annotation operator <code>::</code>), we will see a new type of error:</p>
<pre><code class="language-text">&gt; import Data.List
&gt; Nil :: List
In a type-annotated expression x :: t, the type t must have kind Type
</code></pre>
<p>This is a <em>kind error</em>. Just like values are distinguished by their <em>types</em>, types are distinguished by their <em>kinds</em>, and just like ill-typed values result in <em>type errors</em>, <em>ill-kinded</em> types result in <em>kind errors</em>.</p>
<p>There is a special kind called <code>Type</code> which represents the kind of all types which have values, like <code>Number</code> and <code>String</code>.</p>
<p>There are also kinds for type constructors. For example, the kind <code>Type -&gt; Type</code> represents a function from types to types, just like <code>List</code>. So the error here occurred because values are expected to have types with kind <code>Type</code>, but <code>List</code> has kind <code>Type -&gt; Type</code>.</p>
<p>To find out the kind of a type, use the <code>:kind</code> command in PSCi. For example:</p>
<pre><code class="language-text">&gt; :kind Number
Type

&gt; import Data.List
&gt; :kind List
Type -&gt; Type

&gt; :kind List String
Type
</code></pre>
<p>PureScript's <em>kind system</em> supports other interesting kinds, which we will see later in the book.</p>
<h2 id="displaying-address-book-entries"><a class="header" href="#displaying-address-book-entries">Displaying Address Book Entries</a></h2>
<p>Let's write our first function, which will render an address book entry as a string. We start by giving the function a type. This is optional, but good practice, since it acts as a form of documentation. In fact, the PureScript compiler will give a warning if a top-level declaration does not contain a type annotation. A type declaration separates the name of a function from its type with the <code>::</code> symbol:</p>
<pre><code class="language-haskell">showEntry :: Entry -&gt; String
</code></pre>
<p>This type signature says that <code>showEntry</code> is a function, which takes an <code>Entry</code> as an argument and returns a <code>String</code>. Here is the code for <code>showEntry</code>:</p>
<pre><code class="language-haskell">showEntry entry = entry.lastName &lt;&gt; &quot;, &quot; &lt;&gt;
                  entry.firstName &lt;&gt; &quot;: &quot; &lt;&gt;
                  showAddress entry.address
</code></pre>
<p>This function concatenates the three fields of the <code>Entry</code> record into a single string, using the <code>showAddress</code> function to turn the record inside the <code>address</code> field into a <code>String</code>. <code>showAddress</code> is defined similarly:</p>
<pre><code class="language-haskell">showAddress :: Address -&gt; String
showAddress addr = addr.street &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.city &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.state
</code></pre>
<p>A function definition begins with the name of the function, followed by a list of argument names. The result of the function is specified after the equals sign. Fields are accessed with a dot, followed by the field name. In PureScript, string concatenation uses the diamond operator (<code>&lt;&gt;</code>), instead of the plus operator like in JavaScript.</p>
<h2 id="test-early-test-often"><a class="header" href="#test-early-test-often">Test Early, Test Often</a></h2>
<p>The PSCi interactive mode allows for rapid prototyping with immediate feedback, so let's use it to verify that our first few functions behave as expected.</p>
<p>First, build the code you've written:</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>Next, load PSCi, and use the <code>import</code> command to import your new module:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.AddressBook
</code></pre>
<p>We can create an entry by using a record literal, which looks just like an anonymous object in JavaScript.</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>Now, try applying our function to the example:</p>
<pre><code class="language-text">&gt; showAddress address

&quot;123 Fake St., Faketown, CA&quot;
</code></pre>
<p>Let's also test <code>showEntry</code> by creating an address book entry record containing our example address:</p>
<pre><code class="language-text">&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; showEntry entry

&quot;Smith, John: 123 Fake St., Faketown, CA&quot;
</code></pre>
<h2 id="creating-address-books"><a class="header" href="#creating-address-books">Creating Address Books</a></h2>
<p>Now let's write some utility functions for working with address books. We will need a value which represents an empty address book: an empty list.</p>
<pre><code class="language-haskell">emptyBook :: AddressBook
emptyBook = empty
</code></pre>
<p>We will also need a function for inserting a value into an existing address book. We will call this function <code>insertEntry</code>. Start by giving its type:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>This type signature says that <code>insertEntry</code> takes an <code>Entry</code> as its first argument, and an <code>AddressBook</code> as a second argument, and returns a new <code>AddressBook</code>.</p>
<p>We don't modify the existing <code>AddressBook</code> directly. Instead, we return a new <code>AddressBook</code> which contains the same data. As such, <code>AddressBook</code> is an example of an <em>immutable data structure</em>. This is an important idea in PureScript - mutation is a side-effect of code, and inhibits our ability to reason effectively about its behavior, so we prefer pure functions and immutable data where possible.</p>
<p>To implement <code>insertEntry</code>, we can use the <code>Cons</code> function from <code>Data.List</code>. To see its type, open PSCi and use the <code>:type</code> command:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type Cons

forall a. a -&gt; List a -&gt; List a
</code></pre>
<p>This type signature says that <code>Cons</code> takes a value of some type <code>a</code>, and a list of elements of type <code>a</code>, and returns a new list with entries of the same type. Let's specialize this with <code>a</code> as our <code>Entry</code> type:</p>
<pre><code class="language-haskell">Entry -&gt; List Entry -&gt; List Entry
</code></pre>
<p>But <code>List Entry</code> is the same as <code>AddressBook</code>, so this is equivalent to</p>
<pre><code class="language-haskell">Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>In our case, we already have the appropriate inputs: an <code>Entry</code>, and an <code>AddressBook</code>, so can apply <code>Cons</code> and get a new <code>AddressBook</code>, which is exactly what we wanted!</p>
<p>Here is our implementation of <code>insertEntry</code>:</p>
<pre><code class="language-haskell">insertEntry entry book = Cons entry book
</code></pre>
<p>This brings the two arguments <code>entry</code> and <code>book</code> into scope, on the left hand side of the equals symbol, and then applies the <code>Cons</code> function to create the result.</p>
<h2 id="curried-functions"><a class="header" href="#curried-functions">Curried Functions</a></h2>
<p>Functions in PureScript take exactly one argument. While it looks like the <code>insertEntry</code> function takes two arguments, it is in fact an example of a <em>curried function</em>.</p>
<p>The <code>-&gt;</code> operator in the type of <code>insertEntry</code> associates to the right, which means that the compiler parses the type as</p>
<pre><code class="language-haskell">Entry -&gt; (AddressBook -&gt; AddressBook)
</code></pre>
<p>That is, <code>insertEntry</code> is a function which returns a function! It takes a single argument, an <code>Entry</code>, and returns a new function, which in turn takes a single <code>AddressBook</code> argument and returns a new <code>AddressBook</code>.</p>
<p>This means that we can <em>partially apply</em> <code>insertEntry</code> by specifying only its first argument, for example. In PSCi, we can see the result type:</p>
<pre><code class="language-text">&gt; :type insertEntry entry

AddressBook -&gt; AddressBook
</code></pre>
<p>As expected, the return type was a function. We can apply the resulting function to a second argument:</p>
<pre><code class="language-text">&gt; :type (insertEntry entry) emptyBook
AddressBook
</code></pre>
<p>Note though that the parentheses here are unnecessary - the following is equivalent:</p>
<pre><code class="language-text">&gt; :type insertEntry entry emptyBook
AddressBook
</code></pre>
<p>This is because function application associates to the left, and this explains why we can just specify function arguments one after the other, separated by whitespace.</p>
<p>The <code>-&gt;</code> operator in function types is a <em>type constructor</em> for functions. It takes two type arguments, the function's argument type and the return type. The left and right operands respectively.</p>
<p>Note that in the rest of the book, I will talk about things like &quot;functions of two arguments&quot;. However, it is to be understood that this means a curried function, taking a first argument and returning a function that takes the second.</p>
<p>Now consider the definition of <code>insertEntry</code>:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry book = Cons entry book
</code></pre>
<p>If we explicitly parenthesize the right-hand side, we get <code>(Cons entry) book</code>. That is, <code>insertEntry entry</code> is a function whose argument is just passed along to the <code>(Cons entry)</code> function. But if two functions have the same result for every input, then they are the same function! So we can remove the argument <code>book</code> from both sides:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry = Cons entry
</code></pre>
<p>But now, by the same argument, we can remove <code>entry</code> from both sides:</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry = Cons
</code></pre>
<p>This process is called <em>eta conversion</em>, and can be used (along with some other techniques) to rewrite functions in <em>point-free form</em>, which means functions defined without reference to their arguments.</p>
<p>In the case of <code>insertEntry</code>, <em>eta conversion</em> has resulted in a very clear definition of our function - &quot;<code>insertEntry</code> is just cons on lists&quot;. However, it is arguable whether point-free form is better in general.</p>
<h2 id="property-accessors"><a class="header" href="#property-accessors">Property Accessors</a></h2>
<p>One common pattern is to use a function to access individual fields (or &quot;properties&quot;) of a record. An inline function to extract an <code>Address</code> from an <code>Entry</code> could be written as:</p>
<pre><code class="language-haskell">\entry -&gt; entry.address
</code></pre>
<p>PureScript also allows <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#property-accessors"><em>property accessor</em></a> shorthand, where an underscore acts as the anonymous function argument, so the inline function above is equivalent to:</p>
<pre><code class="language-haskell">_.address
</code></pre>
<p>This works with any number of levels or properties, so a function to extract the city associated with an <code>Entry</code> could be written as:</p>
<pre><code class="language-haskell">_.address.city
</code></pre>
<p>For example:</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; _.lastName entry
&quot;Smith&quot;

&gt; _.address.city entry
&quot;Faketown&quot;
</code></pre>
<h2 id="querying-the-address-book"><a class="header" href="#querying-the-address-book">Querying the Address Book</a></h2>
<p>The last function we need to implement for our minimal address book application will look up a person by name and return the correct <code>Entry</code>. This will be a nice application of building programs by composing small functions - a key idea from functional programming.</p>
<p>We can first filter the address book, keeping only those entries with the correct first and last names. Then we can simply return the head (i.e. first) element of the resulting list.</p>
<p>With this high-level specification of our approach, we can calculate the type of our function. First open PSCi, and find the types of the <code>filter</code> and <code>head</code> functions:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type filter

forall a. (a -&gt; Boolean) -&gt; List a -&gt; List a

&gt; :type head

forall a. List a -&gt; Maybe a
</code></pre>
<p>Let's pick apart these two types to understand their meaning.</p>
<p><code>filter</code> is a curried function of two arguments. Its first argument is a function, which takes an element of the list and returns a <code>Boolean</code> value as a result. Its second argument is a list of elements, and the return value is another list.</p>
<p><code>head</code> takes a list as its argument, and returns a type we haven't seen before: <code>Maybe a</code>. <code>Maybe a</code> represents an optional value of type <code>a</code>, and provides a type-safe alternative to using <code>null</code> to indicate a missing value in languages like JavaScript. We will see it again in more detail in later chapters.</p>
<p>The universally quantified types of <code>filter</code> and <code>head</code> can be <em>specialized</em> by the PureScript compiler, to the following types:</p>
<pre><code class="language-haskell">filter :: (Entry -&gt; Boolean) -&gt; AddressBook -&gt; AddressBook

head :: AddressBook -&gt; Maybe Entry
</code></pre>
<p>We know that we will need to pass the first and last names that we want to search for, as arguments to our function.</p>
<p>We also know that we will need a function to pass to <code>filter</code>. Let's call this function <code>filterEntry</code>. <code>filterEntry</code> will have type <code>Entry -&gt; Boolean</code>. The application <code>filter filterEntry</code> will then have type <code>AddressBook -&gt; AddressBook</code>. If we pass the result of this function to the <code>head</code> function, we get our result of type <code>Maybe Entry</code>.</p>
<p>Putting these facts together, a reasonable type signature for our function, which we will call <code>findEntry</code>, is:</p>
<pre><code class="language-haskell">findEntry :: String -&gt; String -&gt; AddressBook -&gt; Maybe Entry
</code></pre>
<p>This type signature says that <code>findEntry</code> takes two strings, the first and last names, and a <code>AddressBook</code>, and returns an optional <code>Entry</code>. The optional result will contain a value only if the name is found in the address book.</p>
<p>And here is the definition of <code>findEntry</code>:</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -&gt; Boolean
    filterEntry entry = entry.firstName == firstName &amp;&amp; entry.lastName == lastName
</code></pre>
<p>Let's go over this code step by step.</p>
<p><code>findEntry</code> brings three names into scope: <code>firstName</code> and <code>lastName</code>, both representing strings, and <code>book</code>, an <code>AddressBook</code>.</p>
<p>The right hand side of the definition combines the <code>filter</code> and <code>head</code> functions: first, the list of entries is filtered, and the <code>head</code> function is applied to the result.</p>
<p>The predicate function <code>filterEntry</code> is defined as an auxiliary declaration inside a <code>where</code> clause. This way, the <code>filterEntry</code> function is available inside the definition of our function, but not outside it. Also, it can depend on the arguments to the enclosing function, which is essential here because <code>filterEntry</code> uses the <code>firstName</code> and <code>lastName</code> arguments to filter the specified <code>Entry</code>.</p>
<p>Note that, just like for top-level declarations, it was not necessary to specify a type signature for <code>filterEntry</code>. However, doing so is recommended as a form of documentation.</p>
<h2 id="infix-function-application"><a class="header" href="#infix-function-application">Infix Function Application</a></h2>
<p>Most of the functions discussed so far used <em>prefix</em> function application, where the function name was put <em>before</em> the arguments. For example, when using the <code>insertEntry</code> function to add an <code>Entry</code> (<code>john</code>) to an empty <code>AddressBook</code>, we might write:</p>
<pre><code class="language-haskell">&gt; book1 = insertEntry john emptyBook
</code></pre>
<p>However, this chapter has also included examples of <em>infix</em> <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#binary-operators">binary operators</a>, such as  the <code>==</code> operator in the definition of <code>filterEntry</code>, where the operator is put <em>between</em> the two arguments. These infix operators are actually defined in the PureScript source as infix aliases for their underlying <em>prefix</em> implementations. For example, <code>==</code> is defined as an infix alias for the prefix <code>eq</code> function with the line:</p>
<pre><code class="language-haskell">infix 4 eq as ==
</code></pre>
<p>and therefore <code>entry.firstName == firstName</code> in <code>filterEntry</code> could be replaced with the <code>eq entry.firstName firstName</code>. We'll cover a few more examples of defining infix operators later in this section.</p>
<p>There are situations where putting a prefix function in an infix position as an operator leads to more readable code. One example is the <code>mod</code> function:</p>
<pre><code class="language-text">&gt; mod 8 3
2
</code></pre>
<p>The above usage works fine, but is awkward to read. A more familiar phrasing is &quot;eight mod three&quot;, which you can achieve by wrapping a prefix function in backticks (`):</p>
<pre><code class="language-text">&gt; 8 `mod` 3
2
</code></pre>
<p>In the same way, wrapping <code>insertEntry</code> in backticks turns it into an infix operator, such that <code>book1</code> and <code>book2</code> below are equivalent:</p>
<pre><code class="language-haskell">book1 = insertEntry john emptyBook
book2 = john `insertEntry` emptyBook
</code></pre>
<p>We can make an <code>AddressBook</code> with multiple entries by using multiple applications of <code>insertEntry</code> as a prefix function (<code>book3</code>) or as an infix operator (<code>book4</code>) as shown below:</p>
<pre><code class="language-haskell">book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))
book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))
</code></pre>
<p>We can also define an infix operator alias (or synonym) for <code>insertEntry.</code> We'll arbitrarily choose <code>++</code> for this operator, give it a <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#precedence">precedence</a> of <code>5</code>, and make it right <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#associativity">associative</a> using <code>infixr</code>:</p>
<pre><code class="language-haskell">infixr 5 insertEntry as ++
</code></pre>
<p>This new operator lets us rewrite the above <code>book4</code> example as:</p>
<pre><code class="language-haskell">book5 = john ++ (peggy ++ (ned ++ emptyBook))
</code></pre>
<p>and the right associativity of our new <code>++</code> operator lets us get rid of the parentheses without changing the meaning:</p>
<pre><code class="language-haskell">book6 = john ++ peggy ++ ned ++ emptyBook
</code></pre>
<p>Another common technique for eliminating parens is to use <code>apply</code>'s infix operator <code>$</code>, along with your standard prefix functions.</p>
<p>For example, the earlier <code>book3</code> example could be rewritten as:</p>
<pre><code class="language-haskell">book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook
</code></pre>
<p>Substituting <code>$</code> for parens is usually easier to type and (arguably) easier to read. A mnemonic to remember the meaning of this symbol is to think of the dollar sign as being drawn from two parens that are also being crossed-out, suggesting the parens are now unnecessary.</p>
<p>Note that <code>$</code> isn't special syntax that's hardcoded into the language. It's simply the infix operator for a regular function called <code>apply</code>, which is defined in <code>Data.Function</code> as follows:</p>
<pre><code class="language-haskell">apply :: forall a b. (a -&gt; b) -&gt; a -&gt; b
apply f x = f x

infixr 0 apply as $
</code></pre>
<p>The <code>apply</code> function takes another function (of type <code>(a -&gt; b)</code>) as its first argument and a value (of type <code>a</code>) as its second argument, then calls that function with that value. If it seems like this function doesn't contribute anything meaningful, you are absolutely correct! Your program is logically identical without it (see <a href="https://en.wikipedia.org/wiki/Referential_transparency">referential transparency</a>). The syntactic utility of this function comes from the special properties assigned to its infix operator. <code>$</code> is a right-associative (<code>infixr</code>), low precedence (<code>0</code>) operator, which lets us remove sets of parentheses for deeply-nested applications.</p>
<p>Another parens-busting opportunity for the <code>$</code> operator is in our earlier <code>findEntry</code> function:</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head $ filter filterEntry book
</code></pre>
<p>We'll see an even more elegant way to rewrite this line with &quot;function composition&quot; in the next section.</p>
<p>If you'd like to use a concise infix operator alias as a prefix function, you can surround it in parentheses:</p>
<pre><code class="language-text">&gt; 8 + 3
11

&gt; (+) 8 3
11
</code></pre>
<p>Alternatively, operators can be partially applied by surrounding the expression with parentheses and using <code>_</code> as an operand in an <a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#operator-sections">operator section</a>. You can think of this as a more convenient way to create simple anonymous functions (although in the below example, we're then binding that anonymous function to a name, so it's not so anonymous anymore):</p>
<pre><code class="language-text">&gt; add3 = (3 + _)
&gt; add3 2
5
</code></pre>
<p>To summarize, the following are equivalent definitions of a function that adds <code>5</code> to its argument:</p>
<pre><code class="language-haskell">add5 x = 5 + x
add5 x = add 5 x
add5 x = (+) 5 x
add5 x = 5 `add` x
add5   = add 5
add5   = \x -&gt; 5 + x
add5   = (5 + _)
add5 x = 5 `(+)` x  -- Yo Dawg, I herd you like infix, so we put infix in your infix!
</code></pre>
<h2 id="function-composition"><a class="header" href="#function-composition">Function Composition</a></h2>
<p>Just like we were able to simplify the <code>insertEntry</code> function by using eta conversion, we can simplify the definition of <code>findEntry</code> by reasoning about its arguments.</p>
<p>Note that the <code>book</code> argument is passed to the <code>filter filterEntry</code> function, and the result of this application is passed to <code>head</code>. In other words, <code>book</code> is passed to the <em>composition</em> of the functions <code>filter filterEntry</code> and <code>head</code>.</p>
<p>In PureScript, the function composition operators are <code>&lt;&lt;&lt;</code> and <code>&gt;&gt;&gt;</code>. The first is &quot;backwards composition&quot;, and the second is &quot;forwards composition&quot;.</p>
<p>We can rewrite the right-hand side of <code>findEntry</code> using either operator. Using backwards-composition, the right-hand side would be</p>
<pre><code class="language-haskell">(head &lt;&lt;&lt; filter filterEntry) book
</code></pre>
<p>In this form, we can apply the eta conversion trick from earlier, to arrive at the final form of <code>findEntry</code>:</p>
<pre><code class="language-haskell">findEntry firstName lastName = head &lt;&lt;&lt; filter filterEntry
  where
    ...
</code></pre>
<p>An equally valid right-hand side would be:</p>
<pre><code class="language-haskell">filter filterEntry &gt;&gt;&gt; head
</code></pre>
<p>Either way, this gives a clear definition of the <code>findEntry</code> function: &quot;<code>findEntry</code> is the composition of a filtering function and the <code>head</code> function&quot;.</p>
<p>I will let you make your own decision which definition is easier to understand, but it is often useful to think of functions as building blocks in this way - each function executing a single task, and solutions assembled using function composition.</p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li>(Easy) Test your understanding of the <code>findEntry</code> function by writing down the types of each of its major subexpressions. For example, the type of the <code>head</code> function as used is specialized to <code>AddressBook -&gt; Maybe Entry</code>. <em>Note</em>: There is no test for this exercise.</li>
<li>(Medium) Write a function <code>findEntryByStreet :: String -&gt; AddressBook -&gt; Maybe Entry</code> which looks up an <code>Entry</code> given a street address. <em>Hint</em> reusing the existing code in <code>findEntry</code>. Test your function in PSCi and by running <code>spago test</code>.</li>
<li>(Medium) Rewrite <code>findEntryByStreet</code> to replace <code>filterEntry</code> with the composition (using <code>&lt;&lt;&lt;</code> or <code>&gt;&gt;&gt;</code>) of: a property accessor (using the <code>_.</code> notation); and a function that tests whether its given string argument is equal to the given street address.</li>
<li>(Medium) Write a function <code>isInBook</code> which tests whether a name appears in a <code>AddressBook</code>, returning a Boolean value. <em>Hint</em>: Use PSCi to find the type of the <code>Data.List.null</code> function, which tests whether a list is empty or not.</li>
<li>(Difficult) Write a function <code>removeDuplicates</code> which removes &quot;duplicate&quot; address book entries. We'll consider entries duplicated if they share the same first and last names, while ignoring <code>address</code> fields. <em>Hint</em>: Use PSCi to find the type of the <code>Data.List.nubByEq</code> function, which removes duplicate elements from a list based on an equality predicate. Note that the first element in each set of duplicates (closest to list head) is the one that is kept.</li>
</ol>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>In this chapter, we covered several new functional programming concepts:</p>
<ul>
<li>How to use the interactive mode PSCi to experiment with functions and test ideas.</li>
<li>The role of types as both a correctness tool, and an implementation tool.</li>
<li>The use of curried functions to represent functions of multiple arguments.</li>
<li>Creating programs from smaller components by composition.</li>
<li>Structuring code neatly using <code>where</code> expressions.</li>
<li>How to avoid null values by using the <code>Maybe</code> type.</li>
<li>Using techniques like eta conversion and function composition to refactor code into a clear specification.</li>
</ul>
<p>In the following chapters, we'll build on these ideas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion-maps-and-folds"><a class="header" href="#recursion-maps-and-folds">Recursion, Maps And Folds</a></h1>
<h2 id="chapter-goals-2"><a class="header" href="#chapter-goals-2">Chapter Goals</a></h2>
<p>In this chapter, we will look at how recursive functions can be used to structure algorithms. Recursion is a basic technique used in functional programming, which we will use throughout this book.</p>
<p>We will also cover some standard functions from PureScript's standard libraries. We will see the <code>map</code> and <code>fold</code> functions, as well as some useful special cases, like <code>filter</code> and <code>concatMap</code>.</p>
<p>The motivating example for this chapter is a library of functions for working with a virtual filesystem. We will apply the techniques learned in this chapter to write functions which compute properties of the files represented by a model of a filesystem.</p>
<h2 id="project-setup-1"><a class="header" href="#project-setup-1">Project Setup</a></h2>
<p>The source code for this chapter is contained in <code>src/Data/Path.purs</code> and <code>test/Examples.purs</code>. The <code>Data.Path</code> module contains a model of a virtual filesystem. You do not need to modify the contents of this module. Implement your solutions to the exercises in the <code>Test.MySolutions</code> module. Enable accompanying tests in the <code>Test.Main</code> module as you complete each exercise and check your work by running <code>spago test</code>.</p>
<p>The project has the following dependencies:</p>
<ul>
<li><code>maybe</code>, which defines the <code>Maybe</code> type constructor</li>
<li><code>arrays</code>, which defines functions for working with arrays</li>
<li><code>strings</code>, which defines functions for working with JavaScript strings</li>
<li><code>foldable-traversable</code>, which defines functions for folding arrays and other data structures</li>
<li><code>console</code>, which defines functions for printing to the console</li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Recursion is an important technique in programming in general, but particularly common in pure functional programming, because, as we will see in this chapter, recursion helps to reduce the mutable state in our programs.</p>
<p>Recursion is closely linked to the <em>divide and conquer</em> strategy: to solve a problem on certain inputs, we can break down the inputs into smaller parts, solve the problem on those parts, and then assemble a solution from the partial solutions.</p>
<p>Let's see some simple examples of recursion in PureScript.</p>
<p>Here is the usual <em>factorial function</em> example:</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n =
  if n == 0 then
    1
  else
    n * factorial (n - 1)
</code></pre>
<p>Here, we can see how the factorial function is computed by reducing the problem to a subproblem - that of computing the factorial of a smaller integer. When we reach zero, the answer is immediate.</p>
<p>Here is another common example, which computes the <em>Fibonacci function</em>:</p>
<pre><code class="language-haskell">fib :: Int -&gt; Int
fib n =
  if n == 0 then
    0
  else if n == 1 then
    1
  else
    fib (n - 1) + fib (n - 2)
</code></pre>
<p>Again, this problem is solved by considering the solutions to subproblems. In this case, there are two subproblems, corresponding to the expressions <code>fib (n - 1)</code> and <code>fib (n - 2)</code>. When these two subproblems are solved, we assemble the result by adding the partial results.</p>
<p>Note that, while the above examples of <code>factorial</code> and <code>fib</code> work as intended, a more idiomatic implementation would use pattern matching instead of <code>if</code>/<code>then</code>/<code>else</code>. Pattern matching techniques are discussed in a later chapter.</p>
<h2 id="recursion-on-arrays"><a class="header" href="#recursion-on-arrays">Recursion on Arrays</a></h2>
<p>We are not limited to defining recursive functions over the <code>Int</code> type! We will see recursive functions defined over a wide array of data types when we cover <em>pattern matching</em> later in the book, but for now, we will restrict ourselves to numbers and arrays.</p>
<p>Just as we branch based on whether the input is non-zero, in the array case, we will branch based on whether the input is non-empty. Consider this function, which computes the length of an array using recursion:</p>
<pre><code class="language-haskell">import Prelude

import Data.Array (null, tail)
import Data.Maybe (fromMaybe)

length :: forall a. Array a -&gt; Int
length arr =
  if null arr then
    0
  else
    1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>In this function, we use an <code>if .. then .. else</code> expression to branch based on the emptiness of the array. The <code>null</code> function returns <code>true</code> on an empty array. Empty arrays have length zero, and a non-empty array has a length that is one more than the length of its tail.</p>
<p>The <code>tail</code> function returns a <code>Maybe</code> wrapping the given array without its first element. If the array is empty (i.e. it doesn't have a tail) <code>Nothing</code> is returned. The <code>fromMaybe</code> function takes a default value and a <code>Maybe</code> value. If the latter is <code>Nothing</code> it returns the default, in the other case it returns the value wrapped by <code>Just</code>.</p>
<p>This example is obviously a very impractical way to find the length of an array in JavaScript, but should provide enough help to allow you to complete the following exercises:</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li>(Easy) Write a recursive function <code>isEven</code> which returns <code>true</code> if and only if its input is an even integer.</li>
<li>(Medium) Write a recursive function <code>countEven</code> which counts the number of even integers in an array. <em>Hint</em>: the function <code>head</code> (also available in <code>Data.Array</code>) can be used to find the first element in a non-empty array.</li>
</ol>
<h2 id="maps"><a class="header" href="#maps">Maps</a></h2>
<p>The <code>map</code> function is an example of a recursive function on arrays. It is used to transform the elements of an array by applying a function to each element in turn. Therefore, it changes the <em>contents</em> of the array, but preserves its <em>shape</em> (i.e. its length).</p>
<p>When we cover <em>type classes</em> later in the book we will see that the <code>map</code> function is an example of a more general pattern of shape-preserving functions which transform a class of type constructors called <em>functors</em>.</p>
<p>Let's try out the <code>map</code> function in PSCi:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; map (\n -&gt; n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>Notice how <code>map</code> is used - we provide a function which should be &quot;mapped over&quot; the array in the first argument, and the array itself in its second.</p>
<h2 id="infix-operators"><a class="header" href="#infix-operators">Infix Operators</a></h2>
<p>The <code>map</code> function can also be written between the mapping function and the array, by wrapping the function name in backticks:</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) `map` [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>This syntax is called <em>infix function application</em>, and any function can be made infix in this way. It is usually most appropriate for functions with two arguments.</p>
<p>There is an operator which is equivalent to the <code>map</code> function when used with arrays, called <code>&lt;$&gt;</code>. This operator can be used infix like any other binary operator:</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) &lt;$&gt; [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>Let's look at the type of <code>map</code>:</p>
<pre><code class="language-text">&gt; :type map
forall a b f. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The type of <code>map</code> is actually more general than we need in this chapter. For our purposes, we can treat <code>map</code> as if it had the following less general type:</p>
<pre><code class="language-text">forall a b. (a -&gt; b) -&gt; Array a -&gt; Array b
</code></pre>
<p>This type says that we can choose any two types, <code>a</code> and <code>b</code>, with which to apply the <code>map</code> function. <code>a</code> is the type of elements in the source array, and <code>b</code> is the type of elements in the target array. In particular, there is no reason why <code>map</code> has to preserve the type of the array elements. We can use <code>map</code> or <code>&lt;$&gt;</code> to transform integers to strings, for example:</p>
<pre><code class="language-text">&gt; show &lt;$&gt; [1, 2, 3, 4, 5]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>Even though the infix operator <code>&lt;$&gt;</code> looks like special syntax, it is in fact just an alias for a regular PureScript function. The function is simply <em>applied</em> using infix syntax. In fact, the function can be used like a regular function by enclosing its name in parentheses. This means that we can used the parenthesized name <code>(&lt;$&gt;)</code> in place of <code>map</code> on arrays:</p>
<pre><code class="language-text">&gt; (&lt;$&gt;) show [1, 2, 3, 4, 5]
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>Infix function names are defined as <em>aliases</em> for existing function names. For example, the <code>Data.Array</code> module defines an infix operator <code>(..)</code> as a synonym for the <code>range</code> function, as follows:</p>
<pre><code class="language-haskell">infix 8 range as ..
</code></pre>
<p>We can use this operator as follows:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; 1 .. 5
[1, 2, 3, 4, 5]

&gt; show &lt;$&gt; (1 .. 5)
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p><em>Note</em>: Infix operators can be a great tool for defining domain-specific languages with a natural syntax. However, used excessively, they can render code unreadable to beginners, so it is wise to exercise caution when defining any new operators.</p>
<p>In the example above, we parenthesized the expression <code>1 .. 5</code>, but this was actually not necessary, because the <code>Data.Array</code> module assigns a higher precedence level to the <code>..</code> operator than that assigned to the <code>&lt;$&gt;</code> operator. In the example above, the precedence of the <code>..</code> operator was defined as <code>8</code>, the number after the <code>infix</code> keyword. This is higher than the precedence level of <code>&lt;$&gt;</code>, meaning that we do not need to add parentheses:</p>
<pre><code class="language-text">&gt; show &lt;$&gt; 1 .. 5
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>If we wanted to assign an <em>associativity</em> (left or right) to an infix operator, we could do so with the <code>infixl</code> and <code>infixr</code> keywords instead.  Using <code>infix</code> assigns no associativity, meaning that you must parenthesize any expression using the same operator multiple times or using multiple operators of the same precedence.</p>
<h2 id="filtering-arrays"><a class="header" href="#filtering-arrays">Filtering Arrays</a></h2>
<p>The <code>Data.Array</code> module provides another function <code>filter</code>, which is commonly used together with <code>map</code>. It provides the ability to create a new array from an existing array, keeping only those elements which match a predicate function.</p>
<p>For example, suppose we wanted to compute an array of all numbers between 1 and 10 which were even. We could do so as follows:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; filter (\n -&gt; n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
</code></pre>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>squared</code> which calculates the squares of an array of numbers. <em>Hint</em>: Use the <code>map</code> or <code>&lt;$&gt;</code> function.</li>
<li>(Easy) Write a function <code>keepNonNegative</code> which removes the negative numbers from an array of numbers. <em>Hint</em>: Use the <code>filter</code> function.</li>
<li>(Medium)
<ul>
<li>Define an infix synonym <code>&lt;$?&gt;</code> for <code>filter</code>. <em>Note</em>: Infix synonyms may not be defined in the REPL, but you can define it in a file.</li>
<li>Write a <code>keepNonNegativeRewrite</code> function, which is the same as <code>keepNonNegative</code>, but replaces <code>filter</code> with your new infix operator <code>&lt;$?&gt;</code>.</li>
<li>Experiment with the precedence level and associativity of your operator in PSCi. <em>Note</em>: There are no unit tests for this step.</li>
</ul>
</li>
</ol>
<h2 id="flattening-arrays"><a class="header" href="#flattening-arrays">Flattening Arrays</a></h2>
<p>Another standard function on arrays is the <code>concat</code> function, defined in <code>Data.Array</code>. <code>concat</code> flattens an array of arrays into a single array:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concat
forall a. Array (Array a) -&gt; Array a

&gt; concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>There is a related function called <code>concatMap</code> which is like a combination of the <code>concat</code> and <code>map</code> functions. Where <code>map</code> takes a function from values to values (possibly of a different type), <code>concatMap</code> takes a function from values to arrays of values.</p>
<p>Let's see it in action:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concatMap
forall a b. (a -&gt; Array b) -&gt; Array a -&gt; Array b

&gt; concatMap (\n -&gt; [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
</code></pre>
<p>Here, we call <code>concatMap</code> with the function <code>\n -&gt; [n, n * n]</code> which sends an integer to the array of two elements consisting of that integer and its square. The result is an array of ten integers: the integers from 1 to 5 along with their squares.</p>
<p>Note how <code>concatMap</code> concatenates its results. It calls the provided function once for each element of the original array, generating an array for each. Finally, it collapses all of those arrays into a single array, which is its result.</p>
<p><code>map</code>, <code>filter</code> and <code>concatMap</code> form the basis for a whole range of functions over arrays called &quot;array comprehensions&quot;.</p>
<h2 id="array-comprehensions"><a class="header" href="#array-comprehensions">Array Comprehensions</a></h2>
<p>Suppose we wanted to find the factors of a number <code>n</code>. One simple way to do this would be by brute force: we could generate all pairs of numbers between 1 and <code>n</code>, and try multiplying them together. If the product was <code>n</code>, we would have found a pair of factors of <code>n</code>.</p>
<p>We can perform this computation using an array comprehension. We will do so in steps, using PSCi as our interactive development environment.</p>
<p>The first step is to generate an array of pairs of numbers below <code>n</code>, which we can do using <code>concatMap</code>.</p>
<p>Let's start by mapping each number to the array <code>1 .. n</code>:</p>
<pre><code class="language-text">&gt; pairs n = concatMap (\i -&gt; 1 .. n) (1 .. n)
</code></pre>
<p>We can test our function</p>
<pre><code class="language-text">&gt; pairs 3
[1,2,3,1,2,3,1,2,3]
</code></pre>
<p>This is not quite what we want. Instead of just returning the second element of each pair, we need to map a function over the inner copy of <code>1 .. n</code> which will allow us to keep the entire pair:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ pairs' n =
‚Ä¶   concatMap (\i -&gt;
‚Ä¶     map (\j -&gt; [i, j]) (1 .. n)
‚Ä¶   ) (1 .. n)
‚Ä¶ ^D

&gt; pairs' 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
</code></pre>
<p>This is looking better. However, we are generating too many pairs: we keep both [1, 2] and [2, 1] for example. We can exclude the second case by making sure that <code>j</code> only ranges from <code>i</code> to <code>n</code>:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ pairs'' n =
‚Ä¶   concatMap (\i -&gt;
‚Ä¶     map (\j -&gt; [i, j]) (i .. n)
‚Ä¶   ) (1 .. n)
‚Ä¶ ^D
&gt; pairs'' 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
</code></pre>
<p>Great! Now that we have all of the pairs of potential factors, we can use <code>filter</code> to choose the pairs which multiply to give <code>n</code>:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; factors n = filter (\pair -&gt; product pair == n) (pairs'' n)

&gt; factors 10
[[1,10],[2,5]]
</code></pre>
<p>This code uses the <code>product</code> function from the <code>Data.Foldable</code> module in the <code>foldable-traversable</code> library.</p>
<p>Excellent! We've managed to find the correct set of factor pairs without duplicates.</p>
<h2 id="do-notation"><a class="header" href="#do-notation">Do Notation</a></h2>
<p>However, we can improve the readability of our code considerably. <code>map</code> and <code>concatMap</code> are so fundamental, that they (or rather, their generalizations <code>map</code> and <code>bind</code>) form the basis of a special syntax called <em>do notation</em>.</p>
<p><em>Note</em>: Just like <code>map</code> and <code>concatMap</code> allowed us to write <em>array comprehensions</em>, the more general operators <code>map</code> and <code>bind</code> allow us to write so-called <em>monad comprehensions</em>. We'll see plenty more examples of <em>monads</em> later in the book, but in this chapter, we will only consider arrays.</p>
<p>We can rewrite our <code>factors</code> function using do notation as follows:</p>
<pre><code class="language-haskell">factors :: Int -&gt; Array (Array Int)
factors n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  pure [ i, j ]
</code></pre>
<p>The keyword <code>do</code> introduces a block of code which uses do notation. The block consists of expressions of a few types:</p>
<ul>
<li>Expressions which bind elements of an array to a name. These are indicated with the backwards-facing arrow <code>&lt;-</code>, with a name on the left, and an expression on the right whose type is an array.</li>
<li>Expressions which do not bind elements of the array to names. The <code>do</code> <em>result</em> is an example of this kind of expression and is illustrated in the last line, <code>pure [i, j]</code>.</li>
<li>Expressions which give names to expressions, using the <code>let</code> keyword.</li>
</ul>
<p>This new notation hopefully makes the structure of the algorithm clearer. If you mentally replace the arrow <code>&lt;-</code> with the word &quot;choose&quot;, you might read it as follows: &quot;choose an element <code>i</code> between 1 and n, then choose an element <code>j</code> between <code>i</code> and <code>n</code>, and return <code>[i, j]</code>&quot;.</p>
<p>In the last line, we use the <code>pure</code> function. This function can be evaluated in PSCi, but we have to provide a type:</p>
<pre><code class="language-text">&gt; pure [1, 2] :: Array (Array Int)
[[1, 2]]
</code></pre>
<p>In the case of arrays, <code>pure</code> simply constructs a singleton array. In fact, we could modify our <code>factors</code> function to use this form, instead of using <code>pure</code>:</p>
<pre><code class="language-haskell">factorsV2 :: Int -&gt; Array (Array Int)
factorsV2 n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  [ [ i, j ] ]
</code></pre>
<p>and the result would be the same.</p>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<p>One further change we can make to the <code>factors</code> function is to move the filter inside the array comprehension. This is possible using the <code>guard</code> function from the <code>Control.Alternative</code> module (from the <code>control</code> package):</p>
<pre><code class="language-haskell">import Control.Alternative (guard)

factorsV3 :: Int -&gt; Array (Array Int)
factorsV3 n = do
  i &lt;- 1 .. n
  j &lt;- i .. n
  guard $ i * j == n
  pure [ i, j ]
</code></pre>
<p>Just like <code>pure</code>, we can apply the <code>guard</code> function in PSCi to understand how it works. The type of the <code>guard</code> function is more general than we need here:</p>
<pre><code class="language-text">&gt; import Control.Alternative

&gt; :type guard
forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p>In our case, we can assume that PSCi reported the following type:</p>
<pre><code class="language-haskell">Boolean -&gt; Array Unit
</code></pre>
<p>For our purposes, the following calculations tell us everything we need to know about the <code>guard</code> function on arrays:</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; length $ guard true
1

&gt; length $ guard false
0
</code></pre>
<p>That is, if <code>guard</code> is passed an expression which evaluates to <code>true</code>, then it returns an array with a single element. If the expression evaluates to <code>false</code>, then its result is empty.</p>
<p>This means that if the guard fails, then the current branch of the array comprehension will terminate early with no results. This means that a call to <code>guard</code> is equivalent to using <code>filter</code> on the intermediate array. Depending on the application, you might prefer to use <code>guard</code> instead of a <code>filter</code>. Try the two definitions of <code>factors</code> to verify that they give the same results.</p>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>isPrime</code> which tests if its integer argument is prime or not. <em>Hint</em>: Use the <code>factors</code> function.</li>
<li>(Medium) Write a function <code>cartesianProduct</code> which uses do notation to find the <em>cartesian product</em> of two arrays, i.e. the set of all pairs of elements <code>a</code>, <code>b</code>, where <code>a</code> is an element of the first array, and <code>b</code> is an element of the second.</li>
<li>(Medium) Write a function <code>triples :: Int -&gt; Array (Array Int)</code> which takes a number <code>n</code> and returns all Pythagorean triples whose components (the <code>a</code>, <code>b</code> and <code>c</code> values) are each less than or equal to <code>n</code>. A <em>Pythagorean triple</em> is an array of numbers <code>[a, b, c]</code> such that <code>a¬≤ + b¬≤ = c¬≤</code>. <em>Hint</em>: Use the <code>guard</code> function in an array comprehension.</li>
<li>(Difficult) Write a function <code>primeFactors</code> which produces the <a href="https://www.mathsisfun.com/prime-factorization.html">prime factorization</a> of <code>n</code>, i.e. the array of prime integers whose product is <code>n</code>. <em>Hint</em>: for an integer greater than 1, break the problem down into two subproblems: finding the first factor, and finding the remaining factors.</li>
</ol>
<h2 id="folds"><a class="header" href="#folds">Folds</a></h2>
<p>Left and right folds over arrays provide another class of interesting functions which can be implemented using recursion.</p>
<p>Start by importing the <code>Data.Foldable</code> module, and inspecting the types of the <code>foldl</code> and <code>foldr</code> functions using PSCi:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :type foldl
forall a b f. Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b

&gt; :type foldr
forall a b f. Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
</code></pre>
<p>These types are actually more general than we are interested in right now. For the purposes of this chapter, we can assume that PSCi had given the following (more specific) answer:</p>
<pre><code class="language-text">&gt; :type foldl
forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Array a -&gt; b

&gt; :type foldr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Array a -&gt; b
</code></pre>
<p>In both of these cases, the type <code>a</code> corresponds to the type of elements of our array. The type <code>b</code> can be thought of as the type of an &quot;accumulator&quot;, which will accumulate a result as we traverse the array.</p>
<p>The difference between the <code>foldl</code> and <code>foldr</code> functions is the direction of the traversal. <code>foldl</code> folds the array &quot;from the left&quot;, whereas <code>foldr</code> folds the array &quot;from the right&quot;.</p>
<p>Let's see these functions in action. Let's use <code>foldl</code> to sum an array of integers. The type <code>a</code> will be <code>Int</code>, and we can also choose the result type <code>b</code> to be <code>Int</code>. We need to provide three arguments: a function <code>Int -&gt; Int -&gt; Int</code>, which will add the next element to the accumulator, an initial value for the accumulator of type <code>Int</code>, and an array of <code>Int</code>s to add. For the first argument, we can just use the addition operator, and the initial value of the accumulator will be zero:</p>
<pre><code class="language-text">&gt; foldl (+) 0 (1 .. 5)
15
</code></pre>
<p>In this case, it didn't matter whether we used <code>foldl</code> or <code>foldr</code>, because the result is the same, no matter what order the additions happen in:</p>
<pre><code class="language-text">&gt; foldr (+) 0 (1 .. 5)
15
</code></pre>
<p>Let's write an example where the choice of folding function does matter, in order to illustrate the difference. Instead of the addition function, let's use string concatenation to build a string:</p>
<pre><code class="language-text">&gt; foldl (\acc n -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;12345&quot;

&gt; foldr (\n acc -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;54321&quot;
</code></pre>
<p>This illustrates the difference between the two functions. The left fold expression is equivalent to the following application:</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 1) &lt;&gt; show 2) &lt;&gt; show 3) &lt;&gt; show 4) &lt;&gt; show 5)
</code></pre>
<p>whereas the right fold is equivalent to this:</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 5) &lt;&gt; show 4) &lt;&gt; show 3) &lt;&gt; show 2) &lt;&gt; show 1)
</code></pre>
<h2 id="tail-recursion"><a class="header" href="#tail-recursion">Tail Recursion</a></h2>
<p>Recursion is a powerful technique for specifying algorithms, but comes with a problem: evaluating recursive functions in JavaScript can lead to stack overflow errors if our inputs are too large.</p>
<p>It is easy to verify this problem, with the following code in PSCi:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ f n =
‚Ä¶   if n == 0
‚Ä¶     then 0
‚Ä¶     else 1 + f (n - 1)
‚Ä¶ ^D

&gt; f 10
10

&gt; f 100000
RangeError: Maximum call stack size exceeded
</code></pre>
<p>This is a problem. If we are going to adopt recursion as a standard technique from functional programming, then we need a way to deal with possibly unbounded recursion.</p>
<p>PureScript provides a partial solution to this problem in the form of <em>tail recursion optimization</em>.</p>
<p><em>Note</em>: more complete solutions to the problem can be implemented in libraries using so-called <em>trampolining</em>, but that is beyond the scope of this chapter. The interested reader can consult the documentation for the <a href="https://pursuit.purescript.org/packages/purescript-free"><code>free</code></a> and <a href="https://pursuit.purescript.org/packages/purescript-tailrec"><code>tailrec</code></a> packages.</p>
<p>The key observation which enables tail recursion optimization is the following: a recursive call in <em>tail position</em> to a function can be replaced with a <em>jump</em>, which does not allocate a stack frame. A call is in <em>tail position</em> when it is the last call made before a function returns. This is the reason why we observed a stack overflow in the example - the recursive call to <code>f</code> was <em>not</em> in tail position.</p>
<p>In practice, the PureScript compiler does not replace the recursive call with a jump, but rather replaces the entire recursive function with a <em>while loop</em>.</p>
<p>Here is an example of a recursive function with all recursive calls in tail position:</p>
<pre><code class="language-haskell">factorialTailRec :: Int -&gt; Int -&gt; Int
factorialTailRec n acc =
  if n == 0
    then acc
    else factorialTailRec (n - 1) (acc * n)
</code></pre>
<p>Notice that the recursive call to <code>factorialTailRec</code> is the last thing that happens in this function - it is in tail position.</p>
<h2 id="accumulators"><a class="header" href="#accumulators">Accumulators</a></h2>
<p>One common way to turn a function which is not tail recursive into a tail recursive function is to use an <em>accumulator parameter</em>. An accumulator parameter is an additional parameter which is added to a function which <em>accumulates</em> a return value, as opposed to using the return value to accumulate the result.</p>
<p>For example, consider again the <code>length</code> function presented in the beginning of the chapter:</p>
<pre><code class="language-haskell">length :: forall a. Array a -&gt; Int
length arr =
  if null arr
    then 0
    else 1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>This implementation is not tail recursive, so the generated JavaScript will cause a stack overflow when executed on a large input array. However, we can make it tail recursive, by introducing a second function argument to accumulate the result instead:</p>
<pre><code class="language-haskell">lengthTailRec :: forall a. Array a -&gt; Int
lengthTailRec arr = length' arr 0
  where
  length' :: Array a -&gt; Int -&gt; Int
  length' arr' acc =
    if null arr'
      then acc
      else length' (fromMaybe [] $ tail arr') (acc + 1)
</code></pre>
<p>In this case, we delegate to the helper function <code>length'</code>, which is tail recursive - its only recursive call is in the last case, and is in tail position. This means that the generated code will be a <em>while loop</em>, and will not blow the stack for large inputs.</p>
<p>To understand the implementation of <code>lengthTailRec</code>, note that the helper function <code>length'</code> essentially uses the accumulator parameter to maintain an additional piece of state - the partial result. It starts out at 0, and grows by adding 1 for every element in the input array.</p>
<p>Note also that while we might think of the accumulator as &quot;state&quot;, there is no direct mutation going on.</p>
<h2 id="prefer-folds-to-explicit-recursion"><a class="header" href="#prefer-folds-to-explicit-recursion">Prefer Folds to Explicit Recursion</a></h2>
<p>If we can write our recursive functions using tail recursion, then we can benefit from tail recursion optimization, so it becomes tempting to try to write all of our functions in this form. However, it is often easy to forget that many functions can be written directly as a fold over an array or similar data structure. Writing algorithms directly in terms of combinators such as <code>map</code> and <code>fold</code> has the added advantage of code simplicity - these combinators are well-understood, and as such, communicate the <em>intent</em> of the algorithm much better than explicit recursion.</p>
<p>For example, we can reverse an array using <code>foldr</code>:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :paste
‚Ä¶ reverse :: forall a. Array a -&gt; Array a
‚Ä¶ reverse = foldr (\x xs -&gt; xs &lt;&gt; [x]) []
‚Ä¶ ^D

&gt; reverse [1, 2, 3]
[3,2,1]
</code></pre>
<p>Writing <code>reverse</code> in terms of <code>foldl</code> will be left as an exercise for the reader.</p>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>allTrue</code> which uses <code>foldl</code> to test whether an array of boolean values are all true.</li>
<li>(Medium - No Test) Characterize those arrays <code>xs</code> for which the function <code>foldl (==) false xs</code> returns <code>true</code>. In other words, complete the sentence: &quot;The function returns <code>true</code> when <code>xs</code> contains ...&quot;</li>
<li>(Medium) Write a function <code>fibTailRec</code> which is the same as <code>fib</code> but in tail recursive form. <em>Hint</em>: Use an accumulator parameter.</li>
<li>(Medium) Write <code>reverse</code> in terms of <code>foldl</code>.</li>
</ol>
<h2 id="a-virtual-filesystem"><a class="header" href="#a-virtual-filesystem">A Virtual Filesystem</a></h2>
<p>In this section, we're going to apply what we've learned, writing functions which will work with a model of a filesystem. We will use maps, folds and filters to work with a predefined API.</p>
<p>The <code>Data.Path</code> module defines an API for a virtual filesystem, as follows:</p>
<ul>
<li>There is a type <code>Path</code> which represents a path in the filesystem.</li>
<li>There is a path <code>root</code> which represents the root directory.</li>
<li>The <code>ls</code> function enumerates the files in a directory.</li>
<li>The <code>filename</code> function returns the file name for a <code>Path</code>.</li>
<li>The <code>size</code> function returns the file size for a <code>Path</code> which represents a file.</li>
<li>The <code>isDirectory</code> function tests whether a <code>Path</code> is a file or a directory.</li>
</ul>
<p>In terms of types, we have the following type definitions:</p>
<pre><code class="language-haskell">root :: Path

ls :: Path -&gt; Array Path

filename :: Path -&gt; String

size :: Path -&gt; Maybe Int

isDirectory :: Path -&gt; Boolean
</code></pre>
<p>We can try out the API in PSCi:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Path

&gt; root
/

&gt; isDirectory root
true

&gt; ls root
[/bin/,/etc/,/home/]
</code></pre>
<p>The <code>Test.Examples</code> module defines functions which use the <code>Data.Path</code> API. You do not need to modify the <code>Data.Path</code> module, or understand its implementation. We will work entirely in the <code>Test.Examples</code> module.</p>
<h2 id="listing-all-files"><a class="header" href="#listing-all-files">Listing All Files</a></h2>
<p>Let's write a function which performs a deep enumeration of all files inside a directory. This function will have the following type:</p>
<pre><code class="language-haskell">allFiles :: Path -&gt; Array Path
</code></pre>
<p>We can define this function by recursion. First, we can use <code>ls</code> to enumerate the immediate children of the directory. For each child, we can recursively apply <code>allFiles</code>, which will return an array of paths. <code>concatMap</code> will allow us to apply <code>allFiles</code> and flatten the results at the same time.</p>
<p>Finally, we use the cons operator <code>:</code> to include the current file:</p>
<pre><code class="language-haskell">allFiles file = file : concatMap allFiles (ls file)
</code></pre>
<p><em>Note</em>: the cons operator <code>:</code> actually has poor performance on immutable arrays, so it is not recommended in general. Performance can be improved by using other data structures, such as linked lists and sequences.</p>
<p>Let's try this function in PSCi:</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.Path

&gt; allFiles root

[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]
</code></pre>
<p>Great! Now let's see if we can write this function using an array comprehension using do notation.</p>
<p>Recall that a backwards arrow corresponds to choosing an element from an array. The first step is to choose an element from the immediate children of the argument. Then we simply call the function recursively for that file. Since we are using do notation, there is an implicit call to <code>concatMap</code> which concatenates all of the recursive results.</p>
<p>Here is the new version:</p>
<pre><code class="language-haskell">allFiles' :: Path -&gt; Array Path
allFiles' file = file : do
  child &lt;- ls file
  allFiles' child
</code></pre>
<p>Try out the new version in PSCi - you should get the same result. I'll let you decide which version you find clearer.</p>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a function <code>onlyFiles</code> which returns all <em>files</em> (not directories) in all subdirectories of a directory.</p>
</li>
<li>
<p>(Medium) Write a function <code>whereIs</code> to search for a file by name. The function should return a value of type <code>Maybe Path</code>, indicating the directory containing the file, if it exists. It should behave as follows:</p>
<pre><code class="language-text">&gt; whereIs root &quot;ls&quot;
Just (/bin/)

&gt; whereIs root &quot;cat&quot;
Nothing
</code></pre>
<p><em>Hint</em>: Try to write this function as an array comprehension using do notation.</p>
</li>
<li>
<p>(Difficult) Write a function <code>largestSmallest</code> which takes a <code>Path</code> and returns an array containing the single largest and single smallest files in the <code>Path</code>. <em>Note</em>: consider the cases where there are zero or one files in the <code>Path</code> by returning an empty array or a one-element array respectively.</p>
</li>
</ol>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>In this chapter, we covered the basics of recursion in PureScript, as a means of expressing algorithms concisely. We also introduced user-defined infix operators, standard functions on arrays such as maps, filters and folds, and array comprehensions which combine these ideas. Finally, we showed the importance of using tail recursion in order to avoid stack overflow errors, and how to use accumulator parameters to convert functions to tail recursive form.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<h2 id="chapter-goals-3"><a class="header" href="#chapter-goals-3">Chapter Goals</a></h2>
<p>This chapter will introduce two new concepts: algebraic data types, and pattern matching. We will also briefly cover an interesting feature of the PureScript type system: row polymorphism.</p>
<p>Pattern matching is a common technique in functional programming and allows the developer to write compact functions which express potentially complex ideas, by breaking their implementation down into multiple cases.</p>
<p>Algebraic data types are a feature of the PureScript type system which enable a similar level of expressiveness in the language of types - they are closely related to pattern matching.</p>
<p>The goal of the chapter will be to write a library to describe and manipulate simple vector graphics using algebraic types and pattern matching.</p>
<h2 id="project-setup-2"><a class="header" href="#project-setup-2">Project Setup</a></h2>
<p>The source code for this chapter is defined in the file <code>src/Data/Picture.purs</code>.</p>
<p>The <code>Data.Picture</code> module defines a data type <code>Shape</code> for simple shapes, and a type <code>Picture</code> for collections of shapes, along with functions for working with those types.</p>
<p>The module imports the <code>Data.Foldable</code> module, which provides functions for folding data structures:</p>
<pre><code class="language-haskell">module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
</code></pre>
<p>The <code>Data.Picture</code> module also imports the <code>Number</code> module, but this time using the <code>as</code> keyword:</p>
<pre><code class="language-haskell">import Data.Number as Number
</code></pre>
<p>This makes the types and functions in that module available for use, but only by using the <em>qualified name</em>, like <code>Number.max</code>. This can be useful to avoid overlapping imports, or just to make it clearer which modules certain things are imported from.</p>
<p><em>Note</em>: it is not necessary to use the same module name as the original module for a qualified import. Shorter qualified names like <code>import Data.Number as N</code> are possible, and quite common.</p>
<h2 id="simple-pattern-matching"><a class="header" href="#simple-pattern-matching">Simple Pattern Matching</a></h2>
<p>Let's begin by looking at an example. Here is a function which computes the greatest common divisor of two integers using pattern matching:</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>This algorithm is called the Euclidean Algorithm. If you search for its definition online, you will likely find a set of mathematical equations which look a lot like the code above. This is one benefit of pattern matching: it allows you to define code by cases, writing simple, declarative code which looks like a specification of a mathematical function.</p>
<p>A function written using pattern matching works by pairing sets of conditions with their results. Each line is called an <em>alternative</em> or a <em>case</em>. The expressions on the left of the equals sign are called <em>patterns</em>, and each case consists of one or more patterns, separated by spaces. Cases describe which conditions the arguments must satisfy before the expression on the right of the equals sign should be evaluated and returned. Each case is tried in order, and the first case whose patterns match their inputs determines the return value.</p>
<p>For example, the <code>gcd</code> function is evaluated using the following steps:</p>
<ul>
<li>The first case is tried: if the second argument is zero, the function returns <code>n</code> (the first argument).</li>
<li>If not, the second case is tried: if the first argument is zero, the function returns <code>m</code> (the second argument).</li>
<li>Otherwise, the function evaluates and returns the expression in the last line.</li>
</ul>
<p>Note that patterns can bind values to names - each line in the example binds one or both of the names <code>n</code> and <code>m</code> to the input values. As we learn about different kinds of patterns, we will see that different types of patterns correspond to different ways to choose names from the input arguments.</p>
<h2 id="simple-patterns"><a class="header" href="#simple-patterns">Simple Patterns</a></h2>
<p>The example code above demonstrates two types of patterns:</p>
<ul>
<li>Integer literals patterns, which match something of type <code>Int</code>, only if the value matches exactly.</li>
<li>Variable patterns, which bind their argument to a name</li>
</ul>
<p>There are other types of simple patterns:</p>
<ul>
<li><code>Number</code>, <code>String</code>, <code>Char</code> and <code>Boolean</code> literals</li>
<li>Wildcard patterns, indicated with an underscore (<code>_</code>), which match any argument, and which do not bind any names.</li>
</ul>
<p>Here are two more examples which demonstrate using these simple patterns:</p>
<pre><code class="language-haskell">fromString :: String -&gt; Boolean
fromString &quot;true&quot; = true
fromString _      = false

toString :: Boolean -&gt; String
toString true  = &quot;true&quot;
toString false = &quot;false&quot;
</code></pre>
<p>Try these functions in PSCi.</p>
<h2 id="guards-1"><a class="header" href="#guards-1">Guards</a></h2>
<p>In the Euclidean algorithm example, we used an <code>if .. then .. else</code> expression to switch between the two alternatives when <code>m &gt; n</code> and <code>m &lt;= n</code>. Another option in this case would be to use a <em>guard</em>.</p>
<p>A guard is a boolean-valued expression which must be satisfied in addition to the constraints imposed by the patterns. Here is the Euclidean algorithm rewritten to use a guard:</p>
<pre><code class="language-haskell">gcdV2 :: Int -&gt; Int -&gt; Int
gcdV2 n 0 = n
gcdV2 0 n = n
gcdV2 n m | n &gt; m     = gcdV2 (n - m) m
          | otherwise = gcdV2 n (m - n)
</code></pre>
<p>In this case, the third line uses a guard to impose the extra condition that the first argument is strictly larger than the second. The guard in the final line uses the expression <code>otherwise</code>, which might seem like a keyword, but is in fact just a regular binding in <code>Prelude</code>:</p>
<pre><code class="language-text">&gt; :type otherwise
Boolean

&gt; otherwise
true
</code></pre>
<p>As this example demonstrates, guards appear on the left of the equals symbol, separated from the list of patterns by a pipe character (<code>|</code>).</p>
<h2 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h2>
<ol>
<li>(Easy) Write the <code>factorial</code> function using pattern matching. <em>Hint</em>: Consider the two corner cases of zero and non-zero inputs. <em>Note</em>: This is a repeat of an example from the previous chapter, but see if you can rewrite it here on your own.</li>
<li>(Medium) Write a function <code>binomial</code> which finds the coefficient of the x^<code>k</code>th term in the polynomial expansion of (1 + x)^<code>n</code>. This is the same as the number of ways to choose a subset of <code>k</code> elements from a set of <code>n</code> elements. Use the formula <code>n! / k! (n - k)!</code>, where <code>!</code> is the factorial function written earlier. <em>Hint</em>: Use pattern matching to handle corner cases. If it takes a long time to complete or crashes with an error about the call stack, try adding more corner cases.</li>
<li>(Medium) Write a function <code>pascal</code> which uses <a href="https://en.wikipedia.org/wiki/Pascal%27s_rule"><em>Pascal`s Rule</em></a> for computing the same binomial coefficients as the previous exercise.</li>
</ol>
<h2 id="array-patterns"><a class="header" href="#array-patterns">Array Patterns</a></h2>
<p><em>Array literal patterns</em> provide a way to match arrays of a fixed length. For example, suppose we want to write a function <code>isEmpty</code> which identifies empty arrays. We could do this by using an empty array pattern (<code>[]</code>) in the first alternative:</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty [] = true
isEmpty _ = false
</code></pre>
<p>Here is another function which matches arrays of length five, binding each of its five elements in a different way:</p>
<pre><code class="language-haskell">takeFive :: Array Int -&gt; Int
takeFive [0, 1, a, b, _] = a * b
takeFive _ = 0
</code></pre>
<p>The first pattern only matches arrays with five elements, whose first and second elements are 0 and 1 respectively. In that case, the function returns the product of the third and fourth elements. In every other case, the function returns zero. For example, in PSCi:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ takeFive [0, 1, a, b, _] = a * b
‚Ä¶ takeFive _ = 0
‚Ä¶ ^D

&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0
</code></pre>
<p>Array literal patterns allow us to match arrays of a fixed length, but PureScript does <em>not</em> provide any means of matching arrays of an unspecified length, since destructuring immutable arrays in these sorts of ways can lead to poor performance. If you need a data structure which supports this sort of matching, the recommended approach is to use <code>Data.List</code>. Other data structures exist which provide improved asymptotic performance for different operations.</p>
<h2 id="record-patterns-and-row-polymorphism"><a class="header" href="#record-patterns-and-row-polymorphism">Record Patterns and Row Polymorphism</a></h2>
<p><em>Record patterns</em> are used to match - you guessed it - records.</p>
<p>Record patterns look just like record literals, but instead of values on the right of the colon, we specify a binder for each field.</p>
<p>For example: this pattern matches any record which contains fields called <code>first</code> and <code>last</code>, and binds their values to the names <code>x</code> and <code>y</code> respectively:</p>
<pre><code class="language-haskell">showPerson :: { first :: String, last :: String } -&gt; String
showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x
</code></pre>
<p>Record patterns provide a good example of an interesting feature of the PureScript type system: <em>row polymorphism</em>. Suppose we had defined <code>showPerson</code> without a type signature above. What would its inferred type have been? Interestingly, it is not the same as the type we gave:</p>
<pre><code class="language-text">&gt; showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x

&gt; :type showPerson
forall r. { first :: String, last :: String | r } -&gt; String
</code></pre>
<p>What is the type variable <code>r</code> here? Well, if we try <code>showPerson</code> in PSCi, we see something interesting:</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;
</code></pre>
<p>We are able to append additional fields to the record, and the <code>showPerson</code> function will still work. As long as the record contains the <code>first</code> and <code>last</code> fields of type <code>String</code>, the function application is well-typed. However, it is <em>not</em> valid to call <code>showPerson</code> with too <em>few</em> fields:</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot; }

Type of expression lacks required label &quot;last&quot;
</code></pre>
<p>We can read the new type signature of <code>showPerson</code> as &quot;takes any record with <code>first</code> and <code>last</code> fields which are <code>Strings</code> <em>and any other fields</em>, and returns a <code>String</code>&quot;. This function is polymorphic in the <em>row</em> <code>r</code> of record fields, hence the name <em>row polymorphism</em>.  Note that this behavior is different than that of the original <code>showPerson</code>. Without the row variable <code>r</code>, <code>showPerson</code> only accepts records with <em>exactly</em> a <code>first</code> and <code>last</code> field and no others.</p>
<p>Note that we could have also written</p>
<pre><code class="language-haskell">&gt; showPerson p = p.last &lt;&gt; &quot;, &quot; &lt;&gt; p.first
</code></pre>
<p>and PSCi would have inferred the same type.</p>
<h2 id="record-puns"><a class="header" href="#record-puns">Record Puns</a></h2>
<p>Recall that the <code>showPerson</code> function matches a record inside its argument, binding the <code>first</code> and <code>last</code> fields to values named <code>x</code> and <code>y</code>. We could alternatively just reuse the field names themselves, and simplify this sort of pattern match as follows:</p>
<pre><code class="language-haskell">showPersonV2 :: { first :: String, last :: String } -&gt; String
showPersonV2 { first, last } = last &lt;&gt; &quot;, &quot; &lt;&gt; first
</code></pre>
<p>Here, we only specify the names of the fields, and we do not need to specify the names of the values we want to introduce. This is called a <em>record pun</em>.</p>
<p>It is also possible to use record puns to <em>construct</em> records. For example, if we have values named <code>first</code> and <code>last</code> in scope, we can construct a person record using <code>{ first, last }</code>:</p>
<pre><code class="language-haskell">unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = &quot;Jane&quot;
    last  = &quot;Doe&quot;
</code></pre>
<p>This may improve readability of code in some circumstances.</p>
<h2 id="nested-patterns"><a class="header" href="#nested-patterns">Nested Patterns</a></h2>
<p>Array patterns and record patterns both combine smaller patterns to build larger patterns. For the most part, the examples above have only used simple patterns inside array patterns and record patterns, but it is important to note that patterns can be arbitrarily <em>nested</em>, which allows functions to be defined using conditions on potentially complex data types.</p>
<p>For example, this code combines two record patterns:</p>
<pre><code class="language-haskell">type Address = { street :: String, city :: String }

type Person = { name :: String, address :: Address }

livesInLA :: Person -&gt; Boolean
livesInLA { address: { city: &quot;Los Angeles&quot; } } = true
livesInLA _ = false
</code></pre>
<h2 id="named-patterns"><a class="header" href="#named-patterns">Named Patterns</a></h2>
<p>Patterns can be <em>named</em> to bring additional names into scope when using nested patterns. Any pattern can be named by using the <code>@</code> symbol.</p>
<p>For example, this function sorts two-element arrays, naming the two elements, but also naming the array itself:</p>
<pre><code class="language-haskell">sortPair :: Array Int -&gt; Array Int
sortPair arr@[x, y]
  | x &lt;= y = arr
  | otherwise = [y, x]
sortPair arr = arr
</code></pre>
<p>This way, we save ourselves from allocating a new array if the pair is already sorted. Note that if the input array does not contain <em>exactly</em> two elements, then this function simply returns it unchanged, even if it's unsorted.</p>
<h2 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>sameCity</code> which uses record patterns to test whether two <code>Person</code> records belong to the same city.</li>
<li>(Medium) What is the most general type of the <code>sameCity</code> function, taking into account row polymorphism? What about the <code>livesInLA</code> function defined above? <em>Note</em>: There is no test for this exercise.</li>
<li>(Medium) Write a function <code>fromSingleton</code> which uses an array literal pattern to extract the sole member of a singleton array. If the array is not a singleton, your function should return a provided default value. Your function should have type <code>forall a. a -&gt; Array a -&gt; a</code></li>
</ol>
<h2 id="case-expressions"><a class="header" href="#case-expressions">Case Expressions</a></h2>
<p>Patterns do not only appear in top-level function declarations. It is possible to use patterns to match on an intermediate value in a computation, using a <code>case</code> expression. Case expressions provide a similar type of utility to anonymous functions: it is not always desirable to give a name to a function, and a <code>case</code> expression allows us to avoid naming a function just because we want to use a pattern.</p>
<p>Here is an example. This function computes &quot;longest zero suffix&quot; of an array (the longest suffix which sums to zero):</p>
<pre><code class="language-haskell">import Data.Array (tail)
import Data.Foldable (sum)
import Data.Maybe (fromMaybe)

lzs :: Array Int -&gt; Array Int
lzs [] = []
lzs xs = case sum xs of
           0 -&gt; xs
           _ -&gt; lzs (fromMaybe [] $ tail xs)
</code></pre>
<p>For example:</p>
<pre><code class="language-text">&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]
</code></pre>
<p>This function works by case analysis. If the array is empty, our only option is to return an empty array. If the array is non-empty, we first use a <code>case</code> expression to split into two cases. If the sum of the array is zero, we return the whole array. If not, we recurse on the tail of the array.</p>
<h2 id="pattern-match-failures-and-partial-functions"><a class="header" href="#pattern-match-failures-and-partial-functions">Pattern Match Failures and Partial Functions</a></h2>
<p>If patterns in a case expression are tried in order, then what happens in the case when none of the patterns in a case alternatives match their inputs? In this case, the case expression will fail at runtime with a <em>pattern match failure</em>.</p>
<p>We can see this behavior with a simple example:</p>
<pre><code class="language-haskell">import Partial.Unsafe (unsafePartial)

partialFunction :: Boolean -&gt; Boolean
partialFunction = unsafePartial \true -&gt; true
</code></pre>
<p>This function contains only a single case, which only matches a single input, <code>true</code>. If we compile this file, and test in PSCi with any other argument, we will see an error at runtime:</p>
<pre><code class="language-text">&gt; partialFunction false

Failed pattern match
</code></pre>
<p>Functions which return a value for any combination of inputs are called <em>total</em> functions, and functions which do not are called <em>partial</em>.</p>
<p>It is generally considered better to define total functions where possible. If it is known that a function does not return a result for some valid set of inputs, it is usually better to return a value capable of indicating failure, such as type <code>Maybe a</code> for some <code>a</code>, using <code>Nothing</code> when it cannot return a valid result. This way, the presence or absence of a value can be indicated in a type-safe way.</p>
<p>The PureScript compiler will generate an error if it can detect that your function is not total due to an incomplete pattern match. The <code>unsafePartial</code> function can be used to silence these errors (if you are sure that your partial function is safe!) If we removed the call to the <code>unsafePartial</code> function above, then the compiler would generate the following error:</p>
<pre><code class="language-text">A case expression could not be determined to cover all inputs.
The following additional cases are required to cover all inputs:

  false
</code></pre>
<p>This tells us that the value <code>false</code> is not matched by any pattern. In general, these warnings might include multiple unmatched cases.</p>
<p>If we also omit the type signature above:</p>
<pre><code class="language-haskell">partialFunction true = true
</code></pre>
<p>then PSCi infers a curious type:</p>
<pre><code class="language-text">&gt; :type partialFunction

Partial =&gt; Boolean -&gt; Boolean
</code></pre>
<p>We will see more types which involve the <code>=&gt;</code> symbol later on in the book (they are related to <em>type classes</em>), but for now, it suffices to observe that PureScript keeps track of partial functions using the type system, and that we must explicitly tell the type checker when they are safe.</p>
<p>The compiler will also generate a warning in certain cases when it can detect that cases are <em>redundant</em> (that is, a case only matches values which would have been matched by a prior case):</p>
<pre><code class="language-haskell">redundantCase :: Boolean -&gt; Boolean
redundantCase true = true
redundantCase false = false
redundantCase false = false
</code></pre>
<p>In this case, the last case is correctly identified as redundant:</p>
<pre><code class="language-text">A case expression contains unreachable cases:

  false
</code></pre>
<p><em>Note</em>: PSCi does not show warnings, so to reproduce this example, you will need to save this function as a file and compile it using <code>spago build</code>.</p>
<h2 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h2>
<p>This section will introduce a feature of the PureScript type system called <em>Algebraic Data Types</em> (or <em>ADTs</em>), which are fundamentally related to pattern matching.</p>
<p>However, we'll first consider a motivating example, which will provide the basis of a solution to this chapter's problem of implementing a simple vector graphics library.</p>
<p>Suppose we wanted to define a type to represent some simple shapes: lines, rectangles, circles, text, etc. In an object oriented language, we would probably define an interface or abstract class <code>Shape</code>, and one concrete subclass for each type of shape that we wanted to be able to work with.</p>
<p>However, this approach has one major drawback: to work with <code>Shape</code>s abstractly, it is necessary to identify all of the operations one might wish to perform, and to define them on the <code>Shape</code> interface. It becomes difficult to add new operations without breaking modularity.</p>
<p>Algebraic data types provide a type-safe way to solve this sort of problem, if the set of shapes is known in advance. It is possible to define new operations on <code>Shape</code> in a modular way, and still maintain type-safety.</p>
<p>Here is how <code>Shape</code> might be represented as an algebraic data type:</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String

type Point =
  { x :: Number
  , y :: Number
  }
</code></pre>
<p>This declaration defines <code>Shape</code> as a sum of different constructors, and for each constructor identifies the data that is included. A <code>Shape</code> is either a <code>Circle</code> which contains a center <code>Point</code> and a radius (a number), or a <code>Rectangle</code>, or a <code>Line</code>, or <code>Text</code>. There are no other ways to construct a value of type <code>Shape</code>.</p>
<p>An algebraic data type is introduced using the <code>data</code> keyword, followed by the name of the new type and any type arguments. The type's constructors (i.e. its <em>data constructors</em>) are defined after the equals symbol, and are separated by pipe characters (<code>|</code>). The data carried by an ADT's constructors doesn't have to be restricted to primitive types: constructors can include records, arrays, or even other ADTs.</p>
<p>Let's see another example from PureScript's standard libraries. We saw the <code>Maybe</code> type, which is used to define optional values, earlier in the book. Here is its definition from the <code>maybe</code> package:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>This example demonstrates the use of a type parameter <code>a</code>. Reading the pipe character as the word &quot;or&quot;, its definition almost reads like English: &quot;a value of type <code>Maybe a</code> is either <code>Nothing</code>, or <code>Just</code> a value of type <code>a</code>&quot;.</p>
<p>Note that we don't use the syntax <code>forall a.</code> anywhere in our data definition. <code>forall</code> syntax is necessary for functions, but is not used when defining ADTs with <code>data</code> or type aliases with <code>type</code>.</p>
<p>Data constructors can also be used to define recursive data structures. Here is one more example, defining a data type of singly-linked lists of elements of type <code>a</code>:</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
</code></pre>
<p>This example is taken from the <code>lists</code> package. Here, the <code>Nil</code> constructor represents an empty list, and <code>Cons</code> is used to create non-empty lists from a head element and a tail. Notice how the tail is defined using the data type <code>List a</code>, making this a recursive data type.</p>
<h2 id="using-adts"><a class="header" href="#using-adts">Using ADTs</a></h2>
<p>It is simple enough to use the constructors of an algebraic data type to construct a value: simply apply them like functions, providing arguments corresponding to the data included with the appropriate constructor.</p>
<p>For example, the <code>Line</code> constructor defined above required two <code>Point</code>s, so to construct a <code>Shape</code> using the <code>Line</code> constructor, we have to provide two arguments of type <code>Point</code>:</p>
<pre><code class="language-haskell">exampleLine :: Shape
exampleLine = Line p1 p2
  where
    p1 :: Point
    p1 = { x: 0.0, y: 0.0 }

    p2 :: Point
    p2 = { x: 100.0, y: 50.0 }
</code></pre>
<p>So, constructing values of algebraic data types is simple, but how do we use them? This is where the important connection with pattern matching appears: the only way to consume a value of an algebraic data type is to use a pattern to match its constructor.</p>
<p>Let's see an example. Suppose we want to convert a <code>Shape</code> into a <code>String</code>. We have to use pattern matching to discover which constructor was used to construct the <code>Shape</code>. We can do this as follows:</p>
<pre><code class="language-haskell">showShape :: Shape -&gt; String
showShape (Circle c r) =
  &quot;Circle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, radius: &quot; &lt;&gt; show r &lt;&gt; &quot;]&quot;
showShape (Rectangle c w h) =
  &quot;Rectangle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, width: &quot; &lt;&gt; show w &lt;&gt; &quot;, height: &quot; &lt;&gt; show h &lt;&gt; &quot;]&quot;
showShape (Line start end) =
  &quot;Line [start: &quot; &lt;&gt; showPoint start &lt;&gt; &quot;, end: &quot; &lt;&gt; showPoint end &lt;&gt; &quot;]&quot;
showShape (Text loc text) =
  &quot;Text [location: &quot; &lt;&gt; showPoint loc &lt;&gt; &quot;, text: &quot; &lt;&gt; show text &lt;&gt; &quot;]&quot;

showPoint :: Point -&gt; String
showPoint { x, y } =
  &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot;, &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>Each constructor can be used as a pattern, and the arguments to the constructor can themselves be bound using patterns of their own. Consider the first case of <code>showShape</code>: if the <code>Shape</code> matches the <code>Circle</code> constructor, then we bring the arguments of <code>Circle</code> (center and radius) into scope using two variable patterns, <code>c</code> and <code>r</code>. The other cases are similar.</p>
<h2 id="exercises-9"><a class="header" href="#exercises-9">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>circleAtOrigin</code> which constructs a <code>Circle</code> (of type <code>Shape</code>) centered at the origin with radius <code>10.0</code>.</li>
<li>(Medium) Write a function <code>doubleScaleAndCenter</code> which scales the size of a <code>Shape</code> by a factor of <code>2.0</code> and centers it at the origin.</li>
<li>(Medium) Write a function <code>shapeText</code> which extracts the text from a <code>Shape</code>. It should return <code>Maybe String</code>, and use the <code>Nothing</code> constructor if the input is not constructed using <code>Text</code>.</li>
</ol>
<h2 id="newtypes"><a class="header" href="#newtypes">Newtypes</a></h2>
<p>There is a special case of algebraic data types, called <em>newtypes</em>. Newtypes are introduced using the <code>newtype</code> keyword instead of the <code>data</code> keyword.</p>
<p>Newtypes must define <em>exactly one</em> constructor, and that constructor must take <em>exactly one</em> argument. That is, a newtype gives a new name to an existing type. In fact, the values of a newtype have the same runtime representation as the underlying type, so there is no runtime performance overhead. They are, however, distinct from the point of view of the type system. This gives an extra layer of type safety.</p>
<p>As an example, we might want to define newtypes as type-level aliases for <code>Number</code>, to ascribe units like volts, amps, and ohms:</p>
<pre><code class="language-haskell">newtype Volt = Volt Number
newtype Ohm = Ohm Number
newtype Amp = Amp Number
</code></pre>
<p>Then we define functions and values using these types:</p>
<pre><code class="language-haskell">calculateCurrent :: Volt -&gt; Ohm -&gt; Amp
calculateCurrent (Volt v) (Ohm r) = Amp (v / r)

battery :: Volt
battery = Volt 1.5

lightbulb :: Ohm
lightbulb = Ohm 500.0

current :: Amp
current = calculateCurrent battery lightbulb
</code></pre>
<p>This prevents us from making silly mistakes, such as attempting to calculate the current produced by <em>two</em> lightbulbs <em>without</em> a voltage source.</p>
<pre><code class="language-haskell">current :: Amp
current = calculateCurrent lightbulb lightbulb
{-
TypesDoNotUnify:
  current = calculateCurrent lightbulb lightbulb
                             ^^^^^^^^^
  Could not match type
    Ohm
  with type
    Volt
-}
</code></pre>
<p>If we instead just used <code>Number</code> without <code>newtype</code>, then the compiler can't help us catch this mistake:</p>
<pre><code class="language-haskell">-- This also compiles, but is not as type safe.
calculateCurrent :: Number -&gt; Number -&gt; Number
calculateCurrent v r = v / r

battery :: Number
battery = 1.5

lightbulb :: Number
lightbulb = 500.0

current :: Number
current = calculateCurrent lightbulb lightbulb -- uncaught mistake
</code></pre>
<p>Note that while a newtype can only have a single constructor, and the constructor must be of a single value, a newtype <em>can</em> take any number of type variables. For example, the following newtype would be a valid definition (<code>err</code> and <code>a</code> are the type variables, and the <code>CouldError</code> constructor expects a <em>single</em> value of type <code>Either err a</code>):</p>
<pre><code class="language-Haskell">newtype CouldError err a = CouldError (Either err a)
</code></pre>
<p>Also note that the constructor of a newtype often has the same name as the newtype itself, but this is not a requirement. For example, unique names are also valid:</p>
<pre><code class="language-haskell">newtype Coulomb = MakeCoulomb Number
</code></pre>
<p>In this case, <code>Coulomb</code> is the <em>type constructor</em> (of zero arguments) and <code>MakeCoulomb</code> is the <em>data constructor</em>. These constructors live in different namespaces, even when the names are identical, such as with the <code>Volt</code> example. This is true for all ADTs. Note that although the type constructor and data constructor can have different names, in practice it is idiomatic for them to share the same name. This is the case with <code>Amp</code> and <code>Volt</code> types above.</p>
<p>Another application of newtypes is to attach different <em>behavior</em> to an existing type without changing its representation at runtime. We cover that use case in the next chapter when we discuss <em>type classes</em>.</p>
<h2 id="exercises-10"><a class="header" href="#exercises-10">Exercises</a></h2>
<ol>
<li>(Easy) Define <code>Watt</code> as a <code>newtype</code> of <code>Number</code>. Then define a <code>calculateWattage</code> function using this new <code>Watt</code> type and the above definitions <code>Amp</code> and <code>Volt</code>:</li>
</ol>
<pre><code class="language-haskell">calculateWattage :: Amp -&gt; Volt -&gt; Watt
</code></pre>
<p>A wattage in <code>Watt</code>s can be calculated as the product of a given current in <code>Amp</code>s and a given voltage in <code>Volt</code>s.</p>
<h2 id="a-library-for-vector-graphics"><a class="header" href="#a-library-for-vector-graphics">A Library for Vector Graphics</a></h2>
<p>Let's use the data types we have defined above to create a simple library for using vector graphics.</p>
<p>Define a type synonym for a <code>Picture</code> - just an array of <code>Shape</code>s:</p>
<pre><code class="language-haskell">type Picture = Array Shape
</code></pre>
<p>For debugging purposes, we'll want to be able to turn a <code>Picture</code> into something readable. The <code>showPicture</code> function lets us do that:</p>
<pre><code class="language-haskell">showPicture :: Picture -&gt; Array String
showPicture = map showShape
</code></pre>
<p>Let's try it out. Compile your module with <code>spago build</code> and open PSCi with <code>spago repl</code>:</p>
<pre><code class="language-text">$ spago build
$ spago repl

&gt; import Data.Picture

&gt; showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]

[&quot;Line [start: (0.0, 0.0), end: (1.0, 1.0)]&quot;]
</code></pre>
<h2 id="computing-bounding-rectangles"><a class="header" href="#computing-bounding-rectangles">Computing Bounding Rectangles</a></h2>
<p>The example code for this module contains a function <code>bounds</code> which computes the smallest bounding rectangle for a <code>Picture</code>.</p>
<p>The <code>Bounds</code> type defines a bounding rectangle.</p>
<pre><code class="language-haskell">type Bounds =
  { top    :: Number
  , left   :: Number
  , bottom :: Number
  , right  :: Number
  }
</code></pre>
<p><code>bounds</code> uses the <code>foldl</code> function from <code>Data.Foldable</code> to traverse the array of <code>Shapes</code> in a <code>Picture</code>, and accumulate the smallest bounding rectangle:</p>
<pre><code class="language-haskell">bounds :: Picture -&gt; Bounds
bounds = foldl combine emptyBounds
  where
  combine :: Bounds -&gt; Shape -&gt; Bounds
  combine b shape = union (shapeBounds shape) b
</code></pre>
<p>In the base case, we need to find the smallest bounding rectangle of an empty <code>Picture</code>, and the empty bounding rectangle defined by <code>emptyBounds</code> suffices.</p>
<p>The accumulating function <code>combine</code> is defined in a <code>where</code> block. <code>combine</code> takes a bounding rectangle computed from <code>foldl</code>'s recursive call, and the next <code>Shape</code> in the array, and uses the <code>union</code> function to compute the union of the two bounding rectangles. The <code>shapeBounds</code> function computes the bounds of a single shape using pattern matching.</p>
<h2 id="exercises-11"><a class="header" href="#exercises-11">Exercises</a></h2>
<ol>
<li>(Medium) Extend the vector graphics library with a new operation <code>area</code> which computes the area of a <code>Shape</code>. For the purpose of this exercise, the area of a line or a piece of text is assumed to be zero.</li>
<li>(Difficult) Extend the <code>Shape</code> type with a new data constructor <code>Clipped</code>, which clips another <code>Picture</code> to a rectangle. Extend the <code>shapeBounds</code> function to compute the bounds of a clipped picture. Note that this makes <code>Shape</code> into a recursive data type.</li>
</ol>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In this chapter, we covered pattern matching, a basic but powerful technique from functional programming. We saw how to use simple patterns as well as array and record patterns to match parts of deep data structures.</p>
<p>This chapter also introduced algebraic data types, which are closely related to pattern matching. We saw how algebraic data types allow concise descriptions of data structures, and provide a modular way to extend data types with new operations.</p>
<p>Finally, we covered <em>row polymorphism</em>, a powerful type of abstraction which allows many idiomatic JavaScript functions to be given a type.</p>
<p>In the rest of the book, we will use ADTs and pattern matching extensively, so it will pay dividends to become familiar with them now. Try creating your own algebraic data types and writing functions to consume them using pattern matching.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-classes"><a class="header" href="#type-classes">Type Classes</a></h1>
<h2 id="chapter-goals-4"><a class="header" href="#chapter-goals-4">Chapter Goals</a></h2>
<p>This chapter will introduce a powerful form of abstraction which is enabled by PureScript's type system - type classes.</p>
<p>This motivating example for this chapter will be a library for hashing data structures. We will see how the machinery of type classes allow us to hash complex data structures without having to think directly about the structure of the data itself.</p>
<p>We will also see a collection of standard type classes from PureScript's Prelude and standard libraries. PureScript code leans heavily on the power of type classes to express ideas concisely, so it will be beneficial to familiarize yourself with these classes.</p>
<p>If you come from an Object Oriented background, please note that the word &quot;class&quot; means something <em>very</em> different in this context than what you're used to. A type class serves a purpose more similar to an OO interface.</p>
<h2 id="project-setup-3"><a class="header" href="#project-setup-3">Project Setup</a></h2>
<p>The source code for this chapter is defined in the file <code>src/Data/Hashable.purs</code>.</p>
<p>The project has the following dependencies:</p>
<ul>
<li><code>maybe</code>, which defines the <code>Maybe</code> data type, which represents optional values.</li>
<li><code>tuples</code>, which defines the <code>Tuple</code> data type, which represents pairs of values.</li>
<li><code>either</code>, which defines the <code>Either</code> data type, which represents disjoint unions.</li>
<li><code>strings</code>, which defines functions which operate on strings.</li>
<li><code>functions</code>, which defines some helper functions for defining PureScript functions.</li>
</ul>
<p>The module <code>Data.Hashable</code> imports several modules provided by these packages.</p>
<h2 id="show-me"><a class="header" href="#show-me">Show Me!</a></h2>
<p>Our first simple example of a type class is provided by a function we've seen several times already: the <code>show</code> function, which takes a value and displays it as a string.</p>
<p><code>show</code> is defined by a type class in the <code>Prelude</code> module called <code>Show</code>, which is defined as follows:</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String
</code></pre>
<p>This code declares a new <em>type class</em> called <code>Show</code>, which is parameterized by the type variable <code>a</code>.</p>
<p>A type class <em>instance</em> contains implementations of the functions defined in a type class, specialized to a particular type.</p>
<p>For example, here is the definition of the <code>Show</code> type class instance for <code>Boolean</code> values, taken from the Prelude:</p>
<pre><code class="language-haskell">instance showBoolean :: Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<p>This code declares a type class instance called <code>showBoolean</code> - in PureScript, type class instances can be named to aid the readability of the generated JavaScript. We say that the <code>Boolean</code> type <em>belongs to the <code>Show</code> type class</em>.</p>
<p>We can try out the <code>Show</code> type class in PSCi, by showing a few values with different types:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; show true
&quot;true&quot;

&gt; show 1.0
&quot;1.0&quot;

&gt; show &quot;Hello World&quot;
&quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>These examples demonstrate how to <code>show</code> values of various primitive types, but we can also <code>show</code> values with more complicated types:</p>
<pre><code class="language-text">&gt; import Data.Tuple

&gt; show (Tuple 1 true)
&quot;(Tuple 1 true)&quot;

&gt; import Data.Maybe

&gt; show (Just &quot;testing&quot;)
&quot;(Just \&quot;testing\&quot;)&quot;
</code></pre>
<p>The output of <code>show</code> should be a string that you can paste back into the repl (or <code>.purs</code> file) to recreate the item being shown. Here we'll use <code>logShow</code>, which just calls <code>show</code> then <code>log</code>, to render the string without quotes. Ignore the <code>unit</code> print - that will covered in Chapter 8 when we examine <code>Effect</code>s, like <code>log</code>.</p>
<pre><code class="language-text">&gt; import Effect.Console

&gt; logShow (Tuple 1 true)
(Tuple 1 true)
unit

&gt; logShow (Just &quot;testing&quot;)
(Just &quot;testing&quot;)
unit
</code></pre>
<p>If we try to show a value of type <code>Data.Either</code>, we get an interesting error message:</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; show (Left 10)

The inferred type

    forall a. Show a =&gt; String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>The problem here is not that there is no <code>Show</code> instance for the type we intended to <code>show</code>, but rather that PSCi was unable to infer the type. This is indicated by the <em>unknown type</em> <code>a</code> in the inferred type.</p>
<p>We can annotate the expression with a type, using the <code>::</code> operator, so that PSCi can choose the correct type class instance:</p>
<pre><code class="language-text">&gt; show (Left 10 :: Either Int String)
&quot;(Left 10)&quot;
</code></pre>
<p>Some types do not have a <code>Show</code> instance defined at all. One example of this is the function type <code>-&gt;</code>. If we try to <code>show</code> a function from <code>Int</code> to <code>Int</code>, we get an appropriate error message from the type checker:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; show $ \n -&gt; n + 1

No type class instance was found for

  Data.Show.Show (Int -&gt; Int)
</code></pre>
<p>Type class instances can be defined in one of two places: in the same module that the type class is defined, or in the same module that the type &quot;belonging to&quot; the type class is defined. An instance defined in any other spot is called an <a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">&quot;orphan instance&quot;</a> and is not allowed by the PureScript compiler. Some of the exercises in this chapter will require you to copy the definition of a type into your MySolutions module so that you can define type class instances for that type.</p>
<h2 id="exercises-12"><a class="header" href="#exercises-12">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Define a <code>Show</code> instance for <code>Point</code>. Match the same output as the <code>showPoint</code> function from the previous chapter. <em>Note:</em> Point is now a <code>newtype</code> (instead of a <code>type</code> synonym), which allows us to customize how to <code>show</code> it. Otherwise, we'd be stuck with the default <code>Show</code> instance for records.</p>
<pre><code class="language-haskell">newtype Point
  = Point
  { x :: Number
  , y :: Number
  }
</code></pre>
</li>
</ol>
<h2 id="common-type-classes"><a class="header" href="#common-type-classes">Common Type Classes</a></h2>
<p>In this section, we'll look at some standard type classes defined in the Prelude and standard libraries. These type classes form the basis of many common patterns of abstraction in idiomatic PureScript code, so a basic understanding of their functions is highly recommended.</p>
<h3 id="eq"><a class="header" href="#eq">Eq</a></h3>
<p>The <code>Eq</code> type class defines the <code>eq</code> function, which tests two values for equality. The <code>==</code> operator is actually just an alias for <code>eq</code>.</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>Note that in either case, the two arguments must have the same type: it does not make sense to compare two values of different types for equality.</p>
<p>Try out the <code>Eq</code> type class in PSCi:</p>
<pre><code class="language-text">&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true
</code></pre>
<h3 id="ord"><a class="header" href="#ord">Ord</a></h3>
<p>The <code>Ord</code> type class defines the <code>compare</code> function, which can be used to compare two values, for types which support ordering. The comparison operators <code>&lt;</code> and <code>&gt;</code> along with their non-strict companions <code>&lt;=</code> and <code>&gt;=</code>, can be defined in terms of <code>compare</code>.</p>
<pre><code class="language-haskell">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p>The <code>compare</code> function compares two values, and returns an <code>Ordering</code>, which has three alternatives:</p>
<ul>
<li><code>LT</code> - if the first argument is less than the second.</li>
<li><code>EQ</code> - if the first argument is equal to the second.</li>
<li><code>GT</code> - if the first argument is greater than the second.</li>
</ul>
<p>Again, we can try out the <code>compare</code> function in PSCi:</p>
<pre><code class="language-text">&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<p>The <code>Field</code> type class identifies those types which support numeric operators such as addition, subtraction, multiplication and division. It is provided to abstract over those operators, so that they can be reused where appropriate.</p>
<p><em>Note</em>: Just like the <code>Eq</code> and <code>Ord</code> type classes, the <code>Field</code> type class has special support in the PureScript compiler, so that simple expressions such as <code>1 + 2 * 3</code> get translated into simple JavaScript, as opposed to function calls which dispatch based on a type class implementation.</p>
<pre><code class="language-haskell">class EuclideanRing a &lt;= Field a
</code></pre>
<p>The <code>Field</code> type class is composed from several more general <em>superclasses</em>. This allows us to talk abstractly about types which support some but not all of the <code>Field</code> operations. For example, a type of natural numbers would be closed under addition and multiplication, but not necessarily under subtraction, so that type might have an instance of the <code>Semiring</code> class (which is a superclass of <code>Num</code>), but not an instance of <code>Ring</code> or <code>Field</code>.</p>
<p>Superclasses will be explained later in this chapter, but the full <a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">numeric type class hierarchy</a> (<a href="https://harry.garrood.me/numeric-hierarchy-overview/">cheatsheet</a>) is beyond the scope of this chapter. The interested reader is encouraged to read the documentation for the superclasses of <code>Field</code> in <code>prelude</code>.</p>
<h3 id="semigroups-and-monoids"><a class="header" href="#semigroups-and-monoids">Semigroups and Monoids</a></h3>
<p>The <code>Semigroup</code> type class identifies those types which support an <code>append</code> operation to combine two values:</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a
</code></pre>
<p>Strings form a semigroup under regular string concatenation, and so do arrays. Several other standard instances are provided by the <code>prelude</code> package.</p>
<p>The <code>&lt;&gt;</code> concatenation operator, which we have already seen, is provided as an alias for <code>append</code>.</p>
<p>The <code>Monoid</code> type class (provided by the <code>prelude</code> package) extends the <code>Semigroup</code> type class with the concept of an empty value, called <code>mempty</code>:</p>
<pre><code class="language-haskell">class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>Again, strings and arrays are simple examples of monoids.</p>
<p>A <code>Monoid</code> type class instance for a type describes how to <em>accumulate</em> a result with that type, by starting with an &quot;empty&quot; value, and combining new results. For example, we can write a function which concatenates an array of values in some monoid by using a fold. In PSCi:</p>
<pre><code class="language-haskell">&gt; import Prelude
&gt; import Data.Monoid
&gt; import Data.Foldable

&gt; foldl append mempty [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&quot;Hello World&quot;

&gt; foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
</code></pre>
<p>The <code>prelude</code> package provides many examples of monoids and semigroups, which we will use in the rest of the book.</p>
<h3 id="foldable"><a class="header" href="#foldable">Foldable</a></h3>
<p>If the <code>Monoid</code> type class identifies those types which act as the result of a fold, then the <code>Foldable</code> type class identifies those type constructors which can be used as the source of a fold.</p>
<p>The <code>Foldable</code> type class is provided in the <code>foldable-traversable</code> package, which also contains instances for some standard containers such as arrays and <code>Maybe</code>.</p>
<p>The type signatures for the functions belonging to the <code>Foldable</code> class are a little more complicated than the ones we've seen so far:</p>
<pre><code class="language-haskell">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p>It is instructive to specialize to the case where <code>f</code> is the array type constructor. In this case, we can replace <code>f a</code> with <code>Array a</code> for any a, and we notice that the types of <code>foldl</code> and <code>foldr</code> become the types that we saw when we first encountered folds over arrays.</p>
<p>What about <code>foldMap</code>? Well, that becomes <code>forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Array a -&gt; m</code>. This type signature says that we can choose any type <code>m</code> for our result type, as long as that type is an instance of the <code>Monoid</code> type class. If we can provide a function which turns our array elements into values in that monoid, then we can accumulate over our array using the structure of the monoid, and return a single value.</p>
<p>Let's try out <code>foldMap</code> in PSCi:</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;
</code></pre>
<p>Here, we choose the monoid for strings, which concatenates strings together, and the <code>show</code> function which renders an <code>Int</code> as a <code>String</code>. Then, passing in an array of integers, we see that the results of <code>show</code>ing each integer have been concatenated into a single <code>String</code>.</p>
<p>But arrays are not the only types which are foldable. <code>foldable-traversable</code> also defines <code>Foldable</code> instances for types like <code>Maybe</code> and <code>Tuple</code>, and other libraries like <code>lists</code> define <code>Foldable</code> instances for their own data types. <code>Foldable</code> captures the notion of an <em>ordered container</em>.</p>
<h3 id="functor-and-type-class-laws"><a class="header" href="#functor-and-type-class-laws">Functor, and Type Class Laws</a></h3>
<p>The Prelude also defines a collection of type classes which enable a functional style of programming with side-effects in PureScript: <code>Functor</code>, <code>Applicative</code> and <code>Monad</code>. We will cover these abstractions later in the book, but for now, let's look at the definition of the <code>Functor</code> type class, which we have seen already in the form of the <code>map</code> function:</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The <code>map</code> function (and its alias <code>&lt;$&gt;</code>) allows a function to be &quot;lifted&quot; over a data structure. The precise definition of the word &quot;lifted&quot; here depends on the data structure in question, but we have already seen its behavior for some simple types:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; map (\n -&gt; n &lt; 3) [1, 2, 3, 4, 5]
[true, true, false, false, false]

&gt; import Data.Maybe
&gt; import Data.String (length)

&gt; map length (Just &quot;testing&quot;)
(Just 7)
</code></pre>
<p>How can we understand the meaning of the <code>map</code> function, when it acts on many different structures, each in a different way?</p>
<p>Well, we can build an intuition that the <code>map</code> function applies the function it is given to each element of a container, and builds a new container from the results, with the same shape as the original. But how do we make this concept precise?</p>
<p>Type class instances for <code>Functor</code> are expected to adhere to a set of <em>laws</em>, called the <em>functor laws</em>:</p>
<ul>
<li><code>map identity xs = xs</code></li>
<li><code>map g (map f xs) = map (g &lt;&lt;&lt; f) xs</code></li>
</ul>
<p>The first law is the <em>identity law</em>. It states that lifting the identity function (the function which returns its argument unchanged) over a structure just returns the original structure. This makes sense since the identity function does not modify its input.</p>
<p>The second law is the <em>composition law</em>. It states that mapping one function over a structure, and then mapping a second, is the same thing as mapping the composition of the two functions over the structure.</p>
<p>Whatever &quot;lifting&quot; means in the general sense, it should be true that any reasonable definition of lifting a function over a data structure should obey these rules.</p>
<p>Many standard type classes come with their own set of similar laws. The laws given to a type class give structure to the functions of that type class and allow us to study its instances in generality. The interested reader can research the laws ascribed to the standard type classes that we have seen already.</p>
<h3 id="deriving-instances"><a class="header" href="#deriving-instances">Deriving Instances</a></h3>
<p>Rather than writing instances manually, you can let the compiler do most of the work for you. Take a look at this <a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">Type Class Deriving guide</a>. That information will help you solve the following exercises.</p>
<h2 id="exercises-13"><a class="header" href="#exercises-13">Exercises</a></h2>
<p>The following newtype represents a complex number:</p>
<pre><code class="language-haskell">newtype Complex
  = Complex
  { real :: Number
  , imaginary :: Number
  }
</code></pre>
<ol>
<li>
<p>(Easy) Define a <code>Show</code> instance for <code>Complex</code>. Match the output format expected by the tests (e.g. <code>1.2+3.4i</code>, <code>5.6-7.8i</code>, etc.).</p>
</li>
<li>
<p>(Easy) Derive an <code>Eq</code> instance for <code>Complex</code>. <em>Note</em>: You may instead write this instance manually, but why do more work if you don't have to?</p>
</li>
<li>
<p>(Medium) Define a <code>Semiring</code> instance for <code>Complex</code>. <em>Note</em>: You can use <code>wrap</code> and <code>over2</code> from <a href="https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype"><code>Data.Newtype</code></a> to create a more concise solution. If you do so, you will also need to import <code>class Newtype</code> from <code>Data.Newtype</code> and derive a <code>Newtype</code> instance for <code>Complex</code>.</p>
</li>
<li>
<p>(Easy) Derive (via <code>newtype</code>) a <code>Ring</code> instance for <code>Complex</code>. <em>Note</em>: You may instead write this instance manually, but that's not as convenient.</p>
<p>Here's the <code>Shape</code> ADT from the previous chapter:</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String
</code></pre>
</li>
<li>
<p>(Medium) Derive (via <code>Generic</code>) a <code>Show</code> instance for <code>Shape</code>. How does the amount of code written and <code>String</code> output compare to <code>showShape</code> from the previous chapter? <em>Hint</em>: See the <a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic">Deriving from <code>Generic</code></a> section of the <a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">Type Class Deriving</a> guide.</p>
</li>
</ol>
<h2 id="type-class-constraints"><a class="header" href="#type-class-constraints">Type Class Constraints</a></h2>
<p>Types of functions can be constrained by using type classes. Here is an example: suppose we want to write a function which tests if three values are equal, by using equality defined using an <code>Eq</code> type class instance.</p>
<pre><code class="language-haskell">threeAreEqual :: forall a. Eq a =&gt; a -&gt; a -&gt; a -&gt; Boolean
threeAreEqual a1 a2 a3 = a1 == a2 &amp;&amp; a2 == a3
</code></pre>
<p>The type declaration looks like an ordinary polymorphic type defined using <code>forall</code>. However, there is a type class constraint <code>Eq a</code>, separated from the rest of the type by a double arrow <code>=&gt;</code>.</p>
<p>This type says that we can call <code>threeAreEqual</code> with any choice of type <code>a</code>, as long as there is an <code>Eq</code> instance available for <code>a</code> in one of the imported modules.</p>
<p>Constrained types can contain several type class instances, and the types of the instances are not restricted to simple type variables. Here is another example which uses <code>Ord</code> and <code>Show</code> instances to compare two values:</p>
<pre><code class="language-haskell">showCompare :: forall a. Ord a =&gt; Show a =&gt; a -&gt; a -&gt; String
showCompare a1 a2 | a1 &lt; a2 =
  show a1 &lt;&gt; &quot; is less than &quot; &lt;&gt; show a2
showCompare a1 a2 | a1 &gt; a2 =
  show a1 &lt;&gt; &quot; is greater than &quot; &lt;&gt; show a2
showCompare a1 a2 =
  show a1 &lt;&gt; &quot; is equal to &quot; &lt;&gt; show a2
</code></pre>
<p>Note that multiple constraints can be specified by using the <code>=&gt;</code> symbol multiple times, just like we specify curried functions
of multiple arguments. But remember not to confuse the two symbols:</p>
<ul>
<li><code>a -&gt; b</code> denotes the type of functions from <em>type</em> <code>a</code> to <em>type</em> <code>b</code>, whereas</li>
<li><code>a =&gt; b</code> applies the <em>constraint</em> <code>a</code> to the type <code>b</code>.</li>
</ul>
<p>The PureScript compiler will try to infer constrained types when a type annotation is not provided. This can be useful if we want to use the most general type possible for a function.</p>
<p>To see this, try using one of the standard type classes like <code>Semiring</code> in PSCi:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; :type \x -&gt; x + x
forall a. Semiring a =&gt; a -&gt; a
</code></pre>
<p>Here, we might have annotated this function as <code>Int -&gt; Int</code>, or <code>Number -&gt; Number</code>, but PSCi shows us that the most general type works for any <code>Semiring</code>, allowing us to use our function with both <code>Int</code>s and <code>Number</code>s.</p>
<h2 id="instance-dependencies"><a class="header" href="#instance-dependencies">Instance Dependencies</a></h2>
<p>Just as the implementation of functions can depend on type class instances using constrained types, so can the implementation of type class instances depend on other type class instances. This provides a powerful form of program inference, in which the implementation of a program can be inferred using its types.</p>
<p>For example, consider the <code>Show</code> type class. We can write a type class instance to <code>show</code> arrays of elements, as long as we have a way to <code>show</code> the elements themselves:</p>
<pre><code class="language-haskell">instance showArray :: Show a =&gt; Show (Array a) where
  ...
</code></pre>
<p>If a type class instance depends on multiple other instances, those instances should be grouped in parentheses and separated by
commas on the left hand side of the <code>=&gt;</code> symbol:</p>
<pre><code class="language-haskell">instance showEither :: (Show a, Show b) =&gt; Show (Either a b) where
  ...
</code></pre>
<p>These two type class instances are provided in the <code>prelude</code> library.</p>
<p>When the program is compiled, the correct type class instance for <code>Show</code> is chosen based on the inferred type of the argument to <code>show</code>. The selected instance might depend on many such instance relationships, but this complexity is not exposed to the developer.</p>
<h2 id="exercises-14"><a class="header" href="#exercises-14">Exercises</a></h2>
<ol>
<li>
<p>(Easy) The following declaration defines a type of non-empty arrays of elements of type <code>a</code>:</p>
<pre><code class="language-haskell">data NonEmpty a = NonEmpty a (Array a)
</code></pre>
<p>Write an <code>Eq</code> instance for the type <code>NonEmpty a</code> which reuses the instances for <code>Eq a</code> and <code>Eq (Array a)</code>. <em>Note:</em> you may instead derive the <code>Eq</code> instance.</p>
</li>
<li>
<p>(Medium) Write a <code>Semigroup</code> instance for <code>NonEmpty a</code> by reusing the <code>Semigroup</code> instance for <code>Array</code>.</p>
</li>
<li>
<p>(Medium) Write a <code>Functor</code> instance for <code>NonEmpty</code>.</p>
</li>
<li>
<p>(Medium) Given any type <code>a</code> with an instance of <code>Ord</code>, we can add a new &quot;infinite&quot; value which is greater than any other value:</p>
<pre><code class="language-haskell">data Extended a = Infinite | Finite a 
</code></pre>
<p>Write an <code>Ord</code> instance for <code>Extended a</code> which reuses the <code>Ord</code> instance for <code>a</code>.</p>
</li>
<li>
<p>(Difficult) Write a <code>Foldable</code> instance for <code>NonEmpty</code>. <em>Hint</em>: reuse the <code>Foldable</code> instance for arrays.</p>
</li>
<li>
<p>(Difficult) Given a type constructor <code>f</code> which defines an ordered container (and so has a <code>Foldable</code> instance), we can create a new container type which includes an extra element at the front:</p>
<pre><code class="language-haskell">data OneMore f a = OneMore a (f a)
</code></pre>
<p>The container <code>OneMore f</code> also has an ordering, where the new element comes before any element of <code>f</code>. Write a <code>Foldable</code> instance for <code>OneMore f</code>:</p>
<pre><code class="language-haskell">instance foldableOneMore :: Foldable f =&gt; Foldable (OneMore f) where
  ...
</code></pre>
</li>
<li>
<p>(Medium) Write a <code>dedupShapes :: Array Shape -&gt; Array Shape</code> function which removes duplicate <code>Shape</code>s from an array using the <code>nubEq</code> function.</p>
</li>
<li>
<p>(Medium) Write a <code>dedupShapesFast</code> function which is the same as <code>dedupShapes</code>, but uses the more efficient <code>nub</code> function.</p>
</li>
</ol>
<h2 id="multi-parameter-type-classes"><a class="header" href="#multi-parameter-type-classes">Multi Parameter Type Classes</a></h2>
<p>It's not the case that a type class can only take a single type as an argument. This is the most common case, but in fact, a type class can be parameterized by <em>zero or more</em> type arguments.</p>
<p>Let's see an example of a type class with two type arguments.</p>
<pre><code class="language-haskell">module Stream where

import Data.Array as Array
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String

class Stream stream element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }

instance streamArray :: Stream (Array a) a where
  uncons = Array.uncons

instance streamString :: Stream String Char where
  uncons = String.uncons
</code></pre>
<p>The <code>Stream</code> module defines a class <code>Stream</code> which identifies types which look like streams of elements, where elements can be pulled from the front of the stream using the <code>uncons</code> function.</p>
<p>Note that the <code>Stream</code> type class is parameterized not only by the type of the stream itself, but also by its elements. This allows us to define type class instances for the same stream type but different element types.</p>
<p>The module defines two type class instances: an instance for arrays, where <code>uncons</code> removes the head element of the array using pattern matching, and an instance for String, which removes the first character from a String.</p>
<p>We can write functions which work over arbitrary streams. For example, here is a function which accumulates a result in some <code>Monoid</code> based on the elements of a stream:</p>
<pre><code class="language-haskell">import Prelude
import Data.Monoid (class Monoid, mempty)

foldStream :: forall l e m. Stream l e =&gt; Monoid m =&gt; (e -&gt; m) -&gt; l -&gt; m
foldStream f list =
  case uncons list of
    Nothing -&gt; mempty
    Just cons -&gt; f cons.head &lt;&gt; foldStream f cons.tail
</code></pre>
<p>Try using <code>foldStream</code> in PSCi for different types of <code>Stream</code> and different types of <code>Monoid</code>.</p>
<h2 id="functional-dependencies"><a class="header" href="#functional-dependencies">Functional Dependencies</a></h2>
<p>Multi-parameter type classes can be very useful, but can easily lead to confusing types and even issues with type inference. As a simple example, consider writing a generic <code>tail</code> function on streams using the <code>Stream</code> class given above:</p>
<pre><code class="language-haskell">genericTail xs = map _.tail (uncons xs)
</code></pre>
<p>This gives a somewhat confusing error message:</p>
<pre><code class="language-text">The inferred type

  forall stream a. Stream stream a =&gt; stream -&gt; Maybe stream

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>The problem is that the <code>genericTail</code> function does not use the <code>element</code> type mentioned in the definition of the <code>Stream</code> type class, so that type is left unsolved.</p>
<p>Worse still, we cannot even use <code>genericTail</code> by applying it to a specific type of stream:</p>
<pre><code class="language-text">&gt; map _.tail (uncons &quot;testing&quot;)

The inferred type

  forall a. Stream String a =&gt; Maybe String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>Here, we might expect the compiler to choose the <code>streamString</code> instance. After all, a <code>String</code> is a stream of <code>Char</code>s, and cannot be a stream of any other type of elements.</p>
<p>The compiler is unable to make that deduction automatically, and cannot commit to the <code>streamString</code> instance. However, we can help the compiler by adding a hint to the type class definition:</p>
<pre><code class="language-haskell">class Stream stream element | stream -&gt; element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }
</code></pre>
<p>Here, <code>stream -&gt; element</code> is called a <em>functional dependency</em>. A functional dependency asserts a functional relationship between the type arguments of a multi-parameter type class. This functional dependency tells the compiler that there is a function from stream types to (unique) element types, so if the compiler knows the stream type, then it can commit to the element type.</p>
<p>This hint is enough for the compiler to infer the correct type for our generic tail function above:</p>
<pre><code class="language-text">&gt; :type genericTail
forall stream element. Stream stream element =&gt; stream -&gt; Maybe stream

&gt; genericTail &quot;testing&quot;
(Just &quot;esting&quot;)
</code></pre>
<p>Functional dependencies can be quite useful when using multi-parameter type classes to design certain APIs.</p>
<h2 id="nullary-type-classes"><a class="header" href="#nullary-type-classes">Nullary Type Classes</a></h2>
<p>We can even define type classes with zero type arguments! These correspond to compile-time assertions about our functions, allowing us to track global properties of our code in the type system.</p>
<p>An important example is the <code>Partial</code> class which we saw earlier when discussing partial functions. Take for example the functions <code>head</code> and <code>tail</code> defined in <code>Data.Array.Partial</code> that allow us to get the head or tail of an array without wrapping them in a <code>Maybe</code>, so they can fail if the array is empty:</p>
<pre><code class="language-haskell">head :: forall a. Partial =&gt; Array a -&gt; a

tail :: forall a. Partial =&gt; Array a -&gt; Array a
</code></pre>
<p>Note that there is no instance defined for the <code>Partial</code> type class! Doing so would defeat its purpose: attempting to use the <code>head</code> function directly will result in a type error:</p>
<pre><code class="language-text">&gt; head [1, 2, 3]

No type class instance was found for

  Prim.Partial
</code></pre>
<p>Instead, we can republish the <code>Partial</code> constraint for any functions making use of partial functions:</p>
<pre><code class="language-haskell">secondElement :: forall a. Partial =&gt; Array a -&gt; a
secondElement xs = head (tail xs)
</code></pre>
<p>We've already seen the <code>unsafePartial</code> function, which allows us to treat a partial function as a regular function (unsafely). This function is defined in the <code>Partial.Unsafe</code> module:</p>
<pre><code class="language-haskell">unsafePartial :: forall a. (Partial =&gt; a) -&gt; a
</code></pre>
<p>Note that the <code>Partial</code> constraint appears <em>inside the parentheses</em> on the left of the function arrow, but not in the outer <code>forall</code>. That is, <code>unsafePartial</code> is a function from partial values to regular values:</p>
<pre><code class="language-text">&gt; unsafePartial head [1, 2, 3]
1

&gt; unsafePartial secondElement [1, 2, 3]
2
</code></pre>
<h2 id="superclasses"><a class="header" href="#superclasses">Superclasses</a></h2>
<p>Just as we can express relationships between type class instances by making an instance dependent on another instance, we can express relationships between type classes themselves using so-called <em>superclasses</em>.</p>
<p>We say that one type class is a superclass of another if every instance of the second class is required to be an instance of the first, and we indicate a superclass relationship in the class definition by using a backwards facing double arrow.</p>
<p>We've already seen some examples of superclass relationships: the <code>Eq</code> class is a superclass of <code>Ord</code>, and the <code>Semigroup</code> class is a superclass of <code>Monoid</code>. For every type class instance of the <code>Ord</code> class, there must be a corresponding <code>Eq</code> instance for the same type. This makes sense, since in many cases, when the <code>compare</code> function reports that two values are incomparable, we often want to use the <code>Eq</code> class to determine if they are in fact equal.</p>
<p>In general, it makes sense to define a superclass relationship when the laws for the subclass mention the members of the superclass. For example, it is reasonable to assume, for any pair of <code>Ord</code> and <code>Eq</code> instances, that if two values are equal under the <code>Eq</code> instance, then the <code>compare</code> function should return <code>EQ</code>. In other words, <code>a == b</code> should be true exactly when <code>compare a b</code> evaluates to <code>EQ</code>. This relationship on the level of laws justifies the superclass relationship between <code>Eq</code> and <code>Ord</code>.</p>
<p>Another reason to define a superclass relationship is in the case where there is a clear &quot;is-a&quot; relationship between the two classes. That is, every member of the subclass <em>is a</em> member of the superclass as well.</p>
<h2 id="exercises-15"><a class="header" href="#exercises-15">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Define a partial function <code>unsafeMaximum :: Partial =&gt; Array Int -&gt; Int</code> which finds the maximum of a non-empty array of integers. Test out your function in PSCi using <code>unsafePartial</code>. <em>Hint</em>: Use the <code>maximum</code> function from <code>Data.Foldable</code>.</p>
</li>
<li>
<p>(Medium) The <code>Action</code> class is a multi-parameter type class which defines an action of one type on another:</p>
<pre><code class="language-haskell">class Monoid m &lt;= Action m a where
  act :: m -&gt; a -&gt; a
</code></pre>
<p>An <em>action</em> is a function which describes how monoidal values are used to determine how to modify a value of another type. There are two laws for the <code>Action</code> type class:</p>
<ul>
<li><code>act mempty a = a</code></li>
<li><code>act (m1 &lt;&gt; m2) a = act m1 (act m2 a)</code></li>
</ul>
<p>Applying an empty action is a no-op. And applying two actions in sequence is the same as applying the actions combined. That is, actions respect the operations defined by the <code>Monoid</code> class.</p>
<p>For example, the natural numbers form a monoid under multiplication:</p>
<pre><code class="language-haskell">newtype Multiply = Multiply Int

instance semigroupMultiply :: Semigroup Multiply where
  append (Multiply n) (Multiply m) = Multiply (n * m)

instance monoidMultiply :: Monoid Multiply where
  mempty = Multiply 1
</code></pre>
<p>Write an instance which implements this action:</p>
<pre><code class="language-haskell">instance actionMultiplyInt :: Action Multiply Int where
  ...
</code></pre>
<p>Remember, your instance must satisfy the laws listed above.</p>
</li>
<li>
<p>(Difficult) There are actually multiple ways to implement an instance of <code>Action Multiply Int</code>. How many can you think of? Purescript does not allow multiple implementations of a same instance, so you will have to replace your original implementation. <em>Note</em>: the tests cover 4 implementations.</p>
</li>
<li>
<p>(Medium) Write an <code>Action</code> instance which repeats an input string some number of times:</p>
<pre><code class="language-haskell">instance actionMultiplyString :: Action Multiply String where
  ...
</code></pre>
<p><em>Hint</em>: Search Pursuit for a helper-function with the signature <a href="https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String"><code>String -&gt; Int -&gt; String</code></a>. Note that <code>String</code> might appear as a more generic type (such as <code>Monoid</code>).</p>
<p>Does this instance satisfy the laws listed above?</p>
</li>
<li>
<p>(Medium) Write an instance <code>Action m a =&gt; Action m (Array a)</code>, where the action on arrays is defined by acting on each array element independently.</p>
</li>
<li>
<p>(Difficult) Given the following newtype, write an instance for <code>Action m (Self m)</code>, where the monoid <code>m</code> acts on itself using <code>append</code>:</p>
<pre><code class="language-haskell">newtype Self m = Self m
</code></pre>
<p><em>Note</em>: The testing framework requires <code>Show</code> and <code>Eq</code> instances for the <code>Self</code> and <code>Multiply</code> types. You may either write these instances manually, or let the compiler handle this for you with <a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype"><code>derive newtype instance</code></a> shorthand.</p>
</li>
<li>
<p>(Difficult) Should the arguments of the multi-parameter type class <code>Action</code> be related by some functional dependency? Why or why not? <em>Note</em>: There is no test for this exercise.</p>
</li>
</ol>
<h2 id="a-type-class-for-hashes"><a class="header" href="#a-type-class-for-hashes">A Type Class for Hashes</a></h2>
<p>In the last section of this chapter, we will use the lessons from the rest of the chapter to create a library for hashing data structures.</p>
<p>Note that this library is for demonstration purposes only, and is not intended to provide a robust hashing mechanism.</p>
<p>What properties might we expect of a hash function?</p>
<ul>
<li>A hash function should be deterministic, and map equal values to equal hash codes.</li>
<li>A hash function should distribute its results approximately uniformly over some set of hash codes.</li>
</ul>
<p>The first property looks a lot like a law for a type class, whereas the second property is more along the lines of an informal contract, and certainly would not be enforceable by PureScript's type system. However, this should provide the intuition for the following type class:</p>
<pre><code class="language-haskell">newtype HashCode = HashCode Int

instance hashCodeEq :: Eq HashCode where
  eq (HashCode a) (HashCode b) = a == b

hashCode :: Int -&gt; HashCode
hashCode h = HashCode (h `mod` 65535)

class Eq a &lt;= Hashable a where
  hash :: a -&gt; HashCode
</code></pre>
<p>with the associated law that <code>a == b</code> implies <code>hash a == hash b</code>.</p>
<p>We'll spend the rest of this section building a library of instances and functions associated with the <code>Hashable</code> type class.</p>
<p>We will need a way to combine hash codes in a deterministic way:</p>
<pre><code class="language-haskell">combineHashes :: HashCode -&gt; HashCode -&gt; HashCode
combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)
</code></pre>
<p>The <code>combineHashes</code> function will mix two hash codes and redistribute the result over the interval 0-65535.</p>
<p>Let's write a function which uses the <code>Hashable</code> constraint to restrict the types of its inputs. One common task which requires a hashing function is to determine if two values hash to the same hash code. The <code>hashEqual</code> relation provides such a capability:</p>
<pre><code class="language-haskell">hashEqual :: forall a. Hashable a =&gt; a -&gt; a -&gt; Boolean
hashEqual = eq `on` hash
</code></pre>
<p>This function uses the <code>on</code> function from <code>Data.Function</code> to define hash-equality in terms of equality of hash codes, and should read like a declarative definition of hash-equality: two values are &quot;hash-equal&quot; if they are equal after each value has been passed through the <code>hash</code> function.</p>
<p>Let's write some <code>Hashable</code> instances for some primitive types. Let's start with an instance for integers. Since a <code>HashCode</code> is really just a wrapped integer, this is simple - we can use the <code>hashCode</code> helper function:</p>
<pre><code class="language-haskell">instance hashInt :: Hashable Int where
  hash = hashCode
</code></pre>
<p>We can also define a simple instance for <code>Boolean</code> values using pattern matching:</p>
<pre><code class="language-haskell">instance hashBoolean :: Hashable Boolean where
  hash false = hashCode 0
  hash true  = hashCode 1
</code></pre>
<p>With an instance for hashing integers, we can create an instance for hashing <code>Char</code>s by using the <code>toCharCode</code> function from <code>Data.Char</code>:</p>
<pre><code class="language-haskell">instance hashChar :: Hashable Char where
  hash = hash &lt;&lt;&lt; toCharCode
</code></pre>
<p>To define an instance for arrays, we can <code>map</code> the <code>hash</code> function over the elements of the array (if the element type is also an instance of <code>Hashable</code>) and then perform a left fold over the resulting hashes using the <code>combineHashes</code> function:</p>
<pre><code class="language-haskell">instance hashArray :: Hashable a =&gt; Hashable (Array a) where
  hash = foldl combineHashes (hashCode 0) &lt;&lt;&lt; map hash
</code></pre>
<p>Notice how we build up instances using the simpler instances we have already written. Let's use our new <code>Array</code> instance to define an instance for <code>String</code>s, by turning a <code>String</code> into an array of <code>Char</code>s:</p>
<pre><code class="language-haskell">instance hashString :: Hashable String where
  hash = hash &lt;&lt;&lt; toCharArray
</code></pre>
<p>How can we prove that these <code>Hashable</code> instances satisfy the type class law that we stated above? We need to make sure that equal values have equal hash codes. In cases like <code>Int</code>, <code>Char</code>, <code>String</code> and <code>Boolean</code>, this is simple because there are no values of those types which are equal in the sense of <code>Eq</code> but not equal identically.</p>
<p>What about some more interesting types? To prove the type class law for the <code>Array</code> instance, we can use induction on the length of the array. The only array with length zero is <code>[]</code>. Any two non-empty arrays are equal only if they have equal head elements and equal tails, by the definition of <code>Eq</code> on arrays. By the inductive hypothesis, the tails have equal hashes, and we know that the head elements have equal hashes if the <code>Hashable a</code> instance must satisfy the law. Therefore, the two arrays have equal hashes, and so the <code>Hashable (Array a)</code> obeys the type class law as well.</p>
<p>The source code for this chapter includes several other examples of <code>Hashable</code> instances, such as instances for the <code>Maybe</code> and <code>Tuple</code> type.</p>
<h2 id="exercises-16"><a class="header" href="#exercises-16">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use PSCi to test the hash functions for each of the defined instances. <em>Note</em>: There is no provided unit test for this exercise.</p>
</li>
<li>
<p>(Medium) Write a function <code>arrayHasDuplicates</code> which tests if an array has any duplicate elements based on both hash and value equality. First check for hash equality with the <code>hashEqual</code> function, then check for value equality with <code>==</code> if a duplicate pair of hashes is found. <em>Hint</em>: the <code>nubByEq</code> function in <code>Data.Array</code> should make this task much simpler.</p>
</li>
<li>
<p>(Medium) Write a <code>Hashable</code> instance for the following newtype which satisfies the type class law:</p>
<pre><code class="language-haskell">newtype Hour = Hour Int

instance eqHour :: Eq Hour where
  eq (Hour n) (Hour m) = mod n 12 == mod m 12
</code></pre>
<p>The newtype <code>Hour</code> and its <code>Eq</code> instance represent the type of integers modulo 12, so that 1 and 13 are identified as equal, for example. Prove that the type class law holds for your instance.</p>
</li>
<li>
<p>(Difficult) Prove the type class laws for the <code>Hashable</code> instances for <code>Maybe</code>, <code>Either</code> and <code>Tuple</code>. <em>Note</em>: There is no test for this exercise.</p>
</li>
</ol>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>In this chapter, we've been introduced to <em>type classes</em>, a type-oriented form of abstraction which enables powerful forms of code reuse. We've seen a collection of standard type classes from the PureScript standard libraries, and defined our own library based on a type class for computing hash codes.</p>
<p>This chapter also gave an introduction to the notion of type class laws, a technique for proving properties about code which uses type classes for abstraction. Type class laws are part of a larger subject called <em>equational reasoning</em>, in which the properties of a programming language and its type system are used to enable logical reasoning about its programs. This is an important idea, and will be a theme which we will return to throughout the rest of the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applicative-validation"><a class="header" href="#applicative-validation">Applicative Validation</a></h1>
<h2 id="chapter-goals-5"><a class="header" href="#chapter-goals-5">Chapter Goals</a></h2>
<p>In this chapter, we will meet an important new abstraction - the <em>applicative functor</em>, described by the <code>Applicative</code> type class. Don't worry if the name sounds confusing - we will motivate the concept with a practical example - validating form data. This technique allows us to convert code which usually involves a lot of boilerplate checking into a simple, declarative description of our form.</p>
<p>We will also meet another type class, <code>Traversable</code>, which describes <em>traversable functors</em>, and see how this concept also arises very naturally from solutions to real-world problems.</p>
<p>The example code for this chapter will be a continuation of the address book example from chapter 3. This time, we will extend our address book data types, and write functions to validate values for those types. The understanding is that these functions could be used, for example in a web user interface, to display errors to the user as part of a data entry form.</p>
<h2 id="project-setup-4"><a class="header" href="#project-setup-4">Project Setup</a></h2>
<p>The source code for this chapter is defined in the files <code>src/Data/AddressBook.purs</code> and <code>src/Data/AddressBook/Validation.purs</code>.</p>
<p>The project has a number of dependencies, many of which we have seen before. There are two new dependencies:</p>
<ul>
<li><code>control</code>, which defines functions for abstracting control flow using type classes like <code>Applicative</code>.</li>
<li><code>validation</code>, which defines a functor for <em>applicative validation</em>, the subject of this chapter.</li>
</ul>
<p>The <code>Data.AddressBook</code> module defines data types and <code>Show</code> instances for the types in our project, and the <code>Data.AddressBook.Validation</code> module contains validation rules for those types.</p>
<h2 id="generalizing-function-application"><a class="header" href="#generalizing-function-application">Generalizing Function Application</a></h2>
<p>To explain the concept of an <em>applicative functor</em>, let's consider the type constructor <code>Maybe</code> that we met earlier.</p>
<p>The source code for this module defines a function <code>address</code> which has the following type:</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address
</code></pre>
<p>This function is used to construct a value of type <code>Address</code> from three strings: a street name, a city, and a state.</p>
<p>We can apply this function easily and see the result in PSCi:</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; address &quot;123 Fake St.&quot; &quot;Faketown&quot; &quot;CA&quot;
{ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>However, suppose we did not necessarily have a street, city, or state, and wanted to use the <code>Maybe</code> type to indicate a missing value in each of the three cases.</p>
<p>In one case, we might have a missing city. If we try to apply our function directly, we will receive an error from the type checker:</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Could not match type

  Maybe String

with type

  String
</code></pre>
<p>Of course, this is an expected type error - <code>address</code> takes strings as arguments, not values of type <code>Maybe String</code>.</p>
<p>However, it is reasonable to expect that we should be able to &quot;lift&quot; the <code>address</code> function to work with optional values described by the <code>Maybe</code> type. In fact, we can, and the <code>Control.Apply</code> provides the function <code>lift3</code> function which does exactly what we need:</p>
<pre><code class="language-text">&gt; import Control.Apply
&gt; lift3 address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Nothing
</code></pre>
<p>In this case, the result is <code>Nothing</code>, because one of the arguments (the city) was missing. If we provide all three arguments using the <code>Just</code> constructor, then the result will contain a value as well:</p>
<pre><code class="language-text">&gt; lift3 address (Just &quot;123 Fake St.&quot;) (Just &quot;Faketown&quot;) (Just &quot;CA&quot;)

Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })
</code></pre>
<p>The name of the function <code>lift3</code> indicates that it can be used to lift functions of 3 arguments. There are similar functions defined in <code>Control.Apply</code> for functions of other numbers of arguments.</p>
<h2 id="lifting-arbitrary-functions"><a class="header" href="#lifting-arbitrary-functions">Lifting Arbitrary Functions</a></h2>
<p>So, we can lift functions with small numbers of arguments by using <code>lift2</code>, <code>lift3</code>, etc. But how can we generalize this to arbitrary functions?</p>
<p>It is instructive to look at the type of <code>lift3</code>:</p>
<pre><code class="language-text">&gt; :type lift3
forall a b c d f. Apply f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d
</code></pre>
<p>In the <code>Maybe</code> example above, the type constructor <code>f</code> is <code>Maybe</code>, so that <code>lift3</code> is specialized to the following type:</p>
<pre><code class="language-haskell">forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; Maybe a -&gt; Maybe b -&gt; Maybe c -&gt; Maybe d
</code></pre>
<p>This type says that we can take any function with three arguments, and lift it to give a new function whose argument and result types are wrapped with <code>Maybe</code>.</p>
<p>Certainly, this is not possible for every type constructor <code>f</code>, so what is it about the <code>Maybe</code> type which allowed us to do this? Well, in specializing the type above, we removed a type class constraint on <code>f</code> from the <code>Apply</code> type class. <code>Apply</code> is defined in the Prelude as follows:</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The <code>Apply</code> type class is a subclass of <code>Functor</code>, and defines an additional function <code>apply</code>. As <code>&lt;$&gt;</code> was defined as an alias for <code>map</code>, the <code>Prelude</code> module defines <code>&lt;*&gt;</code> as an alias for <code>apply</code>. As we'll see, these two operators are often used together.</p>
<p>Note that this <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Apply#v:apply"><code>apply</code></a> is different than the <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:apply"><code>apply</code></a> from <code>Data.Function</code> (infixed as <code>$</code>). Luckily, infix notation is almost always used for the latter, so you don't need to worry about name collisions.</p>
<p>The type of <code>apply</code> looks a lot like the type of <code>map</code>. The difference between <code>map</code> and <code>apply</code> is that <code>map</code> takes a function as an argument, whereas the first argument to <code>apply</code> is wrapped in the type constructor <code>f</code>. We'll see how this is used soon, but first, let's see how to implement the <code>Apply</code> type class for the <code>Maybe</code> type:</p>
<pre><code class="language-haskell">instance functorMaybe :: Functor Maybe where
  map f (Just a) = Just (f a)
  map f Nothing  = Nothing

instance applyMaybe :: Apply Maybe where
  apply (Just f) (Just x) = Just (f x)
  apply _        _        = Nothing
</code></pre>
<p>This type class instance says that we can apply an optional function to an optional value, and the result is defined only if both are defined.</p>
<p>Now we'll see how <code>map</code> and <code>apply</code> can be used together to lift functions of arbitrary number of arguments.</p>
<p>For functions of one argument, we can just use <code>map</code> directly.</p>
<p>For functions of two arguments, we have a curried function <code>g</code> with type <code>a -&gt; b -&gt; c</code>, say. This is equivalent to the type <code>a -&gt; (b -&gt; c)</code>, so we can apply <code>map</code> to <code>g</code> to get a new function of type <code>f a -&gt; f (b -&gt; c)</code> for any type constructor <code>f</code> with a <code>Functor</code> instance. Partially applying this function to the first lifted argument (of type <code>f a</code>), we get a new wrapped function of type <code>f (b -&gt; c)</code>. If we also have an <code>Apply</code> instance for <code>f</code>, we can then use <code>apply</code> to apply the second lifted argument (of type <code>f b</code>) to get our final value of type <code>f c</code>.</p>
<p>Putting this all together, we see that if we have values <code>x :: f a</code> and <code>y :: f b</code>, then the expression <code>(g &lt;$&gt; x) &lt;*&gt; y</code> has type <code>f c</code> (remember, this expression is equivalent to <code>apply (map g x) y</code>). The precedence rules defined in the Prelude allow us to remove the parentheses: <code>g &lt;$&gt; x &lt;*&gt; y</code>.</p>
<p>In general, we can use <code>&lt;$&gt;</code> on the first argument, and <code>&lt;*&gt;</code> for the remaining arguments, as illustrated here for <code>lift3</code>:</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z
</code></pre>
<p>It is left as an exercise for the reader to verify the types involved in this expression.</p>
<p>As an example, we can try lifting the address function over <code>Maybe</code>, directly using the <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> functions:</p>
<pre><code class="language-text">&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Just &quot;Faketown&quot; &lt;*&gt; Just &quot;CA&quot;
Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })

&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;CA&quot;
Nothing
</code></pre>
<p>Try lifting some other functions of various numbers of arguments over <code>Maybe</code> in this way.</p>
<p>Alternatively <em>applicative do notation</em> can be used for the same purpose in a way that looks similar to the familiar <em>do notation</em>. Here is <code>lift3</code> using <em>applicative do notation</em>. Note <code>ado</code> is used instead of <code>do</code>, and <code>in</code> is used on the final line to denote the yielded value:</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = ado
  a &lt;- x
  b &lt;- y
  c &lt;- z
  in f a b c
</code></pre>
<h2 id="the-applicative-type-class"><a class="header" href="#the-applicative-type-class">The Applicative Type Class</a></h2>
<p>There is a related type class called <code>Applicative</code>, defined as follows:</p>
<pre><code class="language-haskell">class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p><code>Applicative</code> is a subclass of <code>Apply</code> and defines the <code>pure</code> function. <code>pure</code> takes a value and returns a value whose type has been wrapped with the type constructor <code>f</code>.</p>
<p>Here is the <code>Applicative</code> instance for <code>Maybe</code>:</p>
<pre><code class="language-haskell">instance applicativeMaybe :: Applicative Maybe where
  pure x = Just x
</code></pre>
<p>If we think of applicative functors as functors which allow lifting of functions, then <code>pure</code> can be thought of as lifting functions of zero arguments.</p>
<h2 id="intuition-for-applicative"><a class="header" href="#intuition-for-applicative">Intuition for Applicative</a></h2>
<p>Functions in PureScript are pure and do not support side-effects. Applicative functors allow us to work in larger &quot;programming languages&quot; which support some sort of side-effect encoded by the functor <code>f</code>.</p>
<p>As an example, the functor <code>Maybe</code> represents the side effect of possibly-missing values. Some other examples include <code>Either err</code>, which represents the side effect of possible errors of type <code>err</code>, and the arrow functor <code>r -&gt;</code> which represents the side-effect of reading from a global configuration. For now, we'll only consider the <code>Maybe</code> functor.</p>
<p>If the functor <code>f</code> represents this larger programming language with effects, then the <code>Apply</code> and <code>Applicative</code> instances allow us to lift values and function applications from our smaller programming language (PureScript) into the new language.</p>
<p><code>pure</code> lifts pure (side-effect free) values into the larger language, and for functions, we can use <code>map</code> and <code>apply</code> as described above.</p>
<p>This raises a question: if we can use <code>Applicative</code> to embed PureScript functions and values into this new language, then how is the new language any larger? The answer depends on the functor <code>f</code>. If we can find expressions of type <code>f a</code> which cannot be expressed as <code>pure x</code> for some <code>x</code>, then that expression represents a term which only exists in the larger language.</p>
<p>When <code>f</code> is <code>Maybe</code>, an example is the expression <code>Nothing</code>: we cannot write <code>Nothing</code> as <code>pure x</code> for any <code>x</code>. Therefore, we can think of PureScript as having been enlarged to include the new term <code>Nothing</code>, which represents a missing value.</p>
<h2 id="more-effects"><a class="header" href="#more-effects">More Effects</a></h2>
<p>Let's see some more examples of lifting functions over different <code>Applicative</code> functors.</p>
<p>Here is a simple example function defined in PSCi, which joins three names to form a full name:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; fullName first middle last = last &lt;&gt; &quot;, &quot; &lt;&gt; first &lt;&gt; &quot; &quot; &lt;&gt; middle

&gt; fullName &quot;Phillip&quot; &quot;A&quot; &quot;Freeman&quot;
Freeman, Phillip A
</code></pre>
<p>Now suppose that this function forms the implementation of a (very simple!) web service with the three arguments provided as query parameters. We want to make sure that the user provided each of the three parameters, so we might use the <code>Maybe</code> type to indicate the presence or otherwise absence of a parameter. We can lift <code>fullName</code> over <code>Maybe</code> to create an implementation of the web service which checks for missing parameters:</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Just &quot;A&quot; &lt;*&gt; Just &quot;Freeman&quot;
Just (&quot;Freeman, Phillip A&quot;)

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;Freeman&quot;
Nothing
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; :paste‚Ä¶
‚Ä¶ ado
‚Ä¶   f &lt;- Just &quot;Phillip&quot;
‚Ä¶   m &lt;- Just &quot;A&quot;
‚Ä¶   l &lt;- Just &quot;Freeman&quot;
‚Ä¶   in fullName f m l
‚Ä¶ ^D
(Just &quot;Freeman, Phillip A&quot;)

‚Ä¶ ado
‚Ä¶   f &lt;- Just &quot;Phillip&quot;
‚Ä¶   m &lt;- Nothing
‚Ä¶   l &lt;- Just &quot;Freeman&quot;
‚Ä¶   in fullName f m l
‚Ä¶ ^D
Nothing
</code></pre>
<p>Note that the lifted function returns <code>Nothing</code> if any of the arguments was <code>Nothing</code>.</p>
<p>This is good, because now we can send an error response back from our web service if the parameters are invalid. However, it would be better if we could indicate which field was incorrect in the response.</p>
<p>Instead of lifting over <code>Maybe</code>, we can lift over <code>Either String</code>, which allows us to return an error message. First, let's write an operator to convert optional inputs into computations which can signal an error using <code>Either String</code>:</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; :paste
‚Ä¶ withError Nothing  err = Left err
‚Ä¶ withError (Just a) _   = Right a
‚Ä¶ ^D
</code></pre>
<p><em>Note</em>: In the <code>Either err</code> applicative functor, the <code>Left</code> constructor indicates an error, and the <code>Right</code> constructor indicates success.</p>
<p>Now we can lift over <code>Either String</code>, providing an appropriate error message for each parameter:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ fullNameEither first middle last =
‚Ä¶   fullName &lt;$&gt; (first  `withError` &quot;First name was missing&quot;)
‚Ä¶            &lt;*&gt; (middle `withError` &quot;Middle name was missing&quot;)
‚Ä¶            &lt;*&gt; (last   `withError` &quot;Last name was missing&quot;)
‚Ä¶ ^D
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ fullNameEither first middle last = ado
‚Ä¶  f &lt;- first  `withError` &quot;First name was missing&quot;
‚Ä¶  m &lt;- middle `withError` &quot;Middle name was missing&quot;
‚Ä¶  l &lt;- last   `withError` &quot;Last name was missing&quot;
‚Ä¶  in fullName f m l
‚Ä¶ ^D

&gt; :type fullNameEither
Maybe String -&gt; Maybe String -&gt; Maybe String -&gt; Either String String
</code></pre>
<p>Now our function takes three optional arguments using <code>Maybe</code>, and returns either a <code>String</code> error message or a <code>String</code> result.</p>
<p>We can try out the function with different inputs:</p>
<pre><code class="language-text">&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) (Just &quot;Freeman&quot;)
(Right &quot;Freeman, Phillip A&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) Nothing (Just &quot;Freeman&quot;)
(Left &quot;Middle name was missing&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) Nothing
(Left &quot;Last name was missing&quot;)
</code></pre>
<p>In this case, we see the error message corresponding to the first missing field, or a successful result if every field was provided. However, if we are missing multiple inputs, we still only see the first error:</p>
<pre><code class="language-text">&gt; fullNameEither Nothing Nothing Nothing
(Left &quot;First name was missing&quot;)
</code></pre>
<p>This might be good enough, but if we want to see a list of <em>all</em> missing fields in the error, then we need something more powerful than <code>Either String</code>. We will see a solution later in this chapter.</p>
<h2 id="combining-effects"><a class="header" href="#combining-effects">Combining Effects</a></h2>
<p>As an example of working with applicative functors abstractly, this section will show how to write a function which will generically combine side-effects encoded by an applicative functor <code>f</code>.</p>
<p>What does this mean? Well, suppose we have a list of wrapped arguments of type <code>f a</code> for some <code>a</code>. That is, suppose we have a list of type <code>List (f a)</code>. Intuitively, this represents a list of computations with side-effects tracked by <code>f</code>, each with return type <code>a</code>. If we could run all of these computations in order, we would obtain a list of results of type <code>List a</code>. However, we would still have side-effects tracked by <code>f</code>. That is, we expect to be able to turn something of type <code>List (f a)</code> into something of type <code>f (List a)</code> by &quot;combining&quot; the effects inside the original list.</p>
<p>For any fixed list size <code>n</code>, there is a function of <code>n</code> arguments which builds a list of size <code>n</code> out of those arguments. For example, if <code>n</code> is <code>3</code>, the function is <code>\x y z -&gt; x : y : z : Nil</code>. This function has type <code>a -&gt; a -&gt; a -&gt; List a</code>. We can use the <code>Applicative</code> instance for <code>List</code> to lift this function over <code>f</code>, to get a function of type <code>f a -&gt; f a -&gt; f a -&gt; f (List a)</code>. But, since we can do this for any <code>n</code>, it makes sense that we should be able to perform the same lifting for any <em>list</em> of arguments.</p>
<p>That means that we should be able to write a function</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>This function will take a list of arguments, which possibly have side-effects, and return a single wrapped list, applying the side-effects of each.</p>
<p>To write this function, we'll consider the length of the list of arguments. If the list is empty, then we do not need to perform any effects, and we can use <code>pure</code> to simply return an empty list:</p>
<pre><code class="language-haskell">combineList Nil = pure Nil
</code></pre>
<p>In fact, this is the only thing we can do!</p>
<p>If the list is non-empty, then we have a head element, which is a wrapped argument of type <code>f a</code>, and a tail of type <code>List (f a)</code>. We can recursively combine the effects in the tail, giving a result of type <code>f (List a)</code>. We can then use <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to lift the <code>Cons</code> constructor over the head and new tail:</p>
<pre><code class="language-haskell">combineList (Cons x xs) = Cons &lt;$&gt; x &lt;*&gt; combineList xs
</code></pre>
<p>Again, this was the only sensible implementation, based on the types we were given.</p>
<p>We can test this function in PSCi, using the <code>Maybe</code> type constructor as an example:</p>
<pre><code class="language-text">&gt; import Data.List
&gt; import Data.Maybe

&gt; combineList (fromFoldable [Just 1, Just 2, Just 3])
(Just (Cons 1 (Cons 2 (Cons 3 Nil))))

&gt; combineList (fromFoldable [Just 1, Nothing, Just 2])
Nothing
</code></pre>
<p>When specialized to <code>Maybe</code>, our function returns a <code>Just</code> only if every list element was <code>Just</code>, otherwise it returns <code>Nothing</code>. This is consistent with our intuition of working in a larger language supporting optional values - a list of computations which return optional results only has a result itself if every computation contained a result.</p>
<p>But the <code>combineList</code> function works for any <code>Applicative</code>! We can use it to combine computations which possibly signal an error using <code>Either err</code>, or which read from a global configuration using <code>r -&gt;</code>.</p>
<p>We will see the <code>combineList</code> function again later, when we consider <code>Traversable</code> functors.</p>
<h2 id="exercises-17"><a class="header" href="#exercises-17">Exercises</a></h2>
<ol>
<li>(Medium) Write versions of the numeric operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> which work with optional arguments (i.e. arguments wrapped in <code>Maybe</code>) and return a value wrapped in <code>Maybe</code>. Name these functions <code>addMaybe</code>, <code>subMaybe</code>, <code>mulMaybe</code>, and <code>divMaybe</code>. <em>Hint</em>: Use <code>lift2</code>.</li>
<li>(Medium) Extend the above exercise to work with all <code>Apply</code> types (not just <code>Maybe</code>). Name these new functions <code>addApply</code>, <code>subApply</code>, <code>mulApply</code>, and <code>divApply</code>.</li>
<li>(Difficult) Write a function <code>combineMaybe</code> which has type <code>forall a f. Applicative f =&gt; Maybe (f a) -&gt; f (Maybe a)</code>. This function takes an optional computation with side-effects, and returns a side-effecting computation which has an optional result.</li>
</ol>
<h2 id="applicative-validation-1"><a class="header" href="#applicative-validation-1">Applicative Validation</a></h2>
<p>The source code for this chapter defines several data types which might be used in an address book application. The details are omitted here, but the key functions which are exported by the <code>Data.AddressBook</code> module have the following types:</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address

phoneNumber :: PhoneType -&gt; String -&gt; PhoneNumber

person :: String -&gt; String -&gt; Address -&gt; Array PhoneNumber -&gt; Person
</code></pre>
<p>where <code>PhoneType</code> is defined as an algebraic data type:</p>
<pre><code class="language-haskell">data PhoneType
  = HomePhone
  | WorkPhone
  | CellPhone
  | OtherPhone
</code></pre>
<p>These functions can be used to construct a <code>Person</code> representing an address book entry. For example, the following value is defined in <code>Data.AddressBook</code>:</p>
<pre><code class="language-haskell">examplePerson :: Person
examplePerson =
  person &quot;John&quot; &quot;Smith&quot;
    (address &quot;123 Fake St.&quot; &quot;FakeTown&quot; &quot;CA&quot;)
    [ phoneNumber HomePhone &quot;555-555-5555&quot;
    , phoneNumber CellPhone &quot;555-555-0000&quot;
    ]
</code></pre>
<p>Test this value in PSCi (this result has been formatted):</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; examplePerson
{ firstName: &quot;John&quot;
, lastName: &quot;Smith&quot;
, homeAddress:
    { street: &quot;123 Fake St.&quot;
    , city: &quot;FakeTown&quot;
    , state: &quot;CA&quot;
    }
, phones:
    [ { type: HomePhone
      , number: &quot;555-555-5555&quot;
      }
    , { type: CellPhone
      , number: &quot;555-555-0000&quot;
      }
    ]
}
</code></pre>
<p>We saw in a previous section how we could use the <code>Either String</code> functor to validate a data structure of type <code>Person</code>. For example, provided functions to validate the two names in the structure, we might validate the entire data structure as follows:</p>
<pre><code class="language-haskell">nonEmpty1 :: String -&gt; Either String String
nonEmpty1 &quot;&quot;     = Left &quot;Field cannot be empty&quot;
nonEmpty1 value  = Right value

validatePerson1 :: Person -&gt; Either String Person
validatePerson1 p =
  person &lt;$&gt; nonEmpty1 p.firstName
         &lt;*&gt; nonEmpty1 p.lastName
         &lt;*&gt; pure p.homeAddress
         &lt;*&gt; pure p.phones
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePerson1Ado :: Person -&gt; Either String Person
validatePerson1Ado p = ado
  f &lt;- nonEmpty1 p.firstName
  l &lt;- nonEmpty1 p.lastName
  in person f l p.homeAddress p.phones
</code></pre>
<p>In the first two lines, we use the <code>nonEmpty1</code> function to validate a non-empty string. <code>nonEmpty1</code> returns an error indicated with the <code>Left</code> constructor if its input is empty, otherwise it returns the value wrapped with the <code>Right</code> constructor.</p>
<p>The final lines do not perform any validation but simply provide the <code>address</code> and <code>phones</code> fields to the <code>person</code> function as the remaining arguments.</p>
<p>This function can be seen to work in PSCi, but has a limitation which we have seen before:</p>
<pre><code class="language-text">&gt; validatePerson $ person &quot;&quot; &quot;&quot; (address &quot;&quot; &quot;&quot; &quot;&quot;) []
(Left &quot;Field cannot be empty&quot;)
</code></pre>
<p>The <code>Either String</code> applicative functor only provides the first error encountered. Given the input here, we would prefer to see two errors - one for the missing first name, and a second for the missing last name.</p>
<p>There is another applicative functor which is provided by the <code>validation</code> library. This functor is called <code>V</code>, and it provides the ability to return errors in any <em>semigroup</em>. For example, we can use <code>V (Array String)</code> to return an array of <code>String</code>s as errors, concatenating new errors onto the end of the array.</p>
<p>The <code>Data.AddressBook.Validation</code> module uses the <code>V (Array String)</code> applicative functor to validate the data structures in the <code>Data.AddressBook</code> module.</p>
<p>Here is an example of a validator taken from the <code>Data.AddressBook.Validation</code> module:</p>
<pre><code class="language-haskell">type Errors
  = Array String

nonEmpty :: String -&gt; String -&gt; V Errors String
nonEmpty field &quot;&quot;     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' cannot be empty&quot; ]
nonEmpty _     value  = pure value

lengthIs :: String -&gt; Int -&gt; String -&gt; V Errors String
lengthIs field len value | length value /= len =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must have length &quot; &lt;&gt; show len ]
lengthIs _     _   value = pure value

validateAddress :: Address -&gt; V Errors Address
validateAddress a =
  address &lt;$&gt; nonEmpty &quot;Street&quot;  a.street
          &lt;*&gt; nonEmpty &quot;City&quot;    a.city
          &lt;*&gt; lengthIs &quot;State&quot; 2 a.state
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validateAddressAdo :: Address -&gt; V Errors Address
validateAddressAdo a = ado
  street &lt;- nonEmpty &quot;Street&quot;  a.street
  city   &lt;- nonEmpty &quot;City&quot;    a.city
  state  &lt;- lengthIs &quot;State&quot; 2 a.state
  in address street city state
</code></pre>
<p><code>validateAddress</code> validates an <code>Address</code> structure. It checks that the <code>street</code> and <code>city</code> fields are non-empty, and checks that the string in the <code>state</code> field has length 2.</p>
<p>Notice how the <code>nonEmpty</code> and <code>lengthIs</code> validator functions both use the <code>invalid</code> function provided by the <code>Data.Validation</code> module to indicate an error. Since we are working in the <code>Array String</code> semigroup, <code>invalid</code> takes an array of strings as its argument.</p>
<p>We can try this function in PSCi:</p>
<pre><code class="language-text">&gt; import Data.AddressBook
&gt; import Data.AddressBook.Validation

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         , &quot;Field 'State' must have length 2&quot;
         ])

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;CA&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         ])
</code></pre>
<p>This time, we receive an array of all validation errors.</p>
<h2 id="regular-expression-validators"><a class="header" href="#regular-expression-validators">Regular Expression Validators</a></h2>
<p>The <code>validatePhoneNumber</code> function uses a regular expression to validate the form of its argument. The key is a <code>matches</code> validation function, which uses a <code>Regex</code> from the <code>Data.String.Regex</code> module to validate its input:</p>
<pre><code class="language-haskell">matches :: String -&gt; Regex -&gt; String -&gt; V Errors String
matches _     regex value | test regex value
                          = pure value
matches field _     _     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' did not match the required format&quot; ]
</code></pre>
<p>Again, notice how <code>pure</code> is used to indicate successful validation, and <code>invalid</code> is used to signal an array of errors.</p>
<p><code>validatePhoneNumber</code> is built from the <code>matches</code> function in the same way as before:</p>
<pre><code class="language-haskell">validatePhoneNumber :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumber pn =
  phoneNumber &lt;$&gt; pure pn.&quot;type&quot;
              &lt;*&gt; matches &quot;Number&quot; phoneNumberRegex pn.number
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePhoneNumberAdo :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumberAdo pn = ado
  tpe    &lt;- pure pn.&quot;type&quot;
  number &lt;- matches &quot;Number&quot; phoneNumberRegex pn.number
  in phoneNumber tpe number
</code></pre>
<p>Again, try running this validator against some valid and invalid inputs in PSCi:</p>
<pre><code class="language-text">&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555-555-5555&quot;
pure ({ type: HomePhone, number: &quot;555-555-5555&quot; })

&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555.555.5555&quot;
invalid ([&quot;Field 'Number' did not match the required format&quot;])
</code></pre>
<h2 id="exercises-18"><a class="header" href="#exercises-18">Exercises</a></h2>
<ol>
<li>(Easy) Write a regular expression <code>stateRegex :: Regex</code> to check that a string only contains two alphabetic characters. <em>Hint</em>: see the source code for <code>phoneNumberRegex</code>.</li>
<li>(Medium) Write a regular expression <code>nonEmptyRegex :: Regex</code> to check that a string is not entirely whitespace. <em>Hint</em>: If you need help developing this regex expression, check out <a href="https://regexr.com">RegExr</a> which has a great cheatsheet and interactive test environment.</li>
<li>(Medium) Write a function <code>validateAddressImproved</code> that is similar to <code>validateAddress</code>, but uses the above <code>stateRegex</code> to validate the <code>state</code> field and <code>nonEmptyRegex</code> to validate the <code>street</code> and <code>city</code> fields. <em>Hint</em>: see the source for <code>validatePhoneNumber</code> for an example of how to use <code>matches</code>.</li>
</ol>
<h2 id="traversable-functors"><a class="header" href="#traversable-functors">Traversable Functors</a></h2>
<p>The remaining validator is <code>validatePerson</code>, which combines the validators we have seen so far to validate an entire <code>Person</code> structure, including the following new <code>validatePhoneNumbers</code> function:</p>
<pre><code class="language-haskell">validatePhoneNumbers :: String -&gt; Array PhoneNumber -&gt; V Errors (Array PhoneNumber)
validatePhoneNumbers field []      =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must contain at least one value&quot; ]
validatePhoneNumbers _     phones  =
  traverse validatePhoneNumber phones

validatePerson :: Person -&gt; V Errors Person
validatePerson p =
  person &lt;$&gt; nonEmpty &quot;First Name&quot; p.firstName
         &lt;*&gt; nonEmpty &quot;Last Name&quot; p.lastName
         &lt;*&gt; validateAddress p.homeAddress
         &lt;*&gt; validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePersonAdo :: Person -&gt; V Errors Person
validatePersonAdo p = ado
  firstName &lt;- nonEmpty &quot;First Name&quot; p.firstName
  lastName  &lt;- nonEmpty &quot;Last Name&quot; p.lastName
  address   &lt;- validateAddress p.homeAddress
  numbers   &lt;- validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
  in person firstName lastName address numbers
</code></pre>
<p><code>validatePhoneNumbers</code> uses a new function we haven't seen before - <code>traverse</code>.</p>
<p><code>traverse</code> is defined in the <code>Data.Traversable</code> module, in the <code>Traversable</code> type class:</p>
<pre><code class="language-haskell">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p><code>Traversable</code> defines the class of <em>traversable functors</em>. The types of its functions might look a little intimidating, but <code>validatePerson</code> provides a good motivating example.</p>
<p>Every traversable functor is both a <code>Functor</code> and <code>Foldable</code> (recall that a <em>foldable functor</em> was a type constructor which supported a fold operation, reducing a structure to a single value). In addition, a traversable functor provides the ability to combine a collection of side-effects which depend on its structure.</p>
<p>This may sound complicated, but let's simplify things by specializing to the case of arrays. The array type constructor is traversable, which means that there is a function:</p>
<pre><code class="language-haskell">traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; Array a -&gt; m (Array b)
</code></pre>
<p>Intuitively, given any applicative functor <code>m</code>, and a function which takes a value of type <code>a</code> and returns a value of type <code>b</code> (with side-effects tracked by <code>m</code>), we can apply the function to each element of an array of type <code>Array a</code> to obtain a result of type <code>Array b</code> (with side-effects tracked by <code>m</code>).</p>
<p>Still not clear? Let's specialize further to the case where <code>m</code> is the <code>V Errors</code> applicative functor above. Now, we have a function of type</p>
<pre><code class="language-haskell">traverse :: forall a b. (a -&gt; V Errors b) -&gt; Array a -&gt; V Errors (Array b)
</code></pre>
<p>This type signature says that if we have a validation function <code>m</code> for a type <code>a</code>, then <code>traverse m</code> is a validation function for arrays of type <code>Array a</code>. But that's exactly what we need to be able to validate the <code>phones</code> field of the <code>Person</code> data structure! We pass <code>validatePhoneNumber</code> to <code>traverse</code> to create a validation function which validates each element successively.</p>
<p>In general, <code>traverse</code> walks over the elements of a data structure, performing computations with side-effects and accumulating a result.</p>
<p>The type signature for <code>Traversable</code>'s other function <code>sequence</code> might look more familiar:</p>
<pre><code class="language-haskell">sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p>In fact, the <code>combineList</code> function that we wrote earlier is just a special case of the <code>sequence</code> function from the <code>Traversable</code> type class. Setting <code>t</code> to be the type constructor <code>List</code>, we recover the type of the <code>combineList</code> function:</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>Traversable functors capture the idea of traversing a data structure, collecting a set of effectful computations, and combining their effects. In fact, <code>sequence</code> and <code>traverse</code> are equally important to the definition of <code>Traversable</code> - each can be implemented in terms of each other. This is left as an exercise for the interested reader.</p>
<p>The <code>Traversable</code> instance for lists given in the <code>Data.List</code> module is:</p>
<pre><code class="language-haskell">instance traversableList :: Traversable List where
-- traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; List a -&gt; m (List b)
traverse _ Nil         = pure Nil
traverse f (Cons x xs) = Cons &lt;$&gt; f x &lt;*&gt; traverse f xs
</code></pre>
<p>(The actual definition was later modified to improve stack safety. You can read more about that change <a href="https://github.com/purescript/purescript-lists/pull/87">here</a>.)</p>
<p>In the case of an empty list, we can simply return an empty list using <code>pure</code>. If the list is non-empty, we can use the function <code>f</code> to create a computation of type <code>f b</code> from the head element. We can also call <code>traverse</code> recursively on the tail. Finally, we can lift the <code>Cons</code> constructor over the applicative functor <code>m</code> to combine the two results.</p>
<p>But there are more examples of traversable functors than just arrays and lists. The <code>Maybe</code> type constructor we saw earlier also has an instance for <code>Traversable</code>. We can try it in PSCi:</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; import Data.Traversable
&gt; import Data.AddressBook.Validation

&gt; traverse (nonEmpty &quot;Example&quot;) Nothing
pure (Nothing)

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;&quot;)
invalid ([&quot;Field 'Example' cannot be empty&quot;])

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;Testing&quot;)
pure ((Just &quot;Testing&quot;))
</code></pre>
<p>These examples show that traversing the <code>Nothing</code> value returns <code>Nothing</code> with no validation, and traversing <code>Just x</code> uses the validation function to validate <code>x</code>. That is, <code>traverse</code> takes a validation function for type <code>a</code> and returns a validation function for <code>Maybe a</code>, i.e. a validation function for optional values of type <code>a</code>.</p>
<p>Other traversable functors include <code>Array</code>, and <code>Tuple a</code> and <code>Either a</code> for any type <code>a</code>. Generally, most &quot;container&quot; data type constructors have <code>Traversable</code> instances. As an example, the exercises will include writing a <code>Traversable</code> instance for a type of binary trees.</p>
<h2 id="exercises-19"><a class="header" href="#exercises-19">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write <code>Eq</code> and <code>Show</code> instances for the following binary tree data structure:</p>
<pre><code class="language-haskell">data Tree a = Leaf | Branch (Tree a) a (Tree a)
</code></pre>
<p>Recall from the previous chapter that you may either write these instances manually or let the compiler derive them for you.</p>
<p>There are many &quot;correct&quot; formatting options for <code>Show</code> output. The test for this exercise expects the following whitespace style. This happens to match the default formatting of generic show, so you only need to make note of this if you're planning on writing this instance manually.</p>
<pre><code class="language-haskell">(Branch (Branch Leaf 8 Leaf) 42 Leaf)
</code></pre>
</li>
<li>
<p>(Medium) Write a <code>Traversable</code> instance for <code>Tree a</code>, which combines side-effects from left-to-right. <em>Hint</em>: There are some additional instance dependencies that need to be defined for <code>Traversable</code>.</p>
</li>
<li>
<p>(Medium) Write a function <code>traversePreOrder :: forall a m b. Applicative m =&gt; (a -&gt; m b) -&gt; Tree a -&gt; m (Tree b)</code> that performs a pre-order traversal of the tree. This means the order of effect execution is root-left-right, instead of left-root-right as was done for the previous in-order traverse exercise. <em>Hint</em>: No additional instances need to be defined, and you don't need to call any of the the functions defined earlier. Applicative do notation (<code>ado</code>) is the easiest way to write this function.</p>
</li>
<li>
<p>(Medium) Write a function <code>traversePostOrder</code> that performs a post-order traversal of the tree where effects are executed left-right-root.</p>
</li>
<li>
<p>(Medium) Create a new version of the <code>Person</code> type where the <code>homeAddress</code> field is optional (using <code>Maybe</code>). Then write a new version of <code>validatePerson</code> (renamed as <code>validatePersonOptionalAddress</code>) to validate this new <code>Person</code>. <em>Hint</em>: Use <code>traverse</code> to validate a field of type <code>Maybe a</code>.</p>
</li>
<li>
<p>(Difficult) Write a function <code>sequenceUsingTraverse</code> which behaves like <code>sequence</code>, but is written in terms of <code>traverse</code>.</p>
</li>
<li>
<p>(Difficult) Write a function <code>traverseUsingSequence</code> which behaves like <code>traverse</code>, but is written in terms of <code>sequence</code>.</p>
</li>
</ol>
<h2 id="applicative-functors-for-parallelism"><a class="header" href="#applicative-functors-for-parallelism">Applicative Functors for Parallelism</a></h2>
<p>In the discussion above, I chose the word &quot;combine&quot; to describe how applicative functors &quot;combine side-effects&quot;. However, in all the examples given, it would be equally valid to say that applicative functors allow us to &quot;sequence&quot; effects. This would be consistent with the intuition that traversable functors provide a <code>sequence</code> function to combine effects in sequence based on a data structure.</p>
<p>However, in general, applicative functors are more general than this. The applicative functor laws do not impose any ordering on the side-effects that their computations perform. In fact, it would be valid for an applicative functor to perform its side-effects in parallel.</p>
<p>For example, the <code>V</code> validation functor returned an <em>array</em> of errors, but it would work just as well if we picked the <code>Set</code> semigroup, in which case it would not matter what order we ran the various validators. We could even run them in parallel over the data structure!</p>
<p>As a second example, the <code>parallel</code> package provides a type class <code>Parallel</code> which supports <em>parallel computations</em>. <code>Parallel</code> provides a function <code>parallel</code> which uses some <code>Applicative</code> functor to compute the result of its input computation <em>in parallel</em>:</p>
<pre><code class="language-haskell">f &lt;$&gt; parallel computation1
  &lt;*&gt; parallel computation2
</code></pre>
<p>This computation would start computing values asynchronously using <code>computation1</code> and <code>computation2</code>. When both results have been computed, they would be combined into a single result using the function <code>f</code>.</p>
<p>We will see this idea in more detail when we apply applicative functors to the problem of <em>callback hell</em> later in the book.</p>
<p>Applicative functors are a natural way to capture side-effects which can be combined in parallel.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>In this chapter, we covered a lot of new ideas:</p>
<ul>
<li>We introduced the concept of an <em>applicative functor</em> which generalizes the idea of function application to type constructors which capture some notion of side-effect.</li>
<li>We saw how applicative functors gave a solution to the problem of validating data structures, and how by switching the applicative functor we could change from reporting a single error to reporting all errors across a data structure.</li>
<li>We met the <code>Traversable</code> type class, which encapsulates the idea of a <em>traversable functor</em>, or a container whose elements can be used to combine values with side-effects.</li>
</ul>
<p>Applicative functors are an interesting abstraction which provide neat solutions to a number of problems. We will see them a few more times throughout the book. In this case, the validation applicative functor provided a way to write validators in a declarative style, allowing us to define <em>what</em> our validators should validate and not <em>how</em> they should perform that validation. In general, we will see that applicative functors are a useful tool for the design of <em>domain specific languages</em>.</p>
<p>In the next chapter, we will see a related idea, the class of <em>monads</em>, and extend our address book example to run in the browser!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-effect-monad"><a class="header" href="#the-effect-monad">The Effect Monad</a></h1>
<h2 id="chapter-goals-6"><a class="header" href="#chapter-goals-6">Chapter Goals</a></h2>
<p>In the last chapter, we introduced applicative functors, an abstraction which we used to deal with <em>side-effects</em>: optional values, error messages and validation. This chapter will introduce another abstraction for dealing with side-effects in a more expressive way: <em>monads</em>.</p>
<p>The goal of this chapter is to explain why monads are a useful abstraction, and their connection with <em>do notation</em>.</p>
<h2 id="project-setup-5"><a class="header" href="#project-setup-5">Project Setup</a></h2>
<p>The project adds the following dependencies:</p>
<ul>
<li><code>effect</code> - defines the <code>Effect</code> monad, the subject of the second half of the chapter. This dependency is often listed in every starter project (it's been a dependency of every chapter so far), so you'll rarely have to explicitly install it.</li>
<li><code>react-basic-hooks</code> - a web framework that we will use for our Address Book app.</li>
</ul>
<h2 id="monads-and-do-notation"><a class="header" href="#monads-and-do-notation">Monads and Do Notation</a></h2>
<p>Do notation was first introduced when we covered <em>array comprehensions</em>. Array comprehensions provide syntactic sugar for the <code>concatMap</code> function from the <code>Data.Array</code> module.</p>
<p>Consider the following example. Suppose we throw two dice and want to count the number of ways in which we can score a total of <code>n</code>. We could do this using the following non-deterministic algorithm:</p>
<ul>
<li><em>Choose</em> the value <code>x</code> of the first throw.</li>
<li><em>Choose</em> the value <code>y</code> of the second throw.</li>
<li>If the sum of <code>x</code> and <code>y</code> is <code>n</code> then return the pair <code>[x, y]</code>, else fail.</li>
</ul>
<p>Array comprehensions allow us to write this non-deterministic algorithm in a natural way:</p>
<pre><code class="language-hs">import Prelude

import Control.Plus (empty)
import Data.Array ((..))

countThrows :: Int -&gt; Array (Array Int)
countThrows n = do
  x &lt;- 1 .. 6
  y &lt;- 1 .. 6
  if x + y == n
    then pure [ x, y ]
    else empty
</code></pre>
<p>We can see that this function works in PSCi:</p>
<pre><code class="language-text">&gt; import Test.Examples

&gt; countThrows 10
[[4,6],[5,5],[6,4]]

&gt; countThrows 12
[[6,6]]
</code></pre>
<p>In the last chapter, we formed an intuition for the <code>Maybe</code> applicative functor, embedding PureScript functions into a larger programming language supporting <em>optional values</em>. In the same way, we can form an intuition for the <em>array monad</em>, embedding PureScript functions into a larger programming language supporting <em>non-deterministic choice</em>.</p>
<p>In general, a <em>monad</em> for some type constructor <code>m</code> provides a way to use do notation with values of type <code>m a</code>. Note that in the array comprehension above, every line contains a computation of type <code>Array a</code> for some type <code>a</code>. In general, every line of a do notation block will contain a computation of type <code>m a</code> for some type <code>a</code> and our monad <code>m</code>. The monad <code>m</code> must be the same on every line (i.e. we fix the side-effect), but the types <code>a</code> can differ (i.e. individual computations can have different result types).</p>
<p>Here is another example of do notation, this time applied to the type constructor <code>Maybe</code>. Suppose we have some type <code>XML</code> representing XML nodes, and a function</p>
<pre><code class="language-hs">child :: XML -&gt; String -&gt; Maybe XML
</code></pre>
<p>which looks for a child element of a node, and returns <code>Nothing</code> if no such element exists.</p>
<p>In this case, we can look for a deeply-nested element by using do notation. Suppose we wanted to read a user's city from a user profile which had been encoded as an XML document:</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p>The <code>userCity</code> function looks for a child element <code>profile</code>, an element <code>address</code> inside the <code>profile</code> element, and finally an element <code>city</code> inside the <code>address</code> element. If any of these elements are missing, the return value will be <code>Nothing</code>. Otherwise, the return value is constructed using <code>Just</code> from the <code>city</code> node.</p>
<p>Remember, the <code>pure</code> function in the last line is defined for every <code>Applicative</code> functor. Since <code>pure</code> is defined as <code>Just</code> for the <code>Maybe</code> applicative functor, it would be equally valid to change the last line to <code>Just city</code>.</p>
<h2 id="the-monad-type-class"><a class="header" href="#the-monad-type-class">The Monad Type Class</a></h2>
<p>The <code>Monad</code> type class is defined as follows:</p>
<pre><code class="language-hs">class Apply m &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

class (Applicative m, Bind m) &lt;= Monad m
</code></pre>
<p>The key function here is <code>bind</code>, defined in the <code>Bind</code> type class. Just like for the <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> operators in the <code>Functor</code> and <code>Apply</code> type classes, the Prelude defines an infix alias <code>&gt;&gt;=</code> for the <code>bind</code> function.</p>
<p>The <code>Monad</code> type class extends <code>Bind</code> with the operations of the <code>Applicative</code> type class that we have already seen.</p>
<p>It will be useful to see some examples of the <code>Bind</code> type class. A sensible definition for <code>Bind</code> on arrays can be given as follows:</p>
<pre><code class="language-hs">instance bindArray :: Bind Array where
  bind xs f = concatMap f xs
</code></pre>
<p>This explains the connection between array comprehensions and the <code>concatMap</code> function that has been alluded to before.</p>
<p>Here is an implementation of <code>Bind</code> for the <code>Maybe</code> type constructor:</p>
<pre><code class="language-hs">instance bindMaybe :: Bind Maybe where
  bind Nothing  _ = Nothing
  bind (Just a) f = f a
</code></pre>
<p>This definition confirms the intuition that missing values are propagated through a do notation block.</p>
<p>Let's see how the <code>Bind</code> type class is related to do notation. Consider a simple do notation block which starts by binding a value from the result of some computation:</p>
<pre><code class="language-hs">do value &lt;- someComputation
   whatToDoNext
</code></pre>
<p>Every time the PureScript compiler sees this pattern, it replaces the code with this:</p>
<pre><code class="language-hs">bind someComputation \value -&gt; whatToDoNext
</code></pre>
<p>or, written infix:</p>
<pre><code class="language-hs">someComputation &gt;&gt;= \value -&gt; whatToDoNext
</code></pre>
<p>The computation <code>whatToDoNext</code> is allowed to depend on <code>value</code>.</p>
<p>If there are multiple binds involved, this rule is applied multiple times, starting from the top. For example, the <code>userCity</code> example that we saw earlier gets desugared as follows:</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root =
  child root &quot;profile&quot; &gt;&gt;= \prof -&gt;
    child prof &quot;address&quot; &gt;&gt;= \addr -&gt;
      child addr &quot;city&quot; &gt;&gt;= \city -&gt;
        pure city
</code></pre>
<p>It is worth noting that code expressed using do notation is often much clearer than the equivalent code using the <code>&gt;&gt;=</code> operator. However, writing binds explicitly using <code>&gt;&gt;=</code> can often lead to opportunities to write code in <em>point-free</em> form - but the usual warnings about readability apply.</p>
<h2 id="monad-laws"><a class="header" href="#monad-laws">Monad Laws</a></h2>
<p>The <code>Monad</code> type class comes equipped with three laws, called the <em>monad laws</em>. These tell us what we can expect from sensible implementations of the <code>Monad</code> type class.</p>
<p>It is simplest to explain these laws using do notation.</p>
<h3 id="identity-laws"><a class="header" href="#identity-laws">Identity Laws</a></h3>
<p>The <em>right-identity</em> law is the simplest of the three laws. It tells us that we can eliminate a call to <code>pure</code> if it is the last expression in a do notation block:</p>
<pre><code class="language-hs">do
  x &lt;- expr
  pure x
</code></pre>
<p>The right-identity law says that this is equivalent to just <code>expr</code>.</p>
<p>The <em>left-identity</em> law states that we can eliminate a call to <code>pure</code> if it is the first expression in a do notation block:</p>
<pre><code class="language-hs">do
  x &lt;- pure y
  next
</code></pre>
<p>This code is equivalent to <code>next</code>, after the name <code>x</code> has been replaced with the expression <code>y</code>.</p>
<p>The last law is the <em>associativity law</em>. It tells us how to deal with nested do notation blocks. It states that the following piece of code:</p>
<pre><code class="language-hs">c1 = do
  y &lt;- do
    x &lt;- m1
    m2
  m3
</code></pre>
<p>is equivalent to this code:</p>
<pre><code class="language-hs">c2 = do
  x &lt;- m1
  y &lt;- m2
  m3
</code></pre>
<p>Each of these computations involves three monadic expression <code>m1</code>, <code>m2</code> and <code>m3</code>. In each case, the result of <code>m1</code> is eventually bound to the name <code>x</code>, and the result of <code>m2</code> is bound to the name <code>y</code>.</p>
<p>In <code>c1</code>, the two expressions <code>m1</code> and <code>m2</code> are grouped into their own do notation block.</p>
<p>In <code>c2</code>, all three expressions <code>m1</code>, <code>m2</code> and <code>m3</code> appear in the same do notation block.</p>
<p>The associativity law tells us that it is safe to simplify nested do notation blocks in this way.</p>
<p><em>Note</em> that by the definition of how do notation gets desugared into calls to <code>bind</code>, both of <code>c1</code> and <code>c2</code> are also equivalent to this code:</p>
<pre><code class="language-hs">c3 = do
  x &lt;- m1
  do
    y &lt;- m2
    m3
</code></pre>
<h2 id="folding-with-monads"><a class="header" href="#folding-with-monads">Folding With Monads</a></h2>
<p>As an example of working with monads abstractly, this section will present a function which works with any type constructor in the <code>Monad</code> type class. This should serve to solidify the intuition that monadic code corresponds to programming &quot;in a larger language&quot; with side-effects, and also illustrate the generality which programming with monads brings.</p>
<p>The function we will write is called <code>foldM</code>. It generalizes the <code>foldl</code> function that we met earlier to a monadic context. Here is its type signature:</p>
<pre><code class="language-hs">foldM :: forall m a b. Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; List b -&gt; m a
foldl :: forall   a b.            (a -&gt; b -&gt;   a) -&gt; a -&gt; List b -&gt;   a
</code></pre>
<p>Notice that this is the same as the type of <code>foldl</code>, except for the appearance of the monad <code>m</code>.</p>
<p>Intuitively, <code>foldM</code> performs a fold over a list in some context supporting some set of side-effects.</p>
<p>For example, if we picked <code>m</code> to be <code>Maybe</code>, then our fold would be allowed to fail by returning <code>Nothing</code> at any stage - every step returns an optional result, and the result of the fold is therefore also optional.</p>
<p>If we picked <code>m</code> to be the <code>Array</code> type constructor, then every step of the fold would be allowed to return zero or more results, and the fold would proceed to the next step independently for each result. At the end, the set of results would consist of all folds over all possible paths. This corresponds to a traversal of a graph!</p>
<p>To write <code>foldM</code>, we can simply break the input list into cases.</p>
<p>If the list is empty, then to produce the result of type <code>a</code>, we only have one option: we have to return the second argument:</p>
<pre><code class="language-hs">foldM _ a Nil = pure a
</code></pre>
<p>Note that we have to use <code>pure</code> to lift <code>a</code> into the monad <code>m</code>.</p>
<p>What if the list is non-empty? In that case, we have a value of type <code>a</code>, a value of type <code>b</code>, and a function of type <code>a -&gt; b -&gt; m a</code>. If we apply the function, we obtain a monadic result of type <code>m a</code>. We can bind the result of this computation with a backwards arrow <code>&lt;-</code>.</p>
<p>It only remains to recurse on the tail of the list. The implementation is simple:</p>
<pre><code class="language-hs">foldM f a (b : bs) = do
  a' &lt;- f a b
  foldM f a' bs
</code></pre>
<p>Note that this implementation is almost identical to that of <code>foldl</code> on lists, with the exception of do notation.</p>
<p>We can define and test this function in PSCi. Here is an example - suppose we defined a &quot;safe division&quot; function on integers, which tested for division by zero and used the <code>Maybe</code> type constructor to indicate failure:</p>
<pre><code class="language-hs">safeDivide :: Int -&gt; Int -&gt; Maybe Int
safeDivide _ 0 = Nothing
safeDivide a b = Just (a / b)
</code></pre>
<p>Then we can use <code>foldM</code> to express iterated safe division:</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.List (fromFoldable)

&gt; foldM safeDivide 100 (fromFoldable [5, 2, 2])
(Just 5)

&gt; foldM safeDivide 100 (fromFoldable [2, 0, 4])
Nothing
</code></pre>
<p>The <code>foldM safeDivide</code> function returns <code>Nothing</code> if a division by zero was attempted at any point. Otherwise it returns the result of repeatedly dividing the accumulator, wrapped in the <code>Just</code> constructor.</p>
<h2 id="monads-and-applicatives"><a class="header" href="#monads-and-applicatives">Monads and Applicatives</a></h2>
<p>Every instance of the <code>Monad</code> type class is also an instance of the <code>Apply</code> type class, by virtue of the superclass relationship between the two classes.</p>
<p>However, there is also an implementation of the <code>Apply</code> type class which comes &quot;for free&quot; for any instance of <code>Monad</code>, given by the <code>ap</code> function:</p>
<pre><code class="language-hs">ap :: forall m a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
ap mf ma = do
  f &lt;- mf
  a &lt;- ma
  pure (f a)
</code></pre>
<p>If <code>m</code> is a law-abiding member of the <code>Monad</code> type class, then there is a valid <code>Apply</code> instance for <code>m</code> given by <code>ap</code>.</p>
<p>The interested reader can check that <code>ap</code> agrees with <code>apply</code> for the monads we have already encountered: <code>Array</code>, <code>Maybe</code> and <code>Either e</code>.</p>
<p>If every monad is also an applicative functor, then we should be able to apply our intuition for applicative functors to every monad. In particular, we can reasonably expect a monad to correspond, in some sense, to programming &quot;in a larger language&quot; augmented with some set of additional side-effects. We should be able to lift functions of arbitrary arities, using <code>map</code> and <code>apply</code>, into this new language.</p>
<p>But monads allow us to do more than we could do with just applicative functors, and the key difference is highlighted by the syntax of do notation. Consider the <code>userCity</code> example again, in which we looked for a user's city in an XML document which encoded their user profile:</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p>Do notation allows the second computation to depend on the result <code>prof</code> of the first, and the third computation to depend on the result <code>addr</code> of the second, and so on. This dependence on previous values is not possible using only the interface of the <code>Applicative</code> type class.</p>
<p>Try writing <code>userCity</code> using only <code>pure</code> and <code>apply</code>: you will see that it is impossible. Applicative functors only allow us to lift function arguments which are independent of each other, but monads allow us to write computations which involve more interesting data dependencies.</p>
<p>In the last chapter, we saw that the <code>Applicative</code> type class can be used to express parallelism. This was precisely because the function arguments being lifted were independent of one another. Since the <code>Monad</code> type class allows computations to depend on the results of previous computations, the same does not apply - a monad has to combine its side-effects in sequence.</p>
<h2 id="exercises-20"><a class="header" href="#exercises-20">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a function <code>third</code> which returns the third element of an array with three or more elements. Your function should return an appropriate <code>Maybe</code> type. <em>Hint:</em> Look up the types of the <code>head</code> and <code>tail</code> functions from the <code>Data.Array</code> module in the <code>arrays</code> package. Use do notation with the <code>Maybe</code> monad to combine these functions.</p>
</li>
<li>
<p>(Medium) Write a function <code>possibleSums</code> which uses <code>foldM</code> to determine all possible totals that could be made using a set of coins. The coins will be specified as an array which contains the value of each coin. Your function should have the following result:</p>
<pre><code class="language-text">&gt; possibleSums []
[0]

&gt; possibleSums [1, 2, 10]
[0,1,2,3,10,11,12,13]
</code></pre>
<p><em>Hint</em>: This function can be written as a one-liner using <code>foldM</code>. You might want to use the <code>nub</code> and <code>sort</code> functions to remove duplicates and sort the result respectively.</p>
</li>
<li>
<p>(Medium) Confirm that the <code>ap</code> function and the <code>apply</code> operator agree for the <code>Maybe</code> monad. <em>Note:</em> There are no tests for this exercise.</p>
</li>
<li>
<p>(Medium) Verify that the monad laws hold for the <code>Monad</code> instance for the <code>Maybe</code> type, as defined in the <code>maybe</code> package. <em>Note:</em> There are no tests for this exercise.</p>
</li>
<li>
<p>(Medium) Write a function <code>filterM</code> which generalizes the <code>filter</code> function on lists. Your function should have the following type signature:</p>
<pre><code class="language-hs">filterM :: forall m a. Monad m =&gt; (a -&gt; m Boolean) -&gt; List a -&gt; m (List a)
</code></pre>
</li>
<li>
<p>(Difficult) Every monad has a default <code>Functor</code> instance given by:</p>
<pre><code class="language-hs">map f a = do
  x &lt;- a
  pure (f x)
</code></pre>
<p>Use the monad laws to prove that for any monad, the following holds:</p>
<pre><code class="language-hs">lift2 f (pure a) (pure b) = pure (f a b)
</code></pre>
<p>where the <code>Apply</code> instance uses the <code>ap</code> function defined above. Recall that <code>lift2</code> was defined as follows:</p>
<pre><code class="language-hs">lift2 :: forall f a b c. Apply f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
lift2 f a b = f &lt;$&gt; a &lt;*&gt; b
</code></pre>
<p><em>Note:</em> There are no tests for this exercise.</p>
</li>
</ol>
<h2 id="native-effects"><a class="header" href="#native-effects">Native Effects</a></h2>
<p>We will now look at one particular monad which is of central importance in PureScript - the <code>Effect</code> monad.</p>
<p>The <code>Effect</code> monad is defined in the <code>Effect</code> module. It is used to manage so-called <em>native</em> side-effects. If you are familiar with Haskell, it is the equivalent of the <code>IO</code> monad.</p>
<p>What are native side-effects? They are the side-effects which distinguish JavaScript expressions from idiomatic PureScript expressions, which typically are free from side-effects. Some examples of native effects are:</p>
<ul>
<li>Console IO</li>
<li>Random number generation</li>
<li>Exceptions</li>
<li>Reading/writing mutable state</li>
</ul>
<p>And in the browser:</p>
<ul>
<li>DOM manipulation</li>
<li>XMLHttpRequest / AJAX calls</li>
<li>Interacting with a websocket</li>
<li>Writing/reading to/from local storage</li>
</ul>
<p>We have already seen plenty of examples of &quot;non-native&quot; side-effects:</p>
<ul>
<li>Optional values, as represented by the <code>Maybe</code> data type</li>
<li>Errors, as represented by the <code>Either</code> data type</li>
<li>Multi-functions, as represented by arrays or lists</li>
</ul>
<p>Note that the distinction is subtle. It is true, for example, that an error message is a possible side-effect of a JavaScript expression, in the form of an exception. In that sense, exceptions do represent native side-effects, and it is possible to represent them using <code>Effect</code>. However, error messages implemented using <code>Either</code> are not a side-effect of the JavaScript runtime, and so it is not appropriate to implement error messages in that style using <code>Effect</code>. So it is not the effect itself which is native, but rather how it is implemented at runtime.</p>
<h2 id="side-effects-and-purity"><a class="header" href="#side-effects-and-purity">Side-Effects and Purity</a></h2>
<p>In a pure language like PureScript, one question which presents itself is: without side-effects, how can one write useful real-world code?</p>
<p>The answer is that PureScript does not aim to eliminate side-effects. It aims to represent side-effects in such a way that pure computations can be distinguished from computations with side-effects in the type system. In this sense, the language is still pure.</p>
<p>Values with side-effects have different types from pure values. As such, it is not possible to pass a side-effecting argument to a function, for example, and have side-effects performed unexpectedly.</p>
<p>The only way in which side-effects managed by the <code>Effect</code> monad will be presented is to run a computation of type <code>Effect a</code> from JavaScript.</p>
<p>The Spago build tool (and other tools) provide a shortcut, by generating additional JavaScript to invoke the <code>main</code> computation when the application starts. <code>main</code> is required to be a computation in the <code>Effect</code> monad.</p>
<h2 id="the-effect-monad-1"><a class="header" href="#the-effect-monad-1">The Effect Monad</a></h2>
<p>The <code>Effect</code> monad provides a well-typed API for computations with side-effects, while at the same time generating efficient JavaScript.</p>
<p>Let's take a closer look at the return type of the familiar <code>log</code> function. <code>Effect</code> indicates that this function produces a native effect, console IO in this case.
<code>Unit</code> indicates that no <em>meaningful</em> data is returned. You can think of <code>Unit</code> as being analogous to the <code>void</code> keyword in other languages, such as C, Java, etc.</p>
<pre><code class="language-hs">log :: String -&gt; Effect Unit
</code></pre>
<blockquote>
<p><em>Aside:</em> You may encounter IDE suggestions for the more general (and more elaborately typed) <code>log</code> function from <code>Effect.Class.Console</code>. This is interchangeable with the one from <code>Effect.Console</code> when dealing with the basic <code>Effect</code> monad. Reasons for the more general version will become clearer after reading about &quot;Monad Transformers&quot; in the &quot;Monadic Adventures&quot; chapter. For the curious (and impatient), this works because there's a <code>MonadEffect</code> instance for <code>Effect</code>.</p>
<pre><code class="language-hs">log :: forall m. MonadEffect m =&gt; String -&gt; m Unit
</code></pre>
</blockquote>
<p>Now let's consider an <code>Effect</code> that returns meaningful data. The <code>random</code> function from <code>Effect.Random</code> produces a random <code>Number</code>.</p>
<pre><code class="language-hs">random :: Effect Number
</code></pre>
<p>Here's a full example program (found in <code>test/Random.purs</code> of this chapter's exercises folder).</p>
<pre><code class="language-hs">module Test.Random where

import Prelude
import Effect (Effect)
import Effect.Random (random)
import Effect.Console (logShow)

main :: Effect Unit
main = do
  n &lt;- random
  logShow n
</code></pre>
<p>Because <code>Effect</code> is a monad, we use do notation to <em>unwrap</em> the data it contains before passing this data on to the effectful <code>logShow</code> function. As a refresher, here's the equivalent code written using the <code>bind</code> operator:</p>
<pre><code class="language-hs">main :: Effect Unit
main = random &gt;&gt;= logShow
</code></pre>
<p>Try running this yourself with:</p>
<pre><code class="language-shell">spago run --main Test.Random
</code></pre>
<p>You should see a randomly chosen number between <code>0.0</code> and <code>1.0</code> printed to the console.</p>
<blockquote>
<p><em>Aside:</em> <code>spago run</code> defaults to searching in the <code>Main</code> module for a <code>main</code> function. You may also specify an alternate module as an entry point with the <code>--main</code> flag, as is done in the above example. Just be sure that this alternate module also contains a <code>main</code> function.</p>
</blockquote>
<p>Note that it's also possible to generate &quot;random&quot; (technically pseudorandom) data without resorting to impure effectful code. We'll cover these techniques in the &quot;Generative Testing&quot; chapter.</p>
<p>As mentioned previously, the <code>Effect</code> monad is of central importance to PureScript. The reason why it's central is because it is the conventional way to interoperate with PureScript's <code>Foreign Function Interface</code>, which provides the mechanism to execute a program and perform side effects. While it's desireable to avoid using the <code>Foreign Function Interface</code>, it's fairly critical to understand how it works and how to use it, so I recommend reading that chapter before doing any serious PureScript work. That said, the <code>Effect</code> monad is fairly simple. It has a few helper functions, but aside from that it doesn't do much except encapsulate side effects.</p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>Let's examine a function from the <code>node-fs</code> package that involves two <em>native</em> side effects: reading mutable state, and exceptions:</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; String -&gt; Effect String
</code></pre>
<p>If we attempt to read a file that does not exist:</p>
<pre><code class="language-hs">import Node.Encoding (Encoding(..))
import Node.FS.Sync (readTextFile)

main :: Effect Unit
main = do
  lines &lt;- readTextFile UTF8 &quot;iDoNotExist.md&quot;
  log lines
</code></pre>
<p>We encounter the following exception:</p>
<pre><code class="language-text">    throw err;
    ^
Error: ENOENT: no such file or directory, open 'iDoNotExist.md'
...
  errno: -2,
  syscall: 'open',
  code: 'ENOENT',
  path: 'iDoNotExist.md'
</code></pre>
<p>To manage this exception gracefully, we can wrap the potentially problematic code in <code>try</code> to handle either outcome:</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  result &lt;- try $ readTextFile UTF8 &quot;iDoNotExist.md&quot;
  case result of
    Right lines -&gt; log $ &quot;Contents: \n&quot; &lt;&gt; lines
    Left  error -&gt; log $ &quot;Couldn't open file. Error was: &quot; &lt;&gt; message error
</code></pre>
<p><code>try</code> runs an <code>Effect</code> and returns eventual exceptions as a <code>Left</code> value. If the computation succeeds, the result gets wrapped in a <code>Right</code>:</p>
<pre><code class="language-hs">try :: forall a. Effect a -&gt; Effect (Either Error a)
</code></pre>
<p>We can also generate our own exceptions. Here is an alternative implementation of <code>Data.List.head</code> which throws an exception if the list is empty, rather than returning a <code>Maybe</code> value of <code>Nothing</code>.</p>
<pre><code class="language-hs">exceptionHead :: List Int -&gt; Effect Int
exceptionHead l = case l of
  x : _ -&gt; pure x
  Nil -&gt; throwException $ error &quot;empty list&quot;
</code></pre>
<p>Note that the <code>exceptionHead</code> function is a somewhat impractical example, as it is best to avoid generating exceptions in PureScript code and instead use non-native effects such as <code>Either</code> and <code>Maybe</code> to manage errors and missing values.</p>
<h2 id="mutable-state"><a class="header" href="#mutable-state">Mutable State</a></h2>
<p>There is another effect defined in the core libraries: the <code>ST</code> effect.</p>
<p>The <code>ST</code> effect is used to manipulate mutable state. As pure functional programmers, we know that shared mutable state can be problematic. However, the <code>ST</code> effect uses the type system to restrict sharing in such a way that only safe <em>local</em> mutation is allowed.</p>
<p>The <code>ST</code> effect is defined in the <code>Control.Monad.ST</code> module. To see how it works, we need to look at the types of its actions:</p>
<pre><code class="language-hs">new :: forall a r. a -&gt; ST r (STRef r a)

read :: forall a r. STRef r a -&gt; ST r a

write :: forall a r. a -&gt; STRef r a -&gt; ST r a

modify :: forall r a. (a -&gt; a) -&gt; STRef r a -&gt; ST r a
</code></pre>
<p><code>new</code> is used to create a new mutable reference cell of type <code>STRef r a</code>, which can be read using the <code>read</code> action, and modified using the <code>write</code> and <code>modify</code> actions. The type <code>a</code> is the type of the value stored in the cell, and the type <code>r</code> is used to indicate a <em>memory region</em> (or <em>heap</em>) in the type system.</p>
<p>Here is an example. Suppose we want to simulate the movement of a particle falling under gravity by iterating a simple update function over a large number of small time steps.</p>
<p>We can do this by creating a mutable reference cell to hold the position and velocity of the particle, and then using a <code>for</code> loop to update the value stored in that cell:</p>
<pre><code class="language-hs">import Prelude

import Control.Monad.ST.Ref (modify, new, read)
import Control.Monad.ST (ST, for, run)

simulate :: forall r. Number -&gt; Number -&gt; Int -&gt; ST r Number
simulate x0 v0 time = do
  ref &lt;- new { x: x0, v: v0 }
  for 0 (time * 1000) \_ -&gt;
    modify
      ( \o -&gt;
          { v: o.v - 9.81 * 0.001
          , x: o.x + o.v * 0.001
          }
      )
      ref
  final &lt;- read ref
  pure final.x
</code></pre>
<p>At the end of the computation, we read the final value of the reference cell, and return the position of the particle.</p>
<p>Note that even though this function uses mutable state, it is still a pure function, so long as the reference cell <code>ref</code> is not allowed to be used by other parts of the program. We will see that this is exactly what the <code>ST</code> effect disallows.</p>
<p>To run a computation with the <code>ST</code> effect, we have to use the <code>run</code> function:</p>
<pre><code class="language-hs">run :: forall a. (forall r. ST r a) -&gt; a
</code></pre>
<p>The thing to notice here is that the region type <code>r</code> is quantified <em>inside the parentheses</em> on the left of the function arrow. That means that whatever action we pass to <code>run</code> has to work with <em>any region</em> <code>r</code> whatsoever.</p>
<p>However, once a reference cell has been created by <code>new</code>, its region type is already fixed, so it would be a type error to try to use the reference cell outside the code delimited by <code>run</code>.  This is what allows <code>run</code> to safely remove the <code>ST</code> effect, and turn <code>simulate</code> into a pure function!</p>
<pre><code class="language-hs">simulate' :: Number -&gt; Number -&gt; Int -&gt; Number
simulate' x0 v0 time = run (simulate x0 v0 time)
</code></pre>
<p>You can even try running this function in PSCi:</p>
<pre><code class="language-text">&gt; import Main

&gt; simulate' 100.0 0.0 0
100.00

&gt; simulate' 100.0 0.0 1
95.10

&gt; simulate' 100.0 0.0 2
80.39

&gt; simulate' 100.0 0.0 3
55.87

&gt; simulate' 100.0 0.0 4
21.54
</code></pre>
<p>In fact, if we inline the definition of <code>simulate</code> at the call to <code>run</code>, as follows:</p>
<pre><code class="language-hs">simulate :: Number -&gt; Number -&gt; Int -&gt; Number
simulate x0 v0 time =
  run do
    ref &lt;- new { x: x0, v: v0 }
    for 0 (time * 1000) \_ -&gt;
      modify
        ( \o -&gt;
            { v: o.v - 9.81 * 0.001
            , x: o.x + o.v * 0.001
            }
        )
        ref
    final &lt;- read ref
    pure final.x
</code></pre>
<p>then the compiler will notice that the reference cell is not allowed to escape its scope, and can safely turn <code>ref</code> into a <code>var</code>. Here is the generated JavaScript for <code>simulate</code> inlined with <code>run</code>:</p>
<pre><code class="language-javascript">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return (function __do() {

        var ref = { value: { x: x0, v: v0 } };

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        return ref.value.x;

      })();
    };
  };
};
</code></pre>
<p>Note that this resulting JavaScript is not as optimal as it could be. See <a href="https://github.com/purescript-contrib/purescript-book/issues/121">this issue</a> for more details. The above snippet should be updated once that issue is resolved.</p>
<p>For comparison, this is the generated JavaScript of the non-inlined form:</p>
<pre><code class="language-js">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return function __do() {

        var ref = Control_Monad_ST_Internal[&quot;new&quot;]({ x: x0, v: v0 })();

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        var $$final = Control_Monad_ST_Internal.read(ref)();
        return $$final.x;
      };
    };
  };
};
</code></pre>
<p>The <code>ST</code> effect is a good way to generate short JavaScript when working with locally-scoped mutable state, especially when used together with actions like <code>for</code>, <code>foreach</code>, and <code>while</code> which generate efficient loops.</p>
<h2 id="exercises-21"><a class="header" href="#exercises-21">Exercises</a></h2>
<ol>
<li>(Medium) Rewrite the <code>safeDivide</code> function as <code>exceptionDivide</code> and throw an exception using <code>throwException</code> with the message <code>&quot;div zero&quot;</code> if the denominator is zero.</li>
<li>(Medium) Write a function <code>estimatePi :: Int -&gt; Number</code> that uses <code>n</code> terms of the <a href="https://mathworld.wolfram.com/GregorySeries.html">Gregory Series</a> to calculate an approximation of <code>pi</code>. <em>Hints:</em> You can pattern your answer like the definition of <code>simulate</code> above. You might need to convert an <code>Int</code> into a <code>Number</code> using <code>toNumber :: Int -&gt; Number</code> from <code>Data.Int</code>.</li>
<li>(Medium) Write a function <code>fibonacci :: Int -&gt; Int</code> to compute the <code>n</code>th Fibonacci number, using <code>ST</code> to track the values of the previous two Fibonacci numbers. Using PSCi, compare the speed of your new <code>ST</code>-based implementation against the recursive implementation (<code>fib</code>) from Chapter 4.</li>
</ol>
<h2 id="dom-effects"><a class="header" href="#dom-effects">DOM Effects</a></h2>
<p>In the final sections of this chapter, we will apply what we have learned about effects in the <code>Effect</code> monad to the problem of working with the DOM.</p>
<p>There are a number of PureScript packages for working directly with the DOM, or with open-source DOM libraries. For example:</p>
<ul>
<li><a href="https://github.com/purescript-web/purescript-web-dom"><code>web-dom</code></a> provides type definitions and low level interface implementations for the W3C DOM spec.</li>
<li><a href="https://github.com/purescript-web/purescript-web-html"><code>web-html</code></a> provides type definitions and low level interface implementations for the W3C HTML5 spec.</li>
<li><a href="https://github.com/paf31/purescript-jquery"><code>jquery</code></a> is a set of bindings to the <a href="http://jquery.org">jQuery</a> library.</li>
</ul>
<p>There are also PureScript libraries which build abstractions on top of these libraries, such as</p>
<ul>
<li><a href="https://github.com/paf31/purescript-thermite"><code>thermite</code></a>, which builds on <a href="https://github.com/purescript-contrib/purescript-react"><code>react</code></a></li>
<li><a href="https://github.com/megamaddu/purescript-react-basic-hooks"><code>react-basic-hooks</code></a>, which builds on <a href="https://github.com/lumihq/purescript-react-basic"><code>react-basic</code></a></li>
<li><a href="https://github.com/purescript-halogen/purescript-halogen"><code>halogen</code></a> which provides a type-safe set of abstractions on top of a custom virtual DOM library.</li>
</ul>
<p>In this chapter, we will use the <code>react-basic-hooks</code> library to add a user interface to our address book application, but the interested reader is encouraged to explore alternative approaches.</p>
<h2 id="an-address-book-user-interface"><a class="header" href="#an-address-book-user-interface">An Address Book User Interface</a></h2>
<p>Using the <code>react-basic-hooks</code> library, we will define our application as a React <em>component</em>. React components describe HTML elements in code as pure data structures, which are then efficiently rendered to the DOM. In addition, components can respond to events like button clicks. The <code>react-basic-hooks</code> library uses the <code>Effect</code> monad to describe how to handle these events.</p>
<p>A full tutorial for the React library is well beyond the scope of this chapter, but the reader is encouraged to consult its documentation where needed. For our purposes, React will provide a practical example of the <code>Effect</code> monad.</p>
<p>We are going to build a form which will allow a user to add a new entry into our address book. The form will contain text boxes for the various fields (first name, last name, city, state, etc.), and an area in which validation errors will be displayed. As the user types text into the text boxes, the validation errors will be updated.</p>
<p>To keep things simple, the form will have a fixed shape: the different phone number types (home, cell, work, other) will be expanded into separate text boxes.</p>
<p>You can launch the web app from the <code>exercises/chapter8</code> directory with the following commands:</p>
<pre><code class="language-shell">$ npm install
$ npx spago build
$ npx parcel src/index.html --open
</code></pre>
<p>If development tools such as <code>spago</code> and <code>parcel</code> are installed globally, then the <code>npx</code> prefix may be omitted. You have likely already installed <code>spago</code> globally with <code>npm i -g spago</code>, and the same can be done for <code>parcel</code>.</p>
<p><code>parcel</code> should launch a browser window with our &quot;Address Book&quot; app. If you keep the <code>parcel</code> terminal open, and rebuild with <code>spago</code> in another terminal, the page should automatically refresh with your latest edits. You can also configure automatic rebuilds (and therefore automatic page refresh) on file-save if you're using an <a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors">editor</a> that supports <a href="https://github.com/purescript/purescript/tree/master/psc-ide"><code>purs ide</code></a> or are running <a href="https://github.com/kRITZCREEK/pscid"><code>pscid</code></a>.</p>
<p>In this Address Book app, you should be able to enter some values into the form fields and see the validation errors printed onto the page.</p>
<p>Let's explore how it works.</p>
<p>The <code>src/index.html</code> file is minimal:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Address Book&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The <code>&lt;script</code> line includes the JavaScript entry point, <code>index.js</code>, which contains this single line:</p>
<pre><code class="language-js">import { main } from &quot;../output/Main/index.js&quot;;

main();
</code></pre>
<p>It calls our generated JavaScript equivalent of the <code>main</code> function of <code>module Main</code> (<code>src/main.purs</code>). Recall that <code>spago build</code> puts all generated JavaScript in the <code>output</code> directory.</p>
<p>The <code>main</code> function uses the DOM and HTML APIs to render our address book component within the <code>container</code> element we defined in <code>index.html</code>:</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  log &quot;Rendering address book component&quot;
  -- Get window object
  w &lt;- window
  -- Get window's HTML document
  doc &lt;- document w
  -- Get &quot;container&quot; element in HTML
  ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
  case ctr of
    Nothing -&gt; throw &quot;Container element not found.&quot;
    Just c -&gt; do
      -- Create AddressBook react component
      addressBookApp &lt;- mkAddressBookApp
      let
        -- Create JSX node from react component. Pass-in empty props
        app = element addressBookApp {}
      -- Render AddressBook JSX node in DOM &quot;container&quot; element
      D.render app c
</code></pre>
<p>Note that these three lines:</p>
<pre><code class="language-hs">w &lt;- window
doc &lt;- document w
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>Can be consolidated to:</p>
<pre><code class="language-hs">doc &lt;- document =&lt;&lt; window
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>Or consolidated even further to:</p>
<pre><code class="language-hs">ctr &lt;- getElementById &quot;container&quot; &lt;&lt;&lt; toNonElementParentNode =&lt;&lt; document =&lt;&lt; window
-- or, equivalently:
ctr &lt;- window &gt;&gt;= document &gt;&gt;= toNonElementParentNode &gt;&gt;&gt; getElementById &quot;container&quot;
</code></pre>
<p>It is a matter of personal preference whether the intermediate <code>w</code> and <code>doc</code> variables aid in readability.</p>
<p>Let's dig into our AddressBook <code>reactComponent</code>. We'll start with a simplified component, and then build up to the actual code in <code>Main.purs</code>.</p>
<p>Take a look at this minimal component. Feel free to substitute the full component with this one to see it run:</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp =
  reactComponent
    &quot;AddressBookApp&quot;
    (\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;)
</code></pre>
<p><code>reactComponent</code> has this intimidating signature:</p>
<pre><code class="language-hs">reactComponent ::
  forall hooks props.
  Lacks &quot;children&quot; props =&gt;
  Lacks &quot;key&quot; props =&gt;
  Lacks &quot;ref&quot; props =&gt;
  String -&gt;
  ({ | props } -&gt; Render Unit hooks JSX) -&gt;
  Effect (ReactComponent { | props })
</code></pre>
<p>The important points to note are the arguments after all the type class constraints. It takes a <code>String</code> (an arbitrary component name), a function that describes how to convert <code>props</code> into rendered <code>JSX</code>, and returns our <code>ReactComponent</code> wrapped in an <code>Effect</code>.</p>
<p>The props-to-JSX function is simply:</p>
<pre><code class="language-hs">\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;
</code></pre>
<p><code>props</code> are ignored, <code>D.text</code> returns <code>JSX</code>, and <code>pure</code> lifts to rendered JSX. Now <code>component</code> has everything it needs to produce the <code>ReactComponent</code>.</p>
<p>Next we'll examine some of the additional complexities of the full Address Book component.</p>
<p>These are the first few lines of our full component:</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp = do
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p>We track <code>person</code> as a piece of state with the <code>useState</code> hook.</p>
<pre><code class="language-hs">Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p>Note that you are free to break-up component state into multiple pieces of state with multiple calls to <code>useState</code>. For example, we could rewrite this app to use a separate piece of state for each record field of <code>Person</code>, but that happens to result in a slightly less convenient architecture in this case.</p>
<p>In other examples, you may encounter the <code>/\</code> infix operator for <code>Tuple</code>. This is equivalent to the above line:</p>
<pre><code class="language-hs">firstName /\ setFirstName &lt;- useState p.firstName
</code></pre>
<p><code>useState</code> takes a default initial value and returns the current value and a way to update the value. We can check the type of <code>useState</code> to gain more insight of the types <code>person</code> and <code>setPerson</code>:</p>
<pre><code class="language-hs">useState ::
  forall state.
  state -&gt;
  Hook (UseState state) (Tuple state ((state -&gt; state) -&gt; Effect Unit))
</code></pre>
<p>We can strip the <code>Hook (UseState state)</code> wrapper off of the return value because <code>useState</code> is called within an <code>R.do</code> block. We'll elaborate on <code>R.do</code> later.</p>
<p>So now we can observe the following signatures:</p>
<pre><code class="language-hs">person :: state
setPerson :: (state -&gt; state) -&gt; Effect Unit
</code></pre>
<p>The specific type of <code>state</code> is determined by our initial default value. <code>Person</code> <code>Record</code> in this case because that is the type of <code>examplePerson</code>.</p>
<p><code>person</code> is how we access the current state at each rerender.</p>
<p><code>setPerson</code> is how we update the state. We simply provide a function that describes how to transform the current state to the new state. The record update syntax is perfect for this when the type of <code>state</code> happens to be a <code>Record</code>, for example:</p>
<pre><code class="language-hs">setPerson (\currentPerson -&gt; currentPerson {firstName = &quot;NewName&quot;})

</code></pre>
<p>or as shorthand:</p>
<pre><code class="language-hs">setPerson _ {firstName = &quot;NewName&quot;}
</code></pre>
<p>Non-<code>Record</code> states can also follow this update pattern. See <a href="https://github.com/megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541">this guide</a> for more details on best practices.</p>
<p>Recall that <code>useState</code> is used within an <code>R.do</code> block. <code>R.do</code> is a special react hooks variant of <code>do</code>. The <code>R.</code> prefix &quot;qualifies&quot; this as coming from <code>React.Basic.Hooks</code>, and means we use their hooks-compatible version of <code>bind</code> in the <code>R.do</code> block. This is known as a &quot;qualified do&quot;. It lets us ignore the <code>Hook (UseState state)</code> wrapping and bind the inner <code>Tuple</code> of values to variables.</p>
<p>Another possible state management strategy is with <code>useReducer</code>, but that is outside the scope of this chapter.</p>
<p>Rendering <code>JSX</code> occurs here:</p>
<pre><code class="language-hs">pure
  $ D.div
      { className: &quot;container&quot;
      , children:
          renderValidationErrors errors
            &lt;&gt; [ D.div
                  { className: &quot;row&quot;
                  , children:
                      [ D.form_
                          $ [ D.h3_ [ D.text &quot;Basic Information&quot; ]
                            , formField &quot;First Name&quot; &quot;First Name&quot; person.firstName \s -&gt;
                                setPerson _ { firstName = s }
                            , formField &quot;Last Name&quot; &quot;Last Name&quot; person.lastName \s -&gt;
                                setPerson _ { lastName = s }
                            , D.h3_ [ D.text &quot;Address&quot; ]
                            , formField &quot;Street&quot; &quot;Street&quot; person.homeAddress.street \s -&gt;
                                setPerson _ { homeAddress { street = s } }
                            , formField &quot;City&quot; &quot;City&quot; person.homeAddress.city \s -&gt;
                                setPerson _ { homeAddress { city = s } }
                            , formField &quot;State&quot; &quot;State&quot; person.homeAddress.state \s -&gt;
                                setPerson _ { homeAddress { state = s } }
                            , D.h3_ [ D.text &quot;Contact Information&quot; ]
                            ]
                          &lt;&gt; renderPhoneNumbers
                      ]
                  }
              ]
      }
</code></pre>
<p>Here we produce <code>JSX</code> which represents the intended state of the DOM. This JSX is typically created by applying functions corresponding to HTML tags (e.g. <code>div</code>, <code>form</code>, <code>h3</code>, <code>li</code>, <code>ul</code>, <code>label</code>, <code>input</code>) which create single HTML elements. These HTML elements are actually React components themselves, converted to JSX. There are usually three variants of each of these functions:</p>
<ul>
<li><code>div_</code>: Accepts an array of child elements. Uses default attributes.</li>
<li><code>div</code>: Accepts a <code>Record</code> of attributes. An array of child elements may be passed to the <code>children</code> field of this record.</li>
<li><code>div'</code>: Same as <code>div</code>, but returns the <code>ReactComponent</code> before conversion to <code>JSX</code>.</li>
</ul>
<p>To display validation errors (if any) at the top of our form, we create a <code>renderValidationErrors</code> helper function that turns the <code>Errors</code> structure into an array of JSX. This array is prepended to the rest of our form.</p>
<pre><code class="language-hs">renderValidationErrors :: Errors -&gt; Array R.JSX
renderValidationErrors [] = []
renderValidationErrors xs =
  let
    renderError :: String -&gt; R.JSX
    renderError err = D.li_ [ D.text err ]
  in
    [ D.div
        { className: &quot;alert alert-danger row&quot;
        , children: [ D.ul_ (map renderError xs) ]
        }
    ]
</code></pre>
<p>Note that since we are simply manipulating regular data structures here, we can use functions like <code>map</code> to build up more interesting elements:</p>
<pre><code class="language-hs">children: [ D.ul_ (map renderError xs)]
</code></pre>
<p>We use the <code>className</code> property to define classes for CSS styling. We're using the <a href="https://getbootstrap.com/">Bootstrap</a> <code>stylesheet</code> for this project, which is imported in <code>index.html</code>. For example, we want items in our form arranged as <code>row</code>s, and validation errors to be emphasized with <code>alert-danger</code> styling:</p>
<pre><code class="language-hs">className: &quot;alert alert-danger row&quot;
</code></pre>
<p>A second helper function is <code>formField</code>, which creates a text input for a single form field:</p>
<pre><code class="language-hs">formField :: String -&gt; String -&gt; String -&gt; (String -&gt; Effect Unit) -&gt; R.JSX
formField name placeholder value setValue =
  D.label
    { className: &quot;form-group row&quot;
    , children:
        [ D.div
            { className: &quot;col-sm col-form-label&quot;
            , children: [ D.text name ]
            }
        , D.div
            { className: &quot;col-sm&quot;
            , children:
                [ D.input
                    { className: &quot;form-control&quot;
                    , placeholder
                    , value
                    , onChange:
                        let
                          handleValue :: Maybe String -&gt; Effect Unit
                          handleValue (Just v) = setValue v
                          handleValue Nothing  = pure unit
                        in
                          handler targetValue handleValue
                    }
                ]
            }
        ]
    }
</code></pre>
<p>Putting the <code>input</code> and display <code>text</code> in a <code>label</code> aids in accessibility for screen readers.</p>
<p>The <code>onChange</code> attribute allows us to describe how to respond to user input. We use the <code>handler</code> function, which has the following type:</p>
<pre><code class="language-hs">handler :: forall a. EventFn SyntheticEvent a -&gt; (a -&gt; Effect Unit) -&gt; EventHandler
</code></pre>
<p>For the first argument to <code>handler</code> we use <code>targetValue</code>, which provides the value of the text within the HTML <code>input</code> element. It matches the signature expected by <code>handler</code> where the type variable <code>a</code> in this case is <code>Maybe String</code>:</p>
<pre><code class="language-hs">targetValue :: EventFn SyntheticEvent (Maybe String)
</code></pre>
<p>In JavaScript, the <code>input</code> element's <code>onChange</code> event is actually accompanied by a <code>String</code> value, but since strings in JavaScript can be null, <code>Maybe</code> is used for safety.</p>
<p>The second argument to <code>handler</code>, <code>(a -&gt; Effect Unit)</code>, must therefore have this signature:</p>
<pre><code class="language-hs">Maybe String -&gt; Effect Unit
</code></pre>
<p>It is a function that describes how to convert this <code>Maybe String</code> value into our desired effect. We define a custom <code>handleValue</code> function for this purpose and pass it to <code>handler</code> as follows:</p>
<pre><code class="language-hs">onChange:
  let
    handleValue :: Maybe String -&gt; Effect Unit
    handleValue (Just v) = setValue v
    handleValue Nothing  = pure unit
  in
    handler targetValue handleValue
</code></pre>
<p><code>setValue</code> is the function we provided to each <code>formField</code> call that takes a string and makes the appropriate record-update call to the <code>setPerson</code> hook.</p>
<p>Note that <code>handleValue</code> can be substituted as:</p>
<pre><code class="language-hs">onChange: handler targetValue $ traverse_ setValue
</code></pre>
<p>Feel free to investigate the definition of <code>traverse_</code> to see how both forms are indeed equivalent.</p>
<p>That covers the basics of our component implementation. However, you should read the source accompanying this chapter in order to get a full understanding of the way the component works.</p>
<p>Obviously, this user interface can be improved in a number of ways. The exercises will explore some ways in which we can make the application more usable.</p>
<h2 id="exercises-22"><a class="header" href="#exercises-22">Exercises</a></h2>
<p>Modify <code>src/Main.purs</code> in the following exercises. There are no unit tests for these exercises.</p>
<ol>
<li>
<p>(Easy) Modify the application to include a work phone number text box.</p>
</li>
<li>
<p>(Medium) Right now the application shows validation errors collected in a single &quot;pink-alert&quot; background.  Modify to give each validation error its own pink-alert background by separating them  with blank lines.</p>
<p><em>Hint</em>: Instead of using a <code>ul</code> element to show the validation errors in a list, modify the code to create one <code>div</code> with the <code>alert</code> and <code>alert-danger</code> styles for each error.</p>
</li>
<li>
<p>(Difficult, Extended) One problem with this user interface is that the validation errors are not displayed next to the form fields they originated from. Modify the code to fix this problem.</p>
<p><em>Hint</em>: the error type returned by the validator should be extended to indicate which field caused the error. You might want to use the following modified <code>Errors</code> type:</p>
<pre><code class="language-hs">data Field = FirstNameField
           | LastNameField
           | StreetField
           | CityField
           | StateField
           | PhoneField PhoneType

data ValidationError = ValidationError String Field

type Errors = Array ValidationError
</code></pre>
<p>You will need to write a function which extracts the validation error for a particular <code>Field</code> from the <code>Errors</code> structure.</p>
</li>
</ol>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>This chapter has covered a lot of ideas about handling side-effects in PureScript:</p>
<ul>
<li>We met the <code>Monad</code> type class, and its connection to do notation.</li>
<li>We introduced the monad laws, and saw how they allow us to transform code written using do notation.</li>
<li>We saw how monads can be used abstractly, to write code which works with different side-effects.</li>
<li>We saw how monads are examples of applicative functors, how both allow us to compute with side-effects, and the differences between the two approaches.</li>
<li>The concept of native effects was defined, and we met the <code>Effect</code> monad, which is used to handle native side-effects.</li>
<li>We used the <code>Effect</code> monad to handle a variety of effects: random number generation, exceptions, console IO, mutable state, and DOM manipulation using React.</li>
</ul>
<p>The <code>Effect</code> monad is a fundamental tool in real-world PureScript code. It will be used in the rest of the book to handle side-effects in a number of other use-cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-effects"><a class="header" href="#asynchronous-effects">Asynchronous Effects</a></h1>
<h2 id="chapter-goals-7"><a class="header" href="#chapter-goals-7">Chapter Goals</a></h2>
<p>This chapter focuses on the <code>Aff</code> monad, which is similar to the <code>Effect</code> monad, but represents <em>asynchronous</em> side-effects. We'll demonstrate examples of asynchronously interacting with the filesystem and making HTTP requests. We'll also cover how to manage sequential and parallel execution of asynchronous effects.</p>
<h2 id="project-setup-6"><a class="header" href="#project-setup-6">Project Setup</a></h2>
<p>New PureScript libraries introduced in this chapter are:</p>
<ul>
<li><code>aff</code> - defines the <code>Aff</code> monad.</li>
<li><code>node-fs-aff</code> - asynchronous filesystem operations with <code>Aff</code>.</li>
<li><code>affjax</code> - HTTP requests with AJAX and <code>Aff</code>.</li>
<li><code>parallel</code> - parallel execution of <code>Aff</code>.</li>
</ul>
<p>When running outside of the browser (such as in our Node.js environment), the <code>affjax</code> library requires the <code>xhr2</code> NPM module, which is listed as dependency in the <code>package.json</code> of this chapter. Install that by running:</p>
<pre><code class="language-shell">$ npm install
</code></pre>
<h2 id="asynchronous-javascript"><a class="header" href="#asynchronous-javascript">Asynchronous JavaScript</a></h2>
<p>A convenient way to work with asynchronous code in JavaScript is with <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await"><code>async</code> and <code>await</code></a>. See <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">this article on asynchronous JavaScript</a> for more background information.</p>
<p>Here is an example of using this technique to copy the contents of one file to another file:</p>
<pre><code class="language-js">import { promises as fsPromises } from 'fs'

async function copyFile(file1, file2) {
  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });
  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });
}

copyFile('file1.txt', 'file2.txt')
.catch(e =&gt; {
  console.log('There was a problem with copyFile: ' + e.message);
});
</code></pre>
<p>It is also possible to use callbacks or synchronous functions, but those are less desireable because:</p>
<ul>
<li>Callbacks lead to excessive nesting, known as &quot;Callback Hell&quot; or the &quot;Pyramid of Doom&quot;.</li>
<li>Synchronous functions block execution of the other code in your app.</li>
</ul>
<h2 id="asynchronous-purescript"><a class="header" href="#asynchronous-purescript">Asynchronous PureScript</a></h2>
<p>The <code>Aff</code> monad in PureScript offers similar ergonomics of JavaScript's <code>async</code>/<code>await</code> syntax. Here is the same <code>copyFile</code> example from before, but rewritten in PureScript using <code>Aff</code>:</p>
<pre><code class="language-hs">import Prelude
import Data.Either (Either(..))
import Effect.Aff (Aff, attempt, message)
import Effect.Class.Console (log)
import Node.Encoding (Encoding(..))
import Node.FS.Aff (readTextFile, writeTextFile)
import Node.Path (FilePath)

copyFile :: FilePath -&gt; FilePath -&gt; Aff Unit
copyFile file1 file2 = do
  my_data &lt;- readTextFile UTF8 file1
  writeTextFile UTF8 file2 my_data

main :: Aff Unit
main = do
  result &lt;- attempt $ copyFile &quot;file1.txt&quot; &quot;file2.txt&quot;
  case result of
    Left e -&gt; log $ &quot;There was a problem with copyFile: &quot; &lt;&gt; message e
    _ -&gt; pure unit
</code></pre>
<p>It is also possible to re-write the above snippet using callbacks or synchronous functions (for example with <code>Node.FS.Async</code> and <code>Node.FS.Sync</code> respectively), but those share the same downsides as discussed earlier with JavaScript, and so that coding style is not recommended.</p>
<p>The syntax for working with <code>Aff</code> is very similar to working with <code>Effect</code>. They are both monads, and can therefore be written with do notation.</p>
<p>For example, if we look at the signature of <code>readTextFile</code>, we see that it returns the file contents as a <code>String</code> wrapped in <code>Aff</code>:</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; FilePath -&gt; Aff String
</code></pre>
<p>We can &quot;unwrap&quot; the returned string with a bind arrow (<code>&lt;-</code>) in do notation:</p>
<pre><code class="language-hs">my_data &lt;- readTextFile UTF8 file1
</code></pre>
<p>Then pass it as the string argument to <code>writeTextFile</code>:</p>
<pre><code class="language-hs">writeTextFile :: Encoding -&gt; FilePath -&gt; String -&gt; Aff Unit
</code></pre>
<p>The only other notable feature unique to <code>Aff</code> in the above example is <code>attempt</code>, which captures errors or exceptions encountered while running <code>Aff</code> code and stores them in an <code>Either</code>:</p>
<pre><code class="language-hs">attempt :: forall a. Aff a -&gt; Aff (Either Error a)
</code></pre>
<p>You should hopefully be able to draw on your knowledge of concepts from previous chapters and combine this with the new <code>Aff</code> patterns learned in the above <code>copyFile</code> example to tackle the following exercises:</p>
<h2 id="exercises-23"><a class="header" href="#exercises-23">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a <code>concatenateFiles</code> function which concatenates two text files.</p>
</li>
<li>
<p>(Medium) Write a function <code>concatenateMany</code> to concatenate multiple text files, given an array of input file names and an output file name. <em>Hint</em>: use <code>traverse</code>.</p>
</li>
<li>
<p>(Medium) Write a function <code>countCharacters :: FilePath -&gt; Aff (Either Error Int)</code> that returns the number of characters in a file, or an error if one is encountered.</p>
</li>
</ol>
<h2 id="additional-aff-resources"><a class="header" href="#additional-aff-resources">Additional Aff Resources</a></h2>
<p>If you haven't already taken a look at the <a href="https://pursuit.purescript.org/packages/purescript-aff/">official Aff guide</a>, skim through that now. It's not a direct prerequisite for completing the remaining exercises in this chapter, but you may find it helpful to lookup some functions on Pursuit.</p>
<p>You're also welcome to consult these supplemental resources too, but again, the exercises in this chapter don't depend on them:</p>
<ul>
<li><a href="https://blog.drewolson.org/asynchronous-purescript">Drew's Aff Post</a></li>
<li><a href="https://github.com/JordanMartinez/purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff">Additional Aff Explanation and Examples</a></li>
</ul>
<h2 id="a-http-client"><a class="header" href="#a-http-client">A HTTP Client</a></h2>
<p>The <code>affjax</code> library offers a convenient way to make asynchronous AJAX HTTP requests with <code>Aff</code>. Depending on what environment you are targeting you need to use either the <a href="https://github.com/purescript-contrib/purescript-affjax-web">purescript-affjax-web</a> or the <a href="https://github.com/purescript-contrib/purescript-affjax-node">purescript-affjax-node</a> library.
In the rest of this chapter we will be targeting node and thus using <code>purescript-affjax-node</code>.
Consult the <a href="https://pursuit.purescript.org/packages/purescript-affjax">Affjax docs</a> for more usage information. Here is an example that makes HTTP GET requests at a provided URL and returns the response body or an error message:</p>
<pre><code class="language-hs">import Prelude
import Affjax.Node as AN
import Affjax.ResponseFormat as ResponseFormat
import Data.Either (Either(..))
import Effect.Aff (Aff)

getUrl :: String -&gt; Aff String
getUrl url = do
  result &lt;- AN.get ResponseFormat.string url
  pure case result of
    Left err -&gt; &quot;GET /api response failed to decode: &quot; &lt;&gt; AN.printError err
    Right response -&gt; response.body
</code></pre>
<p>When calling this in the repl, <code>launchAff_</code> is required to convert the <code>Aff</code> to a repl-compatible <code>Effect</code>:</p>
<pre><code class="language-shell">$ spago repl

&gt; :pa
‚Ä¶ import Prelude
‚Ä¶ import Effect.Aff (launchAff_)
‚Ä¶ import Effect.Class.Console (log)
‚Ä¶ import Test.HTTP (getUrl)
‚Ä¶
‚Ä¶ launchAff_ do
‚Ä¶   str &lt;- getUrl &quot;https://reqres.in/api/users/1&quot;
‚Ä¶   log str
‚Ä¶
unit
{&quot;data&quot;:{&quot;id&quot;:1,&quot;email&quot;:&quot;george.bluth@reqres.in&quot;,&quot;first_name&quot;:&quot;George&quot;,&quot;last_name&quot;:&quot;Bluth&quot;, ...}}
</code></pre>
<h2 id="exercises-24"><a class="header" href="#exercises-24">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>writeGet</code> which makes an HTTP <code>GET</code> request to a provided url, and writes the response body to a file.</li>
</ol>
<h2 id="parallel-computations"><a class="header" href="#parallel-computations">Parallel Computations</a></h2>
<p>We've seen how to use the <code>Aff</code> monad and do notation to compose asynchronous computations in sequence. It would also be useful to be able to compose asynchronous computations <em>in parallel</em>. With <code>Aff</code>, we can compute in parallel simply by initiating our two computations one after the other.</p>
<p>The <code>parallel</code> package defines a type class <code>Parallel</code> for monads like <code>Aff</code> which support parallel execution. When we met applicative functors earlier in the book, we observed how applicative functors can be useful for combining parallel computations. In fact, an instance for <code>Parallel</code> defines a correspondence between a monad <code>m</code> (such as <code>Aff</code>) and an applicative functor <code>f</code> which can be used to combine computations in parallel:</p>
<pre><code class="language-hs">class (Monad m, Applicative f) &lt;= Parallel f m | m -&gt; f, f -&gt; m where
  sequential :: forall a. f a -&gt; m a
  parallel :: forall a. m a -&gt; f a
</code></pre>
<p>The class defines two functions:</p>
<ul>
<li><code>parallel</code>, which takes computations in the monad <code>m</code> and turns them into computations in the applicative functor <code>f</code>, and</li>
<li><code>sequential</code>, which performs a conversion in the opposite direction.</li>
</ul>
<p>The <code>aff</code> library provides a <code>Parallel</code> instance for the <code>Aff</code> monad. It uses mutable references to combine <code>Aff</code> actions in parallel, by keeping track of which of the two continuations has been called. When both results have been returned, we can compute the final result and pass it to the main continuation.</p>
<p>Because applicative functors support lifting of functions of arbitrary arity, we can perform more computations in parallel by using the applicative combinators. We can also benefit from all of the standard library functions which work with applicative functors, such as <code>traverse</code> and <code>sequence</code>!</p>
<p>We can also combine parallel computations with sequential portions of code, by using applicative combinators in a do notation block, or vice versa, using <code>parallel</code> and <code>sequential</code> to change type constructors where appropriate.</p>
<p>To demonstrate the difference between sequential and parallel execution, we'll create an array of 100 10-millisecond delays, then execute those delays with both techniques.
You'll notice in the repl that <code>seqDelay</code> is much slower than <code>parDelay</code>.
Note that parallel execution is enabled by simply replacing <code>sequence_</code> with <code>parSequence_</code>.</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parSequence_)
import Data.Array (replicate)
import Data.Foldable (sequence_)
import Effect (Effect)
import Effect.Aff (Aff, Milliseconds(..), delay, launchAff_)

delayArray :: Array (Aff Unit)
delayArray = replicate 100 $ delay $ Milliseconds 10.0

seqDelay :: Effect Unit
seqDelay = launchAff_ $ sequence_ delayArray

parDelay :: Effect Unit
parDelay = launchAff_ $ parSequence_ delayArray
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelDelay

&gt; seqDelay -- This is slow
unit

&gt; parDelay -- This is fast
unit
</code></pre>
<p>Here's a more real-world example of making multiple HTTP requests in parallel. We're reusing our <code>getUrl</code> function to fetch information from two users in parallel. Note that <code>parTraverse</code> (the parallel version of <code>traverse</code>) is used in this case. This example would also work fine with <code>traverse</code> instead, but it will be slower.</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parTraverse)
import Effect (Effect)
import Effect.Aff (launchAff_)
import Effect.Class.Console (logShow)
import Test.HTTP (getUrl)

fetchPar :: Effect Unit
fetchPar =
  launchAff_ do
    let
      urls = map (\n -&gt; &quot;https://reqres.in/api/users/&quot; &lt;&gt; show n) [ 1, 2 ]
    res &lt;- parTraverse getUrl urls
    logShow res
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelFetch

&gt; fetchPar
unit
[&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:1,\&quot;email\&quot;:\&quot;george.bluth@reqres.in\&quot;, ... }&quot;
,&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:2,\&quot;email\&quot;:\&quot;janet.weaver@reqres.in\&quot;, ... }&quot;
]
</code></pre>
<p>A full listing of available parallel functions can be found in the <a href="https://pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel"><code>parallel</code> docs on Pursuit</a>. The <a href="https://github.com/purescript-contrib/purescript-aff#parallel-execution">aff docs section on parallel</a> also contains more examples.</p>
<h2 id="exercises-25"><a class="header" href="#exercises-25">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write a <code>concatenateManyParallel</code> function which has the same signature as the earlier <code>concatenateMany</code> function, but reads all input files in parallel.</p>
</li>
<li>
<p>(Medium) Write a <code>getWithTimeout :: Number -&gt; String -&gt; Aff (Maybe String)</code> function which makes an HTTP <code>GET</code> request at the provided URL and returns either:</p>
<ul>
<li><code>Nothing</code>: if the request takes longer than the provided timeout (in milliseconds).</li>
<li>The string response: if the request succeeds before the timeout elapses.</li>
</ul>
</li>
<li>
<p>(Difficult) Write a <code>recurseFiles</code> function which takes a &quot;root&quot; file and returns an array of all paths listed in that file (and listed in the listed files too). Read listed files in parallel. Paths are relative to the directory of the file they appear in. <em>Hint:</em> The <code>node-path</code> module has some helpful functions for negotiating directories.</p>
</li>
</ol>
<p>For example, if starting from the following <code>root.txt</code> file:</p>
<pre><code class="language-shell">$ cat root.txt
a.txt
b/a.txt
c/a/a.txt

$ cat a.txt
b/b.txt

$ cat b/b.txt
c/a.txt

$ cat b/c/a.txt

$ cat b/a.txt

$ cat c/a/a.txt
</code></pre>
<p>The expected output is:</p>
<pre><code class="language-hs">[&quot;root.txt&quot;,&quot;a.txt&quot;,&quot;b/a.txt&quot;,&quot;b/b.txt&quot;,&quot;b/c/a.txt&quot;,&quot;c/a/a.txt&quot;]
</code></pre>
<h2 id="conclusion-7"><a class="header" href="#conclusion-7">Conclusion</a></h2>
<p>In this chapter we covered asynchronous effects and learned how to:</p>
<ul>
<li>Run asynchronous code in the <code>Aff</code> monad with the <code>aff</code> library.</li>
<li>Make HTTP requests asynchronously with the <code>affjax</code> library.</li>
<li>Run asynchronous code in parallel with the <code>parallel</code> library.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-foreign-function-interface"><a class="header" href="#the-foreign-function-interface">The Foreign Function Interface</a></h1>
<h2 id="chapter-goals-8"><a class="header" href="#chapter-goals-8">Chapter Goals</a></h2>
<p>This chapter will introduce PureScript's <em>foreign function interface</em> (or <em>FFI</em>), which enables communication from PureScript code to JavaScript code, and vice versa. We will cover how to:</p>
<ul>
<li>Call pure, effectful, and asynchronous JavaScript functions from PureScript.</li>
<li>Work with untyped data.</li>
<li>Encode and parse JSON using the <code>argonaut</code> package.</li>
</ul>
<p>Towards the end of this chapter, we will revisit our recurring address book example. The goal of the chapter will be to add the following new functionality to our application using the FFI:</p>
<ul>
<li>Alert the user with a popup notification.</li>
<li>Store the serialized form data in the browser's local storage, and reload it when the application restarts.</li>
</ul>
<p>There is also an addendum which covers some additional topics which are not as commonly sought-after. Feel free to read these sections, but don't let them stand in the way of progressing through the remainder of the book if they're less relevant to your learning objectives:</p>
<ul>
<li>Understand the representation of PureScript values at runtime.</li>
<li>Call PureScript functions from JavaScript.</li>
</ul>
<h2 id="project-setup-7"><a class="header" href="#project-setup-7">Project Setup</a></h2>
<p>The source code for this module is a continuation of the source code from chapters 3, 7 and 8. As such, the source tree includes the appropriate source files from those chapters.</p>
<p>This chapter introduces the <code>argonaut</code> library as a dependency. This library is used for encoding and decoding JSON.</p>
<p>The exercises for this chapter should be written in <code>test/MySolutions.purs</code> and can be checked against the unit tests in <code>test/Main.purs</code> by running <code>spago test</code>.</p>
<p>The Address Book app can be launched with <code>parcel src/index.html --open</code>. It uses the same workflow from Chapter 8, so refer to that chapter for more detailed instructions.</p>
<h2 id="a-disclaimer"><a class="header" href="#a-disclaimer">A Disclaimer</a></h2>
<p>PureScript provides a straightforward foreign function interface to make working with JavaScript as simple as possible. However, it should be noted that the FFI is an <em>advanced</em> feature of the language. To use it safely and effectively, you should have an understanding of the runtime representation of the data you plan to work with. This chapter aims to impart such an understanding as pertains to code in PureScript's standard libraries.</p>
<p>PureScript's FFI is designed to be very flexible. In practice, this means that developers have a choice, between giving their foreign functions very simple types, or using the type system to protect against accidental misuses of foreign code. Code in the standard libraries tends to favor the latter approach.</p>
<p>As a simple example, a JavaScript function makes no guarantees that its return value will not be <code>null</code>. Indeed, idiomatic JavaScript code returns <code>null</code> quite frequently! However, PureScript's types are usually not inhabited by a null value. Therefore, it is the responsibility of the developer to handle these corner cases appropriately when designing their interfaces to JavaScript code using the FFI.</p>
<h2 id="calling-javascript-from-purescript"><a class="header" href="#calling-javascript-from-purescript">Calling JavaScript From PureScript</a></h2>
<p>The simplest way to use JavaScript code from PureScript is to give a type to an existing JavaScript value using a <em>foreign import</em> declaration. Foreign import declarations must have a corresponding JavaScript declaration <em>exported</em> from a <em>foreign JavaScript module</em>.</p>
<p>For example, consider the <code>encodeURIComponent</code> function, which can be used in JavaScript to encode a component of a URI by escaping special characters:</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p>This function has the correct runtime representation for the function type <code>String -&gt; String</code>, since it takes non-null strings to non-null strings, and has no other side-effects.</p>
<p>We can assign this type to the function with the following foreign import declaration:</p>
<pre><code class="language-haskell">module Test.URI where

foreign import _encodeURIComponent :: String -&gt; String
</code></pre>
<p>We also need to write a foreign JavaScript module to import it from. A corresponding foreign JavaScript module is one of the same name but extension changed from <code>.purs</code> to <code>.js</code>. If the Purescript module above is saved as <code>URI.purs</code>, then the foreign JavaScript module is saved as <code>URI.js</code>.
Since <code>encodeURIComponent</code> is already defined, we have to export it as <code>_encodeURIComponent</code>:</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

export const _encodeURIComponent = encodeURIComponent;
</code></pre>
<p>Since version 0.15, Purescript uses the ES module system when interoperating with JavaScript. In ES modules, functions and values are exported from a module by providing the <code>export</code> keyword on an object.</p>
<p>With these two pieces in place, we can now use the <code>_encodeURIComponent</code> function from PureScript like any function written in PureScript. For example, in PSCi, we can reproduce the calculation above:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; _encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>We can also define our own functions in foreign modules. Here's an example of how to create and call a custom JavaScript function that squares a <code>Number</code>:</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

export const square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="functions-of-multiple-arguments"><a class="header" href="#functions-of-multiple-arguments">Functions of Multiple Arguments</a></h2>
<p>Let's rewrite our <code>diagonal</code> function from Chapter 2 in a foreign module. This function calculates the diagonal of a right-angled triangle.</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>Recall that functions in PureScript are <em>curried</em>. <code>diagonal</code> is a function that takes a <code>Number</code> and returns a <em>function</em>, that takes a <code>Number</code> and returns a <code>Number</code>.</p>
<pre><code class="language-js">export const diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>Or with ES6 arrow syntax (see ES6 note below).</p>
<pre><code class="language-js">export const diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="uncurried-functions"><a class="header" href="#uncurried-functions">Uncurried Functions</a></h2>
<p>Writing curried functions in JavaScript isn't always feasible, despite being scarcely idiomatic. A typical multi-argument JavaScript function would be of the <em>uncurried</em> form:</p>
<pre><code class="language-js">export const diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>The module <code>Data.Function.Uncurried</code> exports <em>wrapper</em> types and utility functions to work with uncurried functions.</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>Inspecting the type constructor <code>Fn2</code>:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code> takes three type arguments. <code>Fn2 a b c</code> is a type representing an uncurried function of two arguments of types <code>a</code> and <code>b</code>, that returns a value of type <code>c</code>. We used it to import <code>diagonalUncurried</code> from the foreign module.</p>
<p>We can then call it with <code>runFn2</code> which takes the uncurried function then the arguments.</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p>The <code>functions</code> package defines similar type constructors for function arities from 0 to 10.</p>
<h2 id="a-note-about-uncurried-functions"><a class="header" href="#a-note-about-uncurried-functions">A Note About Uncurried Functions</a></h2>
<p>PureScript's curried functions has certain advantages. It allows us to partially apply functions, and to give type class instances for function types - but it comes with a performance penalty. For performance critical code, it is sometimes necessary to define uncurried JavaScript functions which accept multiple arguments.</p>
<p>We can also create uncurried functions from PureScript. For a function of two arguments, we can use the <code>mkFn2</code> function.</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>We can apply the uncurried function of two arguments by using <code>runFn2</code> as before:</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>The key here is that the compiler <em>inlines</em> the <code>mkFn2</code> and <code>runFn2</code> functions whenever they are fully applied. The result is that the generated code is very compact:</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>For contrast, here is a traditional curried function:</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>and the resulting generated code, which is less compact due to the nested functions:</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="a-note-about-modern-javascript-syntax"><a class="header" href="#a-note-about-modern-javascript-syntax">A Note About Modern JavaScript Syntax</a></h2>
<p>The arrow function syntax we saw earlier is an ES6 feature, and so it is incompatible with some older browsers (namely IE11). As of writing, it is <a href="https://caniuse.com/#feat=arrow-functions">estimated that arrow functions are unavailable for the 6% of users</a> who have not yet updated their web browser.</p>
<p>In order to be compatible with the most users, the JavaScript code generated by the PureScript compiler does not use arrow functions. It is also recommended to <strong>avoid arrow functions in public libraries</strong> for the same reason.</p>
<p>You may still use arrow functions in your own FFI code, but then should include a tool such as <a href="https://github.com/babel/babel#intro">Babel</a> in your deployment workflow to convert these back to ES5 compatible functions.</p>
<p>If you find arrow functions in ES6 more readable, you may transform JavaScript code in the compiler's <code>output</code> directory with a tool like <a href="https://github.com/lebab/lebab">Lebab</a>:</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>This operation would convert the above <code>curriedAdd</code> function to:</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>The remaining examples in this book will use arrow functions instead of nested functions.</p>
<h2 id="exercises-26"><a class="header" href="#exercises-26">Exercises</a></h2>
<ol>
<li>(Medium) Write a JavaScript function <code>volumeFn</code> in the <code>Test.MySolutions</code> module that finds the volume of a box. Use an <code>Fn</code> wrapper from <code>Data.Function.Uncurried</code>.</li>
<li>(Medium) Rewrite <code>volumeFn</code> with arrow functions as <code>volumeArrow</code>.</li>
</ol>
<h2 id="passing-simple-types"><a class="header" href="#passing-simple-types">Passing Simple Types</a></h2>
<p>The following data types may be passed between PureScript and JavaScript as-is:</p>
<div class="table-wrapper"><table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
</div>
<p>We've already seen examples with the primitive types <code>String</code> and <code>Number</code>. We'll now take a look at the structural types <code>Array</code> and <code>Record</code> (<code>Object</code> in JavaScript).</p>
<p>To demonstrate passing <code>Array</code>s, here's how to call a JavaScript function which takes an <code>Array</code> of <code>Int</code> and returns the cumulative sum as another array. Recall that, since JavaScript does not have a separate type for <code>Int</code>, both <code>Int</code> and <code>Number</code> in PureScript translate to <code>Number</code> in JavaScript.</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">export const cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p>To demonstrate passing <code>Records</code>, here's how to call a JavaScript function which takes two <code>Complex</code> numbers as records, and returns their sum as another record. Note that a <code>Record</code> in PureScript is represented as an <code>Object</code> in JavaScript:</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">export const addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>Note that the above techniques require trusting that JavaScript will return the expected types, as PureScript is not able to apply type checking to JavaScript code. We will describe this type safety concern in more detail later on in the JSON section, as well as cover techniques to protect against type mismatches.</p>
<h2 id="exercises-27"><a class="header" href="#exercises-27">Exercises</a></h2>
<ol>
<li>(Medium) Write a JavaScript function <code>cumulativeSumsComplex</code> (and corresponding PureScript foreign import) that takes an <code>Array</code> of <code>Complex</code> numbers and returns the cumulative sum as another array of complex numbers.</li>
</ol>
<h2 id="beyond-simple-types"><a class="header" href="#beyond-simple-types">Beyond Simple Types</a></h2>
<p>We have seen examples of how to send and receive types with a native JavaScript representation, such as <code>String</code>, <code>Number</code>, <code>Array</code>, and <code>Record</code>, over FFI. Now we'll cover how to use some of the other types available in PureScript, like <code>Maybe</code>.</p>
<p>Suppose we wanted to recreate the <code>head</code> function on arrays by using a foreign declaration. In JavaScript, we might write the function as follows:</p>
<pre><code class="language-javascript">export const head = arr =&gt;
  arr[0];
</code></pre>
<p>How would we type this function? We might try to give it the type <code>forall a. Array a -&gt; a</code>, but for empty arrays, this function returns <code>undefined</code>. Therefore, the type <code>forall a. Array a -&gt; a</code> does not correctly represent this implementation.</p>
<p>We instead want to return a <code>Maybe</code> value to handle this corner case:</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>But how do we return a <code>Maybe</code>? It is tempting to write the following:</p>
<pre><code class="language-js">// Don't do this
import Data_Maybe from '../Data.Maybe'

export const maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>Importing and using the <code>Data.Maybe</code> module directly in the foreign module isn't recommended as it makes our code brittle to changes in the code generator ‚Äî <code>create</code> and <code>value</code> are not public APIs. Additionally, doing this can cause problems when using <code>purs bundle</code> for dead code elimination.</p>
<p>The recommended approach is to add extra parameters to our FFI-defined function to accept the functions we need.</p>
<pre><code class="language-js">export const maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>Note that we wrote:</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>and not:</p>
<pre><code class="language-hs">forall a. ( a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>While both forms work, the latter is more vulnerable to unwanted inputs in place of <code>Just</code> and <code>Nothing</code>.
For example, in the more vulnerable case we could call it as follows:</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>which returns <code>Just 1000</code> for any array input.
This vulnerability is allowed because <code>(\_ -&gt; Just 1000)</code> and <code>Just 1000</code> match the signatures of <code>(a -&gt; Maybe a)</code> and <code>Maybe a</code> respectively when <code>a</code> is <code>Int</code> (based on input array).</p>
<p>In the more secure type signature, even when <code>a</code> is determined to be <code>Int</code> based on the input array, we still need to provide valid functions matching the signatures involving <code>forall x</code>.
The <em>only</em> option for <code>(forall x. Maybe x)</code> is <code>Nothing</code>, since a <code>Just</code> value would assume a type for <code>x</code> and will no longer be valid for all <code>x</code>. The only options for <code>(forall x. x -&gt; Maybe x)</code> are <code>Just</code> (our desired argument) and <code>(\_ -&gt; Nothing)</code>, which is the only remaining vulnerability.</p>
<h2 id="defining-foreign-types"><a class="header" href="#defining-foreign-types">Defining Foreign Types</a></h2>
<p>Suppose instead of returning a <code>Maybe a</code>, we want to actually return <code>arr[0]</code>. We want a type that represents a value either of type <code>a</code> or the <code>undefined</code> value (but not <code>null</code>). We'll call this type <code>Undefined a</code>.</p>
<p>We can define a <em>foreign type</em> using a <em>foreign type declaration</em>. The syntax is similar to defining a foreign function:</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>The <code>data</code> keyword here indicates that we are defining a <em>type</em>, not a value. Instead of a type signature, we give the <em>kind</em> of the new type. In this case, we declare the kind of <code>Undefined</code> to be <code>Type -&gt; Type</code>. In other words, <code>Undefined</code> is a type constructor.</p>
<p>We can now simply reuse our original definition for <code>head</code>:</p>
<pre><code class="language-javascript">export const undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>And in the PureScript module:</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p>The body of the <code>undefinedHead</code> function returns <code>arr[0]</code> which may be <code>undefined</code>, and the type signature correctly reflects that fact.</p>
<p>This function has the correct runtime representation for its type, but is quite useless since we have no way to use a value of type <code>Undefined a</code>. Well, not exactly. We can use this type in another FFI!</p>
<p>We can write a function that will tell us whether a value is undefined or not:</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>This is defined in our foreign JavaScript module as follows:</p>
<pre><code class="language-javascript">export const isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>We can now use <code>isUndefined</code> and <code>undefinedHead</code> together from PureScript to define a useful function:</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>Here, the foreign function we defined is very simple, which means we can benefit from the use of PureScript's typechecker as much as possible. This is good practice in general: foreign functions should be kept as small as possible, and application logic moved into PureScript code wherever possible.</p>
<h2 id="exceptions-1"><a class="header" href="#exceptions-1">Exceptions</a></h2>
<p>Another option is to simply throw an exception in the case of an empty array. Strictly speaking, pure functions should not throw exceptions, but we have the flexibility to do so. We indicate the lack of safety in the function name:</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>In our foreign JavaScript module, we can define <code>unsafeHead</code> as follows:</p>
<pre><code class="language-javascript">export const unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="exercises-28"><a class="header" href="#exercises-28">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Given a record that represents a quadratic polynomial <code>a*x^2 + b*x + c = 0</code>:</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>Write a JavaScript function <code>quadraticRootsImpl</code> and a wrapper <code>quadraticRoots :: Quadratic -&gt; Pair Complex</code> that uses the quadratic formula to find the roots of this polynomial. Return the two roots as a <code>Pair</code> of <code>Complex</code> numbers. <em>Hint:</em> Use the <code>quadraticRoots</code> wrapper to pass a constructor for <code>Pair</code> to <code>quadraticRootsImpl</code>.</p>
</li>
<li>
<p>(Medium) Write the function <code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>. This function converts <code>undefined</code> to <code>Nothing</code> and <code>a</code> values to <code>Just</code>s.</p>
</li>
<li>
<p>(Difficult) With <code>toMaybe</code> in place, we can rewrite <code>maybeHead</code> as</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>Is this a better approach than our previous implementation? <em>Note:</em> There is no unit test for this exercise.</p>
</li>
</ol>
<h2 id="using-type-class-member-functions"><a class="header" href="#using-type-class-member-functions">Using Type Class Member Functions</a></h2>
<p>Just like our earlier guide on passing the <code>Maybe</code> constructor over FFI, this is another case of writing PureScript that calls JavaScript, which in turn calls PureScript functions again. Here we will explore how to pass type class member functions over the FFI.</p>
<p>We start with writing a foreign JavaScript function which expects the appropriate instance of <code>show</code> to match the type of <code>x</code>.</p>
<pre><code class="language-js">export const boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + &quot;!!!&quot;;
</code></pre>
<p>Then we write the matching signature:</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>and a wrapper function that passes the correct instance of <code>show</code>:</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>Alternatively in point-free form:</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>We can then call the wrapper:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 &quot;Hat&quot;)
&quot;(TUPLE 1 \&quot;HAT\&quot;)!!!&quot;
</code></pre>
<p>Here's another example demonstrating passing multiple functions, including a function of multiple arguments (<code>eq</code>):</p>
<pre><code class="language-js">export const showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return &quot;Equivalent&quot;;
  } else {
    return show(a) + &quot; is not equal to &quot; + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
&quot;Nothing is not equal to (Just 5)&quot;
</code></pre>
<h2 id="effectful-functions"><a class="header" href="#effectful-functions">Effectful Functions</a></h2>
<p>Let's extend our <code>bold</code> function to log to the console. Logging is an <code>Effect</code>, and <code>Effect</code>s are represented in JavaScript as a function of zero arguments, <code>()</code> with arrow notation:</p>
<pre><code class="language-js">export const yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + &quot;!!!&quot;);
</code></pre>
<p>The new foreign import is the same as before, except that the return type changed from <code>String</code> to <code>Effect Unit</code>.</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>When testing this in the repl, notice that the string is printed directly to the console (instead of being quoted) and a <code>unit</code> value is returned.</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 &quot;Hat&quot;)
(TUPLE 1 &quot;HAT&quot;)!!!
unit
</code></pre>
<p>There are also <code>EffectFn</code> wrappers from <code>Effect.Uncurried</code>. These are similar to the <code>Fn</code> wrappers from <code>Data.Function.Uncurried</code> that we've already seen. These wrappers let you call uncurried effectful functions in PureScript.</p>
<p>You'd generally only use these if you want to call existing JavaScript library APIs directly, rather than wrapping those APIs in curried functions. So it doesn't make much sense to present an example of uncurried <code>yell</code>, where the JavaScript relies on PureScript type class members, since you wouldn't find that in the existing JavaScript ecosystem.</p>
<p>Instead, we'll modify our previous <code>diagonal</code> example to include logging in addition to returning the result:</p>
<pre><code class="language-js">export const diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log(&quot;Diagonal is &quot; + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="asynchronous-functions"><a class="header" href="#asynchronous-functions">Asynchronous Functions</a></h2>
<p>Promises in JavaScript translate directly to asynchronous effects in PureScript with the help of the <code>aff-promise</code> library. See that library's <a href="https://pursuit.purescript.org/packages/purescript-aff-promise">documentation</a> for more information. We'll just go through a few examples.</p>
<p>Suppose we want to use this JavaScript <code>wait</code> promise (or asynchronous function) in our PureScript project. It may be used to delay execution for <code>ms</code> milliseconds.</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>We just need to export it wrapped as an <code>Effect</code> (function of zero arguments):</p>
<pre><code class="language-js">export const sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>Then import it as follows:</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>We can then run this <code>Promise</code> in an <code>Aff</code> block like so:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
‚Ä¶ launchAff_ do
‚Ä¶   log &quot;waiting&quot;
‚Ä¶   sleep 300
‚Ä¶   log &quot;done waiting&quot;
‚Ä¶
waiting
unit
done waiting
</code></pre>
<p>Note that asynchronous logging in the repl just waits to print until the entire block has finished executing. This code behaves more predictably when run with <code>spago test</code> where there is a slight delay <em>between</em> prints.</p>
<p>Let's look at another example where we return a value from a promise. This function is written with <code>async</code> and <code>await</code>, which is just syntactic sugar for promises.</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

export const diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p>Since we're returning a <code>Number</code>, we represent this type in the <code>Promise</code> and <code>Aff</code> wrappers:</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
‚Ä¶ launchAff_ do
‚Ä¶   res &lt;- diagonalAsync 300 3.0 4.0
‚Ä¶   logShow res
‚Ä¶
unit
5.0
</code></pre>
<h2 id="exercises-29"><a class="header" href="#exercises-29">Exercises</a></h2>
<p>Exercises for the above sections are still on the ToDo list. If you have any ideas for good exercises, please make a suggestion.</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>There are many reasons to use JSON in an application, for example, it's a common means of communicating with web APIs. This section will discuss other use-cases too, beginning with a technique to improve type safety when passing structural data over the FFI.</p>
<p>Let's revisit our earlier FFI functions <code>cumulativeSums</code> and <code>addComplex</code> and introduce a bug to each:</p>
<pre><code class="language-js">export const cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push(&quot;Broken&quot;); // Bug
  return sums;
};

export const addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>We can use the original type signatures, and the code will still compile, despite the fact that the return types are incorrect.</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>We can even execute the code, which might either produce unexpected results or a runtime error:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>For example, our resulting <code>sums</code> is no-longer a valid <code>Array Int</code>, now that a <code>String</code> is included in the Array. And further operations produce unexpected behavior, rather than an outright error, as the <code>sum</code> of these <code>sums</code> is <code>0</code> rather than <code>10</code>. This could be a difficult bug to track down!</p>
<p>Likewise, there are no errors when calling <code>addComplexBroken</code>; however, accessing the <code>imag</code> field of our <code>Complex</code> result will either produce unexpected behavior (returning <code>NaN</code> instead of <code>7.0</code>), or a non-obvious runtime error.</p>
<p>Let's use JSON to make our PureScript code more impervious to bugs in JavaScript code.</p>
<p>The <code>argonaut</code> library contains the JSON decoding and encoding capabilities we need. That library has excellent <a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">documentation</a>, so we will only cover basic usage in this book.</p>
<p>If we create an alternate foreign import that defines the return type as <code>Json</code>:</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>Note that we're simply pointing to our existing broken functions:</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSumsBroken
export const addComplexJson = addComplexBroken
</code></pre>
<p>And then write a wrapper to decode the returned foreign <code>Json</code> value:</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>Then any values that can't be successfully decoded to our return type appear as a <code>Left</code> error <code>String</code>:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left &quot;Couldn't decode Array (Failed at index 3): Value is not a Number&quot;)

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left &quot;JSON was missing expected field: imag&quot;)
</code></pre>
<p>If we call the working versions, a <code>Right</code> value is returned.</p>
<p>Try this yourself by modifying <code>test/Examples.js</code> with the following change to point to the working versions before running the next repl block.</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSums
export const addComplexJson = addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>Using JSON is also the easiest way to pass other structural types, such as <code>Map</code> and <code>Set</code> through the FFI. Note that since JSON only consists of booleans, numbers, strings, arrays, and objects of other JSON values, we can't write a <code>Map</code> and <code>Set</code> directly in JSON. But we can represent these structures as arrays (assuming the keys and values can also be represented in JSON), and then decode them back to <code>Map</code> or <code>Set</code>.</p>
<p>Here's an example of a foreign function signature that modifies a <code>Map</code> of <code>String</code> keys and <code>Int</code> values, along with the wrapper function that handles JSON encoding and decoding.</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>Note that this is a prime use case for function composition. Both of these alternatives are equivalent to the above:</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>Here is the JavaScript implementation. Note the <code>Array.from</code> step which is necessary to convert the JavaScript <code>Map</code> into a JSON-friendly format before decoding converts it back to a PureScript <code>Map</code>.</p>
<pre><code class="language-js">export const mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set(&quot;Foo&quot;, 42);
  return Array.from(m);
};
</code></pre>
<p>Now we can send and receive a <code>Map</code> over the FFI:</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple &quot;hat&quot; 1, Tuple &quot;cat&quot; 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple &quot;Foo&quot; 42),(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)]))
</code></pre>
<h2 id="exercises-30"><a class="header" href="#exercises-30">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Write a JavaScript function and PureScript wrapper <code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code> that returns a <code>Set</code> of all the values in a <code>Map</code>. <em>Hint</em>: The <code>.values()</code> instance method for Map may be useful in your JavaScript code.</p>
</li>
<li>
<p>(Easy) Write a new wrapper for the previous JavaScript function with the signature <code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code> so it works with a wider variety of maps. Note that you'll need to add some type class constraints for <code>k</code> and <code>v</code>. The compiler will guide you.</p>
</li>
<li>
<p>(Medium) Rewrite the earlier <code>quadraticRoots</code> function as <code>quadraticRootsSet</code> which returns the <code>Complex</code> roots as a <code>Set</code> via JSON (instead of as a <code>Pair</code>).</p>
</li>
<li>
<p>(Difficult) Rewrite the earlier <code>quadraticRoots</code> function as <code>quadraticRootsSafe</code> which uses JSON to pass the <code>Pair</code> of <code>Complex</code> roots over FFI. Don't use the <code>Pair</code> constructor in JavaScript, but instead, just return the pair in a decoder-compatible format.
<em>Hint</em>: You'll need to write a <code>DecodeJson</code> instance for <code>Pair</code>. Consult the <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonaut docs</a> for instruction on writing your own decode instance. Their <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a> instance may also be a helpful reference.  Note that you'll need a <code>newtype</code> wrapper for <code>Pair</code> to avoid creating an &quot;orphan instance&quot;.</p>
</li>
<li>
<p>(Medium) Write a <code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code> function to parse and decode a JSON string containing a 2D array, such as <code>&quot;[[1, 2, 3], [4, 5], [6]]&quot;</code>. <em>Hint</em>: You'll need to use <code>jsonParser</code> to convert the <code>String</code> into <code>Json</code> before decoding.</p>
</li>
<li>
<p>(Medium) The following data type represents a binary tree with values at the leaves:</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>Derive generic <code>EncodeJson</code> and <code>DecodeJson</code> instances for the <code>Tree</code> type.
Consult the <a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonaut docs</a> for instructions on how to do this.
Note that you'll also need generic instances of <code>Show</code> and <code>Eq</code> to enable unit testing for this exercise, but those should be straightforward to implement after tackling the JSON instances.</p>
</li>
<li>
<p>(Difficult) The following <code>data</code> type should be represented directly in JSON as either an integer or a string:</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>Write instances of <code>EncodeJson</code> and <code>DecodeJson</code> for the <code>IntOrString</code> data type which implement this behavior. <em>Hint</em>: The <code>alt</code> operator from <code>Control.Alt</code> may be helpful.</p>
</li>
</ol>
<h2 id="address-book"><a class="header" href="#address-book">Address book</a></h2>
<p>In this section we will apply our newly-acquired FFI and JSON knowledge to build on our address book example from chapter 8. We will add the following features:</p>
<ul>
<li>A Save button at the bottom of the form that, when clicked, serializes the state of the form to JSON and saves it in local storage.</li>
<li>Automatic retrieval of the JSON document from local storage upon page reload. The form fields are populated with the contents of this document.</li>
<li>A pop-up alert if there is an issue saving or loading the form state.</li>
</ul>
<p>We'll start by creating FFI wrappers for the following Web Storage APIs in our <code>Effect.Storage</code> module:</p>
<ul>
<li><code>setItem</code> takes a key and a value (both strings), and returns a computation which stores (or updates) the value in local storage at the specified key.</li>
<li><code>getItem</code> takes a key, and attempts to retrieve the associated value from local storage. However, since the <code>getItem</code> method on <code>window.localStorage</code> can return <code>null</code>, the return type is not <code>String</code>, but <code>Json</code>.</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>Here is the corresponding JavaScript implementation of these functions in <code>Effect/Storage.js</code>:</p>
<pre><code class="language-js">export const setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

export const getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>We'll create a save button like so:</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: &quot;form-group row col-form-label&quot;
    , children:
        [ D.button
            { className: &quot;btn-primary btn&quot;
            , onClick: handler_ validateAndSave
            , children: [ D.text &quot;Save&quot; ]
            }
        ]
    }
</code></pre>
<p>And write our validated <code>person</code> as a JSON string with <code>setItem</code> in the <code>validateAndSave</code> function:</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log &quot;Running validators&quot;
  case validatePerson' person of
    Left errs -&gt; log $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;
    Right validPerson -&gt; do
      setItem &quot;person&quot; $ stringify $ encodeJson validPerson
      log &quot;Saved&quot;
</code></pre>
<p>Note that if we attempt to compile at this stage, we'll encounter the following error:</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>This is because <code>PhoneType</code> in the <code>Person</code> record needs an <code>EncodeJson</code> instance. We'll just derive a generic encode instance, and a decode instance too while we're at it. More information how this works is available in the argonaut docs:</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance genericPhoneType :: Generic PhoneType _

instance encodeJsonPhoneType :: EncodeJson PhoneType where encodeJson = genericEncodeJson
instance decodeJsonPhoneType :: DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>Now we can save our <code>person</code> to local storage, but this isn't very useful unless we can retrieve the data. We'll tackle that next.</p>
<p>We'll start with retrieving the &quot;person&quot; string from local storage:</p>
<pre><code class="language-hs">item &lt;- getItem &quot;person&quot;
</code></pre>
<p>Then we'll create a helper function to handle converting the string from local storage to our <code>Person</code> record. Note that this string in storage may be <code>null</code>, so we represent it as a foreign <code>Json</code> until it is successfully decoded as a <code>String</code>. There are a number of other conversion steps along the way - each of which return an <code>Either</code> value, so it makes sense to organize these together in a <code>do</code> block.</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>Then we inspect this result to see if it succeeded. If it failed, we'll log the errors and use our default <code>examplePerson</code>, otherwise we'll use the person retrieved from local storage.</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>Finally, we'll pass this <code>initialPerson</code> to our component via the <code>props</code> record:</p>
<pre><code class="language-hs">-- Create JSX node from react component.
app = element addressBookApp { initialPerson }
</code></pre>
<p>And pick it up on the other side to use in our state hook:</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>As a finishing touch, we'll improve the quality of our error messages by appending to the <code>String</code> of each <code>Left</code> value with <code>lmap</code>.</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap (&quot;No string in local storage: &quot; &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap (&quot;Cannot parse JSON string: &quot;   &lt;&gt; _) $ jsonParser jsonString
  lmap               (&quot;Cannot decode Person: &quot;       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>Only the first error should ever occur during normal operation of this app. You can trigger the other errors by opening your web browser's dev tools, editing the saved &quot;person&quot; string in local storage, and refreshing the page. How you modify the JSON string determines which error is triggered. See if you can trigger each of them.</p>
<p>That covers local storage. Next we'll implement the <code>alert</code> action, which is very similar to the <code>log</code> action from the <code>Effect.Console</code> module. The only difference is that the <code>alert</code> action uses the <code>window.alert</code> method, whereas the <code>log</code> action uses the <code>console.log</code> method. As such, <code>alert</code> can only be used in environments where <code>window.alert</code> is defined, such as a web browser.</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">export const alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>We want this alert to appear when either:</p>
<ul>
<li>A user attempts to save a form with validation errors.</li>
<li>The state cannot be retrieved from local storage.</li>
</ul>
<p>That is accomplished by simply replacing <code>log</code> with <code>alert</code> on these lines:</p>
<pre><code class="language-hs">Left errs -&gt; alert $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;

alert $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
</code></pre>
<h2 id="exercises-31"><a class="header" href="#exercises-31">Exercises</a></h2>
<ol>
<li>(Easy) Write a wrapper for the <code>removeItem</code> method on the <code>localStorage</code> object, and add your foreign function to the <code>Effect.Storage</code> module.</li>
<li>(Medium) Add a &quot;Reset&quot; button that, when clicked, calls the newly-created <code>removeItem</code> function to delete the &quot;person&quot; entry from local storage.</li>
<li>(Easy) Write a wrapper for the <code>confirm</code> method on the JavaScript <code>Window</code> object, and add your foreign function to the <code>Effect.Alert</code> module.</li>
<li>(Medium) Call this <code>confirm</code> function when a users clicks the &quot;Reset&quot; button to ask if they're sure they want to reset their address book.</li>
</ol>
<h2 id="conclusion-8"><a class="header" href="#conclusion-8">Conclusion</a></h2>
<p>In this chapter, we've learned how to work with foreign JavaScript code from PureScript and we've seen the issues involved with writing trustworthy code using the FFI:</p>
<ul>
<li>We've seen the importance of ensuring that foreign functions have correct representations.</li>
<li>We learned how to deal with corner cases like null values and other types of JavaScript data, by using foreign types, or the <code>Json</code> data type.</li>
<li>We saw how to safely serialize and deserialize JSON data.</li>
</ul>
<p>For more examples, the <code>purescript</code>, <code>purescript-contrib</code> and <code>purescript-node</code> GitHub organizations provide plenty of examples of libraries which use the FFI. In the remaining chapters, we will see some of these libraries put to use to solve real-world problems in a type-safe way.</p>
<h2 id="addendum"><a class="header" href="#addendum">Addendum</a></h2>
<h3 id="calling-purescript-from-javascript"><a class="header" href="#calling-purescript-from-javascript">Calling PureScript from JavaScript</a></h3>
<p>Calling a PureScript function from JavaScript is very simple, at least for functions with simple types.</p>
<p>Let's take the following simple module as an example:</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>This function finds the greatest common divisor of two numbers by repeated subtraction. It is a nice example of a case where you might like to use PureScript to define the function, but have a requirement to call it from JavaScript: it is simple to define this function in PureScript using pattern matching and recursion, and the implementor can benefit from the use of the type checker.</p>
<p>To understand how this function can be called from JavaScript, it is important to realize that PureScript functions always get turned into JavaScript functions of a single argument, so we need to apply its arguments one-by-one:</p>
<pre><code class="language-javascript">import Test from 'Test.js';
Test.gcd(15)(20);
</code></pre>
<p>Here, I am assuming that the code was compiled with <code>spago build</code>, which compiles PureScript modules to ES modules. For that reason, I was able to reference the <code>gcd</code> function on the <code>Test</code> object, after importing the <code>Test</code> module using <code>import</code>.</p>
<p>You might also like to bundle JavaScript code for the browser, using <code>spago bundle-app --to file.js</code>. In that case, you would access the <code>Test</code> module from the global PureScript namespace, which defaults to <code>PS</code>:</p>
<pre><code class="language-javascript">var Test = PS.Test;
Test.gcd(15)(20);
</code></pre>
<h3 id="understanding-name-generation"><a class="header" href="#understanding-name-generation">Understanding Name Generation</a></h3>
<p>PureScript aims to preserve names during code generation as much as possible. In particular, most identifiers which are neither PureScript nor JavaScript keywords can be expected to be preserved, at least for names of top-level declarations.</p>
<p>If you decide to use a JavaScript keyword as an identifier, the name will be escaped with a double dollar symbol. For example,</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>In addition, if you would like to use special characters in your identifier names, they will be escaped using a single dollar symbol. For example,</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>Where compiled PureScript code is intended to be called from JavaScript, it is recommended that identifiers only use alphanumeric characters, and avoid JavaScript keywords. If user-defined operators are provided for use in PureScript code, it is good practice to provide an alternative function with an alphanumeric name for use in JavaScript.</p>
<h3 id="runtime-data-representation"><a class="header" href="#runtime-data-representation">Runtime Data Representation</a></h3>
<p>Types allow us to reason at compile-time that our programs are &quot;correct&quot; in some sense - that is, they will not break at runtime. But what does that mean? In PureScript, it means that the type of an expression should be compatible with its representation at runtime.</p>
<p>For that reason, it is important to understand the representation of data at runtime to be able to use PureScript and JavaScript code together effectively. This means that for any given PureScript expression, we should be able to understand the behavior of the value it will evaluate to at runtime.</p>
<p>The good news is that PureScript expressions have particularly simple representations at runtime. It should always be possible to understand the runtime data representation of an expression by considering its type.</p>
<p>For simple types, the correspondence is almost trivial. For example, if an expression has the type <code>Boolean</code>, then its value <code>v</code> at runtime should satisfy <code>typeof v === 'boolean'</code>. That is, expressions of type <code>Boolean</code> evaluate to one of the (JavaScript) values <code>true</code> or <code>false</code>. In particular, there is no PureScript expression of type <code>Boolean</code> which evaluates to <code>null</code> or <code>undefined</code>.</p>
<p>A similar law holds for expressions of type <code>Int</code>, <code>Number</code>, and <code>String</code> - expressions of type <code>Int</code> or <code>Number</code> evaluate to non-null JavaScript numbers, and expressions of type <code>String</code> evaluate to non-null JavaScript strings. Expressions of type <code>Int</code> will evaluate to integers at runtime, even though they cannot be distinguished from values of type <code>Number</code> by using <code>typeof</code>.</p>
<p>What about <code>Unit</code>? Well, since <code>Unit</code> has only one inhabitant (<code>unit</code>) and its value is not observable, it doesn't actually matter what it's represented with at runtime. Old code tends to represent it using <code>{}</code>. Newer code, however, tends to use <code>undefined</code>. So, although it doesn't really matter what you use to represent <code>Unit</code>, it is recommended to use <code>undefined</code> (not returning anything from a function also returns <code>undefined</code>).</p>
<p>What about some more complex types?</p>
<p>As we have already seen, PureScript functions correspond to JavaScript functions of a single argument. More precisely, if an expression <code>f</code> has type <code>a -&gt; b</code> for some types <code>a</code> and <code>b</code>, and an expression <code>x</code> evaluates to a value with the correct runtime representation for type <code>a</code>, then <code>f</code> evaluates to a JavaScript function, which when applied to the result of evaluating <code>x</code>, has the correct runtime representation for type <code>b</code>. As a simple example, an expression of type <code>String -&gt; String</code> evaluates to a function which takes non-null JavaScript strings to non-null JavaScript strings.</p>
<p>As you might expect, PureScript's arrays correspond to JavaScript arrays. But remember - PureScript arrays are homogeneous, so every element has the same type. Concretely, if a PureScript expression <code>e</code> has type <code>Array a</code> for some type <code>a</code>, then <code>e</code> evaluates to a (non-null) JavaScript array, all of whose elements have the correct runtime representation for type <code>a</code>.</p>
<p>We've already seen that PureScript's records evaluate to JavaScript objects. Just as for functions and arrays, we can reason about the runtime representation of data in a record's fields by considering the types associated with its labels. Of course, the fields of a record are not required to be of the same type.</p>
<h3 id="representing-adts"><a class="header" href="#representing-adts">Representing ADTs</a></h3>
<p>For every constructor of an algebraic data type, the PureScript compiler creates a new JavaScript object type by defining a function. Its constructors correspond to functions which create new JavaScript objects based on those prototypes.</p>
<p>For example, consider the following simple ADT:</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>The PureScript compiler generates the following code:</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>Here, we see two JavaScript object types: <code>Zero</code> and <code>One</code>. It is possible to create values of each type by using JavaScript's <code>new</code> keyword. For constructors with arguments, the compiler stores the associated data in fields called <code>value0</code>, <code>value1</code>, etc.</p>
<p>The PureScript compiler also generates helper functions. For constructors with no arguments, the compiler generates a <code>value</code> property, which can be reused instead of using the <code>new</code> operator repeatedly. For constructors with one or more arguments, the compiler generates a <code>create</code> function, which takes arguments with the appropriate representation and applies the appropriate constructor.</p>
<p>What about constructors with more than one argument? In that case, the PureScript compiler also creates a new object type, and a helper function. This time, however, the helper function is curried function of two arguments. For example, this algebraic data type:</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>generates this JavaScript code:</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>Here, values of the object type <code>Two</code> can be created using the <code>new</code> keyword, or by using the <code>Two.create</code> function.</p>
<p>The case of newtypes is slightly different. Recall that a newtype is like an algebraic data type, restricted to having a single constructor taking a single argument. In this case, the runtime representation of the newtype is actually the same as the type of its argument.</p>
<p>For example, this newtype representing telephone numbers:</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>is actually represented as a JavaScript string at runtime. This is useful for designing libraries, since newtypes provide an additional layer of type safety, but without the runtime overhead of another function call.</p>
<h3 id="representing-quantified-types"><a class="header" href="#representing-quantified-types">Representing Quantified Types</a></h3>
<p>Expressions with quantified (polymorphic) types have restrictive representations at runtime. In practice, this means that there are relatively few expressions with a given quantified type, but that we can reason about them quite effectively.</p>
<p>Consider this polymorphic type, for example:</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>What sort of functions have this type? Well, there is certainly one function with this type - namely, the <code>identity</code> function, defined in the <code>Prelude</code>:</p>
<pre><code class="language-haskell">id :: forall a. a -&gt; a
id a = a
</code></pre>
<p>In fact, the <code>identity</code> function is the <em>only</em> (total) function with this type! This certainly seems to be the case (try writing an expression with this type which is not observably equivalent to <code>identity</code>), but how can we be sure? We can be sure by considering the runtime representation of the type.</p>
<p>What is the runtime representation of a quantified type <code>forall a. t</code>? Well, any expression with the runtime representation for this type must have the correct runtime representation for the type <code>t</code> for any choice of type <code>a</code>. In our example above, a function of type <code>forall a. a -&gt; a</code> must have the correct runtime representation for the types <code>String -&gt; String</code>, <code>Number -&gt; Number</code>, <code>Array Boolean -&gt; Array Boolean</code>, and so on. It must take strings to strings, numbers to numbers, etc.</p>
<p>But that is not enough - the runtime representation of a quantified type is more strict than this. We require any expression to be <em>parametrically polymorphic</em> - that is, it cannot use any information about the type of its argument in its implementation. This additional condition prevents problematic implementations such as the following JavaScript function from inhabiting a polymorphic type:</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>Certainly, this function takes strings to strings, numbers to numbers, etc. but it does not meet the additional condition, since it inspects the (runtime) type of its argument, so this function would not be a valid inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>Without being able to inspect the runtime type of our function argument, our only option is to return the argument unchanged, and so <code>identity</code> is indeed the only inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>A full discussion of <em>parametric polymorphism</em> and <em>parametricity</em> is beyond the scope of this book. Note however, that since PureScript's types are <em>erased</em> at runtime, a polymorphic function in PureScript <em>cannot</em> inspect the runtime representation of its arguments (without using the FFI), and so this representation of polymorphic data is appropriate.</p>
<h3 id="representing-constrained-types"><a class="header" href="#representing-constrained-types">Representing Constrained Types</a></h3>
<p>Functions with a type class constraint have an interesting representation at runtime. Because the behavior of the function might depend on the type class instance chosen by the compiler, the function is given an additional argument, called a <em>type class dictionary</em>, which contains the implementation of the type class functions provided by the chosen instance.</p>
<p>For example, here is a simple PureScript function with a constrained type which uses the <code>Show</code> type class:</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>The generated JavaScript looks like this:</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p>Notice that <code>shout</code> is compiled to a (curried) function of two arguments, not one. The first argument <code>dict</code> is the type class dictionary for the <code>Show</code> constraint. <code>dict</code> contains the implementation of the <code>show</code> function for the type <code>a</code>.</p>
<p>We can call this function from JavaScript by passing an explicit type class dictionary from <code>Data.Show</code> as the first parameter:</p>
<pre><code class="language-javascript">import { showNumber } from 'Data.Show'

shout(showNumber)(42);
</code></pre>
<h3 id="exercises-32"><a class="header" href="#exercises-32">Exercises</a></h3>
<ol>
<li>
<p>(Easy) What are the runtime representations of these types?</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>What can you say about the expressions which have these types?</p>
</li>
<li>
<p>(Medium) Try using the functions defined in the <code>arrays</code> package, calling them from JavaScript, by compiling the library using <code>spago build</code> and importing modules using the <code>import</code> function in NodeJS. <em>Hint</em>: you may need to configure the output path so that the generated ES modules are available on the NodeJS module path.</p>
</li>
</ol>
<h3 id="representing-side-effects"><a class="header" href="#representing-side-effects">Representing Side Effects</a></h3>
<p>The <code>Effect</code> monad is also defined as a foreign type. Its runtime representation is quite simple - an expression of type <code>Effect a</code> should evaluate to a JavaScript function of <strong>no arguments</strong>, which performs any side-effects and returns a value with the correct runtime representation for type <code>a</code>.</p>
<p>The definition of the <code>Effect</code> type constructor is given in the <code>Effect</code> module as follows:</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>As a simple example, consider the <code>random</code> function defined in the <code>random</code> package. Recall that its type was:</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p>The definition of the <code>random</code> function is given here:</p>
<pre><code class="language-javascript">export const random = Math.random;
</code></pre>
<p>Notice that the <code>random</code> function is represented at runtime as a function of no arguments. It performs the side effect of generating a random number, and returns it, and the return value matches the runtime representation of the <code>Number</code> type: it is a non-null JavaScript number.</p>
<p>As a slightly more interesting example, consider the <code>log</code> function defined by the <code>Effect.Console</code> module in the <code>console</code> package. The <code>log</code> function has the following type:</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>And here is its definition:</p>
<pre><code class="language-javascript">export const log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>The representation of <code>log</code> at runtime is a JavaScript function of a single argument, returning a function of no arguments. The inner function performs the side-effect of writing a message to the console.</p>
<p>Expressions of type <code>Effect a</code> can be invoked from JavaScript like regular JavaScript methods. For example, since the <code>main</code> function is required to have type <code>Effect a</code> for some type <code>a</code>, it can be invoked as follows:</p>
<pre><code class="language-javascript">import { main } from 'Main'

main();
</code></pre>
<p>When using <code>spago bundle-app --to</code> or <code>spago run</code>, this call to <code>main</code> is generated automatically, whenever the <code>Main</code> module is defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monadic-adventures"><a class="header" href="#monadic-adventures">Monadic Adventures</a></h1>
<h2 id="chapter-goals-9"><a class="header" href="#chapter-goals-9">Chapter Goals</a></h2>
<p>The goal of this chapter will be to learn about <em>monad transformers</em>, which provide a way to combine side-effects provided by different monads. The motivating example will be a text adventure game which can be played on the console in NodeJS. The various side-effects of the game (logging, state, and configuration) will all be provided by a monad transformer stack.</p>
<h2 id="project-setup-8"><a class="header" href="#project-setup-8">Project Setup</a></h2>
<p>This module's project introduces the following new dependencies:</p>
<ul>
<li><code>ordered-collections</code>, which provides data types for immutable maps and sets</li>
<li><code>transformers</code>, which provides implementations of standard monad transformers</li>
<li><code>node-readline</code>, which provides FFI bindings to the <a href="https://nodejs.org/api/readline.html"><code>readline</code></a> interface provided by NodeJS</li>
<li><code>optparse</code>, which provides applicative parsers for processing command line arguments</li>
</ul>
<h2 id="how-to-play-the-game"><a class="header" href="#how-to-play-the-game">How To Play The Game</a></h2>
<p>To run the project, use <code>spago run</code></p>
<p>By default you will see a usage message:</p>
<pre><code class="language-text">Monadic Adventures! A game to learn monad transformers

Usage: run.js (-p|--player &lt;player name&gt;) [-d|--debug]
  Play the game as &lt;player name&gt;

Available options:
  -p,--player &lt;player name&gt;
                           The player's name &lt;String&gt;
  -d,--debug               Use debug mode
  -h,--help                Show this help text
</code></pre>
<p>To provide command line arguments, you can either call <code>spago run</code> with the <code>-a</code> option to pass additional arguments directly to your application, or you can call <code>spago bundle-app</code>, which will create an index.js file that can be run directly with <code>node</code>.<br />
For example, to provide the player name using the <code>-p</code> option:</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;
&gt;
</code></pre>
<pre><code class="language-text">$ spago bundle-app 
$ node index.js -p Phil
&gt;
</code></pre>
<p>From the prompt, you can enter commands like <code>look</code>, <code>inventory</code>, <code>take</code>, <code>use</code>, <code>north</code>, <code>south</code>, <code>east</code>, and <code>west</code>. There is also a <code>debug</code> command, which can be used to print the game state when the <code>--debug</code> command line option is provided.</p>
<p>The game is played on a two-dimensional grid, and the player moves by issuing commands <code>north</code>, <code>south</code>, <code>east</code>, and <code>west</code>. The game contains a collection of items which can either be in the player's possession (in the user's <em>inventory</em>), or on the game grid at some location. Items can be picked up by the player, using the <code>take</code> command.</p>
<p>For reference, here is a complete walkthrough of the game:</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre>
<p>The game is very simple, but the aim of the chapter is to use the <code>transformers</code> package to build a library which will enable rapid development of this type of game.</p>
<h2 id="the-state-monad"><a class="header" href="#the-state-monad">The State Monad</a></h2>
<p>We will start by looking at some of the monads provided by the <code>transformers</code> package.</p>
<p>The first example is the <code>State</code> monad, which provides a way to model <em>mutable state</em> in pure code. We have already seen an approach to mutable state provided by the <code>Effect</code> monad. <code>State</code> provides an alternative.</p>
<p>The <code>State</code> type constructor takes two type parameters: the type <code>s</code> of the state, and the return type <code>a</code>. Even though we speak of the &quot;<code>State</code> monad&quot;, the instance of the <code>Monad</code> type class is actually provided for the <code>State s</code> type constructor, for any type <code>s</code>.</p>
<p>The <code>Control.Monad.State</code> module provides the following API:</p>
<pre><code class="language-haskell">get     :: forall s.             State s s
gets    :: forall s. (s -&gt; a) -&gt; State s a
put     :: forall s. s        -&gt; State s Unit
modify  :: forall s. (s -&gt; s) -&gt; State s s
modify_ :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>Note that these API signatures are presented in a simplified form using the <code>State</code> type constructor for now. The actual API involves <code>MonadState</code> which we'll cover in the later &quot;Type Classes&quot; section of this chapter, so don't worry if you see different signatures in your IDE tooltips or on Pursuit.</p>
<p>Let's see an example. One use of the <code>State</code> monad might be to add the values in an array of integers to the current state. We could do that by choosing <code>Int</code> as the state type <code>s</code>, and using <code>traverse_</code> to traverse the array, with a call to <code>modify</code> for each array element:</p>
<pre><code class="language-haskell">import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class

sumArray :: Array Int -&gt; State Int Unit
sumArray = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre>
<p>The <code>Control.Monad.State</code> module provides three functions for running a computation in the <code>State</code> monad:</p>
<pre><code class="language-haskell">evalState :: forall s a. State s a -&gt; s -&gt; a
execState :: forall s a. State s a -&gt; s -&gt; s
runState  :: forall s a. State s a -&gt; s -&gt; Tuple a s
</code></pre>
<p>Each of these functions takes an initial state of type <code>s</code> and a computation of type <code>State s a</code>. <code>evalState</code> only returns the return value, <code>execState</code> only returns the final state, and <code>runState</code> returns both, expressed as a value of type <code>Tuple a s</code>.</p>
<p>Given the <code>sumArray</code> function above, we could use <code>execState</code> in PSCi to sum the numbers in several arrays as follows:</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ execState (do
‚Ä¶   sumArray [1, 2, 3]
‚Ä¶   sumArray [4, 5]
‚Ä¶   sumArray [6]) 0
‚Ä¶ ^D
21
</code></pre>
<h2 id="exercises-33"><a class="header" href="#exercises-33">Exercises</a></h2>
<ol>
<li>
<p>(Easy) What is the result of replacing <code>execState</code> with <code>runState</code> or <code>evalState</code> in our example above?</p>
</li>
<li>
<p>(Medium) A string of parentheses is <em>balanced</em> if it is obtained by either concatenating zero-or-more shorter balanced
strings, or by wrapping a shorter balanced string in a pair of parentheses.</p>
<p>Use the <code>State</code> monad and the <code>traverse_</code> function to write a function</p>
<pre><code class="language-haskell">testParens :: String -&gt; Boolean
</code></pre>
<p>which tests whether or not a <code>String</code> of parentheses is balanced, by keeping track of the number of opening parentheses
which have not been closed. Your function should work as follows:</p>
<pre><code class="language-text">&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false
</code></pre>
<p><em>Hint</em>: you may like to use the <code>toCharArray</code> function from the <code>Data.String.CodeUnits</code> module to turn the input string into an array of characters.</p>
</li>
</ol>
<h2 id="the-reader-monad"><a class="header" href="#the-reader-monad">The Reader Monad</a></h2>
<p>Another monad provided by the <code>transformers</code> package is the <code>Reader</code> monad. This monad provides the ability to read from a global configuration. Whereas the <code>State</code> monad provides the ability to read and write a single piece of mutable state, the <code>Reader</code> monad only provides the ability to read a single piece of data.</p>
<p>The <code>Reader</code> type constructor takes two type arguments: a type <code>r</code> which represents the configuration type, and the return type <code>a</code>.</p>
<p>The <code>Control.Monad.Reader</code> module provides the following API:</p>
<pre><code class="language-haskell">ask   :: forall r. Reader r r
local :: forall r a. (r -&gt; r) -&gt; Reader r a -&gt; Reader r a
</code></pre>
<p>The <code>ask</code> action can be used to read the current configuration, and the <code>local</code> action can be used to run a computation with a modified configuration.</p>
<p>For example, suppose we were developing an application controlled by permissions, and we wanted to use the <code>Reader</code> monad to hold the current user's permissions object. We might choose the type <code>r</code> to be some type <code>Permissions</code> with the following API:</p>
<pre><code class="language-haskell">hasPermission :: String -&gt; Permissions -&gt; Boolean
addPermission :: String -&gt; Permissions -&gt; Permissions
</code></pre>
<p>Whenever we wanted to check if the user had a particular permission, we could use <code>ask</code> to retrieve the current permissions object. For example, only administrators might be allowed to create new users:</p>
<pre><code class="language-haskell">createUser :: Reader Permissions (Maybe User)
createUser = do
  permissions &lt;- ask
  if hasPermission &quot;admin&quot; permissions
    then map Just newUser
    else pure Nothing
</code></pre>
<p>To elevate the user's permissions, we might use the <code>local</code> action to modify the <code>Permissions</code> object during the execution of some computation:</p>
<pre><code class="language-haskell">runAsAdmin :: forall a. Reader Permissions a -&gt; Reader Permissions a
runAsAdmin = local (addPermission &quot;admin&quot;)
</code></pre>
<p>Then we could write a function to create a new user, even if the user did not have the <code>admin</code> permission:</p>
<pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre>
<p>To run a computation in the <code>Reader</code> monad, the <code>runReader</code> function can be used to provide the global configuration:</p>
<pre><code class="language-haskell">runReader :: forall r a. Reader r a -&gt; r -&gt; a
</code></pre>
<h2 id="exercises-34"><a class="header" href="#exercises-34">Exercises</a></h2>
<p>In these exercises, we will use the <code>Reader</code> monad to build a small library for rendering documents with indentation. The &quot;global configuration&quot; will be a number indicating the current indentation level:</p>
<pre><code class="language-haskell">type Level = Int

type Doc = Reader Level String
</code></pre>
<ol>
<li>
<p>(Easy) Write a function <code>line</code> which renders a function at the current indentation level. Your function should have the following type:</p>
<pre><code class="language-haskell">line :: String -&gt; Doc
</code></pre>
<p><em>Hint</em>: use the <code>ask</code> function to read the current indentation level. The <code>power</code> function from <code>Data.Monoid</code> may be helpful too.</p>
</li>
<li>
<p>(Easy) Use the <code>local</code> function to write a function</p>
<pre><code class="language-haskell">indent :: Doc -&gt; Doc
</code></pre>
<p>which increases the indentation level for a block of code.</p>
</li>
<li>
<p>(Medium) Use the <code>sequence</code> function defined in <code>Data.Traversable</code> to write a function</p>
<pre><code class="language-haskell">cat :: Array Doc -&gt; Doc
</code></pre>
<p>which concatenates a collection of documents, separating them with new lines.</p>
</li>
<li>
<p>(Medium) Use the <code>runReader</code> function to write a function</p>
<pre><code class="language-haskell">render :: Doc -&gt; String
</code></pre>
<p>which renders a document as a String.</p>
</li>
</ol>
<p>You should now be able to use your library to write simple documents, as follows:</p>
<pre><code class="language-haskell">render $ cat
  [ line &quot;Here is some indented text:&quot;
  , indent $ cat
      [ line &quot;I am indented&quot;
      , line &quot;So am I&quot;
      , indent $ line &quot;I am even more indented&quot;
      ]
  ]
</code></pre>
<h2 id="the-writer-monad"><a class="header" href="#the-writer-monad">The Writer Monad</a></h2>
<p>The <code>Writer</code> monad provides the ability to accumulate a secondary value in addition to the return value of a computation.</p>
<p>A common use case is to accumulate a log of type <code>String</code> or <code>Array String</code>, but the <code>Writer</code> monad is more general than this. It can actually be used to accumulate a value in any monoid, so it might be used to keep track of an integer total using the <code>Additive Int</code> monoid, or to track whether any of several intermediate <code>Boolean</code> values were true, using the <code>Disj Boolean</code> monoid.</p>
<p>The <code>Writer</code> type constructor takes two type arguments: a type <code>w</code> which should be an instance of the <code>Monoid</code> type class, and the return type <code>a</code>.</p>
<p>The key element of the <code>Writer</code> API is the <code>tell</code> function:</p>
<pre><code class="language-haskell">tell :: forall w a. Monoid w =&gt; w -&gt; Writer w Unit
</code></pre>
<p>The <code>tell</code> action appends the provided value to the current accumulated result.</p>
<p>As an example, let's add a log to an existing function by using the <code>Array String</code> monoid. Consider our previous implementation of the <em>greatest common divisor</em> function:</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>We could add a log to this function by changing the return type to <code>Writer (Array String) Int</code>:</p>
<pre><code class="language-haskell">import Control.Monad.Writer
import Control.Monad.Writer.Class

gcdLog :: Int -&gt; Int -&gt; Writer (Array String) Int
</code></pre>
<p>We only have to change our function slightly to log the two inputs at each step:</p>
<pre><code class="language-haskell">    gcdLog n 0 = pure n
    gcdLog 0 m = pure m
    gcdLog n m = do
      tell [&quot;gcdLog &quot; &lt;&gt; show n &lt;&gt; &quot; &quot; &lt;&gt; show m]
      if n &gt; m
        then gcdLog (n - m) m
        else gcdLog n (m - n)
</code></pre>
<p>We can run a computation in the <code>Writer</code> monad by using either of the <code>execWriter</code> or <code>runWriter</code> functions:</p>
<pre><code class="language-haskell">execWriter :: forall w a. Writer w a -&gt; w
runWriter  :: forall w a. Writer w a -&gt; Tuple a w
</code></pre>
<p>Just like in the case of the <code>State</code> monad, <code>execWriter</code> only returns the accumulated log, whereas <code>runWriter</code> returns both the log and the result.</p>
<p>We can test our modified function in PSCi:</p>
<pre><code class="language-text">&gt; import Control.Monad.Writer
&gt; import Control.Monad.Writer.Class

&gt; runWriter (gcdLog 21 15)
Tuple 3 [&quot;gcdLog 21 15&quot;,&quot;gcdLog 6 15&quot;,&quot;gcdLog 6 9&quot;,&quot;gcdLog 6 3&quot;,&quot;gcdLog 3 3&quot;]
</code></pre>
<h2 id="exercises-35"><a class="header" href="#exercises-35">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Rewrite the <code>sumArray</code> function above using the <code>Writer</code> monad and the <code>Additive Int</code> monoid from the <code>monoid</code> package.</p>
</li>
<li>
<p>(Medium) The <em>Collatz</em> function is defined on natural numbers <code>n</code> as <code>n / 2</code> when <code>n</code> is even, and <code>3 * n + 1</code> when <code>n</code> is odd. For example, the iterated Collatz sequence starting at <code>10</code> is as follows:</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>It is conjectured that the iterated Collatz sequence always reaches <code>1</code> after some finite number of applications of the Collatz function.</p>
<p>Write a function which uses recursion to calculate how many iterations of the Collatz function are required before the sequence reaches <code>1</code>.</p>
<p>Modify your function to use the <code>Writer</code> monad to log each application of the Collatz function.</p>
</li>
</ol>
<h2 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h2>
<p>Each of the three monads above: <code>State</code>, <code>Reader</code> and <code>Writer</code>, are also examples of so-called <em>monad transformers</em>. The equivalent monad transformers are called <code>StateT</code>, <code>ReaderT</code>, and <code>WriterT</code> respectively.</p>
<p>What is a monad transformer? Well, as we have seen, a monad augments PureScript code with some type of side effect, which can be interpreted in PureScript by using the appropriate handler (<code>runState</code>, <code>runReader</code>, <code>runWriter</code>, etc.) This is fine if we only need to use <em>one</em> side-effect. However, it is often useful to use more than one side-effect at once. For example, we might want to use <code>Reader</code> together with <code>Maybe</code> to express <em>optional results</em> in the context of some global configuration. Or we might want the mutable state provided by the <code>State</code> monad together with the pure error tracking capability of the <code>Either</code> monad. This is the problem solved by <em>monad transformers</em>.</p>
<p>Note that we have already seen that the <code>Effect</code> monad provides a partial solution to this problem. Monad transformers provide another solution, and each approach has its own benefits and limitations.</p>
<p>A monad transformer is a type constructor which is parameterized not only by a type, but by another type constructor. It takes one monad and turns it into another monad, adding its own variety of side-effects.</p>
<p>Let's see an example. The monad transformer version of the <code>State</code> monad is <code>StateT</code>, defined in the <code>Control.Monad.State.Trans</code> module. We can find the kind of <code>StateT</code> using PSCi:</p>
<pre><code class="language-text">&gt; import Control.Monad.State.Trans
&gt; :kind StateT
Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>This looks quite confusing, but we can apply <code>StateT</code> one argument at a time to understand how to use it.</p>
<p>The first type argument is the type of the state we wish to use, as was the case for <code>State</code>. Let's use a state of type <code>String</code>:</p>
<pre><code class="language-text">&gt; :kind StateT String
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>The next argument is a type constructor of kind <code>Type -&gt; Type</code>. It represents the underlying monad, which we want to add the effects of <code>StateT</code> to. For the sake of an example, let's choose the <code>Either String</code> monad:</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String)
Type -&gt; Type
</code></pre>
<p>We are left with a type constructor. The final argument represents the return type, and we might instantiate it to <code>Number</code> for example:</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String) Number
Type
</code></pre>
<p>Finally we are left with something of kind <code>Type</code>, which means we can try to find values of this type.</p>
<p>The monad we have constructed - <code>StateT String (Either String)</code> - represents computations which can fail with an error, and which can use mutable state.</p>
<p>We can use the actions of the outer <code>StateT String</code> monad (<code>get</code>, <code>put</code>, and <code>modify</code>) directly, but in order to use the effects of the wrapped monad (<code>Either String</code>), we need to &quot;lift&quot; them over the monad transformer. The <code>Control.Monad.Trans</code> module defines the <code>MonadTrans</code> type class, which captures those type constructors which are monad transformers, as follows:</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>This class contains a single member, <code>lift</code>, which takes computations in any underlying monad <code>m</code> and lifts them into the wrapped monad <code>t m</code>. In our case, the type constructor <code>t</code> is <code>StateT String</code>, and <code>m</code> is the <code>Either String</code> monad, so <code>lift</code> provides a way to lift computations of type <code>Either String a</code> to computations of type <code>StateT String (Either String) a</code>. This means that we can use the effects of <code>StateT String</code> and <code>Either String</code> side-by-side, as long as we use <code>lift</code> every time we use a computation of type <code>Either String a</code>.</p>
<p>For example, the following computation reads the underlying state, and then throws an error if the state is the empty string:</p>
<pre><code class="language-haskell">import Data.String (drop, take)

split :: StateT String (Either String) String
split = do
  s &lt;- get
  case s of
    &quot;&quot; -&gt; lift $ Left &quot;Empty string&quot;
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>If the state is not empty, the computation uses <code>put</code> to update the state to <code>drop 1 s</code> (that is, <code>s</code> with the first character removed), and returns <code>take 1 s</code> (that is, the first character of <code>s</code>).</p>
<p>Let's try this in PSCi:</p>
<pre><code class="language-text">&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;
</code></pre>
<p>This is not very remarkable, since we could have implemented this without <code>StateT</code>. However, since we are working in a monad, we can use do notation or applicative combinators to build larger computations from smaller ones. For example, we can apply <code>split</code> twice to read the first two characters from a string:</p>
<pre><code class="language-text">&gt; runStateT ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple &quot;te&quot; &quot;st&quot;))
</code></pre>
<p>We can use the <code>split</code> function with a handful of other actions to build a basic parsing library. In fact, this is the approach taken by the <code>parsing</code> library. This is the power of monad transformers - we can create custom-built monads for a variety of problems, choosing the side-effects that we need, and keeping the expressiveness of do notation and applicative combinators.</p>
<h2 id="the-exceptt-monad-transformer"><a class="header" href="#the-exceptt-monad-transformer">The ExceptT Monad Transformer</a></h2>
<p>The <code>transformers</code> package also defines the <code>ExceptT e</code> monad transformer, which is the transformer corresponding to the <code>Either e</code> monad. It provides the following API:</p>
<pre><code class="language-haskell">class MonadError e m where
  throwError :: forall a. e -&gt; m a
  catchError :: forall a. m a -&gt; (e -&gt; m a) -&gt; m a

instance monadErrorExceptT :: Monad m =&gt; MonadError e (ExceptT e m)

runExceptT :: forall e m a. ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p>The <code>MonadError</code> class captures those monads which support throwing and catching of errors of some type <code>e</code>, and an instance is provided for the <code>ExceptT e</code> monad transformer. The <code>throwError</code> action can be used to indicate failure, just like <code>Left</code> in the <code>Either e</code> monad. The <code>catchError</code> action allows us to continue after an error is thrown using <code>throwError</code>.</p>
<p>The <code>runExceptT</code> handler is used to run a computation of type <code>ExceptT e m a</code>.</p>
<p>This API is similar to that provided by the <code>exceptions</code> package and the <code>Exception</code> effect. However, there are some important differences:</p>
<ul>
<li><code>Exception</code> uses actual JavaScript exceptions, whereas <code>ExceptT</code> models errors as a pure data structure.</li>
<li>The <code>Exception</code> effect only supports exceptions of one type, namely JavaScript's <code>Error</code> type, whereas <code>ExceptT</code> supports errors of any type. In particular, we are free to define new error types.</li>
</ul>
<p>Let's try out <code>ExceptT</code> by using it to wrap the <code>Writer</code> monad. Again, we are free to use actions from the monad transformer <code>ExceptT e</code> directly, but computations in the <code>Writer</code> monad should be lifted using <code>lift</code>:</p>
<pre><code class="language-haskell">import Control.Monad.Except
import Control.Monad.Writer

writerAndExceptT :: ExceptT String (Writer (Array String)) String
writerAndExceptT = do
  lift $ tell [&quot;Before the error&quot;]
  _ &lt;- throwError &quot;Error!&quot;
  lift $ tell [&quot;After the error&quot;]
  pure &quot;Return value&quot;
</code></pre>
<p>If we test this function in PSCi, we can see how the two effects of accumulating a log and throwing an error interact. First, we can run the outer <code>ExceptT</code> computation of type by using <code>runExceptT</code>, leaving a result of type <code>Writer (Array String) (Either String String)</code>. We can then use <code>runWriter</code> to run the inner <code>Writer</code> computation:</p>
<pre><code class="language-text">&gt; runWriter $ runExceptT writerAndExceptT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]
</code></pre>
<p>Note that only those log messages which were written before the error was thrown actually get appended to the log.</p>
<h2 id="monad-transformer-stacks"><a class="header" href="#monad-transformer-stacks">Monad Transformer Stacks</a></h2>
<p>As we have seen, monad transformers can be used to build new monads on top of existing monads. For some monad transformer <code>t1</code> and some monad <code>m</code>, the application <code>t1 m</code> is also a monad. That means that we can apply a <em>second</em> monad transformer <code>t2</code> to the result <code>t1 m</code> to construct a third monad <code>t2 (t1 m)</code>. In this way, we can construct a <em>stack</em> of monad transformers, which combine the side-effects provided by their constituent monads.</p>
<p>In practice, the underlying monad <code>m</code> is either the <code>Effect</code> monad, if native side-effects are required, or the <code>Identity</code> monad, defined in the <code>Data.Identity</code> module. The <code>Identity</code> monad adds no new side-effects, so transforming the <code>Identity</code> monad only provides the effects of the monad transformer. In fact, the <code>State</code>, <code>Reader</code> and <code>Writer</code> monads are implemented by transforming the <code>Identity</code> monad with <code>StateT</code>, <code>ReaderT</code> and <code>WriterT</code> respectively.</p>
<p>Let's see an example in which three side effects are combined. We will use the <code>StateT</code>, <code>WriterT</code> and <code>ExceptT</code> effects, with the <code>Identity</code> monad on the bottom of the stack. This monad transformer stack will provide the side effects of mutable state, accumulating a log, and pure errors.</p>
<p>We can use this monad transformer stack to reproduce our <code>split</code> action with the added feature of logging.</p>
<pre><code class="language-haskell">type Errors = Array String

type Log = Array String

type Parser = StateT String (WriterT Log (ExceptT Errors Identity))

split :: Parser String
split = do
  s &lt;- get
  lift $ tell [&quot;The state is &quot; &lt;&gt; s]
  case s of
    &quot;&quot; -&gt; lift $ lift $ throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>If we test this computation in PSCi, we see that the state is appended to the log for every invocation of <code>split</code>.</p>
<p>Note that we have to remove the side-effects in the order in which they appear in the monad transformer stack: first we use <code>runStateT</code> to remove the <code>StateT</code> type constructor, then <code>runWriterT</code>, then <code>runExceptT</code>. Finally, we run the computation in the <code>Identity</code> monad by using <code>unwrap</code>.</p>
<pre><code class="language-text">&gt; runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
(Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;]))

&gt; runParser ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;]))
</code></pre>
<p>However, if the parse is unsuccessful because the state is empty, then no log is printed at all:</p>
<pre><code class="language-text">&gt; runParser split &quot;&quot;
(Left [&quot;Empty string&quot;])
</code></pre>
<p>This is because of the way in which the side-effects provided by the <code>ExceptT</code> monad transformer interact with the side-effects provided by the <code>WriterT</code> monad transformer. We can address this by changing the order in which the monad transformer stack is composed. If we move the <code>ExceptT</code> transformer to the top of the stack, then the log will contain all messages written up until the first error, as we saw earlier when we transformed <code>Writer</code> with <code>ExceptT</code>.</p>
<p>One problem with this code is that we have to use the <code>lift</code> function multiple times to lift computations over multiple monad transformers: for example, the call to <code>throwError</code> has to be lifted twice, once over <code>WriterT</code> and a second time over <code>StateT</code>. This is fine for small monad transformer stacks, but quickly becomes inconvenient.</p>
<p>Fortunately, as we will see, we can use the automatic code generation provided by type class inference to do most of this &quot;heavy lifting&quot; for us.</p>
<h2 id="exercises-36"><a class="header" href="#exercises-36">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use the <code>ExceptT</code> monad transformer over the <code>Identity</code> functor to write a function <code>safeDivide</code> which divides two numbers, throwing an error (as the String &quot;Divide by zero!&quot;) if the denominator is zero.</p>
</li>
<li>
<p>(Medium) Write a parser</p>
<pre><code class="language-haskell">string :: String -&gt; Parser String
</code></pre>
<p>which matches a string as a prefix of the current state, or fails with an error message.</p>
<p>Your parser should work as follows:</p>
<pre><code class="language-text">&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;
(Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;]))
</code></pre>
<p><em>Hint</em>: you can use the implementation of <code>split</code> as a starting point. You might find the <code>stripPrefix</code> function useful.</p>
</li>
<li>
<p>(Difficult) Use the <code>ReaderT</code> and <code>WriterT</code> monad transformers to reimplement the document printing library which we wrote earlier using the <code>Reader</code> monad.</p>
<p>Instead of using <code>line</code> to emit strings and <code>cat</code> to concatenate strings, use the <code>Array String</code> monoid with the <code>WriterT</code> monad transformer, and <code>tell</code> to append a line to the result. Use the same names as in the original implementation but ending with an apostrophe (<code>'</code>).</p>
</li>
</ol>
<h2 id="type-classes-to-the-rescue"><a class="header" href="#type-classes-to-the-rescue">Type Classes to the Rescue!</a></h2>
<p>When we looked at the <code>State</code> monad at the start of this chapter, I gave the following types for the actions of the <code>State</code> monad:</p>
<pre><code class="language-haskell">get    :: forall s.             State s s
put    :: forall s. s        -&gt; State s Unit
modify :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>In reality, the types given in the <code>Control.Monad.State.Class</code> module are more general than this:</p>
<pre><code class="language-haskell">get    :: forall m s. MonadState s m =&gt;             m s
put    :: forall m s. MonadState s m =&gt; s        -&gt; m Unit
modify :: forall m s. MonadState s m =&gt; (s -&gt; s) -&gt; m Unit
</code></pre>
<p>The <code>Control.Monad.State.Class</code> module defines the <code>MonadState</code> (multi-parameter) type class, which allows us to abstract over &quot;monads which support pure mutable state&quot;. As one would expect, the <code>State s</code> type constructor is an instance of the <code>MonadState s</code> type class, but there are many more interesting instances of this class.</p>
<p>In particular, there are instances of <code>MonadState</code> for the <code>WriterT</code>, <code>ReaderT</code> and <code>ExceptT</code> monad transformers, provided in the <code>transformers</code> package. Each of these monad transformers has an instance for <code>MonadState</code> whenever the underlying <code>Monad</code> does. In practice, this means that as long as <code>StateT</code> appears <em>somewhere</em> in the monad transformer stack, and everything above <code>StateT</code> is an instance of <code>MonadState</code>, then we are free to use <code>get</code>, <code>put</code> and <code>modify</code> directly, without the need to use <code>lift</code>.</p>
<p>Indeed, the same is true of the actions we covered for the <code>ReaderT</code>, <code>WriterT</code>, and <code>ExceptT</code> transformers. <code>transformers</code> defines a type class for each of the major transformers, allowing us to abstract over monads which support their operations.</p>
<p>In the case of the <code>split</code> function above, the monad stack we constructed is an instance of each of the <code>MonadState</code>, <code>MonadWriter</code> and <code>MonadError</code> type classes. This means that we don't need to call <code>lift</code> at all! We can just use the actions <code>get</code>, <code>put</code>, <code>tell</code> and <code>throwError</code> as if they were defined on the monad stack itself:</p>
<pre><code class="language-haskell">split :: Parser String
split = do
  s &lt;- get
  tell [&quot;The state is &quot; &lt;&gt; show s]
  case s of
    &quot;&quot; -&gt; throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>This computation really looks like we have extended our programming language to support the three new side-effects of mutable state, logging and error handling. However, everything is still implemented using pure functions and immutable data under the hood.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>The <code>control</code> package defines a number of abstractions for working with computations which can fail. One of these is the <code>Alternative</code> type class:</p>
<pre><code class="language-haskell">class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<p><code>Alternative</code> provides two new combinators: the <code>empty</code> value, which provides a prototype for a failing computation, and the <code>alt</code> function (and its alias, <code>&lt;|&gt;</code>) which provides the ability to fall back to an <em>alternative</em> computation in the case of an error.</p>
<p>The <code>Data.Array</code> module provides two useful functions for working with type constructors in the <code>Alternative</code> type class:</p>
<pre><code class="language-haskell">many :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
some :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
</code></pre>
<p>There is also an equivalent <code>many</code> and <code>some</code> for <code>Data.List</code></p>
<p>The <code>many</code> combinator uses the <code>Alternative</code> type class to repeatedly run a computation <em>zero-or-more</em> times. The <code>some</code> combinator is similar, but requires at least the first computation to succeed.</p>
<p>In the case of our <code>Parser</code> monad transformer stack, there is an instance of <code>Alternative</code> induced by the <code>ExceptT</code> component, which supports failure by composing errors in different branches using a <code>Monoid</code> instance (this is why we chose <code>Array String</code> for our <code>Errors</code> type). This means that we can use the <code>many</code> and <code>some</code> functions to run a parser multiple times:</p>
<pre><code class="language-text">&gt; import Data.Array (many)

&gt; runParser (many split) &quot;test&quot;
(Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;)
              [ &quot;The state is \&quot;test\&quot;&quot;
              , &quot;The state is \&quot;est\&quot;&quot;
              , &quot;The state is \&quot;st\&quot;&quot;
              , &quot;The state is \&quot;t\&quot;&quot;
              ]))
</code></pre>
<p>Here, the input string <code>&quot;test&quot;</code> has been repeatedly split to return an array of four single-character strings, the leftover state is empty, and the log shows that we applied the <code>split</code> combinator four times.</p>
<h2 id="monad-comprehensions"><a class="header" href="#monad-comprehensions">Monad Comprehensions</a></h2>
<p>The <code>Control.MonadPlus</code> module defines a subclass of the <code>Alternative</code> type class, called <code>MonadPlus</code>. <code>MonadPlus</code> captures those type constructors which are both monads and instances of <code>Alternative</code>:</p>
<pre><code class="language-haskell">class (Monad m, Alternative m) &lt;= MonadPlus m
</code></pre>
<p>In particular, our <code>Parser</code> monad is an instance of <code>MonadPlus</code>.</p>
<p>When we covered array comprehensions earlier in the book, we introduced the <code>guard</code> function, which could be used to filter out unwanted results. In fact, the <code>guard</code> function is more general, and can be used for any monad which is an instance of <code>MonadPlus</code>:</p>
<pre><code class="language-haskell">guard :: forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p>The <code>&lt;|&gt;</code> operator allows us to backtrack in case of failure. To see how this is useful, let's define a variant of the <code>split</code> combinator which only matches upper case characters:</p>
<pre><code class="language-haskell">upper :: Parser String
upper = do
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre>
<p>Here, we use a <code>guard</code> to fail if the string is not upper case. Note that this code looks very similar to the array comprehensions we saw earlier - using <code>MonadPlus</code> in this way, we sometimes refer to constructing <em>monad comprehensions</em>.</p>
<h2 id="backtracking"><a class="header" href="#backtracking">Backtracking</a></h2>
<p>We can use the <code>&lt;|&gt;</code> operator to backtrack to another alternative in case of failure. To demonstrate this, let's define one more parser, which matches lower case characters:</p>
<pre><code class="language-haskell">lower :: Parser String
lower = do
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre>
<p>With this, we can define a parser which eagerly matches many upper case characters if the first character is upper case, or many lower case character if the first character is lower case:</p>
<pre><code class="language-text">&gt; upperOrLower = some upper &lt;|&gt; some lower
</code></pre>
<p>This parser will match characters until the case changes:</p>
<pre><code class="language-text">&gt; runParser upperOrLower &quot;abcDEF&quot;
(Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;))
              [ &quot;The state is \&quot;abcDEF\&quot;&quot;
              , &quot;The state is \&quot;bcDEF\&quot;&quot;
              , &quot;The state is \&quot;cDEF\&quot;&quot;
              ]))
</code></pre>
<p>We can even use <code>many</code> to fully split a string into its lower and upper case components:</p>
<pre><code class="language-text">&gt; components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
(Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;)
              [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;CDeFgh\&quot;&quot;
              , &quot;The state is \&quot;DeFgh\&quot;&quot;
              , &quot;The state is \&quot;eFgh\&quot;&quot;
              , &quot;The state is \&quot;Fgh\&quot;&quot;
              , &quot;The state is \&quot;gh\&quot;&quot;
              , &quot;The state is \&quot;h\&quot;&quot;
              ]))
</code></pre>
<p>Again, this illustrates the power of reusability that monad transformers bring - we were able to write a backtracking parser in a declarative style with only a few lines of code, by reusing standard abstractions!</p>
<h2 id="exercises-37"><a class="header" href="#exercises-37">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Remove the calls to the <code>lift</code> function from your implementation of the <code>string</code> parser. Verify that the new implementation type checks, and convince yourself that it should.</p>
</li>
<li>
<p>(Medium) Use your <code>string</code> parser with the <code>some</code> combinator to write a parser <code>asFollowedByBs</code> which recognizes strings consisting of several copies of the string <code>&quot;a&quot;</code> followed by several copies of the string <code>&quot;b&quot;</code>.</p>
</li>
<li>
<p>(Medium) Use the <code>&lt;|&gt;</code> operator to write a parser <code>asOrBs</code> which recognizes strings of the letters <code>a</code> or <code>b</code> in any order.</p>
</li>
<li>
<p>(Difficult) The <code>Parser</code> monad might also be defined as follows:</p>
<pre><code class="language-haskell">type Parser = ExceptT Errors (StateT String (WriterT Log Identity))
</code></pre>
<p>What effect does this change have on our parsing functions?</p>
</li>
</ol>
<h2 id="the-rws-monad"><a class="header" href="#the-rws-monad">The RWS Monad</a></h2>
<p>One particular combination of monad transformers is so common that it is provided as a single monad transformer in the <code>transformers</code> package. The <code>Reader</code>, <code>Writer</code> and <code>State</code> monads are combined into the <em>reader-writer-state</em> monad, or more simply the <code>RWS</code> monad. This monad has a corresponding monad transformer called the <code>RWST</code> monad transformer.</p>
<p>We will use the <code>RWS</code> monad to model the game logic for our text adventure game.</p>
<p>The <code>RWS</code> monad is defined in terms of three type parameters (in addition to its return type):</p>
<pre><code class="language-haskell">type RWS r w s = RWST r w s Identity
</code></pre>
<p>Notice that the <code>RWS</code> monad is defined in terms of its own monad transformer, by setting the base monad to <code>Identity</code> which provides no side-effects.</p>
<p>The first type parameter, <code>r</code>, represents the global configuration type. The second, <code>w</code>, represents the monoid which we will use to accumulate a log, and the third, <code>s</code> is the type of our mutable state.</p>
<p>In the case of our game, our global configuration is defined in a type called <code>GameEnvironment</code> in the <code>Data.GameEnvironment</code> module:</p>
<pre><code class="language-haskell">type PlayerName = String

newtype GameEnvironment = GameEnvironment
  { playerName    :: PlayerName
  , debugMode     :: Boolean
  }
</code></pre>
<p>It defines the player name, and a flag which indicates whether or not the game is running in debug mode. These options will be set from the command line when we come to run our monad transformer.</p>
<p>The mutable state is defined in a type called <code>GameState</code> in the <code>Data.GameState</code> module:</p>
<pre><code class="language-haskell">import Data.Map as M
import Data.Set as S

newtype GameState = GameState
  { items       :: M.Map Coords (S.Set GameItem)
  , player      :: Coords
  , inventory   :: S.Set GameItem
  }
</code></pre>
<p>The <code>Coords</code> data type represents points on a two-dimensional grid, and the <code>GameItem</code> data type is an enumeration of the items in the game:</p>
<pre><code class="language-haskell">data GameItem = Candle | Matches
</code></pre>
<p>The <code>GameState</code> type uses two new data structures: <code>Map</code> and <code>Set</code>, which represent sorted maps and sorted sets respectively. The <code>items</code> property is a mapping from coordinates of the game grid to sets of game items at that location. The <code>player</code> property stores the current coordinates of the player, and the <code>inventory</code> property stores a set of game items currently held by the player.</p>
<p>The <code>Map</code> and <code>Set</code> data structures are sorted by their keys, can be used with any key type in the <code>Ord</code> type class. This means that the keys in our data structures should be totally ordered.</p>
<p>We will see how the <code>Map</code> and <code>Set</code> structures are used as we write the actions for our game.</p>
<p>For our log, we will use the <code>List String</code> monoid. We can define a type synonym for our <code>Game</code> monad, implemented using <code>RWS</code>:</p>
<pre><code class="language-haskell">type Log = L.List String

type Game = RWS GameEnvironment Log GameState
</code></pre>
<h2 id="implementing-game-logic"><a class="header" href="#implementing-game-logic">Implementing Game Logic</a></h2>
<p>Our game is going to be built from simple actions defined in the <code>Game</code> monad, by reusing the actions from the <code>Reader</code>, <code>Writer</code> and <code>State</code> monads. At the top level of our application, we will run the pure computations in the <code>Game</code> monad, and use the <code>Effect</code> monad to turn the results into observable side-effects, such as printing text to the console.</p>
<p>One of the simplest actions in our game is the <code>has</code> action. This action tests whether the player's inventory contains a particular game item. It is defined as follows:</p>
<pre><code class="language-haskell">has :: GameItem -&gt; Game Boolean
has item = do
  GameState state &lt;- get
  pure $ item `S.member` state.inventory
</code></pre>
<p>This function uses the <code>get</code> action defined in the <code>MonadState</code> type class to read the current game state, and then uses the <code>member</code> function defined in <code>Data.Set</code> to test whether the specified <code>GameItem</code> appears in the <code>Set</code> of inventory items.</p>
<p>Another action is the <code>pickUp</code> action. It adds a game item to the player's inventory if it appears in the current room. It uses actions from the <code>MonadWriter</code> and <code>MonadState</code> type classes. First of all, it reads the current game state:</p>
<pre><code class="language-haskell">pickUp :: GameItem -&gt; Game Unit
pickUp item = do
  GameState state &lt;- get
</code></pre>
<p>Next, <code>pickUp</code> looks up the set of items in the current room. It does this by using the <code>lookup</code> function defined in <code>Data.Map</code>:</p>
<pre><code class="language-haskell">  case state.player `M.lookup` state.items of
</code></pre>
<p>The <code>lookup</code> function returns an optional result indicated by the <code>Maybe</code> type constructor. If the key does not appear in the map, the <code>lookup</code> function returns <code>Nothing</code>, otherwise it returns the corresponding value in the <code>Just</code> constructor.</p>
<p>We are interested in the case where the corresponding item set contains the specified game item. Again we can test this using the <code>member</code> function:</p>
<pre><code class="language-haskell">    Just items | item `S.member` items -&gt; do
</code></pre>
<p>In this case, we can use <code>put</code> to update the game state, and <code>tell</code> to add a message to the log:</p>
<pre><code class="language-haskell">          let newItems = M.update (Just &lt;&lt;&lt; S.delete item) state.player state.items
              newInventory = S.insert item state.inventory
          put $ GameState state { items     = newItems
                                , inventory = newInventory
                                }
          tell (L.singleton (&quot;You now have the &quot; &lt;&gt; show item))
</code></pre>
<p>Note that there is no need to <code>lift</code> either of the two computations here, because there are appropriate instances for both <code>MonadState</code> and <code>MonadWriter</code> for our <code>Game</code> monad transformer stack.</p>
<p>The argument to <code>put</code> uses a record update to modify the game state's <code>items</code> and <code>inventory</code> fields. We use the <code>update</code> function from <code>Data.Map</code> which modifies a value at a particular key. In this case, we modify the set of items at the player's current location, using the <code>delete</code> function to remove the specified item from the set. <code>inventory</code> is also updated, using <code>insert</code> to add the new item to the player's inventory set.</p>
<p>Finally, the <code>pickUp</code> function handles the remaining cases, by notifying the user using <code>tell</code>:</p>
<pre><code class="language-haskell">    _ -&gt; tell (L.singleton &quot;I don't see that item here.&quot;)
</code></pre>
<p>As an example of using the <code>Reader</code> monad, we can look at the code for the <code>debug</code> command. This command allows the user to inspect the game state at runtime if the game is running in debug mode:</p>
<pre><code class="language-haskell">  GameEnvironment env &lt;- ask
  if env.debugMode
    then do
      state :: GameState &lt;- get
      tell (L.singleton (show state))
    else tell (L.singleton &quot;Not running in debug mode.&quot;)
</code></pre>
<p>Here, we use the <code>ask</code> action to read the game configuration. Again, note that we don't need to <code>lift</code> any computation, and we can use actions defined in the <code>MonadState</code>, <code>MonadReader</code> and <code>MonadWriter</code> type classes in the same do notation block.</p>
<p>If the <code>debugMode</code> flag is set, then the <code>tell</code> action is used to write the state to the log. Otherwise, an error message is added.</p>
<p>The remainder of the <code>Game</code> module defines a set of similar actions, each using only the actions defined by the <code>MonadState</code>, <code>MonadReader</code> and <code>MonadWriter</code> type classes.</p>
<h2 id="running-the-computation"><a class="header" href="#running-the-computation">Running the Computation</a></h2>
<p>Since our game logic runs in the <code>RWS</code> monad, it is necessary to run the computation in order to respond to the user's commands.</p>
<p>The front-end of our game is built using two packages: <code>optparse</code>, which provides applicative command line parsing, and <code>node-readline</code>, which wraps NodeJS' <code>readline</code> module, allowing us to write interactive console-based applications.</p>
<p>The interface to our game logic is provided by the function <code>game</code> in the <code>Game</code> module:</p>
<pre><code class="language-haskell">game :: Array String -&gt; Game Unit
</code></pre>
<p>To run this computation, we pass a list of words entered by the user as an array of strings, and run the resulting <code>RWS</code> computation using <code>runRWS</code>:</p>
<pre><code class="language-haskell">data RWSResult state result writer = RWSResult state result writer

runRWS :: forall r w s a. RWS r w s a -&gt; r -&gt; s -&gt; RWSResult s a w
</code></pre>
<p><code>runRWS</code> looks like a combination of <code>runReader</code>, <code>runWriter</code> and <code>runState</code>. It takes a global configuration and an initial state as an argument, and returns a data structure containing the log, the result and the final state.</p>
<p>The front-end of our application is defined by a function <code>runGame</code>, with the following type signature:</p>
<pre><code class="language-haskell">runGame :: GameEnvironment -&gt; Effect Unit
</code></pre>
<p>This function interacts with the user via the console (using the <code>node-readline</code> and <code>console</code> packages). <code>runGame</code> takes the game configuration as a function argument.</p>
<p>The <code>node-readline</code> package provides the <code>LineHandler</code> type, which represents actions in the <code>Effect</code> monad which handle user input from the terminal. Here is the corresponding API:</p>
<pre><code class="language-haskell">type LineHandler a = String -&gt; Effect a

foreign import setLineHandler
  :: forall a
   . Interface
  -&gt; LineHandler a
  -&gt; Effect Unit
</code></pre>
<p>The <code>Interface</code> type represents a handle for the console, and is passed as an argument to the functions which interact with it. An <code>Interface</code> can be created using the <code>createConsoleInterface</code> function:</p>
<pre><code class="language-haskell">import Node.ReadLine as RL

runGame env = do
  interface &lt;- RL.createConsoleInterface RL.noCompletion
</code></pre>
<p>The first step is to set the prompt at the console. We pass the <code>interface</code> handle, and provide the prompt string and indentation level:</p>
<pre><code class="language-haskell">  RL.setPrompt &quot;&gt; &quot; interface
</code></pre>
<p>In our case, we are interested in implementing the line handler function. Our line handler is defined using a helper function in a <code>let</code> declaration, as follows:</p>
<pre><code class="language-haskell">    lineHandler :: GameState -&gt; String -&gt; Effect Unit
    lineHandler currentState input = do
      case runRWS (game (split (wrap &quot; &quot;) input)) env currentState of
        RWSResult state _ written -&gt; do
          for_ written log
          RL.setLineHandler (lineHandler state) $ interface
      RL.prompt interface
      pure unit
</code></pre>
<p>The <code>let</code> binding is closed over both the game configuration, named <code>env</code>, and the console handle, named <code>interface</code>.</p>
<p>Our handler takes an additional first argument, the game state. This is required since we need to pass the game state to <code>runRWS</code> to run the game's logic.</p>
<p>The first thing this action does is to break the user input into words using the <code>split</code> function from the <code>Data.String</code> module. It then uses <code>runRWS</code> to run the <code>game</code> action (in the <code>RWS</code> monad), passing the game environment and current game state.</p>
<p>Having run the game logic, which is a pure computation, we need to print any log messages to the screen and show the user a prompt for the next command. The <code>for_</code> action is used to traverse the log (of type <code>List String</code>) and print its entries to the console. Finally, <code>setLineHandler</code> is used to update the line handler function to use the updated game state, and the prompt is displayed again using the <code>prompt</code> action.</p>
<p>The <code>runGame</code> function finally attaches the initial line handler to the console interface, and displays the initial prompt:</p>
<pre><code class="language-haskell">  RL.setLineHandler (lineHandler initialGameState) interface
  RL.prompt interface
</code></pre>
<h2 id="exercises-38"><a class="header" href="#exercises-38">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Implement a new command <code>cheat</code>, which moves all game items from the game grid into the user's inventory. Create a function <code>cheat :: Game Unit</code> in the <code>Game</code> module, and use this function from <code>game</code>.</p>
</li>
<li>
<p>(Difficult) The <code>Writer</code> component of the <code>RWS</code> monad is currently used for two types of messages: error messages and informational messages. Because of this, several parts of the code use case statements to handle error cases.</p>
<p>Refactor the code to use the <code>ExceptT</code> monad transformer to handle the error messages, and <code>RWS</code> to handle informational messages. <em>Note:</em> There are no tests for this exercise.</p>
</li>
</ol>
<h2 id="handling-command-line-options"><a class="header" href="#handling-command-line-options">Handling Command Line Options</a></h2>
<p>The final piece of the application is responsible for parsing command line options and creating the <code>GameEnvironment</code> configuration record. For this, we use the <code>optparse</code> package.</p>
<p><code>optparse</code> is an example of <em>applicative command line option parsing</em>. Recall that an applicative functor allows us to lift functions of arbitrary arity over a type constructor representing some type of side-effect. In the case of the <code>optparse</code> package, the functor we are interested in is the <code>Parser</code> functor (imported from the optparse module <code>Options.Applicative</code>, not to be confused with our <code>Parser</code> that we defined in the <code>Split</code> module), which adds the side-effect of reading from command line options. It provides the following handler:</p>
<pre><code class="language-haskell">customExecParser :: forall a. ParserPrefs ‚Üí ParserInfo a ‚Üí Effect a
</code></pre>
<p>This is best illustrated by example. The application's <code>main</code> function is defined using <code>customExecParser</code> as follows:</p>
<pre><code class="language-haskell">main = OP.customExecParser prefs argParser &gt;&gt;= runGame 
</code></pre>
<p>The first argument is used to configure the <code>optparse</code> library. In our case, we simply configure it to show the help message when the application is run without any arguments (instead of showing a &quot;missing argument&quot; error) by using <code>OP.prefs OP.showHelpOnEmpty</code>, but the <code>Options.Applicative.Builder</code> module provides several other options.</p>
<p>The second argument is the complete description of our parser program:</p>
<pre><code class="language-haskell">  argParser :: OP.ParserInfo GameEnvironment
  argParser = OP.info (env &lt;**&gt; OP.helper) parserOptions

  parserOptions = fold 
    [ OP.fullDesc
    , OP.progDesc &quot;Play the game as &lt;player name&gt;&quot;
    , OP.header &quot;Monadic Adventures! A game to learn monad transformers&quot; 
    ]
</code></pre>
<p>Here <code>OP.info</code> combines a <code>Parser</code> with a set of options for how the help message is formatted. <code>env &lt;**&gt; OP.helper</code> takes any command line argument <code>Parser</code> named <code>env</code> and adds a <code>--help</code> option to it automatically. Options for the help message are of type <code>InfoMod</code>, which is a monoid, so we can use the <code>fold</code> function to add several options together.</p>
<p>The interesting part of our parser is constructing the <code>GameEnvironment</code>:</p>
<pre><code class="language-haskell">  env :: OP.Parser GameEnvironment
  env = gameEnvironment &lt;$&gt; player &lt;*&gt; debug

  player :: OP.Parser String
  player = OP.strOption $ fold 
    [ OP.long &quot;player&quot;
    , OP.short 'p'
    , OP.metavar &quot;&lt;player name&gt;&quot;
    , OP.help &quot;The player's name &lt;String&gt;&quot;
    ]

  debug :: OP.Parser Boolean
  debug = OP.switch $ fold 
    [ OP.long &quot;debug&quot;
    , OP.short 'd'
    , OP.help &quot;Use debug mode&quot;
    ]
</code></pre>
<p><code>player</code> and <code>debug</code> are both <code>Parser</code>s, so we can use our applicative operators <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to lift our <code>gameEnvironment</code> function, which has the type <code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code> over <code>Parser</code>. <code>OP.strOption</code> constructs a command line option that expects a string value, and is configured via a collection of <code>Mod</code>s folded together. <code>OP.flag</code> works similarly, but doesn't expect an associated value. <code>optparse</code> offers extensive <a href="https://pursuit.purescript.org/packages/purescript-optparse">documentation</a> on different modifiers available to build various command line parsers.</p>
<p>Notice how we were able to use the notation afforded by the applicative operators to give a compact, declarative specification of our command line interface. In addition, it is simple to add new command line arguments, simply by adding a new function argument to <code>runGame</code>, and then using <code>&lt;*&gt;</code> to lift <code>runGame</code> over an additional argument in the definition of <code>env</code>.</p>
<h2 id="exercises-39"><a class="header" href="#exercises-39">Exercises</a></h2>
<ol>
<li>(Medium) Add a new Boolean-valued property <code>cheatMode</code> to the <code>GameEnvironment</code> record. Add a new command line flag <code>-c</code> to the <code>optparse</code> configuration which enables cheat mode. The <code>cheat</code> command from the previous exercise should be disallowed if cheat mode is not enabled.</li>
</ol>
<h2 id="conclusion-9"><a class="header" href="#conclusion-9">Conclusion</a></h2>
<p>This chapter was a practical demonstration of the techniques we've learned so far, using monad transformers to build a pure specification of our game, and the <code>Effect</code> monad to build a front-end using the console.</p>
<p>Because we separated our implementation from the user interface, it would be possible to create other front-ends for our game. For example, we could use the <code>Effect</code> monad to render the game in the browser using the Canvas API or the DOM.</p>
<p>We have seen how monad transformers allow us to write safe code in an imperative style, where effects are tracked by the type system. In addition, type classes provide a powerful way to abstract over the actions provided by a monad, enabling code reuse. We were able to use standard abstractions like <code>Alternative</code> and <code>MonadPlus</code> to build useful monads by combining standard monad transformers.</p>
<p>Monad transformers are an excellent demonstration of the sort of expressive code that can be written by relying on advanced type system features such as higher-kinded polymorphism and multi-parameter type classes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas-graphics"><a class="header" href="#canvas-graphics">Canvas Graphics</a></h1>
<h2 id="chapter-goals-10"><a class="header" href="#chapter-goals-10">Chapter Goals</a></h2>
<p>This chapter will be an extended example focussing on the <code>canvas</code> package, which provides a way to generate 2D graphics from PureScript using the HTML5 Canvas API.</p>
<h2 id="project-setup-9"><a class="header" href="#project-setup-9">Project Setup</a></h2>
<p>This module's project introduces the following new dependencies:</p>
<ul>
<li><code>canvas</code>, which gives types to methods from the HTML5 Canvas API</li>
<li><code>refs</code>, which provides a side-effect for using <em>global mutable references</em></li>
</ul>
<p>The source code for the chapter is broken up into a set of modules, each of which defines a <code>main</code> method. Different sections of this chapter are implemented in different files, and the <code>Main</code> module can be changed by modifying the Spago build command to run the appropriate file's <code>main</code> method at each point.</p>
<p>The HTML file <code>html/index.html</code> contains a single <code>canvas</code> element which will be used in each example, and a <code>script</code> element to load the compiled PureScript code. To test the code for each section, open the HTML file in your browser. Because most exercises target the browser, there are no unit tests for this chapter.</p>
<h2 id="simple-shapes"><a class="header" href="#simple-shapes">Simple Shapes</a></h2>
<p>The <code>Example/Rectangle.purs</code> file contains a simple introductory example, which draws a single blue rectangle at the center of the canvas. The module imports the <code>Effect</code> type from the <code>Effect</code> module, and also the <code>Graphics.Canvas</code> module, which contains actions in the <code>Effect</code> monad for working with the Canvas API.</p>
<p>The <code>main</code> action starts, like in the other modules, by using the <code>getCanvasElementById</code> action to get a reference to the canvas object, and the <code>getContext2D</code> action to access the 2D rendering context for the canvas:</p>
<p>The <code>void</code> function takes a functor and replaces its value with <code>Unit</code>. In the example it is used to make <code>main</code> conform with its signature.</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><em>Note</em>: the call to <code>unsafePartial</code> here is necessary since the pattern match on the result of <code>getCanvasElementById</code> is partial, matching only the <code>Just</code> constructor. For our purposes, this is fine, but in production code, we would probably want to match the <code>Nothing</code> constructor and provide an appropriate error message.</p>
<p>The types of these actions can be found using PSCi or by looking at the documentation:</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code> and <code>Context2D</code> are types defined in the <code>Graphics.Canvas</code> module. The same module also defines the <code>Canvas</code> effect, which is used by all of the actions in the module.</p>
<p>The graphics context <code>ctx</code> manages the state of the canvas, and provides methods to render primitive shapes, set styles and colors, and apply transformations.</p>
<p>We continue by setting the fill style to solid blue using the <code>setFillStyle</code> action. The longer hex notation of <code>#0000FF</code> may also be used for blue, but shorthand notation is easier for simple colors:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p>Note that the <code>setFillStyle</code> action takes the graphics context as an argument. This is a common pattern in the <code>Graphics.Canvas</code> module.</p>
<p>Finally, we use the <code>fillPath</code> action to fill the rectangle. <code>fillPath</code> has the following type:</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code> takes a graphics context and another action which builds the path to render. To build a path, we can use the <code>rect</code> action. <code>rect</code> takes a graphics context, and a record which provides the position and size of the rectangle:</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>Build the rectangle example, providing <code>Example.Rectangle</code> as the name of the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>Now, open the <code>html/index.html</code> file and verify that this code renders a blue rectangle in the center of the canvas.</p>
<h2 id="putting-row-polymorphism-to-work"><a class="header" href="#putting-row-polymorphism-to-work">Putting Row Polymorphism to Work</a></h2>
<p>There are other ways to render paths. The <code>arc</code> function renders an arc segment, and the <code>moveTo</code>, <code>lineTo</code> and <code>closePath</code> functions can be used to render piecewise-linear paths.</p>
<p>The <code>Shapes.purs</code> file renders three shapes: a rectangle, an arc segment and a triangle.</p>
<p>We have seen that the <code>rect</code> function takes a record as its argument. In fact, the properties of the rectangle are defined in a type synonym:</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p>The <code>x</code> and <code>y</code> properties represent the location of the top-left corner, while the <code>w</code> and <code>h</code> properties represent the width and height respectively.</p>
<p>To render an arc segment, we can use the <code>arc</code> function, passing a record with the following type:</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>Here, the <code>x</code> and <code>y</code> properties represent the center point, <code>r</code> is the radius, and <code>start</code> and <code>end</code> represent the endpoints of the arc in radians.</p>
<p>For example, this code fills an arc segment centered at <code>(300, 300)</code> with radius <code>50</code>. The arc completes 2/3rds of a rotation. Note that the unit circle is flipped vertically, since the y-axis increases towards the bottom of the canvas:</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p>Notice that both the <code>Rectangle</code> and <code>Arc</code> record types contain <code>x</code> and <code>y</code> properties of type <code>Number</code>. In both cases, this pair represents a point. This means that we can write row-polymorphic functions which can act on either type of record.</p>
<p>For example, the <code>Shapes</code> module defines a <code>translate</code> function which translates a shape by modifying its <code>x</code> and <code>y</code> properties:</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>Notice the row-polymorphic type. It says that <code>translate</code> accepts any record with <code>x</code> and <code>y</code> properties <em>and any other properties</em>, and returns the same type of record. The <code>x</code> and <code>y</code> fields are updated, but the rest of the fields remain unchanged.</p>
<p>This is an example of <em>record update syntax</em>. The expression <code>shape { ... }</code> creates a new record based on the <code>shape</code> record, with the fields inside the braces updated to the specified values. Note that the expressions inside the braces are separated from their labels by equals symbols, not colons like in record literals.</p>
<p>The <code>translate</code> function can be used with both the <code>Rectangle</code> and <code>Arc</code> records, as can be seen in the <code>Shapes</code> example.</p>
<p>The third type of path rendered in the <code>Shapes</code> example is a piecewise-linear path. Here is the corresponding code:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>There are three functions in use here:</p>
<ul>
<li><code>moveTo</code> moves the current location of the path to the specified coordinates,</li>
<li><code>lineTo</code> renders a line segment between the current location and the specified coordinates, and updates the current location,</li>
<li><code>closePath</code> completes the path by rendering a line segment joining the current location to the start position.</li>
</ul>
<p>The result of this code snippet is to fill an isosceles triangle.</p>
<p>Build the example by specifying <code>Example.Shapes</code> as the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>and open <code>html/index.html</code> again to see the result. You should see the three different types of shapes rendered to the canvas.</p>
<h2 id="exercises-40"><a class="header" href="#exercises-40">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Experiment with the <code>strokePath</code> and <code>setStrokeStyle</code> functions in each of the examples so far.</p>
</li>
<li>
<p>(Easy) The <code>fillPath</code> and <code>strokePath</code> functions can be used to render complex paths with a common style by using a do notation block inside the function argument. Try changing the <code>Rectangle</code> example to render two rectangles side-by-side using the same call to <code>fillPath</code>. Try rendering a sector of a circle by using a combination of a piecewise-linear path and an arc segment.</p>
</li>
<li>
<p>(Medium) Given the following record type:</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>which represents a 2D point, write a function <code>renderPath</code> which strokes a closed path constructed from a number of points:</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>Given a function</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>which takes a <code>Number</code> between <code>0</code> and <code>1</code> as its argument and returns a <code>Point</code>, write an action which plots <code>f</code> by using your <code>renderPath</code> function. Your action should approximate the path by sampling <code>f</code> at a finite set of points.</p>
<p>Experiment by rendering different paths by varying the function <code>f</code>.</p>
</li>
</ol>
<h2 id="drawing-random-circles"><a class="header" href="#drawing-random-circles">Drawing Random Circles</a></h2>
<p>The <code>Example/Random.purs</code> file contains an example which uses the <code>Effect</code> monad to interleave two different types of side-effect: random number generation, and canvas manipulation. The example renders one hundred randomly generated circles onto the canvas.</p>
<p>The <code>main</code> action obtains a reference to the graphics context as before, and then sets the stroke and fill styles:</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>Next, the code uses the <code>for_</code> function to loop over the integers between <code>0</code> and <code>100</code>:</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>On each iteration, the do notation block starts by generating three random numbers distributed between <code>0</code> and <code>1</code>. These numbers represent the <code>x</code> and <code>y</code> coordinates, and the radius of a circle:</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>Next, for each circle, the code creates an <code>Arc</code> based on these parameters and finally fills and strokes the arc with the current styles:</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x                  : x * 600.0
         , y                  : y * 600.0
         , radius             : r * 50.0
         , start              : 0.0
         , end                : Number.tau
         , useCounterClockwise: false
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>Build this example by specifying the <code>Example.Random</code> module as the main module:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p>and view the result by opening <code>html/index.html</code>.</p>
<h2 id="transformations"><a class="header" href="#transformations">Transformations</a></h2>
<p>There is more to the canvas than just rendering simple shapes. Every canvas maintains a transformation which is used to transform shapes before rendering. Shapes can be translated, rotated, scaled, and skewed.</p>
<p>The <code>canvas</code> library supports these transformations using the following functions:</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p>The <code>translate</code> action performs a translation whose components are specified by the properties of the <code>TranslateTransform</code> record.</p>
<p>The <code>rotate</code> action performs a rotation around the origin, through some number of radians specified by the first argument.</p>
<p>The <code>scale</code> action performs a scaling, with the origin as the center. The <code>ScaleTransform</code> record specifies the scale factors along the <code>x</code> and <code>y</code> axes.</p>
<p>Finally, <code>transform</code> is the most general action of the four here. It performs an affine transformation specified by a matrix.</p>
<p>Any shapes rendered after these actions have been invoked will automatically have the appropriate transformation applied.</p>
<p>In fact, the effect of each of these functions is to <em>post-multiply</em> the transformation with the context's current transformation. The result is that if multiple transformations applied after one another, then their effects are actually applied in reverse:</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>The effect of this sequence of actions is that the scene is rotated, then scaled, and finally translated.</p>
<h2 id="preserving-the-context"><a class="header" href="#preserving-the-context">Preserving the Context</a></h2>
<p>A common use case is to render some subset of the scene using a transformation, and then to reset the transformation afterwards.</p>
<p>The Canvas API provides the <code>save</code> and <code>restore</code> methods, which manipulate a <em>stack</em> of states associated with the canvas. <code>canvas</code> wraps this functionality into the following functions:</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p>The <code>save</code> action pushes the current state of the context (including the current transformation and any styles) onto the stack, and the <code>restore</code> action pops the top state from the stack and restores it.</p>
<p>This allows us to save the current state, apply some styles and transformations, render some primitives, and finally restore the original transformation and state. For example, the following function performs some canvas action, but applies a rotation before doing so, and restores the transformation afterwards:</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>In the interest of abstracting over common use cases using higher-order functions, the <code>canvas</code> library provides the <code>withContext</code> function, which performs some canvas action while preserving the original context state:</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p>We could rewrite the <code>rotated</code> function above using <code>withContext</code> as follows:</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="global-mutable-state"><a class="header" href="#global-mutable-state">Global Mutable State</a></h2>
<p>In this section, we'll use the <code>refs</code> package to demonstrate another effect in the <code>Effect</code> monad.</p>
<p>The <code>Effect.Ref</code> module provides a type constructor for global mutable references, and an associated effect:</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>A value of type <code>Ref a</code> is a mutable reference cell containing a value of type <code>a</code>, used to track global mutation. As such, it should be used sparingly.</p>
<p>The <code>Example/Refs.purs</code> file contains an example which uses a <code>Ref</code> to track mouse clicks on the <code>canvas</code> element.</p>
<p>The code starts by creating a new reference containing the value <code>0</code>, by using the <code>new</code> action:</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>Inside the click event handler, the <code>modify</code> action is used to update the click count, and the updated value is returned.</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p>In the <code>render</code> function, the click count is used to determine the transformation applied to a rectangle:</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Number.sin (toNumber count * Number.tau / 8.0) + 1.5
    let scaleY = Number.sin (toNumber count * Number.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Number.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>This action uses <code>withContext</code> to preserve the original transformation, and then applies the following sequence of transformations (remember that transformations are applied bottom-to-top):</p>
<ul>
<li>The rectangle is translated through <code>(-100, -100)</code> so that its center lies at the origin.</li>
<li>The rectangle is scaled around the origin.</li>
<li>The rectangle is rotated through some multiple of <code>10</code> degrees around the origin.</li>
<li>The rectangle is translated through <code>(300, 300)</code> so that it center lies at the center of the canvas.</li>
</ul>
<p>Build the example:</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p>and open the <code>html/index.html</code> file. If you click the canvas repeatedly, you should see a green rectangle rotating around the center of the canvas.</p>
<h2 id="exercises-41"><a class="header" href="#exercises-41">Exercises</a></h2>
<ol>
<li>(Easy) Write a higher-order function which strokes and fills a path simultaneously. Rewrite the <code>Random.purs</code> example using your function.</li>
<li>(Medium) Use <code>Random</code> and <code>Dom</code> to create an application which renders a circle with random position, color and radius to the canvas when the mouse is clicked.</li>
<li>(Medium) Write a function which transforms the scene by rotating it around a point with specified coordinates. <em>Hint</em>: use a translation to first translate the scene to the origin.</li>
</ol>
<h2 id="l-systems"><a class="header" href="#l-systems">L-Systems</a></h2>
<p>In this final example, we will use the <code>canvas</code> package to write a function for rendering <em>L-systems</em> (or <em>Lindenmayer systems</em>).</p>
<p>An L-system is defined by an <em>alphabet</em>, an initial sequence of letters from the alphabet, and a set of <em>production rules</em>. Each production rule takes a letter of the alphabet and returns a sequence of replacement letters. This process is iterated some number of times starting with the initial sequence of letters.</p>
<p>If each letter of the alphabet is associated with some instruction to perform on the canvas, the L-system can be rendered by following the instructions in order.</p>
<p>For example, suppose the alphabet consists of the letters <code>L</code> (turn left), <code>R</code> (turn right) and <code>F</code> (move forward). We might define the following production rules:</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>If we start with the initial sequence &quot;FRRFRRFRR&quot; and iterate, we obtain the following sequence:</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>and so on. Plotting a piecewise-linear path corresponding to this set of instruction approximates a curve called the <em>Koch curve</em>. Increasing the number of iterations increases the resolution of the curve.</p>
<p>Let's translate this into the language of types and functions.</p>
<p>We can represent our alphabet of letters with the following ADT:</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>This data type defines one data constructor for each letter in our alphabet.</p>
<p>How can we represent the initial sequence of letters? Well, that's just an array of letters from our alphabet, which we will call a <code>Sentence</code>:</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>Our production rules can be represented as a function from <code>Letter</code> to <code>Sentence</code> as follows:</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>This is just copied straight from the specification above.</p>
<p>Now we can implement a function <code>lsystem</code> which will take a specification in this form, and render it to the canvas. What type should <code>lsystem</code> have? Well, it needs to take values like <code>initial</code> and <code>productions</code> as arguments, as well as a function which can render a letter of the alphabet to the canvas.</p>
<p>Here is a first approximation to the type of <code>lsystem</code>:</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>The first two argument types correspond to the values <code>initial</code> and <code>productions</code>.</p>
<p>The third argument represents a function which takes a letter of the alphabet and <em>interprets</em> it by performing some actions on the canvas. In our example, this would mean turning left in the case of the letter <code>L</code>, turning right in the case of the letter <code>R</code>, and moving forward in the case of a letter <code>F</code>.</p>
<p>The final argument is a number representing the number of iterations of the production rules we would like to perform.</p>
<p>The first observation is that the <code>lsystem</code> function should work for only one type of <code>Letter</code>, but for any type, so we should generalize our type accordingly. Let's replace <code>Letter</code> and <code>Sentence</code> with <code>a</code> and <code>Array a</code> for some quantified type variable <code>a</code>:</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>The second observation is that, in order to implement instructions like &quot;turn left&quot; and &quot;turn right&quot;, we will need to maintain some state, namely the direction in which the path is moving at any time. We need to modify our function to pass the state through the computation. Again, the <code>lsystem</code> function should work for any type of state, so we will represent it using the type variable <code>s</code>.</p>
<p>We need to add the type <code>s</code> in three places:</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>Firstly, the type <code>s</code> was added as the type of an additional argument to <code>lsystem</code>. This argument will represent the initial state of the L-system.</p>
<p>The type <code>s</code> also appears as an argument to, and as the return type of the interpretation function (the third argument to <code>lsystem</code>). The interpretation function will now receive the current state of the L-system as an argument, and will return a new, updated state as its return value.</p>
<p>In the case of our example, we can define use following type to represent the state:</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>The properties <code>x</code> and <code>y</code> represent the current position of the path, and the <code>theta</code> property represents the current direction of the path, specified as the angle between the path direction and the horizontal axis, in radians.</p>
<p>The initial state of the system might be specified as follows:</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>Now let's try to implement the <code>lsystem</code> function. We will find that its definition is remarkably simple.</p>
<p>It seems reasonable that <code>lsystem</code> should recurse on its fourth argument (of type <code>Int</code>). On each step of the recursion, the current sentence will change, having been updated by using the production rules. With that in mind, let's begin by introducing names for the function arguments, and delegating to a helper function:</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p>The <code>go</code> function works by recursion on its second argument. There are two cases: when <code>n</code> is zero, and when <code>n</code> is non-zero.</p>
<p>In the first case, the recursion is complete, and we simply need to interpret the current sentence according to the interpretation function. We have a sentence of type <code>Array a</code>, a state of type <code>s</code>, and a function of type <code>s -&gt; a -&gt; Effect s</code>. This sounds like a job for the <code>foldM</code> function which we defined earlier, and which is available from the <code>control</code> package:</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>What about in the non-zero case? In that case, we can simply apply the production rules to each letter of the current sentence, concatenate the results, and repeat by calling <code>go</code> recursively:</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>That's it! Note how the use of higher order functions like <code>foldM</code> and <code>concatMap</code> allowed us to communicate our ideas concisely.</p>
<p>However, we're not quite done. The type we have given is actually still too specific. Note that we don't use any canvas operations anywhere in our implementation. Nor do we make use of the structure of the <code>Effect</code> monad at all. In fact, our function works for <em>any</em> monad <code>m</code>!</p>
<p>Here is the more general type of <code>lsystem</code>, as specified in the accompanying source code for this chapter:</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>We can understand this type as saying that our interpretation function is free to have any side-effects at all, captured by the monad <code>m</code>. It might render to the canvas, or print information to the console, or support failure or multiple return values. The reader is encouraged to try writing L-systems which use these various types of side-effect.</p>
<p>This function is a good example of the power of separating data from implementation. The advantage of this approach is that we gain the freedom to interpret our data in multiple different ways. We might even factor <code>lsystem</code> into two smaller functions: the first would build the sentence using repeated application of <code>concatMap</code>, and the second would interpret the sentence using <code>foldM</code>. This is also left as an exercise for the reader.</p>
<p>Let's complete our example by implementing its interpretation function. The type of <code>lsystem</code> tells us that its type signature must be <code>s -&gt; a -&gt; m s</code> for some types <code>a</code> and <code>s</code> and a type constructor <code>m</code>. We know that we want <code>a</code> to be <code>Letter</code> and <code>s</code> to be <code>State</code>, and for the monad <code>m</code> we can choose <code>Effect</code>. This gives us the following type:</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>To implement this function, we need to handle the three data constructors of the <code>Letter</code> type. To interpret the letters <code>L</code> (move left) and <code>R</code> (move right), we simply have to update the state to change the angle <code>theta</code> appropriately:</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Number.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Number.tau / 6.0 }
</code></pre>
<p>To interpret the letter <code>F</code> (move forward), we can calculate the new position of the path, render a line segment, and update the state, as follows:</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Number.cos state.theta * 1.5
          y = state.y + Number.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>Note that in the source code for this chapter, the <code>interpret</code> function is defined using a <code>let</code> binding inside the <code>main</code> function, so that the name <code>ctx</code> is in scope. It would also be possible to move the context into the <code>State</code> type, but this would be inappropriate because it is not a changing part of the state of the system.</p>
<p>To render this L-system, we can simply use the <code>strokePath</code> action:</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>Compile the L-system example using</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p>and open <code>html/index.html</code>. You should see the Koch curve rendered to the canvas.</p>
<h2 id="exercises-42"><a class="header" href="#exercises-42">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Modify the L-system example above to use <code>fillPath</code> instead of <code>strokePath</code>. <em>Hint</em>: you will need to include a call to <code>closePath</code>, and move the call to <code>moveTo</code> outside of the <code>interpret</code> function.</p>
</li>
<li>
<p>(Easy) Try changing the various numerical constants in the code, to understand their effect on the rendered system.</p>
</li>
<li>
<p>(Medium) Break the <code>lsystem</code> function into two smaller functions. The first should build the final sentence using repeated application of <code>concatMap</code>, and the second should use <code>foldM</code> to interpret the result.</p>
</li>
<li>
<p>(Medium) Add a drop shadow to the filled shape, by using the <code>setShadowOffsetX</code>, <code>setShadowOffsetY</code>, <code>setShadowBlur</code> and <code>setShadowColor</code> actions. <em>Hint</em>: use PSCi to find the types of these functions.</p>
</li>
<li>
<p>(Medium) The angle of the corners is currently a constant (<code>tau/6</code>). Instead, it can be moved into the <code>Letter</code> data type, which allows it to be changed by the production rules:</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>How can this new information be used in the production rules to create interesting shapes?</p>
</li>
<li>
<p>(Difficult) An L-system is given by an alphabet with four letters: <code>L</code> (turn left through 60 degrees), <code>R</code> (turn right through 60 degrees), <code>F</code> (move forward) and <code>M</code> (also move forward).</p>
<p>The initial sentence of the system is the single letter <code>M</code>.</p>
<p>The production rules are specified as follows:</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>Render this L-system. <em>Note</em>: you will need to decrease the number of iterations of the production rules, since the size of the final sentence grows exponentially with the number of iterations.</p>
<p>Now, notice the symmetry between <code>L</code> and <code>M</code> in the production rules. The two &quot;move forward&quot; instructions can be differentiated using a <code>Boolean</code> value using the following alphabet type:</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>Implement this L-system again using this representation of the alphabet.</p>
</li>
<li>
<p>(Difficult) Use a different monad <code>m</code> in the interpretation function. You might try using <code>Effect.Console</code> to write the L-system onto the console, or using <code>Effect.Random</code> to apply random &quot;mutations&quot; to the state type.</p>
</li>
</ol>
<h2 id="conclusion-10"><a class="header" href="#conclusion-10">Conclusion</a></h2>
<p>In this chapter, we learned how to use the HTML5 Canvas API from PureScript by using the <code>canvas</code> library. We also saw a practical demonstration of many of the techniques we have learned already: maps and folds, records and row polymorphism, and the <code>Effect</code> monad for handling side-effects.</p>
<p>The examples also demonstrated the power of higher-order functions and <em>separating data from implementation</em>. It would be possible to extend these ideas to completely separate the representation of a scene from its rendering function, using an algebraic data type, for example:</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>This approach is taken in the <code>drawing</code> package, and it brings the flexibility of being able to manipulate the scene as data in various ways before rendering.</p>
<p>For examples of games rendered to the canvas, see the &quot;Behavior&quot; and &quot;Signal&quot; recipes in the <a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generative-testing"><a class="header" href="#generative-testing">Generative Testing</a></h1>
<h2 id="chapter-goals-11"><a class="header" href="#chapter-goals-11">Chapter Goals</a></h2>
<p>In this chapter, we will see a particularly elegant application of type classes to the problem of testing. Instead of testing our code by telling the compiler <em>how</em> to test, we simply assert <em>what</em> properties our code should have. Test cases can be generated randomly from this specification, using type classes to hide the boilerplate code of random data generation. This is called <em>generative testing</em> (or <em>property-based testing</em>), a technique made popular by the <a href="https://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a> library in Haskell.</p>
<p>The <code>quickcheck</code> package is a port of Haskell's QuickCheck library to PureScript, and for the most part, it preserves the types and syntax of the original library. We will see how to use <code>quickcheck</code> to test a simple library, using Spago to integrate our test suite into our development process.</p>
<h2 id="project-setup-10"><a class="header" href="#project-setup-10">Project Setup</a></h2>
<p>This chapter's project adds <code>quickcheck</code> as a dependency.</p>
<p>In a Spago project, test sources should be placed in the <code>test</code> directory, and the main module for the test suite should be named <code>Test.Main</code>. The test suite can be run using the <code>spago test</code> command.</p>
<h2 id="writing-properties"><a class="header" href="#writing-properties">Writing Properties</a></h2>
<p>The <code>Merge</code> module implements a simple function <code>merge</code>, which we will use to demonstrate the features of the <code>quickcheck</code> library.</p>
<pre><code class="language-haskell">merge :: Array Int -&gt; Array Int -&gt; Array Int
</code></pre>
<p><code>merge</code> takes two sorted arrays of integers, and merges their elements so that the result is also sorted. For example:</p>
<pre><code class="language-text">&gt; import Merge
&gt; merge [1, 3, 5] [2, 4, 5]

[1, 2, 3, 4, 5, 5]
</code></pre>
<p>In a typical test suite, we might test <code>merge</code> by generating a few small test cases like this by hand, and asserting that the results were equal to the appropriate values. However, everything we need to know about the <code>merge</code> function can be summarized by this property:</p>
<ul>
<li>If <code>xs</code> and <code>ys</code> are sorted, then <code>merge xs ys</code> is the sorted result of both arrays appended together.</li>
</ul>
<p><code>quickcheck</code> allows us to test this property directly, by generating random test cases. We simply state the properties that we want our code to have, as functions. In this case, we have a single property:</p>
<pre><code class="language-haskell">main = do
  quickCheck \xs ys -&gt;
    eq (merge (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>When we run this code, <code>quickcheck</code> will attempt to disprove the properties we claimed, by generating random inputs <code>xs</code> and <code>ys</code>, and passing them to our functions. If our function returns <code>false</code> for any inputs, the property will be incorrect, and the library will raise an error. Fortunately, the library is unable to disprove our properties after generating 100 random test cases:</p>
<pre><code class="language-text">$ spago test

Installation complete.
Build succeeded.
100/100 test(s) passed.
...
Tests succeeded.
</code></pre>
<p>If we deliberately introduce a bug into the <code>merge</code> function (for example, by changing the less-than check for a greater-than check), then an exception is thrown at runtime after the first failed test case:</p>
<pre><code class="language-text">Error: Test 1 failed:
Test returned false
</code></pre>
<p>As we can see, this error message is not very helpful, but it can be improved with a little work.</p>
<h2 id="improving-error-messages"><a class="header" href="#improving-error-messages">Improving Error Messages</a></h2>
<p>To provide error messages along with our failed test cases, <code>quickcheck</code> provides the <code>&lt;?&gt;</code> operator. Simply separate the property definition from the error message using <code>&lt;?&gt;</code>, as follows:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  let
    result = merge (sort xs) (sort ys)
    expected = sort $ xs &lt;&gt; ys
  in
    eq result expected &lt;?&gt; &quot;Result:\n&quot; &lt;&gt; show result &lt;&gt; &quot;\nnot equal to expected:\n&quot; &lt;&gt; show expected
</code></pre>
<p>This time, if we modify the code to introduce a bug, we see our improved error message after the first failed test case:</p>
<pre><code class="language-text">Error: Test 1 (seed 534161891) failed:
Result:
[-822215,-196136,-116841,618343,887447,-888285]
not equal to expected:
[-888285,-822215,-196136,-116841,618343,887447]
</code></pre>
<p>Notice how the input <code>xs</code> and <code>ys</code> were generated as arrays of randomly-selected integers.</p>
<h2 id="exercises-43"><a class="header" href="#exercises-43">Exercises</a></h2>
<ol>
<li>(Easy) Write a property which asserts that merging an array with the empty array does not modify the original array. <em>Note</em>: This new property is redundant, since this situation is already covered by our existing property. We're just trying to give you readers a simple way to practice using quickCheck.</li>
<li>(Easy) Add an appropriate error message to the remaining property for <code>merge</code>.</li>
</ol>
<h2 id="testing-polymorphic-code"><a class="header" href="#testing-polymorphic-code">Testing Polymorphic Code</a></h2>
<p>The <code>Merge</code> module defines a generalization of the <code>merge</code> function, called <code>mergePoly</code>, which works not only with arrays of numbers, but also arrays of any type belonging to the <code>Ord</code> type class:</p>
<pre><code class="language-haskell">mergePoly :: forall a. Ord a =&gt; Array a -&gt; Array a -&gt; Array a
</code></pre>
<p>If we modify our original test to use <code>mergePoly</code> in place of <code>merge</code>, we see the following error message:</p>
<pre><code class="language-text">No type class instance was found for

  Test.QuickCheck.Arbitrary.Arbitrary t0

The instance head contains unknown type variables.
Consider adding a type annotation.
</code></pre>
<p>This error message indicates that the compiler could not generate random test cases, because it did not know what type of elements we wanted our arrays to have. In these sorts of cases, we can use type annotations to force the compiler to infer a particular type, such as <code>Array Int</code>:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>We can alternatively use a helper function to specify type, which may result in cleaner code. For example, if we define a function <code>ints</code> as a synonym for the identity function:</p>
<pre><code class="language-haskell">ints :: Array Int -&gt; Array Int
ints = id
</code></pre>
<p>then we can modify our test so that the compiler infers the type <code>Array Int</code> for our two array arguments:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>Here, <code>xs</code> and <code>ys</code> both have type <code>Array Int</code>, since the <code>ints</code> function has been used to disambiguate the unknown type.</p>
<h2 id="exercises-44"><a class="header" href="#exercises-44">Exercises</a></h2>
<ol>
<li>(Easy) Write a function <code>bools</code> which forces the types of <code>xs</code> and <code>ys</code> to be <code>Array Boolean</code>, and add additional properties which test <code>mergePoly</code> at that type.</li>
<li>(Medium) Choose a pure function from the core libraries (for example, from the <code>arrays</code> package), and write a QuickCheck property for it, including an appropriate error message. Your property should use a helper function to fix any polymorphic type arguments to either <code>Int</code> or <code>Boolean</code>.</li>
</ol>
<h2 id="generating-arbitrary-data"><a class="header" href="#generating-arbitrary-data">Generating Arbitrary Data</a></h2>
<p>Now we will see how the <code>quickcheck</code> library is able to randomly generate test cases for our properties.</p>
<p>Those types whose values can be randomly generated are captured by the <code>Arbitrary</code> type class:</p>
<pre><code class="language-haskell">class Arbitrary t where
  arbitrary :: Gen t
</code></pre>
<p>The <code>Gen</code> type constructor represents the side-effects of <em>deterministic random data generation</em>. It uses a pseudo-random number generator to generate deterministic random function arguments from a seed value. The <code>Test.QuickCheck.Gen</code> module defines several useful combinators for building generators.</p>
<p><code>Gen</code> is also a monad and an applicative functor, so we have the usual collection of combinators at our disposal for creating new instances of the <code>Arbitrary</code> type class.</p>
<p>For example, we can use the <code>Arbitrary</code> instance for the <code>Int</code> type, provided in the <code>quickcheck</code> library, to create a distribution on the 256 byte values, using the <code>Functor</code> instance for <code>Gen</code> to map a function from integers to bytes over arbitrary integer values:</p>
<pre><code class="language-haskell">newtype Byte = Byte Int

instance arbitraryByte :: Arbitrary Byte where
  arbitrary = map intToByte arbitrary
    where
    intToByte n | n &gt;= 0 = Byte (n `mod` 256)
                | otherwise = intToByte (-n)
</code></pre>
<p>Here, we define a type <code>Byte</code> of integral values between 0 and 255. The <code>Arbitrary</code> instance uses the <code>map</code> function to lift the <code>intToByte</code> function over the <code>arbitrary</code> action. The type of the inner <code>arbitrary</code> action is inferred as <code>Gen Int</code>.</p>
<p>We can also use this idea to improve our test for <code>merge</code>:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>In this test, we generated arbitrary arrays <code>xs</code> and <code>ys</code>, but had to sort them, since <code>merge</code> expects sorted input. On the other hand, we could create a newtype representing sorted arrays, and write an <code>Arbitrary</code> instance which generates sorted data:</p>
<pre><code class="language-haskell">newtype Sorted a = Sorted (Array a)

sorted :: forall a. Sorted a -&gt; Array a
sorted (Sorted xs) = xs

instance arbSorted :: (Arbitrary a, Ord a) =&gt; Arbitrary (Sorted a) where
  arbitrary = map (Sorted &lt;&lt;&lt; sort) arbitrary
</code></pre>
<p>With this type constructor, we can modify our test as follows:</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs &lt;&gt; sorted ys)
</code></pre>
<p>This may look like a small change, but the types of <code>xs</code> and <code>ys</code> have changed to <code>Sorted Int</code>, instead of just <code>Array Int</code>. This communicates our <em>intent</em> in a clearer way - the <code>mergePoly</code> function takes sorted input. Ideally, the type of the <code>mergePoly</code> function itself would be updated to use the <code>Sorted</code> type constructor.</p>
<p>As a more interesting example, the <code>Tree</code> module defines a type of sorted binary trees with values at the branches:</p>
<pre><code class="language-haskell">data Tree a
  = Leaf
  | Branch (Tree a) a (Tree a)
</code></pre>
<p>The <code>Tree</code> module defines the following API:</p>
<pre><code class="language-haskell">insert    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Tree a
member    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Boolean
fromArray :: forall a. Ord a =&gt; Array a -&gt; Tree a
toArray   :: forall a. Tree a -&gt; Array a
</code></pre>
<p>The <code>insert</code> function is used to insert a new element into a sorted tree, and the <code>member</code> function can be used to query a tree for a particular value. For example:</p>
<pre><code class="language-text">&gt; import Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false
</code></pre>
<p>The <code>toArray</code> and <code>fromArray</code> functions can be used to convert sorted trees to and from arrays. We can use <code>fromArray</code> to write an <code>Arbitrary</code> instance for trees:</p>
<pre><code class="language-haskell">instance arbTree :: (Arbitrary a, Ord a) =&gt; Arbitrary (Tree a) where
  arbitrary = map fromArray arbitrary
</code></pre>
<p>We can now use <code>Tree a</code> as the type of an argument to our test properties, whenever there is an <code>Arbitrary</code> instance available for the type <code>a</code>. For example, we can test that the <code>member</code> test always returns <code>true</code> after inserting a value:</p>
<pre><code class="language-haskell">quickCheck \t a -&gt;
  member a $ insert a $ treeOfInt t
</code></pre>
<p>Here, the argument <code>t</code> is a randomly-generated tree of type <code>Tree Int</code>, where the type argument disambiguated by the identity function <code>treeOfInt</code>.</p>
<h2 id="exercises-45"><a class="header" href="#exercises-45">Exercises</a></h2>
<ol>
<li>(Medium) Create a newtype for <code>String</code> with an associated <code>Arbitrary</code> instance which generates collections of randomly-selected characters in the range <code>a-z</code>. <em>Hint</em>: use the <code>elements</code> and <code>arrayOf</code> functions from the <code>Test.QuickCheck.Gen</code> module.</li>
<li>(Difficult) Write a property which asserts that a value inserted into a tree is still a member of that tree after arbitrarily many more insertions.</li>
</ol>
<h2 id="testing-higher-order-functions"><a class="header" href="#testing-higher-order-functions">Testing Higher-Order Functions</a></h2>
<p>The <code>Merge</code> module defines another generalization of the <code>merge</code> function - the <code>mergeWith</code> function takes an additional function as an argument which is used to determine the order in which elements should be merged. That is, <code>mergeWith</code> is a higher-order function.</p>
<p>For example, we can pass the <code>length</code> function as the first argument, to merge two arrays which are already in length-increasing order. The result should also be in length-increasing order:</p>
<pre><code class="language-haskell">&gt; import Data.String

&gt; mergeWith length
    [&quot;&quot;, &quot;ab&quot;, &quot;abcd&quot;]
    [&quot;x&quot;, &quot;xyz&quot;]

[&quot;&quot;,&quot;x&quot;,&quot;ab&quot;,&quot;xyz&quot;,&quot;abcd&quot;]
</code></pre>
<p>How might we test such a function? Ideally, we would like to generate values for all three arguments, including the first argument which is a function.</p>
<p>There is a second type class which allows us to create randomly-generated functions. It is called <code>Coarbitrary</code>, and it is defined as follows:</p>
<pre><code class="language-haskell">class Coarbitrary t where
  coarbitrary :: forall r. t -&gt; Gen r -&gt; Gen r
</code></pre>
<p>The <code>coarbitrary</code> function takes a function argument of type <code>t</code>, and a random generator for a function result of type <code>r</code>, and uses the function argument to <em>perturb</em> the random generator. That is, it uses the function argument to modify the random output of the random generator for the result.</p>
<p>In addition, there is a type class instance which gives us <code>Arbitrary</code> functions if the function domain is <code>Coarbitrary</code> and the function codomain is <code>Arbitrary</code>:</p>
<pre><code class="language-haskell">instance arbFunction :: (Coarbitrary a, Arbitrary b) =&gt; Arbitrary (a -&gt; b)
</code></pre>
<p>In practice, this means that we can write properties which take functions as arguments. In the case of the <code>mergeWith</code> function, we can generate the first argument randomly, modifying our tests to take account of the new argument.</p>
<p>We cannot guarantee that the result will be sorted - we do not even necessarily have an <code>Ord</code> instance - but we can expect that the result be sorted with respect to the function <code>f</code> that we pass in as an argument. In addition, we need the two input arrays to be sorted with respect to <code>f</code>, so we use the <code>sortBy</code> function to sort <code>xs</code> and <code>ys</code> based on comparison after the function <code>f</code> has been applied:</p>
<pre><code class="language-haskell">quickCheck \xs ys f -&gt;
  let
    result =
      map f $
        mergeWith (intToBool f)
                  (sortBy (compare `on` f) xs)
                  (sortBy (compare `on` f) ys)
    expected =
      map f $
        sortBy (compare `on` f) $ xs &lt;&gt; ys
  in
    eq result expected
</code></pre>
<p>Here, we use a function <code>intToBool</code> to disambiguate the type of the function <code>f</code>:</p>
<pre><code class="language-haskell">intToBool :: (Int -&gt; Boolean) -&gt; Int -&gt; Boolean
intToBool = id
</code></pre>
<p>In addition to being <code>Arbitrary</code>, functions are also <code>Coarbitrary</code>:</p>
<pre><code class="language-haskell">instance coarbFunction :: (Arbitrary a, Coarbitrary b) =&gt; Coarbitrary (a -&gt; b)
</code></pre>
<p>This means that we are not limited to just values and functions - we can also randomly generate <em>higher-order functions</em>, or functions whose arguments are higher-order functions, and so on.</p>
<h2 id="writing-coarbitrary-instances"><a class="header" href="#writing-coarbitrary-instances">Writing Coarbitrary Instances</a></h2>
<p>Just as we can write <code>Arbitrary</code> instances for our data types by using the <code>Monad</code> and <code>Applicative</code> instances of <code>Gen</code>, we can write our own <code>Coarbitrary</code> instances as well. This allows us to use our own data types as the domain of randomly-generated functions.</p>
<p>Let's write a <code>Coarbitrary</code> instance for our <code>Tree</code> type. We will need a <code>Coarbitrary</code> instance for the type of the elements stored in the branches:</p>
<pre><code class="language-haskell">instance coarbTree :: Coarbitrary a =&gt; Coarbitrary (Tree a) where
</code></pre>
<p>We have to write a function which perturbs a random generator given a value of type <code>Tree a</code>. If the input value is a <code>Leaf</code>, then we will just return the generator unchanged:</p>
<pre><code class="language-haskell">  coarbitrary Leaf = id
</code></pre>
<p>If the tree is a <code>Branch</code>, then we will perturb the generator using the left subtree, the value, and the right subtree. We use function composition to create our perturbing function:</p>
<pre><code class="language-haskell">  coarbitrary (Branch l a r) =
    coarbitrary l &lt;&lt;&lt;
    coarbitrary a &lt;&lt;&lt;
    coarbitrary r
</code></pre>
<p>Now we are free to write properties whose arguments include functions taking trees as arguments. For example, the <code>Tree</code> module defines a function <code>anywhere</code>, which tests if a predicate holds on any subtree of its argument:</p>
<pre><code class="language-haskell">anywhere :: forall a. (Tree a -&gt; Boolean) -&gt; Tree a -&gt; Boolean
</code></pre>
<p>Now we are able to generate the predicate function randomly. For example, we expect the <code>anywhere</code> function to <em>respect disjunction</em>:</p>
<pre><code class="language-haskell">quickCheck \f g t -&gt;
  anywhere (\s -&gt; f s || g s) t ==
    anywhere f (treeOfInt t) || anywhere g t
</code></pre>
<p>Here, the <code>treeOfInt</code> function is used to fix the type of values contained in the tree to the type <code>Int</code>:</p>
<pre><code class="language-haskell">treeOfInt :: Tree Int -&gt; Tree Int
treeOfInt = id
</code></pre>
<h2 id="testing-without-side-effects"><a class="header" href="#testing-without-side-effects">Testing Without Side-Effects</a></h2>
<p>For the purposes of testing, we usually include calls to the <code>quickCheck</code> function in the <code>main</code> action of our test suite. However, there is a variant of the <code>quickCheck</code> function, called <code>quickCheckPure</code> which does not use side-effects. Instead, it is a pure function which takes a random seed as an input, and returns an array of test results.</p>
<p>We can test <code>quickCheckPure</code> using PSCi. Here, we test that the <code>merge</code> operation is associative:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Merge
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.LCG (mkSeed)

&gt; :paste
‚Ä¶ quickCheckPure (mkSeed 12345) 10 \xs ys zs -&gt;
‚Ä¶   ((xs `merge` ys) `merge` zs) ==
‚Ä¶     (xs `merge` (ys `merge` zs))
‚Ä¶ ^D

Success : Success : ...
</code></pre>
<p><code>quickCheckPure</code> takes three arguments: the random seed, the number of test cases to generate, and the property to test. If all tests pass, you should see an array of <code>Success</code> data constructors printed to the console.</p>
<p><code>quickCheckPure</code> might be useful in other situations, such as generating random input data for performance benchmarks, or generating sample form data for web applications.</p>
<h2 id="exercises-46"><a class="header" href="#exercises-46">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Write <code>Coarbitrary</code> instances for the <code>Byte</code> and <code>Sorted</code> type constructors.</p>
</li>
<li>
<p>(Medium) Write a (higher-order) property which asserts associativity of the <code>mergeWith f</code> function for any function <code>f</code>. Test your property in PSCi using <code>quickCheckPure</code>.</p>
</li>
<li>
<p>(Medium) Write <code>Arbitrary</code> and <code>Coarbitrary</code> instances for the following data type:</p>
<pre><code class="language-haskell">data OneTwoThree a = One a | Two a a | Three a a a
</code></pre>
<p><em>Hint</em>: Use the <code>oneOf</code> function defined in <code>Test.QuickCheck.Gen</code> to define your <code>Arbitrary</code> instance.</p>
</li>
<li>
<p>(Medium) Use <code>all</code> to simplify the result of the <code>quickCheckPure</code> function - your new function should have type <code>List Result -&gt; Boolean</code> and should return <code>true</code> if every test passes and <code>false</code> otherwise.</p>
</li>
<li>
<p>(Medium) As another approach to simplifying the result of <code>quickCheckPure</code>, try writing a function <code>squashResults :: List Result -&gt; Result</code>. Consider using the <code>First</code> monoid from <code>Data.Maybe.First</code> with the <code>foldMap</code> function to preserve the first error in case of failure.</p>
</li>
</ol>
<h2 id="conclusion-11"><a class="header" href="#conclusion-11">Conclusion</a></h2>
<p>In this chapter, we met the <code>quickcheck</code> package, which can be used to write tests in a declarative way using the paradigm of <em>generative testing</em>. In particular:</p>
<ul>
<li>We saw how to automate QuickCheck tests using <code>spago test</code>.</li>
<li>We saw how to write properties as functions, and how to use the <code>&lt;?&gt;</code> operator to improve error messages.</li>
<li>We saw how the <code>Arbitrary</code> and <code>Coarbitrary</code> type classes enable generation of boilerplate testing code, and how they allow us to test higher-order properties.</li>
<li>We saw how to implement custom <code>Arbitrary</code> and <code>Coarbitrary</code> instances for our own data types.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-specific-languages"><a class="header" href="#domain-specific-languages">Domain-Specific Languages</a></h1>
<h2 id="chapter-goals-12"><a class="header" href="#chapter-goals-12">Chapter Goals</a></h2>
<p>In this chapter, we will explore the implementation of <em>domain-specific languages</em> (or <em>DSLs</em>) in PureScript, using a number of standard techniques.</p>
<p>A domain-specific language is a language which is well-suited to development in a particular problem domain. Its syntax and functions are chosen to maximize readability of code used to express ideas in that domain. We have already seen a number of examples of domain-specific languages in this book:</p>
<ul>
<li>The <code>Game</code> monad and its associated actions, developed in chapter 11, constitute a domain-specific language for the domain of <em>text adventure game development</em>.</li>
<li>The <code>quickcheck</code> package, covered in chapter 13, is a domain-specific language for the domain of <em>generative testing</em>. Its combinators enable a particularly expressive notation for test properties.</li>
</ul>
<p>This chapter will take a more structured approach to some of standard techniques in the implementation of domain-specific languages. It is by no means a complete exposition of the subject, but should provide you with enough knowledge to build some practical DSLs for your own tasks.</p>
<p>Our running example will be a domain-specific language for creating HTML documents. Our aim will be to develop a type-safe language for describing correct HTML documents, and we will work by improving a naive implementation in small steps.</p>
<h2 id="project-setup-11"><a class="header" href="#project-setup-11">Project Setup</a></h2>
<p>The project accompanying this chapter adds one new dependency - the <code>free</code> library, which defines the <em>free monad</em>, one of the tools which we will be using.</p>
<p>We will test this chapter's project in PSCi.</p>
<h2 id="a-html-data-type"><a class="header" href="#a-html-data-type">A HTML Data Type</a></h2>
<p>The most basic version of our HTML library is defined in the <code>Data.DOM.Simple</code> module. The module contains the following type definitions:</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Array Content)
  }

data Content
  = TextContent String
  | ElementContent Element

newtype Attribute = Attribute
  { key          :: String
  , value        :: String
  }
</code></pre>
<p>The <code>Element</code> type represents HTML elements. Each element consists of an element name, an array of attribute pairs and some content. The content property uses the <code>Maybe</code> type to indicate that an element might be open (containing other elements and text) or closed.</p>
<p>The key function of our library is a function</p>
<pre><code class="language-haskell">render :: Element -&gt; String
</code></pre>
<p>which renders HTML elements as HTML strings. We can try out this version of the library by constructing values of the appropriate types explicitly in PSCi:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Simple
&gt; import Data.Maybe
&gt; import Effect.Console

&gt; :paste
‚Ä¶ log $ render $ Element
‚Ä¶   { name: &quot;p&quot;
‚Ä¶   , attribs: [
‚Ä¶       Attribute
‚Ä¶         { key: &quot;class&quot;
‚Ä¶         , value: &quot;main&quot;
‚Ä¶         }
‚Ä¶     ]
‚Ä¶   , content: Just [
‚Ä¶       TextContent &quot;Hello World!&quot;
‚Ä¶     ]
‚Ä¶   }
‚Ä¶ ^D

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>As it stands, there are several problems with this library:</p>
<ul>
<li>Creating HTML documents is difficult - every new element requires at least one record and one data constructor.</li>
<li>It is possible to represent invalid documents:
<ul>
<li>The developer might mistype the element name</li>
<li>The developer can associate an attribute with the wrong type of element</li>
<li>The developer can use a closed element when an open element is correct</li>
</ul>
</li>
</ul>
<p>In the remainder of the chapter, we will apply certain techniques to solve these problems and turn our library into a usable domain-specific language for creating HTML documents.</p>
<h2 id="smart-constructors"><a class="header" href="#smart-constructors">Smart Constructors</a></h2>
<p>The first technique we will apply is simple but can be very effective. Instead of exposing the representation of the data to the module's users, we can use the module exports list to hide the <code>Element</code>, <code>Content</code> and <code>Attribute</code> data constructors, and only export so-called <em>smart constructors</em>, which construct data which is known to be correct.</p>
<p>Here is an example. First, we provide a convenience function for creating HTML elements:</p>
<pre><code class="language-haskell">element :: String -&gt; Array Attribute -&gt; Maybe (Array Content) -&gt; Element
element name attribs content = Element
  { name:      name
  , attribs:   attribs
  , content:   content
  }
</code></pre>
<p>Next, we create smart constructors for those HTML elements we want our users to be able to create, by applying the <code>element</code> function:</p>
<pre><code class="language-haskell">a :: Array Attribute -&gt; Array Content -&gt; Element
a attribs content = element &quot;a&quot; attribs (Just content)

p :: Array Attribute -&gt; Array Content -&gt; Element
p attribs content = element &quot;p&quot; attribs (Just content)

img :: Array Attribute -&gt; Element
img attribs = element &quot;img&quot; attribs Nothing
</code></pre>
<p>Finally, we update the module exports list to only export those functions which are known to construct correct data structures:</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute(..)
  , Content(..)

  , a
  , p
  , img

  , render
  ) where
</code></pre>
<p>The module exports list is provided immediately after the module name inside parentheses. Each module export can be one of three types:</p>
<ul>
<li>A value (or function), indicated by the name of the value,</li>
<li>A type class, indicated by the name of the class,</li>
<li>A type constructor and any associated data constructors, indicated by the name of the type followed by a parenthesized list of exported data constructors.</li>
</ul>
<p>Here, we export the <code>Element</code> <em>type</em>, but we do not export its data constructors. If we did, the user would be able to construct invalid HTML elements.</p>
<p>In the case of the <code>Attribute</code> and <code>Content</code> types, we still export all of the data constructors (indicated by the symbol <code>..</code> in the exports list). We will apply the technique of smart constructors to these types shortly.</p>
<p>Notice that we have already made some big improvements to our library:</p>
<ul>
<li>It is impossible to represent HTML elements with invalid names (of course, we are restricted to the set of element names provided by the library).</li>
<li>Closed elements cannot contain content by construction.</li>
</ul>
<p>We can apply this technique to the <code>Content</code> type very easily. We simply remove the data constructors for the <code>Content</code> type from the exports list, and provide the following smart constructors:</p>
<pre><code class="language-haskell">text :: String -&gt; Content
text = TextContent

elem :: Element -&gt; Content
elem = ElementContent
</code></pre>
<p>Let's apply the same technique to the <code>Attribute</code> type. First, we provide a general-purpose smart constructor for attributes. Here is a first attempt:</p>
<pre><code class="language-haskell">attribute :: String -&gt; String -&gt; Attribute
attribute key value = Attribute
  { key: key
  , value: value
  }

infix 4 attribute as :=
</code></pre>
<p>This representation suffers from the same problem as the original <code>Element</code> type - it is possible to represent attributes which do not exist or whose names were entered incorrectly. To solve this problem, we can create a newtype which represents attribute names:</p>
<pre><code class="language-haskell">newtype AttributeKey = AttributeKey String
</code></pre>
<p>With that, we can modify our operator as follows:</p>
<pre><code class="language-haskell">attribute :: AttributeKey -&gt; String -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: value
  }
</code></pre>
<p>If we do not export the <code>AttributeKey</code> data constructor, then the user has no way to construct values of type <code>AttributeKey</code> other than by using functions we explicitly export. Here are some examples:</p>
<pre><code class="language-haskell">href :: AttributeKey
href = AttributeKey &quot;href&quot;

_class :: AttributeKey
_class = AttributeKey &quot;class&quot;

src :: AttributeKey
src = AttributeKey &quot;src&quot;

width :: AttributeKey
width = AttributeKey &quot;width&quot;

height :: AttributeKey
height = AttributeKey &quot;height&quot;
</code></pre>
<p>Here is the final exports list for our new module. Note that we no longer export any data constructors directly:</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute
  , Content
  , AttributeKey

  , a
  , p
  , img

  , href
  , _class
  , src
  , width
  , height

  , attribute, (:=)
  , text
  , elem

  , render
  ) where
</code></pre>
<p>If we try this new module in PSCi, we can already see massive improvements in the conciseness of the user code:</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Smart
&gt; import Effect.Console
&gt; log $ render $ p [ _class := &quot;main&quot; ] [ text &quot;Hello World!&quot; ]

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>Note, however, that no changes had to be made to the <code>render</code> function, because the underlying data representation never changed. This is one of the benefits of the smart constructors approach - it allows us to separate the internal data representation for a module from the representation which is perceived by users of its external API.</p>
<h2 id="exercises-47"><a class="header" href="#exercises-47">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use the <code>Data.DOM.Smart</code> module to experiment by creating new HTML documents using <code>render</code>.</p>
</li>
<li>
<p>(Medium) Some HTML attributes such as <code>checked</code> and <code>disabled</code> do not require values, and may be rendered as <em>empty attributes</em>:</p>
<pre><code class="language-html">&lt;input disabled&gt;
</code></pre>
<p>Modify the representation of an <code>Attribute</code> to take empty attributes into account. Write a function which can be used in place of <code>attribute</code> or <code>:=</code> to add an empty attribute to an element.</p>
</li>
</ol>
<h2 id="phantom-types"><a class="header" href="#phantom-types">Phantom Types</a></h2>
<p>To motivate the next technique, consider the following code:</p>
<pre><code class="language-text">&gt; log $ render $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := &quot;foo&quot;
    , height := &quot;bar&quot;
    ]

&lt;img src=&quot;cat.jpg&quot; width=&quot;foo&quot; height=&quot;bar&quot; /&gt;
unit
</code></pre>
<p>The problem here is that we have provided string values for the <code>width</code> and <code>height</code> attributes, where we should only be allowed to provide numeric values in units of pixels or percentage points.</p>
<p>To solve this problem, we can introduce a so-called <em>phantom type</em> argument to our <code>AttributeKey</code> type:</p>
<pre><code class="language-haskell">newtype AttributeKey a = AttributeKey String
</code></pre>
<p>The type variable <code>a</code> is called a <em>phantom type</em> because there are no values of type <code>a</code> involved in the right-hand side of the definition. The type <code>a</code> only exists to provide more information at compile-time. Any value of type <code>AttributeKey a</code> is simply a string at runtime, but at compile-time, the type of the value tells us the desired type of the values associated with this key.</p>
<p>We can modify the type of our <code>attribute</code> function to take the new form of <code>AttributeKey</code> into account:</p>
<pre><code class="language-haskell">attribute :: forall a. IsValue a =&gt; AttributeKey a -&gt; a -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: toValue value
  }
</code></pre>
<p>Here, the phantom type argument <code>a</code> is used to ensure that the attribute key and attribute value have compatible types. Since the user cannot create values of type <code>AttributeKey a</code> directly (only via the constants we provide in the library), every attribute will be correct by construction.</p>
<p>Note that the <code>IsValue</code> constraint ensures that whatever value type we associate to a key, its values can be converted to strings and displayed in the generated HTML. The <code>IsValue</code> type class is defined as follows:</p>
<pre><code class="language-haskell">class IsValue a where
  toValue :: a -&gt; String
</code></pre>
<p>We also provide type class instances for the <code>String</code> and <code>Int</code> types:</p>
<pre><code class="language-haskell">instance stringIsValue :: IsValue String where
  toValue = id

instance intIsValue :: IsValue Int where
  toValue = show
</code></pre>
<p>We also have to update our <code>AttributeKey</code> constants so that their types reflect the new type parameter:</p>
<pre><code class="language-haskell">href :: AttributeKey String
href = AttributeKey &quot;href&quot;

_class :: AttributeKey String
_class = AttributeKey &quot;class&quot;

src :: AttributeKey String
src = AttributeKey &quot;src&quot;

width :: AttributeKey Int
width = AttributeKey &quot;width&quot;

height :: AttributeKey Int
height = AttributeKey &quot;height&quot;
</code></pre>
<p>Now we find it is impossible to represent these invalid HTML documents, and we are forced to use numbers to represent the <code>width</code> and <code>height</code> attributes instead:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Phantom
&gt; import Effect.Console

&gt; :paste
‚Ä¶ log $ render $ img
‚Ä¶   [ src    := &quot;cat.jpg&quot;
‚Ä¶   , width  := 100
‚Ä¶   , height := 200
‚Ä¶   ]
‚Ä¶ ^D

&lt;img src=&quot;cat.jpg&quot; width=&quot;100&quot; height=&quot;200&quot; /&gt;
unit
</code></pre>
<h2 id="exercises-48"><a class="header" href="#exercises-48">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Create a data type which represents either pixel or percentage lengths. Write an instance of <code>IsValue</code> for your type. Modify the <code>width</code> and <code>height</code> attributes to use your new type.</p>
</li>
<li>
<p>(Difficult) By defining type-level representatives for the Boolean values <code>true</code> and <code>false</code>, we can use a phantom type to encode whether an <code>AttributeKey</code> represents an <em>empty attribute</em> such as <code>disabled</code> or <code>checked</code>.</p>
<pre><code class="language-haskell">data True
data False
</code></pre>
<p>Modify your solution to the previous exercise to use a phantom type to prevent the user from using the <code>attribute</code> operator with an empty attribute.</p>
</li>
</ol>
<h2 id="the-free-monad"><a class="header" href="#the-free-monad">The Free Monad</a></h2>
<p>In our final set of modifications to our API, we will use a construction called the <em>free monad</em> to turn our <code>Content</code> type into a monad, enabling do notation. This will allow us to structure our HTML documents in a form in which the nesting of elements becomes clearer - instead of this:</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ]
  [ elem $ img
      [ src    := &quot;cat.jpg&quot;
      , width  := 100
      , height := 200
      ]
  , text &quot;A cat&quot;
  ]
</code></pre>
<p>we will be able to write this:</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ] $ do
  elem $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := 100
    , height := 200
    ]
  text &quot;A cat&quot;
</code></pre>
<p>However, do notation is not the only benefit of a free monad. The free monad allows us to separate the <em>representation</em> of our monadic actions from their <em>interpretation</em>, and even support <em>multiple interpretations</em> of the same actions.</p>
<p>The <code>Free</code> monad is defined in the <code>free</code> library, in the <code>Control.Monad.Free</code> module. We can find out some basic information about it using PSCi, as follows:</p>
<pre><code class="language-text">&gt; import Control.Monad.Free

&gt; :kind Free
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>The kind of <code>Free</code> indicates that it takes a type constructor as an argument, and returns another type constructor. In fact, the <code>Free</code> monad can be used to turn any <code>Functor</code> into a <code>Monad</code>!</p>
<p>We begin by defining the <em>representation</em> of our monadic actions. To do this, we need to create a <code>Functor</code> with one data constructor for each monadic action we wish to support. In our case, our two monadic actions will be <code>elem</code> and <code>text</code>. In fact, we can simply modify our <code>Content</code> type as follows:</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a

instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
</code></pre>
<p>Here, the <code>ContentF</code> type constructor looks just like our old <code>Content</code> data type - however, it now takes a type argument <code>a</code>, and each data constructor has been modified to take a value of type <code>a</code> as an additional argument. The <code>Functor</code> instance simply applies the function <code>f</code> to the value of type <code>a</code> in each data constructor.</p>
<p>With that, we can define our new <code>Content</code> monad as a type synonym for the <code>Free</code> monad, which we construct by using our <code>ContentF</code> type constructor as the first type argument:</p>
<pre><code class="language-haskell">type Content = Free ContentF
</code></pre>
<p>Instead of a type synonym, we might use a <code>newtype</code> to avoid exposing the internal representation of our library to our users - by hiding the <code>Content</code> data constructor, we restrict our users to only using the monadic actions we provide.</p>
<p>Because <code>ContentF</code> is a <code>Functor</code>, we automatically get a <code>Monad</code> instance for <code>Free ContentF</code>.</p>
<p>We have to modify our <code>Element</code> data type slightly to take account of the new type argument on <code>Content</code>. We will simply require that the return type of our monadic computations be <code>Unit</code>:</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Content Unit)
  }
</code></pre>
<p>In addition, we have to modify our <code>elem</code> and <code>text</code> functions, which become our new monadic actions for the <code>Content</code> monad. To do this, we can use the <code>liftF</code> function, provided by the <code>Control.Monad.Free</code> module. Here is its type:</p>
<pre><code class="language-haskell">liftF :: forall f a. f a -&gt; Free f a
</code></pre>
<p><code>liftF</code> allows us to construct an action in our free monad from a value of type <code>f a</code> for some type <code>a</code>. In our case, we can simply use the data constructors of our <code>ContentF</code> type constructor directly:</p>
<pre><code class="language-haskell">text :: String -&gt; Content Unit
text s = liftF $ TextContent s unit

elem :: Element -&gt; Content Unit
elem e = liftF $ ElementContent e unit
</code></pre>
<p>Some other routine modifications have to be made, but the interesting changes are in the <code>render</code> function, where we have to <em>interpret</em> our free monad.</p>
<h2 id="interpreting-the-monad"><a class="header" href="#interpreting-the-monad">Interpreting the Monad</a></h2>
<p>The <code>Control.Monad.Free</code> module provides a number of functions for interpreting a computation in a free monad:</p>
<pre><code class="language-haskell">runFree
  :: forall f a
   . Functor f
  =&gt; (f (Free f a) -&gt; Free f a)
  -&gt; Free f a
  -&gt; a

runFreeM
  :: forall f m a
   . (Functor f, MonadRec m)
  =&gt; (f (Free f a) -&gt; m (Free f a))
  -&gt; Free f a
  -&gt; m a
</code></pre>
<p>The <code>runFree</code> function is used to compute a <em>pure</em> result. The <code>runFreeM</code> function allows us to use a monad to interpret the actions of our free monad.</p>
<p><em>Note</em>: Technically, we are restricted to using monads <code>m</code> which satisfy the stronger <code>MonadRec</code> constraint. In practice, this means that we don't need to worry about stack overflow, since <code>m</code> supports safe <em>monadic tail recursion</em>.</p>
<p>First, we have to choose a monad in which we can interpret our actions. We will use the <code>Writer String</code> monad to accumulate a HTML string as our result.</p>
<p>Our new <code>render</code> method starts by delegating to a helper function, <code>renderElement</code>, and using <code>execWriter</code> to run our computation in the <code>Writer</code> monad:</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render = execWriter &lt;&lt;&lt; renderElement
</code></pre>
<p><code>renderElement</code> is defined in a where block:</p>
<pre><code class="language-haskell">  where
    renderElement :: Element -&gt; Writer String Unit
    renderElement (Element e) = do
</code></pre>
<p>The definition of <code>renderElement</code> is straightforward, using the <code>tell</code> action from the <code>Writer</code> monad to accumulate several small strings:</p>
<pre><code class="language-haskell">      tell &quot;&lt;&quot;
      tell e.name
      for_ e.attribs $ \x -&gt; do
        tell &quot; &quot;
        renderAttribute x
      renderContent e.content
</code></pre>
<p>Next, we define the <code>renderAttribute</code> function, which is equally simple:</p>
<pre><code class="language-haskell">    where
      renderAttribute :: Attribute -&gt; Writer String Unit
      renderAttribute (Attribute x) = do
        tell x.key
        tell &quot;=\&quot;&quot;
        tell x.value
        tell &quot;\&quot;&quot;
</code></pre>
<p>The <code>renderContent</code> function is more interesting. Here, we use the <code>runFreeM</code> function to interpret the computation inside the free monad, delegating to a helper function, <code>renderContentItem</code>:</p>
<pre><code class="language-haskell">      renderContent :: Maybe (Content Unit) -&gt; Writer String Unit
      renderContent Nothing = tell &quot; /&gt;&quot;
      renderContent (Just content) = do
        tell &quot;&gt;&quot;
        runFreeM renderContentItem content
        tell &quot;&lt;/&quot;
        tell e.name
        tell &quot;&gt;&quot;
</code></pre>
<p>The type of <code>renderContentItem</code> can be deduced from the type signature of <code>runFreeM</code>. The functor <code>f</code> is our type constructor <code>ContentF</code>, and the monad <code>m</code> is the monad in which we are interpreting the computation, namely <code>Writer String</code>. This gives the following type signature for <code>renderContentItem</code>:</p>
<pre><code class="language-haskell">      renderContentItem :: ContentF (Content Unit) -&gt; Writer String (Content Unit)
</code></pre>
<p>We can implement this function by simply pattern matching on the two data constructors of <code>ContentF</code>:</p>
<pre><code class="language-haskell">      renderContentItem (TextContent s rest) = do
        tell s
        pure rest
      renderContentItem (ElementContent e rest) = do
        renderElement e
        pure rest
</code></pre>
<p>In each case, the expression <code>rest</code> has the type <code>Content Unit</code>, and represents the remainder of the interpreted computation. We can complete each case by returning the <code>rest</code> action.</p>
<p>That's it! We can test our new monadic API in PSCi, as follows:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Free
&gt; import Effect.Console

&gt; :paste
‚Ä¶ log $ render $ p [] $ do
‚Ä¶   elem $ img [ src := &quot;cat.jpg&quot; ]
‚Ä¶   text &quot;A cat&quot;
‚Ä¶ ^D

&lt;p&gt;&lt;img src=&quot;cat.jpg&quot; /&gt;A cat&lt;/p&gt;
unit
</code></pre>
<h2 id="exercises-49"><a class="header" href="#exercises-49">Exercises</a></h2>
<ol>
<li>(Medium) Add a new data constructor to the <code>ContentF</code> type to support a new action <code>comment</code>, which renders a comment in the generated HTML. Implement the new action using <code>liftF</code>. Update the interpretation <code>renderContentItem</code> to interpret your new constructor appropriately.</li>
</ol>
<h2 id="extending-the-language"><a class="header" href="#extending-the-language">Extending the Language</a></h2>
<p>A monad in which every action returns something of type <code>Unit</code> is not particularly interesting. In fact, aside from an arguably nicer syntax, our monad adds no extra functionality over a <code>Monoid</code>.</p>
<p>Let's illustrate the power of the free monad construction by extending our language with a new monadic action which returns a non-trivial result.</p>
<p>Suppose we want to generate HTML documents which contain hyperlinks to different sections of the document using <em>anchors</em>. We can accomplish this already, by generating anchor names by hand and including them at least twice in the document: once at the definition of the anchor itself, and once in each hyperlink. However, this approach has some basic issues:</p>
<ul>
<li>The developer might fail to generate unique anchor names.</li>
<li>The developer might mistype one or more instances of the anchor name.</li>
</ul>
<p>In the interest of protecting the developer from their own mistakes, we can introduce a new type which represents anchor names, and provide a monadic action for generating new unique names.</p>
<p>The first step is to add a new type for names:</p>
<pre><code class="language-haskell">newtype Name = Name String

runName :: Name -&gt; String
runName (Name n) = n
</code></pre>
<p>Again, we define this as a newtype around <code>String</code>, but we must be careful not to export the data constructor in the module's export lists.</p>
<p>Next, we define an instance for the <code>IsValue</code> type class for our new type, so that we are able to use names in attribute values:</p>
<pre><code class="language-haskell">instance nameIsValue :: IsValue Name where
  toValue (Name n) = n
</code></pre>
<p>We also define a new data type for hyperlinks which can appear in <code>a</code> elements, as follows:</p>
<pre><code class="language-haskell">data Href
  = URLHref String
  | AnchorHref Name

instance hrefIsValue :: IsValue Href where
  toValue (URLHref url) = url
  toValue (AnchorHref (Name nm)) = &quot;#&quot; &lt;&gt; nm
</code></pre>
<p>With this new type, we can modify the value type of the <code>href</code> attribute, forcing our users to use our new <code>Href</code> type. We can also create a new <code>name</code> attribute, which can be used to turn an element into an anchor:</p>
<pre><code class="language-haskell">href :: AttributeKey Href
href = AttributeKey &quot;href&quot;

name :: AttributeKey Name
name = AttributeKey &quot;name&quot;
</code></pre>
<p>The remaining problem is that our users currently have no way to generate new names. We can provide this functionality in our <code>Content</code> monad. First, we need to add a new data constructor to our <code>ContentF</code> type constructor:</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a
  | NewName (Name -&gt; a)
</code></pre>
<p>The <code>NewName</code> data constructor corresponds to an action which returns a value of type <code>Name</code>. Notice that instead of requiring a <code>Name</code> as a data constructor argument, we require the user to provide a <em>function</em> of type <code>Name -&gt; a</code>. Remembering that the type <code>a</code> represents the <em>rest of the computation</em>, we can see that this function provides a way to continue computation after a value of type <code>Name</code> has been returned.</p>
<p>We also need to update the <code>Functor</code> instance for <code>ContentF</code>, taking into account the new data constructor, as follows:</p>
<pre><code class="language-haskell">instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
  map f (NewName k) = NewName (f &lt;&lt;&lt; k)
</code></pre>
<p>Now we can build our new action by using the <code>liftF</code> function, as before:</p>
<pre><code class="language-haskell">newName :: Content Name
newName = liftF $ NewName id
</code></pre>
<p>Notice that we provide the <code>id</code> function as our continuation, meaning that we return the result of type <code>Name</code> unchanged.</p>
<p>Finally, we need to update our interpretation function, to interpret the new action. We previously used the <code>Writer String</code> monad to interpret our computations, but that monad does not have the ability to generate new names, so we must switch to something else. The <code>WriterT</code> monad transformer can be used with the <code>State</code> monad to combine the effects we need. We can define our interpretation monad as a type synonym to keep our type signatures short:</p>
<pre><code class="language-haskell">type Interp = WriterT String (State Int)
</code></pre>
<p>Here, the state of type <code>Int</code> will act as an incrementing counter, used to generate unique names.</p>
<p>Because the <code>Writer</code> and <code>WriterT</code> monads use the same type class members to abstract their actions, we do not need to change any actions - we only need to replace every reference to <code>Writer String</code> with <code>Interp</code>. We do, however, need to modify the handler used to run our computation. Instead of just <code>execWriter</code>, we now need to use <code>evalState</code> as well:</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render e = evalState (execWriterT (renderElement e)) 0
</code></pre>
<p>We also need to add a new case to <code>renderContentItem</code>, to interpret the new <code>NewName</code> data constructor:</p>
<pre><code class="language-haskell">renderContentItem (NewName k) = do
  n &lt;- get
  let fresh = Name $ &quot;name&quot; &lt;&gt; show n
  put $ n + 1
  pure (k fresh)
</code></pre>
<p>Here, we are given a continuation <code>k</code> of type <code>Name -&gt; Content a</code>, and we need to construct an interpretation of type <code>Content a</code>. Our interpretation is simple: we use <code>get</code> to read the state, use that state to generate a unique name, then use <code>put</code> to increment the state. Finally, we pass our new name to the continuation to complete the computation.</p>
<p>With that, we can try out our new functionality in PSCi, by generating a unique name inside the <code>Content</code> monad, and using it as both the name of an element and the target of a hyperlink:</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Name
&gt; import Effect.Console

&gt; :paste
‚Ä¶ render $ p [ ] $ do
‚Ä¶   top &lt;- newName
‚Ä¶   elem $ a [ name := top ] $
‚Ä¶     text &quot;Top&quot;
‚Ä¶   elem $ a [ href := AnchorHref top ] $
‚Ä¶     text &quot;Back to top&quot;
‚Ä¶ ^D

&lt;p&gt;&lt;a name=&quot;name0&quot;&gt;Top&lt;/a&gt;&lt;a href=&quot;#name0&quot;&gt;Back to top&lt;/a&gt;&lt;/p&gt;
unit
</code></pre>
<p>You can verify that multiple calls to <code>newName</code> do in fact result in unique names.</p>
<h2 id="exercises-50"><a class="header" href="#exercises-50">Exercises</a></h2>
<ol>
<li>
<p>(Medium) We can simplify the API further by hiding the <code>Element</code> type from its users. Make these changes in the following steps:</p>
<ul>
<li>Combine functions like <code>p</code> and <code>img</code> (with return type <code>Element</code>) with the <code>elem</code> action to create new actions with return type <code>Content Unit</code>.</li>
<li>Change the <code>render</code> function to accept an argument of type <code>Content Unit</code> instead of <code>Element</code>.</li>
</ul>
</li>
<li>
<p>(Medium) Hide the implementation of the <code>Content</code> monad by using a <code>newtype</code> instead of a type synonym. You should not export the data
constructor for your <code>newtype</code>.</p>
</li>
<li>
<p>(Difficult) Modify the <code>ContentF</code> type to support a new action</p>
<pre><code class="language-haskell">isMobile :: Content Boolean
</code></pre>
<p>which returns a boolean value indicating whether or not the document is being rendered for display on a mobile device.</p>
<p><em>Hint</em>: use the <code>ask</code> action and the <code>ReaderT</code> monad transformer to interpret this action. Alternatively, you might prefer to use the <code>RWS</code> monad.</p>
</li>
</ol>
<h2 id="conclusion-12"><a class="header" href="#conclusion-12">Conclusion</a></h2>
<p>In this chapter, we developed a domain-specific language for creating HTML documents, by incrementally improving a naive implementation using some standard techniques:</p>
<ul>
<li>We used <em>smart constructors</em> to hide the details of our data representation, only permitting the user to create documents which were <em>correct-by-construction</em>.</li>
<li>We used an <em>user-defined infix binary operator</em> to improve the syntax of the language.</li>
<li>We used <em>phantom types</em> to encode additional information in the types of our data, preventing the user from providing attribute values of the wrong type.</li>
<li>We used the <em>free monad</em> to turn our array representation of a collection of content into a monadic representation supporting do notation. We then extended this representation to support a new monadic action, and interpreted the monadic computations using standard monad transformers.</li>
</ul>
<p>These techniques all leverage PureScript's module and type systems, either to prevent the user from making mistakes or to improve the syntax of the domain-specific language.</p>
<p>The implementation of domain-specific languages in functional programming languages is an area of active research, but hopefully this provides a useful introduction some simple techniques, and illustrates the power of working in a language with expressive types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ÂÆü‰æã„Å´„Çà„Çãpurescript"><a class="header" href="#ÂÆü‰æã„Å´„Çà„Çãpurescript">ÂÆü‰æã„Å´„Çà„ÇãPureScript</a></h1>
<p>„Åì„ÅÆ„É™„Éù„Ç∏„Éà„É™„Å´„ÅØ„ÄÅPhil Freeman„Å´„Çà„Çã<strong>PureScript by
Example</strong>„ÅÆ<a href="https://github.com/purescript-contrib/purescript-book/">„Ç≥„Éü„É•„Éã„ÉÜ„Ç£„Éï„Ç©„Éº„ÇØ</a>„ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇ
ÂêåÊõ∏„ÅØ&quot;the PureScript book&quot; „Å®„Åó„Å¶„ÇÇÁü•„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÅØ„Ç≥„Éº„Éâ„Å®ÊºîÁøí„ÅåÊúÄËøë„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÅÆ„Ç≥„É≥„Éë„Ç§„É©„ÄÅ„É©„Ç§„Éñ„É©„É™„ÄÅ„ÉÑ„Éº„É´„ÅßÂãï„Åè„Çà„ÅÜ„Å´Êõ¥Êñ∞„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
PureScript„ÅÆ„Ç®„Ç≥„Ç∑„Çπ„ÉÜ„É†„ÅÆÊúÄÊñ∞„ÅÆÊ©üËÉΩ„ÇíÁ¥π‰ªã„Åô„Åπ„ÅèÊõ∏„ÅçÁõ¥„Åï„Çå„ÅüÁ´†„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>Êú¨Êõ∏„Çí„ÅäÊ•Ω„Åó„Åø„ÅÑ„Åü„Å†„Åç„ÅäÂΩπÁ´ã„Å°„ÅÑ„Åü„Å†„Åë„Åæ„Åó„Åü„Çâ„ÄÅ<a href="https://leanpub.com/purescript">Leanpub„ÅÆÂéüÊõ∏</a>„ÅÆË≥ºÂÖ•„Çí„ÅîÊ§úË®é„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="ÁèæÁä∂"><a class="header" href="#ÁèæÁä∂">ÁèæÁä∂</a></h2>
<p>„Åì„ÅÆÊú¨„ÅØË®ÄË™û„ÅÆÈÄ≤Âåñ„Å´‰º¥„Å£„Å¶Á∂ôÁ∂öÁöÑ„Å´Êõ¥Êñ∞„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅÂÜÖÂÆπ„Å´Èñ¢„Åó„Å¶Áô∫Ë¶ã„Åó„Åü„Å©„Çì„Å™<a href="https://github.com/purescript-contrib/purescript-book/issues">ÂïèÈ°å</a>„Åß„ÇÇ„ÅîÂ†±Âëä„Åè„Å†„Åï„ÅÑ„ÄÇ
„Çà„ÇäÂàùÂøÉËÄÖ„Å´„ÇÑ„Åï„Åó„Åè„Åß„Åç„Åù„ÅÜ„Å™ÂàÜ„Åã„Çä„Å•„Çâ„ÅÑÁØÄ„ÇíÊåáÊëò„Åô„Çã„Çà„ÅÜ„Å™ÂçòÁ¥î„Å™„ÇÇ„ÅÆ„Åß„ÅÇ„Çå„ÄÅÂÖ±Êúâ„ÅÑ„Åü„Å†„ÅÑ„Åü„Å©„Çì„Å™„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Å´„ÇÇÊÑüË¨ù„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åû„Çå„ÅÆÁ´†„Å´„ÅØÂçò‰Ωì„ÉÜ„Çπ„Éà„ÇÇÂä†„Åà„Çâ„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅÊºîÁøí„Å∏„ÅÆËá™ÂàÜ„ÅÆÂõûÁ≠î„ÅåÊ≠£„Åó„ÅÑ„Åã„Å©„ÅÜ„ÅãÁ¢∫„Åã„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„ÉÜ„Çπ„Éà„ÅÆÊúÄÊñ∞„ÅÆÁä∂ÊÖã„Å´„Å§„ÅÑ„Å¶„ÅØ<a href="https://github.com/purescript-contrib/purescript-book/issues/79">#79</a>„ÇíË¶ã„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="Êú¨Êõ∏„Å´„Å§„ÅÑ„Å¶"><a class="header" href="#Êú¨Êõ∏„Å´„Å§„ÅÑ„Å¶">Êú¨Êõ∏„Å´„Å§„ÅÑ„Å¶</a></h2>
<p>PureScript„ÅØ„ÄÅË°®ÁèæÂäõ„ÅÆ„ÅÇ„ÇãÂûã„ÇíÊåÅ„Å§„ÄÅÂ∞è„Åï„Åè„ÄÅÂº∑Âäõ„Åß„ÄÅÈùôÁöÑ„Å´Âûã‰ªò„Åë„Åï„Çå„Åü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„Åß„Åô„ÄÇ
Haskell„ÅßÊõ∏„Åã„Çå„ÄÅ„Åæ„Åü„Åì„ÅÆË®ÄË™û„Åã„ÇâÁùÄÊÉ≥„ÇíÂæó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åù„Åó„Å¶„ÄÅJavaScript„Å´„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>JavaScript„Åß„ÅÆÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅØÊúÄËøë„Åã„Å™„Çä„ÅÆ‰∫∫Ê∞ó„ÇíË™á„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åó„Åü„Åå„ÄÅ„Ç≥„Éº„Éâ„ÇíÊõ∏„Åè‰∏ä„ÅßÁµ±Âà∂„Åï„Çå„ÅüÁí∞Â¢É„ÅåÊ¨†„Åë„Å¶„ÅÑ„Çã„Åì„Å®„ÅåÂ§ßË¶èÊ®°„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÈñãÁô∫„ÅÆÂ¶®„Åí„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
PureScript„ÅØ„ÄÅÂº∑Âäõ„Å´Âûã‰ªò„Åë„Åï„Çå„ÅüÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÂäõ„ÇíJavaScript„Åß„ÅÆÈñãÁô∫„ÅÆ‰∏ñÁïå„Å´ÊåÅ„Å°Ëæº„ÇÄ„Åì„Å®„Å´„Çà„Çä„ÄÅ„Åì„ÅÆÂïèÈ°å„ÅÆËß£Ê±∫„ÇíÁõÆÊåá„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÊú¨„ÅØ„ÄÅÂü∫Á§éÔºàÈñãÁô∫Áí∞Â¢É„ÅÆÁ´ã„Å°‰∏ä„ÅíÔºâ„Åã„ÇâÂøúÁî®„Å´Ëá≥„Çã„Åæ„Åß„ÅÆ„ÄÅPureScript„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„ÅÆÂßã„ÇÅÊñπ„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åû„Çå„ÅÆÁ´†„ÅØÁâπÂÆö„ÅÆË™≤È°å„Å´„Çà„ÇäÂãïÊ©ü‰ªò„Åë„Çâ„Çå„Å¶„Åä„Çä„ÄÅ„Åù„ÅÆÂïèÈ°å„ÇíËß£„ÅÑ„Å¶„ÅÑ„ÅèÈÅéÁ®ã„Å´„Åä„ÅÑ„Å¶„ÄÅÊñ∞„Åó„ÅÑÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÈÅìÂÖ∑„Å®ÊäÄÊ≥ï„ÅåÂ∞éÂÖ•„Åï„Çå„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅØ„Åì„ÅÆÊú¨„ÅßËß£„ÅÑ„Å¶„ÅÑ„ÅèË™≤È°å„ÅÆ„ÅÑ„Åè„Å§„Åã„ÅÆ‰æã„Åß„Åô„ÄÇ</p>
<ul>
<li>„Éû„ÉÉ„Éó„Å®Áï≥„ÅøËæº„Åø„Çí‰Ωø„Å£„Åü„Éá„Éº„ÇøÊßãÈÄ†„ÅÆÂ§âÊèõ</li>
<li>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Çí‰Ωø„Å£„Åü„Éï„Ç©„Éº„É†„Éï„Ç£„Éº„É´„Éâ„ÅÆÊ§úË®º</li>
<li>QuickCheck„Å´„Çà„Çã„Ç≥„Éº„Éâ„ÅÆÊ§úÊüª</li>
<li>Canvas„ÅÆ‰ΩøÁî®</li>
<li>È†òÂüüÁâπÂåñË®ÄË™û„ÅÆÂÆüË£Ö</li>
<li>DOM„ÅÆÂèñ„ÇäÂõû„Åó</li>
<li>JavaScript„ÅÆÁõ∏‰∫íÈÅãÁî®ÊÄß</li>
<li>‰∏¶ÂàóÈùûÂêåÊúüÂÆüË°å</li>
</ul>
<h2 id="‰ΩøÁî®Ë®±Ë´æ"><a class="header" href="#‰ΩøÁî®Ë®±Ë´æ">‰ΩøÁî®Ë®±Ë´æ</a></h2>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons
Attribution-NonCommercial-ShareAlike 3.0 Unported License:
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p><small>‚Äª‰ª•Èôç„ÅÆÂéüÊñá„ÅÆ‰ΩøÁî®Ë®±Ë´æ„Å´Èñ¢„Åô„ÇãÂíåË®≥„ÅØÊ≥ïÁöÑÂäπÂäõ„ÇíÊåÅ„Å°„Åæ„Åõ„Çì„ÄÇ<br>
Êú¨Êõ∏„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÅØ<a
href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">Ë°®Á§∫ - ÈùûÂñ∂Âà© -
Á∂ôÊâø3.0ÈùûÁßªÊ§ç (CC BY-NC-SA 3.0)</a>„ÅÆ„ÇÇ„Å®„Å´‰ΩøÁî®„ÅåË®±Ë´æ„Åï„Çå„Çã„ÄÇ</small></p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation
Repo</a>, which uses the same
license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various
contributors</a>.</p>
<p><small>„ÅÑ„Åè„Å§„Åã„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÅØ<a href="https://github.com/purescript/documentation">PureScript„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„É™„Éù„Ç∏„Éà„É™</a>„Åã„ÇâÊ¥æÁîü„Åó„Å¶„ÅÑ„Çã„ÄÇ
Ê¥æÁîüÂÖÉ„ÇÇÂêå„Åò‰ΩøÁî®Ë®±Ë´æ„Åß„ÅÇ„Çä„ÄÅ<a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">Êßò„ÄÖ„Å™ÂΩ¢„ÅßË≤¢ÁåÆ„Åï„Çå„ÅüÊñπ„ÄÖ</a>„ÅÆËëó‰ΩúÊ®©„ÅåÂê´„Åæ„Çå„Çã„ÄÇ</small></p>
<p>The exercises are licensed under the MIT license.</p>
<p><small>ÊºîÁøí„ÅØMIT„É©„Ç§„Çª„É≥„Çπ„ÅÆ‰∏ã„Å´‰ΩøÁî®„ÅåË®±Ë´æ„Åï„Çå„Çã„ÄÇ</small></p>
<hr />
<small>
<p>Copyright (C) 2015-2018 aratama.<br>
Copyright (C) 2022 gemmaro.</p>
<p>„Åì„ÅÆÁøªË®≥„ÅØ<a href="https://github.com/aratama">aratama</a>Ê∞è„Å´„Çà„ÇãÁøªË®≥„ÇíÂÖÉ„Å´ÊîπÂ§â„ÇíÂä†„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂêåÊ∞è„ÅÆÁøªË®≥„É™„Éù„Ç∏„Éà„É™„ÅØ<a href="https://github.com/aratama/purescript-book-ja"><code>aratama/purescript-book-ja</code></a>„Å´„ÄÅWeb„Çµ„Ç§„Éà„ÅØ<a href="http://aratama.github.io/purescript/">ÂÆü‰æã„Å´„Çà„ÇãPureScript</a>„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ
<a href="http://aratama.github.io/purescript/">aratamaÊ∞èË®≥„ÅÆ‰ΩøÁî®Ë®±Ë´æ</a>„ÅØ‰ª•‰∏ã„ÅÆÈÄö„Çä„Åß„Åô„ÄÇ</p>
<blockquote>
<p>This book is licensed under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</p>
<p>Êú¨Êõ∏„ÅØ<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">„ÇØ„É™„Ç®„Ç§„ÉÜ„Ç£„Éñ„Ç≥„É¢„É≥„Ç∫ Ë°®Á§∫ - ÈùûÂñ∂Âà© - Á∂ôÊâø 3.0 ÈùûÁßªÊ§ç„É©„Ç§„Çª„É≥„Çπ</a>„Åß„É©„Ç§„Çª„É≥„Çπ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
</blockquote>
<p>Êú¨ÁøªË®≥„ÇÇÂéüÊñá„Å®ÂéüÁøªË®≥„Å´„Åó„Åü„Åå„ÅÑ„ÄÅ
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>„ÅÆ‰∏ã„Å´‰ΩøÁî®„ÅåË®±Ë´æ„Åï„Çå„Åæ„Åô„ÄÇ</p>
</small><div style="break-before: page; page-break-before: always;"></div><h1 id="Â∞éÂÖ•"><a class="header" href="#Â∞éÂÖ•">Â∞éÂÖ•</a></h1>
<h2 id="Èñ¢Êï∞Âûãjavascript"><a class="header" href="#Èñ¢Êï∞Âûãjavascript">Èñ¢Êï∞ÂûãJavaScript</a></h2>
<p>Èñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÊâãÊ≥ï„ÅåJavaScript„Å´Âßø„ÇíÁèæ„Åó„ÅØ„Åò„ÇÅ„Å¶„Åã„Çâ„Åó„Å∞„Çâ„ÅèÁµå„Å°„Åæ„Åô„ÄÇ</p>
<ul>
<li>
<p><a href="https://underscorejs.org">UnderscoreJS</a>„Å™„Å©„ÅÆ„É©„Ç§„Éñ„É©„É™„Åå„ÅÇ„Çå„Å∞„ÄÅÈñãÁô∫
ËÄÖ„ÅØ<code>map</code>„ÇÑ <code>filter</code>„ÄÅ<code>reduce</code>„Å®„ÅÑ„Å£„ÅüÂÆüÁ∏æ„ÅÆ„ÅÇ„ÇãÈñ¢Êï∞„ÇíÊ¥ªÁî®„Åó„Å¶„ÄÅÂ∞è„Åï„ÅÑ
„Éó„É≠„Ç∞„É©„É†„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Åì„Å®„ÅßÂ§ß„Åç„Å™„Éó„É≠„Ç∞„É©„É†„Çí‰Ωú„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">var sumOfPrimes =
    _.chain(_.range(1000))
     .filter(isPrime)
     .reduce(function(x, y) {
         return x + y;
     })
     .value();
</code></pre>
</li>
<li>
<p>NodeJS„Å´„Åä„Åë„ÇãÈùûÂêåÊúü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Åß„ÅØ„ÄÅÁ¨¨‰∏ÄÁ¥ö„ÅÆÂÄ§„Å®„Åó„Å¶„ÅÆÈñ¢Êï∞„Çí„Ç≥„Éº„É´
„Éê„ÉÉ„ÇØ„ÇíÂÆöÁæ©„Åô„Çã„Åü„ÇÅ„Å´Â§öÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">import { readFile, writeFile } from 'fs'

readFile(sourceFile, function (error, data) {
  if (!error) {
    writeFile(destFile, data, function (error) {
      if (!error) {
        console.log(&quot;File copied&quot;);
      }
    });
  }
});
</code></pre>
</li>
<li>
<p><a href="https://reactjs.org">React</a>„ÇÑ<a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a>„Å™„Å©„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅØ„ÄÅ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÁä∂ÊÖã„Å´„Å§„ÅÑ„Å¶„ÅÆÁ¥îÁ≤ã„Å™Èñ¢Êï∞„Å®„Åó„Å¶„Åù„ÅÆÂ§ñË¶≥„Çí„É¢„Éá„É´Âåñ„Åó„Å¶„ÅÑ„Åæ„Åô</p>
</li>
</ul>
<p>Èñ¢Êï∞„ÅØÂçòÁ¥î„Å™ÊäΩË±°Âåñ„ÇíÂèØËÉΩ„Å´„Åó„ÄÅÂÑ™„Çå„ÅüÁîüÁî£ÊÄß„Çí„ÇÇ„Åü„Çâ„Åó„Å¶„Åè„Çå„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅJavaScript„Åß„ÅÆÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Å´„ÅØÊ¨†ÁÇπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
JavaScript„ÅØÂÜóÈï∑„Åß„ÄÅÂûã‰ªò„Åë„Åï„Çå„Åö„ÄÅÂº∑Âäõ„Å™ÊäΩË±°Âåñ„ÇíÊ¨†„ÅÑ„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åô„ÄÇ
„Åæ„Åü„ÄÅÁÑ°Áß©Â∫è„Å´Êõ∏„Åã„Çå„ÅüJavaScript„Ç≥„Éº„Éâ„Åß„ÅØ„ÄÅÁ≠âÂºèÊé®Ë´ñ„Åå„Å®„Å¶„ÇÇÂõ∞Èõ£„Åß„Åô„ÄÇ</p>
<p>PureScript„ÅØ„Åì„ÅÆ„Çà„ÅÜ„Å™ÂïèÈ°å„ÇíËß£Ê±∫„Åô„Åπ„Åè‰Ωú„Çâ„Çå„Åü„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„Åß„Åô„ÄÇ
PureScript„ÅØ„ÄÅ„Å®„Å¶„ÇÇË°®ÁèæÂäõË±ä„Åã„Åß„ÅÇ„Çä„Å™„Åå„Çâ„Çè„Åã„Çä„ÇÑ„Åô„ÅèË™≠„Åø„ÇÑ„Åô„ÅÑ„Ç≥„Éº„Éâ„ÇíÊõ∏„Åë„Çã„Çà„ÅÜ„Å´„Åô„Çã„ÄÅ
ËªΩÈáè„Å™ÊßãÊñá„ÇíÂÇô„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Âº∑Âäõ„Å™ÊäΩË±°Âåñ„ÇíÊèê‰æõ„Åô„ÇãË±ä„Åã„Å™Âûã„Ç∑„Çπ„ÉÜ„É†„ÇÇÊé°Áî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åæ„Åü„ÄÅJavaScript„ÇÑJavaScript„Å∏„Å®„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„Çã‰ªñ„ÅÆË®ÄË™û„Å®Áõ∏‰∫íÈÅãÁî®„Åô„Çã„Å®„Åç„Å´ÈáçË¶Å„Å™„ÄÅ
È´òÈÄü„ÅßÁêÜËß£„Åó„ÇÑ„Åô„ÅÑ„Ç≥„Éº„Éâ„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
PureScript„Çí„Å≤„Å®„Åì„Å®„ÅßË®Ä„Åà„Å∞„ÄÅÁ¥îÁ≤ãÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÁêÜË´ñÁöÑ„Å™Âº∑Âäõ„Åï„Å®„ÄÅ
JavaScript„ÅÆ„ÅäÊâãËªΩ„ÅßÁ∑©„ÅÑ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Çπ„Çø„Ç§„É´„Å®„ÅÆ„ÄÅ
„Å®„Å¶„ÇÇÁèæÂÆüÁöÑ„Å™„Éê„É©„É≥„Çπ„ÇíÁãô„Å£„ÅüË®ÄË™û„Å†„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíÁêÜËß£„Åó„Å¶È†Ç„Åë„Åü„Çâ„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="Âûã„Å®ÂûãÊé®Ë´ñ"><a class="header" href="#Âûã„Å®ÂûãÊé®Ë´ñ">Âûã„Å®ÂûãÊé®Ë´ñ</a></h2>
<p>ÂãïÁöÑÂûã‰ªò„Åë„ÅÆË®ÄË™û„Å®ÈùôÁöÑÂûã‰ªò„Åë„ÅÆË®ÄË™û„Çí„ÇÅ„Åê„ÇãË≠∞Ë´ñ„Å´„Å§„ÅÑ„Å¶„ÅØ„Çà„ÅèÁü•„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
PureScript„ÅØ<strong>ÈùôÁöÑÂûã‰ªò„Åë</strong>„ÅÆË®ÄË™û„ÄÅ
„Å§„Åæ„ÇäÊ≠£„Åó„ÅÑ„Éó„É≠„Ç∞„É©„É†„ÅØ„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶„Åù„ÅÆÂãï‰Ωú„ÇíÁ§∫„Åô„Çà„ÅÜ„Å™<strong>Âûã</strong>„Çí‰∏é„Åà„Çâ„Çå„ÇãË®ÄË™û„Åß„Åô„ÄÇ
ÈÄÜ„Å´„ÅÑ„Åà„Å∞„ÄÅÂûã„Çí‚Äã‚Äã‰∏é„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Å™„ÅÑ„Éó„É≠„Ç∞„É©„É†„ÅØ<strong>Ë™§„Å£„Åü„Éó„É≠„Ç∞„É©„É†</strong>„Åß„ÅÇ„Çä„ÄÅ
„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶ÊãíÂê¶„Åï„Çå„Åæ„Åô„ÄÇ
ÂãïÁöÑÂûã‰ªò„Åë„ÅÆË®ÄË™û„Å®„ÅØÁï∞„Å™„Çä„ÄÅ
PureScript„Åß„ÅØÂûã„ÅØ<strong>„Ç≥„É≥„Éë„Ç§„É´ÊôÇ</strong>„ÅÆ„Åø„Å´Â≠òÂú®„Åó„ÄÅ
ÂÆüË°åÊôÇ„Å´„ÅØÂûã„ÅÆË°®Áèæ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>PureScript„ÅÆÂûã„ÅØ„ÄÅ„Åì„Çå„Åæ„ÅßJava„ÇÑC#„ÅÆ„Çà„ÅÜ„Å™‰ªñ„ÅÆË®ÄË™û„ÅßË¶ã„Åü„Çà„ÅÜ„Å™Âûã„Å®„ÅØ„ÄÅ
„ÅÑ„Çç„ÅÑ„Çç„Å™ÊÑèÂë≥„ÅßÁï∞„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Å´„ÇÇÊ≥®ÊÑè„Åô„Çã„Åì„Å®„ÅåÂ§ßÂàá„Åß„Åô„ÄÇ
„Åä„Åä„Åæ„Åã„Å´Ë®Ä„Åà„Å∞PureScript„ÅÆÂûã„ÅØJava„ÇÑC#„Å®Âêå„ÅòÁõÆÁöÑ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÅÆ„ÄÅ
PureScript„ÅÆÂûã„ÅØML„Å®Haskell„ÅÆ„Çà„ÅÜ„Å™Ë®ÄË™û„Å´ÂΩ±Èüø„ÇíÂèó„Åë„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÈñãÁô∫ËÄÖ„Åå„Éó„É≠„Ç∞„É©„É†„Å´„Å§„ÅÑ„Å¶„ÅÆÂº∑„ÅÑ‰∏ªÂºµ„ÇíË°®Êòé„Åß„Åç„Çã„ÅÆ„Åß„ÄÅPureScript„ÅÆÂûã„ÅØË°®ÁèæÂäõË±ä„Åã„Å™„ÅÆ„Åß„Åô„ÄÇ
ÊúÄ„ÇÇÈáçË¶Å„Å™„ÅÆ„ÅØ„ÄÅPureScript„ÅÆÂûã„Ç∑„Çπ„ÉÜ„É†„ÅØ<strong>ÂûãÊé®Ë´ñ</strong>(type inference)„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Åß„Åô„ÄÇ
ÂûãÊé®Ë´ñ„Åå„ÅÇ„Çå„Å∞‰ªñ„ÅÆË®ÄË™û„Çà„ÇäÈÅ•„Åã„Å´Â∞ë„Å™„ÅÑÂûãÊ≥®Èáà„Åß‰Ωè„Åø„ÄÅ
Âûã„Ç∑„Çπ„ÉÜ„É†„ÇíÂéÑ‰ªãËÄÖ„Åß„ÅØ„Å™„Åè<strong>ÈÅìÂÖ∑</strong>„Å´„Åó„Å¶„Åè„Çå„Åæ„Åô„ÄÇ
Á∞°Âçò„Å™‰æã„ÇíÁ§∫„Åô„Å®„ÄÅÊ¨°„ÅÆ„Ç≥„Éº„Éâ„ÅØ<strong>Êï∞</strong>„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
„Åù„Çå„Åå <code>Number</code>Âûã„Å†„Å®„ÅÑ„ÅÜÊ≥®Èáà„ÅØ„Ç≥„Éº„Éâ„ÅÆ„Å©„Åì„Å´„ÇÇ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">iAmANumber =
  let square x = x * x
  in square 42.0
</code></pre>
<p>Ê¨°„ÅÆ„ÇÇ„Å£„Å®Ë§áÈõë„Å™‰æã„Åß„ÅØ„ÄÅ
<strong>„Ç≥„É≥„Éë„Ç§„É©„Å´„Å®„Å£„Å¶Êú™Áü•</strong>„ÅÆÂûã„ÅåÂ≠òÂú®„Åó„Å¶„ÅÑ„Çã„Å®„Åç„Åß„Åï„Åà„ÇÇ„ÄÅ
ÂûãÊ≥®Èáà„Å™„Åó„ÅßÂûã„ÅÆÊ≠£„Åó„Åï„ÇíÁ¢∫„Åã„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÅåÁ§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">iterate f 0 x = x
iterate f n x = iterate f (n - 1) (f x)
</code></pre>
<p>„Åì„Åì„Åß <code>x</code>„ÅÆÂûã„ÅØ‰∏çÊòé„Åß„Åô„Åå„ÄÅ
<code>x</code>„Åå„Å©„Çì„Å™Âûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åã„Å´„Åã„Åã„Çè„Çâ„Åö„ÄÅ
<code>iterate</code>„ÅåÂûã„Ç∑„Çπ„ÉÜ„É†„ÅÆË¶èÂâá„Å´Âæì„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Çí„Ç≥„É≥„Éë„Ç§„É©„ÅØÊ§úË®º„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>Êú¨Êõ∏„ÅßÁ¥çÂæó„Åó„Å¶„ÅÑ„Åü„Å†„Åç„Åü„ÅÑÔºà„Åæ„Åü„ÅØÊó¢„Å´„ÅäÊåÅ„Å°„ÅÆ‰ø°Êù°„Å´ÂØÑ„ÇäÊ∑ª„Å£„Å¶Êîπ„ÇÅ„Å¶Êñ≠Ë®Ä„Åó„Åü„ÅÑÔºâ„Åì„Å®„ÅØ„ÄÅ
ÈùôÁöÑÂûã„ÅåÂçò„Å´„Éó„É≠„Ç∞„É©„É†„ÅÆÊ≠£„Åó„Åï„Å´Ëá™‰ø°„ÇíÊåÅ„Å§„Åü„ÇÅ„Å†„Åë„ÅÆ„ÇÇ„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ
„Åù„ÇåËá™Ë∫´„ÅÆÊ≠£„Åó„Åï„Å´„Çà„Å£„Å¶ÈñãÁô∫„ÅÆÊâãÂä©„Åë„Å´„Å™„Çã„ÇÇ„ÅÆ„Åß„ÇÇ„ÅÇ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
JavaScript„Åß„ÅØ„Åî„ÅèÂçòÁ¥î„Å™ÊäΩË±°Âåñ„ÇíÊñΩ„Åô„ÅÆ„Åß„ÇÇÂ§ßË¶èÊ®°„Å™„Ç≥„Éº„Éâ„ÅÆ„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞„Çí„Åô„Çã„Åì„Å®„ÅØÈõ£„Åó„ÅÑ„Åß„Åô„Åå„ÄÅ
ÂûãÊ§úË®ºÂô®„ÅÆ„ÅÇ„ÇãË°®ÁèæÂäõË±ä„Åã„Å™Âûã„Ç∑„Çπ„ÉÜ„É†„ÅØ„ÄÅ
„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞„Åï„ÅàÊ•Ω„Åó„ÅèÂØæË©±ÁöÑ„Å™‰ΩìÈ®ì„Å´„Åó„Å¶„Åè„Çå„Åæ„Åô„ÄÇ</p>
<p>Âä†„Åà„Å¶„ÄÅÂûã„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„Å£„Å¶Êèê‰æõ„Åï„Çå„Çã„Åì„ÅÆ„Çª„Éº„Éï„ÉÜ„Ç£„Éç„ÉÉ„Éà„ÅØ„ÄÅ
„Çà„ÇäÈ´òÂ∫¶„Å™ÊäΩË±°Âåñ„Çí„ÇÇÂèØËÉΩ„Å´„Åó„Åæ„Åô„ÄÇ
ÂÆüÈöõ„Å´„ÄÅÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™ûHaskell„Å´„Çà„Å£„Å¶Áü•„Çâ„Çå„Çã„Çà„ÅÜ„Å´„Å™„Å£„Åü„ÄÅ
ÂûãÈßÜÂãï„ÅÆÂº∑Âäõ„Å™ÊäΩË±°Âåñ„ÅÆÂΩ¢Âºè„Åß„ÅÇ„Çã„ÄéÂûã„ÇØ„É©„Çπ„Äè„ÇíPureScript„ÅØÂÇô„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="Â§öË®ÄË™ûweb„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞"><a class="header" href="#Â§öË®ÄË™ûweb„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞">Â§öË®ÄË™ûWeb„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞</a></h2>
<p>Èñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅØ„Åô„Åß„Å´Â§ö„Åè„ÅÆÊàêÂäü„ÇíÂèé„ÇÅ„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÊûöÊåô„Å´Êöá„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅÁâπ„Å´ÊàêÂäü„Åó„Å¶„ÅÑ„ÇãÂøúÁî®‰æã„Çí„ÅÑ„Åè„Å§„ÅãÊåô„Åí„Çã„Å®„ÄÅ
„Éá„Éº„ÇøËß£Êûê„ÄÅÊßãÊñáËß£Êûê„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅÆÂÆüË£Ö„ÄÅ„Ç∏„Çß„Éç„É™„ÉÉ„ÇØ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÄÅ‰∏¶ÂàóÂá¶ÁêÜ„Å™„Å©„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>PureScript„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞ÂûãË®ÄË™û„ÅØ„ÄÅ
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÈñãÁô∫„ÅÆÊúÄÂàù„Åã„ÇâÊúÄÂæå„Åæ„Åß„Çí‚ÄãÂÆüÊñΩ„Åô„Çã„Åì„Å®„ÅåÂèØËÉΩ„Åß„Åô„ÄÇ
ÂÄ§„ÇÑÈñ¢Êï∞„ÅÆÂûã„ÇíÊèê‰æõ„Åô„Çã„Åì„Å®„ÅßÊó¢Â≠ò„ÅÆJavaScript„Ç≥„Éº„Éâ„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„ÄÅ
ÈÄöÂ∏∏„ÅÆPureScript„Ç≥„Éº„Éâ„Åã„Çâ„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„Çí‰ΩøÁî®„Åô„ÇãÊ©üËÉΩ„ÇíPureScript„ÅØÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÊâãÊ≥ï„Å´„Å§„ÅÑ„Å¶„ÅØÊú¨Êõ∏„ÅÆÂæåÂçä„ÅßË¶ã„Å¶„ÅÑ„Åè„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅPureScript„ÅÆÂº∑„Åø„ÅÆ„Å≤„Å®„Å§„ÅØ„ÄÅJavaScript„ÇíÂØæË±°„Å®„Åô„Çã‰ªñ‚Äã‚Äã„ÅÆË®ÄË™û„Å®„ÅÆÁõ∏‰∫íÈÅãÁî®ÊÄß„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÈñãÁô∫„ÅÆ‰∏ÄÈÉ®„Å´„Å†„ÅëPureScript„Çí‰ΩøÁî®„Åó„ÄÅJavaScript„ÅÆÊÆã„Çä„ÅÆÈÉ®ÂàÜ„ÇíË®òËø∞„Åô„Çã„ÅÆ„Å´‰ªñ„ÅÆË®ÄË™û„Çí‰ΩøÁî®„Åô„Çã„Å®„ÅÑ„ÅÜÊñπÊ≥ï„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„ÅÑ„Åè„Å§„Åã„ÅÆ‰æã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<ul>
<li>‰∏≠Ê†∏„Å®„Å™„ÇãÂá¶ÁêÜ„ÅØPureScript„ÅßË®òËø∞„Åó„ÄÅ„É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„ÅØ
JavaScript„ÅßË®òËø∞„Åô„Çã</li>
<li>JavaScript„ÇÑ„ÄÅ‰ªñ„ÅÆJavaScript„Å´„Ç≥„É≥„Éë„Ç§„É´„Åô„ÇãË®ÄË™û„Åß„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÊõ∏
„Åç„ÄÅPureScript„Åß„Åù„ÅÆ„ÉÜ„Çπ„Éà„ÇíÊõ∏„Åè</li>
<li>Êó¢Â≠ò„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ„É¶„Éº„Ç∂„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ„ÅÆ„ÉÜ„Çπ„Éà„ÇíËá™ÂãïÂåñ„Åô„Çã„Åü„ÇÅ„Å´
PureScript„Çí‰ΩøÁî®„Åô„Çã</li>
</ul>
<p>„Åì„ÅÆÊú¨„Åß„ÅØÂ∞èË¶èÊ®°„Å™Ë™≤È°å„ÇíPureScript„ÅßËß£Ê±∫„Åô„Çã„Åì„Å®„Å´ÁÑ¶ÁÇπ„ÇíÂΩì„Å¶„Åæ„Åô„ÄÇ
„Åì„Åì„ÅßÂ≠¶„Å∂ÊâãÊ≥ï„ÅØÂ§ßË¶èÊ®°„Å™„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å´ÁµÑ„ÅøËæº„ÇÄ„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„Åå„ÄÅ
„Åì„Çå„Å´„Å§„ÅÑ„Å¶„ÅØJavaScript„Åã„ÇâPureScript„Ç≥„Éº„Éâ„ÇíÂëº„Å≥Âá∫„ÅôÊñπÊ≥ï„ÄÅ„Åä„Çà„Å≥„Åù„ÅÆÈÄÜ„Å´„Å§„ÅÑ„Å¶„ÇÇË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„ÇΩ„Éï„Éà„Ç¶„Çß„Ç¢Ë¶Å‰ª∂"><a class="header" href="#„ÇΩ„Éï„Éà„Ç¶„Çß„Ç¢Ë¶Å‰ª∂">„ÇΩ„Éï„Éà„Ç¶„Çß„Ç¢Ë¶Å‰ª∂</a></h2>
<p>„Åì„ÅÆÊú¨„Åß„ÅÆ„ÇΩ„Éï„Éà„Ç¶„Çß„Ç¢Ë¶Å‰ª∂„ÅØÊúÄÂ∞èÈôê„Åß„Åô„ÄÇ
Á¨¨1Á´†„Åß„ÅØÈñãÁô∫Áí∞Â¢É„ÅÆÊßãÁØâ„Çí‰∏Ä„Åã„ÇâÊ°àÂÜÖ„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„Åã„Çâ‰ΩøÁî®„Åô„Çã„ÉÑ„Éº„É´„ÅØ„ÄÅ„Åª„Å®„Çì„Å©„ÅÆÁèæ‰ª£„ÅÆ„Ç™„Éö„É¨„Éº„ÉÜ„Ç£„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÅÆÊ®ôÊ∫ñ„É™„Éù„Ç∏„Éà„É™„Åß‰ΩøÁî®„Åß„Åç„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<p>PureScript„Ç≥„É≥„Éë„Ç§„É©Ëá™‰Ωì„ÅØ„Éê„Ç§„Éä„É™ÂΩ¢Âºè„Åß„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„Åó„ÄÅ
ÊúÄÊñ∞„ÅÆHaskell„Ç≥„É≥„Éë„Ç§„É©„ÅåÁ®ºÂÉç„Åó„Å¶„ÅÑ„Çã„Ç∑„Çπ„ÉÜ„É†‰∏ä„Åß„ÇΩ„Éº„Çπ„Åã„Çâ„Éì„É´„Éâ„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
Ê¨°„ÅÆÁ´†„Åß„ÅØ„Åì„ÅÆÊâãÈ†Ü„ÇíË™¨Êòé„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>Êú¨Êõ∏„ÅÆ„Åì„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÅÆ„Ç≥„Éº„Éâ„ÅØ<code>0.15.*</code>„Éê„Éº„Ç∏„Éß„É≥„ÅÆPureScript„Ç≥„É≥„Éë„Ç§„É©„Å®‰∫íÊèõÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="Ë™≠ËÄÖ„Å´„Å§„ÅÑ„Å¶"><a class="header" href="#Ë™≠ËÄÖ„Å´„Å§„ÅÑ„Å¶">Ë™≠ËÄÖ„Å´„Å§„ÅÑ„Å¶</a></h2>
<p>Ë™≠ËÄÖ„ÅØJavaScript„ÅÆÂü∫Êú¨„Çí„Åô„Åß„Å´ÁêÜËß£„Åó„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„Å®‰ªÆÂÆö„Åó„Åæ„Åô„ÄÇ
„Åô„Åß„Å´NPM„ÇÑBower„ÅÆ„Çà„ÅÜ„Å™JavaScript„ÅÆ„Ç®„Ç≥„Ç∑„Çπ„ÉÜ„É†„Åß„ÅÆÁµåÈ®ì„Åå„ÅÇ„Çå„Å∞„ÄÅ
Ëá™Ë∫´„ÅÆÂ•Ω„Åø„Å´Âøú„Åò„Å¶Ê®ôÊ∫ñË®≠ÂÆö„Çí„Ç´„Çπ„Çø„Éû„Ç§„Ç∫„Åó„Åü„ÅÑÂ†¥Âêà„Å™„Å©„Å´ÂΩπ„Å´Á´ã„Å°„Åæ„Åô„ÄÇ
„Åß„Åô„Åå„ÄÅ„Åù„ÅÆ„Çà„ÅÜ„Å™Áü•Ë≠ò„ÅØÂøÖÈ†à„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>Èñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆ‰∫àÂÇôÁü•Ë≠ò„ÅØÂøÖË¶Å„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅ
„ÅÇ„Å£„Å¶„ÇÇÂÆ≥„Å´„ÅØ„Å™„Çâ„Å™„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ
Êñ∞„Åó„ÅÑËÄÉ„Åà„Åã„Åü„ÅØÂÆü‰æã„Å®„Å®„ÇÇ„Å´ÁôªÂ†¥„Åô„Çã„ÅÆ„Åß„ÄÅ
„Åì„Çå„Åã„Çâ‰Ωø„ÅÜÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Åã„Çâ„Åì„ÅÜ„Åó„ÅüÊ¶ÇÂøµ„Å´ÂØæ„Åô„ÇãÁõ¥ÊÑüÁöÑ„Å™ÁêÜËß£„ÇíÂæó„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅØ„Åö„Åß„Åô„ÄÇ</p>
<p>PureScript„ÅØ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™ûHaskell„Å´Âº∑„ÅèÂΩ±Èüø„ÇíÂèó„Åë„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅHaskell„Å´ÈÄö„Åò„Å¶„ÅÑ„ÇãË™≠ËÄÖ„ÅØ„Åì„ÅÆÊú¨„ÅÆ‰∏≠„ÅßÊèêÁ§∫„Åï„Çå„ÅüÊ¶ÇÂøµ„ÇÑÊßãÊñá„ÅÆÂ§ö„Åè„Å´Ë¶ãË¶ö„Åà„Åå„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅË™≠ËÄÖ„ÅØPureScript„Å®Haskell„ÅÆÈñì„Å´„ÅØ„ÅÑ„Åè„Å§„ÅãÈáçË¶Å„Å™ÈÅï„ÅÑ„Åå„ÅÇ„Çã„Åì„Å®„ÇÇÁêÜËß£„Åó„Å¶„Åä„Åã„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ„Åì„Åì„ÅßÁ¥π‰ªã„Åô„ÇãÊ¶ÇÂøµ„ÅÆÂ§ö„Åè„ÅØHaskell„Åß„ÇÇÂêå„Åò„Çà„ÅÜ„Å´Ëß£Èáà„Åß„Åç„Çã„Å®„ÅØ„ÅÑ„Åà„ÄÅ„Å©„Å°„Çâ„Åã„ÅÆË®ÄË™û„Åß„ÅÆËÄÉ„ÅàÊñπ„Çí‰ªñÊñπ„ÅÆË®ÄË™û„Åß„Åù„ÅÆ„Åæ„ÅæÂøúÁî®„Åó„Çà„ÅÜ„Å®„Åô„Çã„Åì„Å®„ÅØ„ÄÅÂøÖ„Åö„Åó„ÇÇÈÅ©Âàá„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<h2 id="Êú¨Êõ∏„ÅÆË™≠„ÅøÈÄ≤„ÇÅ„Åã„Åü"><a class="header" href="#Êú¨Êõ∏„ÅÆË™≠„ÅøÈÄ≤„ÇÅ„Åã„Åü">Êú¨Êõ∏„ÅÆË™≠„ÅøÈÄ≤„ÇÅ„Åã„Åü</a></h2>
<p>Êú¨Êõ∏„ÅÆÂêÑÁ´†„ÅØ„ÄÅÊ¶Ç„Å≠Á´†„Åî„Å®„Å´ÂÆåÁµê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅÂ§öÂ∞ë„ÅÆÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÁµåÈ®ì„Åå„ÅÇ„ÇãÂàùÂøÉËÄÖ„Åß„ÇÇ„ÄÅ
„Åæ„Åö„ÅØÂêÑÁ´†„ÇíÈ†ÜÁï™„Å´ÈÄ≤„ÇÅ„Å¶„ÅÑ„Åè„Åì„Å®„Çí„Åä„Åô„Åô„ÇÅ„Åó„Åæ„Åô„ÄÇ
ÊúÄÂàù„ÅÆÊï∞Á´†„Åß„ÅØ„ÄÅÊú¨Êõ∏„ÅÆÂæåÂçä„ÅÆÂÜÖÂÆπ„ÇíÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´ÂøÖË¶Å„Å™Âü∫Á§éÁü•Ë≠ò„ÇíÈ§ä„ÅÑ„Åæ„Åô„ÄÇ
Èñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆËÄÉ„ÅàÊñπ„Å´ÂçÅÂàÜÈÄö„Åò„ÅüË™≠ËÄÖ
ÔºàÁâπ„Å´ML„ÇÑHaskell„ÅÆ„Çà„ÅÜÂº∑„ÅèÂûã‰ªò„Åë„Åï„Çå„ÅüË®ÄË™û„Åß„ÅÆÁµåÈ®ì„ÇíÊåÅ„Å§Ë™≠ËÄÖÔºâ„Å™„Çâ„ÄÅ
Êú¨Êõ∏„ÅÆÂâçÂçä„ÅÆÁ´†„ÇíË™≠„Åæ„Å™„Åè„Å¶„ÇÇ„ÄÅÂæåÂçä„ÅÆÁ´†„ÅÆ„Ç≥„Éº„Éâ„ÅÆÂ§ß„Åæ„Åã„Å™ÁêÜËß£„ÇíÂæó„Çã„Åì„Å®„Åå„Åä„Åù„Çâ„ÅèÂèØËÉΩ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>ÂêÑÁ´†„Åß„ÅØ„Åù„Çå„Åû„Çå„Å≤„Å®„Å§„ÅÆÂÆüÁî®ÁöÑ„Å™‰æã„Å´ÁÑ¶ÁÇπ„Çí„ÅÇ„Å¶„ÄÅÊñ∞„Åó„ÅÑËÄÉ„ÅàÊñπ„ÇíÂ∞éÂÖ•„Åô„Çã„Åü„ÇÅ„ÅÆÂãïÊ©ü‰ªò„Åë„Å®„Åó„Å¶Áî®„ÅÑ„Åæ„Åô„ÄÇ
ÂêÑÁ´†„ÅÆ„Ç≥„Éº„Éâ„ÅØÊú¨Êõ∏„ÅÆ<a href="https://github.com/purescript-contrib/purescript-book">GitHub„ÅÆ„É™„Éù„Ç∏„Éà„É™</a>„Åã„ÇâÂÖ•Êâã„Åß„Åç„Åæ„Åô„ÄÇ
„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Åã„ÇâÊäúÁ≤ã„Åó„Åü„Ç≥„Éº„ÉâÁâá„ÅåÊé≤Ëºâ„Åï„Çå„Å¶„ÅÑ„ÇãÁ´†„ÇÇ„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅÂÆåÂÖ®„Å´ÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÅØÊú¨Êõ∏„Å´Êé≤Ëºâ„Åï„Çå„Åü„Ç≥„Éº„Éâ„Å®Âπ≥Ë°å„Åó„Å¶„É™„Éù„Ç∏„Éà„É™„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÇíË™≠„ÇÄÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÂØæË©±ÂºèÁí∞Â¢ÉPSCi„ÅßÂÆüË°å„ÅóÁêÜËß£„ÇíÁ¢∫„Åã„ÇÅ„Çâ„Çå„Çã„Çà„ÅÜ„Å´„ÄÅÈï∑„ÇÅ„ÅÆÁØÄ„Å´„ÅØÁü≠„ÅÑ„Ç≥„Éº„ÉâÁâá„ÅåÊé≤Ëºâ„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Ç≥„Éº„Éâ‰æã„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Á≠âÂπÖ„Éï„Ç©„É≥„Éà„ÅßÁ§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">module Example where

import Effect.Console (log)

main = log &quot;Hello, World!&quot;
</code></pre>
<p>ÂÖàÈ†≠„Å´„Éâ„É´Ë®òÂè∑„Åå„Å§„ÅÑ„ÅüË°å„ÅØ„ÄÅ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Å´ÂÖ•Âäõ„Åï„Çå„Åü„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>ÈÄöÂ∏∏„ÄÅ„Åì„Çå„Çâ„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØLinux„ÇÑMac
OS„ÅÆÂà©Áî®ËÄÖ„Å™„Çâ„Åù„ÅÆ„Åæ„ÅæÈÅ©Áî®„Åß„Åç„Åæ„Åô„Åå„ÄÅWindows„ÅÆÂà©Áî®ËÄÖ„ÅØ„Éï„Ç°„Ç§„É´Âå∫Âàá„ÇäÊñáÂ≠ó„ÇíÂ§âÊõ¥„Åô„Çã„ÄÅ„Ç∑„Çß„É´„ÅÆÁµÑ„ÅøËæº„ÅøÊ©üËÉΩ„ÇíWindows„ÅÆÁõ∏ÂΩì„Åô„Çã„ÇÇ„ÅÆ„Å´ÁΩÆ„ÅçÊèõ„Åà„Çã„Å™„Å©„ÅÆÂ∞è„Åï„Å™Â§âÊõ¥„ÇíÂä†„Åà„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<p>PSCiÂØæË©±Âºè„É¢„Éº„Éâ„Éó„É≠„É≥„Éó„Éà„Å´ÂÖ•Âäõ„Åô„Çã„Ç≥„Éû„É≥„Éâ„ÅØ„ÄÅË°å„ÅÆÂÖàÈ†≠„Å´Â±±Êã¨Âºß„Åå‰ªò„Åë„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; 1 + 2
3
</code></pre>
<p>ÂêÑÁ´†„Å´„ÅØÊºîÁøí„Åå‰ªò„ÅÑ„Å¶„Åä„Çä„ÄÅ„Åù„Çå„Åû„ÇåÈõ£ÊòìÂ∫¶„ÇÇÁ§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÂêÑÁ´†„ÅÆÂÜÖÂÆπ„ÇíÂÆåÂÖ®„Å´ÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÄÅÊºîÁøí„Å´Âèñ„ÇäÁµÑ„ÇÄ„Åì„Å®„ÇíÂº∑„Åè„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÊú¨„ÅØÂàùÂøÉËÄÖ„Å´PureScript„Å∏„ÅÆÂ∞éÂÖ•„ÇíÊèê‰æõ„Åô„Çã„Åì„Å®„ÇíÁõÆÁöÑ„Å®„Åó„Å¶„Åä„Çä„ÄÅÂïèÈ°å„Å´„Å§„ÅÑ„Å¶„ÅÆ„ÅäÊ±∫„Åæ„Çä„ÅÆËß£Ê±∫Á≠ñ„ÅÆ‰∏ÄË¶ß„ÇíÊèê‰æõ„Åô„Çã„Çà„ÅÜ„Å™Á®ÆÈ°û„ÅÆÊú¨„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂàùÂøÉËÄÖ„Å´„Å®„Å£„Å¶„Åì„ÅÆÊú¨„ÇíË™≠„ÇÄ„ÅÆ„ÅØÊ•Ω„Åó„ÅÑÊåëÊà¶„Å´„Å™„Çã„ÅØ„Åö„Åß„Åô„Åó„ÄÅÊú¨Êõ∏„ÅÆÂÜÖÂÆπ„ÇíË™≠„ÅøÊºîÁøí„Å´ÊåëÊà¶„Åô„Çå„Å∞„Å†„ÅÑ„Åü„ÅÑ„ÅÆÂà©Áõä„ÇíÂæó„Çâ„Çå„Çã„Åß„Åó„Çá„ÅÜ„Åå„ÄÅ„Å™„Å´„Çà„ÇäÈáçË¶Å„Å™„ÅÆ„ÅØ„ÄÅ„ÅÇ„Å™„Åü„ÅåËá™ÂàÜËá™Ë∫´„ÅÆ„Ç≥„Éº„Éâ„ÇíÊõ∏„ÅÑ„Å¶„Åø„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<h2 id="Âõ∞„Å£„Åü„Å®„Åç„Å´„ÅØ"><a class="header" href="#Âõ∞„Å£„Åü„Å®„Åç„Å´„ÅØ">Âõ∞„Å£„Åü„Å®„Åç„Å´„ÅØ</a></h2>
<p>„ÇÇ„Åó„Å©„Åì„Åã„Åß„Å§„Åæ„Åö„ÅÑ„Åü„Å®„Åç„Å´„ÅØ„ÄÅPureScript„ÇíÂ≠¶„Åπ„Çã„Ç™„É≥„É©„Ç§„É≥„ÅßÂà©Áî®ÂèØËÉΩ„Å™Ë≥áÊñô„Åå„Åü„Åè„Åï„Çì„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li><a href="https://discord.gg/vKn9up84bp">PureScript„ÅÆDiscord„Çµ„Éº„Éê</a>„ÅØÊä±„Åà„Å¶„ÅÑ„Çã
ÂïèÈ°å„Å´„Å§„ÅÑ„Å¶„ÉÅ„É£„ÉÉ„Éà„Åô„Çã„ÅÆ„Å´ËâØ„ÅÑÂ†¥ÊâÄ„Åß„Åô„ÄÇ„Çµ„Éº„Éê„ÅØPureScript„Å´„Å§„ÅÑ„Å¶„ÅÆ
„ÉÅ„É£„ÉÉ„ÉàÂ∞ÇÁî®„Åß„Åô„ÄÇ</li>
<li><a href="https://discourse.purescript.org/">Purescript„ÅÆDiscourse„Éï„Ç©„Éº„É©„É†</a>„ÇÇ
„Çà„Åè„ÅÇ„ÇãÂïèÈ°å„Å∏„ÅÆËß£Ê±∫Á≠ñ„ÇíÊé¢„Åô„ÅÆ„Å´ËâØ„ÅÑÂ†¥ÊâÄ„Åß„Åô„ÄÇ„É°„ÉÉ„Çª„Éº„Ç∏Â±•Ê≠¥„ÅåÁ¥Ñ2ÈÄ±Èñì
„Åó„Åã‰øù„Åü„Å™„ÅÑSlack„Å®„ÅØÈÅï„ÅÑ„ÄÅ„Åì„Åì„ÅßË≥™Âïè„Åó„ÅüÂÜÖÂÆπ„ÅØÂ∞ÜÊù•„ÅÆË™≠ËÄÖ„ÅÆÂä©„Åë„Å®„Åó„Å¶
‰Ωø„Åà„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</li>
<li><a href="https://github.com/jordanmartinez/purescript-jordans-reference">PureScript: Jordan's
Reference</a>
„ÅØÂà•„ÅÆ„Åã„Å™„ÇäÊ∑±„ÅèË∏è„ÅøËæº„Çì„Å†Â≠¶ÁøíË≥áÊñô„Åß„Åô„ÄÇ„Åì„ÅÆÊú¨„ÅÆ‰∏≠„ÅÆ„ÅÇ„ÇãÊ¶ÇÂøµ„ÅåÁêÜËß£„Åó„Å´
„Åè„Åã„Å£„Åü„Çâ„ÄÅ„Åù„Å°„Çâ„ÅÆÂèÇËÄÉÊõ∏„ÅÆÂØæÂøú„Åô„ÇãÁØÄ„ÇíË™≠„ÇÄ„Å®„Çà„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ</li>
<li><a href="https://pursuit.purescript.org">Pursuit</a>„ÅØPureScript„ÅÆÂûã„Å®Èñ¢Êï∞„ÇíÊ§úÁ¥¢
„Åß„Åç„Çã„Éá„Éº„Çø„Éô„Éº„Çπ„Åß„Åô„ÄÇPursuit„ÅÆ„Éò„É´„Éó„Éö„Éº„Ç∏„ÇíË™≠„ÇÄ„Å®<a href="https://pursuit.purescript.org/help/users">„Å©„ÅÆ„Çà„ÅÜ„Å™Á®ÆÈ°û„ÅÆ
Ê§úÁ¥¢„Åå„Åß„Åç„Çã„ÅÆ„Åã„Åå„Çè„Åã„Çä„Åæ
„Åô</a>„ÄÇ</li>
<li>ÈùûÂÖ¨Âºè„ÅÆ<a href="https://github.com/JordanMartinez/purescript-cookbook">PureScript
Cookbook</a>„ÅØ„ÄåX
„Åô„Çã„Å´„ÅØ„Å©„ÅÜ„Åô„Çã„ÅÆÔºü„Äç„Å®„ÅÑ„Å£„ÅüÈ°û„ÅÆË≥™Âïè„Å´„Ç≥„Éº„Éâ„ÇíÊ∑∑„Åò„Åà„Å¶Á≠î„Åà„ÇíÊèê‰æõ„Åó„Åæ
„Åô„ÄÇ</li>
<li><a href="https://github.com/purescript/documentation">PureScript„Éâ„Ç≠„É•„É°„É≥„Éà„É™„Éù„Ç∏„Éà
„É™</a>„Å´„ÅØ„ÄÅPureScript„ÅÆÈñãÁô∫
ËÄÖ„ÇÑÂà©Áî®ËÄÖ„ÅåÊõ∏„ÅÑ„ÅüÂπÖÂ∫É„ÅÑË©±È°å„ÅÆË®ò‰∫ã„Å®‰æã„ÅåÈõÜ„Åæ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><a href="https://www.purescript.org">PureScript„ÅÆWeb„Çµ„Ç§„Éà</a>„Å´„ÅØ„ÄÅ„Ç≥„Éº„Éâ‰æã„ÄÅÊò†
ÂÉè„ÄÅ‰ªñ„ÅÆÂàùÂøÉËÄÖÂêë„ÅëË≥áÊñô„ÇíÂê´„ÇÄ„ÅÑ„Åè„Å§„Åã„ÅÆÂ≠¶ÁøíË≥áÊñô„Å∏„ÅÆ„É™„É≥„ÇØ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</li>
<li><a href="https://try.purescript.org">Try PureScript!</a>„ÅØÂà©Áî®ËÄÖ„ÅåWeb„Éñ„É©„Ç¶„Ç∂„Åß
PureScript„ÅÆ„Ç≥„Éº„Éâ„Çí„Ç≥„É≥„Éë„Ç§„É´„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÇãWeb„Çµ„Ç§„Éà„Åß„Åô„ÄÇ„ÅÑ„Åè„Å§„Åã
„ÅÆÁ∞°Âçò„Å™„Ç≥„Éº„Éâ„ÅÆ‰æã„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</li>
</ul>
<p>„ÇÇ„Åó‰æã„ÇíË™≠„Çì„ÅßÂ≠¶„Å∂Êñπ„ÅåÂ•Ω„Åç„Åß„Åó„Åü„Çâ„ÄÅGitHub„ÅÆ <code>purescript</code>ÁµÑÁπî„ÄÅ
<code>purescript-node</code>ÁµÑÁπî„Åä„Çà„Å≥ <code>purescript-contrib</code>ÁµÑÁπî„Å´„ÅØPureScript„Ç≥„Éº
„Éâ„ÅÆ‰æã„Åå„Åü„Åè„Åï„Çì„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="ËëóËÄÖ„Å´„Å§„ÅÑ„Å¶"><a class="header" href="#ËëóËÄÖ„Å´„Å§„ÅÑ„Å¶">ËëóËÄÖ„Å´„Å§„ÅÑ„Å¶</a></h2>
<p>ÁßÅ„ÅØPureScript„Ç≥„É≥„Éë„Ç§„É©„ÅÆÊúÄÂàù„ÅÆÈñãÁô∫ËÄÖ„Åß„Åô„ÄÇÁßÅ„ÅØ„Ç´„É™„Éï„Ç©„É´„Éã„Ç¢Â∑û„É≠„Çµ„É≥„Çº„É´„Çπ„ÇíÊã†ÁÇπ„Å´„Åó„Å¶„Åä„Çä„ÄÅ8„Éì„ÉÉ„Éà„Éë„Éº„ÇΩ„Éä„É´„Ç≥„É≥„Éî„É•„Éº„Çø„ÄÅAmstrad
CPC‰∏ä„ÅÆBASIC„Åß„Åæ„Å†Âπº„ÅÑÊôÇ„Å´„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÇíÂßã„ÇÅ„Åæ„Åó„Åü„ÄÇ
„Åù„Çå‰ª•Êù•„ÄÅÁßÅ„ÅØ„ÅÑ„Åè„Å§„ÇÇ„ÅÆ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™ûÔºàJava„ÇÑScala„ÄÅC#„ÄÅF#„ÄÅHaskell„ÄÅ„Åù„Åó„Å¶PureScriptÔºâ„ÅßÊ•≠Âãô„Å´Êê∫„Çè„Å£„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</p>
<p>„Éó„É≠„Å®„Åó„Å¶„ÅÆÁµåÊ≠¥„ÅåÂßã„Åæ„Å£„Å¶Èñì„ÇÇ„Å™„Åè„ÄÅÁßÅ„ÅØÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Å®Êï∞Â≠¶„ÅÆÈñ¢‰øÇ„ÇíÁêÜËß£„Åô„Çã„Çà„ÅÜ„Å´„Å™„Çä„ÄÅ
„Åù„Åó„Å¶„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™ûHaskell„Çí‰Ωø„Å£„Å¶Èñ¢Êï∞Âûã„ÅÆÊ¶ÇÂøµ„ÅÆÂ≠¶Áøí„ÇíÊ•Ω„Åó„Åø„Åæ„Åó„Åü„ÄÇ</p>
<p>JavaScript„Åß„ÅÆÁµåÈ®ì„Çí„ÇÇ„Å®„Å´„ÄÅÁßÅ„ÅØPureScript„Ç≥„É≥„Éë„Ç§„É©„ÅÆÈñãÁô∫„ÇíÂßã„ÇÅ„Çã„Åì„Å®„Å´„Åó„Åæ„Åó„Åü„ÄÇ
Ê∞ó„Åå‰ªò„Åè„Å®Haskell„ÅÆ„Çà„ÅÜ„Å™Ë®ÄË™û„Åã„ÇâÂèñ„Çä‰∏ä„Åí„ÅüÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÊâãÊ≥ï„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅ„Åù„Çå„ÇíÂøúÁî®„Åô„Çã„Åü„ÇÅ„ÅÆ„ÇÇ„Å£„Å®ÁêÜ„Å´„Åã„Å™„Å£„ÅüÁí∞Â¢É„ÇíÊ±Ç„ÇÅ„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ
„Åù„ÅÆ„Å®„ÅçÊ§úË®é„Åó„ÅüÊ°à„ÅÆ„Å™„Åã„Å´„ÅØ„ÄÅHaskell„Åã„Çâ„Åù„ÅÆÊÑèÂë≥Ë´ñ„ÇíÁ∂≠ÊåÅ„Åó„Å™„Åå„ÇâJavaScript„Å∏„Å®„Ç≥„É≥„Éë„Ç§„É´„Åô„Çã„ÅÑ„Çç„ÅÑ„Çç„Å™Ë©¶„ÅøÔºàFay„ÄÅHaste„ÄÅGHCJSÔºâ„ÇÇ„ÅÇ„Çä„Åæ„Åó„Åü„Åå„ÄÅÁßÅ„ÅåËààÂë≥„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åü„ÅÆ„ÅØ„ÄÅ„Åì„ÅÆÂïèÈ°å„Å∏„ÅÆÂà•„ÅÆÂàá„ÇäÂè£„Åã„Çâ„ÅÆ„Ç¢„Éó„É≠„Éº„ÉÅ„ÄÅ„Åô„Å™„Çè„Å°Haskell„ÅÆ„Çà„ÅÜ„Å™Ë®ÄË™û„ÅÆÊßãÊñá„Å®Âûã„Ç∑„Çπ„ÉÜ„É†„ÇíÊ•Ω„Åó„Åø„Å™„Åå„ÇâJavaScript„ÅÆÊÑèÂë≥Ë´ñ„ÇÇÁ∂≠ÊåÅ„Åô„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åå„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å´„Åô„Çå„Å∞ÂèØËÉΩ„Å´„Å™„Çã„ÅÆ„Åã„Åß„Åó„Åü„ÄÇ</p>
<p>ÁßÅ„ÅØ<a href="http://blog.functorial.com">„Éñ„É≠„Ç∞</a>„ÇíÈÅãÂñ∂„Åó„Å¶„Åä„Çä„ÄÅ<a href="http://twitter.com/paf31">Twitter„ÅßÈÄ£Áµ°„Çí„Å®„Çã</a>„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="Ë¨ùËæû"><a class="header" href="#Ë¨ùËæû">Ë¨ùËæû</a></h2>
<p>ÁèæÂú®„ÅÆÁä∂ÊÖã„Å´Âà∞ÈÅî„Åô„Çã„Åæ„ÅßPureScript„ÇíÊâã‰ºù„Å£„Å¶„Åè„Çå„ÅüÂ§ö„Åè„ÅÆÂçîÂäõËÄÖ„Å´ÊÑüË¨ù„Åó„Åü„ÅÑ„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ„Ç≥„É≥„Éë„Ç§„É©„ÇÑ„ÉÑ„Éº„É´„ÄÅ„É©„Ç§„Éñ„É©„É™„ÄÅ„Éâ„Ç≠„É•„É°„É≥„Éà„ÄÅ„ÉÜ„Çπ„Éà„Åß„ÅÆÁµÑÁπîÁöÑ„ÅßÂºõ„Åæ„Å¨Âä™Âäõ„Åå„Å™„Åã„Å£„Åü„Çâ„ÄÅ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅØÈñìÈÅï„ÅÑ„Å™„ÅèÂ§±Êïó„Åó„Å¶„ÅÑ„Åü„Åì„Å®„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åì„ÅÆÊú¨„ÅÆË°®Á¥ô„Å´Ë°®Á§∫„Åï„Çå„ÅüPureScript„ÅÆ„É≠„Ç¥„ÅØGareth Hughes„Å´„Çà„Å£„Å¶‰ΩúÊàê„Åï„Çå„Åü„ÇÇ„ÅÆ„Åß„ÄÅ<a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons
Attribution 4.0
license</a>„ÅÆÊù°‰ª∂„ÅÆ‰∏ã„ÅßÂÜçÂà©Áî®„Åï„Åõ„Å¶È†Ç„ÅÑ„Å¶„ÅÑ„Åæ„Åô „ÄÇ</p>
<p>ÊúÄÂæå„Å´„ÄÅ„Åì„ÅÆÊú¨„ÅÆÂÜÖÂÆπ„Å´Èñ¢„Åô„ÇãÂèçÂøú„ÇÑË®ÇÊ≠£„Çí„Åè„Å†„Åï„Å£„Åü„Åô„Åπ„Å¶„ÅÆÊñπ„Å´„ÄÅÂøÉ„Çà„ÇäÊÑüË¨ù„Åó„Åü„ÅÑ„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="„ÅØ„Åò„ÇÅ„Çà„ÅÜ"><a class="header" href="#„ÅØ„Åò„ÇÅ„Çà„ÅÜ">„ÅØ„Åò„ÇÅ„Çà„ÅÜ</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØÂÆüÈöõ„ÅÆPureScript„ÅÆÈñãÁô∫Áí∞Â¢É„ÇíÁ´ã„Å°‰∏ä„Åí„ÄÅ
„ÅÑ„Åè„Å§„Åã„ÅÆÊºîÁøí„ÇíËß£„Åç„ÄÅ
„Åì„ÅÆÊú¨„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Çã„ÉÜ„Çπ„Éà„Çí‰Ωø„Å£„Å¶Á≠î„Åà„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åô„ÄÇ
„ÇÇ„ÅóÂ≠¶Áøí„ÅÆ‰ªïÊñπ„ÅåÂêà„Å£„Å¶„ÅÑ„Çå„Å∞
<a href="https://www.youtube.com/watch?v=GPjPwb6d-70">„Åì„ÅÆÁ´†„ÇíÈÄö„Åó„Å¶ÈÄ≤„ÇÅ„Çã„Éì„Éá„Ç™</a>
„ÅåÂΩπ„Å´Á´ã„Å§„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="Áí∞Â¢ÉÊßãÁØâ"><a class="header" href="#Áí∞Â¢ÉÊßãÁØâ">Áí∞Â¢ÉÊßãÁØâ</a></h2>
<p>ÊúÄÂàù„Å´„Éâ„Ç≠„É•„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„É™„Éù„Ç∏„Éà„É™„Å´„ÅÇ„Çã„Åì„ÅÆ
<a href="https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md">Getting Started
Guide</a>
„ÇíÈÄö„Åó„ÅßÈÄ≤„ÇÅ„ÄÅÁí∞Â¢É„ÅÆÊßãÁØâ„Å®Ë®ÄË™û„ÅÆÂü∫Á§é„ÇíÂ≠¶„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
<a href="http://projecteuler.net/problem=1">Project Euler</a>
„Å∏„ÅÆËß£Á≠î‰æã„Å´„ÅÇ„Çã„Ç≥„Éº„Éâ„Åå„Çè„Åã„Çä„Å´„Åè„Åã„Å£„Åü„ÇäË¶ãÊÖ£„Çå„Å™„ÅÑÊßãÊñá„ÇíÂê´„Çì„Åß„ÅÑ„Åü„Å®„Åó„Å¶„ÇÇÂøÉÈÖçË¶Å„Çä„Åæ„Åõ„Çì„ÄÇ
Êù•„Åü„ÇãÁ´†„Åß„Åì„ÅÆÂÖ®„Å¶„ÅÆÂÜÖÂÆπ„Çí„Å®„Å¶„ÇÇË©≥Á¥∞„Å´Êäº„Åï„Åà„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí„ÇíËß£„Åè"><a class="header" href="#ÊºîÁøí„ÇíËß£„Åè">ÊºîÁøí„ÇíËß£„Åè</a></h2>
<p>„Åì„Åì„Åæ„Åß„ÅßÂøÖË¶Å„Å™ÈñãÁô∫„ÉÑ„Éº„É´„Çí„Ç§„É≥„Çπ„Éà„Éº„É´„Åß„Åç„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„Åì„ÅÆÊú¨„ÅÆ„É™„Éù„Ç∏„Éà„É™„Çí„ÇØ„É≠„Éº„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-sh">git clone https://github.com/purescript-contrib/purescript-book.git
</code></pre>
<p>Êú¨„ÅÆ„É™„Éù„Ç∏„Éà„É™„Å´„ÅØPureScript„ÅÆ„Ç≥„Éº„Éâ‰æã„Å®„Åù„Çå„Åû„Çå„ÅÆÁ´†„Å´‰ªòÂ±û„Åô„ÇãÊºîÁøí„ÅÆ„Åü„ÇÅ„ÅÆÂçò‰Ωì„ÉÜ„Çπ„Éà„ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇ
ÊºîÁøí„ÅÆËß£Ê≥ï„ÇíÁôΩÁ¥ô„Å´Êàª„Åô„Åü„ÇÅ„Å´ÂøÖË¶Å„Å™ÂàùÊúüË®≠ÂÆö„Åå„ÅÇ„Çä„ÄÅ„Åì„ÅÜ„Åô„Çã„Åì„Å®„ÅßËß£„ÅèÊ∫ñÂÇô„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>resetSolutions.sh</code>„Çπ„ÇØ„É™„Éó„Éà„Çí‰Ωø„Å£„Å¶„Åì„ÅÆÂ∑•Á®ã„ÇíÁ∞°Âçò„Å´„Åß„Åç„Åæ„Åô„ÄÇ
„Åù„ÅÆÈñì„Å´<code>removeAnchors.sh</code>„Çπ„ÇØ„É™„Éó„Éà„ÅßÂÖ®„Å¶„ÅÆ„Ç¢„É≥„Ç´„Éº„Ç≥„É°„É≥„Éà„ÇíÂèñ„ÇäÈô§„ÅÑ„Å¶„Åä„Åè„ÅÆ„ÇÇ„Çà„ÅÑ„Åß„Åó„Çá„ÅÜÔºà„Åì„Çå„Çâ„ÅÆ„Ç¢„É≥„Ç´„Éº„ÅØ„Ç≥„Éº„Éâ„Çπ„Éã„Éö„ÉÉ„Éà„ÇíÊú¨„ÅÆÂ§âÊèõÂæå„ÅÆMarkdown„Å´„Ç≥„Éî„Éº„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Å¶„Åä„Çä„ÄÅ
Ëá™ÂàÜ„ÅÆ„É≠„Éº„Ç´„É´„É™„Éù„Ç∏„Éà„É™„Åß„ÅØ„Åì„ÅÆ„Ç¢„É≥„Ç´„Éº„ÅåÊï£„Çâ„Åã„Å£„Å¶„ÅÑ„Å™„ÅÑ„Åª„ÅÜ„Åå„Çà„ÅÑ„Åß„Åó„Çá„ÅÜÔºâ„ÄÇ</p>
<pre><code class="language-sh">cd purescript-book
./scripts/resetSolutions.sh
./scripts/removeAnchors.sh
git add .
git commit --all --message &quot;Exercises ready to be solved&quot;
</code></pre>
<p>„Åù„Çå„Åß„ÅØ„Åì„ÅÆÁ´†„ÅÆ„ÉÜ„Çπ„Éà„ÇíËµ∞„Çâ„Åõ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-sh">cd exercises/chapter2
spago test
</code></pre>
<p>‰ª•‰∏ã„ÅÆÊàêÂäü„Åó„Åü„ÉÜ„Çπ„ÉàÂá∫Âäõ„ÅåÂá∫„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-sh">‚Üí Suite: Euler - Sum of Multiples
  ‚úì Passed: below 10
  ‚úì Passed: below 1000

All 2 tests passed! üéâ
</code></pre>
<p>„Å™„Åä„ÄÅ<code>answer</code>ÁØÄÔºà<code>src/Euler.purs</code>„Å´„ÅÇ„Çä„Åæ„ÅôÔºâ„ÅØ„ÄÅ
„ÅÇ„Çâ„ÇÜ„ÇãÊï¥Êï∞‰ª•‰∏ã„ÅÆ3„Å®5„ÅÆÂÄçÊï∞„ÇíË¶ã‰ªò„Åë„Çã„Çà„ÅÜ„Å´Â§âÊõ¥„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ<code>answer</code>Èñ¢Êï∞„ÅÆ„Åü„ÇÅ„ÅÆ„ÉÜ„Çπ„Éà„Çπ„Éº„ÉàÔºà<code>test/Main.purs</code>„Å´„ÅÇ„Çä„Åæ„ÅôÔºâ„ÅØ
Getting Started Guide„ÅÆÂÜíÈ†≠„Å´„ÅÇ„Çã„ÉÜ„Çπ„Éà„Çà„Çä„ÇÇÁ∂≤ÁæÖÁöÑ„Åß„Åô„ÄÇ
„ÅØ„Åò„ÇÅ„ÅÆÁ´†„ÇíË™≠„Çì„Åß„ÅÑ„ÇãÈñì„ÅØ„Åì„ÅÆ„ÉÜ„Çπ„Éà„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„ÅÆ‰ªïÁµÑ„Åø„ÇíÁêÜËß£„Åó„Çà„ÅÜ„Å®ÊÄù„ÅÑË©∞„ÇÅ„Å™„Åè„Å¶Â§ß‰∏àÂ§´„Åß„Åô„ÄÇ</p>
<p>Êú¨„ÅÆÊÆã„Çä„ÅÆÈÉ®ÂàÜ„Å´„ÅØÂ§ö„Åè„ÅÆÊºîÁøí„ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇ
<code>Test.MySolutions</code>„É¢„Ç∏„É•„Éº„É´ (<code>test/MySolutions.purs</code>) „Å´Ëá™ÂàÜ„ÅÆËß£Ê≥ï„ÇíÊõ∏„Åë„Å∞„ÄÅ
Êèê‰æõ„Åï„Çå„Å¶„ÅÑ„Çã„ÉÜ„Çπ„Éà„Çπ„Éº„Éà„Çí‰Ωø„Å£„Å¶Á¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„ÉÜ„Çπ„ÉàÈßÜÂãïÈñãÁô∫„ÅÆ„Çπ„Çø„Ç§„É´„Åß„Åì„ÅÆÊ¨°„ÅÆÊºîÁøí„Çí‰∏ÄÁ∑í„Å´ÈÄ≤„ÇÅ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="ÊºîÁøí"><a class="header" href="#ÊºîÁøí">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâÁõ¥Ëßí‰∏âËßíÂΩ¢„ÅÆÂØæËßíÁ∑öÔºà„ÅÇ„Çã„ÅÑ„ÅØÊñúËæ∫Ôºâ„ÅÆÈï∑„Åï„Çí
‰ªñ„ÅÆ2„Å§„ÅÆËæ∫„ÅÆÈï∑„Åï„Çí‰Ωø„Å£„Å¶Ë®àÁÆó„Åô„Çã<code>diagonal</code>Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="Ëß£Ê≥ï"><a class="header" href="#Ëß£Ê≥ï">Ëß£Ê≥ï</a></h2>
<p>„Åì„ÅÆÊºîÁøí„ÅÆ„ÉÜ„Çπ„Éà„ÇíÊúâÂäπ„Å´„Åô„Çã„Å®„Åì„Çç„Åã„ÇâÂßã„ÇÅ„Åæ„Åô„ÄÇ
‰ª•‰∏ã„Å´Á§∫„Åô„Çà„ÅÜ„Å´„Éñ„É≠„ÉÉ„ÇØ„Ç≥„É°„É≥„Éà„ÅÆÈñãÂßã„ÇíÊï∞Ë°å‰∏ã„Å´‰∏ã„Åí„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Éñ„É≠„ÉÉ„ÇØ„Ç≥„É°„É≥„Éà„ÅØ<code>{-</code>„Åã„ÇâÂßã„Åæ„Çä<code>-}</code>„ÅßÁµÇ„Çè„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">    suite &quot;diagonal&quot; do
      test &quot;3 4 5&quot; do
        Assert.equal 5.0 (diagonal 3.0 4.0)
      test &quot;5 12 13&quot; do
        Assert.equal 13.0 (diagonal 5.0 12.0)
    {-  Move this block comment starting point to enable more tests
</code></pre>
<p>„Åì„Åì„Åß„ÉÜ„Çπ„Éà„ÇíËµ∞„Çâ„Åõ„Çà„ÅÜ„Å®„Åô„Çã„Å®„ÄÅ„Ç≥„É≥„Éë„Ç§„É´„Ç®„É©„Éº„Å´Áõ¥Èù¢„Åó„Åæ„Åô„ÄÇ
„Å™„Åú„Å™„Çâ<code>diagonal</code>Èñ¢Êï∞„Çí„Åæ„Å†ÂÆüË£Ö„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åã„Çâ„Åß„Åô„ÄÇ</p>
<pre><code class="language-sh">$ spago test

Error found:
in module Test.Main
at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)

  Unknown value diagonal
</code></pre>
<p>„Åæ„Åö„ÅØ„Åì„ÅÆÈñ¢Êï∞„ÅåÊ¨†Èô•„ÅÆ„ÅÇ„Çã„Éê„Éº„Ç∏„Éß„É≥„Åß„ÅÇ„Çã„Å®„Åç„Å´‰Ωï„ÅåËµ∑„Åì„Çã„ÅÆ„ÅãË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„Çí<code>test/MySolutions.purs</code>„Å´ËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-hs">import Data.Number (sqrt)

diagonal w h = sqrt (w * w + h)
</code></pre>
<p>„Åù„Åó„Å¶<code>spago test</code>„ÇíËµ∞„Çâ„Åõ„Å¶Á¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-hs">‚Üí Suite: diagonal
  ‚ò† Failed: 3 4 5 because expected 5.0, got 3.605551275463989
  ‚ò† Failed: 5 12 13 because expected 13.0, got 6.082762530298219

2 tests failed:
</code></pre>
<p>„ÅÇ„Éº„ÅÇ„ÄÅÂÖ®ÁÑ∂Ê≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ
„Éî„Çø„Ç¥„É©„Çπ„ÅÆÂÆöÁêÜ„ÇíÊ≠£„Åó„ÅÑÈÅ©Áî®„Åô„Çã„Åì„Å®„Åß„Åì„Çå„Çí‰øÆÊ≠£„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
Èñ¢Êï∞„Çí‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Â§â„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">diagonal w h = sqrt (w * w + h * h)
</code></pre>
<p>„Åì„Åì„Åß„ÇÇ„ÅÜ‰∏ÄÂ∫¶<code>spago test</code>„Å®„Åó„Å¶„Åø„Çã„Å®ÂÖ®„Å¶„ÅÆ„ÉÜ„Çπ„Éà„ÅåÈÄö„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">‚Üí Suite: Euler - Sum of Multiples
  ‚úì Passed: below 10
  ‚úì Passed: below 1000
‚Üí Suite: diagonal
  ‚úì Passed: 3 4 5
  ‚úì Passed: 5 12 13

All 4 tests passed! üéâ
</code></pre>
<p>ÊàêÂäü„Åß„ÅôÔºÅ
„Åì„Çå„ÅßÊ¨°„ÅÆÊºîÁøí„ÇíËá™Âäõ„ÅßËß£„Åè„Åü„ÇÅ„ÅÆÊ∫ñÂÇô„Åå„Åß„Åç„Åæ„Åó„Åü„ÄÇ</p>
<h2 id="ÊºîÁøí-1"><a class="header" href="#ÊºîÁøí-1">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâÊåáÂÆö„Åï„Çå„ÅüÂçäÂæÑ„ÅÆÂÜÜ„ÅÆÈù¢Á©ç„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞<code>circleArea</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>Numbers</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã <code>pi</code>ÂÆöÊï∞„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö <code>import Data.Number</code>Êñá„Çí‰øÆÊ≠£„Åó„Å¶„ÄÅ <code>pi</code>„Çí„Ç§„É≥„Éù„Éº„Éà„Åô„Çã„Åì„Å®„ÇíÂøò„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>Int</code>„ÇíÂèñ„Å£„Å¶<code>100</code>„ÅßÂâ≤„Å£„Åü„ÅÇ„Å®„ÅÆ‰Ωô„Çä„ÇíËøî„ÅôÈñ¢Êï∞<code>leftoverCents</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>rem</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<a href="https://pursuit.purescript.org/">Pursuit</a>„Åß„Åì„ÅÆÈñ¢Êï∞„ÇíÊ§úÁ¥¢„Åó„Å¶„ÄÅ
‰ΩøÁî®Ê≥ï„Å®„Å©„ÅÆ„É¢„Ç∏„É•„Éº„É´„Åã„Çâ„Ç§„É≥„Éù„Éº„Éà„Åó„Å¶„Åè„Çã„ÅãË™ø„Åπ„Åæ„Åó„Çá„ÅÜ„ÄÇ
<strong>Ë£úË∂≥</strong>ÔºöËá™ÂãïË£úÂÆå„ÅÆÊèêÊ°à„ÇíÂèó„Åë‰ªò„Åë„Çå„Å∞„ÄÅIDE„Åß„Åì„ÅÆÈñ¢Êï∞„ÅÆËá™ÂãïÁöÑ„Å™„Ç§„É≥„Éù„Éº„Éà„Åå„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ"><a class="header" href="#„Åæ„Å®„ÇÅ">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØPureScript„Ç≥„É≥„Éë„Ç§„É©„Å®Spago„ÉÑ„Éº„É´„Çí„Ç§„É≥„Çπ„Éà„Éº„É´„Åó„Åæ„Åó„Åü„ÄÇ
ÊºîÁøí„ÅÆËß£Á≠î„ÅÆÊõ∏„ÅçÊñπ„Å®Ê≠£„Åó„Åï„ÅÆÁ¢∫Ë™çÊñπÊ≥ï„ÇÇÂ≠¶„Å≥„Åæ„Åó„Åü„ÄÇ</p>
<p>„Åì„ÅÆÂÖà„ÅÆÁ´†„Å´„ÅØ„Çà„ÇäÂ§ö„Åè„ÅÆÊºîÁøí„Åå„ÅÇ„Çä„ÄÅ„Åù„Çå„Çâ„Å´Âèñ„ÇäÁµÑ„ÇÄ„ÅÜ„Å°„Å´Â≠¶Áøí„ÅÆÂä©„Åë„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
ÊºîÁøí„ÅÆ„Å©„Åì„Åã„Åß„ÅäÊâã„ÅÇ„Åí„Å´„Å™„Å£„Åü„Çâ„ÄÅ
„Åì„ÅÆÊú¨„ÅÆ<a href="chapter1.ja.html#getting-help">Âõ∞„Å£„Åü„Å®„Åç„ÅØ</a>„ÅÆÁØÄ„Å´Êåô„Åí„Çâ„Çå„Å¶„ÅÑ„Çã
„Ç≥„Éü„É•„Éã„ÉÜ„Ç£„ÅÆË≥áÊñô„ÅÆ„Å©„Çå„Åß„ÇÇË¶ã„Å¶„Åø„Çã„Åã„ÄÅ
„Åì„ÅÆ<a href="https://github.com/purescript-contrib/purescript-book/issues">Êú¨„ÅÆ„É™„Éù„Ç∏„Éà„É™</a>„Å´„Ç§„Ç∑„É•„Éº„ÇíÂ†±Âëä„Åô„Çã„Åì„Å®„Åï„Åà„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÜ„Åó„ÅüÊºîÁøí„ÅÆÊï∑Â±Ö„Çí‰∏ã„Åí„Çã„Åì„Å®„Å´Áπã„Åå„ÇãË™≠ËÄÖ„ÅÆ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„Åå„ÄÅÊú¨„ÅÆÂêë‰∏ä„ÅÆÂä©„Åë„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Á´†„ÅÆÂÖ®„Å¶„ÅÆÊºîÁøí„ÇíËß£„ÅÑ„Åü„Çâ„ÄÅ<code>no-peeking/Solutions.purs</code>„Å´„ÅÇ„Çã„ÇÇ„ÅÆ„Å®Ëß£Á≠î„Å®„ÇíÊØî„Åπ„Çâ„Çå„Åæ„Åô„ÄÇ
„Åü„Å†„Åó„Ç´„É≥„Éã„É≥„Ç∞„Åó„Å¶„ÅØ„Å†„ÇÅ„Åß„ÄÅ„Åì„Çå„Çâ„ÅÆÊºîÁøí„ÇíË™†ÂÆü„Å´Ëá™Âäõ„ÅßËß£„ÅèÂä¥Âäõ„ÇíÊâï„Çè„Å™„ÅÑ„Åì„Å®„Åå„Å™„ÅÑ„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åù„Åó„Å¶„Åü„Å®„ÅàË°å„ÅçË©∞„Åæ„Å£„Åü„Å´„Åó„Å¶„ÇÇ„ÄÅ„Åæ„Åö„ÅØ„Ç≥„Éü„É•„Éã„ÉÜ„Ç£„É°„É≥„Éê„Éº„Å´Â∞ã„Å≠„Å¶„Åø„Çã„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÊºîÁøí„ÅÆ„Éç„Çø„Éê„É¨„Çí„Åô„Çã„Çà„Çä„ÇÇ„ÄÅÂ∞è„Åï„Å™„Éí„É≥„Éà„Çí„ÅÇ„Åí„Åü„ÅÑ„Åã„Çâ„Åß„Åô„ÄÇ
„ÇÇ„Å£„Å®„Ç®„É¨„Ç¨„É≥„Éà„Å™Ëß£Ê≥ïÔºà„Å®„ÅØ„ÅÑ„ÅàÊú¨„ÅÆÂÜÖÂÆπ„ÅßÊäº„Åï„Åà„Çâ„Çå„Å¶„ÅÑ„ÇãÁü•Ë≠ò„ÅÆ„Åø„ÇíÂøÖË¶Å„Å®„Åô„Çã„ÇÇ„ÅÆÔºâ„ÇíË¶ã„Å§„Åë„Åü„Å®„Åç„ÅØPR„ÇíÈÄÅ„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„É™„Éù„Ç∏„Éà„É™„ÅØÁ∂ôÁ∂ö„Åó„Å¶ÊîπË®Ç„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÊñ∞„Åó„ÅÑÁ´†„ÇíÂßã„ÇÅ„ÇãÂâç„Å´Êõ¥Êñ∞„ÇíÁ¢∫Ë™ç„Åô„Çã„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Èñ¢Êï∞„Å®„É¨„Ç≥„Éº„Éâ"><a class="header" href="#Èñ¢Êï∞„Å®„É¨„Ç≥„Éº„Éâ">Èñ¢Êï∞„Å®„É¨„Ç≥„Éº„Éâ</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-1"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-1">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅÈñ¢Êï∞„Åä„Çà„Å≥„É¨„Ç≥„Éº„Éâ„Å®„ÅÑ„ÅÜPureScript„Éó„É≠„Ç∞„É©„É†„ÅÆ2„Å§„ÅÆÊßãÊàêË¶ÅÁ¥†„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„ÄÇ
„Åï„Çâ„Å´„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å´PureScript„Éó„É≠„Ç∞„É©„É†„ÇíÊßãÈÄ†Âåñ„Åô„Çã„ÅÆ„Åã„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å´Âûã„Çí„Éó„É≠„Ç∞„É©„É†ÈñãÁô∫„Å´ÂΩπÁ´ã„Å¶„Çã„Åã„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>ÈÄ£Áµ°ÂÖà„ÅÆ„É™„Çπ„Éà„ÇíÁÆ°ÁêÜ„Åô„ÇãÁ∞°Âçò‚Äã‚Äã„Å™‰ΩèÊâÄÈå≤„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Çí‰ΩúÊàê„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ„Åì„ÅÆ„Ç≥„Éº„Éâ‰æã„Å´„Çà„Çä„ÄÅPureScript„ÅÆÊßãÊñá„Åã„Çâ„ÅÑ„Åè„Å§„Åã„ÅÆÊñ∞„Åó„ÅÑÊ¶ÇÂøµ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅØÂØæË©±Âºè„É¢„Éº„Éâ„Åß„ÅÇ„ÇãPSCi„Çí‰Ωø„ÅÜ„Çà„ÅÜ„Å´„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ„Åì„ÅÆ„Ç≥„Éº„Éâ„ÇíÂúüÂè∞„Å´JavaScript„Åß„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÇíÊõ∏„Åè„Åì„Å®„ÇÇ„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
ÂÆüÈöõ„Å´Âæå„ÅÆÁ´†„Åß„ÄÅ„Éï„Ç©„Éº„É†„ÅÆÊ§úË®º„Å®‰øùÂ≠ò„Åä„Çà„Å≥Âæ©ÂÖÉ„ÅÆÊ©üËÉΩ„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ <code>src/Data/AddressBook.purs</code>„Å®„ÅÑ„ÅÜ„Éï„Ç°„Ç§„É´„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™„É¢„Ç∏„É•„Éº„É´ÂÆ£Ë®Ä„Å®„Ç§„É≥„Éù„Éº„Éà‰∏ÄË¶ß„Åã„ÇâÂßã„Åæ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">module Data.AddressBook where

import Prelude

import Control.Plus (empty)
import Data.List (List(..), filter, head)
import Data.Maybe (Maybe)
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅ„ÅÑ„Åè„Å§„Åã„ÅÆ„É¢„Ç∏„É•„Éº„É´„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>Control.Plus</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ<code>empty</code>ÂÄ§„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>Data.List</code>„É¢„Ç∏„É•„Éº„É´„ÅØ<code>lists</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÊèê‰æõ„Åï„Çå„Å¶„Åä„ÇäSpago„Çí‰Ωø„Å£„Å¶„Ç§„É≥„Çπ„Éà„Éº„É´„Åß„Åç„Åæ„Åô„ÄÇ
ÈÄ£Áµê„É™„Çπ„Éà„Çí‰Ωø„ÅÜ„Åü„ÇÅ„Å´ÂøÖË¶Å„Å™„ÅÑ„Åè„Å§„Åã„ÅÆÈñ¢Êï∞„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>Data.Maybe</code>„É¢„Ç∏„É•„Éº„É´„ÅØ„ÄÅ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆ„Éá„Éº„ÇøÂûã„Å®Èñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
</ul>
<p>Ë®≥ËÄÖÊ≥®Ôºö„ÉÄ„Éñ„É´„Éâ„ÉÉ„Éà (<code>..</code>) „Çí‰ΩøÁî®„Åô„Çã„Å®„ÄÅ
ÊåáÂÆö„Åï„Çå„ÅüÂûã„Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Éá„Éº„Çø„Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø„Çí„Ç§„É≥„Éù„Éº„Éà„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅÆ„Ç§„É≥„Éù„Éº„ÉàÂÜÖÂÆπ„ÅåÊã¨ÂºßÂÜÖ„ÅßÊòéÁ§∫ÁöÑ„Å´ÂàóÊåô„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊòéÁ§∫ÁöÑ„Å™ÂàóÊåô„ÅØ„Ç§„É≥„Éù„Éº„ÉàÂÜÖÂÆπ„ÅÆË°ùÁ™Å„ÇíÈÅø„Åë„Çã„ÅÆ„Å´ÂΩπ„Å´Á´ã„Å§„ÅÆ„Åß„ÄÅ‰∏ÄËà¨„Å´ËâØ„ÅÑÁøíÊÖ£„Åß„Åô„ÄÇ</p>
<p>„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„É™„Éù„Ç∏„Éà„É™„ÇíË§áË£Ω„Åó„Åü„Å®‰ªÆÂÆö„Åô„Çã„Å®„ÄÅ„Åì„ÅÆÁ´†„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅØÊ¨°„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅßSpago„Çí‰ΩøÁî®„Åó„Å¶ÊßãÁØâ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ cd chapter3
$ spago build
</code></pre>
<h2 id="ÂçòÁ¥î„Å™Âûã"><a class="header" href="#ÂçòÁ¥î„Å™Âûã">ÂçòÁ¥î„Å™Âûã</a></h2>
<p>JavaScript„ÅÆ„Éó„É™„Éü„ÉÜ„Ç£„ÉñÂûã„Å´ÂØæÂøú„Åô„ÇãÁµÑ„ÅøËæº„Åø„Éá„Éº„ÇøÂûã„Å®„Åó„Å¶„ÄÅPureScript„Åß„ÅØÊï∞ÂÄ§Âûã„Å®ÊñáÂ≠óÂàóÂûã„ÄÅÁúüÂÅΩÂûã„ÅÆ3„Å§„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅØ<code>Prim</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„Åä„Çä„ÄÅÂÖ®„Å¶„ÅÆ„É¢„Ç∏„É•„Éº„É´„Å´ÊöóÈªô„Å´„Ç§„É≥„Éù„Éº„Éà„Åï„Çå„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅØ„Åù„Çå„Åû„Çå <code>Number</code>„ÄÅ <code>String</code>„ÄÅ
<code>Boolean</code>„Å®Âëº„Å∞„Çå„Å¶„Åä„Çä„ÄÅPSCi„Åß<code>:type</code>„Ç≥„Éû„É≥„Éâ„Çí‰Ωø„ÅÜ„Å®Á∞°Âçò„Å™ÂÄ§„ÅÆÂûã„ÇíË°®Á§∫„Åï„Åõ„Å¶Á¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; :type 1.0
Number

&gt; :type &quot;test&quot;
String

&gt; :type true
Boolean
</code></pre>
<p>PureScript„Å´„ÅØ‰ªñ„Å´„ÇÇ„ÄÅÊï¥Êï∞„ÄÅÊñáÂ≠ó„ÄÅÈÖçÂàó„ÄÅ„É¨„Ç≥„Éº„Éâ„ÄÅÈñ¢Êï∞„Å®„ÅÑ„Å£„ÅüÁµÑ„ÅøËæº„ÅøÂûã„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Êï¥Êï∞„ÅØ„ÄÅÂ∞èÊï∞ÁÇπ‰ª•‰∏ã„ÇíÁúÅ„Åè„Åì„Å®„Å´„Çà„Å£„Å¶„ÄÅÂûã <code>Number</code>„ÅÆÊµÆÂãïÂ∞èÊï∞ÁÇπÊï∞„ÅÆÂÄ§„Å®Âå∫Âà•„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :type 1
Int
</code></pre>
<p>‰∫åÈáçÂºïÁî®Á¨¶„Çí‰ΩøÁî®„Åô„ÇãÊñáÂ≠óÂàó„É™„ÉÜ„É©„É´„Å®„ÅØÁï∞„Å™„Çä„ÄÅÊñáÂ≠ó„É™„ÉÜ„É©„É´„ÅØ‰∏ÄÈáçÂºïÁî®Á¨¶„ÅßÂõ≤„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :type 'a'
Char
</code></pre>
<p>ÈÖçÂàó„ÅØJavaScript„ÅÆÈÖçÂàó„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅJavaScript„ÅÆÈÖçÂàó„Å®„ÅØÁï∞„Å™„Çä„ÄÅPureScript„ÅÆÈÖçÂàó„ÅÆ„Åô„Åπ„Å¶„ÅÆË¶ÅÁ¥†„ÅØÂêå„ÅòÂûã„ÇíÊåÅ„Å§ÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :type [1, 2, 3]
Array Int

&gt; :type [true, false]
Array Boolean

&gt; :type [1, false]
Could not match type Int with type Boolean.
</code></pre>
<p>ÊúÄÂæå„ÅÆ‰æã„ÅßËµ∑„Åç„Å¶„ÅÑ„Çã„Ç®„É©„Éº„ÅØÂûãÊ§úË®ºÂô®„Å´„Çà„Å£„Å¶Â†±Âëä„Åï„Çå„Åü„ÇÇ„ÅÆ„Åß„ÄÅ
ÈÖçÂàó„ÅÆ2„Å§„ÅÆË¶ÅÁ¥†„ÅÆÂûã„Çí<strong>Âçò‰∏ÄÂåñ</strong>ÔºàUnification„ÄÅÁ≠â‰æ°„Å´„Åô„Çã„ÅÆÊÑèÔºâ„Åó„Çà„ÅÜ„Å®„Åó„Å¶Â§±Êïó„Åó„Åü„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„É¨„Ç≥„Éº„Éâ„ÅØJavaScript„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´ÂØæÂøú„Åó„Å¶„Åä„Çä„ÄÅ„É¨„Ç≥„Éº„Éâ„É™„ÉÜ„É©„É´„ÅØJavaScript„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„É™„ÉÜ„É©„É´„Å®Âêå„ÅòÊßãÊñá„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; author = { name: &quot;Phil&quot;, interests: [&quot;Functional Programming&quot;, &quot;JavaScript&quot;] }

&gt; :type author
{ name :: String
, interests :: Array String
}
</code></pre>
<p>„Åì„ÅÆÂûã„ÅåÁ§∫„Åó„Å¶„ÅÑ„Çã„ÅÆ„ÅØ„ÄÅÊåáÂÆö„Åï„Çå„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅØ„ÄÅ <code>String</code>Âûã„ÅÆ„Éï„Ç£„Éº„É´„Éâ <code>name</code> „Å® <code>Array String</code>„Å§„Åæ„Çä
<code>String</code>„ÅÆÈÖçÂàó„ÅÆÂûã„ÅÆ„Éï„Ç£„Éº„É´„Éâ <code>interests</code> „Å®„ÅÑ„ÅÜ2„Å§„ÅÆ<strong>„Éï„Ç£„Éº„É´„Éâ</strong> (field) „ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>„É¨„Ç≥„Éº„Éâ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅØ„ÄÅ„Éâ„ÉÉ„Éà„Å´Á∂ö„Åë„Å¶ÂèÇÁÖß„Åó„Åü„ÅÑ„Éï„Ç£„Éº„É´„Éâ„ÅÆ„É©„Éô„É´„ÇíÊõ∏„Åè„Å®ÂèÇÁÖß„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; author.name
&quot;Phil&quot;

&gt; author.interests
[&quot;Functional Programming&quot;,&quot;JavaScript&quot;]
</code></pre>
<p>PureScript„ÅÆÈñ¢Êï∞„ÅØJavaScript„ÅÆÈñ¢Êï∞„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇPureScript„ÅÆÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„ÅØÂ§ö„Åè„ÅÆÈñ¢Êï∞„ÅÆ‰æã„ÇíÊèê‰æõ„Åó„Å¶„Åä„Çä„ÄÅ„Åì„ÅÆÁ´†„Åß„ÅØ„Åù„Çå„Çâ„Çí„ÇÇ„ÅÜÂ∞ë„ÅóË©≥„Åó„ÅèË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude
&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c

&gt; :type const
forall a b. a -&gt; b -&gt; a
</code></pre>
<p>„Éï„Ç°„Ç§„É´„ÅÆ„Éà„ÉÉ„Éó„É¨„Éô„É´„Åß„ÅØ„ÄÅÁ≠âÂè∑„ÅÆÁõ¥Ââç„Å´ÂºïÊï∞„ÇíÊåáÂÆö„Åô„Çã„Åì„Å®„ÅßÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">add :: Int -&gt; Int -&gt; Int
add x y = x + y
</code></pre>
<p>„Éê„ÉÉ„ÇØ„Çπ„É©„ÉÉ„Ç∑„É•„Å´Á∂ö„Åë„Å¶Á©∫ÁôΩÊñáÂ≠ó„ÅßÂå∫Âàá„Çâ„Çå„ÅüÂºïÊï∞Âêç„ÅÆ„É™„Çπ„Éà„ÇíÊõ∏„Åè„Åì„Å®„Åß„ÄÅÈñ¢Êï∞„Çí„Ç§„É≥„É©„Ç§„É≥„ÅßÂÆöÁæ©„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
PSCi„ÅßË§áÊï∞Ë°å„ÅÆÂÆ£Ë®Ä„ÇíÂÖ•Âäõ„Åô„Çã„Å´„ÅØ„ÄÅ <code>:paste</code>„Ç≥„Éû„É≥„Éâ„Çí‰ΩøÁî®„Åó„Å¶„ÄåË≤º„Çä‰ªò„Åë„É¢„Éº„Éâ„Äç„Å´ÂÖ•„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆ„É¢„Éº„Éâ„Åß„ÅØ„ÄÅ<strong>Control-D</strong>„Ç≠„Éº„Ç∑„Éº„Ç±„É≥„Çπ„Çí‰ΩøÁî®„Åó„Å¶ÂÆ£Ë®Ä„ÇíÁµÇ‰∫Ü„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ add :: Int -&gt; Int -&gt; Int
‚Ä¶ add = \x y -&gt; x + y
‚Ä¶ ^D
</code></pre>
<p>PSCi„Åß„Åì„ÅÆÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„Å®„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´Èñ¢Êï∞„ÅÆÈö£„Å´2„Å§„ÅÆÂºïÊï∞„ÇíÁ©∫ÁôΩ„ÅßÂå∫Âàá„Å£„Å¶Êõ∏„Åè„Åì„Å®„Åß„ÄÅÈñ¢Êï∞„Çí„Åì„Çå„Çâ„ÅÆÂºïÊï∞„Å´<strong>ÈÅ©Áî®</strong> (apply)
„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; add 10 20
30
</code></pre>
<h2 id="ÈáèÂåñ„Åï„Çå„ÅüÂûã"><a class="header" href="#ÈáèÂåñ„Åï„Çå„ÅüÂûã">ÈáèÂåñ„Åï„Çå„ÅüÂûã</a></h2>
<p>Ââç„ÅÆÁØÄ„Åß„ÅØPrelude„ÅßÂÆöÁæ©„Åï„Çå„ÅüÈñ¢Êï∞„ÅÆÂûã„Çí„ÅÑ„Åè„Å§„ÅãË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ„Åü„Å®„Åà„Å∞ <code>flip</code>Èñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ</p>
<pre><code class="language-text">&gt; :type flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</code></pre>
<p>„Åì„ÅÆ <code>forall</code>„Ç≠„Éº„ÉØ„Éº„Éâ„ÅØ„ÄÅ <code>flip</code>„Åå<strong>ÂÖ®Áß∞ÈáèÂåñ„Åï„Çå„ÅüÂûã</strong> (universally quantified type)
„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅ <code>a</code>„ÇÑ <code>b</code>„ÄÅ <code>c</code>„Çí„Å©„ÅÆÂûã„Å´ÁΩÆ„ÅçÊèõ„Åà„Å¶„ÇÇ„ÄÅ <code>flip</code>„ÅØ„Åù„ÅÆÂûã„Åß„ÅÜ„Åæ„ÅèÂãï‰Ωú„Åô„Çã„Å®„ÅÑ„ÅÜÊÑèÂë≥„Åß„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„ÄÅ <code>a</code>„Çí <code>Int</code>„ÄÅ <code>b</code>„Çí <code>String</code>„ÄÅ <code>c</code>„Çí <code>String</code>„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´ÈÅ∏„Çì„Åß„Åø„Åü„Å®„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÂ†¥Âêà„ÄÅ <code>flip</code>„ÅÆÂûã„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´<strong>ÁâπÊÆäÂåñ</strong> (specialize) „Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">(Int -&gt; String -&gt; String) -&gt; String -&gt; Int -&gt; String
</code></pre>
<p>ÈáèÂåñ„Åï„Çå„ÅüÂûã„ÇíÁâπÊÆäÂåñ„Åó„Åü„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Çí„Ç≥„Éº„Éâ„ÅßÁ§∫„ÅôÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÁâπÊÆäÂåñ„ÅØËá™ÂãïÁöÑ„Å´Ë°å„Çè„Çå„Åæ„Åô„ÄÇ„Åü„Å®„Åà„Å∞„ÄÅ„Åô„Åß„Å´„Åù„ÅÆÂûã„ÅÆ
<code>flip</code>„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åü„Åã„ÅÆ„Çà„ÅÜ„Å´„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´Âçò„Å´ <code>flip</code>„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) &quot;Ten&quot; 10

&quot;10Ten&quot;
</code></pre>
<p><code>a</code>„ÄÅ <code>b</code>„ÄÅ <code>c</code>„ÅÆÂûã„ÅØ„Å©„Çì„Å™Âûã„Åß„ÇÇÈÅ∏„Å∂„Åì„Å®„Åå„Åß„Åç„Çã„Å®„ÅÑ„Å£„Å¶„ÇÇ„ÄÅÂûã„ÅÆ‰∏çÊï¥Âêà„ÅØÁîü„Åò„Å™„ÅÑ„Çà„ÅÜ„Å´„Åó„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
<code>flip</code>„Å´Ê∏°„ÅôÈñ¢Êï∞„ÅÆÂûã„ÅØ„ÄÅ‰ªñ„ÅÆÂºïÊï∞„ÅÆÂûã„Å®Êï¥ÂêàÊÄß„Åå„Å™„Åè„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
Á¨¨2ÂºïÊï∞„Å®„Åó„Å¶ÊñáÂ≠óÂàó <code>&quot;Ten&quot;</code>„ÄÅÁ¨¨3ÂºïÊï∞„Å®„Åó„Å¶Êï∞ <code>10</code>„ÇíÊ∏°„Åó„Åü„ÅÆ„ÅØ„Åù„Çå„ÅåÁêÜÁî±„Åß„Åô„ÄÇ
„ÇÇ„ÅóÂºïÊï∞„ÅåÈÄÜ„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Å®„ÅÜ„Åæ„Åè„ÅÑ„Åã„Å™„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; flip (\n s -&gt; show n &lt;&gt; s) 10 &quot;Ten&quot;

Could not match type Int with type String
</code></pre>
<h2 id="Â≠ó‰∏ã„Åí„Å´„Å§„ÅÑ„Å¶„ÅÆÊ≥®ÊÑè"><a class="header" href="#Â≠ó‰∏ã„Åí„Å´„Å§„ÅÑ„Å¶„ÅÆÊ≥®ÊÑè">Â≠ó‰∏ã„Åí„Å´„Å§„ÅÑ„Å¶„ÅÆÊ≥®ÊÑè</a></h2>
<p>JavaScript„Å®„ÅØÁï∞„Å™„Çä„ÄÅPureScript„ÅÆ„Ç≥„Éº„Éâ„ÅØÂ≠ó‰∏ã„Åí„ÅÆÂ§ß„Åç„Åï„Å´ÂΩ±Èüø„Åï„Çå„Åæ„Åô (indentation-sensitive)„ÄÇ
„Åì„Çå„ÅØHaskell„Å®Âêå„Åò„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Ç≥„Éº„ÉâÂÜÖ„ÅÆÁ©∫ÁôΩ„ÅÆÂ§öÂØ°„ÅØÁÑ°ÊÑèÂë≥„Åß„ÅØ„Å™„Åè„ÄÅC„ÅÆ„Çà„ÅÜ„Å™Ë®ÄË™û„Åß‰∏≠Êã¨Âºß„Å´„Çà„Å£„Å¶„Ç≥„Éº„Éâ„ÅÆ„Åæ„Å®„Åæ„Çä„ÇíÁ§∫„Åó„Å¶„ÅÑ„Çã„Çà„ÅÜ„Å´„ÄÅPureScript„Åß„ÅØÁ©∫ÁôΩ„Åå„Ç≥„Éº„Éâ„ÅÆ„Åæ„Å®„Åæ„Çä„ÇíÁ§∫„Åô„ÅÆ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>ÂÆ£Ë®Ä„ÅåË§áÊï∞Ë°å„Å´„Çè„Åü„ÇãÂ†¥Âêà„ÅØ„ÄÅÊúÄÂàù„ÅÆË°å‰ª•Â§ñ„ÅØÊúÄÂàù„ÅÆË°å„ÅÆÂ≠ó‰∏ã„Åí„Çà„ÇäÊ∑±„ÅèÂ≠ó‰∏ã„Åí„Åó„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>„Åó„Åü„Åå„Å£„Å¶„ÄÅÊ¨°„ÅØÊ≠£„Åó„ÅÑPureScript„Ç≥„Éº„Éâ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">add x y z = x +
  y + z
</code></pre>
<p>„Åó„Åã„Åó„ÄÅÊ¨°„ÅØÊ≠£„Åó„ÅÑ„Ç≥„Éº„Éâ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">add x y z = x +
y + z
</code></pre>
<p>ÂæåËÄÖ„Åß„ÅØ„ÄÅPureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØ„Åù„Çå„Åû„Çå„ÅÆË°å„Åî„Å®„Å´„Å≤„Å®„Å§„ÄÅ„Å§„Åæ„Çä<strong>2„Å§</strong>„ÅÆÂÆ£Ë®Ä„Åß„ÅÇ„Çã„Å®ÊßãÊñáËß£Êûê„Åó„Åæ„Åô„ÄÇ</p>
<p>‰∏ÄËà¨„Å´„ÄÅÂêå„Åò„Éñ„É≠„ÉÉ„ÇØÂÜÖ„ÅßÂÆöÁæ©„Åï„Çå„ÅüÂÆ£Ë®Ä„ÅØÂêå„ÅòÊ∑±„Åï„ÅßÂ≠ó‰∏ã„Åí„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞PSCi„ÅßletÊñá„ÅÆÂÆ£Ë®Ä„ÅØÂêå„ÅòÊ∑±„Åï„ÅßÂ≠ó‰∏ã„Åí„Åó„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
Ê¨°„ÅØÊ≠£„Åó„ÅÑ„Ç≥„Éº„Éâ„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ x = 1
‚Ä¶ y = 2
‚Ä¶ ^D
</code></pre>
<p>„Åó„Åã„Åó„ÄÅ„Åì„Çå„ÅØÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ x = 1
‚Ä¶  y = 2
‚Ä¶ ^D
</code></pre>
<p>PureScript„ÅÆ„ÅÑ„Åè„Å§„Åã„ÅÆ‰∫àÁ¥ÑË™ûÔºà‰æã„Åà„Å∞ <code>where</code>„ÇÑ <code>of</code>„ÄÅ
<code>let</code>Ôºâ„ÅØÊñ∞„Åü„Å™„Ç≥„Éº„Éâ„ÅÆ„Åæ„Å®„Åæ„Çä„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„Åå„ÄÅ„Åù„ÅÆ„Ç≥„Éº„Éâ„ÅÆ„Åæ„Å®„Åæ„ÇäÂÜÖ„ÅÆÂÆ£Ë®Ä„ÅØ„Åù„Çå„Çà„ÇäÊ∑±„ÅèÂ≠ó‰∏ã„Åí„Åï„Çå„Å¶„ÅÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">example x y z = foo + bar
  where
    foo = x * y
    bar = y * z
</code></pre>
<p>„Åì„Åì„Åß <code>foo</code>„ÇÑ <code>bar</code>„ÅÆÂÆ£Ë®Ä„ÅØ <code>example</code>„ÅÆÂÆ£Ë®Ä„Çà„ÇäÊ∑±„ÅèÂ≠ó‰∏ã„Åí„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„Åü„Å†„Åó„ÄÅ„ÇΩ„Éº„Çπ„Éï„Ç°„Ç§„É´„ÅÆÂÖàÈ†≠„ÄÅÊúÄÂàù„ÅÆ <code>module</code>ÂÆ£Ë®Ä„Å´„Åä„Åë„Çã‰∫àÁ¥ÑË™û <code>where</code>„Å†„Åë„ÅØ„ÄÅ„Åì„ÅÆË¶èÂâá„ÅÆÂîØ‰∏Ä„ÅÆ‰æãÂ§ñ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="Áã¨Ëá™„ÅÆÂûã„ÅÆÂÆöÁæ©"><a class="header" href="#Áã¨Ëá™„ÅÆÂûã„ÅÆÂÆöÁæ©">Áã¨Ëá™„ÅÆÂûã„ÅÆÂÆöÁæ©</a></h2>
<p>PureScript„ÅßÊñ∞„Åü„Å™ÂïèÈ°å„Å´Âèñ„ÇäÁµÑ„ÇÄ„Å®„Åç„ÅØ„ÄÅ„Åæ„Åö„ÅØ„Åì„Çå„Åã„ÇâÊâ±„Åä„ÅÜ„Å®„Åô„ÇãÂÄ§„ÅÆÂûã„ÅÆÂÆöÁæ©„ÇíÊõ∏„Åè„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Çã„ÅÆ„Åå„Çà„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇÊúÄÂàù„Å´„ÄÅ‰ΩèÊâÄÈå≤„Å´Âê´„Åæ„Çå„Çã„É¨„Ç≥„Éº„Éâ„ÅÆÂûã„ÇíÂÆöÁæ©„Åó„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Entry =
  { firstName :: String
  , lastName  :: String
  , address   :: Address
  }
</code></pre>
<p>„Åì„Çå„ÅØ <code>Entry</code>„Å®„ÅÑ„ÅÜ<strong>ÂûãÂêåÁæ©Ë™û</strong>Ôºàtype synonym„ÄÅÂûã„Ç∑„Éé„Éã„É†Ôºâ„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Âûã <code>Entry</code>„ÅØÁ≠âÂè∑„ÅÆÂè≥Ëæ∫„Å®Âêå„ÅòÂûã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
„É¨„Ç≥„Éº„Éâ„ÅÆÂûã„ÅØ„ÅÑ„Åö„Çå„ÇÇÊñáÂ≠óÂàó„Åß„ÅÇ„Çã <code>firstName</code>„ÄÅ <code>lastName</code>„ÄÅ <code>phone</code>„Å®„ÅÑ„ÅÜ3„Å§„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Åã„Çâ„Å™„Çä„Åæ„Åô„ÄÇ
ÂâçËÄÖ„ÅÆ2„Å§„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅØÂûã <code>String</code>„ÇíÊåÅ„Å°„ÄÅ <code>address</code>„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„ÅüÂûã <code>Address</code>„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Address =
  { street :: String
  , city   :: String
  , state  :: String
  }
</code></pre>
<p>„Å™„Åä„ÄÅ„É¨„Ç≥„Éº„Éâ„Å´„ÅØ‰ªñ„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇíÂê´„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØ„ÄÅ3„Å§„ÇÅ„ÅÆÂûãÂêåÁæ©Ë™û„ÇÇÂÆöÁæ©„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ‰ΩèÊâÄÈå≤„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„Å®„Åó„Å¶„ÅØ„ÄÅÂçò„Å´È†ÖÁõÆ„ÅÆÈÄ£Áµê„É™„Çπ„Éà„Å®„Åó„Å¶Ê†ºÁ¥ç„Åô„Çã„Åì„Å®„Å´„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type AddressBook = List Entry
</code></pre>
<p><code>List Entry</code>„ÅØ <code>Array Entry</code>„Å®„ÅØÂêå„Åò„Åß„ÅØ„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ <code>Array Entry</code>„ÅØ‰ΩèÊâÄÈå≤„ÅÆÈ†ÖÁõÆ„ÅÆ<strong>ÈÖçÂàó</strong>„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÂûãÊßãÁØâÂ≠ê„Å®Á®Æ"><a class="header" href="#ÂûãÊßãÁØâÂ≠ê„Å®Á®Æ">ÂûãÊßãÁØâÂ≠ê„Å®Á®Æ</a></h2>
<p><code>List</code>„ÅØ<strong>ÂûãÊßãÁØâÂ≠ê</strong>Ôºàtype constructor„ÄÅÂûã„Ç≥„É≥„Çπ„Éà„É©„ÇØ„ÇøÔºâ„ÅÆ‰∏Ä‰æã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>List</code>„Åù„ÅÆ„ÇÇ„ÅÆ„ÅØÂûã„Åß„ÅØ„Å™„Åè„ÄÅ‰Ωï„Çâ„Åã„ÅÆÂûã <code>a</code>„Åå„ÅÇ„Çã„Å®„Åç <code>List a</code>„ÅåÂûã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Å§„Åæ„Çä„ÄÅ <code>List</code>„ÅØ<strong>ÂûãÂºïÊï∞</strong> (type argument) <code>a</code>„Çí„Å®„Çä„ÄÅÊñ∞„Åü„Å™Âûã <code>List a</code>„Çí<strong>ÊßãÁØâ</strong>„Åô„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Å°„Çá„ÅÜ„Å©Èñ¢Êï∞ÈÅ©Áî®„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅÂûãÊßãÁØâÂ≠ê„ÅØ‰ªñ„ÅÆÂûã„Å´‰∏¶„Åπ„Çã„Åì„Å®„ÅßÈÅ©Áî®„Åï„Çå„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂûã <code>List„ÄÄEntry</code>„ÅØÂÆü„ÅØÂûãÊßãÁØâÂ≠ê
<code>List</code>„ÅåÂûã <code>Entry</code>„Å´<strong>ÈÅ©Áî®</strong>„Åï„Çå„Åü„ÇÇ„ÅÆ„Åß„Åô„ÄÇ„Åì„Çå„ÅØ‰ΩèÊâÄÈå≤È†ÖÁõÆ„ÅÆ„É™„Çπ„Éà„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÔºàÂûãÊ≥®ÈáàÊºîÁÆóÂ≠ê <code>::</code>„Çí‰Ωø„Å£„Å¶Ôºâ„ÇÇ„ÅóÂûã <code>List</code>„ÅÆÂÄ§„ÇíÈñìÈÅï„Å£„Å¶ÂÆöÁæ©„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å®„ÄÅ‰ªä„Åæ„ÅßË¶ã„Åü„Åì„Å®„ÅÆ„Å™„ÅÑ„Çà„ÅÜ„Å™Á®ÆÈ°û„ÅÆ„Ç®„É©„Éº„ÅåË°®Á§∫„Åï„Çå„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.List
&gt; Nil :: List
In a type-annotated expression x :: t, the type t must have kind Type
</code></pre>
<p>„Åì„Çå„ÅØ<strong>Á®Æ„Ç®„É©„Éº</strong> (kind error) „Åß„Åô„ÄÇ
ÂÄ§„Åå„Åù„ÅÆ<strong>Âûã</strong>„ÅßÂå∫Âà•„Åï„Çå„Çã„ÅÆ„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅÂûã„ÅØ„Åù„ÅÆ<strong>Á®Æ</strong> (kind)
„Å´„Çà„Å£„Å¶Âå∫Âà•„Åï„Çå„ÄÅÈñìÈÅï„Å£„ÅüÂûã„ÅÆÂÄ§„Åå<strong>Âûã„Ç®„É©„Éº</strong>„Å´„Å™„Çã„Çà„ÅÜ„Å´„ÄÅ<strong>ÈñìÈÅï„Å£„ÅüÁ®Æ</strong>„ÅÆÂûã„ÅØ<strong>Á®Æ„Ç®„É©„Éº</strong>„ÇíÂºï„ÅçËµ∑„Åì„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Number</code>„ÇÑ <code>String</code>„ÅÆ„Çà„ÅÜ„Å™„ÄÅÂÄ§„ÇíÊåÅ„Å§„Åô„Åπ„Å¶„ÅÆÂûã„ÅÆÁ®Æ„ÇíË°®„Åô <code>Type</code>„Å®Âëº„Å∞„Çå„ÇãÁâπÂà•„Å™Á®Æ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>ÂûãÊßãÁØâÂ≠ê„Å´„ÇÇÁ®Æ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åü„Å®„Åà„Å∞„ÄÅÁ®Æ <code>Type -&gt; Type</code>„ÅØ„Å°„Çá„ÅÜ„Å© <code>List</code>„ÅÆ„Çà„ÅÜ„Å™Âûã„Åã„ÇâÂûã„Å∏„ÅÆÈñ¢Êï∞„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Åì„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åü„ÅÆ„ÅØ„ÄÅÂÄ§„ÅåÁ®Æ <code>Type</code>„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å§„Å®ÊúüÂæÖ„Åï„Çå„Å¶„ÅÑ„Åü„ÅÆ„Å´„ÄÅ <code>List</code>„ÅØÁ®Æ <code>Type -&gt; Type</code>„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ</p>
<p>PSCi„ÅßÂûã„ÅÆÁ®Æ„ÇíË™ø„Åπ„Çã„Å´„ÅØ„ÄÅ <code>:kind</code>ÂëΩ‰ª§„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ‰æã„Åà„Å∞Ê¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :kind Number
Type

&gt; import Data.List
&gt; :kind List
Type -&gt; Type

&gt; :kind List String
Type
</code></pre>
<p>PureScript„ÅÆ<strong>Á®Æ„Ç∑„Çπ„ÉÜ„É†</strong>„ÅØ‰ªñ„Å´„ÇÇÈù¢ÁôΩ„ÅÑÁ®Æ„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ„Åù„Çå„Çâ„Å´„Å§„ÅÑ„Å¶„ÅØÊú¨Êõ∏„ÅÆ‰ªñ„ÅÆÈÉ®ÂàÜ„ÅßË¶ã„Å¶„ÅÑ„Åè„Åì„Å®„Å´„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="‰ΩèÊâÄÈå≤„ÅÆÈ†ÖÁõÆ„ÅÆË°®Á§∫"><a class="header" href="#‰ΩèÊâÄÈå≤„ÅÆÈ†ÖÁõÆ„ÅÆË°®Á§∫">‰ΩèÊâÄÈå≤„ÅÆÈ†ÖÁõÆ„ÅÆË°®Á§∫</a></h2>
<p>„Åù„Çå„Åß„ÅØÊúÄÂàù„Å´„ÄÅÊñáÂ≠óÂàó„Åß‰ΩèÊâÄÈå≤„ÅÆÈ†ÖÁõÆ„ÇíË°®Áèæ„Åô„Çã„Çà„ÅÜ„Å™Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åæ„Åö„ÅØÈñ¢Êï∞„Å´Âûã„Çí‰∏é„Åà„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åô„ÄÇ
Âûã„ÅÆÂÆöÁæ©„ÅØÁúÅÁï•„Åô„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô„Åå„ÄÅ„Éâ„Ç≠„É•„É°„É≥„Éà„Å®„Åó„Å¶„ÇÇÂΩπÁ´ã„Å§„ÅÆ„ÅßÂûã„ÇíÊõ∏„ÅÑ„Å¶„Åä„Åè„Çà„ÅÜ„Å´„Åô„Çã„Å®ËâØ„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ
ÂÆüÈöõ„ÄÅ„Éà„ÉÉ„Éó„É¨„Éô„É´„ÅÆÂÆ£Ë®Ä„Å´ÂûãË®ªÈáà„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑ„Å®„ÄÅPureScript„Ç≥„É≥„Éë„Ç§„É©„ÅåË≠¶Âëä„ÇíÂá∫„Åó„Åæ„Åô„ÄÇ
ÂûãÂÆ£Ë®Ä„ÅØÈñ¢Êï∞„ÅÆÂêçÂâç„Å®„Åù„ÅÆÂûã„Çí <code>::</code>Ë®òÂè∑„ÅßÂå∫Âàá„Çã„Çà„ÅÜ„Å´„Åó„Å¶Êõ∏„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">showEntry :: Entry -&gt; String
</code></pre>
<p><code>showEntry</code>„ÅØÂºïÊï∞„Å®„Åó„Å¶ <code>Entry</code>„ÇíÂèñ„Çä <code>string</code>„ÇíËøî„ÅôÈñ¢Êï∞„Åß„ÅÇ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Çí„ÄÅ„Åì„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØË®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>showEntry</code>„ÅÆ„Ç≥„Éº„Éâ„ÅØÊ¨°„ÅÆ„Å®„Åä„Çä„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">showEntry entry = entry.lastName &lt;&gt; &quot;, &quot; &lt;&gt;
                  entry.firstName &lt;&gt; &quot;: &quot; &lt;&gt;
                  showAddress entry.address
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ <code>Entry</code>„É¨„Ç≥„Éº„Éâ„ÅÆ3„Å§„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíÈÄ£Áµê„Åó„ÄÅÂçò‰∏Ä„ÅÆÊñáÂ≠óÂàó„Å´„Åó„Åæ„Åô„ÄÇ„Åì„Åì„Åß‰ΩøÁî®„Åï„Çå„Çã <code>showAddress</code>„ÅØ
<code>address</code>„Éï„Ç£„Éº„É´„Éâ„ÇíÈÄ£Êé•„Åó„ÄÅÂçò‰∏Ä„ÅÆÊñáÂ≠óÂàó„Å´„Åô„ÇãÈñ¢Êï∞„Åß„Åô„ÄÇ <code>showAddress</code>„ÅÆÂÆöÁæ©„ÅØÊ¨°„ÅÆ„Å®„Åä„Çä„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">showAddress :: Address -&gt; String
showAddress addr = addr.street &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.city &lt;&gt; &quot;, &quot; &lt;&gt;
                   addr.state
</code></pre>
<p>Èñ¢Êï∞ÂÆöÁæ©„ÅØÈñ¢Êï∞„ÅÆÂêçÂâç„ÅßÂßã„Åæ„Çä„ÄÅÂºïÊï∞Âêç„ÅÆ„É™„Çπ„Éà„ÅåÁ∂ö„Åç„Åæ„Åô„ÄÇÈñ¢Êï∞„ÅÆÁµêÊûú„ÅØÁ≠âÂè∑„ÅÆÂæå„Çç„Å´ÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ„Éï„Ç£„Éº„É´„Éâ„ÅØ„Éâ„ÉÉ„Éà„Å´Á∂ö„Åë„Å¶„Éï„Ç£„Éº„É´„ÉâÂêç„ÇíÊõ∏„Åè„Åì„Å®„ÅßÂèÇÁÖß„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇPureScript„Åß„ÅØ„ÄÅÊñáÂ≠óÂàóÈÄ£Áµê„ÅØJavaScript„ÅÆ„Çà„ÅÜ„Å™Âçò‰∏Ä„ÅÆ„Éó„É©„ÇπË®òÂè∑„Åß„ÅØ„Å™„Åè„ÄÅ„ÉÄ„Ç§„Ç¢„É¢„É≥„ÉâÊºîÁÆóÂ≠êÔºà<code>&lt;&gt;</code>Ôºâ„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="„ÅØ„ÇÑ„ÇÅ„Å´„ÉÜ„Çπ„Éà„Åü„Å≥„Åü„Å≥„ÉÜ„Çπ„Éà"><a class="header" href="#„ÅØ„ÇÑ„ÇÅ„Å´„ÉÜ„Çπ„Éà„Åü„Å≥„Åü„Å≥„ÉÜ„Çπ„Éà">„ÅØ„ÇÑ„ÇÅ„Å´„ÉÜ„Çπ„Éà„ÄÅ„Åü„Å≥„Åü„Å≥„ÉÜ„Çπ„Éà</a></h2>
<p>PSCiÂØæË©±Âºè„É¢„Éº„Éâ„Åß„ÅØÂèçÂøú„ÇíÂç≥Â∫ß„Å´Âæó„Çâ„Çå„Çã„ÅÆ„Åß„ÄÅÁ¥†Êó©„ÅÑË©¶‰ΩúÈñãÁô∫„Å´Âêë„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åù„Çå„Åß„ÅØ„Åì„ÅÆÊúÄÂàù„ÅÆÈñ¢Êï∞„ÅåÊ≠£„Åó„ÅèÂãï‰Ωú„Åô„Çã„Åã„ÇíPSCi„Çí‰ΩøÁî®„Åó„Å¶Á¢∫Ë™ç„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åæ„Åö„ÄÅ„Åì„Çå„Åæ„Åß„Å´Êõ∏„ÅÑ„Åü„Ç≥„Éº„Éâ„Çí„Éì„É´„Éâ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago build
</code></pre>
<p>Ê¨°„Å´„ÄÅPSCi„ÇíËµ∑Âãï„Åó„ÄÅ„Åì„ÅÆÊñ∞„Åó„ÅÑ„É¢„Ç∏„É•„Éº„É´„Çí„Ç§„É≥„Éù„Éº„Éà„Åô„Çã„Åü„ÇÅ„Å´ <code>import</code>ÂëΩ‰ª§„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.AddressBook
</code></pre>
<p>„É¨„Ç≥„Éº„Éâ„É™„ÉÜ„É©„É´„Çí‰Ωø„ÅÜ„Å®„ÄÅ‰ΩèÊâÄÈå≤„ÅÆÈ†ÖÁõÆ„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„É¨„Ç≥„Éº„Éâ„É™„ÉÜ„É©„É´„ÅØJavaScript„ÅÆÁÑ°Âêç„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å®Âêå„Åò„Çà„ÅÜ„Å™ÊßãÊñá„ÅßÂêçÂâç„Å´ÊùüÁ∏õ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>‚Äã„Åù„Çå„Åß„ÅØ„ÄÅ„Åì„ÅÆ‰æã„Å´Èñ¢Êï∞„ÇíÈÅ©Áî®„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-text">&gt; showAddress address

&quot;123 Fake St., Faketown, CA&quot;
</code></pre>
<p><code>showEntry</code>„ÇÇ„ÄÅ‰ΩèÊâÄ„ÇíÂê´„ÇÄ‰ΩèÊâÄÈå≤È†ÖÁõÆ„ÅÆË®òÈå≤‰æã„Çí‰Ωú„Å£„Å¶Ë©¶„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; showEntry entry

&quot;Smith, John: 123 Fake St., Faketown, CA&quot;
</code></pre>
<h2 id="‰ΩèÊâÄÈå≤„ÅÆ‰ΩúÊàê"><a class="header" href="#‰ΩèÊâÄÈå≤„ÅÆ‰ΩúÊàê">‰ΩèÊâÄÈå≤„ÅÆ‰ΩúÊàê</a></h2>
<p>‰ªäÂ∫¶„ÅØ‰ΩèÊâÄÈå≤„ÅÆÊìç‰Ωú„ÇíÊîØÊè¥„Åô„ÇãÈñ¢Êï∞„Çí„ÅÑ„Åè„Å§„ÅãÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
Á©∫„ÅÆ‰ΩèÊâÄÈå≤„ÇíË°®„ÅôÂÄ§„ÅåÂøÖË¶Å„Åß„Åô„Åå„ÄÅ„Åì„Çå„Å´„ÅØÁ©∫„ÅÆ„É™„Çπ„Éà„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">emptyBook :: AddressBook
emptyBook = empty
</code></pre>
<p>Êó¢Â≠ò„ÅÆ‰ΩèÊâÄÈå≤„Å´ÂÄ§„ÇíÊåøÂÖ•„Åô„ÇãÈñ¢Êï∞„ÇÇÂøÖË¶Å„Åß„Åó„Çá„ÅÜ„ÄÇ„Åì„ÅÆÈñ¢Êï∞„Çí <code>insertEntry</code>„Å®Âëº„Å∂„Åì„Å®„Å´„Åó„Åæ„Åô„ÄÇÈñ¢Êï∞„ÅÆÂûã„Çí‰∏é„Åà„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>„Åì„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„Å´Êõ∏„Åã„Çå„Å¶„ÅÑ„Çã„ÅÆ„ÅØ„ÄÅÊúÄÂàù„ÅÆÂºïÊï∞„Å®„Åó„Å¶ <code>Entry</code>„ÄÅÁ¨¨‰∫åÂºïÊï∞„Å®„Åó„Å¶ <code>AddressBook</code>„ÇíÂèñ„Çä„ÄÅÊñ∞„Åó„ÅÑ
<code>AddressBook</code>„ÇíËøî„Åô„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>Êó¢Â≠ò„ÅÆ <code>AddressBook</code>„ÇíÁõ¥Êé•Â§âÊõ¥„Åô„Çã„Åì„Å®„ÅØ„Åó„Åæ„Åõ„Çì„ÄÇ
„Åù„ÅÆ‰ª£„Çè„Çä„Å´„ÄÅÂêå„Åò„Éá„Éº„Çø„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÊñ∞„Åó„ÅÑ <code>AddressBook</code>„ÇíËøî„Åô„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Çà„ÅÜ„Å´„ÄÅ <code>AddressBook</code>„ÅØ<strong>‰∏çÂ§â„Éá„Éº„ÇøÊßãÈÄ†</strong> (immutable data structure) „ÅÆ‰∏Ä‰æã„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØPureScript„Å´„Åä„Åë„ÇãÈáçË¶Å„Å™ËÄÉ„ÅàÊñπ„Åß„Åô„ÄÇ
Â§âÊõ¥„ÅØ„Ç≥„Éº„Éâ„ÅÆÂâØ‰ΩúÁî®„Åß„ÅÇ„Çä„ÄÅÂäπÁéá„ÅÆËâØ„ÅÑ„Ç≥„Éº„Éâ„ÅÆÊåØ„ÇãËàû„ÅÑ„ÅÆÂà§Êñ≠„ÇíÂ¶®„Åí„Åæ„Åô„ÄÇ
„Åù„ÅÆ„Åü„ÇÅ„ÄÅÊàë„ÄÖ„ÅØÂèØËÉΩ„Å™Èôê„ÇäÁ¥îÁ≤ã„Å™Èñ¢Êï∞„ÇÑ‰∏çÂ§â„ÅÆ„Éá„Éº„Çø„ÇíÂ•Ω„ÇÄ„ÅÆ„Åß„Åô„ÄÇ</p>
<p><code>insertEntry</code>„ÇíÂÆüË£Ö„Åô„Çã„ÅÆ„Å´<code>Data.List</code>„ÅÆ<code>Cons</code>Èñ¢Êï∞„Åå‰Ωø„Åà„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅÆÂûã„ÇíË¶ã„Çã„Å´„ÅØ„ÄÅPSCi„ÇíËµ∑Âãï„Åó <code>:type</code>„Ç≥„Éû„É≥„Éâ„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type Cons

forall a. a -&gt; List a -&gt; List a
</code></pre>
<p><code>Cons</code>„ÅØ„ÄÅ„Å™„Çì„Çâ„Åã„ÅÆÂûã <code>a</code>„ÅÆÂÄ§„Å®„ÄÅÂûã
<code>a</code>„ÇíË¶ÅÁ¥†„Å´ÊåÅ„Å§„É™„Çπ„Éà„ÇíÂºïÊï∞„Å´„Å®„Çä„ÄÅÂêå„ÅòÂûã„ÅÆË¶ÅÁ¥†„ÇíÊåÅ„Å§Êñ∞„Åó„ÅÑ„É™„Çπ„Éà„ÇíËøî„Åô„Å®„ÅÑ„ÅÜ„Åì„Å®„Çí„ÄÅ„Åì„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØË®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ <code>a</code>„Çí
<code>Entry</code>Âûã„Å®„Åó„Å¶ÁâπÊÆäÂåñ„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">Entry -&gt; List Entry -&gt; List Entry
</code></pre>
<p>„Åó„Åã„Åó„ÄÅ <code>List Entry</code>„ÅØ„Åæ„Åï„Å´ <code>AddressBook</code>„Åß„Åô„Åã„Çâ„ÄÅÊ¨°„Å®Âêå„Åò„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">Entry -&gt; AddressBook -&gt; AddressBook
</code></pre>
<p>‰ªäÂõû„ÅÆÂ†¥Âêà„ÄÅ„Åô„Åß„Å´ÈÅ©Âàá„Å™ÂÖ•Âäõ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ <code>Entry</code>„Å® <code>AddressBook</code>„Å´ <code>Cons</code>„ÇíÈÅ©Áî®„Åô„Çã„Å®„ÄÅÊñ∞„Åó„ÅÑ
<code>AddressBook</code>„ÇíÂæó„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åì„Çå„Åì„Åù„Åæ„Åï„Å´ÁßÅ„Åü„Å°„ÅåÊ±Ç„ÇÅ„Å¶„ÅÑ„ÅüÈñ¢Êï∞„Åß„ÅôÔºÅ</p>
<p><code>insertEntry</code>„ÅÆÂÆüË£Ö„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">insertEntry entry book = Cons entry book
</code></pre>
<p>Á≠âÂè∑„ÅÆÂ∑¶ÂÅ¥„Å´„ÅÇ„Çã2„Å§„ÅÆÂºïÊï∞ <code>entry</code>„Å® <code>book</code>„Åå„Çπ„Ç≥„Éº„Éó„Å´Â∞éÂÖ•„Åï„Çå„Åæ„Åô„Åã„Çâ„ÄÅ„Åì„Çå„Çâ„Å´ <code>Cons</code>Èñ¢Êï∞„ÇíÈÅ©Áî®„Åó„Å¶ÁµêÊûú„ÅÆÂÄ§„Çí‰ΩúÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞"><a class="header" href="#„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞">„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞</a></h2>
<p>PureScript„Åß„ÅØ„ÄÅÈñ¢Êï∞„ÅØÂ∏∏„Å´„Å≤„Å®„Å§„ÅÆÂºïÊï∞„Å†„Åë„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ
<code>insertEntry</code>Èñ¢Êï∞„ÅØ2„Å§„ÅÆÂºïÊï∞„ÇíÂèñ„Çã„Çà„ÅÜ„Å´Ë¶ã„Åà„Åæ„Åô„Åå„ÄÅ„Åì„Çå„ÅØÂÆüÈöõ„Å´„ÅØ<strong>„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞</strong> (curried function)
„ÅÆ‰∏Ä‰æã„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>insertEntry</code>„ÅÆÂûã„Å´Âê´„Åæ„Çå„Çã <code>-&gt;</code>„ÅØÂè≥ÁµêÂêà„ÅÆÊºîÁÆóÂ≠ê„Åß„ÅÇ„Çä„ÄÅ„Å§„Åæ„Çä„Åì„ÅÆÂûã„ÅØ„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶Ê¨°„ÅÆ„Çà„ÅÜ„Å´Ëß£Èáà„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">Entry -&gt; (AddressBook -&gt; AddressBook)
</code></pre>
<p>„Åô„Å™„Çè„Å°„ÄÅ <code>insertEntry</code>„ÅØÈñ¢Êï∞„ÇíËøî„ÅôÈñ¢Êï∞„Åß„ÅÇ„Çã„ÄÅ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„ÅôÔºÅ„Åì„ÅÆÈñ¢Êï∞„ÅØÂçò‰∏Ä„ÅÆÂºïÊï∞ <code>Entry</code>„ÇíÂèñ„Çä„ÄÅ„Åù„Çå„Åã„ÇâÂçò‰∏Ä„ÅÆÂºïÊï∞
<code>AddressBook</code>„ÇíÂèñ„ÇäÊñ∞„Åó„ÅÑ <code>AddressBook</code>„ÇíËøî„ÅôÊñ∞„Åó„ÅÑÈñ¢Êï∞„ÇíËøî„Åô„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Åì„Çå„ÅØ‰æã„Åà„Å∞„ÄÅÊúÄÂàù„ÅÆÂºïÊï∞„Å†„Åë„Çí‰∏é„Åà„Çã„Å® <code>insertEntry</code>„Çí<strong>ÈÉ®ÂàÜÈÅ©Áî®</strong> (partial application)
„Åß„Åç„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ
PSCi„Åß„Åì„ÅÆÁµêÊûú„ÅÆÂûã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; :type insertEntry entry

AddressBook -&gt; AddressBook
</code></pre>
<p>ÊúüÂæÖ„Åó„Åü„Å®„Åä„Çä„ÄÅÊàª„ÇäÂÄ§„ÅÆÂûã„ÅØÈñ¢Êï∞„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ
„Åì„ÅÆÁµêÊûú„ÅÆÈñ¢Êï∞„Å´„ÄÅ2„Å§ÁõÆ„ÅÆÂºïÊï∞„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :type (insertEntry entry) emptyBook
AddressBook
</code></pre>
<p>„Åì„Åì„ÅßÊã¨Âºß„ÅØ‰∏çË¶Å„Åß„ÅÇ„Çã„Åì„Å®„Å´„ÇÇÊ≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊ¨°„ÅÆÂºè„ÅØÂêåÁ≠â„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :type insertEntry entry emptyBook
AddressBook
</code></pre>
<p>„Åì„Çå„ÅØÈñ¢Êï∞ÈÅ©Áî®„ÅåÂ∑¶ÁµêÂêà„Åß„ÅÇ„Çã„Åü„ÇÅ„Åß„ÄÅ
„Å™„ÅúÂçò„Å´Á©∫ÁôΩ„ÅßÂå∫Âàá„Çã„Å†„Åë„ÅßÈñ¢Êï∞„Å´ÂºïÊï∞„Çí‰∏é„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åã„ÅÆË™¨Êòé„Å´„ÇÇ„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Èñ¢Êï∞„ÅÆÂûã„ÅÆ<code>-&gt;</code>ÊºîÁÆóÂ≠ê„ÅØÈñ¢Êï∞„ÅÆ<strong>ÂûãÊßãÁØâÂ≠ê</strong>„Åß„Åô„ÄÇ
„Åì„ÅÆÊºîÁÆóÂ≠ê„ÅØ2„Å§„ÅÆÂûãÂºïÊï∞„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ
Â∑¶Âè≥„ÅÆË¢´ÊºîÁÆóÂ≠ê„ÅØ„Åù„Çå„Åû„ÇåÈñ¢Êï∞„ÅÆÂºïÊï∞„ÅÆÂûã„Å®ËøîÂÄ§„ÅÆÂûã„Åß„Åô„ÄÇ</p>
<p>Êú¨Êõ∏„Åß„ÅØ‰ªäÂæå„ÄÅ„Äå2ÂºïÊï∞„ÅÆÈñ¢Êï∞„Äç„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´Ë°®Áèæ„Åô„Çã„Åì„Å®„Åå„ÅÇ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åó„Åã„Åó„Åù„Çå„ÅØ„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Çã„Å®ËÄÉ„Åà„Çã„Åπ„Åç„Åß„ÄÅ„Åù„ÅÆÈñ¢Êï∞„ÅØÊúÄÂàù„ÅÆÂºïÊï∞„ÇíÂèñ„Çä2„Å§ÁõÆ„ÅÆÂºïÊï∞„ÇíÂèñ„ÇãÂà•„ÅÆÈñ¢Êï∞„ÇíËøî„Åô„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰ªäÂ∫¶„ÅØ <code>insertEntry</code>„ÅÆÂÆöÁæ©„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry book = Cons entry book
</code></pre>
<p>„ÇÇ„ÅóÂºè„ÅÆÂè≥Ëæ∫„Å´ÊòéÁ§∫ÁöÑ„Å´Êã¨Âºß„Çí„Å§„Åë„Çã„Å™„Çâ„ÄÅ <code>(Cons entry) book</code>„Å®„Å™„Çä„Åæ„Åô„ÄÇ
<code>insertEntry entry</code>„ÅØ„Åù„ÅÆÂºïÊï∞„ÅåÂçò„Å´Èñ¢Êï∞ <code>(Cons entry)</code>„Å´Ê∏°„Åï„Çå„Çã„Çà„ÅÜ„Å™Èñ¢Êï∞„Å†„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
„Åß„ÇÇ„Åì„ÅÆ2„Å§„ÅÆÈñ¢Êï∞„ÅØ„Å©„Çì„Å™ÂÖ•Âäõ„Å´„Å§„ÅÑ„Å¶„ÇÇÂêå„ÅòÁµêÊûú„ÇíËøî„Åó„Åæ„Åô„Åã„Çâ„ÄÅ„Å§„Åæ„Çä„Åì„Çå„Çâ„ÅØÂêå„ÅòÈñ¢Êï∞„Åß„ÅôÔºÅ
„Çà„Å£„Å¶„ÄÅ‰∏°Ëæ∫„Åã„ÇâÂºïÊï∞ <code>book</code>„ÇíÂâäÈô§„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry entry = Cons entry
</code></pre>
<p>„Åó„Åã„Åó‰ªä„ÇÑÂêåÊßò„ÅÆË≠∞Ë´ñ„Å´„Çà„Çä„ÄÅ‰∏°Ëæ∫„Åã„Çâ <code>entry</code>„ÇÇÂâäÈô§„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">insertEntry :: Entry -&gt; AddressBook -&gt; AddressBook
insertEntry = Cons
</code></pre>
<p>„Åì„ÅÆÂá¶ÁêÜ„ÅØ<strong>„Ç§„Éº„ÇøÂ§âÊèõ</strong> (eta conversion)
„Å®Âëº„Å∞„Çå„ÄÅÔºà„Åù„ÅÆ‰ªñ„ÅÆÊäÄÊ≥ï„Çí‰ΩµÁî®„Åó„Å¶ÔºâÂºïÊï∞„ÇíÂèÇÁÖß„Åô„Çã„Åì„Å®„Å™„ÅèÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã<strong>„Éù„Ç§„É≥„Éà„Éï„É™„ÉºÂΩ¢Âºè</strong> (point-free form)
„Å∏„Å®Èñ¢Êï∞„ÇíÊõ∏„ÅçÊèõ„Åà„Çã„ÅÆ„Å´‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>insertEntry</code>„ÅÆÂ†¥Âêà„Å´„ÅØ„ÄÅ„Ç§„Éº„ÇøÂ§âÊèõ„Å´„Çà„Å£„Å¶„Äå<code>insertEntry</code>„ÅØÂçò„Å´„É™„Çπ„Éà„Å´ÂØæ„Åô„Çãcons„Å†„Äç„Å®„Å™„Çä„ÄÅÈñ¢Êï∞„ÅÆÂÆöÁæ©„ÅØ„Å®„Å¶„ÇÇÊòéÁ¢∫„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ
„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅ‰∏ÄËà¨ÁöÑ„Å´„Éù„Ç§„É≥„Éà„Éï„É™„ÉºÂΩ¢Âºè„ÅÆ„Åª„ÅÜ„Åå„ÅÑ„ÅÑ„ÅÆ„Åã„Å©„ÅÜ„Åã„Å´„ÅØË≠∞Ë´ñ„ÅÆ‰ΩôÂú∞„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Éë„ÉÜ„Ç£ÂèñÂæóÂ≠ê"><a class="header" href="#„Éó„É≠„Éë„ÉÜ„Ç£ÂèñÂæóÂ≠ê">„Éó„É≠„Éë„ÉÜ„Ç£ÂèñÂæóÂ≠ê</a></h2>
<p>„Çà„Åè„ÅÇ„Çã„Éë„Çø„Éº„É≥„ÅÆ1„Å§„Å®„Åó„Å¶„ÄÅ„É¨„Ç≥„Éº„Éâ‰∏≠„ÅÆÂÄãÂà•„ÅÆ„Éï„Ç£„Éº„É´„ÉâÔºà„Åæ„Åü„ÅØ„Äå„Éó„É≠„Éë„ÉÜ„Ç£„ÄçÔºâ„ÇíÂèñÂæó„Åô„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
<code>Entry</code>„Åã„Çâ<code>Address</code>„ÇíÂèñ„ÇäÂá∫„Åô„Ç§„É≥„É©„Ç§„É≥Èñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åë„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">\entry -&gt; entry.address
</code></pre>
<p>PureScript„Åß„ÅØ<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#property-accessors"><strong>„Éó„É≠„Éë„ÉÜ„Ç£ÂèñÂæóÂ≠ê</strong></a>„Å®„ÅÑ„ÅÜÁï•Ë®ò„Åå‰Ωø„Åà„Åæ„Åô„ÄÇ
„Åì„ÅÆÁï•Ë®ò„Åß„ÅØ‰∏ãÁ∑öÊñáÂ≠ó„ÅØÁÑ°ÂêçÈñ¢Êï∞„ÅÆÂºïÊï∞„Å®„Åó„Å¶ÊåØËàû„ÅÜ„Åü„ÇÅ„ÄÅ‰∏äË®ò„ÅÆ„Ç§„É≥„É©„Ç§„É≥Èñ¢Êï∞„ÅØÊ¨°„Å®Á≠â‰æ°„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">_.address
</code></pre>
<p>„Åì„Çå„ÅØ‰ΩïÊÆµÈöé„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„Åß„ÇÇÂãï„Åè„Åü„ÇÅ„ÄÅ<code>Entry</code>„Å´Èñ¢ÈÄ£‰ªò„ÅèË°ó„ÇíÂèñ„ÇäÂá∫„ÅôÈñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åë„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">_.address.city
</code></pre>
<p>‰ª•‰∏ã„ÅØ‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; address = { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
&gt; entry = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, address: address }
&gt; _.lastName entry
&quot;Smith&quot;

&gt; _.address.city entry
&quot;Faketown&quot;
</code></pre>
<h2 id="„ÅÇ„Å™„Åü„ÅÆ‰ΩèÊâÄÈå≤„ÅØ"><a class="header" href="#„ÅÇ„Å™„Åü„ÅÆ‰ΩèÊâÄÈå≤„ÅØ">„ÅÇ„Å™„Åü„ÅÆ‰ΩèÊâÄÈå≤„ÅØÔºü</a></h2>
<p>ÊúÄÂ∞èÈôê„ÅÆ‰ΩèÊâÄÈå≤„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÂÆüË£Ö„ÅßÂøÖË¶Å„Å´„Å™„ÇãÊúÄÂæå„ÅÆÈñ¢Êï∞„ÅØ„ÄÅÂêçÂâç„Åß‰∫∫„ÇíÊ§úÁ¥¢„ÅóÈÅ©Âàá„Å™
<code>Entry</code>„ÇíËøî„Åô„ÇÇ„ÅÆ„Åß„Åô„ÄÇ„Åì„Çå„ÅØÂ∞è„Åï„Å™Èñ¢Êï∞„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Åì„Å®„Åß„Éó„É≠„Ç∞„É©„É†„ÇíÊßãÁØâ„Åô„Çã„Å®„ÅÑ„ÅÜ„ÄÅÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅßÈçµ„Å®„Å™„ÇãËÄÉ„ÅàÊñπ„ÅÆ„Çà„ÅÑÂøúÁî®‰æã„Å´„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åæ„Åö„ÅØ‰ΩèÊâÄÈå≤„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åó„ÄÅË©≤ÂΩì„Åô„ÇãÂßìÂêç„ÇíÊåÅ„Å§È†ÖÁõÆ„Å†„Åë„Çí‰øùÊåÅ„Åô„Çã„Çà„ÅÜ„Å´„Åô„Çã„ÅÆ„Åå„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ„Åù„Çå„Åã„Çâ„ÄÅÁµêÊûú„ÅÆ„É™„Çπ„Éà„ÅÆÂÖàÈ†≠„ÅÆ (head)
Ë¶ÅÁ¥†„ÇíËøî„Åô„Å†„Åë„Åß„Åô„ÄÇ</p>
<p>„Åì„ÅÆÂ§ß„Åæ„Åã„Å™‰ªïÊßò„Å´Âæì„Å£„Å¶„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅÆÂûã„ÇíË®àÁÆó„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åæ„ÅöPSCi„ÇíËµ∑Âãï„Åó„ÄÅ <code>filter</code>Èñ¢Êï∞„Å® <code>head</code>Èñ¢Êï∞„ÅÆÂûã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.List
&gt; :type filter

forall a. (a -&gt; Boolean) -&gt; List a -&gt; List a

&gt; :type head

forall a. List a -&gt; Maybe a
</code></pre>
<p>Âûã„ÅÆÊÑèÂë≥„ÇíÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ„Åì„Çå„Çâ„ÅÆ2„Å§„ÅÆÂûã„ÅÆ‰∏ÄÈÉ®„ÇíÂèñ„ÇäÂá∫„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>filter</code>„ÅØ„Ç´„É™„ÉºÂåñ„Åï„Çå„Åü2ÂºïÊï∞„ÅÆÈñ¢Êï∞„Åß„Åô„ÄÇ
ÊúÄÂàù„ÅÆÂºïÊï∞„ÅØ„ÄÅ„É™„Çπ„Éà„ÅÆË¶ÅÁ¥†„ÇíÂèñ„Çä <code>Boolean</code>ÂÄ§„ÇíÁµêÊûú„Å®„Åó„Å¶Ëøî„ÅôÈñ¢Êï∞„Åß„Åô„ÄÇ
Á¨¨2ÂºïÊï∞„ÅØË¶ÅÁ¥†„ÅÆ„É™„Çπ„Éà„Åß„ÄÅËøî„ÇäÂÄ§„ÅØÂà•„ÅÆ„É™„Çπ„Éà„Åß„Åô„ÄÇ</p>
<p><code>head</code>„ÅØÂºïÊï∞„Å®„Åó„Å¶„É™„Çπ„Éà„Çí„Å®„Çä„ÄÅ <code>Maybe a</code>„Å®„ÅÑ„ÅÜ‰ªä„Åæ„ÅßË¶ã„Åü„Åì„Å®„Åå„Å™„ÅÑ„Çà„ÅÜ„Å™Âûã„ÇíËøî„Åó„Åæ„Åô„ÄÇ <code>Maybe a</code>„ÅØÂûã
<code>a</code>„ÅÆ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„ÄÅ„Å§„Åæ„Çä
<code>a</code>„ÅÆÂÄ§„ÇíÊåÅ„Å§„ÅãÊåÅ„Åü„Å™„ÅÑ„Åã„ÅÆ„Å©„Å°„Çâ„Åã„ÅÆÂÄ§„ÇíÁ§∫„Åó„Å¶„Åä„Çä„ÄÅJavaScript„ÅÆ„Çà„ÅÜ„Å™Ë®ÄË™û„ÅßÂÄ§„Åå„Å™„ÅÑ„Åì„Å®„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Çã
<code>null</code>„ÅÆÂûãÂÆâÂÖ®„Å™‰ª£ÊõøÊâãÊÆµ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Å§„ÅÑ„Å¶„ÅØÂæå„ÅÆÁ´†„ÅßË©≥„Åó„ÅèÊâ±„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>filter</code>„Å® <code>head</code>„ÅÆÂÖ®Áß∞ÈáèÂåñ„Åï„Çå„ÅüÂûã„ÅØ„ÄÅPureScript„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶Ê¨°„ÅÆ„Çà„ÅÜ„Å´<strong>ÁâπÊÆäÂåñ</strong> (specialized)
„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">filter :: (Entry -&gt; Boolean) -&gt; AddressBook -&gt; AddressBook

head :: AddressBook -&gt; Maybe Entry
</code></pre>
<p>Ê§úÁ¥¢„Åô„ÇãÈñ¢Êï∞„ÅÆÂºïÊï∞„Å®„Åó„Å¶Âßì„Å®ÂêçÂâç„ÇíÊ∏°„ÅôÂøÖË¶Å„Åå„ÅÇ„Çã„ÅÆ„ÇÇ„Çè„Åã„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>filter</code>„Å´Ê∏°„ÅôÈñ¢Êï∞„ÇÇÂøÖË¶Å„Å´„Å™„Çã„Åì„Å®„ÇÇ„Çè„Åã„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆÈñ¢Êï∞„Çí <code>filterEntry</code>„Å®Âëº„Å∂„Åì„Å®„Å´„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ <code>filterEntry</code>„ÅØ <code>Entry -&gt; Boolean</code>„Å®„ÅÑ„ÅÜÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ <code>filter filterEntry</code>„Å®„ÅÑ„ÅÜÈñ¢Êï∞ÈÅ©Áî®„ÅÆÂºè„ÅØ„ÄÅ <code>AddressBook -&gt; AddressBook</code>„Å®„ÅÑ„ÅÜÂûã„ÇíÊåÅ„Å§„Åß„Åó„Çá„ÅÜ„ÄÇ„ÇÇ„Åó„Åì„ÅÆÈñ¢Êï∞„ÅÆÁµêÊûú„Çí <code>head</code>Èñ¢Êï∞„Å´Ê∏°„Åô„Å®„ÄÅÂûã <code>Maybe Entry</code>„ÅÆÁµêÊûú„ÇíÂæó„Çã„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Åæ„Åß„ÅÆ„Åì„Å®„Çí„Åæ„Å®„ÇÅ„Çã„Å®„ÄÅÈñ¢Êï∞„ÅÆÂ¶•ÂΩì„Å™Âûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ
<code>findEntry</code>„Å®Âëº„Å∂„Åì„Å®„Å´„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">findEntry :: String -&gt; String -&gt; AddressBook -&gt; Maybe Entry
</code></pre>
<p><code>findEntry</code>„ÅØ„ÄÅÂßì„Å®ÂêçÂâç„ÅÆ2„Å§„ÅÆÊñáÂ≠óÂàó„ÄÅ„Åä„Çà„Å≥ <code>AddressBook</code>„ÇíÂºïÊï∞„Å´„Å®„Çä„ÄÅ
<code>Entry</code>„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥Âûã„ÅÆÂÄ§„ÇíÁµêÊûú„Å®„Åó„Å¶Ëøî„Åô„Å®„ÅÑ„ÅÜ„Åì„Å®„Çí„ÄÅ„Åì„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØË®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÁµêÊûú„ÅØ„ÄÅÂêçÂâç„Åå‰ΩèÊâÄÈå≤„ÅßÁô∫Ë¶ã„Åï„Çå„ÅüÂ†¥Âêà„Å´„ÅÆ„ÅøÂÄ§„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ</p>
<p>„Åù„Åó„Å¶„ÄÅ <code>findEntry</code>„ÅÆÂÆöÁæ©„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head (filter filterEntry book)
  where
    filterEntry :: Entry -&gt; Boolean
    filterEntry entry = entry.firstName == firstName &amp;&amp; entry.lastName == lastName
</code></pre>
<p>‰∏ÄÊ≠©„Åö„Å§„Åì„ÅÆ„Ç≥„Éº„Éâ„ÇíË™ø„Åπ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>findEntry</code>„ÅØ„ÄÅ
„Å©„Å°„Çâ„ÇÇÊñáÂ≠óÂàóÂûã„Åß„ÅÇ„Çã <code>firstName</code>„Å® <code>lastName</code>„ÄÅ
<code>AddressBook</code>Âûã„ÅÆ <code>book</code>„Å®„ÅÑ„ÅÜ3„Å§„ÅÆÂêçÂâç„Çí„Çπ„Ç≥„Éº„Éó„Å´Â∞éÂÖ•„Åó„Åæ„Åô„ÄÇ</p>
<p>ÂÆöÁæ©„ÅÆÂè≥Ëæ∫„Åß„ÅØ <code>filter</code>Èñ¢Êï∞„Å® <code>head</code>Èñ¢Êï∞„ÅåÁµÑ„ÅøÂêà„Çè„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åæ„ÅöÈ†ÖÁõÆ„ÅÆ„É™„Çπ„Éà„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åó„ÄÅ„Åù„ÅÆÁµêÊûú„Å´
<code>head</code>Èñ¢Êï∞„ÇíÈÅ©Áî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÁúüÂÅΩÂûã„ÇíËøî„ÅôÈñ¢Êï∞ <code>filterEntry</code>„ÅØ <code>where</code>ÁØÄ„ÅÆÂÜÖÈÉ®„ÅßË£úÂä©ÁöÑ„Å™Èñ¢Êï∞„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ„Åü„ÇÅ„ÄÅ
<code>filterEntry</code>Èñ¢Êï∞„ÅØ„Åì„ÅÆÂÆöÁæ©„ÅÆÂÜÖÈÉ®„Åß„ÅØ‰ΩøÁî®„Åß„Åç„Åæ„Åô„Åå„ÄÅÂ§ñÈÉ®„Åß„ÅØ‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Åæ„Åü„ÄÅ
<code>filterEntry</code>„ÅØ„Åù„Çå„ÇíÂåÖ„ÇÄÈñ¢Êï∞„ÅÆÂºïÊï∞„Å´‰æùÂ≠ò„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ <code>filterEntry</code>„ÅØÊåáÂÆö„Åï„Çå„Åü
<code>Entry</code>„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åô„Çã„Åü„ÇÅ„Å´ÂºïÊï∞ <code>firstName</code>„Å® <code>lastName</code>„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ <code>filterEntry</code>„Åå
<code>findEntry</code>„ÅÆÂÜÖÈÉ®„Å´„ÅÇ„Çã„Åì„Å®„ÅØÂøÖÈ†à„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÊúÄ‰∏ä‰Ωç„Åß„ÅÆÂÆ£Ë®Ä„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅÂøÖ„Åö„Åó„ÇÇ
<code>filterEntry</code>„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊåáÂÆö„Åó„Å™„Åè„Å¶„ÇÇ„Çà„ÅÑ„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åü„Å†„Åó„ÄÅ„Éâ„Ç≠„É•„É°„É≥„Éà„Å®„Åó„Å¶„ÇÇÂΩπ„Å´Á´ã„Å§„ÅÆ„ÅßÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊõ∏„Åè„Åì„Å®„ÅØÊé®Â•®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="‰∏≠ÁΩÆ„ÅÆÈñ¢Êï∞ÈÅ©Áî®"><a class="header" href="#‰∏≠ÁΩÆ„ÅÆÈñ¢Êï∞ÈÅ©Áî®">‰∏≠ÁΩÆ„ÅÆÈñ¢Êï∞ÈÅ©Áî®</a></h2>
<p>„Åì„Çå„Åæ„Åß„ÅäË©±„Åó„Åó„ÅüÈñ¢Êï∞„ÅÆ„Åª„Å®„Çì„Å©„ÅØ<strong>ÂâçÁΩÆ</strong>Èñ¢Êï∞ÈÅ©Áî®„Åß„Åó„Åü„ÄÇ
Èñ¢Êï∞Âêç„ÅåÂºïÊï∞„ÅÆ<strong>Ââç</strong>„Å´ÁΩÆ„Åã„Çå„Å¶„ÅÑ„Åü„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
‰æã„Åà„Å∞<code>insertEntry</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶<code>Entry</code> (<code>john</code>) „ÇíÁ©∫„ÅÆ<code>AddressBook</code>„Å´ËøΩÂä†„Åô„ÇãÂ†¥Âêà„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åë„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">&gt; book1 = insertEntry john emptyBook
</code></pre>
<p>„Åó„Åã„Åó„Åì„ÅÆÁ´†„Å´„ÅØ<strong>‰∏≠ÁΩÆ</strong><a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#binary-operators">2ÂºïÊï∞ÊºîÁÆóÂ≠ê</a>„ÅÆ‰æã„ÇÇÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞<code>filterEntry</code>„ÅÆÂÆöÁæ©‰∏≠„ÅÆ<code>==</code>ÊºîÁÆóÂ≠ê„Åß„ÄÅÊºîÁÆóÂ≠ê„Åå2„Å§„ÅÆÂºïÊï∞„ÅÆ<strong>Èñì</strong>„Å´ÁΩÆ„Åã„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂÆü„ÅØ„Åì„ÅÜ„Åó„Åü‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„ÅØPureScript„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Åß„ÄÅ
ËÉåÂæå„Å´„ÅÇ„Çã<strong>ÂâçÁΩÆ</strong>Áâà„ÅÆÂÆüË£Ö„Å∏„ÅÆ‰∏≠ÁΩÆÂà•Áß∞„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞<code>==</code>„ÅØ‰ª•‰∏ã„ÅÆË°å„Å´„Çà„ÇäÂâçÁΩÆ„ÅÆ<code>eq</code>Èñ¢Êï∞„ÅÆ‰∏≠ÁΩÆÂà•Áß∞„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">infix 4 eq as ==
</code></pre>
<p>„Åó„Åü„Åå„Å£„Å¶<code>filterEntry</code>‰∏≠„ÅÆ<code>entry.firstName == firstName</code>„ÅØ<code>eq entry.firstName firstName</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Çâ„Çå„Åæ„Åô„ÄÇ
„Åì„ÅÆÁØÄ„ÅÆÂæå„ÅÆ„Åª„ÅÜ„Åß‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„ÇíÂÆöÁæ©„Åô„Çã‰æã„Çí„ÇÇ„ÅÜÂ∞ë„ÅóÊäº„Åï„Åà„Åæ„Åô„ÄÇ</p>
<p>ÂâçÁΩÆÈñ¢Êï∞„ÇíÊºîÁÆóÂ≠ê„Å®„Åó„Å¶„ÅÆ‰∏≠ÁΩÆ„ÅÆ‰ΩçÁΩÆ„Å´ÁΩÆ„Åè„Å®„Çà„ÇäË™≠„Åø„ÇÑ„Åô„ÅÑ„Ç≥„Éº„Éâ„Å´„Å™„ÇãÂ†¥Èù¢„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åù„ÅÆ‰∏Ä‰æã„Åå<code>mod</code>Èñ¢Êï∞„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; mod 8 3
2
</code></pre>
<p>‰∏ä„ÅÆÁî®‰æã„ÅØÊ≠£„Åó„ÅèÂãï„Åç„Åæ„Åô„Åå„ÄÅË™≠„Åø„Å•„Çâ„ÅÑ„Åß„Åô„ÄÇ
„Çà„ÇäÈ¶¥Êüì„Åø„ÅÆ„ÅÇ„ÇãË°®Áèæ„ÅÆ‰ªïÊñπ„ÅØ„Äå8 mod 3„Äç„Åß„Åô„Åå„ÄÅ
„Éê„ÉÉ„ÇØ„Çπ„É©„ÉÉ„Ç∑„É• (`) „ÅÆ‰∏≠„Å´ÂâçÁΩÆÈñ¢Êï∞„ÇíÂåÖ„ÇÅ„Å∞„Åì„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åë„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; 8 `mod` 3
2
</code></pre>
<p>ÂêåÊßò„Å´„ÄÅ<code>insertEntry</code>„Çí„Éê„ÉÉ„ÇØ„Çπ„É©„ÉÉ„Ç∑„É•„ÅßÂåÖ„ÇÄ„Å®‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„Å´Â§â„Çè„Çä„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞‰ª•‰∏ã„ÅÆ<code>book1</code>„Å®<code>book2</code>„ÅØÁ≠â‰æ°„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">book1 = insertEntry john emptyBook
book2 = john `insertEntry` emptyBook
</code></pre>
<p>Ë§áÊï∞Âõû<code>insertEntry</code>„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„ÅßË§áÊï∞„ÅÆÈ†ÖÁõÆ„Åå„ÅÇ„Çã<code>AddressBook</code>„Çí‰Ωú„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„Åå„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ÂâçÁΩÆÈñ¢Êï∞
(<code>book3</code>) „Å®„Åó„Å¶ÈÅ©Áî®„Åô„Çã„Åã‰∏≠ÁΩÆÊºîÁÆóÂ≠ê (<code>book4</code>) „Å®„Åó„Å¶ÈÅ©Áî®„Åô„Çã„Åã„ÅÆ2Êäû„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))
book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))
</code></pre>
<p><code>insertEntry</code>„Å´‰∏≠ÁΩÆÊºîÁÆóÂ≠êÂà•Áß∞Ôºà„Åæ„Åü„ÅØÂêåÁæ©Ë™ûÔºâ„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆÊºîÁÆóÂ≠ê„ÅÆÂêçÂâç„Å´ÈÅ©ÂΩì„Å´<code>++</code>„ÇíÈÅ∏„Å≥„ÄÅ
<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#precedence">ÂÑ™ÂÖàÂ∫¶</a>„Çí<code>5</code>„Å´„Åó„ÄÅ
„Åù„Åó„Å¶<code>infixr</code>„Çí‰Ωø„Å£„Å¶Âè≥<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#associativity">ÁµêÂêà</a>„Å®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">infixr 5 insertEntry as ++
</code></pre>
<p>„Åì„ÅÆÊñ∞„Åó„ÅÑÊºîÁÆóÂ≠ê„Åß‰∏ä„ÅÆ<code>book4</code>„ÅÆ‰æã„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êõ∏„ÅçÁõ¥„Åõ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">book5 = john ++ (peggy ++ (ned ++ emptyBook))
</code></pre>
<p>„Åù„Åó„Å¶Êñ∞„Åó„ÅÑ<code>++</code>ÊºîÁÆóÂ≠ê„ÅåÂè≥ÁµêÂêà„Å™„ÅÆ„ÅßÊÑèÂë≥„ÇíÂ§â„Åà„Åö„Å´Êã¨Âºß„ÇíÈô§Âéª„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">book6 = john ++ peggy ++ ned ++ emptyBook
</code></pre>
<p>Êã¨Âºß„ÇíÊ∂àÂéª„Åô„Çã‰ªñ„ÅÆ„Çà„Åè„ÅÇ„ÇãÊäÄÊ≥ï„ÅØ„ÄÅ„ÅÑ„Å§„ÇÇ„ÅÆÂâçÁΩÆÈñ¢Êï∞„Å®‰∏ÄÁ∑í„Å´<code>apply</code>„ÅÆ‰∏≠ÁΩÆÊºîÁÆóÂ≠ê<code>$</code>„Çí‰Ωø„ÅÜ„Å®„ÅÑ„ÅÜ„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞Ââç„ÅÆ<code>book3</code>„ÅÆ‰æã„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Êõ∏„ÅçÁõ¥„Åõ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook
</code></pre>
<p>Êã¨Âºß„Çí<code>$</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Çã„ÅÆ„ÅØÂ§ßÊäµÂÖ•Âäõ„Åó„ÇÑ„Åô„Åè„Å™„Çä„Åæ„Åô„ÅóÔºàË≠∞Ë´ñ„ÅÆ‰ΩôÂú∞„Åå„ÅÇ„Çä„Åæ„Åô„ÅåÔºâË™≠„Åø„ÇÑ„Åô„Åè„Å™„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆË®òÂè∑„ÅÆÊÑèÂë≥„ÇíË¶ö„Åà„Çã„Åü„ÇÅ„ÅÆË®òÊÜ∂Ë°ì„Å®„Åó„Å¶„ÄÅ„Éâ„É´Ë®òÂè∑„Çí2„Å§„ÅÆÊã¨Âºß„Å´Êâì„Å°Ê∂à„ÅóÁ∑ö„ÅåÂºï„Åã„Çå„Åü„ÇÇ„ÅÆ„Å®Ë¶ã„Çã„Åì„Å®„Åß„ÄÅ„Åì„Çå„ÅßÊã¨Âºß„Åå‰∏çÂøÖË¶Å„Å´„Å™„Å£„Åü„ÅÆ„Å†„Å®Êé®Ê∏¨„Åß„Åç„Çã„Å®„ÅÑ„ÅÜÊñπÊ≥ï„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Å™„Åä„ÄÅ<code>($)</code>„ÅØË®ÄË™û„Å´„Éè„Éº„Éâ„Ç≥„Éº„Éâ„Åï„Çå„ÅüÁâπÂà•„Å™ÊßãÊñá„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
Âçò„Å´<code>apply</code>„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆÈÄöÂ∏∏„ÅÆÈñ¢Êï∞„ÅÆ„Åü„ÇÅ„ÅÆ‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„Åß„ÅÇ„Å£„Å¶„ÄÅ<code>Data.Function</code>„Åß‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">apply :: forall a b. (a -&gt; b) -&gt; a -&gt; b
apply f x = f x

infixr 0 apply as $
</code></pre>
<p><code>apply</code>Èñ¢Êï∞„ÅØ„ÄÅ‰ªñ„ÅÆÈñ¢Êï∞ÔºàÂûã„ÅØ<code>(a -&gt; b)</code>Ôºâ„ÇíÊúÄÂàù„ÅÆÂºïÊï∞„Å´„ÄÅÂÄ§ÔºàÂûã„ÅØ<code>a</code>Ôºâ„Çí2„Å§ÁõÆ„ÅÆÂºïÊï∞„Å´Âèñ„Å£„Å¶„ÄÅ„Åù„ÅÆÂÄ§„Å´ÂØæ„Åó„Å¶Èñ¢Êï∞„ÇíÂëº„Å≥„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„Åå‰Ωï„ÇâÊÑèÂë≥„ÅÆ„ÅÇ„Çã„Åì„Å®„Çí„Åó„Å¶„ÅÑ„Å™„ÅÑ„Çà„ÅÜ„Å†„Å®ÊÄù„Å£„Åü„Çâ„ÄÅ„Åæ„Å£„Åü„Åè„ÇÇ„Å£„Å¶Ê≠£„Åó„ÅÑ„Åß„ÅôÔºÅ
„Åì„ÅÆÈñ¢Êï∞„Åå„Å™„Åè„Å¶„ÇÇ„Éó„É≠„Ç∞„É©„É†„ÅØË´ñÁêÜÁöÑ„Å´Âêå‰∏Ä„Åß„ÅôÔºà<a href="https://en.wikipedia.org/wiki/Referential_transparency">ÂèÇÁÖßÈÄèÈÅéÊÄß</a>„ÇÇË¶ã„Å¶„Åè„Å†„Åï„ÅÑÔºâ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅÆÊßãÊñáÁöÑ„Å™Âà©‰æøÊÄß„ÅØ„Åù„ÅÆ‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„Å´Ââ≤„ÇäÂΩì„Å¶„Çâ„Çå„ÅüÁâπÂà•„Å™ÊÄßË≥™„Åã„Çâ„Åç„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>$</code>„ÅØÂè≥ÁµêÂêà (<code>infixr</code>) „Åß‰Ωé„ÅÑÂÑ™ÂÖàÂ∫¶ (<code>0</code>) „ÅÆÊºîÁÆóÂ≠ê„Åß„Åô„Åå„ÄÅ„Åì„Çå„Å´„Çà„ÇäÊ∑±„ÅÑÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„ÅüÈÅ©Áî®„Åã„ÇâÊã¨Âºß„ÅÆÊùü„ÇíÂâäÈô§„Åß„Åç„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Åï„Çâ„Å™„Çã<code>$</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„Å£„ÅüÊã¨ÂºßÈÄÄÊ≤ª„ÅÆÊ©ü‰ºö„ÅØ„ÄÅ‰ª•Ââç„ÅÆ<code>findEntry</code>Èñ¢Êï∞„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">findEntry firstName lastName book = head $ filter filterEntry book
</code></pre>
<p>„Åì„ÅÆË°å„Çí„Çà„ÇäÁ∞°ÊΩî„Å´Êõ∏„ÅçÊèõ„Åà„ÇãÊñπÊ≥ï„ÇíÊ¨°ÁØÄ„ÅÆ„ÄåÈñ¢Êï∞ÂêàÊàê„Äç„ÅßË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>ÂêçÂâç„ÅÆÁü≠„ÅÑ‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„ÇíÂâçÁΩÆÈñ¢Êï∞„Å®„Åó„Å¶‰Ωø„ÅÑ„Åü„Åë„Çå„Å∞Êã¨Âºß„ÅßÂõ≤„ÇÄ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; 8 + 3
11

&gt; (+) 8 3
11
</code></pre>
<p>„Åù„ÅÆ‰ª£„Çè„Çä„ÅÆÊâãÊÆµ„Å®„Åó„Å¶ÊºîÁÆóÂ≠ê„ÅØÈÉ®ÂàÜÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ„Åì„Çå„Å´„ÅØÂºè„ÇíÊã¨Âºß„ÅßÂõ≤„Çì„Åß<a href="https://github.com/purescript/documentation/blob/master/language/Syntax.md#operator-sections">ÊºîÁÆóÂ≠êÁØÄ</a>‰∏≠„ÅÆÂºïÊï∞„Å®„Åó„Å¶<code>_</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÁ∞°Âçò„Å™ÁÑ°ÂêçÈñ¢Êï∞„Çí‰Ωú„Çã„Çà„Çä‰æøÂà©„Å™ÊñπÊ≥ï„Å®„Åó„Å¶ËÄÉ„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„ÅôÔºà‰ª•‰∏ã„ÅÆ‰æã„Åß„ÅØ„Åù„Åì„Åã„ÇâÁÑ°ÂêçÈñ¢Êï∞„ÇíÂêçÂâç„Å´ÊùüÁ∏õ„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„ÇÇ„ÅØ„ÇÑÂà•„Å´ÁÑ°Âêç„Å®„ÇÇË®Ä„Åà„Å™„Åè„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÅåÔºâ„ÄÇ</p>
<pre><code class="language-text">&gt; add3 = (3 + _)
&gt; add3 2
5
</code></pre>
<p>„Åæ„Å®„ÇÅ„Çã„Å®„ÄÅ‰ª•‰∏ã„ÅØÂºïÊï∞„Å´<code>5</code>„ÇíÂä†„Åà„ÇãÈñ¢Êï∞„ÅÆÁ≠â‰æ°„Å™ÂÆöÁæ©„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">add5 x = 5 + x
add5 x = add 5 x
add5 x = (+) 5 x
add5 x = 5 `add` x
add5   = add 5
add5   = \x -&gt; 5 + x
add5   = (5 + _)
add5 x = 5 `(+)` x  -- „Çà„Åä„Éù„ÉÅ„ÄÅ‰∏≠ÁΩÆ„Å´ÁõÆ„Åå„Å™„ÅÑ„Å£„Å¶„ÅÑ„ÅÜ„Åã„Çâ„ÄÅ‰∏≠ÁΩÆ„ÅÆ‰∏≠„Å´‰∏≠ÁΩÆ„ÇíÂÖ•„Çå„Å®„ÅÑ„Åü„ÅúÔºÅ
</code></pre>
<h2 id="Èñ¢Êï∞ÂêàÊàê"><a class="header" href="#Èñ¢Êï∞ÂêàÊàê">Èñ¢Êï∞ÂêàÊàê</a></h2>
<p>„Ç§„Éº„ÇøÂ§âÊèõ„Çí‰Ωø„ÅÜ„Å® <code>insertEntry</code>Èñ¢Êï∞„ÇíÁ∞°Áï•Âåñ„Åß„Åç„Åü„ÅÆ„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅÂºïÊï∞„Çí„Çà„ÅèËÄÉÂØü„Åô„Çã„Å®
<code>findEntry</code>„ÅÆÂÆöÁæ©„ÇíÁ∞°Áï•Âåñ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÂºïÊï∞ <code>book</code>„ÅåÈñ¢Êï∞ <code>filter filterEntry</code>„Å´Ê∏°„Åï„Çå„ÄÅ„Åì„ÅÆÈÅ©Áî®„ÅÆÁµêÊûú„Åå
<code>head</code>„Å´Ê∏°„Åï„Çå„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åì„Çå„ÅØË®Ä„ÅÑ„Åã„Åü„ÇíÂ§â„Åà„Çå„Å∞„ÄÅ <code>filter filterEntry</code>„Å® <code>head</code>„ÅÆ<strong>ÂêàÊàê</strong>
(composition) „Å´ <code>book</code>„ÅåÊ∏°„Åï„Çå„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>PureScript„ÅÆÈñ¢Êï∞ÂêàÊàêÊºîÁÆóÂ≠ê„ÅØ <code>&lt;&lt;&lt;</code>„Å® <code>&gt;&gt;&gt;</code>„Åß„Åô„ÄÇÂâçËÄÖ„ÅØ„ÄåÈÄÜÊñπÂêë„ÅÆÂêàÊàê„Äç„Åß„ÅÇ„Çä„ÄÅÂæåËÄÖ„ÅØ„ÄåÈ†ÜÊñπÂêë„ÅÆÂêàÊàê„Äç„Åß„Åô„ÄÇ</p>
<p>„ÅÑ„Åö„Çå„Åã„ÅÆÊºîÁÆóÂ≠ê„Çí‰ΩøÁî®„Åó„Å¶ <code>findEntry</code>„ÅÆÂè≥Ëæ∫„ÇíÊõ∏„ÅçÊèõ„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇÈÄÜÈ†Ü„ÅÆÂêàÊàê„Çí‰ΩøÁî®„Åô„Çã„Å®„ÄÅÂè≥Ëæ∫„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">(head &lt;&lt;&lt; filter filterEntry) book
</code></pre>
<p>„Åì„ÅÆÂΩ¢Âºè„Å™„ÇâÊúÄÂàù„ÅÆÂÆöÁæ©„Å´„Ç§„Éº„ÇøÂ§âÊèõ„ÅÆÊäÄ„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ <code>findEntry</code>„ÅØÊúÄÁµÇÁöÑ„Å´Ê¨°„ÅÆ„Çà„ÅÜ„Å™ÂΩ¢Âºè„Å´Âà∞ÈÅî„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">findEntry firstName lastName = head &lt;&lt;&lt; filter filterEntry
  where
    ...
</code></pre>
<p>Âè≥Ëæ∫„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Åó„Å¶„ÇÇÂêå„Åò„ÅèÂ¶•ÂΩì„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">filter filterEntry &gt;&gt;&gt; head
</code></pre>
<p>„Å©„Å°„Çâ„Å´„Åó„Å¶„ÇÇ„ÄÅ„Åì„Çå„ÅØ„Äå<code>findEntry</code>„ÅØ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞Èñ¢Êï∞„Å® <code>head</code>Èñ¢Êï∞„ÅÆÂêàÊàê„Åß„ÅÇ„Çã„Äç„Å®„ÅÑ„ÅÜ
<code>findEntry</code>Èñ¢Êï∞„ÅÆ„Çè„Åã„Çä„ÇÑ„Åô„ÅÑÂÆöÁæ©„Çí‰∏é„Åà„Åæ„Åô„ÄÇ</p>
<p>„Å©„Å°„Çâ„ÅÆÂÆöÁæ©„ÅÆ„Åª„ÅÜ„Åå„Çè„Åã„Çä„ÇÑ„Åô„ÅÑ„Åã„ÅÆÂà§Êñ≠„ÅØ„Åä‰ªª„Åõ„Åó„Åæ„Åô„Åå„ÄÅ„Åì„ÅÆ„Çà„ÅÜ„Å´Èñ¢Êï∞„ÇíÈÉ®ÂìÅ„Å®„Åó„Å¶Êçâ„Åà„Çã„Å®ÊúâÁî®„Å™„Åì„Å®„Åå„Çà„Åè„ÅÇ„Çä„Åæ„Åô„ÄÇ
Èñ¢Êï∞„ÅØ„Å≤„Å®„Å§„ÅÆÂΩπÁõÆ„Å†„Åë„Çí„Åì„Å™„Åó„ÄÅÊ©üËÉΩ„ÇíÈñ¢Êï∞ÂêàÊàê„ÅßÁµÑ„ÅøÁ´ã„Å¶„Çã„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´„ÄÇ</p>
<h2 id="ÊºîÁøí-2"><a class="header" href="#ÊºîÁøí-2">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ<code>findEntry</code>Èñ¢Êï∞„ÅÆÂÆöÁæ©„ÅÆ‰∏ª„Å™ÈÉ®ÂàÜÂºè„ÅÆÂûã„ÇíÊõ∏„Åç‰∏ã„Åó„ÄÅ <code>findEntry</code>Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„Çà„ÅèÁêÜËß£„Åó„Å¶„ÅÑ„Çã„ÅãË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åü„Å®„Åà„Å∞„ÄÅ <code>findEntry</code>„ÅÆÂÆöÁæ©„ÅÆ„Å™„Åã„Å´„ÅÇ„Çã <code>head</code>Èñ¢Êï∞„ÅÆÂûã„ÅØ <code>AddressBook -&gt; Maybe Entry</code>„Å®ÁâπÊÆäÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÂïèÈ°å„Å´„ÅØ„ÉÜ„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÈñ¢Êï∞<code>findEntryByStreet :: String -&gt; AddressBook -&gt; Maybe Entry</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ‰∏é„Åà„Çâ„Çå„ÅüÈÄö„Çä„ÅÆ‰ΩèÊâÄ„Åã„Çâ<code>Entry</code>„ÇíË¶ã‰ªò„ÅëÂá∫„Åó„Åæ„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>findEntry</code>„Å´„ÅÇ„ÇãÊó¢Â≠ò„ÅÆ„Ç≥„Éº„Éâ„ÇíÂÜçÂà©Áî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÂÆüË£Ö„Åó„ÅüÈñ¢Êï∞„ÇíPSCi„Å®<code>spago test</code>„ÇíËµ∞„Çâ„Åõ„Çã„Åì„Å®„Åß„ÉÜ„Çπ„Éà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>filterEntry</code>„ÇíÔºà<code>&lt;&lt;&lt;</code>„ÇÑ<code>&gt;&gt;&gt;</code>„Çí‰Ωø„Å£„ÅüÔºâÂêàÊàê„ÅßÁΩÆ„ÅçÊèõ„Åà„Å¶„ÄÅ<code>findEntryByStreet</code>„ÇíÊõ∏„ÅçÁõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÂêàÊàê„ÅÆÂØæË±°„ÅØ„ÄÅ„Éó„É≠„Éë„ÉÜ„Ç£ÂèñÂæóÂ≠êÔºà<code>_.</code>Ë®òÊ≥ï„Çí‰Ωø„ÅÑ„Åæ„ÅôÔºâ„Å®„ÄÅ‰∏é„Åà„Çâ„Çå„ÅüÊñáÂ≠óÂàóÂºïÊï∞„Åå‰∏é„Åà„Çâ„Çå„ÅüÈÄö„Çä„ÅÆ‰ΩèÊâÄ„Å´Á≠â„Åó„ÅÑ„Åã„ÇíÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞„Åß„Åô„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÊåáÂÆö„Åï„Çå„ÅüÂêçÂâç„Åå <code>AddressBook</code>„Å´Â≠òÂú®„Åô„Çã„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„Å¶ÁúüÂÅΩÂÄ§„ÅßËøî„ÅôÈñ¢Êï∞<code>isInBook</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö„É™„Çπ„Éà„ÅåÁ©∫„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„Çã <code>Data.List.null</code>Èñ¢Êï∞„ÅÆÂûã„ÇíPSCi„ÅßË™ø„Åπ„Å¶„Åø„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
<li>ÔºàÈõ£„Åó„ÅÑÔºâ„ÄåÈáçË§á„Äç„Åó„Å¶„ÅÑ„ÇãÈ†ÖÁõÆ„Çí‰ΩèÊâÄÈå≤„Åã„ÇâÂâäÈô§„Åô„ÇãÈñ¢Êï∞ <code>removeDuplicates</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
È†ÖÁõÆ„ÅåÂêå„ÅòÂßìÂêç„ÇíÂÖ±Êúâ„Åó„Å¶„ÅÑ„Çå„Å∞<code>address</code>„Éï„Ç£„Éº„É´„Éâ„Å´Èñ¢‰øÇ„Å™„Åè„ÄÅÈ†ÖÁõÆ„ÅåÈáçË§á„Åó„Å¶„ÅÑ„Çã„Å®ËÄÉ„Åà„Åæ„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöÈñ¢Êï∞ <code>Data.List.nubBy</code>„ÅÆÂûã„Çí„ÄÅPSCi„Çí‰ΩøÁî®„Åó„Å¶Ë™ø„Åπ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÂÄ§ÂêåÂ£´„ÅÆÁ≠â‰æ°ÊÄß„ÇíÂÆöÁæ©„Åô„ÇãËø∞Ë™ûÈñ¢Êï∞„Å´Âü∫„Å•„ÅÑ„Å¶„É™„Çπ„Éà„Åã„ÇâÈáçË§áË¶ÅÁ¥†„ÇíÂâäÈô§„Åó„Åæ„Åô„ÄÇ
„Å™„Åä„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÈáçË§á„Åô„ÇãÈ†ÖÁõÆ„ÅÆÈõÜÂêà„Å´„Åä„Åë„ÇãÊúÄÂàù„ÅÆË¶ÅÁ¥†Ôºà„É™„Çπ„Éà„ÅÆÂÖàÈ†≠„Å´ÊúÄ„ÇÇËøë„ÅÑÔºâ„Åå‰øùÊåÅ„Åô„ÇãÈ†ÖÁõÆ„Åß„Åô„ÄÇ</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-1"><a class="header" href="#„Åæ„Å®„ÇÅ-1">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÊñ∞„Åó„ÅÑÊ¶ÇÂøµ„Çí„ÅÑ„Åè„Å§„ÅãÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇ</p>
<ul>
<li>ÂØæË©±ÁöÑ„É¢„Éº„ÉâPSCi„Çí‰ΩøÁî®„Åó„Å¶Èñ¢Êï∞„ÇíË™ø„Åπ„Çã„Å™„Å©ÊÄù„ÅÑ„Å§„ÅÑ„Åü„Åì„Å®„ÇíË©¶„ÅôÊñπÊ≥ï</li>
<li>Ê§úË®º„ÇÑÂÆüË£Ö„ÅÆÈÅìÂÖ∑„Å®„Åó„Å¶„ÅÆÂûã„ÅÆÂΩπÂâ≤</li>
<li>Â§öÂºïÊï∞Èñ¢Êï∞„ÇíË°®Áèæ„Åô„Çã„ÄÅ„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„ÅÆ‰ΩøÁî®</li>
<li>Èñ¢Êï∞ÂêàÊàê„ÅßÂ∞è„Åï„Å™ÈÉ®ÂìÅ„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶„ÅÆ„Éó„É≠„Ç∞„É©„É†„ÅÆÊßãÁØâ</li>
<li><code>where</code>ÁØÄ„ÇíÂà©Áî®„Åó„Åü„Ç≥„Éº„Éâ„ÅÆÊßãÈÄ†Âåñ</li>
<li><code>Maybe</code>Âûã„Çí‰ΩøÁî®„Åó„Å¶nullÂÄ§„ÇíÂõûÈÅø„Åô„ÇãÊñπÊ≥ï</li>
<li>„Ç§„Éº„ÇøÂ§âÊèõ„ÇÑÈñ¢Êï∞ÂêàÊàê„ÅÆ„Çà„ÅÜ„Å™ÊâãÊ≥ï„ÇíÂà©Áî®„Åó„Åü„ÄÅ„Çà„Çä„Çè„Åã„Çä„ÇÑ„Åô„ÅÑ„Ç≥„Éº„Éâ„Å∏„ÅÆ
ÂÜçÊßãÊàê</li>
</ul>
<p>Ê¨°„ÅÆÁ´†„Åã„Çâ„ÅØ„ÄÅ„Åì„Çå„Çâ„ÅÆËÄÉ„Åà„Åã„Åü„Å´Âü∫„Å•„ÅÑ„Å¶ÈÄ≤„ÇÅ„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ÂÜçÂ∏∞„Éû„ÉÉ„ÉóÁï≥„ÅøËæº„Åø"><a class="header" href="#ÂÜçÂ∏∞„Éû„ÉÉ„ÉóÁï≥„ÅøËæº„Åø">ÂÜçÂ∏∞„ÄÅ„Éû„ÉÉ„Éó„ÄÅÁï≥„ÅøËæº„Åø</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-2"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-2">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÊßãÈÄ†Âåñ„Åô„Çã„Å®„Åç„Å´ÂÜçÂ∏∞Èñ¢Êï∞„Çí„Å©„ÅÆ„Çà„ÅÜ„Å´‰Ωø„ÅÜ„Åã„Å´„Å§„ÅÑ„Å¶Ë¶ã„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇÂÜçÂ∏∞„ÅØÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÂü∫Êú¨ÁöÑ„Å™ÊâãÊ≥ï„Åß„ÅÇ„Çä„ÄÅ„Åì„ÅÆÊú¨„ÅÆÂÖ®‰Ωì„Å´‰∫ô„Å£„Å¶‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ</p>
<p>„Åæ„Åü„ÄÅPureScript„ÅÆÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„Åã„ÇâÊ®ôÊ∫ñÁöÑ„Å™Èñ¢Êï∞„Çí„ÅÑ„Åè„Å§„ÅãÂèñ„ÇäÊâ±„ÅÑ„Åæ„Åô„ÄÇ
<code>map</code>„ÇÑ<code>fold</code>„Å®„ÅÑ„Å£„ÅüÈñ¢Êï∞„Å†„Åë„Åß„Å™„Åè„ÄÅ<code>filter</code>„ÇÑ<code>concatMap</code>„Å®„ÅÑ„Å£„ÅüÁâπÂà•„Å™Â†¥Âêà„Å´„Åä„ÅÑ„Å¶‰æøÂà©„Å™„ÇÇ„ÅÆ„Å´„Å§„ÅÑ„Å¶„ÇÇË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ‰ªÆÊÉ≥ÁöÑ„Å™„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„ÇíÊìç‰Ωú„Åô„ÇãÈñ¢Êï∞„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíÂãïÊ©ü‰ªò„Åë„Å´Áî®„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆÁ´†„ÅßÂ≠¶„Å∂ÊâãÊ≥ï„ÇíÂøúÁî®„Åó„Å¶„ÄÅÊì¨‰ººÁöÑ„Å™„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„Å£„Å¶Ë°®„Åï„Çå„Çã„Éï„Ç°„Ç§„É´„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞„ÇíË®òËø∞„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-1"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-1">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ<code>src/Data/Path.purs</code>„Å®<code>test/Examples.purs</code>„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Data.Path</code>„É¢„Ç∏„É•„Éº„É´„ÅØ‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„ÅÆ„É¢„Éá„É´„ÇíÂê´„Åø„Åæ„Åô„ÄÇ
„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅÆÂÜÖÂÆπ„ÇíÂ§âÊõ¥„Åô„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
ÊºîÁøí„Å∏„ÅÆËß£Á≠î„ÅØ<code>Test.MySolutions</code>„É¢„Ç∏„É•„Éº„É´„Å´ÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åù„Çå„Åû„Çå„ÅÆÊºîÁøí„ÇíÂÆå‰∫Ü„Åï„Åõ„Å§„Å§ÈÉΩÂ∫¶<code>Test.Main</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅÇ„ÇãÂØæÂøú„Åô„Çã„ÉÜ„Çπ„Éà„ÇíÊúâÂäπ„Å´„Åó„ÄÅ
<code>spago test</code>„ÇíËµ∞„Çâ„Åõ„Çã„Åì„Å®„ÅßËß£Á≠î„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´„ÅØ‰ª•‰∏ã„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>maybe</code>: <code>Maybe</code>ÂûãÊßãÁØâÂ≠ê„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>arrays</code>: ÈÖçÂàó„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>strings</code>: JavaScript„ÅÆÊñáÂ≠óÂàó„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>foldable-traversable</code>: ÈÖçÂàó„ÇÑ„Åù„ÅÆ‰ªñ„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„ÇíÁï≥„ÅøËæº„ÇÄÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï
„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>console</code>: „Ç≥„É≥„ÇΩ„Éº„É´„Å∏„ÅÆÂá∫Âäõ„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
</ul>
<h2 id="Â∞éÂÖ•-1"><a class="header" href="#Â∞éÂÖ•-1">Â∞éÂÖ•</a></h2>
<p>ÂÜçÂ∏∞„ÅØ‰∏ÄËà¨„ÅÆ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Åß„ÇÇÈáçË¶Å„Å™ÊâãÊ≥ï„Åß„Åô„Åå„ÄÅÁâπ„Å´Á¥îÁ≤ãÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Åß„ÅØÂΩì„Åü„ÇäÂâç„ÅÆ„Çà„ÅÜ„Å´Áî®„ÅÑ„Çâ„Çå„Åæ„Åô„ÄÇ„Åì„ÅÆÁ´†„ÅßË¶ã„Å¶„ÅÑ„Åè„Çà„ÅÜ„Å´„ÄÅÂÜçÂ∏∞„ÅØ„Éó„É≠„Ç∞„É©„É†„ÅÆÂ§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„ÇíÊ∏õ„Çâ„Åô„Åü„ÇÅ„Å´ÂΩπÁ´ã„Å§„Åã„Çâ„Åß„Åô„ÄÇ</p>
<p>ÂÜçÂ∏∞„ÅØ<strong>ÂàÜÂâ≤Áµ±Ê≤ª</strong> (divide and conquer) Êà¶Áï•„Å®ÂØÜÊé•„Å™Èñ¢‰øÇ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÂàÜÂâ≤Áµ±Ê≤ª„Å®„ÅØ„Åô„Å™„Çè„Å°„ÄÅ‰Ωï„Çâ„Åã„ÅÆÂÖ•Âäõ„Å®„Åó„Å¶„ÅÆÂïèÈ°å„ÇíËß£„Åè„Å´„ÅÇ„Åü„Çä„ÄÅÂÖ•Âäõ„ÇíÂ∞è„Åï„Å™ÈÉ®ÂàÜ„Å´ÂàÜÂâ≤„Åó„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÈÉ®ÂàÜ„Å´„Å§„ÅÑ„Å¶ÂïèÈ°å„ÇíËß£„ÅÑ„Å¶„ÄÅÈÉ®ÂàÜ„Åî„Å®„ÅÆÁ≠î„Åà„Åã„ÇâÊúÄÁµÇÁöÑ„Å™Á≠î„Åà„ÇíÁµÑ„ÅøÁ´ã„Å¶„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØ„ÄÅPureScript„Å´„Åä„Åë„ÇãÂÜçÂ∏∞„ÅÆÁ∞°Âçò„Å™‰æã„Çí„ÅÑ„Åè„Å§„ÅãË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>Ê¨°„ÅØ<strong>Èöé‰πóÈñ¢Êï∞</strong> (factorial function) „ÅÆ„Çà„Åè„ÅÇ„Çã‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial n =
  if n == 0 then
    1
  else
    n * factorial (n - 1)
</code></pre>
<p>ÈÉ®ÂàÜÂïèÈ°å„Å∏ÂïèÈ°å„ÇíÂàÜÂâ≤„Åô„Çã„Åì„Å®„Å´„Çà„Å£„Å¶Èöé‰πóÈñ¢Êï∞„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´Ë®àÁÆó„Åï„Çå„Çã„Åã„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ„Çà„ÇäÂ∞è„Åï„ÅÑÊï∞„Å∏„Å®Èöé‰πó„ÇíË®àÁÆó„Åó„Å¶„ÅÑ„Åè„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ„Çº„É≠„Å´Âà∞ÈÅî„Åô„Çã„Å®„ÄÅÁ≠î„Åà„ÅØÁõ¥„Å°„Å´Ê±Ç„Åæ„Çä„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„ÅØ„ÄÅ<strong>„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÈñ¢Êï∞</strong> (Fibonacci function) „ÇíË®àÁÆó„Åô„Çã„Å®„ÅÑ„ÅÜ„ÄÅ„Åì„Çå„Åæ„Åü„Çà„Åè„ÅÇ„Çã‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">fib :: Int -&gt; Int
fib n =
  if n == 0 then
    0
  else if n == 1 then
    1
  else
    fib (n - 1) + fib (n - 2)
</code></pre>
<p>„ÇÑ„ÅØ„Çä„ÄÅÈÉ®ÂàÜÂïèÈ°å„ÅÆËß£Ê±∫Á≠ñ„ÇíËÄÉ„Åà„Çã„Åì„Å®„ÅßÂÖ®‰Ωì„ÇíËß£Ê±∫„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Å®„Åç„ÄÅ<code>fib (n - 1)</code>„Å®<code>fib (n - 2)</code>„Å®„ÅÑ„ÅÜÂºè„Å´ÂØæÂøú„Åó„Åü„ÄÅ2„Å§„ÅÆÈÉ®ÂàÜÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆ2„Å§„ÅÆÈÉ®ÂàÜÂïèÈ°å„ÅåËß£Ê±∫„Åï„Çå„Å¶„ÅÑ„Çå„Å∞„ÄÅ„Åì„ÅÆÈÉ®ÂàÜÁöÑ„Å™Á≠î„Åà„ÇíÂä†ÁÆó„Åô„Çã„Åì„Å®„Åß„ÄÅÂÖ®‰Ωì„ÅÆÁ≠î„Åà„ÇíÁµÑ„ÅøÁ´ã„Å¶„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Å™„Åä‰∏ä„ÅÆ<code>factorial</code>„Å®<code>fib</code>„ÅÆ‰æã„ÅØÊÑèÂõ≥ÈÄö„Çä„Å´Âãï„Åç„Åæ„Åô„Åå„ÄÅ
„Çà„ÇäÊÖ£ÁøíÁöÑ„Å™ÂÆüË£Ö„Åß„ÅØ<code>if</code>„ÇÑ<code>then</code>„ÇÑ<code>else</code>„Çí‰Ωø„ÅÜ‰ª£„Çè„Çä„Å´„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰Ωø„ÅÜ„ÇÇ„ÅÆ„Åß„Åó„Çá„ÅÜ„ÄÇ
„Éë„Çø„Éº„É≥ÁÖßÂêà„ÅÆÊäÄÊ≥ï„ÅØÂæå„ÅÆÁ´†„Åß„ÅäË©±„Åó„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="ÈÖçÂàó‰∏ä„Åß„ÅÆÂÜçÂ∏∞"><a class="header" href="#ÈÖçÂàó‰∏ä„Åß„ÅÆÂÜçÂ∏∞">ÈÖçÂàó‰∏ä„Åß„ÅÆÂÜçÂ∏∞</a></h2>
<p>ÂÜçÂ∏∞Èñ¢Êï∞„ÅÆÂÆöÁæ©„ÅØ„ÄÅ<code>Int</code>Âûã„Å†„Åë„Å´ÈôêÂÆö„Åï„Çå„Çã„ÇÇ„ÅÆ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„ÇìÔºÅ
Êú¨Êõ∏„ÅÆÂæåÂçä„Åß<strong>„Éë„Çø„Éº„É≥ÁÖßÂêà</strong> (pattern matching)
„ÇíÊâ±„ÅÜ„Å®„Åç„Å´„ÄÅ„ÅÑ„Çç„ÅÑ„Çç„Å™„Éá„Éº„ÇøÂûã„ÅÆ‰∏ä„Åß„ÅÆÂÜçÂ∏∞Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶Ë¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„Åå„ÄÅ„Åì„Åì„Åß„ÅØÊï∞„Å®ÈÖçÂàó„Å´Èôê„Å£„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<p>ÂÖ•Âäõ„Åå„Çº„É≠„Åß„Å™„ÅÑ„Åã„Å©„ÅÜ„Åã„Å´„Å§„ÅÑ„Å¶ÂàÜÂ≤ê„Åô„Çã„ÅÆ„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅÈÖçÂàó„ÅÆÂ†¥Âêà„ÇÇ„ÄÅÈÖçÂàó„ÅåÁ©∫„Åß„Å™„ÅÑ„Åã„Å©„ÅÜ„Åã„Å´„Å§„ÅÑ„Å¶ÂàÜÂ≤ê„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇÂÜçÂ∏∞„Çí‰ΩøÁî®„Åó„Å¶ÈÖçÂàó„ÅÆÈï∑„Åï„ÇíË®àÁÆó„Åô„ÇãÊ¨°„ÅÆÈñ¢Êï∞„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Prelude

import Data.Array (null, tail)
import Data.Maybe (fromMaybe)

length :: forall a. Array a -&gt; Int
length arr =
  if null arr then
    0
  else
    1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„Åß„ÅØÈÖçÂàó„ÅåÁ©∫„Åã„Å©„ÅÜ„Åã„ÅßÂàÜÂ≤ê„Åô„Çã„Åü„ÇÅ„Å´<code>if ... then ... else</code>Âºè„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ<code>null</code>Èñ¢Êï∞„ÅØÈÖçÂàó„ÅåÁ©∫„ÅÆ„Å®„Åç„Å´<code>true</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ
Á©∫„ÅÆÈÖçÂàó„ÅÆÈï∑„Åï„ÅØ„Çº„É≠„Åß„ÅÇ„Çä„ÄÅÁ©∫„Åß„Å™„ÅÑÈÖçÂàó„ÅÆÈï∑„Åï„ÅØÈÖçÂàó„ÅÆÂÖàÈ†≠„ÇíÂèñ„ÇäÈô§„ÅÑ„ÅüÊÆã„Çä„ÅÆÈÉ®ÂàÜ„ÅÆÈï∑„Åï„Çà„Çä1Â§ß„Åç„ÅÑ„Å®„ÅÑ„ÅÜ„Çè„Åë„Åß„Åô„ÄÇ</p>
<p><code>tail</code>Èñ¢Êï∞„ÅØ‰∏é„Åà„Çâ„Çå„ÅüÈÖçÂàó„Åã„ÇâÊúÄÂàù„ÅÆË¶ÅÁ¥†„ÇíÈô§„ÅÑ„Åü„ÇÇ„ÅÆ„Çí<code>Maybe</code>„Å´ÂåÖ„Çì„ÅßËøî„Åó„Åæ„Åô„ÄÇ
ÈÖçÂàó„ÅåÁ©∫„Åß„ÅÇ„Çå„Å∞Ôºà„Å§„Åæ„ÇäÂ∞æÈ∞≠„Åå„ÅÇ„Çä„Åæ„Åõ„ÇìÔºâ<code>Nothing</code>„ÅåËøî„Çä„Åæ„Åô„ÄÇ
<code>fromMaybe</code>Èñ¢Êï∞„ÅØÊó¢ÂÆöÂÄ§„Å®<code>Maybe</code>ÂÄ§„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ
ÂæåËÄÖ„Åå<code>Nothing</code>„Åß„ÅÇ„Çå„Å∞Êó¢ÂÆöÁæ©„ÇíËøî„Åó„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞<code>Just</code>„Å´ÂåÖ„Åæ„Çå„ÅüÂÄ§„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>JavaScript„ÅßÈÖçÂàó„ÅÆÈï∑„Åï„ÇíË™ø„Åπ„Çã„ÅÆ„Å´„ÅØ„ÄÅ„Åì„ÅÆ‰æã„ÅØ„Å©„ÅÜ„Åø„Å¶„ÇÇÂÆüÁî®ÁöÑ„Å™ÊñπÊ≥ï„Å®„ÅØ„ÅÑ„Åà„Åæ„Åõ„Çì„Åå„ÄÅÊ¨°„ÅÆÊºîÁøí„ÇíÂÆå‰∫Ü„Åô„Çã„Åü„ÇÅ„ÅÆÊâã„Åå„Åã„Çä„Å®„Åó„Å¶„ÅØÂÖÖÂàÜ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="ÊºîÁøí-3"><a class="header" href="#ÊºîÁøí-3">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâÂÖ•Âäõ„ÅåÂÅ∂Êï∞„Åß„ÅÇ„Çã„Å®„Åç„ÄÅ„Åã„Å§„Åù„ÅÆ„Å®„Åç„Å´Èôê„Çä<code>true</code>„Å´Ëøî„Åô„Çà„ÅÜ„Å™ÂÜçÂ∏∞Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
<li>ÔºàÂ∞ë„ÅóÈõ£„Åó„ÅÑÔºâÈÖçÂàóÂÜÖ„ÅÆÂÅ∂Êï∞„ÅÆÊï∞„ÇíÊï∞„Åà„ÇãÂÜçÂ∏∞Èñ¢Êï∞<code>countEven</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>Data.Array</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ<code>head</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Å®„ÄÅÁ©∫„Åß„Å™„ÅÑÈÖçÂàó„ÅÆÊúÄÂàù„ÅÆË¶ÅÁ¥†„ÇíË¶ã„Å§„Åë„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</li>
</ol>
<h2 id="„Éû„ÉÉ„Éó"><a class="header" href="#„Éû„ÉÉ„Éó">„Éû„ÉÉ„Éó</a></h2>
<p><code>map</code>Èñ¢Êï∞„ÅØÈÖçÂàó„Å´ÂØæ„Åô„ÇãÂÜçÂ∏∞Èñ¢Êï∞„ÅÆ„Å≤„Å®„Å§„Åß„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„Çí‰Ωø„ÅÜ„Å®„ÄÅÈÖçÂàó„ÅÆÂêÑË¶ÅÁ¥†„Å´È†ÜÁï™„Å´Èñ¢Êï∞„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åß„ÄÅÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÇíÂ§âÊèõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åù„ÅÆ„Åü„ÇÅ„ÄÅÈÖçÂàó„ÅÆ<strong>ÂÜÖÂÆπ</strong>„ÅØÂ§âÊõ¥„Åï„Çå„Åæ„Åô„Åå„ÄÅ„Åù„ÅÆ<strong>ÂΩ¢Áä∂</strong>Ôºà„Åì„Åì„Åß„ÅØ„ÄåÈï∑„Åï„ÄçÔºâ„ÅØ‰øùÂ≠ò„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>Êú¨Êõ∏„ÅÆÂæåÂçä„Åß<strong>Âûã„ÇØ„É©„Çπ</strong> (type class) „ÅÆÂÜÖÂÆπ„ÇíÊäº„Åï„Åà„Çã„Å®„Åç„ÄÅ
<code>map</code>Èñ¢Êï∞„ÅåÂΩ¢Áä∂‰øùÂ≠òÈñ¢Êï∞„ÅÆ„Çà„Çä‰∏ÄËà¨ÁöÑ„Å™ÊßòÂºè„ÅÆ‰∏Ä‰æã„Åß„ÅÇ„Çã„Åì„Å®„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ<strong>Èñ¢Êâã</strong> (functor) „Å®Âëº„Å∞„Çå„ÇãÂûãÊßãÁØâÂ≠ê„ÅÆ„ÇØ„É©„Çπ„ÇíÂ§âÊèõ„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØ„ÄÅPSCi„Åß<code>map</code>Èñ¢Êï∞„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; map (\n -&gt; n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p><code>map</code>„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Çã„Åã„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÊúÄÂàù„ÅÆÂºïÊï∞„Å´„ÅØÈÖçÂàó‰∏ä„Åß„ÄåÂÜô„Åô„ÄçÈñ¢Êï∞„ÄÅÁ¨¨2ÂºïÊï∞„Å´„ÅØÈÖçÂàó„Åù„ÅÆ„ÇÇ„ÅÆ„ÇíÊ∏°„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="‰∏≠ÁΩÆÊºîÁÆóÂ≠ê"><a class="header" href="#‰∏≠ÁΩÆÊºîÁÆóÂ≠ê">‰∏≠ÁΩÆÊºîÁÆóÂ≠ê</a></h2>
<p>„Éê„ÉÉ„ÇØ„ÇØ„Ç©„Éº„Éà„ÅßÈñ¢Êï∞Âêç„ÇíÂõ≤„ÇÄ„Å®„ÄÅÂÜô„ÅôÈñ¢Êï∞„Å®ÈÖçÂàó„ÅÆÈñì„Å´„ÄÅ<code>map</code>Èñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) `map` [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>„Åì„ÅÆÊßãÊñá„ÅØ<strong>‰∏≠ÁΩÆÈñ¢Êï∞ÈÅ©Áî®</strong>„Å®Âëº„Å∞„Çå„ÄÅ„Å©„Çì„Å™Èñ¢Êï∞„Åß„ÇÇ„Åì„ÅÆ„Çà„ÅÜ„Å´‰∏≠ÁΩÆ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
ÊôÆÈÄö„ÅØ2ÂºïÊï∞„ÅÆÈñ¢Êï∞„Å´ÂØæ„Åó„Å¶‰Ωø„ÅÜ„ÅÆ„ÅåÊúÄÈÅ©„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>ÈÖçÂàó„ÇíÊâ±„ÅÜ„Å®„Åç„ÅØ„ÄÅ<code>map</code>Èñ¢Êï∞„Å®Á≠â‰æ°„Å™<code>&lt;$&gt;</code>„Å®„ÅÑ„ÅÜÊºîÁÆóÂ≠ê„ÅåÂ≠òÂú®„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆÊºîÁÆóÂ≠ê„ÅØ‰ªñ„ÅÆ‰∫åÈ†ÖÊºîÁÆóÂ≠ê„Å®Âêå„Åò„Çà„ÅÜ„Å´‰∏≠ÁΩÆ„Åß‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; (\n -&gt; n + 1) &lt;$&gt; [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
</code></pre>
<p>„Åù„Çå„Åß„ÅØ<code>map</code>„ÅÆÂûã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; :type map
forall a b f. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>ÂÆü„ÅØ<code>map</code>„ÅÆÂûã„ÅØ„ÄÅ„Åì„ÅÆÁ´†„ÅßÂøÖË¶Å„Å®„Åï„Çå„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„Çà„Çä„ÇÇ‰∏ÄËà¨ÁöÑ„Å™Âûã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ‰ªäÂõû„ÅÆÁõÆÁöÑ„Åß„ÅØ„ÄÅ<code>map</code>„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„Å£„Å®ÂÖ∑‰ΩìÁöÑ„Å™Âûã„Åß„ÅÇ„Çã„Åã„ÅÆ„Çà„ÅÜ„Å´ËÄÉ„Åà„Çã„Å®„Çà„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">forall a b. (a -&gt; b) -&gt; Array a -&gt; Array b
</code></pre>
<p>„Åì„ÅÆÂûã„Åß„ÅØ„ÄÅ<code>map</code>Èñ¢Êï∞„Å´ÈÅ©Áî®„Åô„Çã„Å®„Åç„Å´„ÅØ<code>a</code>„Å®<code>b</code>„Å®„ÅÑ„ÅÜ2„Å§„ÅÆÂûã„ÇíËá™Áî±„Å´ÈÅ∏„Å∂„Åì„Å®„Åå„Åß„Åç„Çã„ÄÅ„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇÇÁ§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>a</code>„ÅØÂÖÉ„ÅÆÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÅÆÂûã„Åß„ÄÅ<code>b</code>„ÅØÁõÆÁöÑ„ÅÆÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÅÆÂûã„Åß„Åô„ÄÇ
„ÇÇ„Å£„Å®Ë®Ä„Åà„Å∞„ÄÅ<code>map</code>„ÅåÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÅÆÂûã„Çí‰øùÂ≠ò„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Çè„Åë„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Åü„Å®„Åà„Å∞„ÄÅ<code>map</code>„Çí‰ΩøÁî®„Åô„Çã„Å®Êï∞ÂÄ§„ÇíÊñáÂ≠óÂàó„Å´Â§âÊèõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; show &lt;$&gt; [1, 2, 3, 4, 5]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>‰∏≠ÁΩÆÊºîÁÆóÂ≠ê<code>&lt;$&gt;</code>„ÅØÁâπÂà•„Å™ÊßãÊñá„ÅÆ„Çà„ÅÜ„Å´Ë¶ã„Åà„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åå„ÄÅÂÆü„ÅØPureScript„ÅÆÊôÆÈÄö„ÅÆÈñ¢Êï∞„ÅÆÂà•Áß∞„Åß„Åô„ÄÇ
‰∏≠ÁΩÆÊßãÊñá„Çí‰ΩøÁî®„Åó„ÅüÂçò„Å™„Çã<strong>ÈÅ©Áî®</strong>„Å´„Åô„Åé„Åæ„Åõ„Çì„ÄÇ
ÂÆüÈöõ„ÄÅÊã¨Âºß„Åß„Åù„ÅÆÂêçÂâç„ÇíÂõ≤„ÇÄ„Å®„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÇíÈÄöÂ∏∏„ÅÆÈñ¢Êï∞„ÅÆ„Çà„ÅÜ„Å´‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅ<code>map</code>‰ª£„Çè„Çä„Å´„ÄÅÊã¨Âºß„ÅßÂõ≤„Åæ„Çå„Åü<code>(&lt;$&gt;)</code>„Å®„ÅÑ„ÅÜÂêçÂâç„Çí‰Ωø„Å£„Å¶ÈÖçÂàó„Å´Èñ¢Êï∞„ÇíÈÅ©Áî®„Åß„Åç„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; (&lt;$&gt;) show [1, 2, 3, 4, 5]
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>‰∏≠ÁΩÆÈñ¢Êï∞„ÅØÊó¢Â≠ò„ÅÆÈñ¢Êï∞Âêç„ÅÆÂà•Áß∞„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Åæ„Åô„ÄÇ
„Åü„Å®„Åà„Å∞„ÄÅ<code>Data.Array</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´<code>range</code>Èñ¢Êï∞„ÅÆÂêåÁæ©Ë™û„Å®„Åó„Å¶‰∏≠ÁΩÆÊºîÁÆóÂ≠ê<code>(..)</code>„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">infix 8 range as ..
</code></pre>
<p>„Åì„ÅÆÊºîÁÆóÂ≠ê„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; 1 .. 5
[1, 2, 3, 4, 5]

&gt; show &lt;$&gt; (1 .. 5)
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p><strong>Ê≥®ÊÑè</strong>Ôºö Áã¨Ëá™„ÅÆ‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„ÅØ„ÄÅËá™ÁÑ∂„Å™ÊßãÊñá„ÇíÊåÅ„Å£„ÅüÈ†òÂüüÁâπÂåñË®ÄË™û„ÇíÂÆöÁæ©„Åô„Çã„ÅÆ„Å´ÂÑ™„Çå„ÅüÊâãÊÆµ„Å´„Å™„Çä„Åà„Åæ„Åô„ÄÇ
„Åü„Å†„Åó„ÄÅ‰π±Áî®„Åô„Çã„Å®ÂàùÂøÉËÄÖ„ÅåË™≠„ÇÅ„Å™„ÅÑ„Ç≥„Éº„Éâ„Å´„Å™„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„Åã„Çâ„ÄÅÊñ∞„Åü„Å™ÊºîÁÆóÂ≠ê„ÅÆÂÆöÁæ©„Å´„ÅØÊÖéÈáç„Å´„Å™„Çã„ÅÆ„ÅåË≥¢Êòé„Åß„Åô„ÄÇ</p>
<p>‰∏äË®ò„ÅÆ‰æã„Åß„ÅØ„ÄÅ<code>1 .. 5</code>„Å®„ÅÑ„ÅÜÂºè„ÅØÊã¨Âºß„ÅßÂõ≤„Åæ„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅÂÆüÈöõ„Å´„ÅØ„Åì„Çå„ÅØÂøÖË¶Å„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Å™„Åú„Å™„Çâ„ÄÅ<code>Data.Array</code>„É¢„Ç∏„É•„Éº„É´„ÅØ„ÄÅ<code>&lt;$&gt;</code>„Å´Ââ≤„ÇäÂΩì„Å¶„Çâ„Çå„ÅüÂÑ™ÂÖàÈ†Ü‰Ωç„Çà„ÇäÈ´ò„ÅÑÂÑ™ÂÖàÈ†Ü‰Ωç„Çí<code>..</code>ÊºîÁÆóÂ≠ê„Å´Ââ≤„ÇäÂΩì„Å¶„Å¶„ÅÑ„Çã„Åã„Çâ„Åß„Åô„ÄÇ
‰∏ä„ÅÆ‰æã„Åß„ÅØ„ÄÅ<code>..</code>„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç„ÅØ„ÄÅ‰∫àÁ¥ÑË™û<code>infix</code>„ÅÆ„ÅÇ„Å®„Å´Êõ∏„Åã„Çå„ÅüÊï∞„ÅÆ<code>8</code> „Å®ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ
„Åì„Åì„Åß„ÅØ<code>&lt;$&gt;</code>„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç„Çà„Çä„ÇÇÈ´ò„ÅÑÂÑ™ÂÖàÈ†Ü‰Ωç„Çí<code>..</code>„Å´Ââ≤„ÇäÂΩì„Å¶„Å¶„Åä„Çä„ÄÅ„Åì„ÅÆ„Åü„ÇÅÊã¨Âºß„Çí‰ªò„ÅëÂä†„Åà„ÇãÂøÖË¶Å„Åå„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; show &lt;$&gt; 1 .. 5
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]
</code></pre>
<p>‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„Å´ÔºàÂ∑¶„Åæ„Åü„ÅØÂè≥„ÅÆÔºâ<strong>ÁµêÂêàÊÄß</strong>„Çí‰∏é„Åà„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅ‰ª£„Çè„Çä„Å´‰∫àÁ¥ÑË™û<code>infixl</code>„Å®<code>infixr</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
<code>infix</code>„Çí‰Ωø„ÅÜ„Å®‰Ωï„ÇâÁµêÂêàÊÄß„ÅØÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Åö„ÄÅ
Âêå„ÅòÊºîÁÆóÂ≠ê„ÇíË§áÊï∞Âõû‰Ωø„Å£„Åü„ÇäË§áÊï∞„ÅÆÂêå„ÅòÂÑ™ÂÖàÂ∫¶„ÅÆÊºîÁÆóÂ≠ê„Çí‰Ωø„Å£„Åü„Çä„Åô„Çã„Å®„Åç„Å´„ÄÅÂºè„ÇíÊã¨Âºß„ÅßÂõ≤„Åæ„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Å™„Åè„Å™„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="ÈÖçÂàó„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞"><a class="header" href="#ÈÖçÂàó„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞">ÈÖçÂàó„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞</a></h2>
<p><code>Data.Array</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ‰ªñ„Å´„ÇÇ„ÄÅ„Çà„Åè<code>map</code>„Å®‰∏ÄÁ∑í„Å´‰Ωø„Çè„Çå„ÇãÈñ¢Êï∞<code>filter</code>„ÇÇÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ„ÄÅËø∞Ë™ûÈñ¢Êï∞„Å´ÈÅ©Âêà„Åô„ÇãË¶ÅÁ¥†„ÅÆ„Åø„ÇíÊÆã„Åó„ÄÅÊó¢Â≠ò„ÅÆÈÖçÂàó„Åã„ÇâÊñ∞„Åó„ÅÑÈÖçÂàó„Çí‰ΩúÊàê„Åô„ÇãÊ©üËÉΩ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅ1„Åã„Çâ10„Åæ„Åß„ÅÆÊï∞„Åß„ÄÅÂÅ∂Êï∞„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™Êï∞„ÅÆÈÖçÂàó„ÇíË®àÁÆó„Åó„Åü„ÅÑ„Å®„Åó„Åæ„Åô„ÄÇ„Åì„Çå„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Ë°å„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; filter (\n -&gt; n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
</code></pre>
<h2 id="ÊºîÁøí-4"><a class="header" href="#ÊºîÁøí-4">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ<code>map</code>Èñ¢Êï∞„ÇÑ<code>&lt;$&gt;</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ ÈÖçÂàó„Å´Ê†ºÁ¥ç„Åï„Çå„ÅüÊï∞„ÅÆ„Åù„Çå„Åû„Çå„ÅÆÂπ≥Êñπ„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞<code>squared</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>map</code>„ÇÑ<code>&lt;$&gt;</code>„Å®„ÅÑ„Å£„ÅüÈñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÁ∞°ÂçòÔºâ<code>filter</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊï∞„ÅÆÈÖçÂàó„Åã„ÇâË≤†„ÅÆÊï∞„ÇíÂèñ„ÇäÈô§„ÅèÈñ¢Êï∞<code>keepNonNegative</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>filter</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ
<ul>
<li><code>filter</code>„ÅÆ‰∏≠ÁΩÆÂêåÁæ©Ë™û<code>&lt;$?&gt;</code>„ÇíÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö‰∏≠ÁΩÆÂêåÁæ©Ë™û„ÅØREPL„Åß„ÅØÂÆöÁæ©„Åß„Åç„Å™„ÅÑ„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åå„ÄÅ„Éï„Ç°„Ç§„É´„Åß„ÅØÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</li>
<li>Èñ¢Êï∞<code>keepNonNegativeRewrite</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>filter</code>„ÇíËá™Ââç„ÅÆÁ≤ó„Åó„ÅÑ‰∏≠ÁΩÆÊºîÁÆóÂ≠ê<code>&lt;$?&gt;</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Åü„Å®„Åì„Çç‰ª•Â§ñ„ÅØ<code>keepNonNegative</code>„Å®Âêå„Åò„Åß„Åô„ÄÇ</li>
<li>PSCi„ÅßËá™Ââç„ÅÆÊºîÁÆóÂ≠ê„ÅÆÂÑ™ÂÖàÂ∫¶Âêà„ÅÑ„Å®ÁµêÂêàÊÄß„ÇíË©¶„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÂïèÈ°å„ÅÆ„Åü„ÇÅ„ÅÆÂçò‰ΩìË©¶È®ì„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</li>
</ul>
</li>
</ol>
<h2 id="ÈÖçÂàó„ÅÆÂπ≥Âù¶Âåñ"><a class="header" href="#ÈÖçÂàó„ÅÆÂπ≥Âù¶Âåñ">ÈÖçÂàó„ÅÆÂπ≥Âù¶Âåñ</a></h2>
<p>ÈÖçÂàó„Å´Èñ¢„Åô„ÇãÊ®ôÊ∫ñÁöÑ„Å™Èñ¢Êï∞„Å®„Åó„Å¶<code>Data.Array</code>„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„Å´„ÅØ„ÄÅ<code>concat</code>Èñ¢Êï∞„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ<code>concat</code>„ÅØÈÖçÂàó„ÅÆÈÖçÂàó„Çí„Å≤„Å®„Å§„ÅÆÈÖçÂàó„Å∏„Å®Âπ≥Âù¶Âåñ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concat
forall a. Array (Array a) -&gt; Array a

&gt; concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
</code></pre>
<p>Èñ¢ÈÄ£„Åô„ÇãÈñ¢Êï∞„Å®„Åó„Å¶„ÄÅ<code>concat</code>„Å®<code>map</code>„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Åü„Çà„ÅÜ„Å™<code>concatMap</code>„Å®Âëº„Å∞„Çå„ÇãÈñ¢Êï∞„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
<code>map</code>„ÅØÔºàÁõ∏Áï∞„Å™„ÇãÂûã„ÇÇÂèØËÉΩ„Å™ÔºâÂÄ§„Åã„Çâ„ÅÆÂÄ§„Å∏„ÅÆÈñ¢Êï∞„ÇíÂºïÊï∞„Å´Âèñ„Çä„Åæ„Åô„Åå„ÄÅ„Åù„Çå„Å´ÂØæ„Åó„Å¶<code>concatMap</code>„ÅØÂÄ§„Åã„ÇâÂÄ§„ÅÆÈÖçÂàó„ÅÆÈñ¢Êï∞„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ</p>
<p>ÂÆüÈöõ„Å´Âãï„Åã„Åó„Å¶Ë¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; :type concatMap
forall a b. (a -&gt; Array b) -&gt; Array a -&gt; Array b

&gt; concatMap (\n -&gt; [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅÊï∞„Çí„Åù„ÅÆÊï∞„Å®„Åù„ÅÆÊï∞„ÅÆÂπ≥Êñπ„ÅÆ2„Å§„ÅÆË¶ÅÁ¥†„Åã„Çâ„Å™„ÇãÈÖçÂàó„Å´ÂÜô„ÅôÈñ¢Êï∞<code>\n -&gt; [n, n * n]</code>„ÇíÂºïÊï∞„Å´<code>concatMap</code>„ÇíÂëº„Å≥Âá∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÁµêÊûú„ÅØ10ÂÄã„ÅÆÊï¥Êï∞„ÅÆÈÖçÂàó„Åß„Åô„ÄÇ
ÈÖçÂàó„ÅØ1„Åã„Çâ5„ÅÆÊï∞„Å®„Åù„ÅÆ„Åù„Çå„Åû„Çå„ÅÆÊï∞„ÅÆÂπ≥Êñπ„Åã„Çâ„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p><code>concatMap</code>„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´ÁµêÊûú„ÇíÈÄ£Áµê„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åã„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Ê∏°„Åï„Çå„ÅüÈñ¢Êï∞„ÇíÂÖÉ„ÅÆÈÖçÂàó„ÅÆ„Åù„Çå„Åû„Çå„ÅÆË¶ÅÁ¥†„Å´„Å§„ÅÑ„Å¶‰∏ÄÂ∫¶„Å•„Å§Âëº„Å≥Âá∫„Åó„ÄÅ„Åù„ÅÆÈñ¢Êï∞„ÅØ„Åù„Çå„Åû„ÇåÈÖçÂàó„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
ÊúÄÂæå„Å´„Åù„Çå„Çâ„ÅÆÈÖçÂàó„ÇíÂçò‰∏Ä„ÅÆÈÖçÂàó„Å´Êäº„ÅóÊΩ∞„Åó„ÄÅ„Åù„Çå„ÅåÁµêÊûú„Å®„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p><code>map</code>„Å®<code>filter</code>„ÄÅ<code>concatMap</code>„ÅØ„ÄÅ„ÄåÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Äç(array comprehensions)
„Å®Âëº„Å∞„Çå„Çã„ÄÅÈÖçÂàó„Å´Èñ¢„Åô„Çã„ÅÇ„Çâ„ÇÜ„ÇãÈñ¢Êï∞„ÅÆÂü∫Áõ§„ÇíÂΩ¢Êàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÈÖçÂàóÂÜÖÂåÖË°®Ë®ò"><a class="header" href="#ÈÖçÂàóÂÜÖÂåÖË°®Ë®ò">ÈÖçÂàóÂÜÖÂåÖË°®Ë®ò</a></h2>
<p>Êï∞<code>n</code>„ÅÆ„Åµ„Åü„Å§„ÅÆÂõ†Êï∞„ÇíË¶ã„Å§„Åë„Åü„ÅÑ„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ„Åì„Çå„ÇíË°å„ÅÜ„Åü„ÇÅ„ÅÆÁ∞°Âçò‚Äã‚Äã„Å™ÊñπÊ≥ï„Å®„Åó„Å¶„ÅØ„ÄÅÁ∑èÂΩì„Çä„ÅßË™ø„Åπ„ÇãÊñπÊ≥ï„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Å§„Åæ„Çä„ÄÅ<code>1</code>„Åã„Çâ<code>n</code>„ÅÆÊï∞„ÅÆ„Åô„Åπ„Å¶„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÁîüÊàê„Åó„ÄÅ„Åù„Çå„Çí‰πóÁÆó„Åó„Å¶„Åø„Çã„Çè„Åë„Åß„Åô„ÄÇ„ÇÇ„Åó„Åù„ÅÆÁ©ç„Åå<code>n</code>„Å™„Çâ„ÄÅ<code>n</code>„ÅÆÂõ†Êï∞„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÇíË¶ã„Å§„Åë„Åü„Å®„ÅÑ„ÅÜ„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>ÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Çí‰ΩøÁî®„Åô„Çã„Å®„ÄÅ„Åì„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
PSCi„ÇíÂØæË©±Âºè„ÅÆÈñãÁô∫Áí∞Â¢É„Å®„Åó„Å¶‰ΩøÁî®„Åó„ÄÅ„Å≤„Å®„Å§„Å•„Å§„Åì„ÅÆÊâãÈ†Ü„ÇíÈÄ≤„ÇÅ„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>ÊúÄÂàù„ÅÆÊâãÈ†Ü„Åß„ÅØ<code>n</code>‰ª•‰∏ã„ÅÆÊï∞„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆÈÖçÂàó„ÇíÁîüÊàê„Åó„Åæ„Åô„Åå„ÄÅ„Åì„Çå„Å´„ÅØ<code>concatMap</code>„Çí‰Ωø„Åà„Å∞„Çà„ÅÑ„Åß„Åô„ÄÇ</p>
<p><code>1 .. n</code>„ÅÆ„Åù„Çå„Åû„Çå„ÅÆÊï∞„ÇíÈÖçÂàó<code>1 .. n</code>„Å∏„Å®„Éû„ÉÉ„Éî„É≥„Ç∞„Åô„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; pairs n = concatMap (\i -&gt; 1 .. n) (1 .. n)
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„Çí„ÉÜ„Çπ„Éà„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; pairs 3
[1,2,3,1,2,3,1,2,3]
</code></pre>
<p>„Åì„Çå„ÅØÊ±Ç„ÇÅ„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„Å®„ÅØ„Åú„Çì„Åú„ÇìÈÅï„ÅÑ„Åæ„Åô„ÄÇ
Âçò„Å´„Åù„Çå„Åû„Çå„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆ2„Å§ÁõÆ„ÅÆË¶ÅÁ¥†„ÇíËøî„Åô„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ„Éö„Ç¢ÂÖ®‰Ωì„Çí‰øùÊåÅ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅÂÜÖÂÅ¥„ÅÆ<code>1 .. n</code>„ÅÆË§áË£Ω„Å´„Å§„ÅÑ„Å¶Èñ¢Êï∞„Çí„Éû„ÉÉ„Éî„É≥„Ç∞„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ pairs' n =
‚Ä¶   concatMap (\i -&gt;
‚Ä¶     map (\j -&gt; [i, j]) (1 .. n)
‚Ä¶   ) (1 .. n)
‚Ä¶ ^D

&gt; pairs' 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
</code></pre>
<p>„ÅÑ„ÅÑÊÑü„Åò„Å´„Å™„Å£„Å¶„Åç„Åæ„Åó„Åü„ÄÇ
„Åó„Åã„Åó„ÄÅ<code>[1, 2]</code>„Å®<code>[2, 1]</code>„ÅÆ‰∏°Êñπ„Åå„ÅÇ„Çã„Çà„ÅÜ„Å´„ÄÅÈáçË§á„Åó„ÅüÁµÑ„ÅøÂêà„Çè„Åõ„ÅåÁîüÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>j</code>„Çí<code>i</code>„Åã„Çâ<code>n</code>„ÅÆÁØÑÂõ≤„Å´ÈôêÂÆö„Åô„Çã„Åì„Å®„Åß„ÄÅ2„Å§ÁõÆ„ÅÆÂ†¥Âêà„ÇíÂèñ„ÇäÈô§„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ pairs'' n =
‚Ä¶   concatMap (\i -&gt;
‚Ä¶     map (\j -&gt; [i, j]) (i .. n)
‚Ä¶   ) (1 .. n)
‚Ä¶ ^D
&gt; pairs'' 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
</code></pre>
<p>„Åô„Å∞„Çâ„Åó„ÅÑ„Åß„ÅôÔºÅÂõ†Êï∞„ÅÆÂÄôË£ú„ÅÆ„Åô„Åπ„Å¶„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÊâã„Å´ÂÖ•„Çå„Åü„ÅÆ„Åß„ÄÅ<code>filter</code>„Çí‰Ωø„Åà„Å∞„ÄÅ„Åù„ÅÆÁ©ç„Åå<code>n</code>„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™ÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÈÅ∏„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; factors n = filter (\pair -&gt; product pair == n) (pairs'' n)

&gt; factors 10
[[1,10],[2,5]]
</code></pre>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ„Åß„ÅØ„ÄÅ<code>foldable-traversable</code>„É©„Ç§„Éñ„É©„É™„ÅÆ<code>Data.Foldable</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅÇ„Çã<code>product</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„ÅÜ„Åæ„Åè„ÅÑ„Åç„Åæ„Åó„ÅüÔºÅÂõ†Êï∞„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆÊ≠£„Åó„ÅÑÈõÜÂêà„ÇíÈáçË§á„Å™„ÅèË¶ã„Å§„Åë„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åó„Åü„ÄÇ</p>
<h2 id="doË®òÊ≥ï"><a class="header" href="#doË®òÊ≥ï">doË®òÊ≥ï</a></h2>
<p>„Åó„Åã„Åó„ÄÅ„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅÆÂèØË™≠ÊÄß„ÅØÂ§ßÂπÖ„Å´Âêë‰∏ä„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>map</code>„ÇÑ<code>concatMap</code>„ÅØÂü∫Êú¨ÁöÑ„Å™Èñ¢Êï∞„Åß„ÅÇ„Çä„ÄÅ<strong>doË®òÊ≥ï</strong> (do notation)
„Å®Âëº„Å∞„Çå„ÇãÁâπÂà•„Å™ÊßãÊñá„ÅÆÂü∫Á§é„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„ÅôÔºà„ÇÇ„Å£„Å®Âé≥ÂØÜ„Å´„ÅÑ„Åà„Å∞„ÄÅ„Åù„Çå„Çâ„ÅÆ‰∏ÄËà¨Âåñ„Åß„ÅÇ„Çã<code>map</code>„Å®<code>bind</code>„ÅåÂü∫Á§é„Çí„Å™„Åó„Å¶„ÅÑ„Åæ„ÅôÔºâ„ÄÇ</p>
<p><strong>Ê≥®ÊÑè</strong>Ôºö<code>map</code>„Å®<code>concatMap</code>„Åå<strong>ÈÖçÂàóÂÜÖÂåÖË°®Ë®ò</strong>„ÇíÊõ∏„Åë„Çã„Çà„ÅÜ„Å´„Åó„Å¶„ÅÑ„Çã„Çà„ÅÜ„Å´„ÄÅ„ÇÇ„Å£„Å®‰∏ÄËà¨ÁöÑ„Å™ÊºîÁÆóÂ≠ê„Åß„ÅÇ„Çã<code>map</code>„Å®<code>bind</code>„ÅØ<strong>„É¢„Éä„ÉâÂÜÖÂåÖË°®Ë®ò</strong>
(monad comprehensions) „Å®Âëº„Å∞„Çå„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÇíÊõ∏„Åë„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ
Êú¨Êõ∏„ÅÆÂæåÂçä„Åß„ÅØ<strong>„É¢„Éä„Éâ</strong> (monad) „ÅÆ‰æã„Çí„Åü„Å£„Å∑„ÇäË¶ã„Å¶„ÅÑ„Åè„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„Åå„ÄÅ
„Åì„ÅÆÁ´†„Åß„ÅØÈÖçÂàó„ÅÆ„Åø„ÇíËÄÉ„Åà„Åæ„Åô„ÄÇ</p>
<p>doË®òÊ≥ï„Çí‰Ωø„ÅÜ„Å®„ÄÅÂÖà„Åª„Å©„ÅÆ<code>factors</code>Èñ¢Êï∞„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êõ∏„ÅçÁõ¥„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">factors :: Int -&gt; Array (Array Int)
factors n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  pure [ i, j ]
</code></pre>
<p>„Ç≠„Éº„ÉØ„Éº„Éâ<code>do</code>„ÅØdoË®òÊ≥ï„Çí‰Ωø„ÅÜ„Ç≥„Éº„Éâ„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÅØÂπæ„Å§„Åã„ÅÆÁ®ÆÈ°û„ÅÆÂºè„ÅßÊßãÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li>ÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÇíÂêçÂâç„Å´ÊùüÁ∏õ„Åô„ÇãÂºè„ÄÇ
„Åì„Çå„ÅØÂæå„ÇçÂêë„Åç„ÅÆÁü¢Âç∞<code>&lt;-</code>„ÅßÁ§∫„Åï„Çå„Å¶„ÅÑ„Å¶„ÄÅ„Åù„ÅÆÂ∑¶ÂÅ¥„ÅØÂêçÂâç„ÄÅÂè≥ÂÅ¥„ÅØÈÖçÂàó„ÅÆÂûã„ÇíÊåÅ„Å§Âºè„Åß„Åô„ÄÇ</li>
<li>ÂêçÂâç„Å´ÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÇíÊùüÁ∏õ„Åó„Å™„ÅÑÂºè„ÄÇ
<code>do</code>„ÅÆ <em>ÁµêÊûú</em> „ÅØ„Åì„ÅÆÁ®ÆÈ°û„ÅÆÂºè„ÅÆ‰∏Ä‰æã„Åß„ÅÇ„Çä„ÄÅÊúÄÂæå„ÅÆË°å„ÅÆ<code>pure [i, j]</code>„Å´Á§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>let</code>„Ç≠„Éº„ÉØ„Éº„Éâ„Çí‰ΩøÁî®„Åó„ÄÅÂºè„Å´ÂêçÂâç„Çí‰∏é„Åà„ÇãÂºè„ÄÇ</li>
</ul>
<p>„Åì„ÅÆÊñ∞„Åó„ÅÑË®òÊ≥ï„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÊßãÈÄ†„Åå„Çè„Åã„Çä„ÇÑ„Åô„Åè„Å™„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÂøÉ„ÅÆ„Å™„Åã„Åß<code>&lt;-</code>„Çí„ÄåÈÅ∏„Å∂„Äç„Å®„ÅÑ„ÅÜÂçòË™û„Å´ÁΩÆ„ÅçÊèõ„Åà„Çã„Å®„Åô„Çã„Å®„ÄÅ„Äå1„Åã„Çân„ÅÆÈñì„ÅÆË¶ÅÁ¥†<code>i</code>„ÇíÈÅ∏„Å≥„ÄÅ„Åù„Çå„Åã„Çâi„Åã„Çân„ÅÆÈñì„ÅÆË¶ÅÁ¥†<code>j</code>„ÇíÈÅ∏„Å≥„ÄÅ<code>[i, j]</code>„ÇíËøî„Åô„Äç„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´Ë™≠„ÇÄ„Åì„Å®„Åå„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>ÊúÄÂæå„ÅÆË°å„Åß„ÅØ„ÄÅ<code>pure</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØPSCi„ÅßË©ï‰æ°„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„Åå„ÄÅÂûã„ÇíÊòéÁ§∫„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; pure [1, 2] :: Array (Array Int)
[[1, 2]]
</code></pre>
<p>ÈÖçÂàó„ÅÆÂ†¥Âêà„ÄÅ<code>pure</code>„ÅØÂçò„Å´1Ë¶ÅÁ¥†„ÅÆÈÖçÂàó„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ
ÂÆüÈöõ„Å´„ÄÅ<code>factors</code>Èñ¢Êï∞„ÇíÂ§âÊõ¥„Åó„Å¶„ÄÅ<code>pure</code>„ÅÆ‰ª£„Çè„Çä„Å´„Åì„ÅÆÂΩ¢Âºè„Çí‰Ωø„ÅÜ„Çà„ÅÜ„Å´„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">factorsV2 :: Int -&gt; Array (Array Int)
factorsV2 n = filter (\xs -&gt; product xs == n) do
  i &lt;- 1 .. n
  j &lt;- i .. n
  [ [ i, j ] ]
</code></pre>
<p>„Åù„Åó„Å¶„ÄÅÁµêÊûú„ÅØÂêå„Åò„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="„Ç¨„Éº„Éâ"><a class="header" href="#„Ç¨„Éº„Éâ">„Ç¨„Éº„Éâ</a></h2>
<p><code>factors</code>Èñ¢Êï∞„ÇíÊõ¥„Å´ÊîπËâØ„Åô„ÇãÊñπÊ≥ï„Å®„Åó„Å¶„ÅØ„ÄÅ„Åì„ÅÆ„Éï„Ç£„É´„Çø„ÇíÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„ÅÆÂÜÖÂÅ¥„Å´ÁßªÂãï„Åô„Çã„Å®„ÅÑ„ÅÜ„ÇÇ„ÅÆ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ<code>control</code>„É©„Ç§„Éñ„É©„É™„Å´„ÅÇ„Çã<code>Control.Alternative</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ<code>guard</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„ÅßÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Control.Alternative (guard)

factorsV3 :: Int -&gt; Array (Array Int)
factorsV3 n = do
  i &lt;- 1 .. n
  j &lt;- i .. n
  guard $ i * j == n
  pure [ i, j ]
</code></pre>
<p><code>pure</code>„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å´Âãï‰Ωú„Åô„Çã„Åã„ÇíÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÄÅPSCi„Åß<code>guard</code>Èñ¢Êï∞„ÇíÈÅ©Áî®„Åó„Å¶Ë™ø„Åπ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>guard</code>Èñ¢Êï∞„ÅÆÂûã„ÅØ„ÄÅ„Åì„Åì„ÅßÂøÖË¶Å„Å®„Åï„Çå„Çã„ÇÇ„ÅÆ„Çà„Çä„ÇÇ„Å£„Å®‰∏ÄËà¨ÁöÑ„Å™Âûã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Control.Alternative

&gt; :type guard
forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p>‰ªäÂõû„ÅÆÂ†¥Âêà„ÅØ„ÄÅPSCi„ÅØÊ¨°„ÅÆÂûã„ÇíÂ†±Âëä„Åô„Çã„ÇÇ„ÅÆ„Å®ËÄÉ„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">Boolean -&gt; Array Unit
</code></pre>
<p>ÁõÆÁöÑ„Åã„Çâ„Åô„Çã„Å®„ÄÅÊ¨°„ÅÆË®àÁÆó„ÅÆÁµêÊûú„Åã„ÇâÈÖçÂàó„Å´„Åä„Åë„Çã<code>guard</code>Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶‰ªäÁü•„Çä„Åü„ÅÑ„Åì„Å®„ÅØ„Åô„Åπ„Å¶„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Array

&gt; length $ guard true
1

&gt; length $ guard false
0
</code></pre>
<p>„Å§„Åæ„Çä„ÄÅ<code>guard</code>„Åå<code>true</code>„Å´Ë©ï‰æ°„Åï„Çå„ÇãÂºè„ÇíÊ∏°„Åï„Çå„ÅüÂ†¥Âêà„ÄÅÂçò‰∏Ä„ÅÆË¶ÅÁ¥†„ÇíÊåÅ„Å§ÈÖçÂàó„ÇíËøî„Åô„ÅÆ„Åß„Åô„ÄÇ„ÇÇ„ÅóÂºè„Åå<code>false</code>„Å®Ë©ï‰æ°„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„ÄÅ„Åù„ÅÆÁµêÊûú„ÅØÁ©∫„Åß„Åô„ÄÇ</p>
<p>„Ç¨„Éº„Éâ„ÅåÂ§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„ÅÆÁèæÂú®„ÅÆÂàÜÂ≤ê„ÅØ„ÄÅÁµêÊûú„Å™„Åó„ÅßÊó©„ÇÅ„Å´ÁµÇ‰∫Ü„Åï„Çå„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅ<code>guard</code>„ÅÆÂëº„Å≥Âá∫„Åó„Åå„ÄÅÈÄî‰∏≠„ÅÆÈÖçÂàó„Å´ÂØæ„Åó„Å¶<code>filter</code>„Çí‰ΩøÁî®„Åô„Çã„ÅÆ„Å®Âêå„Åò„Å†„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
ÂÆüË∑µ„ÅÆÂ†¥Èù¢„Å´„ÇÇ„Çà„Çä„Åæ„Åô„Åå„ÄÅ<code>filter</code>„ÅÆ‰ª£„Çè„Çä„Å´<code>guard</code>„Çí‰Ωø„ÅÑ„Åü„ÅÑ„Åì„Å®„ÅØÂ§ö„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åì„Çå„Çâ„ÅåÂêå„ÅòÁµêÊûú„Å´„Å™„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ<code>factors</code>„ÅÆ2„Å§„ÅÆÂÆöÁæ©„ÇíË©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="ÊºîÁøí-5"><a class="header" href="#ÊºîÁøí-5">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâÊï¥Êï∞„ÅÆÂºïÊï∞„ÅåÁ¥†Êï∞„Åß„ÅÇ„Çã„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„ÇãÈñ¢Êï∞<code>isPrime</code>„ÇíÂÆöÁæ©„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>factors</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâdoË®òÊ≥ï„Çí‰Ωø„ÅÑ„ÄÅ2„Å§„ÅÆÈÖçÂàó„ÅÆ<strong>Áõ¥Á©çÈõÜÂêà</strong>„ÇíË¶ã„Å§„Åë„Çã„Åü„ÇÅ„ÅÆÈñ¢Êï∞<code>cartesianProduct</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
Áõ¥Á©çÈõÜÂêà„Å®„ÅØ„ÄÅË¶ÅÁ¥†<code>a</code>„ÄÅ<code>b</code>„ÅÆ„Åô„Åπ„Å¶„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆÈõÜÂêà„ÅÆ„Åì„Å®„Åß„Åô„ÄÇ
„Åì„Åì„Åß<code>a</code>„ÅØÊúÄÂàù„ÅÆÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÄÅ<code>b</code>„ÅØ2„Å§ÁõÆ„ÅÆÈÖçÂàó„ÅÆË¶ÅÁ¥†„Åß„Åô„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÊï∞ÂÄ§<code>n</code>„ÇíÂèñ„Å£„Å¶ÊßãÊàêË¶ÅÁ¥†ÔºàÂÄ§<code>a</code>, <code>b</code>, <code>c</code>Ôºâ„Åå„Åù„Çå„Åû„Çå<code>n</code>‰ª•‰∏ã„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™ÂÖ®„Å¶„ÅÆ„Éî„Çø„Ç¥„É©„Çπ„ÅÆ3„Å§ÁµÑ
(pythagorean triples) „ÇíËøî„ÅôÈñ¢Êï∞<code>triples :: Int -&gt; Array (Array Int)</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éî„Çø„Ç¥„É©„Çπ„ÅÆ3„Å§ÁµÑ</strong> „ÅØÊï∞ÂÄ§„ÅÆÈÖçÂàó<code>[a, b, c]</code>„Åß <code>a¬≤ + b¬≤ = c¬≤</code> „Åß„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Åß<code>guard</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÈõ£„Åó„ÅÑÔºâ<code>factors</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊï∞<code>n</code>„ÅÆ<a href="https://www.mathsisfun.com/prime-factorization.html">Á¥†Âõ†Êï∞ÂàÜËß£</a>„ÇíÊ±Ç„ÇÅ„ÇãÈñ¢Êï∞<code>primeFactors</code>„ÇíÂÆöÁæ©„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
Êï∞<code>n</code>„ÅÆÁ¥†Âõ†Êï∞ÂàÜËß£„Å®„ÅØ„ÄÅÁ¥†Êï∞„ÅÆÁ©ç„Åå<code>n</code>„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™Êï¥Êï∞„ÅÆÈÖçÂàó„ÅÆ„Åì„Å®„Åß„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö1„Çà„ÇäÂ§ß„Åç„ÅÑÊï¥Êï∞„Å´„Å§„ÅÑ„Å¶„ÄÅÂïèÈ°å„Çí2„Å§„ÅÆÈÉ®ÂàÜÂïèÈ°å„Å´ÂàÜËß£„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÊúÄÂàù„ÅÆÂõ†Êï∞„ÇíÊé¢„Åó„ÄÅ„Åù„Çå„Åã„ÇâÊÆã„Çä„ÅÆÂõ†Êï∞„ÇíÊé¢„Åô„ÅÆ„Åß„Åô„ÄÇ</li>
</ol>
<h2 id="Áï≥„ÅøËæº„Åø"><a class="header" href="#Áï≥„ÅøËæº„Åø">Áï≥„ÅøËæº„Åø</a></h2>
<p>ÈÖçÂàó„Å´„Åä„Åë„ÇãÂ∑¶Âè≥„ÅÆÁï≥„ÅøËæº„Åø„ÅØ„ÄÅÂÜçÂ∏∞„ÇíÁî®„ÅÑ„Å¶ÂÆüË£Ö„Åï„Çå„ÇãÂà•„ÅÆËààÂë≥Ê∑±„ÅÑÈñ¢Êï∞„ÅÆÈõÜ„Åæ„Çä„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p>PSCi„Çí‰Ωø„Å£„Å¶„ÄÅ<code>Data.Foldable</code>„É¢„Ç∏„É•„Éº„É´„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„ÄÅ<code>foldl</code>„Å®<code>foldr</code>Èñ¢Êï∞„ÅÆÂûã„ÇíË™ø„Åπ„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :type foldl
forall a b f. Foldable f =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b

&gt; :type foldr
forall a b f. Foldable f =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
</code></pre>
<p>„Åì„Çå„Çâ„ÅÆÂûã„ÅØ„ÄÅÁèæÂú®ËààÂë≥„Åå„ÅÇ„Çã„ÇÇ„ÅÆ„Çà„Çä„ÇÇ‰∏ÄËà¨ÁöÑ„Åß„Åô„ÄÇ
„Åì„ÅÆÁ´†„ÅÆÁõÆÁöÑ„Åß„ÅØ„ÄÅPSCi„ÅØ‰ª•‰∏ã„ÅÆÔºà„Çà„ÇäÂÖ∑‰ΩìÁöÑ„Å™ÔºâÁ≠î„Åà„Çí‰∏é„Åà„Å¶„ÅÑ„Åü„Å®ËÄÉ„Åà„Å¶„Åä„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; :type foldl
forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; Array a -&gt; b

&gt; :type foldr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; Array a -&gt; b
</code></pre>
<p>„Å©„Å°„Çâ„ÅÆÂûã„Åß„ÇÇ„ÄÅ<code>a</code>„ÅØÈÖçÂàó„ÅÆË¶ÅÁ¥†„ÅÆÂûã„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Âûã<code>b</code>„ÅØ„ÄÅÈÖçÂàó„ÇíËµ∞Êüª (traverse) „Åó„Åü„Å®„Åç„ÅÆÁµêÊûú„ÇíÁ¥ØÁ©ç„Åô„Çã„ÄåÁ¥ØÁ©çÂô®„Äç(accumulator) „ÅÆÂûã„Å†„Å®ËÄÉ„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>foldl</code>Èñ¢Êï∞„Å®<code>foldr</code>Èñ¢Êï∞„ÅÆÈÅï„ÅÑ„ÅØËµ∞Êüª„ÅÆÊñπÂêë„Åß„Åô„ÄÇ
<code>foldr</code>„Åå„ÄåÂè≥„Åã„Çâ„ÄçÈÖçÂàó„ÇíÁï≥„ÅøËæº„ÇÄ„ÅÆ„Å´ÂØæ„Åó„Å¶„ÄÅ<code>foldl</code>„ÅØ„ÄåÂ∑¶„Åã„Çâ„ÄçÈÖçÂàó„ÇíÁï≥„ÅøËæº„Åø„Åæ„Åô„ÄÇ</p>
<p>ÂÆüÈöõ„Å´„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÅÆÂãï„Åç„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>foldl</code>„Çí‰ΩøÁî®„Åó„Å¶Êï∞„ÅÆÈÖçÂàó„ÅÆÂíå„ÇíÊ±Ç„ÇÅ„Å¶„Åø„Åæ„Åô„ÄÇ
Âûã<code>a</code>„ÅØ<code>Int</code>„Å´„Å™„Çä„ÄÅÁµêÊûú„ÅÆÂûã<code>b</code>„ÇÇ<code>Int</code>„Å®„Åó„Å¶ÈÅ∏Êäû„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Åì„Åß„ÅØ„ÄÅÊ¨°„ÅÆË¶ÅÁ¥†„ÇíÁ¥ØÁ©çÂô®„Å´Âä†ÁÆó„Åô„Çã<code>Int -&gt; Int -&gt; Int</code>„Å®„ÅÑ„ÅÜÂûã„ÅÆÈñ¢Êï∞„ÄÅ<code>Int</code>Âûã„ÅÆÁ¥ØÁ©çÂô®„ÅÆÂàùÊúüÂÄ§„ÄÅ
Âíå„ÇíÊ±Ç„ÇÅ„Åü„ÅÑ<code>Int</code>„ÅÆÈÖçÂàó„Å®„ÅÑ„ÅÜ„ÄÅ3„Å§„ÅÆÂºïÊï∞„ÇíÊèê‰æõ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÊúÄÂàù„ÅÆÂºïÊï∞„Å®„Åó„Å¶„ÅØ„ÄÅÂä†ÁÆóÊºîÁÆóÂ≠ê„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„Åó„ÄÅÁ¥ØÁ©çÂô®„ÅÆÂàùÊúüÂÄ§„ÅØ„Çº„É≠„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; foldl (+) 0 (1 .. 5)
15
</code></pre>
<p>„Åì„ÅÆÂ†¥Âêà„Åß„ÅØ„ÄÅÂºïÊï∞„ÅåÈÄÜ„Å´„Å™„Å£„Å¶„ÅÑ„Å¶„ÇÇ<code>(+)</code>Èñ¢Êï∞„ÅØÂêå„ÅòÁµêÊûú„ÇíËøî„Åô„ÅÆ„Åß„ÄÅ<code>foldl</code>„Å®<code>foldr</code>„ÅÆ„Å©„Å°„Çâ„Åß„ÇÇÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; foldr (+) 0 (1 .. 5)
15
</code></pre>
<p><code>foldl</code>„Å®<code>foldr</code>„ÅÆÈÅï„ÅÑ„ÇíË™¨Êòé„Åô„Çã„Åü„ÇÅ„Å´„ÄÅÁï≥„ÅøËæº„ÅøÈñ¢Êï∞„ÅÆÈÅ∏Êäû„ÅåÂΩ±Èüø„Åô„Çã‰æã„ÇÇÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
Âä†ÁÆóÈñ¢Êï∞„ÅÆ‰ª£„Çè„Çä„Å´„ÄÅÊñáÂ≠óÂàóÈÄ£Áµê„Çí‰ΩøÁî®„Åó„Å¶ÊñáÂ≠óÂàó„Çí‰Ωú„Å£„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; foldl (\acc n -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;12345&quot;

&gt; foldr (\n acc -&gt; acc &lt;&gt; show n) &quot;&quot; [1,2,3,4,5]
&quot;54321&quot;
</code></pre>
<p>„Åì„Çå„ÅØ„ÄÅ2„Å§„ÅÆÈñ¢Êï∞„ÅÆ‚Äã‚ÄãÈÅï„ÅÑ„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂ∑¶Áï≥„ÅøËæº„ÅøÂºè„ÅØ„ÄÅ‰ª•‰∏ã„ÅÆÈñ¢Êï∞ÈÅ©Áî®„Å®ÂêåÁ≠â„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 1) &lt;&gt; show 2) &lt;&gt; show 3) &lt;&gt; show 4) &lt;&gt; show 5)
</code></pre>
<p>„Åù„Çå„Å´ÂØæ„Åó„ÄÅÂè≥Áï≥„ÅøËæº„Åø„ÅØ‰ª•‰∏ã„Å´Áõ∏ÂΩì„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">(((((&quot;&quot; &lt;&gt; show 5) &lt;&gt; show 4) &lt;&gt; show 3) &lt;&gt; show 2) &lt;&gt; show 1)
</code></pre>
<h2 id="Êú´Â∞æÂÜçÂ∏∞"><a class="header" href="#Êú´Â∞æÂÜçÂ∏∞">Êú´Â∞æÂÜçÂ∏∞</a></h2>
<p>ÂÜçÂ∏∞„ÅØ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÂÆöÁæ©„Åô„Çã„Åü„ÇÅ„ÅÆÂº∑Âäõ„Å™ÊâãÊ≥ï„Åß„Åô„Åå„ÄÅÂïèÈ°å„ÇÇÊä±„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ
JavaScript„ÅßÂÜçÂ∏∞Èñ¢Êï∞„ÇíË©ï‰æ°„Åô„Çã„Å®„Åç„ÄÅÂÖ•Âäõ„ÅåÂ§ß„Åç„Åô„Åé„Çã„Å®„Çπ„Çø„ÉÉ„ÇØ„Ç™„Éº„Éê„Éº„Éï„É≠„Éº„Åß„Ç®„É©„Éº„ÇíËµ∑„Åì„ÅôÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>PSCi„ÅßÊ¨°„ÅÆ„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åô„Çã„Å®„ÄÅ„Åì„ÅÆÂïèÈ°å„ÇíÁ∞°Âçò„Å´Ê§úË®º„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ f n =
‚Ä¶   if n == 0
‚Ä¶     then 0
‚Ä¶     else 1 + f (n - 1)
‚Ä¶ ^D

&gt; f 10
10

&gt; f 100000
RangeError: Maximum call stack size exceeded
</code></pre>
<p>„Åì„Çå„ÅØÂïèÈ°å„Åß„Åô„ÄÇÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆÂü∫Êú¨ÁöÑ„Å™ÊâãÊ≥ï„Å®„Åó„Å¶ÂÜçÂ∏∞„ÇíÊé°Áî®„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å™„Çâ„ÄÅÁÑ°Èôê„Åã„ÇÇ„Åó„Çå„Å™„ÅÑÂÜçÂ∏∞„Åß„ÇÇÊâ±„Åà„ÇãÊñπÊ≥ï„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ</p>
<p>PureScript„ÅØ<strong>Êú´Â∞æÂÜçÂ∏∞ÊúÄÈÅ©Âåñ</strong> (tail recursion optimization)
„ÅÆÂΩ¢„Åß„Åì„ÅÆÂïèÈ°å„Å´ÂØæ„Åô„ÇãÈÉ®ÂàÜÁöÑ„Å™Ëß£Ê±∫Á≠ñ„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><strong>Ê≥®ÊÑè</strong>Ôºö„Åì„ÅÆÂïèÈ°å„Å∏„ÅÆ„Çà„ÇäÂÆåÂÖ®„Å™Ëß£Ê±∫Á≠ñ„Å®„Åó„Å¶„ÅØ„ÄÅ„ÅÑ„Çè„ÇÜ„Çã<strong>„Éà„É©„É≥„Éù„É™„É≥</strong> (trampolining)
„Çí‰ΩøÁî®„Åó„Åü„É©„Ç§„Éñ„É©„É™„ÅßÂÆüË£Ö„Åô„ÇãÊñπÊ≥ï„Åå„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ„Åù„Çå„ÅØ„Åì„ÅÆÁ´†„ÅßÊâ±„ÅÜÁØÑÂõ≤„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÂÜÖÂÆπ„Å´ËààÂë≥„ÅÆ„ÅÇ„ÇãË™≠ËÄÖ„ÅØ
<a href="https://pursuit.purescript.org/packages/purescript-free"><code>free</code></a>„ÇÑ
<a href="https://pursuit.purescript.org/packages/purescript-tailrec"><code>tailrec</code></a>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ
„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÂèÇÁÖß„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>Êú´Â∞æÂÜçÂ∏∞ÊúÄÈÅ©Âåñ„ÇíÂèØËÉΩ„Å´„Åô„Çã‰∏ä„ÅßÈçµ„Å®„Å™„ÇãË¶≥ÁÇπ„ÅØ‰ª•‰∏ã„Å®„Å™„Çä„Åæ„Åô„ÄÇ
<strong>Êú´Â∞æ‰ΩçÁΩÆ</strong> (tail position)
„Å´„ÅÇ„ÇãÈñ¢Êï∞„ÅÆÂÜçÂ∏∞ÁöÑ„Å™Âëº„Å≥Âá∫„Åó„ÅØ„ÄÅ„Çπ„Çø„ÉÉ„ÇØ„Éï„É¨„Éº„É†„ÅåÁ¢∫‰øù„Åï„Çå„Å™„ÅÑ<strong>„Ç∏„É£„É≥„Éó</strong>„Å´ÁΩÆ„ÅçÊèõ„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
Èñ¢Êï∞„ÅåÊàª„Çã„Çà„ÇäÂâç„ÅÆÊúÄÂæå„ÅÆÂëº„Å≥Âá∫„Åó„Åß„ÅÇ„Çã„Å®„Åç„ÄÅÂëº„Å≥Âá∫„Åó„Åå<strong>Êú´Â∞æ‰ΩçÁΩÆ</strong>„Å´„ÅÇ„Çã„Å®„ÅÑ„ÅÑ„Åæ„Åô„ÄÇ
„Å™„Åú„Åì„ÅÆ‰æã„Åß„Çπ„Çø„ÉÉ„ÇØ„Ç™„Éº„Éê„Éº„Éï„É≠„Éº„ÇíË¶≥ÂØü„Åó„Åü„ÅÆ„Åã„ÅØ„Åì„Çå„ÅåÁêÜÁî±„Åß„Åô„ÄÇ
„Åì„ÅÆ<code>f</code>„ÅÆÂÜçÂ∏∞Âëº„Å≥Âá∫„Åó„ÅØ„ÄÅÊú´Â∞æ‰ΩçÁΩÆ<strong>„Åß„ÅØ„Å™„ÅÑ</strong>„Åã„Çâ„Åß„Åô„ÄÇ</p>
<p>ÂÆüÈöõ„Å´„ÅØ„ÄÅPureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØÂÜçÂ∏∞Âëº„Å≥Âá∫„Åó„Çí„Ç∏„É£„É≥„Éó„Å´ÁΩÆ„ÅçÊèõ„Åà„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅÂÜçÂ∏∞ÁöÑ„Å™Èñ¢Êï∞ÂÖ®‰Ωì„Çí<strong>while„É´„Éº„Éó</strong>„Å´ÁΩÆ„ÅçÊèõ„Åà„Åæ„Åô„ÄÇ</p>
<p>‰ª•‰∏ã„ÅØ„Åô„Åπ„Å¶„ÅÆÂÜçÂ∏∞Âëº„Å≥Âá∫„Åó„ÅåÊú´Â∞æ‰ΩçÁΩÆ„Å´„ÅÇ„ÇãÂÜçÂ∏∞Èñ¢Êï∞„ÅÆ‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">factorialTailRec :: Int -&gt; Int -&gt; Int
factorialTailRec n acc =
  if n == 0
    then acc
    else factorialTailRec (n - 1) (acc * n)
</code></pre>
<p><code>fact</code>„Å∏„ÅÆÂÜçÂ∏∞Âëº„Å≥Âá∫„Åó„ÅØ„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅÆ‰∏≠„ÅßËµ∑„Åì„ÇãÊúÄÂæå„ÅÆ„ÇÇ„ÅÆ„Åß„ÅÇ„Çã„ÄÅ„Å§„Åæ„ÇäÊú´Â∞æ‰ΩçÁΩÆ„Å´„ÅÇ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="Á¥ØÁ©çÂô®"><a class="header" href="#Á¥ØÁ©çÂô®">Á¥ØÁ©çÂô®</a></h2>
<p>Êú´Â∞æÂÜçÂ∏∞„Åß„ÅØ„Å™„ÅÑÈñ¢Êï∞„ÇíÊú´Â∞æÂÜçÂ∏∞Èñ¢Êï∞„Å´Â§â„Åà„Çã‰∏ÄËà¨ÁöÑ„Å™ÊñπÊ≥ï„Å®„Åó„Å¶„ÅØ„ÄÅ<strong>Á¥ØÁ©çÂô®ÂºïÊï∞</strong> (accumulator parameter)
„Çí‰ΩøÁî®„Åô„ÇãÊñπÊ≥ï„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
Á¥ØÁ©çÂô®ÂºïÊï∞„ÅØÈñ¢Êï∞„Å´ËøΩÂä†„Åï„Çå„Çã‰ΩôÂâ∞„ÅÆÂºïÊï∞„ÅßËøî„ÇäÂÄ§„Çí<strong>Á¥ØÁ©ç</strong>„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
„Åì„Çå„ÅØÁµêÊûú„ÇíÁ¥ØÁ©ç„Åô„Çã„Åü„ÇÅ„Å´Ëøî„ÇäÂÄ§„Çí‰Ωø„ÅÜ„ÅÆ„Å®„ÅØÂØæÁß∞ÁöÑ„Åß„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞Á´†„ÅÆÂàù„ÇÅ„Å´Á§∫„Åó„Åü<code>length</code>Èñ¢Êï∞„ÇíÂÜçËÄÉ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">length :: forall a. Array a -&gt; Int
length arr =
  if null arr
    then 0
    else 1 + (length $ fromMaybe [] $ tail arr)
</code></pre>
<p>„Åì„ÅÆÂÆüË£Ö„ÅØÊú´Â∞æÂÜçÂ∏∞„Åß„ÅØ„Å™„ÅÑ„ÅÆ„Åß„ÄÅÂ§ß„Åç„Å™ÂÖ•ÂäõÈÖçÂàó„Å´ÂØæ„Åó„Å¶ÂÆüË°å„Åï„Çå„Çã„Å®„ÄÅ
ÁîüÊàê„Åï„Çå„ÅüJavaScript„ÅØ„Çπ„Çø„ÉÉ„ÇØ„Ç™„Éº„Éê„Éº„Éï„É≠„Éº„ÇíÁô∫Áîü„Åï„Åõ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åó„Åã„Åó‰ª£„Çè„Çä„Å´„ÄÅÁµêÊûú„ÇíËìÑÁ©ç„Åô„Çã„Åü„ÇÅ„ÅÆ2„Å§ÁõÆ„ÅÆÂºïÊï∞„ÇíÈñ¢Êï∞„Å´Â∞éÂÖ•„Åô„Çã„Åì„Å®„Åß„ÄÅ„Åì„Çå„ÇíÊú´Â∞æÂÜçÂ∏∞„Å´Â§â„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">lengthTailRec :: forall a. Array a -&gt; Int
lengthTailRec arr = length' arr 0
  where
  length' :: Array a -&gt; Int -&gt; Int
  length' arr' acc =
    if null arr'
      then acc
      else length' (fromMaybe [] $ tail arr') (acc + 1)
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅÈÖçÂàó„ÇíÈÄÜËª¢„Åï„Åõ„Çã‰ΩúÊ•≠„ÇíË£úÂä©Èñ¢Êï∞<code>length'</code>„Å´ÂßîË≠≤„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>length'</code>„ÅØÊú´Â∞æÂÜçÂ∏∞„Åß„Åô„ÄÇ
„Åù„ÅÆÂîØ‰∏Ä„ÅÆÂÜçÂ∏∞Âëº„Å≥Âá∫„Åó„ÅØ„ÄÅÊúÄÂæå„ÅÆÂ†¥Âêà„ÅÆÊú´Â∞æ‰ΩçÁΩÆ„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅÁîüÊàê„Åï„Çå„Åü„Ç≥„Éº„Éâ„Åå<strong>while„É´„Éº„Éó</strong>„Å®„Å™„Çä„ÄÅÂ§ß„Åç„Å™ÂÖ•Âäõ„Åß„ÇÇ„Çπ„Çø„ÉÉ„ÇØ„ÅåÊ∫¢„Çå„Å™„ÅÑ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ</p>
<p><code>lengthTailRec</code>„ÅÆÂÆüË£Ö„ÇíÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´Ë£úÂä©Èñ¢Êï∞<code>length'</code>„Å´ÁùÄÁõÆ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÂøÖÁÑ∂ÁöÑ„Å´Á¥ØÁ©çÂô®ÂºïÊï∞„Çí‰Ωø„Å£„Å¶ËøΩÂä†„ÅÆÁä∂ÊÖã‚Ä¶‚Ä¶„Åì„Çå„ÅØÈÉ®ÂàÜÁöÑ„Å™ÁµêÊûú„Åß„Åô‚Ä¶‚Ä¶„ÇíÁ∂≠ÊåÅ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
0„Åã„ÇâÂßã„Åæ„Çä„ÄÅÂÖ•Âäõ„ÅÆÈÖçÂàó‰∏≠„ÅÆÂÖ®„Å¶„ÅÆË¶ÅÁ¥†„Åù„Çå„Åû„Çå„Å´„Å§„ÅÑ„Å¶1„Åö„Å§Ë∂≥„Åó„Å¶ÊàêÈï∑„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>Á¥ØÁ©çÂô®„Çí„ÄåÁä∂ÊÖã„Äç„Å®ËÄÉ„Åà„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„Åå„ÄÅÁõ¥Êé•„Å´Â§âÊõ¥„Åå„Åï„Çå„Å¶„ÅÑ„Çã„Çè„Åë„Åß„ÅØ„Å™„ÅÑ„Åì„Å®„Å´„ÇÇÊ≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="ÊòéÁ§∫ÁöÑ„Å™ÂÜçÂ∏∞„Çà„ÇäÁï≥„ÅøËæº„Åø„ÇíÈÅ∏„Å∂"><a class="header" href="#ÊòéÁ§∫ÁöÑ„Å™ÂÜçÂ∏∞„Çà„ÇäÁï≥„ÅøËæº„Åø„ÇíÈÅ∏„Å∂">ÊòéÁ§∫ÁöÑ„Å™ÂÜçÂ∏∞„Çà„ÇäÁï≥„ÅøËæº„Åø„ÇíÈÅ∏„Å∂</a></h2>
<p>Êú´Â∞æÂÜçÂ∏∞„Çí‰ΩøÁî®„Åó„Å¶ÂÜçÂ∏∞Èñ¢Êï∞„ÇíË®òËø∞„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çå„Å∞Êú´Â∞æÂÜçÂ∏∞ÊúÄÈÅ©Âåñ„ÅÆÊÅ©ÊÅµ„ÇíÂèó„Åë„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„ÄÅ
„Åô„Åπ„Å¶„ÅÆÈñ¢Êï∞„Çí„Åì„ÅÆÂΩ¢„ÅßÊõ∏„Åì„ÅÜ„Å®„Åô„ÇãË™òÊÉë„Å´„Åã„Çâ„Çå„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅÂ§ö„Åè„ÅÆÈñ¢Êï∞„ÅØÈÖçÂàó„ÇÑ„Åù„Çå„Å´‰ºº„Åü„Éá„Éº„ÇøÊßãÈÄ†„Å´ÂØæ„Åô„ÇãÊäò„ÇäÁï≥„Åø„Å®„Åó„Å¶Áõ¥Êé•Êõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„Åì„Å®„ÇíÂøò„Çå„Åå„Å°„Åß„Åô„ÄÇ
<code>map</code>„ÇÑ<code>fold</code>„ÅÆ„Çà„ÅÜ„Å™„Ç≥„É≥„Éì„Éç„Éº„Çø„Çí‰Ωø„Å£„Å¶Áõ¥Êé•„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÊõ∏„Åè„Åì„Å®„Å´„ÅØ„ÄÅ„Ç≥„Éº„Éâ„ÅÆÂçòÁ¥î„Åï„Å®„ÅÑ„ÅÜÂà©ÁÇπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆ„Ç≥„É≥„Éì„Éç„Éº„Çø„ÅØ„Çà„ÅèÁü•„Çâ„Çå„Å¶„Åä„Çä„ÄÅÊòéÁ§∫ÁöÑ„Å™ÂÜçÂ∏∞„Çà„Çä„ÇÇ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆ<strong>ÊÑèÂõ≥</strong>„Çí„Çà„Çä„ÅØ„Å£„Åç„Çä„Å®„Åï„Åõ„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞<code>foldr</code>„Çí‰Ωø„Å£„Å¶ÈÖçÂàó„ÇíÂèçËª¢„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; :paste
‚Ä¶ reverse :: forall a. Array a -&gt; Array a
‚Ä¶ reverse = foldr (\x xs -&gt; xs &lt;&gt; [x]) []
‚Ä¶ ^D

&gt; reverse [1, 2, 3]
[3,2,1]
</code></pre>
<p><code>foldl</code>„Çí‰Ωø„Å£„Å¶<code>reverse</code>„ÇíÊõ∏„Åè„Åì„Å®„ÅØ„ÄÅË™≠ËÄÖ„Å∏„ÅÆË™≤È°å„Å®„Åó„Å¶ÊÆã„Åó„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-6"><a class="header" href="#ÊºîÁøí-6">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ<code>foldl</code>„Çí‰Ωø„Å£„Å¶ÁúüÂÅΩÂÄ§ÈÖçÂàó„ÅÆÂÄ§„ÅåÂÖ®„Å¶Áúü„ÅãÊ§úÊüª„Åô„ÇãÈñ¢Êï∞<code>allTrue</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄö„ÄÇ„ÉÜ„Çπ„Éà„Å™„ÅóÔºâÈñ¢Êï∞<code>foldl (==) false xs</code>„ÅåÁúü„ÇíËøî„Åô„Çà„ÅÜ„Å™ÈÖçÂàó<code>xs</code>„Å®„ÅØ„Å©„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„ÅãË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Ë®Ä„ÅÑÊèõ„Åà„Çã„Å®„ÄÅ„ÄåÈñ¢Êï∞„ÅØ<code>xs</code>„Åå‚Ä¶‚Ä¶„ÇíÂê´„ÇÄ„Å®„Åç„Å´<code>true</code>„ÇíËøî„Åô„Äç„Å®„ÅÑ„ÅÜÊñá„ÇíÂÆåÊàê„Åï„Åõ„Çã„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÊú´Â∞æÂÜçÂ∏∞„ÅÆÂΩ¢Âºè„ÇíÂèñ„Å£„Å¶„ÅÑ„Çã„Åì„Å®‰ª•Â§ñ„ÅØ<code>fib</code>„Å®Âêå„Åò„Çà„ÅÜ„Å™Èñ¢Êï∞<code>fibTailRec</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöÁ¥ØÁ©çÂô®ÂºïÊï∞„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>foldl</code>„Çí‰Ωø„Å£„Å¶<code>reverse</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
</ol>
<h2 id="‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†"><a class="header" href="#‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†">‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†</a></h2>
<p>„Åì„ÅÆÁØÄ„Åß„ÅØ„ÄÅ„Åì„Çå„Åæ„ÅßÂ≠¶„Çì„Å†„Åì„Å®„ÇíÂøúÁî®„Åó„Å¶„ÄÅÊ®°Êì¨ÁöÑ„Å™„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„ÅßÂãï‰Ωú„Åô„ÇãÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
‰∫ãÂâç„Å´ÂÆöÁæ©„Åï„Çå„ÅüAPI„ÅßÂãï‰Ωú„Åô„Çã„Çà„ÅÜ„Å´„ÄÅ„Éû„ÉÉ„Éó„ÄÅÁï≥„ÅøËæº„Åø„ÄÅ„Åä„Çà„Å≥„Éï„Ç£„É´„Çø„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Data.Path</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´‰ªÆÊÉ≥„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„ÅÆAPI„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li>„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†ÂÜÖ„ÅÆ„Éë„Çπ„ÇíË°®„ÅôÂûã<code>Path</code>„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</li>
<li>„É´„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíË°®„Åô„Éë„Çπ<code>root</code>„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</li>
<li><code>ls</code>Èñ¢Êï∞„ÅØ„Éá„Ç£„É¨„ÇØ„Éà„É™ÂÜÖ„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂàóÊåô„Åó„Åæ„Åô„ÄÇ</li>
<li><code>filename</code>Èñ¢Êï∞„ÅØ<code>Path</code>„ÅÆ„Éï„Ç°„Ç§„É´Âêç„ÇíËøî„Åó„Åæ„Åô„ÄÇ</li>
<li><code>size</code>Èñ¢Êï∞„ÅØ<code>Path</code>„ÅåÁ§∫„Åô„Éï„Ç°„Ç§„É´„ÅÆÂ§ß„Åç„Åï„ÇíËøî„Åó„Åæ„Åô„ÄÇ</li>
<li><code>isDirectory</code>Èñ¢Êï∞„ÅØ„Éï„Ç°„Ç§„É´„Åã„Éá„Ç£„É¨„ÇØ„Éà„É™„Åã„ÇíË™ø„Åπ„Åæ„Åô„ÄÇ</li>
</ul>
<p>Âûã„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅÂûãÂÆöÁæ©„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">root :: Path

ls :: Path -&gt; Array Path

filename :: Path -&gt; String

size :: Path -&gt; Maybe Int

isDirectory :: Path -&gt; Boolean
</code></pre>
<p>PSCi„Åß„Åì„ÅÆAPI„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Path

&gt; root
/

&gt; isDirectory root
true

&gt; ls root
[/bin/,/etc/,/home/]
</code></pre>
<p><code>Test.Examples</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ<code>Data.Path</code>API„Çí‰ΩøÁî®„Åô„ÇãÈñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Data.Path</code>„É¢„Ç∏„É•„Éº„É´„ÇíÂ§âÊõ¥„Åó„Åü„ÇäÂÆöÁæ©„ÇíÁêÜËß£„Åó„Åü„Çä„Åô„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
ÂÖ®„Å¶<code>Test.Examples</code>„É¢„Ç∏„É•„Éº„É´„Å†„Åë„Åß‰ΩúÊ•≠„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ‰∏ÄË¶ß"><a class="header" href="#„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ‰∏ÄË¶ß">„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ‰∏ÄË¶ß</a></h2>
<p>„Åù„Çå„Åß„ÅØ„ÄÅÂÜÖÂÅ¥„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„Åæ„Åß„ÄÅ„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂàóÊåô„Åô„ÇãÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å§„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">allFiles :: Path -&gt; Array Path
</code></pre>
<p>ÂÜçÂ∏∞„Çí‰Ωø„Å£„Å¶„Åì„ÅÆÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åæ„Åö„ÅØ<code>ls</code>„Çí‰ΩøÁî®„Åó„Å¶„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÁõ¥Êé•„ÅÆÂ≠ê„ÇíÂàóÊåô„Åó„Åæ„Åô„ÄÇ
„Åù„Çå„Åû„Çå„ÅÆÂ≠ê„Å´„Å§„ÅÑ„Å¶ÂÜçÂ∏∞ÁöÑ„Å´<code>allFiles</code>„ÇíÈÅ©Áî®„Åô„Çã„Å®„ÄÅ„Åù„Çå„Åû„Çå„Éë„Çπ„ÅÆÈÖçÂàó„ÅåËøî„Å£„Å¶„Åè„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
<code>concatMap</code>„ÇíÈÅ©Áî®„Åô„Çã„Å®„ÄÅ„Åì„ÅÆÁµêÊûú„ÇíÂêåÊôÇ„Å´Âπ≥Âù¶Âåñ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂæå„Å´„ÄÅconsÊºîÁÆóÂ≠ê<code>:</code>„Çí‰Ωø„Å£„Å¶ÁèæÂú®„ÅÆ„Éï„Ç°„Ç§„É´„ÇÇÂê´„ÇÅ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">allFiles file = file : concatMap allFiles (ls file)
</code></pre>
<p><strong>Ê≥®ÊÑè</strong>ÔºöconsÊºîÁÆóÂ≠ê<code>:</code>„ÅØ„ÄÅÂÆüÈöõ„Å´„ÅØ‰∏çÂ§â„Å™ÈÖçÂàó„Å´ÂØæ„Åó„Å¶„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÅåÊÇ™„ÅÑ„ÅÆ„Åß„ÄÅ‰∏ÄËà¨ÁöÑ„Å´„ÅØÊé®Â•®„Åï„Çå„Åæ„Åõ„Çì„ÄÇ
„É™„É≥„ÇØ„É™„Çπ„Éà„ÇÑ„Ç∑„Éº„Ç±„É≥„Çπ„Å™„Å©„ÅÆ‰ªñ„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„Çí‰ΩøÁî®„Åô„Çã„Å®„ÄÅ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÇíÂêë‰∏ä„Åï„Åõ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØPSCi„Åß„Åì„ÅÆÈñ¢Êï∞„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.Path

&gt; allFiles root

[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]
</code></pre>
<p>„Åô„Å∞„Çâ„Åó„ÅÑÔºÅ
doË®òÊ≥ï„ÅßÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Çí‰Ωø„Å£„Å¶„ÇÇ„Åì„ÅÆÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„ÅßË¶ã„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>ÈÄÜÂêë„Åç„ÅÆÁü¢Âç∞„ÅØÈÖçÂàó„Åã„ÇâË¶ÅÁ¥†„ÇíÈÅ∏Êäû„Åô„Çã„ÅÆ„Å´Áõ∏ÂΩì„Åô„Çã„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
ÊúÄÂàù„ÅÆÊâãÈ†Ü„ÅØ„ÄÅÂºïÊï∞„ÅÆÁõ¥Êé•„ÅÆÂ≠ê„Åã„ÇâË¶ÅÁ¥†„ÇíÈÅ∏Êäû„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ
„Åù„Çå„Åã„Çâ„ÄÅÂçò„Å´„Åù„ÅÆ„Éï„Ç°„Ç§„É´„Å´ÂØæ„Åó„Å¶„Åì„ÅÆÂÜçÂ∏∞Èñ¢Êï∞„ÇíÂëº„Å≥„Åó„Åæ„Åô„ÄÇ
doË®òÊ≥ï„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅÂÜçÂ∏∞ÁöÑ„Å™ÁµêÊûú„Çí„Åô„Åπ„Å¶ÈÄ£Áµê„Åô„Çã<code>concatMap</code>„ÅåÊöóÈªô„Å´Âëº„Å≥Âá∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Êñ∞„Åó„ÅÑ„Éê„Éº„Ç∏„Éß„É≥„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">allFiles' :: Path -&gt; Array Path
allFiles' file = file : do
  child &lt;- ls file
  allFiles' child
</code></pre>
<p>PSCi„ÅßÊñ∞„Åó„ÅÑ„Ç≥„Éº„Éâ„ÇíË©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Âêå„ÅòÁµêÊûú„ÅåËøî„Å£„Å¶„Åè„Çã„ÅØ„Åö„Åß„Åô„ÄÇ
„Å©„Å°„Çâ„ÅÆ„Åª„ÅÜ„Åå„Çè„Åã„Çä„ÇÑ„Åô„ÅÑ„Åã„ÅÆÈÅ∏Êäû„ÅØ„Åä‰ªª„Åõ„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-7"><a class="header" href="#ÊºîÁøí-7">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Çµ„Éñ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ‰∏≠„Åæ„Åß„ÄÅÔºà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÈô§„ÅèÔºâ„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÇíËøî„Åô„Çà„ÅÜ„Å™Èñ¢Êï∞<code>onlyFiles</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ„Éï„Ç°„Ç§„É´„ÇíÂêçÂâç„ÅßÊ§úÁ¥¢„Åô„ÇãÈñ¢Êï∞<code>whereIs</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÂûã<code>Maybe Path</code>„ÅÆÂÄ§„ÇíËøî„Åô„ÇÇ„ÅÆ„Å®„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÂÄ§„ÅåÂ≠òÂú®„Åô„Çã„Å™„Çâ„ÄÅ„Åù„ÅÆ„Éï„Ç°„Ç§„É´„Åå„Åù„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíË°®„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÊåØ„ÇãËàû„ÅÜÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; whereIs root &quot;ls&quot;
Just (/bin/)

&gt; whereIs root &quot;cat&quot;
Nothing
</code></pre>
<p><strong>„Éí„É≥„Éà</strong>Ôºö„Åì„ÅÆÈñ¢Êï∞„ÇídoË®òÊ≥ï„Çí‰Ωø„Å£„ÅüÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„ÅßÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>Path</code>„ÇíÂèñ„Å£„Å¶<code>Path</code>„Å´ÊúÄÂ§ß„ÅÆ„Éï„Ç°„Ç§„É´„Å®ÊúÄÂ∞è„ÅÆ„Éï„Ç°„Ç§„É´„Çí1„Å§„Åö„Å§Âê´„ÇÄÈÖçÂàó„ÇíËøî„ÅôÈñ¢Êï∞<code>largestSmallest</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>ÔºöÁ©∫ÈÖçÂàó„ÇÑ1Ë¶ÅÁ¥†„ÅÆÈÖçÂàó„ÇíËøî„Åô„Åì„Å®„Åß„ÄÅ
<code>Path</code>„Å´„Çº„É≠„Åã1ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´„Åå„ÅÇ„ÇãÂ†¥Âêà„Å´„Å§„ÅÑ„Å¶„ÇÇËÄÉÊÖÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-2"><a class="header" href="#„Åæ„Å®„ÇÅ-2">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíÁ∞°ÊΩî„Å´Ë°®Áèæ„Åô„ÇãÊâãÊÆµ„Å®„Åó„Å¶„ÄÅPureScript„Åß„ÅÆÂÜçÂ∏∞„ÅÆÂü∫Êú¨„ÇíË™¨Êòé„Åó„Åæ„Åó„Åü„ÄÇ
„Åæ„Åü„ÄÅÁã¨Ëá™„ÅÆ‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„ÇÑ„ÄÅ„Éû„ÉÉ„Éó„ÄÅ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„ÇÑÁï≥„ÅøËæº„Åø„Å™„Å©„ÅÆÈÖçÂàó„Å´ÂØæ„Åô„ÇãÊ®ôÊ∫ñÈñ¢Êï∞„ÄÅ
„Åä„Çà„Å≥„Åì„Çå„Çâ„ÅÆÊ¶ÇÂøµ„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„ÅüÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„ÇíÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇ
ÊúÄÂæå„Å´„ÄÅ„Çπ„Çø„ÉÉ„ÇØ„Ç™„Éº„Éê„Éº„Éï„É≠„Éº„Ç®„É©„Éº„ÇíÂõûÈÅø„Åô„Çã„Åü„ÇÅ„Å´Êú´Â∞æÂÜçÂ∏∞„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„ÅÆÈáçË¶ÅÊÄß„ÄÅ
Á¥ØÁ©çÂô®ÂºïÊï∞„Çí‰ΩøÁî®„Åó„Å¶Êú´Â∞æÂÜçÂ∏∞ÂΩ¢„Å´Èñ¢Êï∞„ÇíÂ§âÊèõ„Åô„ÇãÊñπÊ≥ï„ÇíÁ§∫„Åó„Åæ„Åó„Åü„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="„Éë„Çø„Éº„É≥ÁÖßÂêà"><a class="header" href="#„Éë„Çø„Éº„É≥ÁÖßÂêà">„Éë„Çø„Éº„É≥ÁÖßÂêà</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-3"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-3">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Å®„Éë„Çø„Éº„É≥ÁÖßÂêà„Å®„ÅÑ„ÅÜ„ÄÅ„Åµ„Åü„Å§„ÅÆÊñ∞„Åó„ÅÑÊ¶ÇÂøµ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„ÄÇ
„Åæ„Åü„ÄÅË°åÂ§öÁõ∏„Å®„ÅÑ„ÅÜPureScript„ÅÆÂûã„Ç∑„Çπ„ÉÜ„É†„ÅÆËààÂë≥Ê∑±„ÅÑÊ©üËÉΩ„Å´„Å§„ÅÑ„Å¶„ÇÇÁ∞°Âçò„Å´Âèñ„ÇäÊâ±„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><strong>„Éë„Çø„Éº„É≥ÁÖßÂêà</strong> (pattern matching) „ÅØÈñ¢Êï∞‚Äã‚ÄãÂûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Å´„Åä„Åë„Çã‰∏ÄËà¨ÁöÑ„Å™ÊâãÊ≥ï„Åß„ÄÅ
Ë§áÊï∞„ÅÆÂ†¥Âêà„Å´ÂÆüË£Ö„ÇíÂàÜËß£„Åô„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅÈñãÁô∫ËÄÖ„ÅØÊΩúÂú®ÁöÑ„Å´Ë§áÈõë„Å™Âãï‰Ωú„ÅÆÈñ¢Êï∞„ÇíÁ∞°ÊΩî„Å´Êõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅØPureScript„ÅÆÂûã„Ç∑„Çπ„ÉÜ„É†„ÅÆÊ©üËÉΩ„Åß„ÅÇ„Çä„ÄÅ
Âûã„ÅÆ„ÅÇ„ÇãË®ÄË™û„Å´„Åä„ÅÑ„Å¶ÂêåÊßò„ÅÆÊ∞¥Ê∫ñ„ÅÆË°®ÁèæÂäõ„ÇíÂèØËÉΩ„Å´„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Éë„Çø„Éº„É≥ÁÖßÂêà„Å®„ÇÇÂØÜÊé•„Å´Èñ¢ÈÄ£„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„ÅÆÁõÆÁöÑ„ÅØ„ÄÅ‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÇÑ„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ
ÂçòÁ¥î„Å™„Éô„ÇØ„Çø„Éº„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÊèèÁîª„ÅóÊìç‰Ωú„Åô„Çã„Åü„ÇÅ„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíÊõ∏„Åè„Åì„Å®„Åß„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-2"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-2">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ„Éï„Ç°„Ç§„É´ <code>src/Data/Picture.purs</code>„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Data.Picture</code>„É¢„Ç∏„É•„Éº„É´„ÅØ„ÄÅÁ∞°Âçò„Å™Âõ≥ÂΩ¢„ÇíË°®„Åô„Éá„Éº„ÇøÂûã <code>Shape</code>„ÇÑ„ÄÅÂõ≥ÂΩ¢„ÅÆÈõÜÂêà„Åß„ÅÇ„ÇãÂûã
<code>Picture</code>„ÄÅÂèä„Å≥„Åì„Çå„Çâ„ÅÆÂûã„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆÈñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„ÄÅ„Éá„Éº„ÇøÊßãÈÄ†„ÅÆÁï≥Ëæº„Åø„ÇíË°å„ÅÜÈñ¢Êï∞„ÇíÊèê‰æõ„Åô„Çã <code>Data.Foldable</code>„É¢„Ç∏„É•„Éº„É´„ÇÇ„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
</code></pre>
<p><code>Data.Picture</code>„É¢„Ç∏„É•„Éº„É´„ÅØ<code>Number</code>„É¢„Ç∏„É•„Éº„É´„ÇÇ„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åô„Åå„ÄÅ„Åì„Å°„Çâ„ÅØ<code>as</code>„Ç≠„Éº„ÉØ„Éº„Éâ„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Data.Number as Number
</code></pre>
<p>„Åì„Çå„ÅØÂûã„ÇÑÈñ¢Êï∞„Çí„É¢„Ç∏„É•„Éº„É´ÂÜÖ„Åß‰ΩøÁî®„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„Åå„ÄÅ
„Åù„Çå„ÅØ<code>Number.max</code>„ÅÆ„Çà„ÅÜ„Å´<strong>‰øÆÈ£æÂêç</strong>„Çí‰Ωø„Å£„Åü„Å®„Åç„ÅÆ„Åø„Åß„Åô„ÄÇ
„Åì„Çå„ÅØÈáçË§á„Åó„Åü„Ç§„É≥„Éù„Éº„Éà„ÇíÈÅø„Åë„Åü„Çä„ÄÅ
‰Ωï„Çâ„Åã„ÅÆ„ÇÇ„ÅÆ„Åå„Å©„ÅÆ„É¢„Ç∏„É•„Éº„É´„Åã„Çâ„Ç§„É≥„Éù„Éº„Éà„Åï„Çå„Åü„ÅÆ„Åã„ÇíÊòé„Çâ„Åã„Å´„Åô„Çã„ÅÆ„Å´ÂΩπÁ´ã„Å°„Åæ„Åô„ÄÇ</p>
<p><strong>Ê≥®ÊÑè</strong>ÔºöÂÖÉ„ÅÆ„É¢„Ç∏„É•„Éº„É´„Å®Âêå„Åò„É¢„Ç∏„É•„Éº„É´Âêç„Çí‰øÆÈ£æÂêç„Å´‰ΩøÁî®„Åô„Çã„ÅÆ„ÅØ‰∏çË¶Å„Åß„Åô„ÄÇ
<code>import Math as M</code>„Å™„Å©„ÅÆ„Çà„ÇäÁü≠„ÅÑÂêçÂâç„Å´„Åô„Çã„Åì„Å®„ÅØÂèØËÉΩ„Åß„Åô„Åó„ÄÅ„Åã„Å™„Çä„Çà„Åè„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥ÁÖßÂêà"><a class="header" href="#ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥ÁÖßÂêà">ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥ÁÖßÂêà</a></h2>
<p>„Åù„Çå„Åß„ÅØ„Ç≥„Éº„Éâ‰æã„ÇíË¶ã„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å¶2„Å§„ÅÆÊï¥Êï∞„ÅÆÊúÄÂ§ßÂÖ¨Á¥ÑÊï∞„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>„Åì„ÅÆ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅØ„É¶„Éº„ÇØ„É™„ÉÉ„Éâ„ÅÆ‰∫íÈô§Ê≥ï„Å®Âëº„Å∞„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åù„ÅÆÂÆöÁæ©„Çí„Ç™„É≥„É©„Ç§„É≥„ÅßÊ§úÁ¥¢„Åô„Çã„Å®„ÄÅ
„Åä„Åù„Çâ„Åè‰∏äË®ò„ÅÆ„Ç≥„Éº„Éâ„Å´„Çà„Åè‰ºº„ÅüÊï∞Â≠¶„ÅÆÊñπÁ®ãÂºè„ÅåË¶ã„Å§„Åã„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Éë„Çø„Éº„É≥ÁÖßÂêà„ÅÆÂà©ÁÇπ„ÅÆ„Å≤„Å®„Å§„ÅØ„ÄÅ
‰∏äË®ò„ÅÆ„Çà„ÅÜ„Å´„Ç≥„Éº„Éâ„ÇíÂ†¥ÂêàÂàÜ„Åë„Åó„Å¶ÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ
Êï∞Â≠¶Èñ¢Êï∞„ÅÆÂÆöÁæ©„Å®‰ºº„Åü„Çà„ÅÜ„Å™Á∞°ÊΩî„ÅßÂÆ£Ë®ÄÂûã„Å™„Ç≥„Éº„Éâ„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å¶Êõ∏„Åã„Çå„ÅüÈñ¢Êï∞„ÅØ„ÄÅ
Êù°‰ª∂„Å®ÁµêÊûú„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„Å´„Çà„Å£„Å¶Âãï‰Ωú„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÂÆöÁæ©„ÅÆÂêÑË°å„ÅØ<strong>ÈÅ∏ÊäûËÇ¢</strong> (alternative) „ÇÑ<strong>Â†¥Âêà</strong> (case) „Å®Âëº„Å∞„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Á≠âÂè∑„ÅÆÂ∑¶Ëæ∫„ÅÆÂºè„ÅØ<strong>„Éë„Çø„Éº„É≥</strong>„Å®Âëº„Å∞„Çå„Å¶„Åä„Çä„ÄÅ
„Åù„Çå„Åû„Çå„ÅÆÂ†¥Âêà„ÅØÁ©∫ÁôΩ„ÅßÂå∫Âàá„Çâ„Çå„Åü1„Å§‰ª•‰∏ä„ÅÆ„Éë„Çø„Éº„É≥„ÅßÊßãÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Â†¥Âêà„ÅÆÈõÜ„Åæ„Çä„ÅØ„ÄÅÁ≠âÂè∑„ÅÆÂè≥ÂÅ¥„ÅÆÂºè„ÅåË©ï‰æ°„Åï„ÇåÂÄ§„ÅåËøî„Åï„Çå„ÇãÂâç„Å´„ÄÅ
ÂºïÊï∞„ÅåÊ∫Ä„Åü„Åï„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„Å©„Çå„Åã„ÅÆÊù°‰ª∂„ÇíË°®Áèæ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åù„Çå„Åû„Çå„ÅÆÂ†¥Âêà„ÅØ‰∏ä„Åã„Çâ„Åì„ÅÆÈ†ÜÁï™„Å´Ë©¶„Åï„Çå„Å¶„ÅÑ„Åç„ÄÅ
ÊúÄÂàù„Å´ÂÖ•Âäõ„Å´ÈÅ©Âêà„Åó„ÅüÂ†¥Âêà„ÅåËøî„ÇäÂÄ§„ÇíÊ±∫ÂÆö„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅ <code>gcd</code>Èñ¢Êï∞„ÅØÊ¨°„ÅÆÊâãÈ†Ü„ÅßË©ï‰æ°„Åï„Çå„Åæ„Åô„ÄÇ</p>
<ul>
<li>„Åæ„ÅöÊúÄÂàù„ÅÆÂ†¥Âêà„ÅåË©¶„Åï„Çå„Åæ„Åô„ÄÇÁ¨¨2ÂºïÊï∞„Åå„Çº„É≠„ÅÆÂ†¥Âêà„ÄÅÈñ¢Êï∞„ÅØ <code>n</code>ÔºàÊúÄÂàù„ÅÆÂºï
Êï∞Ôºâ„ÇíËøî„Åó„Åæ„Åô„ÄÇ</li>
<li>„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞„ÄÅ2Áï™ÁõÆ„ÅÆÂ†¥Âêà„ÅåË©¶„Åï„Çå„Åæ„Åô„ÄÇÊúÄÂàù„ÅÆÂºïÊï∞„Åå„Çº„É≠„ÅÆÂ†¥Âêà„ÄÅÈñ¢Êï∞
„ÅØ <code>m</code>ÔºàÁ¨¨2ÂºïÊï∞Ôºâ„ÇíËøî„Åó„Åæ„Åô„ÄÇ</li>
<li>„Åù„Çå‰ª•Â§ñ„ÅÆÂ†¥Âêà„ÄÅÈñ¢Êï∞„ÅØÊúÄÂæå„ÅÆË°å„ÅÆÂºè„ÇíË©ï‰æ°„Åó„Å¶Ëøî„Åó„Åæ„Åô„ÄÇ</li>
</ul>
<p>„Éë„Çø„Éº„É≥„ÅØÂÄ§„ÇíÂêçÂâç„Å´ÊùüÁ∏õ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆ‰æã„ÅÆÂêÑË°å„Åß„ÅØ <code>n</code>„Å®„ÅÑ„ÅÜÂêçÂâç„Å® <code>m</code>„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆ‰∏°Êñπ„ÄÅ
„Åæ„Åü„ÅØ„Å©„Å°„Çâ„Åã‰∏ÄÊñπ„Å´„ÄÅÂÖ•Âäõ„Åï„Çå„ÅüÂÄ§„ÇíÊùüÁ∏õ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çà„Çä„Åï„Åæ„Åñ„Åæ„Å™Á®ÆÈ°û„ÅÆ„Éë„Çø„Éº„É≥„Å´„Å§„ÅÑ„Å¶Â≠¶„Å≥„Åæ„Åô„Åå„ÄÅ
„Åì„Çå„Çâ„ÅÆ„Éë„Çø„Éº„É≥„ÅØÂÖ•Âäõ„ÅÆÂºïÊï∞„Åã„ÇâÂêçÂâç„ÇíÈÅ∏„Å∂„Åï„Åæ„Åñ„Åæ„Å™ÊñπÊ≥ï„Å´ÂØæÂøú‰ªò„Åë„Çâ„Çå„Çã„Åì„Å®„Åå„Çè„Åã„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥"><a class="header" href="#ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥">ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥</a></h2>
<p>‰∏äË®ò„ÅÆ„Ç≥„Éº„Éâ‰æã„Åß„ÅØ„ÄÅ2Á®ÆÈ°û„ÅÆ„Éë„Çø„Éº„É≥„ÇíÁ§∫„Åó„Åæ„Åó„Åü„ÄÇ</p>
<ul>
<li><code>Int</code>Âûã„ÅÆÂÄ§„ÅåÊ≠£Á¢∫„Å´‰∏ÄËá¥„Åô„ÇãÂ†¥Âêà„Å´„ÅÆ„ÅøÈÅ©Âêà„Åô„Çã„ÄÅÊï¥Êï∞„É™„ÉÜ„É©„É´„Éë„Çø„Éº„É≥</li>
<li>ÂºïÊï∞„ÇíÂêçÂâç„Å´ÊùüÁ∏õ„Åô„Çã„ÄÅÂ§âÊï∞„Éë„Çø„Éº„É≥</li>
</ul>
<p>ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥„Å´„ÅØ‰ªñ„Å´„ÇÇÁ®ÆÈ°û„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>Number</code>„ÄÅ<code>String</code>„ÄÅ<code>Char</code>„ÄÅ„Åù„Åó„Å¶<code>Boolean</code>„Å®„ÅÑ„Å£„Åü„É™„ÉÜ„É©„É´</li>
<li>„Å©„Çì„Å™ÂºïÊï∞„Å®„ÇÇÈÅ©Âêà„Åô„Çã„ÅåÂêçÂâç„Å´ÊùüÁ∏õ„ÅØ„Åó„Å™„ÅÑ„ÄÅ„Ç¢„É≥„ÉÄ„Éº„Çπ„Ç≥„Ç¢ (<code>_</code>) „ÅßË°®
„Åï„Çå„Çã„ÉØ„Ç§„É´„Éâ„Ç´„Éº„Éâ„Éë„Çø„Éº„É≥</li>
</ul>
<p>„Åì„Åì„Åß„ÅØ„Åì„Çå„Çâ„ÅÆÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥„Çí‰ΩøÁî®„Åó„Åü„ÄÅ„Åï„Çâ„Å´2„Å§„ÅÆ‰æã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">fromString :: String -&gt; Boolean
fromString &quot;true&quot; = true
fromString _      = false

toString :: Boolean -&gt; String
toString true  = &quot;true&quot;
toString false = &quot;false&quot;
</code></pre>
<p>PSCi„Åß„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÇíË©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="„Ç¨„Éº„Éâ-1"><a class="header" href="#„Ç¨„Éº„Éâ-1">„Ç¨„Éº„Éâ</a></h2>
<p>„É¶„Éº„ÇØ„É™„ÉÉ„Éâ„ÅÆ‰∫íÈô§Ê≥ï„ÅÆ‰æã„Åß„ÅØ„ÄÅ<code>m &gt; n</code>„ÅÆ„Å®„Åç„Å® <code>m &lt;= n</code>„ÅÆ„Å®„Åç„ÅÆ2„Å§„Å´ÂàÜÂ≤ê„Åô„Çã„Åü„ÇÅ„Å´ <code>if .. then .. else</code>Âºè„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ
„Åì„ÅÜ„ÅÑ„ÅÜ„Å®„Åç„Å´„ÅØ‰ªñ„Å´<strong>„Ç¨„Éº„Éâ</strong> (guard) „Çí‰Ωø„ÅÜ„Å®„ÅÑ„ÅÜÈÅ∏ÊäûËÇ¢„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Ç¨„Éº„Éâ„ÅØ„Éë„Çø„Éº„É≥„Å´„Çà„ÇãÂà∂Á¥Ñ„Å´Âä†„Åà„Å¶Ê∫Ä„Åü„Åï„Çå„Å™„Åè„Å¶„ÅØ„ÅÑ„Åë„Å™„ÅÑÁúüÂÅΩÂÄ§„ÅÆÂºè„Åß„Åô„ÄÇ
„Ç¨„Éº„Éâ„Çí‰ΩøÁî®„Åó„Å¶„É¶„Éº„ÇØ„É™„ÉÉ„Éâ„ÅÆ‰∫íÈô§Ê≥ï„ÇíÊõ∏„ÅçÁõ¥„Åô„Å®„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">gcdV2 :: Int -&gt; Int -&gt; Int
gcdV2 n 0 = n
gcdV2 0 n = n
gcdV2 n m | n &gt; m     = gcdV2 (n - m) m
          | otherwise = gcdV2 n (m - n)
</code></pre>
<p>„Åì„ÅÆÂ†¥Âêà„ÄÅ3Ë°åÁõÆ„Åß„ÅØ„Ç¨„Éº„Éâ„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊúÄÂàù„ÅÆÂºïÊï∞„ÅåÁ¨¨2ÂºïÊï∞„Çà„Çä„ÇÇÂé≥ÂØÜ„Å´Â§ß„Åç„ÅÑ„Å®„ÅÑ„ÅÜÊù°‰ª∂„Çí‰ªò„ÅëÂä†„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÊúÄÂæå„ÅÆË°å„Åß„ÅÆ„Ç¨„Éº„Éâ„ÅØÂºè<code>otherwise</code>„Çí‰Ωø„Å£„Å¶„Åä„Çä„ÄÅ„Ç≠„Éº„ÉØ„Éº„Éâ„ÅÆ„Çà„ÅÜ„Å´„ÇÇË¶ã„Åà„Åæ„Åô„Åå„ÄÅ
ÂÆüÈöõ„Å´„ÅØ„Åü„Å†„ÅÆ<code>Prelude</code>„Å´„Åä„Åë„ÇãÈÄöÂ∏∏„ÅÆÊùüÁ∏õ„Å™„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :type otherwise
Boolean

&gt; otherwise
true
</code></pre>
<p>„Åì„ÅÆ‰æã„ÅåÁ§∫„Åô„Çà„ÅÜ„Å´„ÄÅ„Ç¨„Éº„Éâ„ÅØÁ≠âÂè∑„ÅÆÂ∑¶ÂÅ¥„Å´Áèæ„Çå„ÄÅ„Éë„Ç§„ÉóÊñáÂ≠ó (<code>|</code>) „Åß„Éë„Çø„Éº„É≥„ÅÆ„É™„Çπ„Éà„Å®Âå∫Âàá„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-8"><a class="header" href="#ÊºîÁøí-8">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÈöé‰πóÈñ¢Êï∞<code>factorial</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<strong>„Éí„É≥„Éà</strong>:ÂÖ•Âäõ„Åå„Çº„É≠„ÅÆ„Å®„Åç„Å®„Çº„É≠„Åß„Å™„ÅÑ„Å®„Åç„ÅÆ„ÄÅ„Åµ„Åü„Å§„ÅÆ„Ç≥„Éº„Éä„Éº„Ç±„Éº„Çπ„ÇíËÄÉ„Åà„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„Çå„ÅØÂâç„ÅÆÁ´†„Åã„Çâ„ÅÆ‰æã„ÅÆÁπ∞„ÇäËøî„Åó„Åß„Åô„Åå„ÄÅ„Åì„Åì„Åß„ÅØËá™Âäõ„ÅßÊõ∏„ÅçÁõ¥„Åõ„Çã„Åã„ÇÑ„Å£„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ\( (1 + x) ^ n \)„ÇíÂ§öÈ†ÖÂºèÂ±ïÈñã„Åó„ÅüÂºè„Å´„ÅÇ„Çã
\( x ^ k \)„ÅÆÈ†Ö„ÅÆ‰øÇÊï∞„ÇíÊ±Ç„ÇÅ„ÇãÈñ¢Êï∞<code>binomial</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„ÅØ<code>n</code>Ë¶ÅÁ¥†„ÅÆÈõÜÂêà„Åã„Çâ<code>k</code>Ë¶ÅÁ¥†„ÅÆÈÉ®ÂàÜÈõÜÂêà„ÇíÈÅ∏„Å∂ÊñπÊ≥ï„ÅÆÊï∞„Å®Âêå„Åò„Åß„Åô„ÄÇ
Êï∞Âºè\( n! / k! (n - k)! \)„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Åì„Åß \( ! \) „ÅØÂâç„Å´Êõ∏„ÅÑ„ÅüÈöé‰πóÈñ¢Êï∞„Åß„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰Ωø„Å£„Å¶„Ç≥„Éº„Éä„Éº„Ç±„Éº„Çπ„ÇíÂà∂Âæ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Èï∑„ÅÑÊôÇÈñì„ÅåÊéõ„Åã„Å£„Åü„Çä„Ç≥„Éº„É´„Çπ„Çø„ÉÉ„ÇØ„ÅÆ„Ç®„É©„Éº„Åß„ÇØ„É©„ÉÉ„Ç∑„É•„Åó„Åü„Çä„Åó„Åü„Çâ„ÄÅ
„ÇÇ„Å£„Å®„Ç≥„Éº„Éä„Éº„Ç±„Éº„Çπ„ÇíËøΩÂä†„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<a href="https://en.wikipedia.org/wiki/Pascal%27s_rule"><strong>„Éë„Çπ„Ç´„É´„ÅÆÊ≥ïÂâá</strong></a>„Çí‰Ωø„Å£„Å¶
Ââç„ÅÆÊºîÁøí„ÅÆÂêå„Åò2È†Ö‰øÇÊï∞„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞<code>pascal</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="ÈÖçÂàó„Éë„Çø„Éº„É≥"><a class="header" href="#ÈÖçÂàó„Éë„Çø„Éº„É≥">ÈÖçÂàó„Éë„Çø„Éº„É≥</a></h2>
<p><strong>ÈÖçÂàó„É™„ÉÜ„É©„É´„Éë„Çø„Éº„É≥</strong> (array literal patterns) „ÅØ„ÄÅÂõ∫ÂÆöÈï∑„ÅÆÈÖçÂàó„Å´ÂØæ„Åó„Å¶ÁÖßÂêà„ÇíË°å„ÅÜÊñπÊ≥ï„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
„Åü„Å®„Åà„Å∞„ÄÅÁ©∫„ÅÆÈÖçÂàó„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁâπÂÆö„Åô„ÇãÈñ¢Êï∞ <code>isEmpty</code>„ÇíÊõ∏„Åç„Åü„ÅÑ„Å®„Åó„Åæ„Åô„ÄÇ
ÊúÄÂàù„ÅÆÈÅ∏ÊäûËÇ¢„Å´Á©∫„ÅÆÈÖçÂàó„Éë„Çø„Éº„É≥ (<code>[]</code>) „ÇíÁî®„ÅÑ„Çã„Å®„Åì„Çå„ÇíÂÆüÁèæ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty [] = true
isEmpty _ = false
</code></pre>
<p>Ê¨°„ÅÆÈñ¢Êï∞„Åß„ÅØ„ÄÅÈï∑„Åï5„ÅÆÈÖçÂàó„Å®ÈÅ©Âêà„Åó„ÄÅÈÖçÂàó„ÅÆ5„Å§„ÅÆË¶ÅÁ¥†„Çí„Åù„Çå„Åû„ÇåÁï∞„Å™„Å£„ÅüÊñπÊ≥ï„ÅßÊùüÁ∏õ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">takeFive :: Array Int -&gt; Int
takeFive [0, 1, a, b, _] = a * b
takeFive _ = 0
</code></pre>
<p>ÊúÄÂàù„ÅÆ„Éë„Çø„Éº„É≥„ÅØ„ÄÅÁ¨¨1Ë¶ÅÁ¥†„Å®Á¨¨2Ë¶ÅÁ¥†„Åå„Åù„Çå„Åû„Çå0„Å®1„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™„ÄÅ5Ë¶ÅÁ¥†„ÅÆÈÖçÂàó„Å´„ÅÆ„ÅøÈÅ©Âêà„Åó„Åæ„Åô„ÄÇ
„Åù„ÅÆÂ†¥Âêà„ÄÅÈñ¢Êï∞„ÅØÁ¨¨3Ë¶ÅÁ¥†„Å®Á¨¨4Ë¶ÅÁ¥†„ÅÆÁ©ç„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åù„Çå‰ª•Â§ñ„ÅÆÂ†¥Âêà„ÅØ„ÄÅÈñ¢Êï∞„ÅØ0„ÇíËøî„Åó„Åæ„Åô„ÄÇ
PSCi„ÅßË©¶„Åó„Å¶„Åø„Çã„Å®„ÄÅ„Åü„Å®„Åà„Å∞Ê¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ takeFive [0, 1, a, b, _] = a * b
‚Ä¶ takeFive _ = 0
‚Ä¶ ^D

&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0
</code></pre>
<p>ÈÖçÂàó„ÅÆ„É™„ÉÜ„É©„É´„Éë„Çø„Éº„É≥„Åß„ÅØ„ÄÅÂõ∫ÂÆöÈï∑„ÅÆÈÖçÂàó„Å®‰∏ÄËá¥„Åï„Åõ„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åô„Åå„ÄÅ
PureScript„ÅØ‰∏çÁâπÂÆö„ÅÆÈï∑„Åï„ÅÆÈÖçÂàó„ÇíÁÖßÂêà„Åï„Åõ„ÇãÊâãÊÆµ„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ
„Åù„ÅÆ„Çà„ÅÜ„Å™ÊñπÊ≥ï„Åß‰∏çÂ§â„Å™ÈÖçÂàó„ÇíÂàÜËß£„Åô„Çã„Å®„ÄÅ
ÂÆüË°åÈÄüÂ∫¶„Åå‰Ωé‰∏ã„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ
„Åì„ÅÆÁ®Æ„ÅÆÁÖßÂêà„ÇíË°å„ÅÜ„Åì„Å®„Åå„Åß„Åç„Çã„Éá„Éº„ÇøÊßãÈÄ†„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØ„ÄÅ
<code>Data.List</code>„Çí‰Ωø„ÅÜ„Åì„Å®„Çí„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ
„Åù„ÅÆ„Åª„Åã„ÅÆÊìç‰Ωú„Å´„Å§„ÅÑ„Å¶„ÄÅ
„Çà„ÇäÂÑ™„Çå„ÅüÊº∏ËøëÊÄßËÉΩ„ÇíÊèê‰æõ„Åô„Çã„Éá„Éº„ÇøÊßãÈÄ†„ÇÇÂ≠òÂú®„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„Å®Ë°åÂ§öÁõ∏"><a class="header" href="#„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„Å®Ë°åÂ§öÁõ∏">„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„Å®Ë°åÂ§öÁõ∏</a></h2>
<p><strong>„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥</strong> (Record patterns) „ÅØÔºà„ÅîÊÉ≥ÂÉè„ÅÆ„Å®„Åä„ÇäÔºâ„É¨„Ç≥„Éº„Éâ„Å´ÁÖßÂêà„Åó„Åæ„Åô„ÄÇ</p>
<p>„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„ÅØ„É¨„Ç≥„Éº„Éâ„É™„ÉÜ„É©„É´„Å´Ë¶ã„ÅüÁõÆ„Åå‰ºº„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
„É¨„Ç≥„Éº„Éâ„É™„ÉÜ„É©„É´„Åß„É©„Éô„É´„Å®Âºè„Çí<strong>„Ç≥„É≠„É≥</strong>„ÅßÂå∫Âàá„Çã„ÅÆ„Å®„ÅØÁï∞„Å™„Çä„ÄÅ
„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„Åß„ÅØ„É©„Éô„É´„Å®„Éë„Çø„Éº„É≥„Çí<strong>Á≠âÂè∑</strong>„ÅßÂå∫Âàá„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅÊ¨°„ÅÆ„Éë„Çø„Éº„É≥„ÅØ <code>first</code>„Å® <code>last</code>„Å®Âëº„Å∞„Çå„Çã„Éï„Ç£„Éº„É´„Éâ„ÅåÂê´„Åæ„Çå„Åü‰ªªÊÑè„ÅÆ„É¨„Ç≥„Éº„Éâ„Å´„Éû„ÉÉ„ÉÅ„Åó„ÄÅ
„Åì„Çå„Çâ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅÆÂÄ§„ÅØ„Åù„Çå„Åû„Çå <code>x</code>„Å® <code>y</code>„Å®„ÅÑ„ÅÜÂêçÂâç„Å´ÊùüÁ∏õ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">showPerson :: { first :: String, last :: String } -&gt; String
showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x
</code></pre>
<p>„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„ÅØPureScript„ÅÆÂûã„Ç∑„Çπ„ÉÜ„É†„ÅÆËààÂë≥Ê∑±„ÅÑÊ©üËÉΩ„Åß„ÅÇ„Çã
<strong>Ë°åÂ§öÁõ∏</strong> (row polymorphism) „ÅÆËâØ„ÅÑ‰æã„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„ÇÇ„Åó‰∏ä„ÅÆ<code>showPerson</code>„ÇíÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„Å™„Åó„ÅßÂÆöÁæ©„Åó„Å¶„ÅÑ„Åü„Å®„Åô„Çã„Å®„ÄÅ
„Åì„ÅÆÂûã„ÅØ„Å©„ÅÆ„Çà„ÅÜ„Å´Êé®Ë´ñ„Åï„Çå„Çã„ÅÆ„Åß„Åó„Çá„ÅÜ„ÅãÔºü
Èù¢ÁôΩ„ÅÑ„Åì„Å®„Å´„ÄÅÊé®Ë´ñ„Åï„Çå„ÇãÂûã„ÅØ‰∏ä„Åß‰∏é„Åà„ÅüÂûã„Å®„ÅØÂêå„Åò„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x

&gt; :type showPerson
forall r. { first :: String, last :: String | r } -&gt; String
</code></pre>
<p>„Åì„ÅÆÂûãÂ§âÊï∞ <code>r</code>„Å®„ÅØ‰Ωï„Åß„Åó„Çá„ÅÜ„ÅãÔºü
PSCi„Åß <code>showPerson</code>„Çí‰Ωø„Å£„Å¶„Åø„Çã„Å®„ÄÅÈù¢ÁôΩ„ÅÑ„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;
</code></pre>
<p>„É¨„Ç≥„Éº„Éâ„Å´„Åù„Çå‰ª•Â§ñ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Å¶„ÇÇ„ÄÅ
<code>showPerson</code>Èñ¢Êï∞„ÅØ„Åù„ÅÆ„Åæ„ÅæÂãï‰Ωú„Åô„Çã„ÅÆ„Åß„Åô„ÄÇ
Âûã„Åå <code>String</code>„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™„Éï„Ç£„Éº„É´„Éâ <code>first</code>„Å® <code>last</code>„Åå„É¨„Ç≥„Éº„Éâ„Å´Â∞ë„Å™„Åè„Å®„ÇÇÂê´„Åæ„Çå„Å¶„ÅÑ„Çå„Å∞„ÄÅ
Èñ¢Êï∞ÈÅ©Áî®„ÅØÊ≠£„Åó„ÅèÂûã‰ªò„Åë„Åï„Çå„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Éï„Ç£„Éº„É´„Éâ„Åå<strong>‰∏çË∂≥</strong>„Åó„Å¶„ÅÑ„Çã„Å®„ÄÅ <code>showPerson</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÅØ<strong>‰∏çÊ≠£</strong>„Å®„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot; }

Type of expression lacks required label &quot;last&quot;
</code></pre>
<p><code>showPerson</code>„ÅÆÊñ∞„Åó„ÅÑÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíË™≠„ÇÄ„Å®„ÄÅ„Äå<code>String</code>„Å™<code>first</code>„Å®<code>last</code>„Éï„Ç£„Éº„É´„Éâ<strong>„Å®‰ªñ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Çí‰Ωï„Åß„ÇÇ</strong>ÊåÅ„Å§„ÅÇ„Çâ„ÇÜ„Çã„É¨„Ç≥„Éº„Éâ„ÇíÂèñ„Çä„ÄÅ<code>String</code>„ÇíËøî„Åô„Äç„Å®„Å™„Çä„Åæ„Åô„ÄÇ
„Å™„Åä„ÄÅ„Åì„ÅÆÊåØËàû„ÅÑ„ÅØÂÖÉ„ÅÆ<code>showPerson</code>„ÅÆ„ÇÇ„ÅÆ„Å®„ÅØÁï∞„Å™„Çä„Åæ„Åô„ÄÇ
Ë°åÂ§âÊï∞<code>r</code>„Åå„Å™„Åë„Çå„Å∞<code>showPerson</code>„ÅØ<strong>Âé≥ÂØÜ„Å´</strong><code>first</code>„Å®<code>last</code>„Éï„Ç£„Éº„É´„Éâ„Åó„Åã„Å™„ÅÑ„É¨„Ç≥„Éº„Éâ„ÅÆ„Åø„ÇíÂèó„Åë‰ªò„Åë„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„Åì„Å®„Å´„ÇÇÊ≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">&gt; showPerson p = p.last &lt;&gt; &quot;, &quot; &lt;&gt; p.first
</code></pre>
<p>„Åì„ÅÆÂ†¥Âêà„ÇÇ„ÄÅ PSCi„ÅØÂÖà„Åª„Å©„Å®Âêå„ÅòÂûã„ÇíÊé®Ë´ñ„Åô„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="„É¨„Ç≥„Éº„ÉâÂêåÂêçÂà©Áî®"><a class="header" href="#„É¨„Ç≥„Éº„ÉâÂêåÂêçÂà©Áî®">„É¨„Ç≥„Éº„ÉâÂêåÂêçÂà©Áî®</a></h2>
<p><code>showPerson</code>Èñ¢Êï∞„ÅØÂºïÊï∞ÂÜÖ„ÅÆ„É¨„Ç≥„Éº„Éâ„Å®‰∏ÄËá¥„Åó„ÄÅ
<code>first</code>„Å®<code>last</code>„Éï„Ç£„Éº„É´„Éâ„Çí<code>x</code>„Å® <code>y</code>„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆÂÄ§„Å´ÊùüÁ∏õ„Åó„Å¶„ÅÑ„Åü„ÅÆ„Åß„Åó„Åü„ÄÇ
Âà•„ÅÆÊñπÊ≥ï„Å®„Åó„Å¶„ÄÅ„Éï„Ç£„Éº„É´„ÉâÂêçËá™‰Ωì„ÇíÂÜçÂà©Áî®„Åô„Çã„Å†„Åë„Åß„ÄÅ„Åì„ÅÆ„Çà„ÅÜ„Å™„Éë„Çø„Éº„É≥‰∏ÄËá¥„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂçòÁ¥îÂåñ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">showPersonV2 :: { first :: String, last :: String } -&gt; String
showPersonV2 { first, last } = last &lt;&gt; &quot;, &quot; &lt;&gt; first
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅ„Éó„É≠„Éë„ÉÜ„Ç£„ÅÆÂêçÂâç„ÅÆ„Åø„ÇíÊåáÂÆö„Åó„ÄÅÂêçÂâç„Å´Â∞éÂÖ•„Åó„Åü„ÅÑÂÄ§„ÇíÊåáÂÆö„Åô„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Åì„Çå„ÅØ<strong>„É¨„Ç≥„Éº„ÉâÂêåÂêçÂà©Áî®</strong> (record pun) „Å®Âëº„Å∞„Çå„Åæ„Åô„ÄÇ</p>
<p>„É¨„Ç≥„Éº„ÉâÂêåÂêçÂà©Áî®„Çí„É¨„Ç≥„Éº„Éâ„ÅÆ<strong>ÊßãÁØâ</strong>„Å´‰ΩøÁî®„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞„ÄÅ„Çπ„Ç≥„Éº„ÉóÂÜÖ„Å´ <code>first</code>„Å® <code>last</code>„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆÂÄ§„Åå„ÅÇ„Çå„Å∞„ÄÅ
<code>{ first, last }</code>„Çí‰Ωø„Å£„Å¶‰∫∫Áâ©„É¨„Ç≥„Éº„Éâ„Çí‰Ωú„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = &quot;Jane&quot;
    last  = &quot;Doe&quot;
</code></pre>
<p>„Åì„Çå„ÅØ„ÄÅÁä∂Ê≥Å„Å´„Çà„Å£„Å¶„ÅØ„Ç≥„Éº„Éâ„ÅÆÂèØË™≠ÊÄß„ÇíÂêë‰∏ä„Åï„Åõ„Çã„ÅÆ„Å´ÂΩπÁ´ã„Å°„Åæ„Åô„ÄÇ</p>
<h2 id="ÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„Åü„Éë„Çø„Éº„É≥"><a class="header" href="#ÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„Åü„Éë„Çø„Éº„É≥">ÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„Åü„Éë„Çø„Éº„É≥</a></h2>
<p>ÈÖçÂàó„Éë„Çø„Éº„É≥„Å®„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„ÅØ„Å©„Å°„Çâ„ÇÇÂ∞è„Åï„Å™„Éë„Çø„Éº„É≥„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Åì„Å®„ÅßÂ§ß„Åç„Å™„Éë„Çø„Éº„É≥„ÇíÊßãÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Åæ„Åß„ÅÆ‰æã„Åß„ÅØ„Åª„Å®„Çì„Å©„ÅÆÂ†¥Âêà„ÅßÈÖçÂàó„Éë„Çø„Éº„É≥„Å®„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„ÅÆÂÜÖÈÉ®„Å´ÂçòÁ¥î„Å™„Éë„Çø„Éº„É≥„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅ
„Éë„Çø„Éº„É≥„ÅåËá™Áî±„Å´<strong>ÂÖ•„ÇåÂ≠ê</strong>„Å´„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Åì„Å®„ÇÇÁü•„Å£„Å¶„Åä„Åè„ÅÆ„ÅåÂ§ßÂàá„Åß„Åô„ÄÇ
ÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„Åü„Éë„Çø„Éº„É≥„Çí‰Ωø„ÅÜ„Å®„ÄÅ
ÊΩúÂú®ÁöÑ„Å´Ë§áÈõë„Å™„Éá„Éº„ÇøÂûã„Å´ÂØæ„Åó„Å¶„ÅÆÊù°‰ª∂ÂàÜÂ≤ê„ÇíÁî®„ÅÑ„Å¶Èñ¢Êï∞„ÇíÂÆöÁæ©„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅ„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØ2„Å§„ÅÆ„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„ÇíÁµêÂêà„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Address = { street :: String, city :: String }

type Person = { name :: String, address :: Address }

livesInLA :: Person -&gt; Boolean
livesInLA { address: { city: &quot;Los Angeles&quot; } } = true
livesInLA _ = false
</code></pre>
<h2 id="ÂêçÂâç‰ªò„Åç„Éë„Çø„Éº„É≥"><a class="header" href="#ÂêçÂâç‰ªò„Åç„Éë„Çø„Éº„É≥">ÂêçÂâç‰ªò„Åç„Éë„Çø„Éº„É≥</a></h2>
<p>ÂÖ•„ÇåÂ≠ê„ÅÆ„Éë„Çø„Éº„É≥„Çí‰Ωø„ÅÜÂ†¥Âêà„ÄÅ„Éë„Çø„Éº„É≥„Å´„ÅØ<strong>ÂêçÂâç„Çí‰ªò„Åë</strong>„Å¶ËøΩÂä†„ÅßÂêçÂâç„Çí„Çπ„Ç≥„Éº„Éó„Å´ÊåÅ„Å°Ëæº„ÇÄ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
‰ªªÊÑè„ÅÆ„Éë„Çø„Éº„É≥„Å´ÂêçÂâç„Çí‰ªò„Åë„Çã„Å´„ÅØ„ÄÅ <code>@</code>Ë®òÂè∑„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅÊ¨°„ÅÆÈñ¢Êï∞„ÅØ2Ë¶ÅÁ¥†ÈÖçÂàó„ÇíÊï¥Âàó„Åô„Çã„ÇÇ„ÅÆ„Åß„ÄÅ2„Å§„ÅÆË¶ÅÁ¥†„ÅÆÂêçÂâç„Çí‰ªò„Åë„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
ÈÖçÂàóËá™Ë∫´„Å´„ÇÇÂêçÂâç„Çí‰ªò„Åë„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">sortPair :: Array Int -&gt; Array Int
sortPair arr@[x, y]
  | x &lt;= y = arr
  | otherwise = [y, x]
sortPair arr = arr
</code></pre>
<p>„Åì„ÅÆ„Çà„ÅÜ„Å´„Åô„Çå„Å∞ÂØæ„ÅåÊó¢„Å´Êï¥Âàó„Åï„Çå„Å¶„ÅÑ„Çã„Å®„Åç„Å´Êñ∞„Åó„ÅÑÈÖçÂàó„ÇíÂâ≤„ÇäÂΩì„Å¶„Å™„Åè„Å¶Ê∏à„Åø„Åæ„Åô„ÄÇ
„Å™„Åä„ÇÇ„ÅóÂÖ•Âäõ„ÅÆÈÖçÂàó„Åå<strong>Âé≥ÂØÜ„Å´</strong>2„Å§„ÅÆË¶ÅÁ¥†„ÇíÂê´„Çì„Åß„ÅÑ„Å™„Åë„Çå„Å∞„ÄÅ
„Åü„Å®„ÅàÊï¥Âàó„Åï„Çå„Å¶„ÅÑ„Å™„Åã„Å£„Åü„Å®„Åó„Å¶„ÇÇ„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØÂçò„Å´ÂÖÉ„ÅÆ„Åæ„ÅæÂ§â„Åà„Åö„Å´Ëøî„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-9"><a class="header" href="#ÊºîÁøí-9">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„Çí‰Ωø„Å£„Å¶„ÄÅ
2„Å§„ÅÆ <code>Person</code>„É¨„Ç≥„Éº„Éâ„ÅåÂêå„ÅòÈÉΩÂ∏Ç„Å´„ÅÑ„Çã„ÅãÊé¢„ÅôÈñ¢Êï∞ <code>sameCity</code>„ÇíÂÆöÁæ©„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâË°åÂ§öÁõ∏„ÇíËÄÉÊÖÆ„Åô„Çã„Å®„ÄÅ <code>sameCity</code>Èñ¢Êï∞„ÅÆÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Å™Âûã„ÅØ‰Ωï„Åß„Åó„Çá„ÅÜ„ÅãÔºü
ÂÖà„Åª„Å©ÂÆöÁæ©„Åó„Åü <code>livesInLA</code>Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„ÅãÔºü
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÉÜ„Çπ„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÈÖçÂàó„É™„ÉÜ„É©„É´„Éë„Çø„Éº„É≥„Çí‰Ωø„Å£„Å¶„ÄÅ
1Ë¶ÅÁ¥†„ÅÆÈÖçÂàó„ÅÆÂîØ‰∏Ä„ÅÆ„É°„É≥„Éê„Éº„ÇíÊäΩÂá∫„Åô„ÇãÈñ¢Êï∞<code>fromSingleton</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
1Ë¶ÅÁ¥†„Å†„Åë„ÇíÊåÅ„Å§ÈÖçÂàó„Åß„Å™„ÅÑÂ†¥Âêà„ÄÅ
Èñ¢Êï∞„ÅØÊåáÂÆö„Åï„Çå„Åü„Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíËøî„Åï„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ <code>forall a. a -&gt; Array a -&gt; a</code>„Å®„ÅÑ„ÅÜÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</li>
</ol>
<h2 id="caseÂºè"><a class="header" href="#caseÂºè">CaseÂºè</a></h2>
<p>„Éë„Çø„Éº„É≥„ÅØÊúÄ‰∏ä‰Ωç„Å´„ÅÇ„ÇãÈñ¢Êï∞ÂÆ£Ë®Ä„Å†„Åë„Å´Áèæ„Çå„Çã„Çè„Åë„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
<code>case</code>Âºè„Çí‰Ωø„Å£„Å¶Ë®àÁÆó„ÅÆÈÄî‰∏≠„ÅÆÂÄ§„Å´ÂØæ„Åó„Å¶„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
caseÂºè„Å´„ÅØÁÑ°ÂêçÈñ¢Êï∞„Å´‰ºº„ÅüÁ®ÆÈ°û„ÅÆ‰æøÂà©„Åï„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
Èñ¢Êï∞„Å´ÂêçÂâç„Çí‰∏é„Åà„Çã„Åì„Å®„Åå„ÅÑ„Å§„ÇÇÊúõ„Åæ„Åó„ÅÑ„Çè„Åë„Åß„ÅØ„Å™„ÅÑ„Çà„ÅÜ„Å´„ÄÅ
„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰Ωø„ÅÑ„Åü„ÅÑ„Åü„ÇÅ„Å†„Åë„Å´Èñ¢Êï∞„Å´ÂêçÂâç„Çí„Å§„Åë„Çã„Çà„ÅÜ„Å™„Åì„Å®„ÇíÈÅø„Åë„Çâ„Çå„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>‰æã„ÇíÁ§∫„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
Ê¨°„ÅÆÈñ¢Êï∞„ÅØ„ÄÅÈÖçÂàó„ÅÆ„ÄåÊúÄÈï∑„Çº„É≠Êú´Â∞æ„ÄçÔºàÂíå„Åå„Çº„É≠„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™„ÄÅÊúÄ„ÇÇÈï∑„ÅÑÈÖçÂàó„ÅÆÊú´Â∞æÔºâ„ÇíË®àÁÆó„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Data.Array (tail)
import Data.Foldable (sum)
import Data.Maybe (fromMaybe)

lzs :: Array Int -&gt; Array Int
lzs [] = []
lzs xs = case sum xs of
           0 -&gt; xs
           _ -&gt; lzs (fromMaybe [] $ tail xs)
</code></pre>
<p>‰ª•‰∏ã„ÅØ‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÂ†¥Âêà„Åî„Å®„ÅÆÂàÜÊûê„Å´„Çà„Å£„Å¶Âãï‰Ωú„Åó„Åæ„Åô„ÄÇ
„ÇÇ„ÅóÈÖçÂàó„ÅåÁ©∫„Å™„Çâ„ÄÅÂîØ‰∏Ä„ÅÆÈÅ∏ÊäûËÇ¢„ÅØÁ©∫„ÅÆÈÖçÂàó„ÇíËøî„Åô„Åì„Å®„Åß„Åô„ÄÇ
ÈÖçÂàó„ÅåÁ©∫„Åß„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„Åï„Çâ„Å´2„Å§„ÅÆÂ†¥Âêà„Å´ÂàÜ„Åë„Çã„Åü„ÇÅ„Å´„Åæ„Åö <code>case</code>Âºè„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ
ÈÖçÂàó„ÅÆÂêàË®à„Åå„Çº„É≠„Åß„ÅÇ„Çå„Å∞„ÄÅÈÖçÂàóÂÖ®‰Ωì„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞„ÄÅÈÖçÂàó„ÅÆÊÆã„Çä„Å´ÂØæ„Åó„Å¶ÂÜçÂ∏∞„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="„Éë„Çø„Éº„É≥ÁÖßÂêà„ÅÆÂ§±Êïó„Å®ÈÉ®ÂàÜÈñ¢Êï∞"><a class="header" href="#„Éë„Çø„Éº„É≥ÁÖßÂêà„ÅÆÂ§±Êïó„Å®ÈÉ®ÂàÜÈñ¢Êï∞">„Éë„Çø„Éº„É≥ÁÖßÂêà„ÅÆÂ§±Êïó„Å®ÈÉ®ÂàÜÈñ¢Êï∞</a></h2>
<p>caseÂºè„ÅÆ„Éë„Çø„Éº„É≥„ÇíÈ†ÜÁï™„Å´ÁÖßÂêà„Åó„Å¶„ÅÑ„Å£„Å¶„ÄÅ
„ÇÇ„ÅóÈÅ∏ÊäûËÇ¢„ÅÆ„ÅÑ„Åö„Çå„ÅÆÂ†¥Âêà„ÇÇÂÖ•Âäõ„ÅåÈÅ©Âêà„Åó„Å™„Åã„Å£„ÅüÊôÇ„ÅØ‰Ωï„ÅåËµ∑„Åì„Çã„ÅÆ„Åß„Åó„Çá„ÅÜ„ÅãÔºü
„Åì„ÅÆÂ†¥Âêà„ÄÅ<strong>„Éë„Çø„Éº„É≥ÁÖßÂêàÂ§±Êïó</strong>„Å´„Çà„Å£„Å¶„ÄÅcaseÂºè„ÅØÂÆüË°åÊôÇ„Å´Â§±Êïó„Åó„Åæ„Åô„ÄÇ</p>
<p>Á∞°Âçò„Å™‰æã„Åß„Åì„ÅÆÂãï‰Ωú„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">import Partial.Unsafe (unsafePartial)

partialFunction :: Boolean -&gt; Boolean
partialFunction = unsafePartial \true -&gt; true
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÂçò‰∏Ä„ÅÆÂ†¥Âêà„Åó„ÅãÂê´„Çì„Åß„Åä„Çâ„Åö„ÄÅ„Åù„ÅÆÂ†¥Âêà„Åß„ÅØÂçò‰∏Ä„ÅÆÂÖ•Âäõ„Åß„ÅÇ„Çã<code>true</code>„Å´„ÅÆ„ÅøÁÖßÂêà„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Éï„Ç°„Ç§„É´„Çí„Ç≥„É≥„Éë„Ç§„É´„Åó„Å¶PSCi„Åß„Åù„Çå‰ª•Â§ñ„ÅÆÂÄ§„Çí‰∏é„Åà„Å¶„ÉÜ„Çπ„Éà„Åô„Çã„Å®„ÄÅÂÆüË°åÊôÇ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; partialFunction false

Failed pattern match
</code></pre>
<p>„Å©„Çì„Å™ÂÖ•Âäõ„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„Å´ÂØæ„Åó„Å¶„ÇÇÂÄ§„ÇíËøî„Åô„Çà„ÅÜ„Å™Èñ¢Êï∞„ÅØ<strong>ÂÖ®Èñ¢Êï∞</strong> (total function) „Å®Âëº„Å∞„Çå„ÄÅ
„Åù„ÅÜ„Åß„Å™„ÅÑÈñ¢Êï∞„ÅØ<strong>ÈÉ®ÂàÜÁöÑ</strong> (partial) „Åß„ÅÇ„Çã„Å®Âëº„Å∞„Çå„Åæ„Åô„ÄÇ</p>
<p>‰∏ÄËà¨ÁöÑ„Å´„ÅØ„ÄÅÂèØËÉΩ„Å™Èôê„ÇäÂÖ®Èñ¢Êï∞„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Åü„Åª„ÅÜ„ÅåËâØ„ÅÑ„Å®ËÄÉ„Åà„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„ÇÇ„ÅóÈñ¢Êï∞„Åå‰Ωï„Çâ„Åã„ÅÆÂ¶•ÂΩì„Å™ÂÖ•Âäõ„ÅÆÈõÜÂêà„Å´„Å§„ÅÑ„Å¶ÁµêÊûú„ÇíËøî„Åï„Å™„ÅÑ„Åì„Å®„Åå„Çè„Åã„Å£„Å¶„ÅÑ„Çã„Å™„Çâ„ÄÅ
Â§ßÊäµ„ÅØÂ§±Êïó„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åô„Åì„Å®„Åå„Åß„Åç„ÇãÂÄ§„ÇíËøî„Åô„Åª„ÅÜ„Åå„Çà„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ
‰æã„Åà„Å∞‰Ωï„Çâ„Åã„ÅÆ<code>a</code>„Å´„Å§„ÅÑ„Å¶„ÅÆÂûã<code>Maybe a</code>„Åß„ÄÅÂ¶•ÂΩì„Å™ÁµêÊûú„ÇíËøî„Åõ„Å™„ÅÑ„Å®„Åç„ÅØ<code>Nothing</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÊñπÊ≥ï„Å™„Çâ„ÄÅÂûãÂÆâÂÖ®„Å™ÊñπÊ≥ï„ÅßÂÄ§„ÅÆÊúâÁÑ°„ÇíÁ§∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>PureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØ„ÄÅ
„Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„Åå‰∏çÂÆåÂÖ®„ÅßÈñ¢Êï∞„ÅåÂÖ®Èñ¢Êï∞„Åß„ÅØ„Å™„ÅÑ„Åì„Å®„ÇíÊ§úÂá∫„Åô„Çã„Å®„Ç®„É©„Éº„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
ÈÉ®ÂàÜÈñ¢Êï∞„ÅåÂÆâÂÖ®„Åß„ÅÇ„ÇãÂ†¥Âêà„ÄÅ
<code>unsafePartial</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åì„Çå„Çâ„ÅÆ„Ç®„É©„Éº„ÇíÊäëÂà∂„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
Ôºà„Åù„ÅÆÈÉ®ÂàÜÈñ¢Êï∞„ÅåÂÆâÂÖ®„Å†„Å®Ë®Ä„ÅÑÂàá„Çå„Çã„Å™„ÇâÔºÅÔºâ
„ÇÇ„Åó‰∏äË®ò„ÅÆ <code>unsafePartial</code>Èñ¢Êï∞„ÅÆÂëº„Å≥Âá∫„Åó„ÇíÂèñ„ÇäÈô§„Åè„Å®„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅØÊ¨°„ÅÆ„Ç®„É©„Éº„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">A case expression could not be determined to cover all inputs.
The following additional cases are required to cover all inputs:

  false
</code></pre>
<p>„Åì„Çå„ÅØÂÄ§<code>false</code>„Åå„ÄÅÂÆöÁæ©„Åï„Çå„Åü„Å©„ÅÆ„Éë„Çø„Éº„É≥„Å®„ÇÇ‰∏ÄËá¥„Åó„Å™„ÅÑ„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰∏ÄËà¨ÁöÑ„Å´„Åì„Çå„Çâ„ÅÆË≠¶Âëä„Å´„ÅØ„ÄÅË§áÊï∞„ÅÆ‰∏ç‰∏ÄËá¥„ÅÆ„Ç±„Éº„Çπ„ÅåÂê´„Åæ„Çå„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>‰∏äË®ò„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇÇÁúÅÁï•„Åó„ÅüÂ†¥Âêà„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">partialFunction true = true
</code></pre>
<p>„Åì„ÅÆ„Å®„Åç„ÄÅPSCi„ÅØËààÂë≥Ê∑±„ÅÑÂûã„ÇíÊé®Ë´ñ„Åó„Åæ„ÅôÔΩ°</p>
<pre><code class="language-text">&gt; :type partialFunction

Partial =&gt; Boolean -&gt; Boolean
</code></pre>
<p>Êú¨Êõ∏„Åß„ÅØ„ÅÆ„Å°„Å´<code>=&gt;</code>Ë®òÂè∑„ÇíÂê´„ÇÄ„ÅÑ„Çç„ÅÑ„Çç„Å™Âûã„ÇíË¶ã„Çã„Åì„Å®„Å´„Å™„Çä„Åæ„ÅôÔºà„Åì„Çå„Çâ„ÅØ<strong>Âûã„ÇØ„É©„Çπ</strong>„Å´Èñ¢ÈÄ£„Åó„Å¶„ÅÑ„Åæ„ÅôÔºâ„ÄÇ
„Åó„Åã„Åó„ÄÅ‰ªä„ÅÆ„Å®„Åì„Çç„ÅØ„ÄÅPureScript„ÅØÂûã„Ç∑„Çπ„ÉÜ„É†„Çí‰Ωø„Å£„Å¶ÈÉ®ÂàÜÈñ¢Êï∞„ÇíËøΩË∑°„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Å®„ÄÅ
ÂÆâÂÖ®„Å™Â†¥Âêà„Å´ÂûãÊ§úË®ºÂô®„Å´ÊòéÁ§∫„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åô„Çå„Å∞ÂçÅÂàÜ„Åß„Åô„ÄÇ</p>
<p>„Ç≥„É≥„Éë„Ç§„É©„ÅØ„ÄÅÂÆöÁæ©„Åï„Çå„Åü„Éë„Çø„Éº„É≥„Åå<strong>ÂÜóÈï∑</strong>„Åß„ÅÇ„Çã„Åì„Å®„ÇíÊ§úÂá∫„Åó„ÅüÂ†¥Âêà
ÔºàÂâç„ÅÆÊñπ„Å´ÂÆöÁæ©„Åï„Çå„Åü„Éë„Çø„Éº„É≥„Å´‰∏ÄËá¥„Åô„Çã„Ç±„Éº„Çπ„ÅÆ„ÅøÔºâ„Åß„ÇÇË≠¶Âëä„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">redundantCase :: Boolean -&gt; Boolean
redundantCase true = true
redundantCase false = false
redundantCase false = false
</code></pre>
<p>„Åì„ÅÆ„Å®„Åç„ÄÅÊúÄÂæå„ÅÆ„Ç±„Éº„Çπ„ÅØÂÜóÈï∑„Åß„ÅÇ„Çã„Å®Ê≠£„Åó„ÅèÊ§úÂá∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">A case expression contains unreachable cases:

  false
</code></pre>
<p><strong>Ê≥®ÊÑè</strong>ÔºöPSCi„ÅØË≠¶Âëä„ÇíË°®Á§∫„Åó„Å™„ÅÑ„ÅÆ„Åß„ÄÅ
„Åì„ÅÆ‰æã„ÇíÂÜçÁèæ„Åô„Çã„Å´„ÅØ„ÄÅ„Åì„ÅÆÈñ¢Êï∞„Çí„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò„Åó„ÄÅ <code>pulp build</code>„Çí‰Ωø„Å£„Å¶„Ç≥„É≥„Éë„Ç§„É´„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã"><a class="header" href="#‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã">‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã</a></h2>
<p>„Åì„ÅÆÁØÄ„Åß„ÅØ<strong>‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã</strong> (algebraic data type, ADT) „Å®Âëº„Å∞„Çå„Çã„ÄÅ
PureScript„ÅÆÂûã„Ç∑„Çπ„ÉÜ„É†„ÅÆÊ©üËÉΩ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÊ©üËÉΩ„ÅØ„Éë„Çø„Éº„É≥ÁÖßÂêà„Å®Âú∞Á∂ö„Åç„ÅÆÈñ¢‰øÇ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó„Åæ„Åö„ÅØÂàá„ÇäÂè£„Å®„Å™„Çã‰æã„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆ‰æã„Åß„ÅØÂçòÁ¥î„Å™„Éô„ÇØ„Çø„Éº„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„É©„Ç§„Éñ„É©„É™„ÅÆÂÆüË£Ö„Å®„ÅÑ„ÅÜ„Åì„ÅÆÁ´†„ÅÆË™≤È°å„ÇíËß£Ê±∫„Åô„ÇãÂü∫Á§é„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p>Áõ¥Á∑ö„ÄÅÁü©ÂΩ¢„ÄÅÂÜÜ„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„Å™„Å©„ÅÆÂçòÁ¥î„Å™Âõ≥ÂΩ¢„ÅÆÁ®ÆÈ°û„ÇíË°®Áèæ„Åô„ÇãÂûã„ÇíÂÆöÁæ©„Åó„Åü„ÅÑ„Å®„Åó„Åæ„Åô„ÄÇ
„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊåáÂêëË®ÄË™û„Åß„ÅØ„ÄÅ„Åä„Åù„Çâ„Åè„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ„ÇÇ„Åó„Åè„ÅØÊäΩË±°„ÇØ„É©„Çπ <code>Shape</code>„ÇíÂÆöÁæ©„Åó„ÄÅ
‰Ωø„ÅÑ„Åü„ÅÑ„Åù„Çå„Åû„Çå„ÅÆÂõ≥ÂΩ¢„Å´„Å§„ÅÑ„Å¶ÂÖ∑‰ΩìÁöÑ„Å™„Çµ„Éñ„ÇØ„É©„Çπ„ÇíÂÆöÁæ©„Åô„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅ„Åì„ÅÆÊñπÈáù„ÅØÂ§ß„Åç„Å™Ê¨†ÁÇπ„Çí„Å≤„Å®„Å§Êä±„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Shape</code>„ÇíÊäΩË±°ÁöÑ„Å´Êâ±„ÅÜ„Åü„ÇÅ„Å´„ÅØ„ÄÅÂÆüË°å„Åó„Åü„ÅÑ„Å®ÊÄù„ÅÜÂèØËÉΩÊÄß„ÅÆ„ÅÇ„Çã„Åô„Åπ„Å¶„ÅÆÊìç‰Ωú„Çí‰∫ãÂâç„Å´ÊääÊè°„Åó„ÄÅ
<code>Shape</code>„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ„Å´ÂÆöÁæ©„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÅÆ„Åß„Åô„ÄÇ
„Åì„ÅÆ„Åü„ÇÅ„ÄÅ„É¢„Ç∏„É•„Éº„É´ÊÄß„ÇíÂ£ä„Åï„Åö„Å´Êñ∞„Åó„ÅÑÊìç‰Ωú„ÇíËøΩÂä†„Åô„Çã„Åì„Å®„ÅåÈõ£„Åó„Åè„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„ÇÇ„ÅóÂõ≥ÂΩ¢„ÅÆÁ®ÆÈ°û„Åå‰∫ãÂâç„Å´„Çè„Åã„Å£„Å¶„ÅÑ„Çã„Å™„Çâ„ÄÅ
‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅØ„Åì„ÅÜ„Åó„ÅüÂïèÈ°å„ÇíËß£Ê±∫„Åô„ÇãÂûãÂÆâÂÖ®„Å™ÊñπÊ≥ï„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
„É¢„Ç∏„É•„Éº„É´ÊÄß„ÅÆ„ÅÇ„ÇãÊñπÊ≥ï„Åß <code>Shape</code>„Å´Êñ∞„Åü„Å™Êìç‰Ωú„ÇíÂÆöÁæ©„Åó„ÄÅ
ÂûãÂÆâÂÖ®ÊÄß„ÅåÁ∂≠ÊåÅ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Å®„Åó„Å¶„Å©„ÅÆ„Çà„ÅÜ„Å´<code>Shape</code>„ÅåË°®Áèæ„Åï„Çå„Çã„Åã„ÇíÊ¨°„Å´Á§∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String

type Point =
  { x :: Number
  , y :: Number
  }
</code></pre>
<p>„Åì„ÅÆÂÆ£Ë®Ä„Åß„ÅØ<code>Shape</code>„Çí„Åù„Çå„Åû„Çå„ÅÆÊßãÁØâÂ≠ê„ÅÆÂíå„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Å¶„Åä„Çä„ÄÅ
ÂêÑÊßãÁØâÂ≠ê„Åß„ÅØÂê´„Åæ„Çå„Çã„Éá„Éº„Çø„ÇíÊåáÂÆö„Åó„Åæ„Åô„ÄÇ
<code>Shape</code>„ÅØ„ÄÅ‰∏≠Â§Æ <code>Point</code>„Å®ÂçäÂæÑÔºàÊï∞ÂÄ§Ôºâ„ÇíÊåÅ„Å§ <code>Circle</code>„Åã„ÄÅ
<code>Rectangle</code>„ÄÅ <code>Line</code>„ÄÅ <code>Text</code>„ÅÆ„ÅÑ„Åö„Çå„Åã„Åß„Åô„ÄÇ
‰ªñ„Å´„ÅØ <code>Shape</code>Âûã„ÅÆÂÄ§„ÇíÊßãÁØâ„Åô„ÇãÊñπÊ≥ï„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅÆÂÆöÁæ©„ÅØ„Ç≠„Éº„ÉØ„Éº„Éâ <code>data</code>„Åã„ÇâÂßã„Åæ„Çä„ÄÅ
„Åù„Çå„Å´Êñ∞„Åó„ÅÑÂûã„ÅÆÂêçÂâç„Å®‰ªªÊÑèÂÄã„ÅÆÂûãÂºïÊï∞„ÅåÁ∂ö„Åç„Åæ„Åô„ÄÇ
„Åù„ÅÆÂûã„ÅÆÊßãÁØâÂ≠êÔºà„ÅÇ„Çã„ÅÑ„ÅØ<strong>„Éá„Éº„ÇøÊßãÁØâÂ≠ê</strong> (data constructor)Ôºâ„ÅØÁ≠âÂè∑„ÅÆÂæå„Å´ÂÆöÁæ©„Åï„Çå„ÄÅ
„Éë„Ç§„ÉóÊñáÂ≠ó (<code>|</code>) „ÅßÂå∫Âàá„Çâ„Çå„Åæ„Åô„ÄÇ
ADT„ÅÆÊßãÁØâÂ≠ê„ÅåÊåÅ„Å§„Éá„Éº„Çø„ÅØÂéüÂßãÂûã„Å´Èôê„Çä„Åæ„Åõ„Çì„ÄÇ
ÊßãÁØâÂ≠ê„Å´„ÅØ„É¨„Ç≥„Éº„Éâ„ÄÅÈÖçÂàó„ÄÅ„Åæ„Åü‰ªñ„ÅÆADT„Åï„Åà„ÇÇÂê´„ÇÄ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØPureScript„ÅÆÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„Åã„ÇâÂà•„ÅÆ‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„ÇíÂÆöÁæ©„Åô„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„Çã <code>Maybe</code>Âûã„ÇíÊú¨Êõ∏„ÅÆÂÜíÈ†≠„ÅßÊâ±„ÅÑ„Åæ„Åó„Åü„ÄÇ
<code>maybe</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÅØ <code>Maybe</code>„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>„Åì„ÅÆ‰æã„Åß„ÅØÂûãÂºïÊï∞ <code>a</code>„ÅÆ‰ΩøÁî®ÊñπÊ≥ï„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Éë„Ç§„ÉóÊñáÂ≠ó„Çí„Äå„Åæ„Åü„ÅØ„Äç„Å®Ë™≠„ÇÄ„Åì„Å®„Å´„Åô„Çã„Å®„ÄÅ„Åì„ÅÆÂÆöÁæ©„ÅØ„Äå<code>Maybe a</code>Âûã„ÅÆÂÄ§„ÅØ„ÄÅÁÑ°„ÅÑ (<code>Nothing</code>) „Åã„ÄÅ„Åæ„Åü„ÅØ„Åü„Å†„ÅÆ (<code>Just</code>) Âûã
<code>a</code>„ÅÆÂÄ§„Å†„Äç„Å®„Åª„ÅºËã±Ë™û„ÅÆ„Çà„ÅÜ„Å´Ë™≠„ÇÄ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Å™„Åä„Éá„Éº„ÇøÂÆöÁæ©„ÅÆ„Å©„Åì„Å´„ÇÇÊßãÊñá<code>forall a</code>„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ
<code>forall</code>ÊßãÊñá„ÅØÈñ¢Êï∞„Å´„ÅØÂøÖÈ†à„Åß„Åô„Åå„ÄÅ<code>data</code>„Å´„Çà„ÇãADT„ÇÑ<code>type</code>„Åß„ÅÆÂûãÂà•Áß∞„ÇíÂÆöÁæ©„Åô„Çã„Å®„Åç„ÅØ‰Ωø„Çè„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<p>„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅØÂÜçÂ∏∞ÁöÑ„Å™„Éá„Éº„ÇøÊßãÈÄ†„ÇíÂÆöÁæ©„Åô„Çã„Åü„ÇÅ„Å´‰ΩøÁî®„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
Êõ¥„Å´‰æã„ÇíÊåô„Åí„Çã„Å®„ÄÅË¶ÅÁ¥†„ÅåÂûã <code>a</code>„ÅÆÂçòÊñπÂêëÈÄ£Áµê„É™„Çπ„Éà„ÅÆ„Éá„Éº„ÇøÂûã„ÇíÂÆöÁæ©„ÅØ„Åì„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
</code></pre>
<p>„Åì„ÅÆ‰æã„ÅØ <code>lists</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åã„ÇâÊåÅ„Å£„Å¶„Åç„Åæ„Åó„Åü„ÄÇ
„Åì„Åì„Åß <code>Nil</code>ÊßãÁØâÂ≠ê„ÅØÁ©∫„ÅÆ„É™„Çπ„Éà„ÇíË°®„Åó„Å¶„Åä„Çä„ÄÅ
<code>Cons</code>„ÅØÂÖàÈ†≠„Å®„Å™„ÇãË¶ÅÁ¥†„Å®Â∞æÈ∞≠„Åã„ÇâÁ©∫„Åß„Å™„ÅÑ„É™„Çπ„Éà„Çí‰ΩúÊàê„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ
<code>Cons</code>„ÅÆ2„Å§ÁõÆ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Åß„Éá„Éº„ÇøÂûã <code>List a</code>„Çí‰ΩøÁî®„Åó„Å¶„Åä„Çä„ÄÅ
ÂÜçÂ∏∞ÁöÑ„Å™„Éá„Éº„ÇøÂûã„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="adt„ÅÆ‰ΩøÁî®"><a class="header" href="#adt„ÅÆ‰ΩøÁî®">ADT„ÅÆ‰ΩøÁî®</a></h2>
<p>‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅÆÊßãÁØâÂ≠ê„Çí‰ΩøÁî®„Åó„Å¶ÂÄ§„ÇíÊßãÁØâ„Åô„Çã„ÅÆ„ÅØ„Å®„Å¶„ÇÇÁ∞°Âçò„Åß„Åô„ÄÇ
ÂØæÂøú„Åô„ÇãÊßãÁØâÂ≠ê„Å´Âê´„Åæ„Çå„Çã„Éá„Éº„Çø„Å´Âøú„Åò„ÅüÂºïÊï∞„ÇíÁî®ÊÑè„Åó„ÄÅ
„Åù„ÅÆÊßãÁØâÂ≠ê„ÇíÂçò„Å´Èñ¢Êï∞„ÅÆ„Çà„ÅÜ„Å´ÈÅ©Áî®„Åô„Çã„Å†„Åë„Åß„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„ÄÅ‰∏ä„ÅßÂÆöÁæ©„Åó„Åü <code>Line</code>ÊßãÁØâÂ≠ê„ÅØ2„Å§„ÅÆ <code>Point</code>„ÇíÂøÖË¶Å„Å®„Åó„Å¶„ÅÑ„Åæ„Åô„ÅÆ„Åß„ÄÅ
<code>Line</code>ÊßãÁØâÂ≠ê„Çí‰Ωø„Å£„Å¶ <code>Shape</code>„ÇíÊßãÁØâ„Åô„Çã„Å´„ÅØ„ÄÅ
Âûã <code>Point</code>„ÅÆ„Åµ„Åü„Å§„ÅÆÂºïÊï∞„Çí‰∏é„Åà„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">exampleLine :: Shape
exampleLine = Line p1 p2
  where
    p1 :: Point
    p1 = { x: 0.0, y: 0.0 }

    p2 :: Point
    p2 = { x: 100.0, y: 50.0 }
</code></pre>
<p>„Åï„Å¶„ÄÅ‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅßÂÄ§„ÇíÊßãÁØâ„Åô„Çã„Åì„Å®„ÅØÁ∞°Âçò„Åß„Åô„Åå„ÄÅ
„Åì„Çå„Çí„Å©„ÅÜ„ÇÑ„Å£„Å¶‰Ωø„Å£„Åü„Çâ„Çà„ÅÑ„ÅÆ„Åß„Åó„Çá„ÅÜ„ÅãÔºü
„Åì„Åì„Åß‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Å®„Éë„Çø„Éº„É≥ÁÖßÂêà„Å®„ÅÆÈáçË¶Å„Å™Êé•ÁÇπ„ÅåË¶ã„Åà„Å¶„Åç„Åæ„Åô„ÄÇ
‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅÆÂÄ§„ÇíÊ∂àË≤ª„Åô„ÇãÂîØ‰∏Ä„ÅÆÊñπÊ≥ï„ÅØÊßãÁØâÂ≠ê„Å´ÁÖßÂêà„Åô„Çã„Éë„Çø„Éº„É≥„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>Shape</code>„Çí <code>String</code>„Å´Â§âÊèõ„Åó„Åü„ÅÑ„Å®„Åó„Åæ„Åô„ÄÇ
<code>Shape</code>„ÇíÊßãÁØâ„Åô„Çã„ÅÆ„Å´„Å©„ÅÆÊßãÁØâÂ≠ê„Åå‰ΩøÁî®„Åï„Çå„Åü„Åã„ÇíË™ø„Åπ„Çã„Å´„ÅØ„ÄÅ
„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
„Åì„Çå„Å´„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">showShape :: Shape -&gt; String
showShape (Circle c r) =
  &quot;Circle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, radius: &quot; &lt;&gt; show r &lt;&gt; &quot;]&quot;
showShape (Rectangle c w h) =
  &quot;Rectangle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, width: &quot; &lt;&gt; show w &lt;&gt; &quot;, height: &quot; &lt;&gt; show h &lt;&gt; &quot;]&quot;
showShape (Line start end) =
  &quot;Line [start: &quot; &lt;&gt; showPoint start &lt;&gt; &quot;, end: &quot; &lt;&gt; showPoint end &lt;&gt; &quot;]&quot;
showShape (Text loc text) =
  &quot;Text [location: &quot; &lt;&gt; showPoint loc &lt;&gt; &quot;, text: &quot; &lt;&gt; show text &lt;&gt; &quot;]&quot;

showPoint :: Point -&gt; String
showPoint { x, y } =
  &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot;, &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>ÂêÑÊßãÁØâÂ≠ê„ÅØ„Éë„Çø„Éº„É≥„Å®„Åó„Å¶‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ
ÊßãÁØâÂ≠ê„Å∏„ÅÆÂºïÊï∞„ÅØ„Åù„ÅÆ„Éë„Çø„Éº„É≥„ÅßÊùüÁ∏õ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>showShape</code>„ÅÆÊúÄÂàù„ÅÆÂ†¥Âêà„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„ÇÇ„Åó <code>Shape</code>„Åå <code>Circle</code>ÊßãÁØâÂ≠êÈÅ©Âêà„Åó„ÅüÂ†¥Âêà„ÄÅ
2„Å§„ÅÆÂ§âÊï∞„Éë„Çø„Éº„É≥ <code>c</code>„Å® <code>r</code>„Çí‰Ωø„Å£„Å¶
<code>Circle</code>„ÅÆÂºïÊï∞Ôºà‰∏≠ÂøÉ„Å®ÂçäÂæÑÔºâ„Åå„Çπ„Ç≥„Éº„Éó„Å´Â∞éÂÖ•„Åï„Çå„Åæ„Åô„ÄÇ
„Åù„ÅÆ‰ªñ„ÅÆÂ†¥Âêà„ÇÇÂêåÊßò„Åß„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-10"><a class="header" href="#ÊºîÁøí-10">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ<code>Circle</code>ÔºàÂûã„ÅØ<code>Shape</code>Ôºâ„ÇíÊßãÁØâ„Åô„ÇãÈñ¢Êï∞<code>circleAtOrigin</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰∏≠ÂøÉ„ÅØÂéüÁÇπ„Å´„ÅÇ„Çä„ÄÅÂçäÂæÑ„ÅØ<code>10.0</code>„Åß„Åô„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>Shape</code>„Çí„ÄÅÂéüÁÇπ„Çí‰∏≠ÂøÉ„Å®„Åó„Å¶<code>2.0</code>ÂÄç„Å´Êã°Â§ß„Åô„ÇãÈñ¢Êï∞<code>doubleScaleAndCenter</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>Shape</code>„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫„Åô„ÇãÈñ¢Êï∞<code>shapeText</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>Maybe String</code>„ÇíËøî„Åó„Åæ„Åô„Åå„ÄÅ„ÇÇ„ÅóÂÖ•Âäõ„Åå<code>Text</code>„Çí‰ΩøÁî®„Åó„Å¶ÊßãÁØâ„Åï„Çå„Åü„ÅÆ„Åß„Å™„Åë„Çå„Å∞„ÄÅËøî„ÇäÂÄ§„Å´„ÅØ<code>Nothing</code>ÊßãÁØâÂ≠ê„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="newtype"><a class="header" href="#newtype">Newtype</a></h2>
<p>‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅÆÁâπÂà•„Å™Â†¥Âêà„Å®„Åó„Å¶„ÄÅ<strong>newtype</strong>„Å®Âëº„Å∞„Çå„Çã„ÇÇ„ÅÆ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
newtype„ÅØ„Ç≠„Éº„ÉØ„Éº„Éâ <code>data</code>„ÅÆ‰ª£„Çè„Çä„Å´„Ç≠„Éº„ÉØ„Éº„Éâ <code>newtype</code>„Çí‰ΩøÁî®„Åó„Å¶Â∞éÂÖ•„Åó„Åæ„Åô„ÄÇ</p>
<p>newtypeÂÆ£Ë®Ä„Åß„ÅØ<strong>ÈÅé‰∏çË∂≥„Å™„Åè„Å≤„Å®„Å§„Å†„Åë„ÅÆ</strong>ÊßãÁØâÂ≠ê„ÇíÂÆöÁæ©„Åó„Å™„Åë„Çå„Å∞„Å™„Çâ„Åö„ÄÅ
„Åù„ÅÆÊßãÁØâÂ≠ê„ÅØ<strong>ÈÅé‰∏çË∂≥„Å™„Åè„Å≤„Å®„Å§„Å†„Åë„ÅÆ</strong>ÂºïÊï∞„ÇíÂèñ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Å§„Åæ„Çä„ÄÅnewtypeÂÆ£Ë®Ä„ÅØÊó¢Â≠ò„ÅÆÂûã„Å´Êñ∞„Åó„ÅÑÂêçÂâç„Çí‰∏é„Åà„Çã„ÇÇ„ÅÆ„Å™„ÅÆ„Åß„Åô„ÄÇ
ÂÆüÈöõ„ÄÅnewtype„ÅÆÂÄ§„ÅØ„ÄÅÂÖÉ„ÅÆÂûã„Å®Âêå„ÅòÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å£„Å¶„Çã„ÅÆ„Åß„ÄÅÂÆüË°åÊôÇÊÄßËÉΩ„ÅÆ„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åì„Çå„Çâ„ÅØÂûã„Ç∑„Çπ„ÉÜ„É†„ÅÆË¶≥ÁÇπ„Åã„ÇâÂå∫Âà•„Åï„Çå„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÂûãÂÆâÂÖ®ÊÄß„ÅÆËøΩÂä†„ÅÆÂ±§„ÇíÊèê‰æõ„Åô„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰æã„Å®„Åó„Å¶„ÄÅ„Éú„É´„Éà„ÄÅ„Ç¢„É≥„Éö„Ç¢„ÄÅ„Ç™„Éº„É†„ÅÆ„Çà„ÅÜ„Å™Âçò‰Ωç„ÇíË°®Áèæ„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ
<code>Number</code>„ÅÆÂûã„É¨„Éô„É´„ÅÆÂà•Âêç„ÇíÂÆöÁæ©„Åó„Åü„Åè„Å™„ÇãÂ†¥Âêà„Åå„ÅÇ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">newtype Volt = Volt Number
newtype Ohm = Ohm Number
newtype Amp = Amp Number
</code></pre>
<p>„Åù„Çå„Åã„Çâ„Åì„Çå„Çâ„ÅÆÂûã„Çí‰Ωø„ÅÜÈñ¢Êï∞„Å®ÂÄ§„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">calculateCurrent :: Volt -&gt; Ohm -&gt; Amp
calculateCurrent (Volt v) (Ohm r) = Amp (v / r)

battery :: Volt
battery = Volt 1.5

lightbulb :: Ohm
lightbulb = Ohm 500.0

current :: Amp
current = calculateCurrent battery lightbulb
</code></pre>
<p>„Åì„Çå„Å´„Çà„Çä„Å§„Åæ„Çâ„Å™„ÅÑ„Éü„Çπ„ÇíÈò≤„Åê„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞ÈõªÊ∫ê<strong>„Å™„Åó</strong>„Å´<strong>2„Å§</strong>„ÅÆÈõªÁêÉ„Å´„Çà„ÇäÁîü„ÅøÂá∫„Åï„Çå„ÇãÈõªÊµÅ„ÇíË®àÁÆó„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å™„Å©„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">current :: Amp
current = calculateCurrent lightbulb lightbulb
{-
TypesDoNotUnify:
  current = calculateCurrent lightbulb lightbulb
                             ^^^^^^^^^
  Could not match type
    Ohm
  with type
    Volt
-}
</code></pre>
<p>„ÇÇ„Åó<code>newtype</code>„Å™„Åó„Å´Âçò„Å´<code>Numebr</code>„Çí‰Ωø„Å£„Å¶„ÅÑ„Åü„Çâ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅØ„Åì„ÅÆ„Éü„Çπ„ÇíË£úË∂≥„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">-- „Åì„Çå„ÇÇ„Ç≥„É≥„Éë„Ç§„É´„Åß„Åç„Åæ„Åô„Åå„ÄÅÂûãÂÆâÂÖ®„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
calculateCurrent :: Number -&gt; Number -&gt; Number
calculateCurrent v r = v / r

battery :: Number
battery = 1.5

lightbulb :: Number
lightbulb = 500.0

current :: Number
current = calculateCurrent lightbulb lightbulb -- Ë£úË∂≥„Åï„Çå„Å™„ÅÑ„Éü„Çπ
</code></pre>
<p>„Å™„Åä„ÄÅnewtype„ÅØÂçò‰∏Ä„ÅÆÊßãÁØâÂ≠ê„Åó„Åã„Å®„Çå„Åö„ÄÅÊßãÁØâÂ≠ê„ÅØÂçò‰∏Ä„ÅÆÂÄ§„Åß„Å™„Åè„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„Åå„ÄÅ
newtype„ÅØ‰ªªÊÑè„ÅÆÊï∞„ÅÆÂûãÂ§âÊï∞„ÇíÂèñ„Çã„Åì„Å®„Åå<strong>„Åß„Åç„Åæ„Åô</strong>„ÄÇ
‰æã„Åà„Å∞‰ª•‰∏ã„ÅÆnewtype„ÅØÂ¶•ÂΩì„Å™ÂÆöÁæ©„Åß„ÅôÔºà<code>err</code>„Å®<code>a</code>„ÅØÂûãÂ§âÊï∞„Åß„ÄÅ<code>CouldError</code>ÊßãÁØâÂ≠ê„ÅØÂûã<code>Either err a</code>„ÅÆ<strong>Âçò‰∏Ä</strong>„ÅÆÂÄ§„ÇíÊúüÂæÖ„Åó„Åæ„ÅôÔºâ„ÄÇ</p>
<pre><code class="language-Haskell">newtype CouldError err a = CouldError (Either err a)
</code></pre>
<p>„Åæ„Åü„ÄÅnewtype„ÅÆÊßãÁØâÂ≠ê„ÅØ„Çà„ÅènewtypeËá™Ë∫´„Å®Âêå„ÅòÂêçÂâç„ÇíÊåÅ„Å§„Åì„Å®„Åå„ÅÇ„Çã„Åì„Å®„Å´„ÇÇÊ≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åü„Å†„Åì„Çå„ÅØÂøÖÈ†à„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
‰æã„Åà„Å∞Âõ∫Êúâ„ÅÆÂêçÂâç„Åß„ÅÇ„Å£„Å¶„ÇÇÂ¶•ÂΩì„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Coulomb = MakeCoulomb Number
</code></pre>
<p>„Åì„ÅÆÂ†¥Âêà<code>Coulomb</code>„ÅØ<strong>ÂûãÊßãÁØâÂ≠ê</strong>ÔºàÂºïÊï∞„ÅØ„Çº„É≠Ôºâ„Åß<code>MakeCoulomb</code>„ÅØ<strong>„Éá„Éº„ÇøÊßãÁØâÂ≠ê</strong>„Åß„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆÊßãÁØâÂ≠ê„ÅØÁï∞„Å™„ÇãÂêçÂâçÁ©∫Èñì„Å´Â±û„Åó„Å¶„Åä„Çä„ÄÅ<code>Volt</code>„ÅÆ‰æã„Åß„Åù„ÅÜ„Å†„Å£„Åü„Çà„ÅÜ„Å´„ÄÅÂêçÂâç„Å´‰∏ÄÊÑèÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÂÖ®„Å¶„ÅÆADT„Å´„Å§„ÅÑ„Å¶Ë®Ä„Åà„Çã„Åì„Å®„Åß„Åô„ÄÇ
„Å™„Åä„ÄÅÂûãÊßãÁØâÂ≠ê„Å®„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅØÁï∞„Å™„ÇãÂêçÂâç„ÇíÊåÅ„Å§„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„Åå„ÄÅ
ÂÆüÈöõ„Å´„ÅØÂêå„ÅòÂêçÂâç„ÇíÂÖ±Êúâ„Åô„Çã„ÅÆ„ÅåÊôÆÈÄö„Åß„Åô„ÄÇ
‰∏ä„ÅÆ<code>Amp</code>„Å®<code>Volt</code>„ÅÆÂ†¥Âêà„Åå„Åì„Çå„Åß„Åô„ÄÇ</p>
<p>newtype„ÅÆÂà•„ÅÆÂøúÁî®„ÅØ„ÄÅÂÆüË°åÊôÇË°®Áèæ„ÇíÂ§â„Åà„Çã„Åì„Å®„Å™„Åè„ÄÅÊó¢Â≠ò„ÅÆÂûã„Å´Áï∞„Å™„Çã<strong>ÊåØËàû„ÅÑ</strong>„Çí‰ªòÂä†„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ
„Åù„ÅÆÂà©Áî®‰æã„Å´„Å§„ÅÑ„Å¶„ÅØÊ¨°Á´†„Åß<strong>Âûã„ÇØ„É©„Çπ</strong>„Çí„ÅäË©±„Åó„Åô„Çã„Å®„Åç„Å´Êäº„Åï„Åà„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-11"><a class="header" href="#ÊºîÁøí-11">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ<code>Watt</code>„Çí<code>Number</code>„ÅÆ<code>newtype</code>„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åù„Çå„Åã„Çâ„Åì„ÅÆÊñ∞„Åó„ÅÑ<code>Watt</code>Âûã„Å®‰∏ä„ÅÆ<code>Amp</code>„Å®<code>Volt</code>„ÅÆÂÆöÁæ©„Çí‰Ωø„Å£„Å¶<code>calculateWattage</code>Èñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<pre><code class="language-haskell">calculateWattage :: Amp -&gt; Volt -&gt; Watt
</code></pre>
<p><code>Watt</code>‰∏≠„ÅÆ„ÉØ„ÉÉ„ÉàÊï∞„ÅØ‰∏é„Åà„Çâ„Çå„Åü<code>Amp</code>‰∏≠„ÅÆÈõªÊµÅ„Å®‰∏é„Åà„Çâ„Çå„Åü<code>Volt</code>„ÅÆÈõªÂúß„ÅÆÁ©ç„ÅßË®àÁÆó„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„Éô„ÇØ„Çø„Éº„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„É©„Ç§„Éñ„É©„É™"><a class="header" href="#„Éô„ÇØ„Çø„Éº„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„É©„Ç§„Éñ„É©„É™">„Éô„ÇØ„Çø„Éº„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„É©„Ç§„Éñ„É©„É™</a></h2>
<p>„Åì„Çå„Åæ„ÅßÂÆöÁæ©„Åó„Å¶„Åç„Åü„Éá„Éº„ÇøÂûã„Çí‰Ωø„Å£„Å¶„ÄÅ„Éô„ÇØ„Çø„Éº„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÊâ±„ÅÜÁ∞°Âçò„Å™„É©„Ç§„Éñ„É©„É™„Çí‰ΩúÊàê„Åó„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åü„Å†„ÅÆ <code>Shape</code>„ÅÆÈÖçÂàó„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™„ÄÅ <code>Picture</code>„Å®„ÅÑ„ÅÜÂûãÂêåÁæ©Ë™û„ÇíÂÆöÁæ©„Åó„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Picture = Array Shape
</code></pre>
<p>„Éá„Éê„ÉÉ„Ç∞„Åó„Å¶„ÅÑ„Çã„Å® <code>Picture</code>„Çí <code>String</code>„Å®„Åó„Å¶Ë°®Á§∫„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åó„Åü„Åè„Å™„Çã„Åì„Å®„ÇÇ„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åì„Çå„ÅØ„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Åü <code>showPicture</code>Èñ¢Êï∞„ÅßË°å„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">showPicture :: Picture -&gt; Array String
showPicture = map showShape
</code></pre>
<p>Ë©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„É¢„Ç∏„É•„Éº„É´„Çí <code>spago build</code>„Åß„Ç≥„É≥„Éë„Ç§„É´„Åó„ÄÅ <code>spago repl</code>„ÅßPSCi„ÇíÈñã„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago build
$ spago repl

&gt; import Data.Picture

&gt; showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]

[&quot;Line [start: (0.0, 0.0), end: (1.0, 1.0)]&quot;]
</code></pre>
<h2 id="Â§ñÊé•Áü©ÂΩ¢„ÅÆÁÆóÂá∫"><a class="header" href="#Â§ñÊé•Áü©ÂΩ¢„ÅÆÁÆóÂá∫">Â§ñÊé•Áü©ÂΩ¢„ÅÆÁÆóÂá∫</a></h2>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅÆ„Ç≥„Éº„Éâ‰æã„Å´„ÅØ„ÄÅ <code>Picture</code>„ÅÆÊúÄÂ∞èÂ§ñÊé•Áü©ÂΩ¢„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞ <code>bounds</code>„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Bounds</code>Âûã„ÅØÂ§ñÊé•Áü©ÂΩ¢„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Bounds =
  { top    :: Number
  , left   :: Number
  , bottom :: Number
  , right  :: Number
  }
</code></pre>
<p><code>Picture</code>ÂÜÖ„ÅÆ <code>Shape</code>„ÅÆÈÖçÂàó„ÇíËµ∞Êüª„Åó„ÄÅÊúÄÂ∞è„ÅÆÂ§ñÊé•Áü©ÂΩ¢„ÇíÁ¥ØÁ©ç„Åô„Çã„Åü„ÇÅ„ÄÅ
<code>bounds</code>„ÅØ <code>Data.Foldable</code>„ÅÆ <code>foldl</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">bounds :: Picture -&gt; Bounds
bounds = foldl combine emptyBounds
  where
  combine :: Bounds -&gt; Shape -&gt; Bounds
  combine b shape = union (shapeBounds shape) b
</code></pre>
<p>Âü∫Â∫ï„ÅÆÂ†¥Âêà„Åß„ÅØ„ÄÅÁ©∫„ÅÆ <code>Picture</code>„ÅÆÊúÄÂ∞èÂ§ñÊé•Áü©ÂΩ¢„ÇíÊ±Ç„ÇÅ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ
<code>emptyBounds</code>„ÅßÂÆöÁæ©„Åï„Çå„ÇãÁ©∫„ÅÆÂ§ñÊé•Áü©ÂΩ¢„Åå„Åù„ÅÆÊù°‰ª∂„ÇíÊ∫Ä„Åü„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Á¥ØÁ©çÈñ¢Êï∞ <code>combine</code>„ÅØ <code>where</code>„Éñ„É≠„ÉÉ„ÇØ„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>combine</code>„ÅØ <code>foldl</code>„ÅÆÂÜçÂ∏∞Âëº„Å≥Âá∫„Åó„ÅßË®àÁÆó„Åï„Çå„ÅüÂ§ñÊé•Áü©ÂΩ¢„Å®„ÄÅ
ÈÖçÂàóÂÜÖ„ÅÆÊ¨°„ÅÆ <code>Shape</code>„ÇíÂºïÊï∞„Å´„Å®„Çä„ÄÅ
„É¶„Éº„Ç∂ÂÆöÁæ©„ÅÆÊºîÁÆóÂ≠ê <code>union</code>„Çí‰Ωø„Å£„Å¶„Åµ„Åü„Å§„ÅÆÂ§ñÊé•Áü©ÂΩ¢„ÅÆÂíå„ÇíË®àÁÆó„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>shapeBounds</code>Èñ¢Êï∞„ÅØ„ÄÅ„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÂçò‰∏Ä„ÅÆÂõ≥ÂΩ¢„ÅÆÂ§ñÊé•Áü©ÂΩ¢„ÇíË®àÁÆó„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-12"><a class="header" href="#ÊºîÁøí-12">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ„Éô„ÇØ„Çø„Éº„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„É©„Ç§„Éñ„É©„É™„ÇíÊã°Âºµ„Åó„ÄÅ<code>Shape</code>„ÅÆÈù¢Á©ç„ÇíË®àÁÆó„Åô„ÇãÊñ∞„Åó„ÅÑÊìç‰Ωú <code>area</code>„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÊºîÁøí„Åß„ÅØ„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÅÆÈù¢Á©ç„ÅØ0„Åß„ÅÇ„Çã„ÇÇ„ÅÆ„Å®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÈõ£„Åó„ÅÑÔºâ<code>Shape</code>„ÇíÊã°Âºµ„Åó„ÄÅÊñ∞„Åó„ÅÑ„Éá„Éº„ÇøÊßãÁØâÂ≠ê <code>Clipped</code>„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>Clipped</code>„ÅØ‰ªñ„ÅÆ <code>Picture</code>„ÇíÁü©ÂΩ¢„Å´Âàá„ÇäÊäú„Åç„Åæ„Åô„ÄÇ
Âàá„ÇäÊäú„ÅÑ„Å¶„Åç„Åü<code>Picture</code>„ÅÆÂ¢ÉÁïå„ÇíË®àÁÆó„Åß„Åç„Çã„Çà„ÅÜ„ÄÅ<code>shapeBounds</code>Èñ¢Êï∞„ÇíÊã°Âºµ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Å™„Åä„ÄÅ„Åì„Çå„Å´„Çà„Çä<code>Shape</code>„ÅØÂÜçÂ∏∞ÁöÑ„Å™„Éá„Éº„ÇøÂûã„Å´„Å™„Çä„Åæ„Åô„ÄÇ</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-3"><a class="header" href="#„Åæ„Å®„ÇÅ-3">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Åã„ÇâÂü∫Êú¨„Å†„ÅåÂº∑Âäõ„Å™„ÉÜ„ÇØ„Éã„ÉÉ„ÇØ„Åß„ÅÇ„Çã„Éë„Çø„Éº„É≥ÁÖßÂêà„ÇíÊâ±„ÅÑ„Åæ„Åó„Åü„ÄÇ
Ë§áÈõë„Å™„Éá„Éº„ÇøÊßãÈÄ†„ÅÆÈÉ®ÂàÜ„Å®ÁÖßÂêà„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ
Á∞°Âçò„Å™„Éë„Çø„Éº„É≥„ÅÆ‰Ωø„ÅÑÊñπ„Å†„Åë„Åß„ÅØ„Å™„Åè„ÄÅ
ÈÖçÂàó„Éë„Çø„Éº„É≥„ÇÑ„É¨„Ç≥„Éº„Éâ„Éë„Çø„Éº„É≥„Çí‰Ωø„Å£„ÅüÊ∑±„ÅÑ„Éá„Éº„ÇøÊßãÈÄ†„ÅÆ‰∏ÄÈÉ®„ÅÆÁÖßÂêàÊñπÊ≥ï„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</p>
<p>„Åæ„Åü„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ„Éë„Çø„Éº„É≥ÁÖßÂêà„Å´ÂØÜÊé•„Å´Èñ¢ÈÄ£„Åô„Çã‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÇíÁ¥π‰ªã„Åó„Åæ„Åó„Åü„ÄÇ
‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅÆ„Åä„Åã„Åí„Åß„Éá„Éº„ÇøÊßãÈÄ†„ÇíÁ∞°ÊΩî„Å´Ë®òËø∞„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ
Êñ∞„Åü„Å™Êìç‰Ωú„Åß„Éá„Éº„ÇøÂûã„ÇíÊã°Âºµ„Åô„Çã„Åü„ÇÅ„ÅÆ„É¢„Ç∏„É•„Éº„É´ÊÄß„ÅÆ„ÅÇ„ÇãÊñπÊ≥ï„ÅåÊèê‰æõ„Åï„Çå„Çã„Åì„Å®„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</p>
<p>ÊúÄÂæå„Å´Âº∑Âäõ„Å™ÊäΩË±°Âåñ„Åß„ÅÇ„Çã<strong>Ë°åÂ§öÁõ∏</strong>„ÇíÊâ±„ÅÑ„Åæ„Åó„Åü„ÄÇ
„Åì„Çå„Å´„Çà„ÇäÂ§ö„Åè„ÅÆÊó¢Â≠ò„ÅÆJavaScriptÈñ¢Êï∞„Å´Âûã„Çí‰∏é„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<p>Êú¨Êõ∏„Åß„ÅØ‰ªäÂæå„ÇÇ‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Å®„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí„ÅÑ„Çç„Çì„Å™„Å®„Åì„Çç„Åß‰ΩøÁî®„Åô„Çã„ÅÆ„Åß„ÄÅ
‰ªä„ÅÆ„ÅÜ„Å°„Å´„Åì„Çå„Çâ„Å´ÁøíÁÜü„Åó„Å¶„Åä„Åè„Å®Âæå„ÅßÂÆü„ÇíÁµê„Å∂„Åì„Å®„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åì„Çå‰ª•Â§ñ„Å´„ÇÇÁã¨Ëá™„ÅÆ‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Çí‰ΩúÊàê„Åó„ÄÅ
„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰ΩøÁî®„Åó„Å¶„Åù„Çå„Çâ„Çí‰Ωø„ÅÜÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„ÇíË©¶„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Âûã„ÇØ„É©„Çπ"><a class="header" href="#Âûã„ÇØ„É©„Çπ">Âûã„ÇØ„É©„Çπ</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-4"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-4">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅPureScript„ÅÆÂûã„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„Å£„Å¶ÂèØËÉΩ„Å´„Å™„ÇãÂº∑Âäõ„Å™ÊäΩË±°Âåñ„ÅÆÊâãÊ≥ï„Åß„ÅÇ„Çã„ÄÅÂûã„ÇØ„É©„Çπ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„Éá„Éº„ÇøÊßãÈÄ†„Çí„Éè„ÉÉ„Ç∑„É•„Åô„Çã„Åü„ÇÅ„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíÈ°åÊùê„Å´Ë™¨Êòé„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ„Éá„Éº„ÇøËá™Ë∫´„ÅÆÊßãÈÄ†„Å´„Å§„ÅÑ„Å¶Áõ¥Êé•ËÄÉ„Åà„Çã„Åì„Å®„Å™„ÅèË§áÈõë„Å™ÊßãÈÄ†„ÅÆ„Éá„Éº„Çø„ÅÆ„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÊ±Ç„ÇÅ„Çã„Åü„ÇÅ„Å´„ÄÅÂûã„ÇØ„É©„Çπ„ÅÆ‰ªïÁµÑ„Åø„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´„Åó„Å¶ÂÉç„Åè„ÅÆ„Åã„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åæ„Åü„ÄÅPureScript„ÅÆPrelude„ÇÑÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„Å´Âê´„Åæ„Çå„Çã„ÄÅÊ®ôÊ∫ñÁöÑ„Å™Âûã„ÇØ„É©„Çπ„ÇÇË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇPureScript„ÅÆ„Ç≥„Éº„Éâ„ÅØÊ¶ÇÂøµ„ÇíÁ∞°ÊΩî„Å´Ë°®Áèæ„Åô„Çã„Åü„ÇÅ„Å´Âûã„ÇØ„É©„Çπ„ÅÆÂº∑Âäõ„Åï„Å´Â§ß„Åç„Åè‰æùÂ≠ò„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„Åì„Çå„Çâ„ÅÆ„ÇØ„É©„Çπ„Å´ÊÖ£„Çå„Å¶„Åä„Åè„Å®ÂΩπ„Å´Á´ã„Å§„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊåáÂêë„ÅÆÊñπÈù¢„Åã„ÇâÂÖ•„Å£„Å¶Êù•„ÅüÊñπ„ÅØ„ÄÅ
„Äå„ÇØ„É©„Çπ„Äç„Å®„ÅÑ„ÅÜÂçòË™û„Åå„Åù„Çå„Åæ„ÅßÈ¶¥Êüì„Åø„ÅÆ„ÅÇ„Çã„ÇÇ„ÅÆ„Å®„Åì„ÅÆÊñáËÑà„Å®„Åß„ÅØ
<strong>„Åã„Å™„Çä</strong>Áï∞„Å™„Çã„ÇÇ„ÅÆ„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-3"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-3">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ„ÄÅ„Éï„Ç°„Ç§„É´ <code>src/data/Hashable.purs</code>„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´„ÅØ‰ª•‰∏ã„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>maybe</code>: „Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„ÇíË°®„Åô <code>Maybe</code>„Éá„Éº„ÇøÂûã„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>tuples</code>: ÂÄ§„ÅÆÁµÑ„ÇíË°®„Åô <code>Tuple</code>„Éá„Éº„ÇøÂûã„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>either</code>: Èùû‰∫§Âíå„ÇíË°®„Åô <code>Either</code>„Éá„Éº„ÇøÂûã„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>strings</code>: ÊñáÂ≠óÂàó„ÇíÊìç‰Ωú„Åô„ÇãÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>functions</code>: PureScript„ÅÆË®òËø∞Áî®„ÅÆË£úÂä©Èñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
</ul>
<p>„É¢„Ç∏„É•„Éº„É´ <code>Data.Hashable</code>„Åß„ÅØ„ÄÅ„Åì„Çå„Çâ„ÅÆ„Éë„ÉÉ„Ç±„Éº„Ç∏„Å´„Çà„Å£„Å¶Êèê‰æõ„Åï„Çå„Çã„É¢„Ç∏„É•„Éº„É´„ÅÆ„ÅÑ„Åè„Å§„Åã„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="Ë¶ã„Åõ„Å¶„Åè„Å†„Åï„ÅÑ"><a class="header" href="#Ë¶ã„Åõ„Å¶„Åè„Å†„Åï„ÅÑ">Ë¶ã„Åõ„Å¶„Åè„Å†„Åï„ÅÑÔºÅ</a></h2>
<p>Âûã„ÇØ„É©„Çπ„ÅÆÊúÄÂàù„ÅÆÁ∞°Âçò„Å™‰æã„ÅØ„ÄÅ„Åô„Åß„Å´‰ΩïÂõû„ÅãË¶ã„Åü„Åì„Å®„Åå„ÅÇ„ÇãÈñ¢Êï∞„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>show</code>„ÅØ„ÄÅ‰Ωï„Çâ„Åã„ÅÆÂÄ§„ÇíÂèñ„Çä„ÄÅ„Åù„Çå„ÇíÊñáÂ≠óÂàó„Å®„Åó„Å¶Ë°®Á§∫„Åô„ÇãÈñ¢Êï∞„Åß„Åô„ÄÇ</p>
<p><code>show</code>„ÅØ <code>Prelude</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ <code>Show</code>„Å®Âëº„Å∞„Çå„ÇãÂûã„ÇØ„É©„Çπ„ÅßÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String
</code></pre>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ„Åß„ÅØ„ÄÅÂûãÂ§âÊï∞ <code>a</code>„Åß„Éë„É©„É°„Éº„ÇøÂåñ„Åï„Çå„Åü„ÄÅ
<code>Show</code>„Å®„ÅÑ„ÅÜÊñ∞„Åó„ÅÑ<strong>Âûã„ÇØ„É©„Çπ</strong> (type class) „ÇíÂÆ£Ë®Ä„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Âûã„ÇØ„É©„Çπ<strong>„Ç§„É≥„Çπ„Çø„É≥„Çπ</strong>„Å´„ÅØ„ÄÅÂûã„ÇØ„É©„Çπ„ÅßÂÆöÁæ©„Åï„Çå„ÅüÈñ¢Êï∞„ÅÆ„ÄÅ„Åù„ÅÆÂûã„Å´ÁâπÊÆäÂåñ„Åï„Çå„ÅüÂÆüË£Ö„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„ÄÅPrelude„Å´„ÅÇ„Çã <code>Boolean</code>ÂÄ§„Å´ÂØæ„Åô„Çã <code>Show</code>Âûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÂÆöÁæ©„ÅØÊ¨°„ÅÆÈÄö„Çä„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance showBoolean :: Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØ <code>showBool‚Äã‚Äãean</code>„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆ£Ë®Ä„Åó„Åæ„Åô„ÄÇ
PureScript„Åß„ÅØ„ÄÅÁîüÊàê„Åï„Çå„ÅüJavaScript„ÅÆÂèØË™≠ÊÄß„ÇíËâØ„Åè„Åô„Çã„Åü„ÇÅ„Å´„ÄÅÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´ÂêçÂâç„Çí„Å§„Åë„Åæ„Åô„ÄÇ„Åì„ÅÆ„Å®„Åç„ÄÅ<strong><code>Boolean</code>Âûã„ÅØ
<code>Show</code>Âûã„ÇØ„É©„Çπ„Å´Â±û„Åó„Å¶„ÅÑ„Çã</strong>„Å®„ÅÑ„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>PSCi„Åß„ÄÅ„ÅÑ„Çç„ÅÑ„Çç„Å™Âûã„ÅÆÂÄ§„Çí<code>Show</code>Âûã„ÇØ„É©„Çπ„ÇíÂà©Áî®„Åó„Å¶Ë°®Á§∫„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude

&gt; show true
&quot;true&quot;

&gt; show 1.0
&quot;1.0&quot;

&gt; show &quot;Hello World&quot;
&quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>„Åì„ÅÆ‰æã„Åß„ÅØ„Åï„Åæ„Åñ„Åæ„Å™„Éó„É™„Éü„ÉÜ„Ç£„ÉñÂûã„ÅÆÂÄ§„Çí <code>show</code>„Åó„Åæ„Åó„Åü„Åå„ÄÅ„ÇÇ„Å£„Å®Ë§áÈõë„Å™Âûã„ÇíÊåÅ„Å§ÂÄ§„Çí <code>show</code>„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Tuple

&gt; show (Tuple 1 true)
&quot;(Tuple 1 true)&quot;

&gt; import Data.Maybe

&gt; show (Just &quot;testing&quot;)
&quot;(Just \&quot;testing\&quot;)&quot;
</code></pre>
<p><code>show</code>„ÅÆÂá∫Âäõ„ÅØ„ÄÅREPL„Å´Ôºà„ÅÇ„Çã„ÅÑ„ÅØ<code>.purs</code>„Éï„Ç°„Ç§„É´„Å´Ôºâ„ÇÇ„ÅÜ‰∏ÄÂ∫¶Ë≤º„Çä‰ªò„Åë„Çå„Å∞„ÄÅ
Ë°®Á§∫„Åï„Çå„Çã„ÇÇ„ÅÆ„ÇíÂÜç‰ΩúÊàê„Åß„Åç„Çã„Çà„ÅÜ„Å™ÊñáÂ≠óÂàó„Åß„ÅÇ„Çã„Åπ„Åç„Åß„Åô„ÄÇ
‰ª•‰∏ã„Åß„ÅØ<code>logShow</code>„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ„Åì„Çå„ÅØÂçò„Å´<code>show</code>„Å®<code>log</code>„ÇíÈ†Ü„Å´Âëº„Å≥Âá∫„Åó„Å¶„ÄÅ
ÂºïÁî®Á¨¶„Å™„Åó„Å´ÊñáÂ≠óÂàó„ÇíË°®Á§∫„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
<code>unit</code>„ÅÆË°®Á§∫„ÅØÁÑ°Ë¶ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Á¨¨8Á´†„Åß„ÄÅ<code>log</code>„ÅÆ„Çà„ÅÜ„Å™<code>Effect</code>„ÇíË™ø„Åπ„Çã„Å®„Åç„Å´Êäº„Åï„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Effect.Console

&gt; logShow (Tuple 1 true)
(Tuple 1 true)
unit

&gt; logShow (Just &quot;testing&quot;)
(Just &quot;testing&quot;)
unit
</code></pre>
<p>Âûã <code>Data.Either</code>„ÅÆÂÄ§„ÇíË°®Á§∫„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å®„ÄÅËààÂë≥Ê∑±„ÅÑ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; show (Left 10)

The inferred type

    forall a. Show a =&gt; String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>„Åì„Åì„Åß„ÅÆÂïèÈ°å„ÅØ <code>show</code>„Åó„Çà„ÅÜ„Å®„Åó„Å¶„ÅÑ„ÇãÂûã„Å´ÂØæ„Åô„Çã <code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„ÅØ„Å™„Åè„ÄÅ
PSCi„Åå„Åì„ÅÆÂûã„ÇíÊé®Ë´ñ„Åß„Åç„Å™„Åã„Å£„Åü„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
„Åì„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Åß<strong>Êú™Áü•„ÅÆÂûã</strong><code>a</code>„Å®Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åå„Åù„Çå„Åß„Åô„ÄÇ</p>
<p><code>::</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„Å£„Å¶Âºè„Å´ÂØæ„Åó„Å¶ÂûãÊ≥®Èáà„ÇíÂä†„Åà„Çã„Å®„ÄÅ
PSCi„ÅåÊ≠£„Åó„ÅÑÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÈÅ∏„Å∂„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; show (Left 10 :: Either Int String)
&quot;(Left 10)&quot;
</code></pre>
<p><code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí„Åæ„Å£„Åü„ÅèÊåÅ„Å£„Å¶„ÅÑ„Å™„ÅÑÂûã„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
Èñ¢Êï∞„ÅÆÂûã <code>-&gt;</code>„Åå„Åù„ÅÆ‰∏Ä‰æã„Åß„Åô„ÄÇ
<code>Int</code>„Åã„Çâ <code>Int</code>„Å∏„ÅÆÈñ¢Êï∞„Çí <code>show</code>„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å®„ÄÅ
ÂûãÊ§úË®ºÂô®„Å´„Çà„Å£„Å¶„Åù„ÅÆÈÄö„Çä„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude
&gt; show $ \n -&gt; n + 1

No type class instance was found for

  Data.Show.Show (Int -&gt; Int)
</code></pre>
<p>Âûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØÊ¨°„ÅÆ2„Å§„ÅÆ„ÅÜ„Å°„ÅÑ„Åö„Çå„Åã„ÅÆÂΩ¢„ÅßÂÆöÁæ©„Åï„Çå„Åæ„Åô„ÄÇ
Âûã„ÇØ„É©„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÂêå„Åò„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åô„Çã„Åã„ÄÅ
Âûã„ÇØ„É©„Çπ„Å´„ÄåÂ±û„Åó„Å¶„Äç„ÅÑ„ÇãÂûã„Å®Âêå„Åò„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åô„Çã„Åã„Åß„Åô„ÄÇ
„Åì„Çå„Çâ„Å®„ÅØÂà•„ÅÆÂ†¥ÊâÄ„ÅßÂÆöÁæ©„Åï„Çå„Çã„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">„ÄåÂ≠§Á´ã„Ç§„É≥„Çπ„Çø„É≥„Çπ„Äç</a>„Å®Âëº„Å∞„Çå„ÄÅPureScript„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶Ë®±„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ
„Åì„ÅÆÁ´†„ÅÆÊºîÁøí„ÅÆ„ÅÑ„Åè„Å§„Åã„Åß„ÅØ„ÄÅ
„Åù„ÅÆÂûã„ÅÆÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅ
Âûã„ÅÆÂÆöÁæ©„ÇíËá™ÂàÜ„ÅÆ<code>MySolutions</code>„É¢„Ç∏„É•„Éº„É´„Å´Ë§áË£Ω„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-13"><a class="header" href="#ÊºîÁøí-13">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí<code>Point</code>„Å´ÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Ââç„ÅÆÁ´†„ÅÆ<code>showPoint</code>Èñ¢Êï∞„Å®Âêå„ÅòÂá∫Âäõ„Å´‰∏ÄËá¥„Åô„Çã„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö<code>Point</code>„ÅØ„Åì„Åì„Åß„ÅØÔºà<code>type</code>ÂêåÁæ©Ë™û„Åß„ÅØ„Å™„ÅèÔºâ<code>newtype</code>„Åß„Åô„ÄÇ
„Åù„ÅÆ„Åü„ÇÅ<code>show</code>„ÅÆ‰ªïÊñπ„ÇíÂ§â„Åà„Çâ„Çå„Åæ„Åô„ÄÇ
„Åì„ÅÜ„Åß„ÇÇ„Åó„Å™„ÅÑ„Å®„É¨„Ç≥„Éº„Éâ„Å∏„ÅÆÊó¢ÂÆö„ÅÆ<code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åã„ÇâÈÄÉ„Çå„Çâ„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">newtype Point
  = Point
  { x :: Number
  , y :: Number
  }
</code></pre>
</li>
</ol>
<h2 id="„Çà„ÅèË¶ã„Åã„Åë„ÇãÂûã„ÇØ„É©„Çπ"><a class="header" href="#„Çà„ÅèË¶ã„Åã„Åë„ÇãÂûã„ÇØ„É©„Çπ">„Çà„ÅèË¶ã„Åã„Åë„ÇãÂûã„ÇØ„É©„Çπ</a></h2>
<p>„Åì„ÅÆÁØÄ„Åß„ÅØ„ÄÅPrelude„ÇÑÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÊ®ôÊ∫ñÁöÑ„Å™Âûã„ÇØ„É©„Çπ„Çí„ÅÑ„Åè„Å§„ÅãË¶ã„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„Çå„Çâ„ÅÆÂûã„ÇØ„É©„Çπ„ÅØPureScriptÁâπÊúâ„ÅÆÊäΩË±°Âåñ„ÅÆÂ§ö„Åè„ÅÆ„Çà„Åè„ÅÇ„Çã„Éë„Çø„Éº„É≥„ÅÆÂü∫Á§é„ÇíÂΩ¢Êàê„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ
„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÅÆÂü∫Êú¨„Å´„Å§„ÅÑ„Å¶„Çà„ÅèÁêÜËß£„Åó„Å¶„Åä„Åè„Åì„Å®„ÇíÂº∑„Åè„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ</p>
<h3 id="eq-1"><a class="header" href="#eq-1">Eq</a></h3>
<p><code>Eq</code>Âûã„ÇØ„É©„Çπ„ÅØ„ÄÅ2„Å§„ÅÆÂÄ§„ÅåÁ≠â„Åó„ÅÑ„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„Çã<code>eq</code>Èñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Á≠âÂÄ§ÊºîÁÆóÂ≠ê (<code>==</code>) „ÅØ<code>eq</code>„ÅÆÂà•Âêç„Å´„Åô„Åé„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>Áï∞„Å™„ÇãÂûã„ÅÆ2„Å§„ÅÆÂÄ§„ÇíÊØîËºÉ„Åó„Å¶„ÇÇÊÑèÂë≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„Åã„Çâ„ÄÅ
„ÅÑ„Åö„Çå„ÅÆÊºîÁÆóÂ≠ê„ÇÇ2„Å§„ÅÆÂºïÊï∞„ÅåÂêå„ÅòÂûã„ÇíÊåÅ„Å§ÂøÖË¶Å„Åå„ÅÇ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>PSCi„Åß <code>Eq</code>Âûã„ÇØ„É©„Çπ„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true
</code></pre>
<h3 id="ord-1"><a class="header" href="#ord-1">Ord</a></h3>
<p><code>Ord</code>Âûã„ÇØ„É©„Çπ„ÅØÈ†ÜÂ∫è‰ªò„ÅëÂèØËÉΩ„Å™Âûã„Å´ÂØæ„Åó„Å¶2„Å§„ÅÆÂÄ§„ÇíÊØîËºÉ„Åô„Çã <code>compare</code>Èñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ
ÊØîËºÉÊºîÁÆóÂ≠ê <code>&lt;</code>„ÄÅ <code>&gt;</code>„Å®„ÄÅ„Åù„ÅÆ‰ª≤Èñì„ÅÆÂé≥ÂØÜ„Å™ÊØîËºÉ„Åß„ÅØ„Å™„ÅÑ<code>&lt;=</code>„ÄÅ <code>&gt;=</code>„ÇÇ„ÄÅ<code>compare</code>„Çí‰Ωø„Å£„Å¶ÂÆöÁæ©„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p><code>compare</code>Èñ¢Êï∞„ÅØ2„Å§„ÅÆÂÄ§„ÇíÊØîËºÉ„Åó„Å¶ <code>Ordering</code>„ÅÆ3„Å§„ÅÆÂÄ§„ÅÆ„ÅÜ„Å°„ÅÑ„Åö„Çå„Åã„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>LT</code>- ÊúÄÂàù„ÅÆÂºïÊï∞„Åå2Áï™ÁõÆ„ÅÆÂÄ§„Çà„ÇäÂ∞è„Åï„ÅÑ„Å®„Åç</li>
<li><code>EQ</code>- ÊúÄÂàù„ÅÆÂºïÊï∞„Åå2Áï™ÁõÆ„ÅÆÂÄ§„Å®Á≠â„Åó„ÅÑÔºà„Åæ„Åü„ÅØÊØîËºÉ„Åß„Åç„Å™„ÅÑÔºâ„Å®„Åç</li>
<li><code>GT</code>- ÊúÄÂàù„ÅÆÂºïÊï∞„Åå2Áï™ÁõÆ„ÅÆÂÄ§„Çà„ÇäÂ§ß„Åç„ÅÑ„Å®„Åç</li>
</ul>
<p>„Åì„Åì„Åß„ÇÇ<code>compare</code>Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶PSCi„ÅßË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT
</code></pre>
<h3 id="field-1"><a class="header" href="#field-1">Field</a></h3>
<p><code>Field</code>Âûã„ÇØ„É©„Çπ„ÅØÂä†ÁÆó„ÄÅÊ∏õÁÆó„ÄÅ‰πóÁÆó„ÄÅÈô§ÁÆó„Å™„Å©„ÅÆÊï∞ÂÄ§ÊºîÁÆóÂ≠ê„Çí‰ΩøÁî®ÂèØËÉΩ„Å™Âûã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ
ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂÜçÂà©Áî®„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅ„Åì„Çå„Çâ„ÅÆÊºîÁÆóÂ≠ê„ÇíÊäΩË±°Âåñ„Åô„Çã„Çè„Åë„Åß„Åô„ÄÇ</p>
<p><strong>Ê≥®ÊÑè</strong>ÔºöÂûã„ÇØ„É©„Çπ <code>Eq</code>„ÇÑ <code>Ord</code>„ÅÆ„ÇØ„É©„Çπ„Å®„Å°„Çá„ÅÜ„Å©Âêå„Åò„Çà„ÅÜ„Å´„ÄÅ
<code>Field</code>Âûã„ÅÆ„ÇØ„É©„Çπ„ÅØPureScript„Ç≥„É≥„Éë„Ç§„É©„ÅßÁâπÂà•„Å´Êâ±„Çè„Çå„ÄÅ
<code>1 + 2 * 3</code>„ÅÆ„Çà„ÅÜ„Å™ÂçòÁ¥î„Å™Âºè„ÅØÂçòÁ¥î„Å™JavaScript„Å∏„Å®Â§âÊèõ„Åï„Çå„Åæ„Åô„ÄÇ
Âûã„ÇØ„É©„Çπ„ÅÆÂÆüË£Ö„Å´Âü∫„ÅÑ„Å¶Âëº„Å≥Âá∫„Åï„Çå„ÇãÈñ¢Êï∞Âëº„Å≥Âá∫„Åó„Å®„ÅØÂØæÁÖßÁöÑ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">class EuclideanRing a &lt;= Field a
</code></pre>
<p><code>Field</code>Âûã„ÇØ„É©„Çπ„ÅØ„ÄÅ„ÅÑ„Åè„Å§„Åã„ÅÆ„Çà„ÇäÊäΩË±°ÁöÑ„Å™<strong>‰∏ä‰Ωç„ÇØ„É©„Çπ</strong> (Super Class) „ÅåÁµÑ„ÅøÂêà„Çè„Åï„Å£„Å¶„Åß„Åç„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅ„Åù„ÅÆÂûã„ÅØ<code>Field</code>Âûã„ÇØ„É©„Çπ„ÅÆÊìç‰Ωú„Çí„Åô„Åπ„Å¶„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Çã„Çè„Åë„Åß„ÅØ„Å™„ÅÑ„Åå„ÄÅ
„Åù„ÅÆ‰∏ÄÈÉ®„ÇíÊèê‰æõ„Åô„Çã„ÄÅ„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´ÊäΩË±°ÁöÑ„Å´Ë™¨Êòé„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆÂûã„ÇØ„É©„Çπ„ÅØÊäΩË±°ÁöÑ„Å™„Åô„Åπ„Å¶„Åß„ÅØ„Å™„ÅÑ„ÅÑ„Åè„Å§„Åã„ÅÆÊï∞ÂÄ§ÊºîÁÆóÂ≠ê„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞„ÄÅËá™ÁÑ∂Êï∞„ÅÆÂûã„ÅØÂä†ÁÆó„Åä„Çà„Å≥‰πóÁÆó„Å´„Å§„ÅÑ„Å¶„ÅØÈñâ„Åò„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
Ê∏õÁÆó„Å´„Å§„ÅÑ„Å¶„ÅØÈñâ„Åò„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„ÄÅ
„Åì„ÅÆÂûã„ÅØ<code>Semiring</code>„ÇØ„É©„ÇπÔºà„Åì„Çå„ÅØ<code>Num</code>„ÅÆ‰∏ä‰Ωç„ÇØ„É©„Çπ„Åß„ÅôÔºâ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„Åô„Åå„ÄÅ
<code>Ring</code>„ÇÑ<code>Field</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>‰∏ä‰Ωç„ÇØ„É©„Çπ„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅ„Åì„ÅÆÁ´†„ÅÆÂæåÂçä„ÅßË©≥„Åó„ÅèË™¨Êòé„Åó„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åô„Åπ„Å¶„ÅÆ<a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">Êï∞ÂÄ§Âûã„ÇØ„É©„Çπ„ÅÆÈöéÂ±§</a>Ôºà<a href="https://harry.garrood.me/numeric-hierarchy-overview/">„ÉÅ„Éº„Éà„Ç∑„Éº„Éà</a>Ôºâ„Å´„Å§„ÅÑ„Å¶Ëø∞„Åπ„Çã„ÅÆ„ÅØ„Åì„ÅÆÁ´†„ÅÆÁõÆÁöÑ„Åã„ÇâÂ§ñ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÂÜÖÂÆπ„Å´ËààÂë≥„ÅÆ„ÅÇ„ÇãË™≠ËÄÖ„ÅØ<code>prelude</code>ÂÜÖ„ÅÆ <code>Field</code>„Å´Èñ¢„Åô„Çã„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h3 id="ÂçäÁæ§„Å®„É¢„Éé„Ç§„Éâ"><a class="header" href="#ÂçäÁæ§„Å®„É¢„Éé„Ç§„Éâ">ÂçäÁæ§„Å®„É¢„Éé„Ç§„Éâ</a></h3>
<p><code>Semigroup</code>ÔºàÂçäÁæ§ÔºâÂûã„ÇØ„É©„Çπ„ÅØ„ÄÅ2„Å§„ÅÆÂÄ§„ÇíÈÄ£Áµê„Åô„ÇãÊºîÁÆóÂ≠ê <code>append</code>„ÇíÊèê‰æõ„Åô„ÇãÂûã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a
</code></pre>
<p>ÊôÆÈÄö„ÅÆÊñáÂ≠óÂàóÈÄ£Áµê„Å´„Å§„ÅÑ„Å¶ÊñáÂ≠óÂàó„ÅØÂçäÁæ§„Çí„Å™„Åó„ÄÅÂêåÊßò„Å´ÈÖçÂàó„ÇÇÂçäÁæ§„Çí„Å™„Åó„Åæ„Åô„ÄÇ
„Åù„ÅÆ‰ªñ„ÅÆÊ®ôÊ∫ñÁöÑ„Å™„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÂπæ„Å§„Åã„ÅØ„ÄÅ <code>prelude</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰ª•Ââç„Å´Ë¶ã„Åü <code>&lt;&gt;</code>ÈÄ£ÁµêÊºîÁÆóÂ≠ê„ÅØ„ÄÅ <code>append</code>„ÅÆÂà•Âêç„Å®„Åó„Å¶Êèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Ôºà<code>prelude</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„ÇãÔºâ<code>Monoid</code>Âûã„ÇØ„É©„Çπ„ÅØ„ÄÅ
<code>mempty</code>„Å®Âëº„Å∞„Çå„ÇãÁ©∫„ÅÆÂÄ§„ÅÆÊ¶ÇÂøµ„Åß <code>Semigroup</code>Âûã„ÇØ„É©„Çπ„ÇíÊã°Âºµ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>„Åì„Åì„Åß„ÇÇÊñáÂ≠óÂàó„ÇÑÈÖçÂàó„ÅØ„É¢„Éé„Ç§„Éâ„ÅÆÁ∞°Âçò„Å™‰æã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Monoid</code>Âûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅØ„ÄÅ
„ÄåÁ©∫„Äç„ÅÆÂÄ§„Åã„ÇâÂßã„ÇÅ„Å¶Êñ∞„Åü„Å™ÂÄ§„ÇíÂêàÊàê„Åó„Å¶„ÅÑ„Åç„ÄÅ
„Åù„ÅÆÂûã„Åß<strong>Á¥ØÁ©ç</strong>„Åó„ÅüÁµêÊûú„ÇíËøî„Åô„Å´„ÅØ„Å©„ÅÜ„Åô„Çã„Åã„ÇíË®òËø∞„Åô„ÇãÂûã„ÇØ„É©„Çπ„Åß„Åô„ÄÇ
‰æã„Åà„Å∞„ÄÅÁï≥„ÅøËæº„Åø„Çí‰Ωø„Å£„Å¶„ÅÑ„Åè„Å§„Åã„ÅÆ„É¢„Éé„Ç§„Éâ„ÅÆÂÄ§„ÅÆÈÖçÂàó„ÇíÈÄ£Áµê„Åô„ÇãÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
PSCi„ÅßË©¶„Åô„Å®Ê¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">&gt; import Prelude
&gt; import Data.Monoid
&gt; import Data.Foldable

&gt; foldl append mempty [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&quot;Hello World&quot;

&gt; foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
</code></pre>
<p><code>prelude</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Å´„ÅØ„É¢„Éé„Ç§„Éâ„Å®ÂçäÁæ§„ÅÆÂ§ö„Åè„ÅÆ‰æã„ÇíÊèê‰æõ„Åó„Å¶„Åä„Çä„ÄÅ
‰ª•Èôç„ÇÇ„Åì„Çå„Çâ„ÇíÊú¨Êõ∏„ÅßÊâ±„Å£„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h3 id="foldable-1"><a class="header" href="#foldable-1">Foldable</a></h3>
<p><code>Monoid</code>Âûã„ÇØ„É©„Çπ„ÅØÁï≥„ÅøËæº„Åø„ÅÆÁµêÊûú„Å´„Å™„Çã„Çà„ÅÜ„Å™Âûã„ÇíÁ§∫„Åó„Åæ„Åô„Åå„ÄÅ
<code>Foldable</code>Âûã„ÇØ„É©„Çπ„ÅØ„ÄÅÁï≥„ÅøËæº„Åø„ÅÆÂÖÉ„ÅÆ„Éá„Éº„Çø„Å®„Åó„Å¶‰Ωø„Åà„Çã„Çà„ÅÜ„Å™ÂûãÊßãÁØâÂ≠ê„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åæ„Åü„ÄÅ <code>Foldable</code>Âûã„ÇØ„É©„Çπ„ÅØ„ÄÅ
ÈÖçÂàó„ÇÑ <code>Maybe</code>„Å™„Å©„ÅÆ„ÅÑ„Åè„Å§„Åã„ÅÆÊ®ôÊ∫ñÁöÑ„Å™„Ç≥„É≥„ÉÜ„Éä„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂê´„ÇÄ
<code>foldable-traversable</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Foldable</code>„ÇØ„É©„Çπ„Å´Â±û„Åô„ÇãÈñ¢Êï∞„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØ„ÄÅ„Åì„Çå„Åæ„ÅßË¶ã„Å¶„Åç„Åü„ÇÇ„ÅÆ„Çà„Çä„ÇÇÂ∞ë„ÅóË§áÈõë„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p>„Åì„ÅÆÂÆöÁæ©„ÅØ <code>f</code>„ÇíÈÖçÂàó„ÅÆÂûãÊßãÁØâÂ≠ê„Å®„Åó„Å¶ÁâπÊÆäÂåñ„Åó„Å¶ËÄÉ„Åà„Å¶„Åø„Çã„Å®„Çè„Åã„Çä„ÇÑ„Åô„Åè„Å™„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆÂ†¥Âêà„ÄÅ„Åô„Åπ„Å¶„ÅÆ <code>a</code>„Å´„Å§„ÅÑ„Å¶ <code>f a</code>„Çí <code>Array a</code>„Å´ÁΩÆ„ÅçÊèõ„Åà„Çã‰∫ã„Åå„Åß„Åç„Åæ„Åô„Åå„ÄÅ
<code>foldl</code>„Å® <code>foldr</code>„ÅÆÂûã„Åå„ÄÅÊúÄÂàù„Å´Ë¶ã„ÅüÈÖçÂàó„Å´ÂØæ„Åô„ÇãÁï≥„ÅøËæº„Åø„ÅÆÂûã„Å´„Å™„Çã„Å®„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<p><code>foldMap</code>„Å´„Å§„ÅÑ„Å¶„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„ÅãÔºü
„Åì„Çå„ÅØ <code>forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Array a -&gt; m</code>„Å´„Å™„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØ„ÄÅÂûã <code>m</code>„Åå <code>Monoid</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅÇ„Çå„Å∞
„Å©„Çì„Å™Âûã„Åß„ÇÇËøî„ÇäÂÄ§„ÅÆÂûã„Å®„Åó„Å¶ÈÅ∏„Å∂„Åì„Å®„Åå„Åß„Åç„Çã„Å®Ë®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÈÖçÂàó„ÅÆË¶ÅÁ¥†„Çí„Åù„ÅÆ„É¢„Éé„Ç§„Éâ„ÅÆÂÄ§„Å∏„Å®Â§âÊèõ„Åô„ÇãÈñ¢Êï∞„ÇíÊèê‰æõ„Åô„Çå„Å∞„ÄÅ
„Åù„ÅÆ„É¢„Éé„Ç§„Éâ„ÅÆÊßãÈÄ†„ÇíÂà©Áî®„Åó„Å¶ÈÖçÂàó„ÇíÁï≥„ÅøËæº„Åø„ÄÅ„Å≤„Å®„Å§„ÅÆÂÄ§„Å´„Åó„Å¶Ëøî„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØPSCi„Åß <code>foldMap</code>„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;
</code></pre>
<p>„Åì„Åì„Åß„ÅØÁπã„ÅéÂêà„Çè„Åõ„Çã„Åü„ÇÅ„ÅÆ„É¢„Éé„Ç§„Éâ„Å®„Åó„Å¶ÊñáÂ≠óÂàó„Çí„ÄÅ
„Åù„Åó„Å¶<code>Int</code>„ÇíÊñáÂ≠óÂàó„Å®„Åó„Å¶Ë°®Á§∫„Åô„Çã <code>show</code>Èñ¢Êï∞„ÇíÈÅ∏„Å≥„Åæ„Åó„Åü„ÄÇ
„Åù„Çå„Åã„Çâ„ÄÅÊï∞„ÅÆÈÖçÂàó„ÇíÊ∏°„Åô„Å®„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÊï∞„Çí <code>show</code>„Åó„Å¶„Å≤„Å®„Å§„ÅÆÊñáÂ≠óÂàó„Å∏„Å®ÈÄ£Áµê„Åó„ÅüÁµêÊûú„ÅåÂá∫Âäõ„Åï„Çå„Åæ„Åó„Åü„ÄÇ</p>
<p>„Åó„Åã„ÅóÁï≥„ÅøËæº„ÅøÂèØËÉΩ„Å™Âûã„ÅØÈÖçÂàó„Å†„Åë„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
<code>foldable-traversable</code>„Åß„ÅØ <code>Maybe</code>„ÇÑ <code>Tuple</code>„ÅÆ„Çà„ÅÜ„Å™Âûã„ÅÆ <code>Foldable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„Åä„Çä„ÄÅ
<code>lists</code>„ÅÆ„Çà„ÅÜ„Å™‰ªñ„ÅÆ„É©„Ç§„Éñ„É©„É™„Åß„ÅØ„ÄÅ
„Åù„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅÆ„Åù„Çå„Åû„Çå„ÅÆ„Éá„Éº„ÇøÂûã„Å´ÂØæ„Åó„Å¶ <code>Foldable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Foldable</code>„ÅØ<strong>È†ÜÂ∫è‰ªò„Åç„Ç≥„É≥„ÉÜ„Éä</strong> (ordered container) „ÅÆÊ¶ÇÂøµ„ÇíÊçâ„Åà„Åü„ÇÇ„ÅÆ„Å™„ÅÆ„Åß„Åô„ÄÇ</p>
<h3 id="Èñ¢Êâã„Å®Âûã„ÇØ„É©„ÇπÂâá"><a class="header" href="#Èñ¢Êâã„Å®Âûã„ÇØ„É©„ÇπÂâá">Èñ¢Êâã„Å®Âûã„ÇØ„É©„ÇπÂâá</a></h3>
<p>PureScript„ÅßÂâØ‰ΩúÁî®„Çí‰º¥„ÅÜÈñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÅÆ„Çπ„Çø„Ç§„É´„ÇíÂèØËÉΩ„Å´„Åô„Çã„Åü„ÇÅ„ÅÆ
<code>Functor</code>„Å® <code>Applicative</code>„ÄÅ <code>Monad</code>„Å®„ÅÑ„Å£„ÅüÂûã„ÇØ„É©„Çπ„ÅåPrelude„Åß„ÅØÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆÊäΩË±°„Å´„Å§„ÅÑ„Å¶„ÅØÊú¨Êõ∏„ÅßÂæå„Åª„Å©Êâ±„ÅÑ„Åæ„Åô„Åå„ÄÅ
„Åæ„Åö„ÅØ<code>map</code>Èñ¢Êï∞„ÅÆÂΩ¢„Åß„Åô„Åß„Å´Ë¶ã„Å¶„Åç„Åü <code>Functor</code>Âûã„ÇØ„É©„Çπ„ÅÆÂÆöÁæ©„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>map</code>Èñ¢Êï∞ÔºàÂà•Âêç<code>&lt;$&gt;</code>Ôºâ„ÅØÈñ¢Êï∞„Çí„Åù„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„Åæ„Åß„ÄåÊåÅ„Å°‰∏ä„Åí„Çã„Äç(lift) „Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Åì„Åß„ÄåÊåÅ„Å°‰∏ä„Åí„Äç„Å®„ÅÑ„ÅÜË®ÄËëâ„ÅÆÂÖ∑‰ΩìÁöÑ„Å™ÂÆöÁæ©„ÅØÂïèÈ°å„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„Å´‰æù„Çä„Åæ„Åô„Åå„ÄÅ
„Åô„Åß„Å´„ÅÑ„Åè„Å§„Åã„ÅÆÂçòÁ¥î„Å™Âûã„Å´„Å§„ÅÑ„Å¶„Åù„ÅÆÂãï‰Ωú„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude

&gt; map (\n -&gt; n &lt; 3) [1, 2, 3, 4, 5]
[true, true, false, false, false]

&gt; import Data.Maybe
&gt; import Data.String (length)

&gt; map length (Just &quot;testing&quot;)
(Just 7)
</code></pre>
<p><code>map</code>ÊºîÁÆóÂ≠ê„ÅØÊßò„ÄÖ„Å™ÊßãÈÄ†„ÅÆ‰∏ä„Åß„Åù„Çå„Åû„ÇåÁï∞„Å™„ÇãÊåØ„ÇãËàû„ÅÑ„Çí„Åó„Åæ„Åô„Åå„ÄÅ <code>map</code>ÊºîÁÆóÂ≠ê„ÅÆÊÑèÂë≥„ÅØ„Å©„ÅÆ„Çà„ÅÜ„Å´ÁêÜËß£„Åô„Çå„Å∞„ÅÑ„ÅÑ„ÅÆ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
<p>Áõ¥ÊÑüÁöÑ„Å´„ÅØ„ÄÅ <code>map</code>ÊºîÁÆóÂ≠ê„ÅØ„Ç≥„É≥„ÉÜ„Éä„ÅÆ„Åù„Çå„Åû„Çå„ÅÆË¶ÅÁ¥†„Å∏Èñ¢Êï∞„ÇíÈÅ©Áî®„Åó„ÄÅ
„Åù„ÅÆÁµêÊûú„Åã„ÇâÂÖÉ„ÅÆ„Éá„Éº„Çø„Å®Âêå„ÅòÂΩ¢Áä∂„ÇíÊåÅ„Å£„ÅüÊñ∞„Åó„ÅÑ„Ç≥„É≥„ÉÜ„Éä„ÇíÊßãÁØâ„Åô„Çã„ÇÇ„ÅÆ„Å®„Åß„Åç„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åì„ÅÆÁùÄÊÉ≥„ÇíÁ≤æÂØÜ„Å´„Åô„Çã„Å´„ÅØ„Å©„ÅÜ„Åó„Åü„Çâ„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü</p>
<p><code>Functor</code>„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ„ÄÅ
<strong>Èñ¢ÊâãÂâá</strong> (functor laws) „Å®Âëº„Å∞„Çå„ÇãÊ≥ïÂâá„ÇíÈ†ÜÂÆà„Åô„Çã„ÇÇ„ÅÆ„Å®ÊúüÂæÖ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>map identity xs = xs</code></li>
<li><code>map g (map f xs) = map (g &lt;&lt;&lt; f) xs</code></li>
</ul>
<p>ÊúÄÂàù„ÅÆÊ≥ïÂâá„ÅØ<strong>ÊÅíÁ≠âÂ∞ÑÂæã</strong> (identity law) „Åß„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅÊÅíÁ≠âÈñ¢Êï∞ÔºàÂºïÊï∞„ÇíÂ§â„Åà„Åö„Å´Ëøî„ÅôÈñ¢Êï∞Ôºâ„Çí„Åù„ÅÆÊßãÈÄ†„Åæ„ÅßÊåÅ„Å°‰∏ä„Åí„Çã„Å®„ÄÅ
ÂÖÉ„ÅÆÊßãÈÄ†„Çí„Åù„ÅÆ„Åæ„ÅæËøî„Åô„Å®„ÅÑ„ÅÜÊÑèÂë≥„Åß„Åô„ÄÇ
ÊÅíÁ≠âÈñ¢Êï∞„ÅØÂÖ•Âäõ„ÇíÂ§âÊõ¥„Åó„Åæ„Åõ„Çì„Åã„Çâ„ÄÅ„Åì„Çå„ÅØÁêÜ„Å´„Åã„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Á¨¨‰∫å„ÅÆÊ≥ïÂâá„ÅØ<strong>ÂêàÊàêÂæã</strong> (composition law) „Åß„Åô„ÄÇ
ÊßãÈÄ†„Çí„Å≤„Å®„Å§„ÅÆÈñ¢Êï∞„ÅßÂÜô„Åó„Å¶„Åã„Çâ2„Å§„ÇÅ„ÅÆÈñ¢Êï∞„ÅßÂÜô„Åô„ÅÆ„ÅØ„ÄÅ
2„Å§„ÅÆÈñ¢Êï∞„ÅÆÂêàÊàê„ÅßÊßãÈÄ†„ÇíÂÜô„Åô„ÅÆ„Å®Âêå„Åò„Å†„ÄÅ„Å®Ë®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„ÄåÊåÅ„Å°‰∏ä„Åí„Äç„ÅÆ‰∏ÄËà¨ÁöÑ„Å™ÊÑèÂë≥„Åå‰Ωï„Åß„ÅÇ„Çå„ÄÅ
„Éá„Éº„ÇøÊßãÈÄ†„Å´ÂØæ„Åô„ÇãÊåÅ„Å°‰∏ä„ÅíÈñ¢Êï∞„ÅÆÊ≠£„Åó„ÅÑÂÆöÁæ©„ÅØ„Åì„Çå„Çâ„ÅÆÊ≥ïÂâá„Å´Âæì„Å£„Å¶„ÅÑ„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>Ê®ôÊ∫ñ„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆÂ§ö„Åè„Å´„ÅØ„ÄÅ
„Åì„ÅÆ„Çà„ÅÜ„Å™Ê≥ïÂâá„Åå‰ªòÈöè„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰∏ÄËà¨„Å´„ÄÅÂûã„ÇØ„É©„Çπ„Å´‰∏é„Åà„Çâ„Çå„ÅüÊ≥ïÂâá„ÅØ„ÄÅ
Âûã„ÇØ„É©„Çπ„ÅÆÈñ¢Êï∞„Å´ÊßãÈÄ†„Çí‰∏é„Åà„ÄÅ
ÊôÆÈÅçÁöÑ„Å´„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´„Å§„ÅÑ„Å¶Ë™ø„Åπ„Çâ„Çå„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ
ËààÂë≥„ÅÆ„ÅÇ„ÇãË™≠ËÄÖ„ÅØ„ÄÅ„Åô„Åß„Å´Ë¶ã„Å¶„Åç„ÅüÊ®ôÊ∫ñ„ÅÆÂûã„ÇØ„É©„Çπ„Å´Â±û„Åô„ÇãÊ≥ïÂâá„Å´„Å§„ÅÑ„Å¶Ë™ø„Åπ„Å¶„Åø„Å¶„ÇÇ„Çà„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h3 id="„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÂ∞éÂá∫"><a class="header" href="#„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÂ∞éÂá∫">„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÂ∞éÂá∫</a></h3>
<p>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊâã‰ΩúÊ•≠„ÅßÊèè„Åè‰ª£„Çè„Çä„Å´„ÄÅ„Åª„Å®„Çì„Å©„ÅÆ‰ΩúÊ•≠„Çí„Ç≥„É≥„Éë„Ç§„É©„Å´„Åï„Åõ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆ<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">Âûã„ÇØ„É©„ÇπÂ∞éÂá∫ÊâãÂºï„Åç</a>„ÇíË¶ã„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åù„Å°„Çâ„ÅÆÊÉÖÂ†±„Åå‰ª•‰∏ã„ÅÆÊºîÁøí„ÇíËß£„ÅèÊâãÂä©„Åë„Å´„Å™„Çã„Åì„Å®„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="ÊºîÁøí-14"><a class="header" href="#ÊºîÁøí-14">ÊºîÁøí</a></h2>
<p>ÔºàÁ∞°ÂçòÔºâÊ¨°„ÅÆnewtype„ÅØË§áÁ¥†Êï∞„ÇíË°®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Complex
  = Complex
  { real :: Number
  , imaginary :: Number
  }
</code></pre>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>Complex</code>„Å´<code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Âá∫Âäõ„ÅÆÂΩ¢Âºè„ÅØ„ÉÜ„Çπ„Éà„ÅßÊúüÂæÖ„Åï„Çå„ÇãÂΩ¢Âºè„Å®‰∏ÄËá¥„Åï„Åõ„Å¶„Åè„Å†„Åï„ÅÑÔºà‰æãÔºö<code>1.2+3.4i</code>„ÄÅ<code>5.6-7.7i</code>„Å™„Å©Ôºâ„ÄÇ</p>
</li>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí<code>Complex</code>„Å´Â∞éÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö‰ª£„Çè„Çä„Å´„Åì„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊâã‰ΩúÊ•≠„ÅßÊõ∏„ÅÑ„Å¶„ÇÇ„Çà„ÅÑ„Åß„Åô„Åå„ÄÅ„Åó„Å™„Åè„Å¶„ÅÑ„ÅÑ„ÅÆ„Å´„Å™„Åú„Åô„Çã„ÅÆ„Åß„Åô„ÅãÔºü</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Semiring</code>„Ç§„É≥„Çø„É≥„Çπ„Çí<code>Complex</code>„Å´ÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö<a href="https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype"><code>Data.Newtype</code></a>„ÅÆ<code>wrap</code>„Å®<code>over2</code>„Çí‰Ωø„Å£„Å¶„Çà„ÇäÁ∞°ÊΩî„Å™Ëß£Ê≥ï„Çí„Å§„Åè„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„ÇÇ„Åó„Åù„ÅÜ„Åô„Çã„ÅÆ„Åß„Åó„Åü„Çâ„ÄÅ<code>Data.Newtype</code>„Åã„Çâ<code>class Newtype</code>„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åü„Çä„ÄÅ
<code>Newtype</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí<code>Complex</code>„Å´Â∞éÂá∫„Åó„Åü„Çä„Åô„ÇãÂøÖË¶Å„ÇÇÂá∫„Å¶„Åè„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÁ∞°ÂçòÔºâÔºà<code>newtype</code>„Çí‰ªã„Åó„Å¶Ôºâ<code>Ring</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí<code>Complex</code>„Å´Â∞éÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö‰ª£„Çè„Çä„Å´„Åì„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊâã‰ΩúÊ•≠„ÅßÊõ∏„Åè„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„Åå„ÄÅ
„Åù„ÅÜÊâãËªΩ„Å´„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</p>
<p>‰ª•‰∏ã„ÅØÂâçÁ´†„Åã„Çâ„ÅÆ<code>Shape</code>„ÅÆADT„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String
</code></pre>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÔºà<code>Generic</code>„Çí‰ªã„Åó„Å¶Ôºâ<code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí<code>Shape</code>„Å´Â∞éÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Ç≥„Éº„Éâ„ÅÆÈáè„ÅØ„Å©„ÅÆ„Åè„Çâ„ÅÑ„Å´„Å™„Çä„Åæ„Åó„Åü„ÅãÔºü
„Åæ„Åü„ÄÅÂâç„ÅÆÁ´†„ÅÆ<code>showShape</code>„Å®ÊØîËºÉ„Åó„Å¶<code>String</code>„ÅÆÂá∫Âäõ„ÅØ„Å©„ÅÜ„Å™„Çä„Åæ„Åó„Åü„ÅãÔºü
<strong>„Éí„É≥„Éà</strong>Ôºö<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">Âûã„ÇØ„É©„ÇπÂ∞éÂá∫</a>ÊâãÂºï„Åç„ÅÆ<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic"><code>Generic</code>„Åã„ÇâÂ∞éÂá∫„Åô„Çã</a>ÁØÄ„ÇíË¶ã„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="Âûã„ÇØ„É©„ÇπÂà∂Á¥Ñ"><a class="header" href="#Âûã„ÇØ„É©„ÇπÂà∂Á¥Ñ">Âûã„ÇØ„É©„ÇπÂà∂Á¥Ñ</a></h2>
<p>Âûã„ÇØ„É©„Çπ„Çí‰Ωø„ÅÜ„Å®„ÄÅÈñ¢Êï∞„ÅÆÂûã„Å´Âà∂Á¥Ñ„ÇíÂä†„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
‰æã„ÇíÁ§∫„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>Eq</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅßÂÆöÁæ©„Åï„Çå„ÅüÁ≠âÂÄ§ÊÄß„Çí‰Ωø„Å£„Å¶„ÄÅ3„Å§„ÅÆÂÄ§„ÅåÁ≠â„Åó„ÅÑ„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„ÇãÈñ¢Êï∞„ÇíÊõ∏„Åç„Åü„ÅÑ„Å®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">threeAreEqual :: forall a. Eq a =&gt; a -&gt; a -&gt; a -&gt; Boolean
threeAreEqual a1 a2 a3 = a1 == a2 &amp;&amp; a2 == a3
</code></pre>
<p>„Åì„ÅÆÂûãÂÆ£Ë®Ä„ÅØ <code>forall</code>„Çí‰Ωø„Å£„Å¶ÂÆöÁæ©„Åï„Çå„ÅüÈÄöÂ∏∏„ÅÆÂ§öÁõ∏Âûã„ÅÆ„Çà„ÅÜ„Å´„ÇÇË¶ã„Åà„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ‰∫åÈáçÁ∑öÁü¢Âç∞ <code>=&gt;</code>„ÅßÂûã„ÅÆÊÆã„Çä„ÅÆÈÉ®ÂàÜ„Åã„ÇâÂå∫Âàá„Çâ„Çå„Åü„ÄÅÂûã„ÇØ„É©„ÇπÂà∂Á¥Ñ (type class constraint) <code>Eq a</code>„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Ç§„É≥„Éù„Éº„Éà„Åï„Çå„Åü„É¢„Ç∏„É•„Éº„É´„ÅÆ„Å©„Çå„Åã„Å´ <code>a</code>„Å´ÂØæ„Åô„Çã <code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂ≠òÂú®„Åô„Çã„Å™„Çâ„ÄÅ
„Å©„Çì„Å™Âûã <code>a</code>„ÇíÈÅ∏„Çì„Åß„ÇÇ <code>threeAsEqual</code>„ÇíÂëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Çã„ÄÅ„Å®„Åì„ÅÆÂûã„ÅØË®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Âà∂Á¥Ñ„Åï„Çå„ÅüÂûã„Å´„ÅØË§áÊï∞„ÅÆÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂê´„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„Åó„ÄÅ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÂûã„ÅØÂçòÁ¥î„Å™ÂûãÂ§âÊï∞„Å´ÈôêÂÆö„Åï„Çå„Åæ„Åõ„Çì„ÄÇ <code>Ord</code>„Å®
<code>Show</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰Ωø„Å£„Å¶2„Å§„ÅÆÂÄ§„ÇíÊØîËºÉ„Åô„Çã‰æã„ÇíÊ¨°„Å´Á§∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">showCompare :: forall a. Ord a =&gt; Show a =&gt; a -&gt; a -&gt; String
showCompare a1 a2 | a1 &lt; a2 =
  show a1 &lt;&gt; &quot; is less than &quot; &lt;&gt; show a2
showCompare a1 a2 | a1 &gt; a2 =
  show a1 &lt;&gt; &quot; is greater than &quot; &lt;&gt; show a2
showCompare a1 a2 =
  show a1 &lt;&gt; &quot; is equal to &quot; &lt;&gt; show a2
</code></pre>
<p><code>=&gt;</code>„Ç∑„É≥„Éú„É´„ÇíË§áÊï∞Âõû‰Ωø„Å£„Å¶Ë§áÊï∞„ÅÆÂà∂Á¥Ñ„ÇíÊåáÂÆö„Åß„Åç„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Ë§áÊï∞„ÅÆÂºïÊï∞„ÅÆ„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„ÅÆ„Å®ÂêåÊßò„Åß„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ2„Å§„ÅÆË®òÂè∑„ÇíÊ∑∑Âêå„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<ul>
<li><code>a -&gt; b</code>„ÅØ<strong>Âûã</strong><code>a</code>„Åã„Çâ<strong>Âûã</strong><code>b</code>„Å∏„ÅÆÈñ¢Êï∞„ÅÆÂûã„ÇíË°®„Åó„Åæ„Åô„ÄÇ</li>
<li>‰∏ÄÊñπ„Åß„ÄÅ<code>a =&gt; b</code>„ÅØ<strong>Âà∂Á¥Ñ</strong><code>a</code>„ÇíÂûã<code>b</code>„Å´ÈÅ©Áî®„Åó„Åæ„Åô„ÄÇ</li>
</ul>
<p>PureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØ„ÄÅÂûã„ÅÆÊ≥®Èáà„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÄÅÂà∂Á¥Ñ‰ªò„ÅçÂûã„ÇíÊé®Ê∏¨„Åó„Çà„ÅÜ„Å®„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅÈñ¢Êï∞„Å´ÂØæ„Åó„Å¶ÂèØËÉΩ„Å™ÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Å™Âûã„Çí‰ΩøÁî®„Åó„Åü„ÅÑÂ†¥Âêà„Å´‰æøÂà©„Åß„Åô„ÄÇ</p>
<p>PSCi„Åß <code>Semiring</code>„ÅÆ„Çà„ÅÜ„Å™Ê®ôÊ∫ñ„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆ„ÅÑ„Åö„Çå„Åã„Çí‰Ωø„Å£„Å¶„ÄÅ„Åì„ÅÆ„Åì„Å®„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude

&gt; :type \x -&gt; x + x
forall a. Semiring a =&gt; a -&gt; a
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ„Åì„ÅÆÈñ¢Êï∞„Å´„ÅØ<code>Int -&gt; Int</code>„Åæ„Åü„ÅØ<code>Number -&gt; Number</code>„Å®Ê≥®Èáà„Çí‰ªò„Åë„Çã„Åì„Å®„ÅåËÄÉ„Åà„Çâ„Çå„Åæ„Åô„Åå„ÄÅ
ÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Å™Âûã„Åå<code>Semiring</code>„ÅßÂãï‰Ωú„Åô„Çã„Åü„ÇÅ„ÄÅ
PSCi„Åß„ÅØ<code>Int</code>„Å® <code>Number</code>„ÅÆ‰∏°Êñπ„ÅßÈñ¢Êï∞„ÇíÂÆüË°å„Åï„Åõ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ‰æùÂ≠òÈñ¢‰øÇ"><a class="header" href="#„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ‰æùÂ≠òÈñ¢‰øÇ">„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ‰æùÂ≠òÈñ¢‰øÇ</a></h2>
<p>Âà∂Á¥Ñ„Åï„Çå„ÅüÂûã„Çí‰Ωø„ÅÜ„Å®Èñ¢Êï∞„ÅÆÂÆüË£Ö„ÅåÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´‰æùÂ≠ò„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅ
Âûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÂÆüË£Ö„ÅØ‰ªñ„ÅÆÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´‰æùÂ≠ò„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„Å´„Çà„Çä„ÄÅÂûã„Çí‰Ωø„Å£„Å¶„Éó„É≠„Ç∞„É©„É†„ÅÆÂÆüË£Ö„ÇíÊé®Ë´ñ„Åô„Çã„Å®„ÅÑ„ÅÜ„ÄÅ„Éó„É≠„Ç∞„É©„É†Êé®Ë´ñ„ÅÆÂº∑Âäõ„Å™ÂΩ¢Âºè„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Show</code>Âûã„ÇØ„É©„Çπ„Çí‰æã„Å´ËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åù„Çå„Åû„Çå„ÅÆË¶ÅÁ¥†„Çí <code>show</code>„Åô„ÇãÊñπÊ≥ï„Åå„ÅÇ„ÇãÈôê„Çä„ÄÅ
„Åù„ÅÆË¶ÅÁ¥†„ÅÆÈÖçÂàó„Çí <code>show</code>„Åô„ÇãÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance showArray :: Show a =&gt; Show (Array a) where
  ...
</code></pre>
<p>Âûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåË§áÊï∞„ÅÆ‰ªñ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´‰æùÂ≠ò„Åô„ÇãÂ†¥Âêà„ÄÅ
Êã¨Âºß„ÅßÂõ≤„Çì„Åß„Åù„Çå„Çâ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí„Ç≥„É≥„Éû„ÅßÂå∫Âàá„Çä„ÄÅ
„Åù„Çå„Çí<code>=&gt;</code>„Ç∑„É≥„Éú„É´„ÅÆÂ∑¶ÂÅ¥„Å´ÁΩÆ„ÅèÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance showEither :: (Show a, Show b) =&gt; Show (Either a b) where
  ...
</code></pre>
<p>„Åì„Çå„Çâ„ÅÆ2„Å§„ÅÆÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ <code>prelude</code>„É©„Ç§„Éñ„É©„É™„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Éó„É≠„Ç∞„É©„É†„Åå„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„Çã„Å®„ÄÅ
<code>Show</code>„ÅÆÊ≠£„Åó„ÅÑÂûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ <code>show</code>„ÅÆÂºïÊï∞„ÅÆÊé®Ë´ñ„Åï„Çå„ÅüÂûã„Å´Âü∫„Å•„ÅÑ„Å¶ÈÅ∏„Å∞„Çå„Åæ„Åô„ÄÇ
ÈÅ∏Êäû„Åï„Çå„Åü„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÊ≤¢Â±±„ÅÆ„Åù„ÅÜ„Åó„Åü„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆÈñ¢‰øÇ„Å´‰æùÂ≠ò„Åó„Å¶„ÅÑ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åå„ÄÅ
„Åì„ÅÆ„ÅÇ„Åü„Çä„ÅÆË§áÈõë„Åï„Å´ÈñãÁô∫ËÄÖ„ÅåÈñ¢‰∏é„Åô„Çã„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<h2 id="ÊºîÁøí-15"><a class="header" href="#ÊºîÁøí-15">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ‰ª•‰∏ã„ÅÆÂÆ£Ë®Ä„Åß„ÅØÂûã <code>a</code>„ÅÆË¶ÅÁ¥†„ÅÆÁ©∫„Åß„Å™„ÅÑÈÖçÂàó„ÅÆÂûã„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data NonEmpty a = NonEmpty a (Array a)
</code></pre>
<p><code>Eq a</code>„Å®<code>Eq (Array a)</code>„Å∏„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÜçÂà©Áî®„Åó„ÄÅÂûã<code>NonEmpty</code>„Å´<code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<strong>Ë£úË∂≥</strong>Ôºö‰ª£„Çè„Çä„Å´<code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØÂ∞éÂá∫„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Array</code>„Å∏„ÅÆ<code>Semigroup</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÜçÂà©Áî®„Åó„Å¶„ÄÅ<code>NonEmpty</code>„Å∏„ÅÆ<code>Semigroup</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>NonEmpty</code>„Å´<code>Functor</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Ord</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ‰ªò„Åç„ÅÆ„ÅÇ„Çâ„ÇÜ„ÇãÂûã<code>a</code>„Åå‰∏é„Åà„Çâ„Çå„Å¶„ÅÑ„Çã„Å®„Åô„Çã„Å®„ÄÅÊñ∞„Åó„Åè„Åù„Çå‰ª•Â§ñ„ÅÆ„Å©„Çì„Å™ÂÄ§„Çà„Çä„ÇÇÂ§ß„Åç„ÅÑ„ÄåÁÑ°Èôê„ÅÆ„ÄçÂÄ§„Çí‰ªò„ÅëÂä†„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Extended a = Infinite | Finite a 
</code></pre>
<p><code>a</code>„Å∏„ÅÆ<code>Ord</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÜçÂà©Áî®„Åó„Å¶„ÄÅ<code>Extended a</code>„Å´<code>Ord</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>NonEmpty</code>„Å´<code>Foldable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöÈÖçÂàó„Å∏„ÅÆ<code>Foldable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÜçÂà©Áî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâÈ†ÜÂ∫è‰ªò„Åç„Ç≥„É≥„ÉÜ„Éä„ÇíÂÆöÁæ©„Åô„ÇãÔºà„Åù„Åó„Å¶ <code>Foldable</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊåÅ„Å£„Å¶„ÅÑ„ÇãÔºâ„Çà„ÅÜ„Å™ÂûãÊßãÁØâÂ≠ê
<code>f</code>„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åç„ÄÅËøΩÂä†„ÅÆË¶ÅÁ¥†„ÇíÂÖàÈ†≠„Å´Âê´„ÇÅ„Çã„Çà„ÅÜ„Å™Êñ∞„Åü„Å™„Ç≥„É≥„ÉÜ„ÉäÂûã„Çí‰Ωú„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data OneMore f a = OneMore a (f a)
</code></pre>
<p>„Åì„ÅÆ„Ç≥„É≥„ÉÜ„Éä <code>OneMore f</code>„ÇÇ„Åæ„ÅüÈ†ÜÂ∫è„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Åì„Åß„ÄÅÊñ∞„Åó„ÅÑË¶ÅÁ¥†„ÅØ‰ªªÊÑè„ÅÆ <code>f</code>„ÅÆË¶ÅÁ¥†„Çà„Çä„ÇÇÂâç„Å´„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆ <code>OneMore f</code>„ÅÆ <code>Foldable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">instance foldableOneMore :: Foldable f =&gt; Foldable (OneMore f) where
  ...
</code></pre>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>nubEq</code>Èñ¢Êï∞„Çí‰Ωø„ÅÑ„ÄÅ
ÈÖçÂàó„Åã„ÇâÈáçË§á„Åô„Çã<code>Shape</code>„ÇíÂâäÈô§„Åô„Çã
<code>dedupShapes :: Array Shape -&gt; Array Shape</code>Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>dedupShapesFast</code>Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>dedupShapes</code>„Å®„Åª„ÅºÂêå„Åò„Åß„Åô„Åå„ÄÅ„Çà„ÇäÂäπÁéá„ÅÆËâØ„ÅÑ<code>nub</code>Èñ¢Êï∞„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
</li>
</ol>
<h2 id="Â§öÂ§âÊï∞Âûã„ÇØ„É©„Çπ"><a class="header" href="#Â§öÂ§âÊï∞Âûã„ÇØ„É©„Çπ">Â§öÂ§âÊï∞Âûã„ÇØ„É©„Çπ</a></h2>
<p>Âûã„ÇØ„É©„Çπ„ÅØÂøÖ„Åö„Åó„ÇÇ„Å≤„Å®„Å§„ÅÆÂûã„Å†„Åë„ÇíÂûãÂ§âÊï∞„Å®„Åó„Å¶„Å®„Çã„Çè„Åë„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
ÂûãÂ§âÊï∞„Åå„Å≤„Å®„Å§„Å†„Åë„Å™„ÅÆ„ÅåÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Åß„Åô„Åå„ÄÅ
ÂÆüÈöõ„Å´„ÅØÂûã„ÇØ„É©„Çπ„ÅØ<strong>„Çº„É≠ÂÄã‰ª•‰∏ä„ÅÆ</strong>ÂûãÂ§âÊï∞„ÇíÊåÅ„Å§„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØ2„Å§„ÅÆÂûãÂºïÊï∞„ÇíÊåÅ„Å§Âûã„ÇØ„É©„Çπ„ÅÆ‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">module Stream where

import Data.Array as Array
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String

class Stream stream element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }

instance streamArray :: Stream (Array a) a where
  uncons = Array.uncons

instance streamString :: Stream String Char where
  uncons = String.uncons
</code></pre>
<p>„Åì„ÅÆ <code>Stream</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„ÄÅ
Ë¶ÅÁ¥†„ÅÆ„Çπ„Éà„É™„Éº„É†„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÁ§∫„Åô„ÇØ„É©„Çπ <code>Stream</code>„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>uncons</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Çπ„Éà„É™„Éº„É†„ÅÆÂÖàÈ†≠„Åã„ÇâË¶ÅÁ¥†„ÇíÂèñ„ÇäÂá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Stream</code>Âûã„ÇØ„É©„Çπ„ÅØ„ÄÅ
„Çπ„Éà„É™„Éº„É†Ëá™Ë∫´„ÅÆÂûã„Å†„Åë„Åß„Å™„Åè„Åù„ÅÆË¶ÅÁ¥†„ÅÆÂûã„ÇÇÂûãÂ§âÊï∞„Å®„Åó„Å¶ÊåÅ„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„Å´„Çà„Å£„Å¶„ÄÅ„Çπ„Éà„É™„Éº„É†„ÅÆÂûã„ÅåÂêå„Åò„Åß„ÇÇË¶ÅÁ¥†„ÅÆÂûã„Å´„Å§„ÅÑ„Å¶Áï∞„Å™„ÇãÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ2„Å§„ÅÆÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>uncons</code>„Åå„Éë„Çø„Éº„É≥ÁÖßÂêà„ÅßÈÖçÂàó„ÅÆÂÖàÈ†≠„ÅÆË¶ÅÁ¥†„ÇíÂèñ„ÇäÈô§„Åè„Çà„ÅÜ„Å™ÈÖçÂàó„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å®„ÄÅ
ÊñáÂ≠óÂàó„Åã„ÇâÊúÄÂàù„ÅÆÊñáÂ≠ó„ÇíÂèñ„ÇäÈô§„Åè„Çà„ÅÜ„Å™ÊñáÂ≠óÂàó„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„Åô„ÄÇ</p>
<p>‰ªªÊÑè„ÅÆ„Çπ„Éà„É™„Éº„É†‰∏ä„ÅßÂãï‰Ωú„Åô„ÇãÈñ¢Êï∞„ÇíË®òËø∞„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞„ÄÅ„Çπ„Éà„É™„Éº„É†„ÅÆË¶ÅÁ¥†„Å´Âü∫„Å•„ÅÑ„Å¶ <code>Monoid</code>„Å´ÁµêÊûú„ÇíÁ¥ØÁ©ç„Åô„ÇãÈñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Prelude
import Data.Monoid (class Monoid, mempty)

foldStream :: forall l e m. Stream l e =&gt; Monoid m =&gt; (e -&gt; m) -&gt; l -&gt; m
foldStream f list =
  case uncons list of
    Nothing -&gt; mempty
    Just cons -&gt; f cons.head &lt;&gt; foldStream f cons.tail
</code></pre>
<p>PSCi„Åß‰Ωø„Å£„Å¶„ÄÅÁï∞„Å™„Çã <code>Stream</code>„ÅÆÂûã„ÇÑÁï∞„Å™„Çã <code>Monoid</code>„ÅÆÂûã„Å´„Å§„ÅÑ„Å¶ <code>foldStream</code>„ÇíÂëº„Å≥Âá∫„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="Èñ¢Êï∞ÂæìÂ±ûÊÄß"><a class="header" href="#Èñ¢Êï∞ÂæìÂ±ûÊÄß">Èñ¢Êï∞ÂæìÂ±ûÊÄß</a></h2>
<p>Â§öÂ§âÊï∞Âûã„ÇØ„É©„Çπ„ÅØÈùûÂ∏∏„Å´‰æøÂà©„Åß„Åô„Åå„ÄÅ
Ê∑∑‰π±„Åó„ÇÑ„Åô„ÅÑÂûã„ÇÑÂûãÊé®Ë´ñ„ÅÆÂïèÈ°å„Å´„ÇÇ„Å§„Å™„Åå„Çä„Åæ„Åô„ÄÇ
Á∞°Âçò„Å™‰æã„Å®„Åó„Å¶„ÄÅ‰∏äË®ò„ÅÆ <code>Stream</code>„ÇØ„É©„Çπ„Çí‰Ωø„Å£„Å¶Ê±éÁî®ÁöÑ„Å™<code>tail</code>Èñ¢Êï∞„Çí„Çπ„Éà„É™„Éº„É†„Å´Êõ∏„Åè„Åì„Å®„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">genericTail xs = map _.tail (uncons xs)
</code></pre>
<p>„Åì„Çå„ÅØ„ÇÑ„ÇÑË§áÈõë„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂá∫Âäõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">The inferred type

  forall stream a. Stream stream a =&gt; stream -&gt; Maybe stream

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>„Ç®„É©„Éº„ÅØ„ÄÅ <code>genericTail</code>Èñ¢Êï∞„Åå <code>Stream</code>Âûã„ÇØ„É©„Çπ„ÅÆÂÆöÁæ©„ÅßË®ÄÂèä„Åï„Çå„Åü <code>element</code>Âûã„Çí‰ΩøÁî®„Åó„Å™„ÅÑ„ÅÆ„Åß„ÄÅ
„Åù„ÅÆÂûã„ÅØÊú™Ëß£Ê±∫„ÅÆ„Åæ„Åæ„Åß„ÅÇ„Çã„Åì„Å®„ÇíÊåá„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åï„Çâ„Å´„ÄÅÁâπÂÆö„ÅÆÂûã„ÅÆ„Çπ„Éà„É™„Éº„É†„Å´ <code>genericTail</code>„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; map _.tail (uncons &quot;testing&quot;)

The inferred type

  forall a. Stream String a =&gt; Maybe String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„Åå <code>streamString</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÈÅ∏Êäû„Åô„Çã„Åì„Å®„ÇíÊúüÂæÖ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÁµêÂ±Ä„ÅÆ„Å®„Åì„Çç„ÄÅ <code>String</code>„ÅØ <code>Char</code>„ÅÆ„Çπ„Éà„É™„Éº„É†„Åß„ÅÇ„Çä„ÄÅ‰ªñ„ÅÆÂûã„ÅÆ„Çπ„Éà„É™„Éº„É†„Åß„ÅÇ„Å£„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>„Ç≥„É≥„Éë„Ç§„É©„ÅØËá™ÂãïÁöÑ„Å´„Åù„ÅÆÊé®Ë´ñ„ÇíË°å„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åö„ÄÅ
<code>streamString</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂâ≤„ÇäÂΩì„Å¶„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„ÄÇ
„Åó„Åã„Åó„ÄÅÂûã„ÇØ„É©„ÇπÂÆöÁæ©„Å´„Éí„É≥„Éà„ÇíËøΩÂä†„Åô„Çã„Å®„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÇíÂä©„Åë„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Stream stream element | stream -&gt; element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ <code>stream -&gt; element</code>„ÅØ<strong>Èñ¢Êï∞ÂæìÂ±ûÊÄß</strong> (functional dependency) „Å®Âëº„Å∞„Çå„Åæ„Åô„ÄÇ
Èñ¢Êï∞ÂæìÂ±ûÊÄß„ÅØ„ÄÅÂ§öÂ§âÊï∞Âûã„ÇØ„É©„Çπ„ÅÆÂûãÂºïÊï∞Èñì„ÅÆÈñ¢Êï∞Èñ¢‰øÇ„ÇíÂÆ£Ë®Ä„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÅØ„ÄÅ„Çπ„Éà„É™„Éº„É†Âûã„Åã„ÇâÔºà‰∏ÄÊÑè„ÅÆÔºâË¶ÅÁ¥†Âûã„Å∏„ÅÆÈñ¢Êï∞„Åå„ÅÇ„Çã„Åì„Å®„Çí„Ç≥„É≥„Éë„Ç§„É©„Å´‰ºù„Åà„Çã„ÅÆ„Åß„ÄÅ
„Ç≥„É≥„Éë„Ç§„É©„Åå„Çπ„Éà„É™„Éº„É†Âûã„ÇíÁü•„Å£„Å¶„ÅÑ„Çå„Å∞Ë¶ÅÁ¥†„ÅÆÂûã„ÇíÂâ≤„ÇäÂΩì„Å¶„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Éí„É≥„Éà„ÅØ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„Åå‰∏äË®ò„ÅÆÊ±éÁî®ÁöÑ„Å™Â∞æÈ∞≠Èñ¢Êï∞„ÅÆÊ≠£„Åó„ÅÑÂûã„ÇíÊé®Ë´ñ„Åô„Çã„ÅÆ„Å´ÂçÅÂàÜ„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :type genericTail
forall stream element. Stream stream element =&gt; stream -&gt; Maybe stream

&gt; genericTail &quot;testing&quot;
(Just &quot;esting&quot;)
</code></pre>
<p>Â§öÁ®Æ„ÅÆÂûã„ÅÆ„ÇØ„É©„Çπ„Çí‰ΩøÁî®„Åó„Å¶‰Ωï„Çâ„Åã„ÅÆAPI„ÇíË®≠Ë®à„Åô„ÇãÂ†¥Âêà„ÄÅÈñ¢Êï∞ÂæìÂ±ûÊÄß„ÅØÈùûÂ∏∏„Å´ÊúâÁî®„Åß„Åô„ÄÇ</p>
<h2 id="ÂûãÂ§âÊï∞„ÅÆ„Å™„ÅÑÂûã„ÇØ„É©„Çπ"><a class="header" href="#ÂûãÂ§âÊï∞„ÅÆ„Å™„ÅÑÂûã„ÇØ„É©„Çπ">ÂûãÂ§âÊï∞„ÅÆ„Å™„ÅÑÂûã„ÇØ„É©„Çπ</a></h2>
<p>„Çº„É≠ÂÄã„ÅÆÂûãÂ§âÊï∞„ÇíÊåÅ„Å§Âûã„ÇØ„É©„Çπ„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„ÅôÔºÅ
„Åì„Çå„Çâ„ÅØÈñ¢Êï∞„Å´ÂØæ„Åô„Çã„Ç≥„É≥„Éë„Ç§„É´ÊôÇ„ÅÆ„Ç¢„Çµ„Éº„Ç∑„Éß„É≥„Å´ÂØæÂøú„Åó„Å¶„Åä„Çä„ÄÅ
Âûã„Ç∑„Çπ„ÉÜ„É†ÂÜÖ„ÅÆ„Ç≥„Éº„Éâ„ÅÆÂ§ßÂüüÁöÑ„Å™ÊÄßË≥™„ÇíËøΩË∑°„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÈáçË¶Å„Å™‰∏Ä‰æã„Å®„Åó„Å¶„ÄÅÂâç„Å´ÈÉ®ÂàÜÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅäË©±„Åó„Åó„ÅüÈöõ„Å´Ë¶ã„Åü<code>Partial</code>„ÇØ„É©„Çπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
<code>Data.Array.Partial</code>„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÈñ¢Êï∞<code>head</code>„Å®<code>tail</code>„Çí‰æã„Å´Âèñ„Çä„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÈÖçÂàó„ÅÆÂÖàÈ†≠„Å®Â∞æÈ∞≠„Çí<code>Maybe</code>„Å´ÂåÖ„ÇÄ„Åì„Å®„Å™„ÅèÂèñÂæó„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Å™„ÅÆ„ÅßÈÖçÂàó„ÅåÁ©∫„ÅÆ„Å®„Åç„Å´Â§±Êïó„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">head :: forall a. Partial =&gt; Array a -&gt; a

tail :: forall a. Partial =&gt; Array a -&gt; Array a
</code></pre>
<p><code>Partial</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ <code>Partial</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÜ„Åô„Çã„Å®ÁõÆÁöÑ„ÇíÈÅîÊàê„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Åæ„Åæ„ÅÆÂÆöÁæ©„Åß„ÅØ <code>head</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å®Âûã„Ç®„É©„Éº„Å´„Å™„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; head [1, 2, 3]

No type class instance was found for

  Prim.Partial
</code></pre>
<p>‰ª£„Çè„Çä„Å´„ÄÅ„Åì„Çå„Çâ„ÅÆÈÉ®ÂàÜÈñ¢Êï∞„ÇíÂà©Áî®„Åô„Çã„Åô„Åπ„Å¶„ÅÆÈñ¢Êï∞„Åß <code>Partial</code>Âà∂Á¥Ñ„ÇíÂÜçÁô∫Ë°å„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">secondElement :: forall a. Partial =&gt; Array a -&gt; a
secondElement xs = head (tail xs)
</code></pre>
<p>ÂâçÁ´†„ÅßË¶ã„Åü <code>unsafePartial</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„ÄÅ
ÈÉ®ÂàÜÈñ¢Êï∞„ÇíÈÄöÂ∏∏„ÅÆÈñ¢Êï∞ÔºàunsafelyÔºâ„Å®„Åó„Å¶Êâ±„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ <code>Partial.Unsafe</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">unsafePartial :: forall a. (Partial =&gt; a) -&gt; a
</code></pre>
<p><code>Partial</code>Âà∂Á¥Ñ„ÅØÈñ¢Êï∞„ÅÆÁü¢Âç∞„ÅÆÂ∑¶ÂÅ¥„ÅÆÊã¨Âºß„ÅÆ‰∏≠„Å´Áèæ„Çå„Åæ„Åô„Åå„ÄÅ
Â§ñÂÅ¥„ÅÆ <code>forall</code>„Åß„ÅØÁèæ„Çå„Åæ„Åõ„Çì„ÄÇ
„Å§„Åæ„Çä„ÄÅ <code>unsafePartial</code>„ÅØÈÉ®ÂàÜÁöÑ„Å™ÂÄ§„Åã„ÇâÈÄöÂ∏∏„ÅÆÂÄ§„Å∏„ÅÆÈñ¢Êï∞„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; unsafePartial head [1, 2, 3]
1

&gt; unsafePartial secondElement [1, 2, 3]
2
</code></pre>
<h2 id="‰∏ä‰Ωç„ÇØ„É©„Çπ"><a class="header" href="#‰∏ä‰Ωç„ÇØ„É©„Çπ">‰∏ä‰Ωç„ÇØ„É©„Çπ</a></h2>
<p>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂà•„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´‰æùÂ≠ò„Åï„Åõ„Çã„Åì„Å®„Å´„Çà„Å£„Å¶Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„ÇπÈñì„ÅÆÈñ¢‰øÇ„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅ
„ÅÑ„Çè„ÇÜ„Çã<strong>‰∏ä‰Ωç„ÇØ„É©„Çπ</strong> (superclass) „Çí‰Ωø„Å£„Å¶Âûã„ÇØ„É©„ÇπÈñì„ÅÆÈñ¢‰øÇ„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„ÅÇ„Çã„ÇØ„É©„Çπ„ÅÆ„Å©„Çì„Å™„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇÇ„ÄÅ
Âà•„ÅÆ„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Å®„Åç„ÄÅ
ÂæåËÄÖ„ÅÆÂûã„ÇØ„É©„Çπ„ÅØÂâçËÄÖ„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆ‰∏ä‰Ωç„ÇØ„É©„Çπ„Åß„ÅÇ„Çã„Å®„ÅÑ„ÅÑ„ÄÅ
„ÇØ„É©„ÇπÂÆöÁæ©„ÅßÈÄÜÂêë„Åç„ÅÆÂ§™„ÅÑÁü¢Âç∞„Çí‰Ωø„Å£„Å¶‰∏ä‰Ωç„ÇØ„É©„ÇπÈñ¢‰øÇ„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åô„Åß„Å´‰∏ä‰Ωç„ÇØ„É©„Çπ„ÅÆÈñ¢‰øÇ„ÅÆ‰æã„ÇíË¶ãÊéõ„Åë„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Eq</code>„ÇØ„É©„Çπ„ÅØ <code>Ord</code>„ÅÆ‰∏ä‰Ωç„ÇØ„É©„Çπ„Åß„Åô„Åó„ÄÅ<code>Semigroup</code>„ÇØ„É©„Çπ„ÅØ<code>Monoid</code>„ÅÆ‰∏ä‰Ωç„ÇØ„É©„Çπ„Åß„Åô„ÄÇ
<code>Ord</code>„ÇØ„É©„Çπ„ÅÆ„Åô„Åπ„Å¶„ÅÆÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´„Å§„ÅÑ„Å¶„ÄÅ
„Åù„ÅÆÂêå„ÅòÂûã„Å´ÂØæÂøú„Åô„Çã <code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂ≠òÂú®„Åó„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
<code>compare</code>Èñ¢Êï∞„Åå2„Å§„ÅÆÂÄ§„ÅåÊØîËºÉ„Åß„Åç„Å™„ÅÑ„Å®Â†±Âëä„Åó„ÅüÊôÇ„ÅØ„ÄÅ
„Åù„Çå„Çâ„ÅåÂÆü„ÅØÂêåÂÄ§„Åß„ÅÇ„Çã„Åã„Å©„ÅÜ„Åã„ÇíÊ±∫ÂÆö„Åô„Çã„Åü„ÇÅ„Å´ <code>Eq</code>„ÇØ„É©„Çπ„Çí‰Ωø„ÅÑ„Åü„Åè„Å™„Çã„Åì„Å®„ÅåÂ§ö„ÅÑ„Åß„Åó„Çá„ÅÜ„Åã„Çâ„ÄÅ
„Åì„Çå„ÅØÁêÜ„Å´„Åã„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰∏ÄËà¨„Å´„ÄÅ‰∏ã‰Ωç„ÇØ„É©„Çπ„ÅÆÊ≥ïÂâá„Åå‰∏ä‰Ωç„ÇØ„É©„Çπ„ÅÆ„É°„É≥„Éê„Å´Ë®ÄÂèä„Åó„Å¶„ÅÑ„Çã„Å®„Åç„ÄÅ
‰∏ä‰Ωç„ÇØ„É©„ÇπÈñ¢‰øÇ„ÇíÂÆöÁæ©„Åô„Çã„ÅÆ„ÅØÁêÜ„Å´„Åã„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞„ÄÅ <code>Ord</code>„Å® <code>Eq</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„Å©„Çì„Å™ÁµÑ„Å´„Å§„ÅÑ„Å¶„ÇÇ„ÄÅ
„ÇÇ„Åó„Åµ„Åü„Å§„ÅÆÂÄ§„Åå <code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„ÇÇ„Å®„ÅßÂêåÂÄ§„Åß„ÅÇ„Çã„Å™„Çâ„ÄÅ
<code>compare</code>Èñ¢Êï∞„ÅØ <code>EQ</code>„ÇíËøî„Åô„ÅØ„Åö„Å†„Å®„Åø„Å™„Åô„ÅÆ„ÅØÂ¶•ÂΩì„Åß„Åô„ÄÇ
Ë®Ä„ÅÑÊèõ„Åà„Çå„Å∞„ÄÅ„Åæ„Åï„Åó„Åè<code>a == b</code>„Å™„Çâ„Å∞ <code>compare a b == EQ</code>„Åß„Åô„ÄÇ
Ê≥ïÂâá„ÅÆÈöéÂ±§‰∏ä„ÅÆ„Åì„ÅÆÈñ¢‰øÇ„ÅØ„ÄÅ <code>Eq</code>„Å® <code>Ord</code>„ÅÆÈñì„ÅÆ‰∏ä‰Ωç„ÇØ„É©„ÇπÈñ¢‰øÇ„ÇíË™¨Êòé„Åó„Åæ„Åô„ÄÇ</p>
<p>‰∏ä‰Ωç„ÇØ„É©„ÇπÈñ¢‰øÇ„ÇíÂÆöÁæ©„Åô„ÇãÂà•„ÅÆÁêÜÁî±„Å®„Å™„Çã„ÅÆ„ÅØ„ÄÅ
„Åì„ÅÆ2„Å§„ÅÆ„ÇØ„É©„Çπ„ÅÆÈñì„Å´Êòé„Çâ„Åã„Å´ &quot;is-a&quot; „ÅÆÈñ¢‰øÇ„Åå„ÅÇ„Çã„Åì„Å®„Åß„Åô„ÄÇ
‰∏ã‰Ωç„ÇØ„É©„Çπ„ÅÆ„Åô„Åπ„Å¶„ÅÆ„É°„É≥„Éê„ÅØ„ÄÅ‰∏ä‰Ωç„ÇØ„É©„Çπ„ÅÆ„É°„É≥„Éê„Åß„ÇÇ„ÅÇ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-16"><a class="header" href="#ÊºîÁøí-16">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÊôÆÈÄöÔºâÈÉ®ÂàÜÈñ¢Êï∞<code>unsafeMaximum :: Partial =&gt; Array Int -&gt; Int</code>„ÇíÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÊï¥Êï∞„ÅÆÁ©∫„Åß„Å™„ÅÑÈÖçÂàó„ÅÆÊúÄÂ§ßÂÄ§„ÇíÊ±Ç„ÇÅ„Åæ„Åô„ÄÇ
<code>unsafePartial</code>„Çí‰Ωø„Å£„Å¶PSCi„ÅßÈñ¢Êï∞„Çí„ÉÜ„Çπ„Éà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>Data.Foldable</code>„ÅÆ <code>maximum</code>Èñ¢Êï∞„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÊ¨°„ÅÆ <code>Action</code>„ÇØ„É©„Çπ„ÅØ„ÄÅ„ÅÇ„ÇãÂûã„ÅÆÂà•„ÅÆÂûã„Åß„ÅÆÂãï‰Ωú (action) „ÇíÂÆöÁæ©„Åô„Çã„ÄÅÂ§öÂ§âÊï∞Âûã„ÇØ„É©„Çπ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Monoid m &lt;= Action m a where
  act :: m -&gt; a -&gt; a
</code></pre>
<p><strong>Âãï‰Ωú</strong>„ÅØ„Å©„ÅÆ„Çà„ÅÜ„Å´„É¢„Éé„Ç§„Éâ„Å™ÂÄ§„Çí‰Ωø„Å£„Å¶‰ªñ„ÅÆÂûã„ÅÆÂÄ§„ÇíÂ§âÊõ¥„Åô„ÇãÊñπÊ≥ï„ÇíÊ±∫„ÇÅ„Çâ„Çå„Çã„ÅÆ„Åã„ÇíË®òËø∞„Åô„ÇãÈñ¢Êï∞„Åß„Åô„ÄÇ
<code>Action</code>Âûã„ÇØ„É©„Çπ„Å´„ÅØ2„Å§„ÅÆÊ≥ïÂâá„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>act mempty a = a</code></li>
<li><code>act (m1 &lt;&gt; m2) a = act m1 (act m2 a)</code></li>
</ul>
<p>Á©∫„ÅÆÂãï‰Ωú„ÇíÊèê‰æõ„Åó„Å¶„ÇÇ‰Ωï„ÇÇËµ∑„Åì„Çä„Åæ„Åõ„Çì„ÄÇ
„Åù„Åó„Å¶2„Å§„ÅÆÂãï‰Ωú„ÇíÈÄ£Á∂ö„ÅßÈÅ©Áî®„Åô„Çã„Åì„Å®„ÅØÁµêÂêà„Åó„ÅüÂãï‰Ωú„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Å®Âêå„Åò„Åß„Åô„ÄÇ
„Å§„Åæ„Çä„ÄÅÂãï‰Ωú„ÅØ<code>Monoid</code>„ÇØ„É©„Çπ„ÅßÂÆöÁæ©„Åï„Çå„ÇãÊìç‰Ωú„Å´ÂÄ£„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅËá™ÁÑ∂Êï∞„ÅØ‰πóÁÆó„ÅÆ„ÇÇ„Å®„Åß„É¢„Éé„Ç§„Éâ„ÇíÂΩ¢Êàê„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Multiply = Multiply Int

instance semigroupMultiply :: Semigroup Multiply where
  append (Multiply n) (Multiply m) = Multiply (n * m)

instance monoidMultiply :: Monoid Multiply where
  mempty = Multiply 1
</code></pre>
<p>„Åì„ÅÆÂãï‰Ωú„ÇíÂÆüË£Ö„Åô„Çã„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">instance actionMultiplyInt :: Action Multiply Int where
  ...
</code></pre>
<p>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå‰∏ä„ÅßÊåô„Åí„ÅüÊ≥ïÂâá„ÇíË¶ã„Åü„Åï„Å™„Åè„Å¶„ÅØ„Å™„Çâ„Å™„ÅÑ„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâÂÆü„ÅØ<code>Action Multiply Int</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆüË£Ö„Åô„Çã„Å´„ÅØË§áÊï∞„ÅÆÊñπÊ≥ï„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Å©„Çå„Å†„ÅëÊÄù„ÅÑ‰ªò„Åç„Åæ„Åô„ÅãÔºü
PureScript„ÅØÂêå„Åò„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆË§áÊï∞„ÅÆÂÆüË£Ö„ÇíË®±„Åï„Å™„ÅÑ„Åü„ÇÅ„ÄÅ
ÂÖÉ„ÅÆÂÆüË£Ö„ÇíÁΩÆ„ÅçÊèõ„Åà„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„ÉÜ„Çπ„Éà„Åß„ÅØ4„Å§„ÅÆÂÆüË£Ö„ÇíÊäº„Åï„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÂÖ•Âäõ„ÅÆÊñáÂ≠óÂàó„Çí‰ΩïÂõû„ÅãÁπ∞„ÇäËøî„Åô<code>Action</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">instance actionMultiplyString :: Action Multiply String where
  ...
</code></pre>
<p><strong>„Éí„É≥„Éà</strong>ÔºöPursuit„Åß„Ç∑„Ç∞„Éç„ÉÅ„É£„Åå<a href="https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String"><code>String -&gt; Int -&gt; String</code></a>„ÅÆ„ÅäÂä©„ÅëÈñ¢Êï∞„ÇíÊ§úÁ¥¢„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Å™„Åä<code>String</code>„ÅØÔºà<code>Monoid</code>„ÅÆ„Çà„ÅÜ„Å™Ôºâ„Çà„ÇäÊ±éÁî®ÁöÑ„Å™Âûã„Å®„Åó„Å¶Áèæ„Çå„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ‰∏ä„Å´Êåô„Åí„ÅüÊ≥ïÂâá„ÇíÊ∫Ä„Åü„Åô„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ„Ç§„É≥„Çπ„Çø„É≥„Çπ <code>Action m a =&gt; Action m (Array a)</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„Åì„Åß„ÄÅ ÈÖçÂàó‰∏ä„ÅÆÂãï‰Ωú„ÅØ„Åù„Çå„Åû„Çå„ÅÆË¶ÅÁ¥†„ÇíÁã¨Á´ã„Å´ÂÆüË°å„Åô„Çã„ÇÇ„ÅÆ„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ‰ª•‰∏ã„ÅÆnewtype„Åå‰∏é„Åà„Çâ„Åà„Å¶„ÅÑ„Çã„Å®„Åç„ÄÅ
<code>Action m (Self m)</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Åì„Åß„É¢„Éé„Ç§„Éâ<code>m</code>„ÅØ<code>append</code>„ÇíÁî®„ÅÑ„Å¶Ëá™Âäõ„ÅßÂãï‰Ωú„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Self m = Self m
</code></pre>
<p><strong>Ë£úË∂≥</strong>Ôºö„ÉÜ„Çπ„Éà„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„Åß„ÅØ<code>Self</code>„Å®<code>Multiply</code>Âûã„Å´<code>Show</code>„Å®<code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ
Êâã‰ΩúÊ•≠„Åß„Åì„Çå„Çâ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„ÇÇ„Çà„ÅÑ„Åß„Åô„Åó„ÄÅ
<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype"><code>derive newtype instance</code></a>„Å®Êõ∏„Åè„Å†„Åë„Åß„Ç≥„É≥„Éë„Ç§„É©„Å´Âèñ„Çä‰ªïÂàá„Å£„Å¶„ÇÇ„Çâ„ÅÜ„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâÂ§öÂ§âÊï∞Âûã„ÅÆ„ÇØ„É©„Çπ <code>Action</code>„ÅÆÂºïÊï∞„ÅØ„ÄÅ‰Ωï„Çâ„Åã„ÅÆÈñ¢Êï∞ÂæìÂ±ûÊÄß„Å´„Çà„Å£„Å¶Èñ¢ÈÄ£„Å•„Åë„Çâ„Çå„Çã„Åπ„Åç„Åß„Åô„Åã„ÄÇ
„Å™„Åú„Åù„ÅÜ„Åô„Åπ„Åç„ÄÅ„ÅÇ„Çã„ÅÑ„ÅØ„Åù„ÅÜ„Åô„Åπ„Åç„Åß„Å™„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÅØ„ÉÜ„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
</ol>
<h2 id="„Éè„ÉÉ„Ç∑„É•„ÅÆÂûã„ÇØ„É©„Çπ"><a class="header" href="#„Éè„ÉÉ„Ç∑„É•„ÅÆÂûã„ÇØ„É©„Çπ">„Éè„ÉÉ„Ç∑„É•„ÅÆÂûã„ÇØ„É©„Çπ</a></h2>
<p>„Åì„ÅÆÊúÄÂæå„ÅÆÁØÄ„Åß„ÅØ„ÄÅÁ´†„ÅÆÊÆã„Çä„Çí‰Ωø„Å£„Å¶„Éá„Éº„ÇøÊßãÈÄ†„Çí„Éè„ÉÉ„Ç∑„É•„Åô„Çã„É©„Ç§„Éñ„É©„É™„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅÆÁõÆÁöÑ„ÅØË™¨Êòé„Å†„Åë„Åß„ÅÇ„Çä„ÄÅ
Â†ÖÁâ¢„Å™„Éè„ÉÉ„Ç∑„É≥„Ç∞„ÅÆ‰ªïÁµÑ„Åø„ÅÆÊèê‰æõ„ÇíÁõÆÁöÑ„Å®„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„Éè„ÉÉ„Ç∑„É•Èñ¢Êï∞„Å´ÊúüÂæÖ„Åï„Çå„ÇãÊÄßË≥™„Å®„ÅØ„Å©„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Åß„Åó„Çá„ÅÜ„ÅãÔºü</p>
<ul>
<li>„Éè„ÉÉ„Ç∑„É•Èñ¢Êï∞„ÅØÊ±∫ÂÆöÁöÑ„Åß„Å™„Åè„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ„Å§„Åæ„Çä„ÄÅÂêå„ÅòÂÄ§„Å´„ÅØÂêå„Åò„Éè„ÉÉ„Ç∑„É•
ÂÄ§„ÇíÂØæÂøú„Åï„Åõ„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</li>
<li>„Éè„ÉÉ„Ç∑„É•Èñ¢Êï∞„ÅØ„ÅÑ„Çç„ÅÑ„Çç„Å™„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÅÆÈõÜÂêà„ÅßÁµêÊûú„Åå‰∏ÄÊßò„Å´ÂàÜÂ∏É„Åó„Å™„Åë„Çå„Å∞„Å™
„Çä„Åæ„Åõ„Çì„ÄÇ</li>
</ul>
<p>ÊúÄÂàù„ÅÆÊÄßË≥™„ÅØ„Åæ„Åï„Å´Âûã„ÇØ„É©„Çπ„ÅÆÊ≥ïÂâá„ÅÆ„Çà„ÅÜ„Å´Ë¶ã„Åà„Çã‰∏ÄÊñπ„Åß„ÄÅ
2Áï™ÁõÆ„ÅÆÊÄßË≥™„ÅØ„Çà„Çä„Åè„Å†„Åë„ÅüË¶èÁ¥Ñ„ÅÆÊù°È†Ö„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Åß„ÄÅ
PureScript„ÅÆÂûã„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„Å£„Å¶Á¢∫ÂÆü„Å´Âº∑Âà∂„Åß„Åç„Çã„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Åß„ÅØ„Å™„Åï„Åù„ÅÜ„Åß„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åì„Çå„ÅØÂûã„ÇØ„É©„Çπ„Å´„Å§„ÅÑ„Å¶Ê¨°„ÅÆ„Çà„ÅÜ„Å™Áõ¥ÊÑüÁöÑÁêÜËß£„Çí‰∏é„Åà„Çã„ÅØ„Åö„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype HashCode = HashCode Int

instance hashCodeEq :: Eq HashCode where
  eq (HashCode a) (HashCode b) = a == b

hashCode :: Int -&gt; HashCode
hashCode h = HashCode (h `mod` 65535)

class Eq a &lt;= Hashable a where
  hash :: a -&gt; HashCode
</code></pre>
<p>„Åì„Çå„Å´„ÄÅ <code>a == b</code>„Å™„Çâ„Å∞ <code>hash a == hash b</code>„ÇíÁ§∫ÂîÜ„Åô„Çã„Å®„ÅÑ„ÅÜÈñ¢‰øÇÊÄß„ÅÆÊ≥ïÂâá„Åå‰ªòÈöè„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁØÄ„ÅÆÊÆã„Çä„ÅÆÈÉ®ÂàÜ„ÇíË≤ª„ÇÑ„Åó„Å¶„ÄÅ
<code>Hashable</code>Âûã„ÇØ„É©„Çπ„Å´Èñ¢ÈÄ£‰ªò„Åë„Çâ„Çå„Å¶„ÅÑ„Çã„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å®Èñ¢Êï∞„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíÊßãÁØâ„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>Ê±∫ÂÆöÁöÑ„Å™ÊñπÊ≥ï„Åß„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÁµêÂêà„Åô„ÇãÊñπÊ≥ï„ÅåÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">combineHashes :: HashCode -&gt; HashCode -&gt; HashCode
combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)
</code></pre>
<p><code>combineHashes</code>Èñ¢Êï∞„ÅØ2„Å§„ÅÆ„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÊ∑∑„Åú„Å¶ÁµêÊûú„Çí0-65535„ÅÆÈñì„Å´ÂàÜÂ∏É„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØ„ÄÅÂÖ•Âäõ„ÅÆÁ®ÆÈ°û„ÇíÂà∂Èôê„Åô„Çã <code>Hashable</code>Âà∂Á¥Ñ„Çí‰Ωø„ÅÜÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Éè„ÉÉ„Ç∑„É•Èñ¢Êï∞„ÇíÂøÖË¶Å„Å®„Åô„Çã„Çà„Åè„ÅÇ„ÇãÁõÆÁöÑ„Å®„Åó„Å¶„ÅØ„ÄÅ
2„Å§„ÅÆÂÄ§„ÅåÂêå„Åò„Éè„ÉÉ„Ç∑„É•ÂÄ§„Å´„Éè„ÉÉ„Ç∑„É•„Åï„Çå„Çã„Åã„Å©„ÅÜ„Åã„ÇíÊ±∫ÂÆö„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ
<code>hashEqual</code>Èñ¢‰øÇ„ÅØ„Åù„ÅÆ„Çà„ÅÜ„Å™Ê©üËÉΩ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">hashEqual :: forall a. Hashable a =&gt; a -&gt; a -&gt; Boolean
hashEqual = eq `on` hash
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„Éè„ÉÉ„Ç∑„É•„Ç≥„Éº„Éâ„ÅÆÁ≠âÂÄ§ÊÄß„ÇíÂà©Áî®„Åó„Åü„Éè„ÉÉ„Ç∑„É•ÂêåÂÄ§ÊÄß„ÇíÂÆöÁæ©„Åô„Çã„Åü„ÇÅ„Å´
<code>Data.Function</code>„ÅÆ <code>on</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
„Åì„Çå„ÅØ„Éè„ÉÉ„Ç∑„É•ÂêåÂÄ§ÊÄß„ÅÆÂÆ£Ë®ÄÁöÑ„Å™ÂÆöÁæ©„Å®„Åó„Å¶Ë™≠„ÇÅ„Çã„ÅØ„Åö„Åß„Åô„ÄÇ
„Å§„Åæ„Çä„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÂÄ§„Åå <code>hash</code>Èñ¢Êï∞„Å´Ê∏°„Åï„Çå„Åü„ÅÇ„Å®„Åß2„Å§„ÅÆÂÄ§„ÅåÁ≠â„Åó„ÅÑ„Å™„Çâ„ÄÅ
„Åù„Çå„Çâ„ÅÆÂÄ§„ÅØ„Äå„Éè„ÉÉ„Ç∑„É•ÂêåÂÄ§„Äç„Åß„Åô„ÄÇ</p>
<p>ÂéüÂßãÂûã„ÅÆ <code>Hashable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí„ÅÑ„Åè„Å§„ÅãÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åæ„Åö„ÅØÊï¥Êï∞„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„Åô„ÄÇ
<code>HashCode</code>„ÅØÂÆüÈöõ„Å´„ÅØÂçò„Å™„Çã„É©„ÉÉ„Éó„Åï„Çå„ÅüÊï¥Êï∞„Å™„ÅÆ„Åß„ÄÅ„Åì„Çå„ÅØÁ∞°Âçò„Åß„Åô„ÄÇ
<code>hashCode</code>„Éò„É´„Éë„ÉºÈñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance hashInt :: Hashable Int where
  hash = hashCode
</code></pre>
<p>„Éë„Çø„Éº„É≥ÁÖßÂêà„Çí‰Ωø„ÅÜ„Å®„ÄÅ<code>Boolean</code>ÂÄ§„ÅÆÂçòÁ¥î„Å™„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance hashBoolean :: Hashable Boolean where
  hash false = hashCode 0
  hash true  = hashCode 1
</code></pre>
<p>Êï¥Êï∞„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅØ„ÄÅ
<code>Data.Char</code>„ÅÆ <code>toCharCode</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Å®<code>Char</code>„Çí„Éè„ÉÉ„Ç∑„É•„Åô„Çã„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance hashChar :: Hashable Char where
  hash = hash &lt;&lt;&lt; toCharCode
</code></pre>
<p>ÔºàË¶ÅÁ¥†Âûã„Åå <code>Hashable</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÇÇ„ÅÇ„Çã„Å™„Çâ„Å∞ÔºâÈÖçÂàó„ÅÆË¶ÅÁ¥†„Å´ <code>hash</code>Èñ¢Êï∞„Çí <code>map</code>„Åó„Å¶„Åã„Çâ„ÄÅ
<code>combineHashes</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶ÁµêÊûú„ÅÆ„Éè„ÉÉ„Ç∑„É•„ÇíÂ∑¶ÂÅ¥„Å´Áï≥„ÅøËæº„ÇÄ„Åì„Å®„Åß„ÄÅ
ÈÖçÂàó„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance hashArray :: Hashable a =&gt; Hashable (Array a) where
  hash = foldl combineHashes (hashCode 0) &lt;&lt;&lt; map hash
</code></pre>
<p>„Åô„Åß„Å´Êõ∏„ÅÑ„Åü„ÇÇ„ÅÆ„Çà„ÇäÂçòÁ¥î„Å™„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ
Êñ∞„Åü„Å™„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊßãÁØâ„Åó„Å¶„ÅÑ„Çã„ÇÑ„ÇäÊñπ„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>String</code>„Çí<code>Char</code>„ÅÆÈÖçÂàó„Å´Â§âÊèõ„Åó„ÄÅ
„Åì„ÅÆÊñ∞„Åü„Å™<code>Array</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰Ωø„Å£„Å¶<code>String</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">instance hashString :: Hashable String where
  hash = hash &lt;&lt;&lt; toCharArray
</code></pre>
<p>„Åì„Çå„Çâ„ÅÆ <code>Hashable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå
ÂÖà„Åª„Å©„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆÊ≥ïÂâá„ÇíÊ∫Ä„Åü„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíË®ºÊòé„Åô„Çã„Å´„ÅØ„Å©„ÅÜ„Åó„Åü„Çâ„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
Âêå„ÅòÂÄ§„ÅåÁ≠â„Åó„ÅÑ„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
<code>Int</code>„ÄÅ <code>Char</code>„ÄÅ <code>String</code>„ÄÅ <code>Boolean</code>„ÅÆÂ†¥Âêà„ÅØ„ÄÅ
<code>Eq</code>„ÅÆÊÑèÂë≥„Åß„ÅØÂêå„ÅòÂÄ§„Åß„ÇÇÂé≥ÂØÜ„Å´„ÅØÂêå„Åò„Åß„ÅØ„Å™„ÅÑ„ÄÅ
„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å™Âûã„ÅÆÂÄ§„ÅØÂ≠òÂú®„Åó„Å™„ÅÑ„ÅÆ„ÅßÁ∞°Âçò„Åß„Åô„ÄÇ</p>
<p>„ÇÇ„Å£„Å®Èù¢ÁôΩ„ÅÑÂûã„Å´„Å§„ÅÑ„Å¶„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
„Åì„ÅÆÂ†¥Âêà„ÄÅÈÖçÂàó„ÅÆÈï∑„Åï„Å´Èñ¢„Åô„ÇãÂ∏∞Á¥ç„Çí‰Ωø„ÅÜ„Å®„ÄÅÂûã„ÇØ„É©„Çπ„ÅÆÊ≥ïÂâá„ÇíË®ºÊòé„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
Èï∑„Åï„Çº„É≠„ÅÆÂîØ‰∏Ä„ÅÆÈÖçÂàó„ÅØ <code>[]</code>„Åß„Åô„ÄÇ
ÈÖçÂàó„ÅÆ <code>Eq</code>„ÅÆÂÆöÁæ©„Å´„Çà„Çä„ÄÅ‰ªªÊÑè„ÅÆ2„Å§„ÅÆÁ©∫„Åß„Å™„ÅÑÈÖçÂàó„ÅØ„ÄÅ„Åù„Çå„Çâ„ÅÆÂÖàÈ†≠„ÅÆË¶ÅÁ¥†„ÅåÂêå„Åò„ÅßÈÖçÂàó„ÅÆÊÆã„Çä„ÅÆÈÉ®ÂàÜ„ÅåÁ≠â„Åó„ÅÑ„Å®„Åç„ÄÅ„Åæ„Åü„Åù„ÅÆÊôÇ„Å´Èôê„ÇäÁ≠â„Åó„Åè„Å™„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆÂ∏∞Á¥çÁöÑ„Å™‰ªÆÂÆö„Å´„Çà„Çä„ÄÅÈÖçÂàó„ÅÆÊÆã„Çä„ÅÆÈÉ®ÂàÜ„ÅØÂêå„Åò„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÊåÅ„Å°„Åæ„Åô„Åó„ÄÅ„ÇÇ„Åó <code>Hashable a</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„Åì„ÅÆÊ≥ïÂâá„ÇíÊ∫Ä„Åü„Åô„Å™„Çâ„ÄÅÂÖàÈ†≠„ÅÆË¶ÅÁ¥†„ÇÇÂêå„Åò„Éè„ÉÉ„Ç∑„É•ÂÄ§„Çí„ÇÇ„Å§„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ
„Åó„Åü„Åå„Å£„Å¶„ÄÅ2„Å§„ÅÆÈÖçÂàó„ÅØÂêå„Åò„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíÊåÅ„Å°„ÄÅ<code>Hashable (Array a)</code>„ÇÇÂêåÊßò„Å´Âûã„ÇØ„É©„ÇπÊ≥ïÂâá„ÇíÊ∫Ä„Åü„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Å´„ÅØ„ÄÅ <code>Maybe</code>„Å® <code>Tuple</code>Âûã„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å™„Å©„ÄÅ
‰ªñ„Å´„ÇÇ <code>Hashable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ‰æã„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-17"><a class="header" href="#ÊºîÁøí-17">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâPSCi„Çí‰Ωø„Å£„Å¶„ÄÅÂÆöÁæ©„Åó„ÅüÂêÑ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ„Éè„ÉÉ„Ç∑„É•Èñ¢Êï∞„Çí„ÉÜ„Çπ„Éà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÅØÂçò‰ΩìË©¶È®ì„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ„Éè„ÉÉ„Ç∑„É•„Å®ÂÄ§„ÅÆÂêåÂÄ§ÊÄß„Å´Âü∫„Å•„ÅÑ„Å¶ÈÖçÂàó„ÅåÈáçË§á„Åô„ÇãË¶ÅÁ¥†„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„ÇãÈñ¢Êï∞<code>arrayHasDuplicates</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åæ„Åö„Éè„ÉÉ„Ç∑„É•ÂêåÂÄ§ÊÄß„Çí<code>hashEqual</code>Èñ¢Êï∞„ÅßÁ¢∫Ë™ç„Åó„ÄÅ
„Åù„Çå„Åã„Çâ„ÇÇ„ÅóÈáçË§á„Åô„Çã„Éè„ÉÉ„Ç∑„É•„ÅÆÂØæ„ÅåË¶ã‰ªò„Åã„Å£„Åü„Çâ<code>==</code>„ÅßÂÄ§„ÅÆÂêåÂÄ§ÊÄß„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>Data.Array</code>„ÅÆ <code>nubByEq</code>Èñ¢Êï∞„ÅØ„Åì„ÅÆÂïèÈ°å„Çí„Åö„Å£„Å®Á∞°Âçò„Å´„Åó„Å¶„Åè„Çå„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÂûã„ÇØ„É©„Çπ„ÅÆÊ≥ïÂâá„ÇíÊ∫Ä„Åü„Åô„ÄÅÊ¨°„ÅÆnewtype„ÅÆ <code>Hashable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">newtype Hour = Hour Int

instance eqHour :: Eq Hour where
  eq (Hour n) (Hour m) = mod n 12 == mod m 12
</code></pre>
</li>
</ol>
<p>newtype„ÅÆ <code>Hour</code>„Å®„Åù„ÅÆ <code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ„ÄÅ12„ÇíÊ≥ï„Å®„Åô„ÇãÊï¥Êï∞„ÅÆÂûã„ÇíË°®„Åó„Åæ„Åô„ÄÇ
„Åó„Åü„Åå„Å£„Å¶„ÄÅ‰æã„Åà„Å∞1„Å®13„ÅØÁ≠â„Åó„ÅÑ„Å®Ë¶ã„Å™„Åï„Çå„Åæ„Åô„ÄÇ
„Åù„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂûã„ÇØ„É©„Çπ„ÅÆÊ≥ïÂâá„ÇíÊ∫Ä„Åü„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíË®ºÊòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<ol>
<li>ÔºàÈõ£„Åó„ÅÑÔºâ<code>Maybe</code>„ÄÅ<code>Either</code>„Åù„Åó„Å¶<code>Tuple</code>„Å∏„ÅÆ<code>Hashable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´„Å§„ÅÑ„Å¶Âûã„ÇØ„É©„Çπ„ÅÆÊ≥ïÂâá„ÇíË®ºÊòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÉÜ„Çπ„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-4"><a class="header" href="#„Åæ„Å®„ÇÅ-4">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅÂûã„Å´Âü∫„Å•„ÅèÊäΩË±°Âåñ„Åß„ÄÅ
„Ç≥„Éº„Éâ„ÅÆÂÜçÂà©Áî®„ÅÆ„Åü„ÇÅ„ÅÆÂº∑Âäõ„Å™ÂΩ¢ÂºèÂåñ„ÇíÂèØËÉΩ„Å´„Åô„Çã<strong>Âûã„ÇØ„É©„Çπ</strong>„ÇíÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇ
PureScript„ÅÆÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„Åã„ÇâÊ®ôÊ∫ñ„ÅÆÂûã„ÇØ„É©„Çπ„ÇíÂπæ„Å§„ÅãË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ
„Åæ„Åü„ÄÅ„Éè„ÉÉ„Ç∑„É•ÂÄ§„ÇíË®àÁÆó„Åô„ÇãÂûã„ÇØ„É©„Çπ„Å´Âü∫„Å•„ÅèÁã¨Ëá™„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíÂÆöÁæ©„Åó„Åæ„Åó„Åü„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„Åß„ÅØÂûã„ÇØ„É©„ÇπÊ≥ïÂâá„ÅÆËÄÉ„ÅàÊñπ„ÇÇÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„Åå„ÄÅ
„Åì„Çå„ÅØÊäΩË±°Âåñ„Å´Âûã„ÇØ„É©„Çπ„Çí‰Ωø„ÅÜ„Ç≥„Éº„Éâ„Å´„Å§„ÅÑ„Å¶„ÅÆÊÄßË≥™„ÇíË®ºÊòé„Åô„ÇãÊâãÊ≥ï„Åß„Åó„Åü„ÄÇ
Âûã„ÇØ„É©„ÇπÊ≥ïÂâá„ÅØ<strong>Á≠âÂºèÊé®Ë´ñ</strong> (equational reasoning) „Å®Âëº„Å∞„Çå„ÇãÂ§ß„Åç„Å™ÂàÜÈáé„ÅÆ‰∏ÄÈÉ®„Åß„ÅÇ„Çä„ÄÅ
„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„ÅÆÊÄßË≥™„Å®Âûã„Ç∑„Çπ„ÉÜ„É†„ÅØ„Éó„É≠„Ç∞„É©„É†„Å´„Å§„ÅÑ„Å¶Ë´ñÁêÜÁöÑ„Å™Êé®Ë´ñ„Çí„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÈáçË¶Å„Å™ËÄÉ„ÅàÊñπ„Åß„ÄÅÊú¨Êõ∏„Åß„ÅØ‰ªäÂæå„ÅÇ„Çâ„ÇÜ„ÇãÁÆáÊâÄ„ÅßÁ´ã„Å°Ëøî„ÇãË©±È°å„Å®„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º"><a class="header" href="#„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º">„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-5"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-5">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ
<code>Applicative</code>Âûã„ÇØ„É©„Çπ„Å´„Çà„Å£„Å¶Ë°®Áèæ„Åï„Çå„Çã<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã</strong> (applicative functor)
„Å®„ÅÑ„ÅÜÈáçË¶Å„Å™ÊäΩË±°Âåñ„Å®Êñ∞„Åü„Å´Âá∫‰ºö„ÅÜ„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ
ÂêçÂâç„ÅåÈõ£„Åó„Åù„ÅÜ„Å´ÊÄù„Åà„Å¶„ÇÇÂøÉÈÖç„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
„Éï„Ç©„Éº„É†„Éá„Éº„Çø„ÅÆÊ§úË®º„Å®„ÅÑ„ÅÜÂÆüÁî®ÁöÑ„Å™‰æã„Çí‰Ωø„Å£„Å¶„Åì„ÅÆÊ¶ÇÂøµ„ÅÆÂãïÊ©ü‰ªò„Åë„Çí„Åó„Åæ„Åô„ÄÇ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Çí‰Ωø„ÅÜ„Å®„ÄÅ
ÈÄöÂ∏∏„Åß„ÅÇ„Çå„Å∞Â§ßÈáè„ÅÆÊ±∫„Åæ„ÇäÊñáÂè•„Çí‰º¥„ÅÜ„Çà„ÅÜ„Å™„Ç≥„Éº„Éâ„Çí„ÄÅ
Á∞°ÊΩî„ÅßÂÆ£Ë®ÄÁöÑ„Å™Ë®òËø∞„Å∏„Å®Â§â„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åæ„Åü„ÄÅ<strong>Â∑°ÂõûÂèØËÉΩÈñ¢Êâã</strong> (traversable functor) „ÇíË°®Áèæ„Åô„Çã<code>Traversable</code>„Å®„ÅÑ„ÅÜÂà•„ÅÆÂûã„ÇØ„É©„Çπ„Å´„ÇÇÂá∫‰ºö„ÅÑ„Åæ„Åô„ÄÇ
ÁèæÂÆü„ÅÆÂïèÈ°å„Å∏„ÅÆËß£Ê±∫Á≠ñ„Åã„Çâ„Åì„ÅÆÊ¶ÇÂøµ„ÅåËá™ÁÑ∂„Å´Áîü„Åò„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åå„Çè„Åã„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„Åß„ÅØÁ¨¨3Á´†„Å´Âºï„ÅçÁ∂ö„Åç‰ΩèÊâÄÈå≤„Çí‰æã„Å®„Åó„Å¶Êâ±„ÅÑ„Åæ„Åô„ÄÇ
‰ªäÂõû„ÅØ‰ΩèÊâÄÈå≤„ÅÆ„Éá„Éº„ÇøÂûã„ÇíÊã°Âºµ„Åó„ÄÅ
„Åì„Çå„Çâ„ÅÆÂûã„ÅÆÂÄ§„ÇíÊ§úË®º„Åô„ÇãÈñ¢Êï∞„ÇíÊõ∏„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÅØ„ÄÅ‰æã„Åà„Å∞„Éá„Éº„ÇøÂÖ•Âäõ„Éï„Ç©„Éº„É†„ÅÆ‰∏ÄÈÉ®„Åß„ÄÅ
‰ΩøÁî®ËÄÖ„Å∏„Ç®„É©„Éº„ÇíË°®Á§∫„Åô„Çã„Ç¶„Çß„Éñ„É¶„Éº„Ç∂„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ„Åß‰Ωø„Çè„Çå„Çã„Å®ËÄÉ„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-4"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-4">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ„ÄÅ„Åµ„Åü„Å§„ÅÆ„Éï„Ç°„Ç§„É´<code>src/Data/AddressBook.purs</code>
„Åä„Çà„Å≥<code>src/Data/AddressBook/Validation.purs</code>„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅØÂ§ö„Åè„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
„Åù„ÅÆÂ§ßÂçä„ÅØ„Åô„Åß„Å´Ë¶ã„Å¶„Åç„Åü„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
Êñ∞„Åó„ÅÑ‰æùÂ≠òÈñ¢‰øÇ„ÅØ2„Å§„Åß„Åô„ÄÇ</p>
<ul>
<li><code>control</code> - <code>Applicative</code>„ÅÆ„Çà„ÅÜ„Å™„ÄÅÂûã„ÇØ„É©„Çπ„Çí‰ΩøÁî®„Åó„Å¶Âà∂Âæ°„Éï„É≠„Éº„ÇíÊäΩË±°
Âåñ„Åô„ÇãÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>validation</code> - „Åì„ÅÆÁ´†„ÅÆ‰∏ªÈ°å„Åß„ÅÇ„Çã <strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º</strong> „ÅÆ„Åü„ÇÅ
„ÅÆÈñ¢Êâã„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
</ul>
<p><code>Data.AddressBook</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ„ÄÅ
„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ„Éá„Éº„ÇøÂûã„Å®„Åù„Çå„Çâ„ÅÆÂûã„Å´ÂØæ„Åô„Çã<code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„Åä„Çä„ÄÅ
<code>Data.AddressBook.Validation</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ„Åù„Çå„Çâ„ÅÆÂûã„ÅÆÊ§úË®ºË¶èÂâá„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="Èñ¢Êï∞ÈÅ©Áî®„ÅÆ‰∏ÄËà¨Âåñ"><a class="header" href="#Èñ¢Êï∞ÈÅ©Áî®„ÅÆ‰∏ÄËà¨Âåñ">Èñ¢Êï∞ÈÅ©Áî®„ÅÆ‰∏ÄËà¨Âåñ</a></h2>
<p><strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã</strong>„ÅÆÊ¶ÇÂøµ„ÇíÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ
‰ª•ÂâçÊâ±„Å£„ÅüÂûãÊßãÁØâÂ≠ê<code>Maybe</code>„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Åß„ÅØ„ÄÅ
Ê¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å§<code>address</code>Èñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„ÄÅÈÄö„Çä„ÅÆÂêçÂâç„ÄÅÂ∏Ç„ÄÅÂ∑û„Å®„ÅÑ„ÅÜ3„Å§„ÅÆÊñáÂ≠óÂàó„Åã„ÇâÂûã<code>Address</code>„ÅÆÂÄ§„ÇíÊßãÁØâ„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÁ∞°Âçò„Å´ÈÅ©Áî®„Åß„Åç„Åæ„Åô„ÅÆ„Åß„ÄÅ
PSCi„Åß„Å©„ÅÜ„Å™„Çã„ÅãË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; address &quot;123 Fake St.&quot; &quot;Faketown&quot; &quot;CA&quot;
{ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>„Åó„Åã„Åó„ÄÅÈÄö„Çä„ÄÅÂ∏Ç„ÄÅÂ∑û„ÅÆ3„Å§ÂÖ®„Å¶„ÅåÂøÖ„Åö„Åó„ÇÇÂÖ•Âäõ„Åï„Çå„Å™„ÅÑ„ÇÇ„ÅÆ„Å®„Åô„Çã„Å®„ÄÅ3„Å§„ÅÆÂ†¥Âêà„Åå„Åù„Çå„Åû„ÇåÁúÅÁï•ÂèØËÉΩ„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´<code>Maybe</code>Âûã„Çí‰ΩøÁî®„Åó„Åü„Åè„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>ËÄÉ„Åà„Çâ„Çå„ÇãÂ†¥Âêà„Å®„Åó„Å¶„ÅØ„ÄÅ
Â∏Ç„ÅåÁúÅÁï•„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„Åå„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„ÇÇ„Åó<code>address</code>Èñ¢Êï∞„ÇíÁõ¥Êé•ÈÅ©Áî®„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å®„ÄÅ
ÂûãÊ§úË®ºÂô®„Åã„Çâ„Ç®„É©„Éº„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Could not match type

  Maybe String

with type

  String
</code></pre>
<p><code>address</code>„ÅØ<code>Maybe String</code>Âûã„Åß„ÅØ„Å™„ÅèÊñáÂ≠óÂàóÂûã„ÅÆÂºïÊï∞„ÇíÂèñ„Çã„ÅÆ„Åß„ÄÅ
„ÇÇ„Å°„Çç„Çì„Åì„Çå„ÅØÊúüÂæÖÈÄö„ÇäÂûã„Ç®„É©„Éº„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó„ÄÅ„ÇÇ„Åó<code>address</code>Èñ¢Êï∞„Çí„ÄåÊåÅ„Å°‰∏ä„Åí„Çã„Äç„Åì„Å®„Åå„Åß„Åç„Çå„Å∞„ÄÅ
<code>Maybe</code>Âûã„ÅßÁ§∫„Åï„Çå„ÇãÁúÅÁï•ÂèØËÉΩ„Å™ÂÄ§„ÇíÊâ±„ÅÜ„Åì„Å®„Åå„Åß„Åç„Çã„ÅØ„Åö„Å†„Å®ÊúüÂæÖ„Åô„Çã„Åì„Å®„ÅØÁêÜ„Å´„Åã„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂÆüÈöõ„Å´„Åù„Çå„ÅØÂèØËÉΩ„Åß„ÄÅ
<code>Control.Apply</code>„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„ÇãÈñ¢Êï∞<code>lift3</code>„Åå„ÄÅ„Åæ„Åï„Å´Ê±Ç„ÇÅ„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Control.Apply
&gt; lift3 address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Nothing
</code></pre>
<p>„Åì„ÅÆ„Å®„Åç„ÄÅÂºïÊï∞„ÅÆ„Å≤„Å®„Å§ÔºàÂ∏ÇÔºâ„ÅåÊ¨†ËêΩ„Åó„Å¶„ÅÑ„Åü„ÅÆ„Åß„ÄÅ
ÁµêÊûú„ÅØ<code>Nothing</code>„Å´„Å™„Çä„Åæ„Åô„ÄÇ
„ÇÇ„Åó3„Å§„ÅÆÂºïÊï∞„Åô„Åπ„Å¶„Åå<code>Just</code>ÊßãÁØâÂ≠ê„Çí‰Ωø„Å£„Å¶‰∏é„Åà„Çâ„Çå„Çå„Å∞„ÄÅ
ÁµêÊûú„ÅØÂÄ§„ÇíÂê´„ÇÄ„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; lift3 address (Just &quot;123 Fake St.&quot;) (Just &quot;Faketown&quot;) (Just &quot;CA&quot;)

Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })
</code></pre>
<p><code>lift3</code>„Å®„ÅÑ„ÅÜÈñ¢Êï∞„ÅÆÂêçÂâç„ÅØ„ÄÅ
3ÂºïÊï∞„ÅÆÈñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Åü„ÇÅ„Å´‰ΩøÁî®„Åß„Åç„Çã„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Èñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„ÇãÂêåÊßò„ÅÆÈñ¢Êï∞„Åß„ÄÅ
ÂºïÊï∞„ÅÆÊï∞„ÅåÁï∞„Å™„Çã„ÇÇ„ÅÆ„Åå<code>Control.Apply</code>„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="‰ªªÊÑèÂÄã„ÅÆÂºïÊï∞„ÇíÊåÅ„Å§Èñ¢Êï∞„ÅÆÊåÅ„Å°‰∏ä„Åí"><a class="header" href="#‰ªªÊÑèÂÄã„ÅÆÂºïÊï∞„ÇíÊåÅ„Å§Èñ¢Êï∞„ÅÆÊåÅ„Å°‰∏ä„Åí">‰ªªÊÑèÂÄã„ÅÆÂºïÊï∞„ÇíÊåÅ„Å§Èñ¢Êï∞„ÅÆÊåÅ„Å°‰∏ä„Åí</a></h2>
<p>„Åì„Çå„Åß„ÄÅ<code>lift2</code>„ÇÑ<code>lift3</code>„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„Çí‰Ωø„Åà„Å∞„ÄÅ
ÂºïÊï∞„Åå2ÂÄã„ÇÑ3ÂÄã„ÅÆÈñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„ÅØ„Çè„Åã„Çä„Åæ„Åó„Åü„ÄÇ
„Åß„ÇÇ„ÄÅ„Åì„Çå„Çí‰ªªÊÑèÂÄã„ÅÆÂºïÊï∞„ÅÆÈñ¢Êï∞„Å∏„Å®‰∏ÄËà¨Âåñ„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Çã„ÅÆ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
<p><code>lift3</code>„ÅÆÂûã„ÇíË¶ã„Å¶„Åø„Çã„Å®„Çè„Åã„Çä„ÇÑ„Åô„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; :type lift3
forall a b c d f. Apply f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d
</code></pre>
<p>‰∏ä„ÅÆ<code>Maybe</code>„ÅÆ‰æã„Åß„ÅØÂûãÊßãÁØâÂ≠ê<code>f</code>„ÅØ<code>Maybe</code>„Åß„Åô„Åã„Çâ„ÄÅ<code>lift3</code>„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÁâπÊÆäÂåñ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; Maybe a -&gt; Maybe b -&gt; Maybe c -&gt; Maybe d
</code></pre>
<p>„Åì„ÅÆÂûã„ÅåË®Ä„Å£„Å¶„ÅÑ„Çã„ÅÆ„ÅØ„ÄÅ
3ÂºïÊï∞„ÅÆ‰ªªÊÑè„ÅÆÈñ¢Êï∞„ÇíÂèñ„Çä„ÄÅ
„Åù„ÅÆÈñ¢Êï∞„ÇíÂºïÊï∞„Å®Ëøî„ÇäÂÄ§„Åå<code>Maybe</code>„ÅßÂåÖ„Åæ„Çå„ÅüÊñ∞„Åó„ÅÑÈñ¢Êï∞„Å∏„Å®ÊåÅ„Å°‰∏ä„Åí„Çã„ÄÅ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>„ÇÇ„Å°„Çç„Çì„Å©„Çì„Å™ÂûãÊßãÁØâÂ≠ê<code>f</code>„Å´„Å§„ÅÑ„Å¶„ÇÇÊåÅ„Å°‰∏ä„Åí„Åå„Åß„Åç„Çã„Çè„Åë„Åß„ÅØ„Å™„ÅÑ„ÅÆ„Åß„Åô„Åå„ÄÅ
„Åù„Çå„Åß„ÅØ<code>Maybe</code>Âûã„ÇíÊåÅ„Å°‰∏ä„Åí„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åó„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÅØ‰Ωï„Å™„ÅÆ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
„Åï„Å¶„ÄÅÂÖà„Åª„Å©„ÅÆÂûã„ÅÆÁâπÊÆäÂåñ„Åß„ÅØ„ÄÅ
<code>f</code>„Å´ÂØæ„Åô„ÇãÂûã„ÇØ„É©„ÇπÂà∂Á¥Ñ„Åã„Çâ<code>Apply</code>Âûã„ÇØ„É©„Çπ„ÇíÂèñ„ÇäÈô§„ÅÑ„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ
<code>Apply</code>„ÅØPrelude„ÅßÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>Apply</code>Âûã„ÇØ„É©„Çπ„ÅØ<code>Functor</code>„ÅÆ‰∏ã‰Ωç„ÇØ„É©„Çπ„Åß„ÅÇ„Çä„ÄÅ
ËøΩÂä†„ÅÆÈñ¢Êï∞<code>apply</code>„ÅåÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>&lt;$&gt;</code>„Åå<code>map</code>„ÅÆÂà•Âêç„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„Çà„ÅÜ„Å´„ÄÅ
<code>Prelude</code>„É¢„Ç∏„É•„Éº„É´„Åß<code>&lt;*&gt;</code>„Çí<code>apply</code>„ÅÆÂà•Âêç„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Åã„ÇâË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„Åå„ÄÅ„Åì„Çå„Çâ2„Å§„ÅÆÊºîÁÆóÂ≠ê„ÅØ„Çà„Åè‰∏ÄÁ∑í„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ</p>
<p>„Å™„Åä„Åì„ÅÆ<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Apply#v:apply"><code>apply</code></a>„ÅØ<code>Data.Function</code>„ÅÆ<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:apply"><code>apply</code></a>Ôºà‰∏≠ÁΩÆ„Åß<code>$</code>Ôºâ„Å®„ÅØÁï∞„Å™„Çä„Åæ„Åô„ÄÇ
ÈÅãËâØ„ÅèÂæåËÄÖ„ÅØ„Åª„ÅºÂ∏∏„Å´‰∏≠ÁΩÆË®òÊ≥ï„Å®„Åó„Å¶‰Ωø„Çè„Çå„Çã„ÅÆ„Åß„ÄÅÂêçÂâç„ÅÆË°ùÁ™Å„Å´„Å§„ÅÑ„Å¶„ÅØÂøÉÈÖç„ÅîÁÑ°Áî®„Åß„Åô„ÄÇ</p>
<p><code>apply</code>„ÅÆÂûã„ÅØ<code>map</code>„ÅÆÂûã„Å®ÂÆü„Å´„Çà„Åè‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>map</code>„Å®<code>apply</code>„ÅÆÈÅï„ÅÑ„ÅØ„ÄÅ<code>map</code>„Åå„Åü„Å†„ÅÆÈñ¢Êï∞„ÇíÂºïÊï∞„Å´Âèñ„Çã„ÅÆ„Å´ÂØæ„Åó„ÄÅ
<code>apply</code>„ÅÆÊúÄÂàù„ÅÆÂºïÊï∞„ÅØÂûãÊßãÁØâÂ≠ê<code>f</code>„ÅßÂåÖ„Åæ„Çå„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜÁÇπ„Åß„Åô„ÄÇ
„Åì„Çå„Çí„Å©„ÅÆ„Çà„ÅÜ„Å´‰Ωø„ÅÜ„ÅÆ„Åã„ÅØ„Åì„Çå„Åã„Çâ„Åô„Åê„Å´Ë¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„Åå„ÄÅ
„Åù„ÅÆÂâç„Å´„Åæ„Åö<code>Maybe</code>Âûã„Å´„Å§„ÅÑ„Å¶<code>Apply</code>Âûã„ÇØ„É©„Çπ„Çí„Å©„ÅÜÂÆüË£Ö„Åô„Çã„ÅÆ„Åã„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">instance functorMaybe :: Functor Maybe where
  map f (Just a) = Just (f a)
  map f Nothing  = Nothing

instance applyMaybe :: Apply Maybe where
  apply (Just f) (Just x) = Just (f x)
  apply _        _        = Nothing
</code></pre>
<p>„Åì„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåË®Ä„Å£„Å¶„ÅÑ„Çã„ÅÆ„ÅØ„ÄÅ
‰ªªÊÑè„ÅÆ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„Å´„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™Èñ¢Êï∞„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ
„Åù„ÅÆ‰∏°Êñπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÊôÇ„Å´Èôê„ÇäÁµêÊûú„ÇÇÂÆöÁæ©„Åï„Çå„Çã„ÄÅ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØ„ÄÅ<code>map</code>„Å®<code>apply</code>„Çí‰∏ÄÁ∑í„Å´‰Ωø„Å£„Å¶„Å©„ÅÜ„ÇÑ„Å£„Å¶ÂºïÊï∞„Åå‰ªªÊÑèÂÄã„ÅÆÈñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„ÅÆ„Åã„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>1ÂºïÊï∞„ÅÆÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅ<code>map</code>„Çí„Åù„ÅÆ„Åæ„Åæ‰Ωø„ÅÜ„Å†„Åë„Åß„Åô„ÄÇ</p>
<p>2ÂºïÊï∞Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅØÂûã<code>a -&gt; b -&gt; c</code>„ÅÆ„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞<code>g</code>„Åå„ÅÇ„Çã„Å®„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÂûã<code>a -&gt; (b -&gt; c)</code>„Å®Âêå„Åò„Åß„Åô„Åã„Çâ„ÄÅ
<code>Functor</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ‰ªò„Åç„ÅÆ„ÅÇ„Çâ„ÇÜ„ÇãÂûãÊßãÁØâÂ≠ê<code>f</code>„Å´„Å§„ÅÑ„Å¶„ÄÅ
<code>map</code>„Çí<code>f</code>„Å´ÈÅ©Áî®„Åô„Çã„Å®Âûã<code>f a -&gt; f (b -&gt; c)</code>„ÅÆÊñ∞„Åü„Å™Èñ¢Êï∞„ÇíÂæó„Çã„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ
ÊåÅ„Å°‰∏ä„Åí„Çâ„Çå„ÅüÔºàÂûã<code>f a</code>„ÅÆÔºâÊúÄÂàù„ÅÆÂºïÊï∞„Å´„Åù„ÅÆÈñ¢Êï∞„ÇíÈÉ®ÂàÜÈÅ©Áî®„Åô„Çã„Å®„ÄÅ
Âûã<code>f (b -&gt; c)</code>„ÅÆÊñ∞„Åü„Å™ÂåÖ„Åæ„Çå„ÅüÈñ¢Êï∞„ÅåÂæó„Çâ„Çå„Åæ„Åô„ÄÇ
<code>f</code>„Å´<code>Apply</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇÇ„ÅÇ„Çã„Å™„Çâ„Å∞„ÄÅ
„Åù„Åì„Åã„Çâ„ÄÅ2Áï™ÁõÆ„ÅÆÊåÅ„Å°‰∏ä„Åí„Çâ„Çå„ÅüÔºàÂûã<code>f b</code>„ÅÆÔºâÂºïÊï∞„Å∏<code>apply</code>„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅ
Âûã<code>f c</code>„ÅÆÊúÄÁµÇÁöÑ„Å™ÂÄ§„ÇíÂæó„Åæ„Åô„ÄÇ</p>
<p>„Åæ„Å®„ÇÅ„Çã„Å®„ÄÅ<code>x :: f a</code>„Å®<code>y :: f b</code>„Åå„ÅÇ„Çã„Å®„Åç„ÄÅÂºè<code>(g &lt;$&gt; x) &lt;*&gt; y</code>„ÅÆÂûã„ÅØ<code>f c</code>„Å´„Å™„Çä„Åæ„ÅôÔºà„Åì„ÅÆÂºè„ÅØ<code>apply (map g x)  y</code>„Å®Âêå„ÅòÊÑèÂë≥„Å†„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Åæ„Åó„Çá„ÅÜÔºâ„ÄÇ
Prelude„ÅßÂÆöÁæ©„Åï„Çå„ÅüÂÑ™ÂÖàÈ†Ü‰Ωç„ÅÆË¶èÂâá„Å´Âæì„ÅÜ„Å®„ÄÅ<code>g &lt;$&gt; x &lt;*&gt; y</code>„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´Êã¨Âºß„ÇíÂ§ñ„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰∏ÄËà¨ÁöÑ„Å´„ÅÑ„Åà„Å∞„ÄÅÊúÄÂàù„ÅÆÂºïÊï∞„Å´<code>&lt;$&gt;</code>„Çí‰Ωø„ÅÑ„ÄÅ
ÊÆã„Çä„ÅÆÂºïÊï∞„Å´ÂØæ„Åó„Å¶„ÅØ<code>&lt;*&gt;</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
<code>lift3</code>„ÅßË™¨Êòé„Åô„Çã„Å®Ê¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z
</code></pre>
<p>„Åì„ÅÆÂºè„ÅÆÂûã„Åå„Å°„ÇÉ„Çì„Å®Êï¥Âêà„Åó„Å¶„ÅÑ„Çã„Åã„ÅÆÁ¢∫Ë™ç„ÅØ„ÄÅ
Ë™≠ËÄÖ„Å∏„ÅÆÊºîÁøí„Å®„Åó„Å¶ÊÆã„Åó„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<p>‰æã„Å®„Åó„Å¶„ÄÅ<code>&lt;$&gt;</code>„Å®<code>&lt;*&gt;</code>„Çí„Åù„ÅÆ„Åæ„Åæ‰Ωø„ÅÜ„Å®„ÄÅ
<code>Maybe</code>‰∏ä„Å´<code>address</code>Èñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Just &quot;Faketown&quot; &lt;*&gt; Just &quot;CA&quot;
Just ({ street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })

&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;CA&quot;
Nothing
</code></pre>
<p>„Åì„ÅÆ„Çà„ÅÜ„Å´„ÄÅÂºïÊï∞„ÅåÁï∞„Å™„Çã‰ªñ„ÅÆ„ÅÑ„Çç„ÅÑ„Çç„Å™Èñ¢Êï∞„Çí<code>Maybe</code>‰∏ä„Å´ÊåÅ„Å°‰∏ä„Åí„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„Åì„ÅÆ‰ª£„Çè„Çä„Å´„ÅäÈ¶¥Êüì„ÅÆ<strong>doË®òÊ≥ï</strong>„Å´‰ºº„ÅüË¶ã„ÅüÁõÆ„ÅÆ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñdoË®òÊ≥ï</strong>„ÅåÂêå„ÅòÁõÆÁöÑ„Åß‰Ωø„Åà„Åæ„Åô„ÄÇ
‰ª•‰∏ã„Åß„ÅØ<code>lift3</code>„Å´<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñdoË®òÊ≥ï</strong>„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Å™„Åä<code>ado</code>„Åå<code>do</code>„ÅÆ‰ª£„Çè„Çä„Å´‰Ωø„Çè„Çå„Å¶„Åä„Çä„ÄÅÁîü„ÅøÂá∫„Åï„Çå„ÅüÂÄ§„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´ÊúÄÂæå„ÅÆË°å„Åß<code>in</code>„Åå‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = ado
  a &lt;- x
  b &lt;- y
  c &lt;- z
  in f a b c
</code></pre>
<h2 id="„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÂûã„ÇØ„É©„Çπ"><a class="header" href="#„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÂûã„ÇØ„É©„Çπ">„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÂûã„ÇØ„É©„Çπ</a></h2>
<p>Èñ¢ÈÄ£„Åô„Çã<code>Applicative</code>„Å®„ÅÑ„ÅÜÂûã„ÇØ„É©„Çπ„ÅåÂ≠òÂú®„Åó„Å¶„Åä„Çä„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p><code>Applicative</code>„ÅØ<code>Apply</code>„ÅÆ‰∏ã‰Ωç„ÇØ„É©„Çπ„Åß„ÅÇ„Çä„ÄÅ
<code>pure</code>Èñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>pure</code>„ÅØÂÄ§„ÇíÂèñ„Çä„ÄÅ„Åù„ÅÆÂûã„ÅÆÂûãÊßãÁØâÂ≠ê<code>f</code>„ÅßÂåÖ„Åæ„Çå„ÅüÂÄ§„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Maybe</code>„Å´„Å§„ÅÑ„Å¶„ÅÆ<code>Applicative</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance applicativeMaybe :: Applicative Maybe where
  pure x = Just x
</code></pre>
<p>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØÈñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„ÇíÂèØËÉΩ„Å´„Åô„ÇãÈñ¢Êâã„Å†„Å®ËÄÉ„Åà„Çã„Å®„Åô„Çã„Å®„ÄÅ
<code>pure</code>„ÅØÂºïÊï∞„ÅÆ„Å™„ÅÑÈñ¢Êï∞„ÅÆÊåÅ„Å°‰∏ä„Åí„Å†„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´ËÄÉ„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´ÂØæ„Åô„ÇãÁõ¥ÊÑüÁöÑÁêÜËß£"><a class="header" href="#„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´ÂØæ„Åô„ÇãÁõ¥ÊÑüÁöÑÁêÜËß£">„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´ÂØæ„Åô„ÇãÁõ¥ÊÑüÁöÑÁêÜËß£</a></h2>
<p>PureScript„ÅÆÈñ¢Êï∞„ÅØÁ¥îÁ≤ã„Åß„ÅÇ„Çä„ÄÅ
ÂâØ‰ΩúÁî®„ÅØÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ
ApplicativeÈñ¢Êâã„ÅØ„ÄÅ
Èñ¢Êâã<code>f</code>„Å´„Çà„Å£„Å¶Ë°®Áèæ„Åï„Çå„Åü„ÅÇ„ÇãÁ®Æ„ÅÆÂâØ‰ΩúÁî®„ÇíÊèê‰æõ„Åô„Çã„Çà„ÅÜ„Å™„ÄÅ
„Çà„ÇäÂ§ß„Åç„Å™„Äå„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„Äç„ÇíÊâ±„Åà„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅÈñ¢Êâã<code>Maybe</code>„ÅØ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„ÅÆÂâØ‰ΩúÁî®„ÇíË°®Áèæ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åù„ÅÆ‰ªñ„ÅÆ‰æã„Å®„Åó„Å¶„ÅØ„ÄÅ
Âûã<code>err</code>„ÅÆ„Ç®„É©„Éº„ÅÆÂèØËÉΩÊÄß„ÅÆÂâØ‰ΩúÁî®„ÇíË°®„Åô<code>Either err</code>„ÇÑ„ÄÅ
Â§ßÂüüÁöÑ„Å™ÊßãÊàê„ÇíË™≠„ÅøÂèñ„ÇãÂâØ‰ΩúÁî®„ÇíË°®„ÅôArrowÈñ¢Êâã (arrow functor) <code>r -&gt;</code>„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Åì„Åß„ÅØ<code>Maybe</code>Èñ¢Êâã„Å´„Å§„ÅÑ„Å¶„Å†„Åë„ÇíËÄÉ„Åà„Çã„Åì„Å®„Å´„Åó„Åæ„Åô„ÄÇ</p>
<p>„ÇÇ„ÅóÈñ¢Êâã<code>f</code>„Åå‰ΩúÁî®„ÇíÊåÅ„Å§„Çà„ÇäÂ§ß„Åç„Å™„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„ÇíË°®„Åô„Å®„Åô„Çã„Å®„ÄÅ
<code>Apply</code>„Å®<code>Applicative</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØÂ∞è„Åï„Å™„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û (PureScript) „Åã„Çâ
Êñ∞„Åó„ÅÑÂ§ß„Åç„Å™Ë®ÄË™û„Å∏„Å®ÂÄ§„ÇÑÈñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„ÇíÂèØËÉΩ„Å´„Åó„Åæ„Åô„ÄÇ</p>
<p><code>pure</code>„ÅØÁ¥îÁ≤ã„Å™ÔºàÂâØ‰ΩúÁî®„Åå„Å™„ÅÑÔºâÂÄ§„Çí„Çà„ÇäÂ§ß„Åç„Å™Ë®ÄË™û„Å∏„Å®ÊåÅ„Å°‰∏ä„Åí„Åæ„Åô„Åó„ÄÅ
Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅØ‰∏ä„ÅßËø∞„Åπ„Åü„Å®„Åä„Çä<code>map</code>„Å®<code>apply</code>„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„Åì„ÅßÁñëÂïè„ÅåÁîü„Åæ„Çå„Åæ„Åô„ÄÇ
„ÇÇ„ÅóPureScript„ÅÆÈñ¢Êï∞„Å®ÂÄ§„ÇíÊñ∞„Åü„Å™Ë®ÄË™û„Å∏Âüã„ÇÅËæº„ÇÄ„ÅÆ„Å´<code>Applicative</code>„Åå‰Ωø„Åà„Çã„Å™„Çâ„ÄÅ
„Å©„ÅÜ„ÇÑ„Å£„Å¶Êñ∞„Åü„Å™Ë®ÄË™û„ÅØÂ§ß„Åç„Åè„Å™„Å£„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„ÅÆ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
„Åì„ÅÆÁ≠î„Åà„ÅØÈñ¢Êâã<code>f</code>„Å´‰æùÂ≠ò„Åó„Åæ„Åô„ÄÇ
„ÇÇ„Åó„Å™„Çì„Çâ„Åã„ÅÆ<code>x</code>„Å´„Å§„ÅÑ„Å¶<code>pure x</code>„ÅßË°®„Åõ„Å™„ÅÑ„Çà„ÅÜ„Å™Âûã<code>f a</code>„ÅÆÂºè„ÇíË¶ã„Å§„Åë„Åü„Å™„Çâ„ÄÅ
„Åù„ÅÆÂºè„ÅØ„Åù„ÅÆ„Çà„ÇäÂ§ß„Åç„Å™Ë®ÄË™û„Å†„Åë„Å´Â≠òÂú®„Åô„ÇãÈ†Ö„ÇíË°®„Åó„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p><code>f</code>„Åå<code>Maybe</code>„ÅÆ„Å®„Åç„ÅØ„ÄÅÂºè<code>Nothing</code>„Åå„Åù„ÅÆ‰æã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Å©„Çì„Å™<code>x</code>„Åå„ÅÇ„Å£„Å¶„ÇÇ<code>Nothing</code>„Çí<code>pure x</code>„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´Êõ∏„Åè„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ
„Åó„Åü„Åå„Å£„Å¶„ÄÅPureScript„ÅØÂÄ§„ÅÆÊ¨†ËêΩ„ÇíË°®„ÅôÊñ∞„Åó„ÅÑÈ†Ö<code>Nothing</code>„ÇíÂê´„ÇÄ„Çà„ÅÜ„Å´Êã°Â§ß„Åï„Çå„Åü„Å®ËÄÉ„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„ÇÇ„Å£„Å®‰ΩúÁî®„Çí"><a class="header" href="#„ÇÇ„Å£„Å®‰ΩúÁî®„Çí">„ÇÇ„Å£„Å®‰ΩúÁî®„Çí</a></h2>
<p>Êßò„ÄÖ„Å™<code>Applicative</code>Èñ¢Êâã„Å∏„Å®Èñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã‰æã„Çí„ÇÇ„Å£„Å®Ë¶ã„Å¶„ÅÑ„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>‰ª•‰∏ã„ÅØ„ÄÅPSCi„ÅßÂÆöÁæ©„Åï„Çå„Åü3„Å§„ÅÆÂêçÂâç„ÇíÁµêÂêà„Åó„Å¶ÂÆåÂÖ®„Å™ÂêçÂâç„Çí‰Ωú„ÇãÁ∞°Âçò„Å™Èñ¢Êï∞„ÅÆ‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude

&gt; fullName first middle last = last &lt;&gt; &quot;, &quot; &lt;&gt; first &lt;&gt; &quot; &quot; &lt;&gt; middle

&gt; fullName &quot;Phillip&quot; &quot;A&quot; &quot;Freeman&quot;
Freeman, Phillip A
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„ÄÅ„ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø„Å®„Åó„Å¶‰∏é„Åà„Çâ„Çå„Åü3„Å§„ÅÆÂºïÊï∞„ÇíÊåÅ„Å§„ÄÅ
Ôºà„Å®„Å¶„ÇÇÁ∞°Âçò„Å™ÔºÅÔºâ„Ç¶„Çß„Éñ„Çµ„Éº„Éì„Çπ„ÅÆÂÆüË£Ö„Åß„ÅÇ„Çã„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
‰ΩøÁî®ËÄÖ„Åå3„Å§„ÅÆÂºïÊï∞„Åô„Åπ„Å¶„Çí‰∏é„Åà„Åü„Åì„Å®„ÇíÁ¢∫„Åã„ÇÅ„Åü„ÅÑ„ÅÆ„Åß„ÄÅ
ÂºïÊï∞„ÅåÂ≠òÂú®„Åô„Çã„Åã„Å©„ÅÜ„Åã„ÇíË°®„Åô<code>Maybe</code>Âûã„Çí‰Ωø„ÅÜ„Åì„Å®„Å´„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
<code>fullName</code>„Çí<code>Maybe</code>„ÅÆ‰∏ä„Å∏ÊåÅ„Å°‰∏ä„Åí„Çã„Å®„ÄÅ
ÁúÅÁï•„Åï„Çå„ÅüÂºïÊï∞„ÇíÁ¢∫Ë™ç„Åô„Çã„Ç¶„Çß„Éñ„Çµ„Éº„Éì„Çπ„ÇíÂÆüË£Ö„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Just &quot;A&quot; &lt;*&gt; Just &quot;Freeman&quot;
Just (&quot;Freeman, Phillip A&quot;)

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;Freeman&quot;
Nothing
</code></pre>
<p>„Åæ„Åü„ÅØ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñdo</strong>„Åß</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; :paste‚Ä¶
‚Ä¶ ado
‚Ä¶   f &lt;- Just &quot;Phillip&quot;
‚Ä¶   m &lt;- Just &quot;A&quot;
‚Ä¶   l &lt;- Just &quot;Freeman&quot;
‚Ä¶   in fullName f m l
‚Ä¶ ^D
(Just &quot;Freeman, Phillip A&quot;)

‚Ä¶ ado
‚Ä¶   f &lt;- Just &quot;Phillip&quot;
‚Ä¶   m &lt;- Nothing
‚Ä¶   l &lt;- Just &quot;Freeman&quot;
‚Ä¶   in fullName f m l
‚Ä¶ ^D
Nothing
</code></pre>
<p>„Åì„ÅÆÊåÅ„Å°‰∏ä„Åí„ÅüÈñ¢Êï∞„ÅØ„ÄÅÂºïÊï∞„ÅÆ„ÅÑ„Åö„Çå„Åã„Åå<code>Nothing</code>„Å™„Çâ<code>Nothing</code>Ëøî„Åô„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„Åì„Çå„Åß„ÄÅ„ÇÇ„ÅóÂºïÊï∞„Åå‰∏çÊ≠£„Å™„ÇâWeb„Çµ„Éº„Éì„Çπ„Åã„Çâ„Ç®„É©„ÉºÂøúÁ≠î„ÇíÈÄÅ‰ø°„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„ÄÅ„Å™„Åã„Å™„Åã„ÅÑ„ÅÑÊÑü„Åò„Åß„Åô„ÄÇ„Åó„Åã„Åó„ÄÅ„Å©„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅåÈñìÈÅï„Å£„Å¶„ÅÑ„Åü„ÅÆ„Åã„ÇíÂøúÁ≠î„ÅßË°®Á§∫„Åß„Åç„Çã„Å®„ÄÅ„ÇÇ„Å£„Å®ËâØ„Åè„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>Meybe</code>‰∏ä„Å∏ÊåÅ„Å°‰∏ä„Åí„Çã‰ª£„Çè„Çä„Å´<code>Either String</code>‰∏ä„Å∏ÊåÅ„Å°‰∏ä„Åí„Çã„Çà„ÅÜ„Å´„Åô„Çã„Å®„ÄÅ
„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËøî„Åô„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ
„Åæ„Åö„ÅØ<code>Either String</code>„Çí‰Ωø„Å£„Å¶„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÖ•Âäõ„Çí„Ç®„É©„Éº„ÇíÁô∫‰ø°„Åß„Åç„ÇãË®àÁÆó„Å´Â§âÊèõ„Åô„ÇãÊºîÁÆóÂ≠ê„ÇíÊõ∏„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; :paste
‚Ä¶ withError Nothing  err = Left err
‚Ä¶ withError (Just a) _   = Right a
‚Ä¶ ^D
</code></pre>
<p><strong>Ê≥®ÊÑè</strong>Ôºö<code>Either err</code>ApplicativeÈñ¢Êâã„Å´„Åä„ÅÑ„Å¶„ÄÅ<code>Left</code>ÊßãÁØâÂ≠ê„ÅØÂ§±Êïó„ÇíË°®„Åó„Å¶„Åä„Çä„ÄÅ<code>Right</code>ÊßãÁØâÂ≠ê„ÅØÊàêÂäü„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Åß<code>Either String</code>‰∏ä„Å∏ÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„Åß„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÂºïÊï∞„Å´„Å§„ÅÑ„Å¶ÈÅ©Âàá„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊèê‰æõ„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ fullNameEither first middle last =
‚Ä¶   fullName &lt;$&gt; (first  `withError` &quot;First name was missing&quot;)
‚Ä¶            &lt;*&gt; (middle `withError` &quot;Middle name was missing&quot;)
‚Ä¶            &lt;*&gt; (last   `withError` &quot;Last name was missing&quot;)
‚Ä¶ ^D
</code></pre>
<p>„Åæ„Åü„ÅØ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñdo</strong>„Åß</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ fullNameEither first middle last = ado
‚Ä¶  f &lt;- first  `withError` &quot;First name was missing&quot;
‚Ä¶  m &lt;- middle `withError` &quot;Middle name was missing&quot;
‚Ä¶  l &lt;- last   `withError` &quot;Last name was missing&quot;
‚Ä¶  in fullName f m l
‚Ä¶ ^D

&gt; :type fullNameEither
Maybe String -&gt; Maybe String -&gt; Maybe String -&gt; Either String String
</code></pre>
<p>„Åì„Çå„Åß„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>Maybe</code>„ÅÆ3„Å§„ÅÆÁúÅÁï•ÂèØËÉΩ„Å™ÂºïÊï∞„ÇíÂèñ„Çä„ÄÅ
<code>String</code>„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Åã<code>String</code>„ÅÆÁµêÊûú„ÅÆ„Å©„Å°„Çâ„Åã„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>„ÅÑ„Çç„ÅÑ„Çç„Å™ÂÖ•Âäõ„Åß„Åì„ÅÆÈñ¢Êï∞„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) (Just &quot;Freeman&quot;)
(Right &quot;Freeman, Phillip A&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) Nothing (Just &quot;Freeman&quot;)
(Left &quot;Middle name was missing&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) Nothing
(Left &quot;Last name was missing&quot;)
</code></pre>
<p>„Åì„ÅÆ„Å®„Åç„ÄÅ„Åô„Åπ„Å¶„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Åå‰∏é„Åà„Çâ„Çå„Å∞ÊàêÂäü„ÅÆÁµêÊûú„ÅåË°®Á§∫„Åï„Çå„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞ÁúÅÁï•„Åï„Çå„Åü„Éï„Ç£„Éº„É´„Éâ„ÅÆ„ÅÜ„Å°ÊúÄÂàù„ÅÆ„ÇÇ„ÅÆ„Å´ÂØæÂøú„Åô„Çã„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ„Åó„Åã„Åó„ÄÅ„ÇÇ„ÅóË§áÊï∞„ÅÆÂÖ•Âäõ„ÅåÁúÅÁï•„Åï„Çå„Å¶„ÅÑ„Çã„Å®„Åç„ÄÅÊúÄÂàù„ÅÆ„Ç®„É©„Éº„Åó„ÅãË¶ã„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; fullNameEither Nothing Nothing Nothing
(Left &quot;First name was missing&quot;)
</code></pre>
<p>„Åì„Çå„Åß„ÇÇÂçÅÂàÜ„Å™„Å®„Åç„ÇÇ„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ„Ç®„É©„ÉºÊôÇ„Å´<strong>„Åô„Åπ„Å¶„ÅÆ</strong>ÁúÅÁï•„Åï„Çå„Åü„Éï„Ç£„Éº„É´„Éâ„ÅÆ‰∏ÄË¶ß„Åå„Åª„Åó„ÅÑ„Å®„Åç„ÅØ„ÄÅ<code>Either String</code>„Çà„Çä„ÇÇÂº∑Âäõ„Å™„ÇÇ„ÅÆ„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ„Åì„ÅÆÁ´†„ÅÆÂæåÂçä„Åß„Åì„ÅÆËß£Ê±∫Á≠ñ„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="‰ΩúÁî®„ÅÆÁµêÂêà"><a class="header" href="#‰ΩúÁî®„ÅÆÁµêÂêà">‰ΩúÁî®„ÅÆÁµêÂêà</a></h2>
<p>ÊäΩË±°ÁöÑ„Å´ApplicativeÈñ¢Êâã„ÇíÊâ±„ÅÜ‰æã„Å®„Åó„Å¶„ÄÅ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã<code>f</code>„Å´„Çà„Å£„Å¶Ë°®Áèæ„Åï„Çå„ÅüÂâØ‰ΩúÁî®„ÇíÁ∑èÁß∞ÁöÑ„Å´ÁµÑ„ÅøÂêà„Çè„Åõ„ÇãÈñ¢Êï∞„Çí„Å©„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åè„ÅÆ„Åã„Çí„Åì„ÅÆÁØÄ„Åß„ÅØÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„ÅØ„Å©„ÅÜ„ÅÑ„ÅÜÊÑèÂë≥„Åß„Åó„Çá„ÅÜ„ÅãÔºü
‰Ωï„Çâ„Åã„ÅÆ<code>a</code>„Å´„Å§„ÅÑ„Å¶Âûã<code>f a</code>„ÅßÂåÖ„Åæ„Çå„ÅüÂºïÊï∞„ÅÆ„É™„Çπ„Éà„Åå„ÅÇ„Çã„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åù„Çå„ÅØÂûã<code>List (f a)</code>„ÅÆ„É™„Çπ„Éà„Åå„ÅÇ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
Áõ¥ÊÑüÁöÑ„Å´„ÅØ„ÄÅ„Åì„Çå„ÅØ<code>f</code>„Å´„Çà„Å£„Å¶ËøΩË∑°„Åï„Çå„ÇãÂâØ‰ΩúÁî®„ÇíÊåÅ„Å§„ÄÅ
Ëøî„ÇäÂÄ§„ÅÆÂûã„Åå<code>a</code>„ÅÆË®àÁÆó„ÅÆ„É™„Çπ„Éà„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆË®àÁÆó„ÅÆ„Åô„Åπ„Å¶„ÇíÈ†ÜÁï™„Å´ÂÆüË°å„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çå„Å∞„ÄÅ
<code>List a</code>Âûã„ÅÆÁµêÊûú„ÅÆ„É™„Çπ„Éà„ÇíÂæó„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åæ„Å†<code>f</code>„Å´„Çà„Å£„Å¶ËøΩË∑°„Åï„Çå„ÇãÂâØ‰ΩúÁî®„ÅåÊÆã„Çä„Åæ„Åô„ÄÇ
„Å§„Åæ„Çä„ÄÅÂÖÉ„ÅÆ„É™„Çπ„Éà„ÅÆ‰∏≠„ÅÆ‰ΩúÁî®„Çí„ÄåÁµêÂêà„Åô„Çã„Äç„Åì„Å®„Å´„Çà„Çä„ÄÅ
Âûã<code>List (f a)</code>„ÅÆ‰Ωï„Åã„ÇíÂûã<code>f (List a)</code>„ÅÆ‰Ωï„Åã„Å∏„Å®Â§âÊèõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Å®ËÄÉ„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<p>‰ªªÊÑè„ÅÆÂõ∫ÂÆöÈï∑„É™„Çπ„Éà„ÅÆÈï∑„Åï<code>n</code>„Å´„Å§„ÅÑ„Å¶„ÄÅ
„Åù„ÅÆÂºïÊï∞„ÇíË¶ÅÁ¥†„Å´ÊåÅ„Å£„ÅüÈï∑„Åï<code>n</code>„ÅÆ„É™„Çπ„Éà„ÇíÊßãÁØâ„Åô„Çã„Çà„ÅÜ„Å™<code>n</code>ÂºïÊï∞„ÅÆÈñ¢Êï∞„ÅåÂ≠òÂú®„Åó„Åæ„Åô„ÄÇ
„Åü„Å®„Åà„Å∞„ÄÅ„ÇÇ„Åó<code>n</code>„Åå<code>3</code>„Å™„Çâ„ÄÅ
Èñ¢Êï∞„ÅØ<code>\x y z -&gt; x : y : z : Nil</code>„Åß„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅÆÂûã„ÅØ<code>a -&gt; a -&gt; a -&gt; List a</code>„Åß„Åô„ÄÇ
<code>Applicative</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰Ωø„ÅÜ„Å®„ÄÅ
„Åì„ÅÆÈñ¢Êï∞„Çí<code>f</code>„ÅÆ‰∏ä„Å∏ÊåÅ„Å°‰∏ä„Åí„Å¶Èñ¢Êï∞Âûã<code>f a -&gt; f a -&gt; f a -&gt; f (List a)</code>„ÇíÂæó„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„ÅÑ„Åã„Å™„Çã<code>n</code>„Å´„Å§„ÅÑ„Å¶„ÇÇ„Åì„Çå„ÅåÂèØËÉΩ„Å™„ÅÆ„Åß„ÄÅ
„ÅÑ„Åã„Å™„ÇãÂºïÊï∞„ÅÆ<strong>„É™„Çπ„Éà</strong>„Å´„Å§„ÅÑ„Å¶„ÇÇÂêå„Åò„Çà„ÅÜ„Å´ÊåÅ„Å°‰∏ä„Åí„Çâ„Çå„Çã„Åì„Å®„ÅåÁ¢∫„Åã„ÇÅ„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<p>„Åó„Åü„Åå„Å£„Å¶„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„ÅØ„Åö„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÂâØ‰ΩúÁî®„ÇíÊåÅ„Å§„Åã„ÇÇ„Åó„Çå„Å™„ÅÑÂºïÊï∞„ÅÆ„É™„Çπ„Éà„Çí„Å®„Çä„ÄÅ
„Åù„Çå„Åû„Çå„ÅÆÂâØ‰ΩúÁî®„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åß„ÄÅ<code>f</code>„Å´ÂåÖ„Åæ„Çå„ÅüÂçò‰∏Ä„ÅÆ„É™„Çπ„Éà„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÈñ¢Êï∞„ÇíÊõ∏„Åè„Åü„ÇÅ„Å´„ÅØ„ÄÅ
ÂºïÊï∞„ÅÆ„É™„Çπ„Éà„ÅÆÈï∑„Åï„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Åæ„Åô„ÄÇ
„É™„Çπ„Éà„ÅåÁ©∫„ÅÆÂ†¥Âêà„ÅØ„Å©„Çì„Å™‰ΩúÁî®„ÇÇÂÆüË°å„Åô„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åã„Çâ„ÄÅ
<code>pure</code>„Çí‰ΩøÁî®„Åó„Å¶Âçò„Å´Á©∫„ÅÆ„É™„Çπ„Éà„ÇíËøî„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">combineList Nil = pure Nil
</code></pre>
<p>ÂÆüÈöõ„ÅÆ„Å®„Åì„Çç„ÄÅ„Åì„Çå„ÅåÂîØ‰∏Ä„Åß„Åç„Çã„Åì„Å®„Åß„ÅôÔºÅ</p>
<p>ÂÖ•Âäõ„ÅÆ„É™„Çπ„Éà„ÅåÁ©∫„Åß„Å™„ÅÑ„Å™„Çâ„Å∞„ÄÅ
Âûã<code>f a</code>„ÅÆÂåÖ„Åæ„Çå„ÅüÂºïÊï∞„Åß„ÅÇ„ÇãÂÖàÈ†≠Ë¶ÅÁ¥†„Å®„ÄÅ
Âûã<code>List (f a)</code>„ÅÆÂ∞æÈ∞≠„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Åæ„Åô„ÄÇ
„Åæ„Åü„ÄÅÂÜçÂ∏∞ÁöÑ„Å´„É™„Çπ„Éà„ÅÆÊÆã„Çä„ÇíÁµêÂêà„Åô„Çã„Å®„ÄÅ
Âûã<code>f (List a)</code>„ÅÆÁµêÊûú„ÅåÂæó„Çâ„Çå„Åæ„Åô„ÄÇ
„Åù„Çå„Åã„Çâ<code>&lt;$&gt;</code>„Å®<code>&lt;*&gt;</code>„Çí‰Ωø„ÅÜ„Å®„ÄÅ
<code>Cons</code>ÊßãÁØâÂ≠ê„ÇíÂÖàÈ†≠„Å®Êñ∞„Åó„ÅÑÂ∞æÈ∞≠„ÅÆ‰∏ä„Å´ÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">combineList (Cons x xs) = Cons &lt;$&gt; x &lt;*&gt; combineList xs
</code></pre>
<p>Áπ∞„ÇäËøî„Åó„Å´„Å™„Çä„Åæ„Åô„Åå„ÄÅ„Åì„Çå„ÅØ‰∏é„Åà„Çâ„Çå„ÅüÂûã„Å´Âü∫„Å•„ÅÑ„Å¶„ÅÑ„ÇãÂîØ‰∏Ä„ÅÆÂ¶•ÂΩì„Å™ÂÆüË£Ö„Åß„Åô„ÄÇ</p>
<p><code>Maybe</code>ÂûãÊßãÁØâÂ≠ê„Çí‰æã„Å´„Å®„Å£„Å¶„ÄÅPSCi„Åß„Åì„ÅÆÈñ¢Êï∞„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.List
&gt; import Data.Maybe

&gt; combineList (fromFoldable [Just 1, Just 2, Just 3])
(Just (Cons 1 (Cons 2 (Cons 3 Nil))))

&gt; combineList (fromFoldable [Just 1, Nothing, Just 2])
Nothing
</code></pre>
<p><code>Meybe</code>„Å∏ÁâπÊÆäÂåñ„Åó„Å¶ËÄÉ„Åà„Çã„Å®„ÄÅ
„É™„Çπ„Éà„ÅÆ„Åô„Åπ„Å¶„ÅÆË¶ÅÁ¥†„Åå<code>Just</code>„Åß„ÅÇ„Çã„Å®„Åç„Å´Èôê„Çä„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>Just</code>„ÇíËøî„Åó„Åæ„Åô„Åó„ÄÅ
„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞<code>Nothing</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„Å´ÂØæÂøú„Åô„Çã„Çà„ÇäÂ§ß„Åç„Å™Ë®ÄË™û„Å´Âèñ„ÇäÁµÑ„ÇÄ‰∏ä„Åß„ÅÆÁõ¥ÊÑü„Å®‰∏ÄË≤´„Åó„Åü„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÁµêÊûú„ÇíËøî„ÅôË®àÁÆó„ÅÆ„É™„Çπ„Éà„ÅØ„ÄÅ
ÂÖ®„Å¶„ÅÆË®àÁÆó„ÅåÁµêÊûú„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Å™„Çâ„Å∞„Åù„ÇåËá™Ë∫´„ÅÆÁµêÊûú„ÅÆ„Åø„ÇíÊåÅ„Å§„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó<code>combineList</code>Èñ¢Êï∞„ÅØ„Å©„Çì„Å™<code>Applicative</code>„Å´ÂØæ„Åó„Å¶„ÇÇÊ©üËÉΩ„Åó„Åæ„ÅôÔºÅ
<code>Either err</code>„Çí‰Ωø„Å£„Å¶„Ç®„É©„Éº„ÇíÁô∫‰ø°„Åô„Çã„Åã„ÇÇ„Åó„Çå„Å™„Åã„Å£„Åü„Çä„ÄÅ
<code>r -&gt;</code>„Çí‰Ωø„Å£„Å¶Â§ßÂüüÁöÑ„Å™Áä∂ÊÖã„ÇíË™≠„ÅøÂèñ„ÇãË®àÁÆó„ÇíÈÄ£Èéñ„Åï„Åõ„Çã„Å®„Åç„Å´„ÇÇ‰Ωø„Åà„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p><code>combineList</code>Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅÂæå„Åª„Å©<code>Traversable</code>Èñ¢Êâã„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Çã„Å®„Åç„Å´ÂÜç‰ºö„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-18"><a class="header" href="#ÊºîÁøí-18">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâÊï∞ÂÄ§ÊºîÁÆóÂ≠ê<code>+</code>„ÄÅ<code>-</code>„ÄÅ<code>*</code>„ÄÅ<code>/</code>„ÅÆ„Ç™„Éó„Ç∑„Éß„Éä„É´ÂºïÊï∞Ôºà„Å§„Åæ„Çä<code>Maybe</code>„Å´ÂåÖ„Åæ„Çå„ÅüÂºïÊï∞Ôºâ„ÇíÊâ±„Å£„Å¶<code>Maybe</code>„Å´ÂåÖ„Åæ„Çå„ÅüÂÄ§„ÇíËøî„ÅôÁâà„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„Å´„ÅØ<code>addMaybe</code>„ÄÅ<code>subMaybe</code>„ÄÅ<code>mulMaybe</code>„ÄÅ<code>divMaybe</code>„Å®ÂêçÂâç„Çí‰ªò„Åë„Åæ„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>lift2</code>„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ‰∏ä„ÅÆÊºîÁøí„ÇíÔºà<code>Maybe</code>„Å†„Åë„Åß„Å™„ÅèÔºâÂÖ®„Å¶„ÅÆ<code>Apply</code>Âûã„ÅßÂãï„Åè„Çà„ÅÜ„Å´Êã°Âºµ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„Çâ„ÅÆÊñ∞„Åó„ÅÑÈñ¢Êï∞„Å´„ÅØ<code>addApply</code>„ÄÅ<code>subApply</code>„ÄÅ<code>mulApply</code>„ÄÅ<code>divApply</code>„Å®ÂêçÂâç„Çí‰ªò„Åë„Åæ„Åô„ÄÇ</li>
<li>ÔºàÈõ£„Åó„ÅÑÔºâÂûã<code>combineMaybe : forall a f. (Applicative f) =&gt; Maybe (f a) -&gt; f (Maybe a)</code>
„ÇíÊåÅ„Å§Èñ¢Êï∞<code>combineMaybe</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÂâØ‰ΩúÁî®„Çí„ÇÇ„Å§„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™Ë®àÁÆó„Çí„Å®„Çä„ÄÅ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÁµêÊûú„Çí„ÇÇ„Å§ÂâØ‰ΩúÁî®„ÅÆ„ÅÇ„ÇãË®àÁÆó„ÇíËøî„Åó„Åæ„Åô„ÄÇ</li>
</ol>
<h2 id="„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º-1"><a class="header" href="#„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º-1">„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å´„Çà„ÇãÊ§úË®º</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Åß„ÅØ‰ΩèÊâÄÈå≤„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Åß‰Ωø„ÅÜ„Åì„Å®„ÅÆ„Åß„Åç„Çã„ÅÑ„Çç„ÅÑ„Çç„Å™„Éá„Éº„ÇøÂûã„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ë©≥Á¥∞„ÅØ„Åì„Åì„Åß„ÅØÂâ≤ÊÑõ„Åó„Åæ„Åô„Åå„ÄÅ
<code>Data.AddressBook</code>„É¢„Ç∏„É•„Éº„É´„Åã„Çâ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åï„Çå„ÇãÈáçË¶Å„Å™Èñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address

phoneNumber :: PhoneType -&gt; String -&gt; PhoneNumber

person :: String -&gt; String -&gt; Address -&gt; Array PhoneNumber -&gt; Person
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ<code>PhoneType</code>„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data PhoneType
  = HomePhone
  | WorkPhone
  | CellPhone
  | OtherPhone
</code></pre>
<p>„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÅØ‰ΩèÊâÄÈå≤„ÅÆÈ†ÖÁõÆ„ÇíË°®„Åô<code>Person</code>„ÇíÊßãÁØâ„Åô„Çã„ÅÆ„Å´‰Ωø„Åà„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞„ÄÅ<code>Data.AddressBook</code>„Å´„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÂÄ§„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">examplePerson :: Person
examplePerson =
  person &quot;John&quot; &quot;Smith&quot;
    (address &quot;123 Fake St.&quot; &quot;FakeTown&quot; &quot;CA&quot;)
    [ phoneNumber HomePhone &quot;555-555-5555&quot;
    , phoneNumber CellPhone &quot;555-555-0000&quot;
    ]
</code></pre>
<p>PSCi„Åß„Åì„Çå„Çâ„ÅÆÂÄ§„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜÔºàÁµêÊûú„ÅØÊï¥ÂΩ¢„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºâ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; examplePerson
{ firstName: &quot;John&quot;
, lastName: &quot;Smith&quot;
, homeAddress:
    { street: &quot;123 Fake St.&quot;
    , city: &quot;FakeTown&quot;
    , state: &quot;CA&quot;
    }
, phones:
    [ { type: HomePhone
      , number: &quot;555-555-5555&quot;
      }
    , { type: CellPhone
      , number: &quot;555-555-0000&quot;
      }
    ]
}
</code></pre>
<p>Ââç„ÅÆÁ´†„Åß„ÅØÂûã<code>Person</code>„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„ÇíÊ§úË®º„Åô„Çã„ÅÆ„Å´<code>Either String</code>Èñ¢Êâã„Çí„Å©„ÅÆ„Çà„ÅÜ„Å´‰Ωø„ÅÜ„Åã„ÇíË¶ã„Åæ„Åó„Åü„ÄÇ
‰æã„Åà„Å∞„ÄÅ„Éá„Éº„ÇøÊßãÈÄ†„ÅÆ2„Å§„ÅÆÂêçÂâç„ÇíÊ§úË®º„Åô„ÇãÈñ¢Êï∞„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åç„ÄÅ
„Éá„Éº„ÇøÊßãÈÄ†ÂÖ®‰Ωì„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Ê§úË®º„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">nonEmpty1 :: String -&gt; Either String String
nonEmpty1 &quot;&quot;     = Left &quot;Field cannot be empty&quot;
nonEmpty1 value  = Right value

validatePerson1 :: Person -&gt; Either String Person
validatePerson1 p =
  person &lt;$&gt; nonEmpty1 p.firstName
         &lt;*&gt; nonEmpty1 p.lastName
         &lt;*&gt; pure p.homeAddress
         &lt;*&gt; pure p.phones
</code></pre>
<p>„Åæ„Åü„ÅØ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñdo</strong>„Åß</p>
<pre><code class="language-haskell">validatePerson1Ado :: Person -&gt; Either String Person
validatePerson1Ado p = ado
  f &lt;- nonEmpty1 p.firstName
  l &lt;- nonEmpty1 p.lastName
  in person f l p.homeAddress p.phones
</code></pre>
<p>ÊúÄÂàù„ÅÆ2Ë°å„Åß„ÅØ<code>nonEmpty</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Á©∫ÊñáÂ≠óÂàó„Åß„Å™„ÅÑ„Åì„Å®„ÇíÊ§úË®º„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„ÇÇ„ÅóÂÖ•Âäõ„ÅåÁ©∫„Å™„Çâ<code>nonEMpty</code>„ÅØ„Ç®„É©„Éº„ÇíËøî„ÅóÔºà<code>Left</code>ÊßãÁØâÂ≠ê„ÅßÁ§∫„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºâ„ÄÅ
„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞<code>Right</code>ÊßãÁØâÂ≠ê„Çí‰Ωø„Å£„Å¶ÂÄ§„ÇíÂåÖ„Çì„ÅßËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂæå„ÅÆ2Ë°å„Åß„ÅØ‰Ωï„ÅÆÊ§úË®º„ÇÇÂÆüË°å„Åõ„Åö„ÄÅ
Âçò„Å´<code>address</code>„Éï„Ç£„Éº„É´„Éâ„Å®<code>phones</code>„Éï„Ç£„Éº„É´„Éâ„ÇíÊÆã„Çä„ÅÆÂºïÊï∞„Å®„Åó„Å¶<code>person</code>Èñ¢Êï∞„Å∏„Å®Êèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØPSCi„Åß„ÅÜ„Åæ„ÅèÂãï‰Ωú„Åô„Çã„Çà„ÅÜ„Å´Ë¶ã„Åà„Åæ„Åô„Åå„ÄÅ‰ª•ÂâçË¶ã„Åü„Çà„ÅÜ„Å™Âà∂Èôê„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; validatePerson $ person &quot;&quot; &quot;&quot; (address &quot;&quot; &quot;&quot; &quot;&quot;) []
(Left &quot;Field cannot be empty&quot;)
</code></pre>
<p><code>Either String</code>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØÈÅ≠ÈÅá„Åó„ÅüÊúÄÂàù„ÅÆ„Ç®„É©„Éº„Å†„Åë„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åß„ÇÇ„Åì„ÅÆÂÖ•Âäõ„Åß„ÅØ„ÄÅÂêçÂâç„ÅÆ‰∏çË∂≥„Å®Âßì„ÅÆ‰∏çË∂≥„Å®„ÅÑ„ÅÜ2„Å§„ÅÆ„Ç®„É©„Éº„Åå„Çè„Åã„Çã„Çà„ÅÜ„Å´„Åó„Åü„Åè„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>validation</code>„É©„Ç§„Éñ„É©„É™„ÅØÂà•„ÅÆ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÇÇÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÂçò„Å´<code>V</code>„Å®Âëº„Å∞„Çå„Å¶„ÅÑ„Å¶„ÄÅ
‰Ωï„Çâ„Åã„ÅÆ<strong>ÂçäÁæ§</strong> (Semigroup) „Åß„Ç®„É©„Éº„ÇíËøî„ÅôÊ©üËÉΩ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åü„Å®„Åà„Å∞„ÄÅ<code>V (Array String)</code>„Çí‰Ωø„ÅÜ„Å®„ÄÅÊñ∞„Åó„ÅÑ„Ç®„É©„Éº„ÇíÈÖçÂàó„ÅÆÊúÄÂæå„Å´ÈÄ£Áµê„Åó„Å¶„ÅÑ„Åç„ÄÅ
<code>String</code>„ÅÆÈÖçÂàó„Çí„Ç®„É©„Éº„Å®„Åó„Å¶Ëøî„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Data.Validation</code>„É¢„Ç∏„É•„Éº„É´„ÅØ<code>Data.AddressBook</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ
„Éá„Éº„ÇøÊßãÈÄ†„ÇíÊ§úË®º„Åô„Çã„Åü„ÇÅ„Å´<code>V (Array String)</code>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Data.AddressBook.Validation</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅÇ„ÇãÊ§úË®º„ÅÆ‰æã„Å®„Åó„Å¶„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Errors
  = Array String

nonEmpty :: String -&gt; String -&gt; V Errors String
nonEmpty field &quot;&quot;     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' cannot be empty&quot; ]
nonEmpty _     value  = pure value

lengthIs :: String -&gt; Int -&gt; String -&gt; V Errors String
lengthIs field len value | length value /= len =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must have length &quot; &lt;&gt; show len ]
lengthIs _     _   value = pure value

validateAddress :: Address -&gt; V Errors Address
validateAddress a =
  address &lt;$&gt; nonEmpty &quot;Street&quot;  a.street
          &lt;*&gt; nonEmpty &quot;City&quot;    a.city
          &lt;*&gt; lengthIs &quot;State&quot; 2 a.state
</code></pre>
<p>„Åæ„Åü„ÅØ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñdo</strong>„Åß</p>
<pre><code class="language-haskell">validateAddressAdo :: Address -&gt; V Errors Address
validateAddressAdo a = ado
  street &lt;- nonEmpty &quot;Street&quot;  a.street
  city   &lt;- nonEmpty &quot;City&quot;    a.city
  state  &lt;- lengthIs &quot;State&quot; 2 a.state
  in address street city state
</code></pre>
<p><code>validateAddress</code>„ÅØ<code>Address</code>„ÅÆÊßãÈÄ†„ÇíÊ§úË®º„Åó„Åæ„Åô„ÄÇ
<code>street</code>„Å®<code>city</code>„ÅåÁ©∫„Åß„Å™„ÅÑ„Åã„Å©„ÅÜ„Åã„ÄÅ<code>state</code>„ÅÆÊñáÂ≠óÂàó„ÅÆÈï∑„Åï„Åå2„Åß„ÅÇ„Çã„Åã„Å©„ÅÜ„Åã„ÇíÊ§úË®º„Åó„Åæ„Åô„ÄÇ</p>
<p><code>nonEmpty</code>„Å®<code>lengthIs</code>„ÅÆ2„Å§„ÅÆÊ§úË®ºÈñ¢Êï∞„ÅØ„ÅÑ„Åö„Çå„ÇÇ„ÄÅ
<code>Data.Validation</code>„É¢„Ç∏„É•„Éº„É´„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Çã<code>invalid</code>Èñ¢Êï∞„Çí
„Ç®„É©„Éº„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´‰Ωø„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>Array String</code>ÂçäÁæ§„ÇíÊâ±„Å£„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ<code>invalid</code>„ÅØÂºïÊï∞„Å®„Åó„Å¶ÊñáÂ≠óÂàó„ÅÆÈÖçÂàó„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ</p>
<p>PSCi„Åß„Åì„ÅÆÈñ¢Êï∞„ÇíË©¶„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.AddressBook
&gt; import Data.AddressBook.Validation

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         , &quot;Field 'State' must have length 2&quot;
         ])

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;CA&quot;
(invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         ])
</code></pre>
<p>„Åì„Çå„Åß„ÄÅ„Åô„Åπ„Å¶„ÅÆÊ§úË®º„Ç®„É©„Éº„ÅÆÈÖçÂàó„ÇíÂèó„ÅëÂèñ„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ</p>
<h2 id="Ê≠£Ë¶èË°®ÁèæÊ§úË®ºÂô®"><a class="header" href="#Ê≠£Ë¶èË°®ÁèæÊ§úË®ºÂô®">Ê≠£Ë¶èË°®ÁèæÊ§úË®ºÂô®</a></h2>
<p><code>validatePhoneNumber</code>Èñ¢Êï∞„Åß„ÅØÂºïÊï∞„ÅÆÂΩ¢Âºè„ÇíÊ§úË®º„Åô„Çã„Åü„ÇÅ„Å´Ê≠£Ë¶èË°®Áèæ„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÈáçË¶Å„Å™„ÅÆ„ÅØ<code>matches</code>Ê§úË®ºÈñ¢Êï∞„Åß„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>Data.String.Regex</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã<code>Regex</code>„Çí‰Ωø„Å£„Å¶ÂÖ•Âäõ„ÇíÊ§úË®º„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">matches :: String -&gt; Regex -&gt; String -&gt; V Errors String
matches _     regex value | test regex value
                          = pure value
matches field _     _     = invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' did not match the required format&quot; ]
</code></pre>
<p>Áπ∞„ÇäËøî„Åó„Å´„Å™„Çä„Åæ„Åô„Åå„ÄÅ<code>pure</code>„ÅØÂ∏∏„Å´ÊàêÂäü„Åô„ÇãÊ§úË®º„ÇíË°®„Åó„Å¶„Åä„Çä„ÄÅ„Ç®„É©„Éº„ÅÆÈÖçÂàó„ÅÆ‰ºùÈÅî„Å´„ÅØ<code>invalid</code>„Åå‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Åæ„Åß„Å®Âêå„Åò„Çà„ÅÜ„Å™ÊÑü„Åò„Åß„ÄÅ<code>validatePhoneNumber</code>„ÅØ<code>matches</code>Èñ¢Êï∞„Åã„ÇâÊßãÁØâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">validatePhoneNumber :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumber pn =
  phoneNumber &lt;$&gt; pure pn.&quot;type&quot;
              &lt;*&gt; matches &quot;Number&quot; phoneNumberRegex pn.number
</code></pre>
<p>„Åæ„Åü„ÅØ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñdo</strong>„Åß</p>
<pre><code class="language-haskell">validatePhoneNumberAdo :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumberAdo pn = ado
  tpe    &lt;- pure pn.&quot;type&quot;
  number &lt;- matches &quot;Number&quot; phoneNumberRegex pn.number
  in phoneNumber tpe number
</code></pre>
<p>„Åæ„Åü„ÄÅPSCi„Åß„ÅÑ„Çç„ÅÑ„Çç„Å™ÊúâÂäπ„Å™ÂÖ•Âäõ„ÇÑÁÑ°Âäπ„Å™ÂÖ•Âäõ„Å´ÂØæ„Åó„Å¶„ÄÅ„Åì„ÅÆÊ§úË®ºÂô®„ÇíÂÆüË°å„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-text">&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555-555-5555&quot;
pure ({ type: HomePhone, number: &quot;555-555-5555&quot; })

&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555.555.5555&quot;
invalid ([&quot;Field 'Number' did not match the required format&quot;])
</code></pre>
<h2 id="ÊºîÁøí-19"><a class="header" href="#ÊºîÁøí-19">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâÊ≠£Ë¶èË°®Áèæ<code>stateRegex :: Regex</code>„ÇíÊõ∏„ÅÑ„Å¶
ÊñáÂ≠óÂàó„Åå2ÊñáÂ≠ó„ÅÆ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫„Åã„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>phoneNumberRegex</code>„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÇíÂèÇÁÖß„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÊñáÂ≠óÂàóÂÖ®‰Ωì„ÅåÁ©∫ÁôΩ„Åß„Å™„ÅÑ„Åì„Å®„ÇíÊ§úÊüª„Åô„ÇãÊ≠£Ë¶èË°®Áèæ<code>nonEmptyRegex :: Regex</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö„Åì„ÅÆÊ≠£Ë¶èË°®Áèæ„ÇíÈñãÁô∫„Åô„Çã„ÅÆ„Å´ÊâãÂä©„Åë„ÅåÂøÖË¶Å„Å™„Çâ„ÄÅ<a href="https://regexr.com">RegExr</a>„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ
Á¥†Êô¥„Åó„ÅÑÊó©Ë¶ãË°®„Å®ÂØæË©±ÁöÑ„Å™„ÅäË©¶„ÅóÁí∞Â¢É„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>validateAddress</code>„Å´‰ºº„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
‰∏ä„ÅÆ<code>stateRegex</code>„Çí‰Ωø„Å£„Å¶<code>state</code>„Éï„Ç£„Éº„É´„Éâ„ÇíÊ§úË®º„Åó„ÄÅ
<code>nonEmptyRegex</code>„Çí‰Ωø„Å£„Å¶<code>street</code>„Å®<code>city</code>„Éï„Ç£„Éº„É´„Éâ„ÇíÊ§úË®º„Åô„ÇãÈñ¢Êï∞<code>validateAddressImproved</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>matches</code>„ÅÆÁî®‰æã„Å´„Å§„ÅÑ„Å¶„ÅØ<code>validatePhoneNumber</code>„ÅÆ„ÇΩ„Éº„Çπ„ÇíË¶ã„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="Â∑°ÂõûÂèØËÉΩÈñ¢Êâã"><a class="header" href="#Â∑°ÂõûÂèØËÉΩÈñ¢Êâã">Â∑°ÂõûÂèØËÉΩÈñ¢Êâã</a></h2>
<p>ÊÆã„Å£„ÅüÊ§úË®ºÂô®„ÅØ<code>validatePerson</code>„Åß„Åô„ÄÇ
„Åì„Çå„ÅØ„Åì„Çå„Åæ„ÅßË¶ã„Å¶„Åç„ÅüÊ§úË®ºÂô®„Å®‰ª•‰∏ã„ÅÆÊñ∞„Åó„ÅÑ<code>validatePhoneNumbers</code>Èñ¢Êï∞„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶
<code>Person</code>ÂÖ®‰Ωì„ÇíÊ§úË®º„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">validatePhoneNumbers :: String -&gt; Array PhoneNumber -&gt; V Errors (Array PhoneNumber)
validatePhoneNumbers field []      =
  invalid [ &quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must contain at least one value&quot; ]
validatePhoneNumbers _     phones  =
  traverse validatePhoneNumber phones

validatePerson :: Person -&gt; V Errors Person
validatePerson p =
  person &lt;$&gt; nonEmpty &quot;First Name&quot; p.firstName
         &lt;*&gt; nonEmpty &quot;Last Name&quot; p.lastName
         &lt;*&gt; validateAddress p.homeAddress
         &lt;*&gt; validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
</code></pre>
<p>„Åæ„Åü„ÅØ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñdo</strong>„Åß</p>
<pre><code class="language-haskell">validatePersonAdo :: Person -&gt; V Errors Person
validatePersonAdo p = ado
  firstName &lt;- nonEmpty &quot;First Name&quot; p.firstName
  lastName  &lt;- nonEmpty &quot;Last Name&quot; p.lastName
  address   &lt;- validateAddress p.homeAddress
  numbers   &lt;- validatePhoneNumbers &quot;Phone Numbers&quot; p.phones
  in person firstName lastName address numbers
</code></pre>
<p><code>validatePhoneNumbers</code>„ÅØ„Åì„Çå„Åæ„Åß„Å´Ë¶ã„Åü„Åì„Å®„ÅÆ„Å™„ÅÑÊñ∞„Åó„ÅÑÈñ¢Êï∞„ÄÅ<code>traverse</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>traverse</code>„ÅØ<code>Data.Traversable</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ<code>Traversable</code>Âûã„ÇØ„É©„Çπ„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p><code>Traversable</code>„ÅØ<strong>Â∑°ÂõûÂèØËÉΩÈñ¢Êâã</strong>„ÅÆÂûã„ÇØ„É©„Çπ„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÅÆÂûã„ÅØÂ∞ë„ÅóÈõ£„Åó„Åù„ÅÜ„Å´Ë¶ã„Åà„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åå„ÄÅ<code>validatePerson</code>„ÅØËâØ„ÅÑ„Åç„Å£„Åã„Åë„Å®„Å™„Çã‰æã„Åß„Åô„ÄÇ</p>
<p>„Åô„Åπ„Å¶„ÅÆÂ∑°ÂõûÂèØËÉΩÈñ¢Êâã„ÅØ<code>Functor</code>„Å®<code>Foldable</code>„ÅÆ„Å©„Å°„Çâ„Åß„ÇÇ„ÅÇ„Çä„Åæ„ÅôÔºà<strong>Áï≥„ÅøËæº„ÅøÂèØËÉΩÈñ¢Êâã</strong>„ÅØÊßãÈÄ†„Çí„Å≤„Å®„Å§„ÅÆÂÄ§„Å∏„Å®„Åæ„Å®„ÇÅ„Çã„ÄÅÁï≥„ÅøËæº„ÅøÊìç‰Ωú„ÇíÊèê‰æõ„Åô„ÇãÂûãÊßãÁØâÂ≠ê„Åß„ÅÇ„Å£„Åü„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ„ÄÇ
„Åù„Çå„Å´Âä†„Åà„Å¶„ÄÅ<code>Traversable</code>Èñ¢Êâã„ÅØ„Åù„ÅÆÊßãÈÄ†„Å´‰æùÂ≠ò„Åó„ÅüÂâØ‰ΩúÁî®„ÅÆÈõÜ„Åæ„Çä„ÇíÈÄ£Áµê„Åô„ÇãÊ©üËÉΩ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p>Ë§áÈõë„Åù„ÅÜ„Å´ËÅû„Åì„Åà„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åå„ÄÅÈÖçÂàó„ÅÆÂ†¥Âêà„Å´ÁâπÊÆäÂåñ„Åó„Å¶Á∞°Âçò„Å´ËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇÈÖçÂàóÂûãÊßãÁØâÂ≠ê„ÅØ<code>Traversable</code>„Åß„ÅÇ„Çã„ÄÅ„Å§„Åæ„ÇäÊ¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„ÅåÂ≠òÂú®„Åô„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; Array a -&gt; m (Array b)
</code></pre>
<p>Áõ¥ÊÑüÁöÑ„Å´„ÅØ„ÄÅ‰ªªÊÑè„ÅÆ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã<code>m</code>„Å®„ÄÅ
Âûã<code>a</code>„ÅÆÂÄ§„ÇíÂèñ„Å£„Å¶Âûã<code>b</code>„ÅÆÂÄ§„ÇíËøî„ÅôÔºà<code>f</code>„ÅßËøΩË∑°„Åï„Çå„ÇãÂâØ‰ΩúÁî®„ÇíÊåÅ„Å§ÔºâÈñ¢Êï∞„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åç„ÄÅ
„Åù„ÅÆÈñ¢Êï∞„ÇíÂûã<code>Array a</code>„ÅÆÈÖçÂàó„ÅÆ„Åù„Çå„Åû„Çå„ÅÆË¶ÅÁ¥†„Å´ÈÅ©Áî®„Åó„ÄÅ
Âûã<code>Array b</code>„ÅÆÔºà<code>f</code>„ÅßËøΩË∑°„Åï„Çå„ÇãÂâØ‰ΩúÁî®„ÇíÊåÅ„Å§ÔºâÁµêÊûú„ÇíÂæó„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åæ„Å†„Çà„Åè„Çè„Åã„Çâ„Å™„ÅÑ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
„Åù„Çå„Åß„ÅØ„ÄÅÊõ¥„Å´<code>f</code>„Çí‰∏äË®ò„ÅÆ<code>V Errors</code>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å´ÁâπÊÆäÂåñ„Åó„Å¶ËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„Çå„ÅßÊ¨°„ÅÆÂûã„ÇíÊåÅ„Å§Èñ¢Êï∞„ÅåÂæó„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">traverse :: forall a b. (a -&gt; V Errors b) -&gt; Array a -&gt; V Errors (Array b)
</code></pre>
<p>„Åì„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØ„ÄÅ
Âûã<code>a</code>„Å´„Å§„ÅÑ„Å¶„ÅÆÊ§úË®ºÈñ¢Êï∞<code>m</code>„Åå„ÅÇ„Çå„Å∞„ÄÅ
<code>traverse m</code>„ÅØÂûã<code>Array a</code>„ÅÆÈÖçÂàó„Å´„Å§„ÅÑ„Å¶„ÅÆÊ§úË®ºÈñ¢Êï∞„Åß„ÅÇ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíË®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„Åæ„Åï„Å´‰ªäÂøÖË¶Å„Å´„Å™„Å£„Å¶„ÅÑ„Çã<code>Person</code>„Éá„Éº„ÇøÊßãÈÄ†‰Ωì„ÅÆ<code>phones</code>„Éï„Ç£„Éº„É´„Éâ„ÇíÊ§úË®º„Åô„ÇãÊ§úË®ºÂô®„Åù„ÅÆ„ÇÇ„ÅÆ„Åß„ÅôÔºÅ
„Åù„Çå„Åû„Çå„ÅÆË¶ÅÁ¥†„ÅåÊàêÂäü„Åô„Çã„Åã„Å©„ÅÜ„Åã„ÇíÊ§úË®º„Åô„ÇãÊ§úË®ºÈñ¢Êï∞„Çí‰Ωú„Çã„Åü„ÇÅ„Å´„ÄÅ
<code>validatePhoneNumber</code>„Çí<code>traverse</code>„Å∏Ê∏°„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰∏ÄËà¨„Å´„ÄÅ<code>traverse</code>„ÅØ„Éá„Éº„ÇøÊßãÈÄ†„ÅÆË¶ÅÁ¥†„Çí„Å≤„Å®„Å§„Å•„Å§Ëæø„Å£„Å¶„ÅÑ„Åç„ÄÅÂâØ‰ΩúÁî®„ÅÆ„ÅÇ„ÇãË®àÁÆó„ÇíÂÆüË°å„Åó„Å¶ÁµêÊûú„ÇíÁ¥ØÁ©ç„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Traversable</code>„ÅÆ„ÇÇ„ÅÜ1„Å§„ÅÆÈñ¢Êï∞„ÄÅ<code>sequence</code>„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„Å´„ÅØË¶ãË¶ö„Åà„Åå„ÅÇ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<p>ÂÆüÈöõ„ÄÅÂÖà„Åª„Å©Êõ∏„ÅÑ„Åü<code>combineList</code>Èñ¢Êï∞„ÅØ<code>Traversable</code>Âûã„ÇØ„É©„Çπ„ÅÆ<code>sequence</code>Èñ¢Êï∞„ÅÆÁâπÂà•„Å™Â†¥Âêà„Å´ÈÅé„Åé„Åæ„Åõ„Çì„ÄÇ
<code>t</code>„ÇíÂûãÊßãÁØâÂ≠ê<code>List</code>„Å†„Å®„Åô„Çã„Å®„ÄÅ<code>combineList</code>Èñ¢Êï∞„ÅÆÂûã„ÅåÂæ©ÂÖÉ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>Â∑°ÂõûÂèØËÉΩÈñ¢Êâã„ÅØ„ÄÅ
‰ΩúÁî®„ÅÆ„ÅÇ„ÇãË®àÁÆó„ÇíÈÄ£Èéñ„Åï„Åõ„Å¶„Åù„ÅÆ‰ΩúÁî®„ÇíÁµêÂêà„Åô„Çã„Å®„ÅÑ„ÅÜ„ÄÅ
„Éá„Éº„ÇøÊßãÈÄ†Ëµ∞Êüª„ÅÆËÄÉ„ÅàÊñπ„ÇíÊääÊè°„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
ÂÆüÈöõ„ÄÅ<code>sequence</code>„Å®<code>traversable</code>„ÅØ<code>Traversable</code>„ÇíÂÆöÁæ©„Åô„Çã‰∏ä„Åß„Å©„Å°„Çâ„ÇÇÂêå„Åò„Åè„Çâ„ÅÑÈáçË¶Å„Åß„Åô„ÄÇ
„Åì„Çå„Çâ„ÅØ„Åä‰∫í„ÅÑ„Åå‰∫í„ÅÑ„ÇíÂà©Áî®„Åó„Å¶ÂÆüË£Ö„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„Å´„Å§„ÅÑ„Å¶„ÅØËààÂë≥„ÅÇ„ÇãË™≠ËÄÖ„Å∏„ÅÆÊºîÁøí„Å®„Åó„Å¶ÊÆã„Åó„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Data.List</code>„Åß‰∏é„Åà„Çâ„Çå„Å¶„ÅÑ„Çã„É™„Çπ„Éà„ÅÆ<code>Traversable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØÊ¨°„ÅÆÈÄö„Çä„ÄÇ</p>
<pre><code class="language-haskell">instance traversableList :: Traversable List where
-- traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; List a -&gt; m (List b)
traverse _ Nil         = pure Nil
traverse f (Cons x xs) = Cons &lt;$&gt; f x &lt;*&gt; traverse f xs
</code></pre>
<p>ÔºàÂÆüÈöõ„ÅÆÂÆöÁæ©„ÅØÂæå„Å´„Çπ„Çø„ÉÉ„ÇØÂÆâÂÖ®ÊÄß„ÇíÂêë‰∏ä„Åô„Çã„Åü„ÇÅ„ÅÆÂ§âÊõ¥„Åï„Çå„Åæ„Åó„Åü„ÄÇ
„Åù„ÅÆÂ§âÊõ¥„Å´„Å§„ÅÑ„Å¶„Çà„ÇäË©≥„Åó„Åè„ÅØ<a href="https://github.com/purescript/purescript-lists/pull/87">„Åì„Å°„Çâ</a>„ÅßË™≠„ÇÄ„Åì„Å®„Åå„Åß„Åç„Åæ„ÅôÔºâ</p>
<p>ÂÖ•Âäõ„ÅåÁ©∫„ÅÆ„É™„Çπ„Éà„ÅÆ„Å®„Åç„Å´„ÅØ„ÄÅ
Âçò„Å´<code>pure</code>„Çí‰Ωø„Å£„Å¶Á©∫„ÅÆÈÖçÂàó„ÇíËøî„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
ÈÖçÂàó„ÅåÁ©∫„Åß„Å™„ÅÑ„Å®„Åç„ÅØ„ÄÅ
Èñ¢Êï∞<code>f</code>„Çí‰Ωø„ÅÜ„Å®ÂÖàÈ†≠„ÅÆË¶ÅÁ¥†„Åã„ÇâÂûã<code>f b</code>„ÅÆË®àÁÆó„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åæ„Åü„ÄÅÈÖçÂàó„ÅÆÊÆã„Çä„Å´ÂØæ„Åó„Å¶<code>traverse</code>„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
ÊúÄÂæå„Å´„ÄÅ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã<code>m</code>„Åæ„Åß<code>Cons</code>ÊßãÁØâÂ≠ê„ÇíÊåÅ„Å°‰∏ä„Åí„Å¶„ÄÅ2„Å§„ÅÆÁµêÊûú„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Åæ„Åô„ÄÇ</p>
<p>Â∑°ÂõûÂèØËÉΩÈñ¢Êâã„ÅÆ‰æã„ÅØ„Åü„Å†„ÅÆÈÖçÂàó„ÇÑ„É™„Çπ„Éà‰ª•Â§ñ„Å´„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰ª•Ââç„Å´Ë¶ã„Åü<code>Maybe</code>ÂûãÊßãÁØâÂ≠ê„ÇÇ<code>Traversable</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
PSCi„ÅßË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; import Data.Traversable
&gt; import Data.AddressBook.Validation

&gt; traverse (nonEmpty &quot;Example&quot;) Nothing
pure (Nothing)

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;&quot;)
invalid ([&quot;Field 'Example' cannot be empty&quot;])

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;Testing&quot;)
pure ((Just &quot;Testing&quot;))
</code></pre>
<p>„Åì„Çå„Çâ„ÅÆ‰æã„Åß„ÅØ„ÄÅ
<code>Nothing</code>„ÅÆÂÄ§„ÅÆËµ∞Êüª„ÅØÊ§úË®º„Å™„Åó„Åß<code>Nothing</code>„ÅÆÂÄ§„ÇíËøî„Åó„ÄÅ
<code>Just x</code>„ÇíËµ∞Êüª„Åô„Çã„Å®<code>x</code>„ÇíÊ§úË®º„Åô„Çã„ÅÆ„Å´Ê§úË®ºÈñ¢Êï∞„Åå‰Ωø„Çè„Çå„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ë¶Å„ÅØ„ÄÅ<code>traverse</code>„ÅØÂûã<code>a</code>„Å´„Å§„ÅÑ„Å¶„ÅÆÊ§úË®ºÈñ¢Êï∞„Çí„Å®„Çä„ÄÅ<code>Maybe a</code>„Å´„Å§„ÅÑ„Å¶„ÅÆÊ§úË®ºÈñ¢Êï∞„ÄÅ
„Å§„Åæ„ÇäÂûã<code>a</code>„ÅÆ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§„Å´„Å§„ÅÑ„Å¶„ÅÆÊ§úË®ºÈñ¢Êï∞„ÇíËøî„Åô„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰ªñ„ÅÆÂ∑°ÂõûÂèØËÉΩÈñ¢Êâã„Å´„ÅØ<code>Array</code>„ÄÅ„Åæ„Åü‰ªªÊÑè„ÅÆÂûã<code>a</code>„Å´„Å§„ÅÑ„Å¶<code>Tuple a</code>„ÄÅ<code>Either a</code>„ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇ
‰∏ÄËà¨ÁöÑ„Å´„ÄÅ„ÄåÂÆπÂô®„Äç„ÅÆ„Çà„ÅÜ„Å™„Éá„Éº„Çø„ÅÆÂûãÊßãÁØâÂ≠ê„ÅØÂ§ßÊäµ<code>Traversable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰æã„Å®„Åó„Å¶„ÄÅÊºîÁøí„Åß„ÅØ‰∫åÂàÜÊú®„ÅÆÂûã„ÅÆ<code>Traversable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-20"><a class="header" href="#ÊºîÁøí-20">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>Eq</code>„Å®<code>Show</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ª•‰∏ã„ÅÆ2ÂàÜÊú®„Éá„Éº„ÇøÊßãÈÄ†„Å´Êõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">data Tree a = Leaf | Branch (Tree a) a (Tree a)
</code></pre>
<p>„Åì„Çå„Çâ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊâã‰ΩúÊ•≠„ÅßÊõ∏„Åè„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„Åó„ÄÅ
„Ç≥„É≥„Éë„Ç§„É©„Å´Â∞éÂá∫„Åó„Å¶„ÇÇ„Çâ„ÅÜ„Åì„Å®„ÇÇ„Åß„Åç„Çã„Åì„Å®„ÇíÂâç„ÅÆÁ´†„Åã„ÇâÊÄù„ÅÑËµ∑„Åì„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><code>Show</code>„ÅÆÂá∫Âäõ„Å´„ÅØÂ§ö„Åè„ÅÆ„ÄåÊ≠£„Åó„ÅÑ„ÄçÊõ∏Âºè„ÅÆÈÅ∏ÊäûËÇ¢„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆÊºîÁøí„ÅÆ„ÉÜ„Çπ„Éà„Åß„ÅØ‰ª•‰∏ã„ÅÆÁ©∫ÁôΩ„Çπ„Çø„Ç§„É´„ÇíÊúüÂæÖ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„Å°„Çá„ÅÜ„Å©‰∏ÄËà¨Âåñ„Åï„Çå„Åüshow„ÅÆÊó¢ÂÆö„ÅÆÊõ∏Âºè„Å®ÂêàËá¥„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ
„Åì„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊâã‰ΩúÊ•≠„ÅßÊõ∏„Åè„Å§„ÇÇ„Çä„Åß„ÅÇ„Çå„Å∞„ÄÅ
„Åì„ÅÆ„Åì„Å®„ÇíÂøµÈ†≠„Å´ÁΩÆ„ÅÑ„Å¶„Åä„Åè„Å†„Åë„Åß„Çà„ÅÑ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">(Branch (Branch Leaf 8 Leaf) 42 Leaf)
</code></pre>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Traversable</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí<code>Tree a</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„ÅØÂâØ‰ΩúÁî®„ÇíÂ∑¶„Åã„ÇâÂè≥„Å´ÁµêÂêà„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>Traversable</code>„Å´ÂÆöÁæ©„Åô„ÇãÂøÖË¶Å„ÅÆ„ÅÇ„ÇãËøΩÂä†„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ‰æùÂ≠òÈñ¢‰øÇ„Åå„ÅÑ„Åè„Å§„Åã„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâË°å„ÅçÊéõ„ÅëÈ†Ü„Å´Êú®„ÇíÂ∑°Âõû„Åô„ÇãÈñ¢Êï∞
<code>traversePreOrder :: forall a m b. Applicative m =&gt; (a -&gt; m b) -&gt; Tree a -&gt; m (Tree b)</code>
„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Å§„Åæ„Çä‰ΩúÁî®„ÅÆÂÆüË°å„ÅØÊ†πÂ∑¶Âè≥„Å®Ë°å„Çè„Çå„ÄÅ
‰ª•Ââç„ÅÆÈÄö„ÇäÊéõ„ÅëÈ†Ü„ÅÆÂ∑°Âõû„ÅÆÊºîÁøí„Åß„Åó„Åü„Çà„ÅÜ„Å™Â∑¶Ê†πÂè≥„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöËøΩÂä†„Åß„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åô„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åó„ÄÅ
Ââç„Å´ÂÆöÁæ©„Åó„ÅüÈñ¢Êï∞„ÅØ‰Ωï„ÇÇÂëº„Å∂ÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñdoË®òÊ≥ï (<code>ado</code>) „ÅØ„Åì„ÅÆÈñ¢Êï∞„ÇíÊõ∏„ÅèÊúÄ„ÇÇÁ∞°Âçò„Å™ÊñπÊ≥ï„Åß„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ‰ΩúÁî®„ÅåÂ∑¶Âè≥Ê†π„Å®ÂÆüË°å„Åï„Çå„ÇãÊú®„ÅÆÂ∏∞„ÇäÊéõ„ÅëÈ†Ü„ÅÆÂ∑°Âõû„ÇíË°å„ÅÜÈñ¢Êï∞
<code>traversePostOrder</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>homeAddress</code>„Éï„Ç£„Éº„É´„Éâ„Åå„Ç™„Éó„Ç∑„Éß„Éä„É´Ôºà<code>Maybe</code>„Çí‰ΩøÁî®Ôºâ„Å™
Êñ∞„Åó„ÅÑÁâà„ÅÆ<code>Person</code>Âûã„Çí„Å§„Åè„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åù„Çå„Åã„Çâ„Åì„ÅÆÊñ∞„Åó„ÅÑ<code>Person</code>„ÇíÊ§úË®º„Åô„ÇãÊñ∞„Åó„ÅÑÁâà„ÅÆ<code>validatePerson</code>Ôºà<code>validatePersonOptionalAddress</code>„Å®ÊîπÂêç„Åó„Åæ„ÅôÔºâ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>traverse</code>„Çí‰Ωø„Å£„Å¶Âûã<code>Maybe a</code>„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÇíÊ§úË®º„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>sequence</code>„ÅÆ„Çà„ÅÜ„Å´ÊåØ„ÇãËàû„ÅÜÈñ¢Êï∞<code>sequenceUsingTraverse</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åü„Å†„Åó<code>traverse</code>„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>traverse</code>„ÅÆ„Çà„ÅÜ„Å´ÊåØ„ÇãËàû„ÅÜÈñ¢Êï∞<code>traverseUsingSequence</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åü„Å†„Åó<code>sequence</code>„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å´„Çà„Çã‰∏¶ÂàóÂá¶ÁêÜ"><a class="header" href="#„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å´„Çà„Çã‰∏¶ÂàóÂá¶ÁêÜ">„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å´„Çà„Çã‰∏¶ÂàóÂá¶ÁêÜ</a></h2>
<p>„Åì„Çå„Åæ„Åß„ÅÆË≠∞Ë´ñ„Åß„ÅØ„ÄÅ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´„ÄåÂâØ‰ΩúÁî®„ÇíÁµêÂêà„Äç„Åï„Åõ„Çã„Åã„ÇíË™¨Êòé„Åô„Çã„Å®„Åç„Å´„ÄÅ
„ÄåÁµêÂêà„Äç(combine) „Å®„ÅÑ„ÅÜÂçòË™û„ÇíÈÅ∏„Å≥„Åæ„Åó„Åü„ÄÇ
„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅ„Åì„Çå„Çâ„ÅÆ„Åô„Åπ„Å¶„ÅÆ‰æã„Å´„Åä„ÅÑ„Å¶„ÄÅ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØ‰ΩúÁî®„Çí„ÄåÈÄ£Èéñ„Äç(sequence) „Åï„Åõ„Çã„ÄÅ
„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´Ë®Ä„Å£„Å¶„ÇÇÂêå„Åò„ÅèÂ¶•ÂΩì„Åß„Åô„ÄÇ
Â∑°ÂõûÂèØËÉΩÈñ¢Êâã„Åå„Éá„Éº„ÇøÊßãÈÄ†„Å´Âæì„Å£„Å¶‰ΩúÁî®„ÇíÈ†ÜÁï™„Å´ÁµêÂêà„Åï„Åõ„Çã<code>sequence</code>Èñ¢Êï∞„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Å®„ÄÅ
„Åì„ÅÆÁõ¥ÊÑüÁöÑÁêÜËß£„Å®„ÅØ‰∏ÄËá¥„Åô„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åó„Åã„Åó‰∏ÄËà¨„Å´„ÅØ„ÄÅ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØ„Åì„Çå„Çà„Çä„ÇÇ„ÇÇ„Å£„Å®‰∏ÄËà¨ÁöÑ„Åß„Åô„ÄÇ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅÆË¶èÂâá„ÅØ„ÄÅ
„Åù„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„ÇãÂâØ‰ΩúÁî®„Å´„Å©„Çì„Å™È†ÜÂ∫è‰ªò„Åë„ÇÇÂº∑Âà∂„Åó„Åæ„Åõ„Çì„ÄÇ
ÂÆüÈöõ„ÄÅ‰∏¶Âàó„Å´ÂâØ‰ΩúÁî®„ÇíÂÆüË°å„Åô„Çã„Åü„ÇÅ„ÅÆ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å®„ÅÑ„ÅÜ„ÇÇ„ÅÆ„ÅØÂ¶•ÂΩì„Å´„Å™„Çä„Åà„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅ
<code>V</code>Ê§úË®ºÈñ¢Êâã„ÅØ„Ç®„É©„Éº„ÅÆ<strong>ÈÖçÂàó</strong>„ÇíËøî„Åó„Åæ„Åô„Åå„ÄÅ
„Åù„ÅÆ‰ª£„Çè„Çä„Å´<code>Set</code>ÂçäÁæ§„ÇíÈÅ∏„Çì„Å†„Å®„Åó„Å¶„ÇÇ„ÇÑ„ÅØ„ÇäÊ≠£Â∏∏„Å´Âãï„Åç„ÄÅ
„Åì„ÅÆ„Å®„Åç„Å©„Çì„Å™È†ÜÂ∫è„Åß„Åù„Çå„Åû„Çå„ÅÆÊ§úË®ºÂô®„ÇíÂÆüË°å„Åó„Å¶„ÇÇÂïèÈ°å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Éá„Éº„ÇøÊßãÈÄ†„Å´ÂØæ„Åó„Å¶‰∏¶Âàó„Å´„Åì„Çå„ÇíÂÆüË°å„Åô„Çã„Åì„Å®„Åï„Åà„Åß„Åç„Çã„ÅÆ„Åß„ÅôÔºÅ</p>
<p>Âà•„ÅÆ‰æã„Å®„Åó„Å¶„ÄÅ<code>parallel</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅØ„ÄÅ
<strong>‰∏¶ÂàóË®àÁÆó</strong>„Çí„Çµ„Éù„Éº„Éà„Åô„Çã<code>Parallel</code>Âûã„ÇØ„É©„Çπ„Çí‰∏é„Åà„Åæ„Åô„ÄÇ
<code>Parallel</code>„ÅØÈñ¢Êï∞<code>parallel</code>„ÇíÊèê‰æõ„Åó„Å¶„Åä„Çä„ÄÅ
‰Ωï„Çâ„Åã„ÅÆ<code>Applicative</code>Èñ¢Êâã„Çí‰Ωø„Å£„Å¶ÂÖ•Âäõ„ÅÆË®àÁÆó„Çí<strong>‰∏¶Âàó„Å´</strong>Ë®àÁÆó„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">f &lt;$&gt; parallel computation1
  &lt;*&gt; parallel computation2
</code></pre>
<p>„Åì„ÅÆË®àÁÆó„ÅØ<code>computation1</code>„Å®<code>computation2</code>„ÇíÈùûÂêåÊúü„Å´‰Ωø„Å£„Å¶ÂÄ§„ÇíË®àÁÆó„ÇíÂßã„ÇÅ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åù„Åó„Å¶‰∏°Êñπ„ÅÆÁµêÊûú„ÅÆË®àÁÆó„ÅåÁµÇ„Çè„Å£„ÅüÊôÇ„Å´„ÄÅÈñ¢Êï∞<code>f</code>„Çí‰Ωø„Å£„Å¶„Å≤„Å®„Å§„ÅÆÁµêÊûú„Å∏„Å®ÁµêÂêà„Åô„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åì„ÅÆËÄÉ„ÅàÊñπ„ÅÆË©≥Á¥∞„ÅØ„ÄÅ
Êú¨Êõ∏„ÅÆÂæåÂçä„Åß<strong>„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÂú∞ÁçÑ</strong>„ÅÆÂïèÈ°å„Å´ÂØæ„Åó„Å¶
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÇíÂøúÁî®„Åô„Çã„Å®„Åç„Å´Ë¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØ‰∏¶Âàó„Å´ÁµêÂêà„Åï„Çå„ÅÜ„ÇãÂâØ‰ΩúÁî®„ÇíÊçïÊçâ„Åô„ÇãËá™ÁÑ∂„Å™ÊñπÊ≥ï„Åß„Åô„ÄÇ</p>
<h2 id="„Åæ„Å®„ÇÅ-5"><a class="header" href="#„Åæ„Å®„ÇÅ-5">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØÊñ∞„Åó„ÅÑËÄÉ„ÅàÊñπ„Çí„Åü„Åè„Åï„ÇìÊâ±„ÅÑ„Åæ„Åó„Åü„ÄÇ</p>
<ul>
<li>Èñ¢Êï∞ÈÅ©Áî®„ÅÆÊ¶ÇÂøµ„ÇíÂâØ‰ΩúÁî®„ÅÆË¶≥Âøµ„ÇíÊçâ„Åà„ÅüÂûãÊßãÁØâÂ≠ê„Å∏„Å®‰∏ÄËà¨Âåñ„Åô„Çã„ÄÅ<strong>„Ç¢„Éó„É™„Ç´
„ÉÜ„Ç£„ÉñÈñ¢Êâã</strong>„ÅÆÊ¶ÇÂøµ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇ</li>
<li>„Éá„Éº„ÇøÊßãÈÄ†„ÅÆÊ§úË®º„Å®„ÅÑ„ÅÜË™≤È°å„Å´„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åå„Å©„ÅÆ„Çà„ÅÜ„Å™Ëß£Ê±∫Á≠ñ„Çí‰∏é„Åà
„Çã„Åã„ÄÅ„Å©„ÅÜ„Åô„Çå„Å∞Âçò‰∏Ä„ÅÆ„Ç®„É©„Éº„ÅÆÂ†±Âëä„Åã„Çâ„Éá„Éº„ÇøÊßãÈÄ†„ÇíÊ®™Êñ≠„Åô„Çã„Åô„Åπ„Å¶„ÅÆ„Ç®„É©„Éº
„ÅÆÂ†±Âëä„Å∏Â§âÊèõ„Åß„Åç„Çã„ÅÆ„Åã„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</li>
<li><code>Traversable</code>Âûã„ÇØ„É©„Çπ„Å´Âá∫‰ºö„ÅÑ„Åæ„Åó„Åü„ÄÇ<strong>Â∑°ÂõûÂèØËÉΩÈñ¢Êâã</strong>„ÅÆËÄÉ„ÅàÊñπ„ÇíÂÜÖÂåÖ„Åô
„Çã„ÇÇ„ÅÆ„Åß„ÅÇ„Çä„ÄÅË¶ÅÁ¥†„ÅåÂâØ‰ΩúÁî®„ÇíÊåÅ„Å§ÂÄ§„ÅÆÁµêÂêà„Å´‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„ÇãÂÆπÂô®„Åß„Åó„Åü„ÄÇ</li>
</ul>
<p>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØÂ§ö„Åè„ÅÆÂïèÈ°å„Å´ÂØæ„Åó„Å¶ÂÑ™„Çå„ÅüËß£Ê±∫Á≠ñ„Çí‰∏é„Åà„ÇãËààÂë≥Ê∑±„ÅÑÊäΩË±°Âåñ„Åß„Åô„ÄÇ
Êú¨Êõ∏„ÇíÈÄö„Åò„Å¶‰ΩïÂ∫¶„ÇÇË¶ã„Çã„Åì„Å®„Å´„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
‰ªäÂõû„ÅÆÂ†¥Âêà„ÄÅ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØÂÆ£Ë®ÄÁöÑ„Å™ÊµÅÂÑÄ„ÅßÊõ∏„ÅèÊâãÊÆµ„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅ
„Åì„Çå„Å´„Çà„Çä<strong>„Å©„ÅÜ„ÇÑ„Å£„Å¶</strong>Ê§úË®º„ÇíË°å„ÅÜ„Åã„Åß„ÅØ„Å™„Åè„ÄÅ
<strong>‰Ωï„Çí</strong>Ê§úË®ºÂô®„ÅåÊ§úË®º„Åô„Åπ„Åç„Å™„ÅÆ„Åã„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åó„Åü„ÄÇ
‰∏ÄËà¨„Å´„ÄÅ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅØ<strong>È†òÂüüÁâπÂåñË®ÄË™û</strong>„ÇíË®≠Ë®à„Åô„Çã‰∏ä„Åß‰æøÂà©„Å™ÈÅìÂÖ∑„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„ÅÆÁ´†„Åß„ÅØ„ÄÅ„Åì„Çå„Å´Èñ¢ÈÄ£„Åô„ÇãËÄÉ„ÅàÊñπ„Åß„ÅÇ„Çã<strong>„É¢„Éä„Éâ</strong>„ÇØ„É©„Çπ„ÇíË¶ã„Å¶„ÄÅ
„Ç¢„Éâ„É¨„ÇπÂ∏≥„ÅÆ‰æã„Çí„Éñ„É©„Ç¶„Ç∂„ÅßÂÆüË°å„Åï„Åõ„Çâ„Çå„Çã„Çà„ÅÜ„Å´Êã°Âºµ„Åó„Åæ„Åó„Çá„ÅÜÔºÅ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="‰ΩúÁî®„É¢„Éä„Éâ"><a class="header" href="#‰ΩúÁî®„É¢„Éä„Éâ">‰ΩúÁî®„É¢„Éä„Éâ</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-6"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-6">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>ÂâçÁ´†„Åß„ÅØ„ÄÅ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™Âûã„ÇÑ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÄÅ
„Éá„Éº„Çø„ÅÆÊ§úË®º„Å™„Å©„ÄÅ<strong>ÂâØ‰ΩúÁî®</strong>„ÇíÊâ±„ÅÑ„ÇíÊäΩË±°Âåñ„Åô„Çã„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÇíÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇ
„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ„Çà„ÇäË°®ÁèæÂäõ„ÅÆÈ´ò„ÅÑÊñπÊ≥ï„ÅßÂâØ‰ΩúÁî®„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆÂà•„ÅÆÊäΩË±°Âåñ„ÄÅ<strong>„É¢„Éä„Éâ</strong>„ÇíÂ∞éÂÖ•„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„ÅÆÁõÆÁöÑ„ÅØ„ÄÅ„Å™„Åú„É¢„Éä„Éâ„Åå‰æøÂà©„Å™ÊäΩË±°Âåñ„Å™„ÅÆ„Åã„Å®„ÅÑ„ÅÜ„Åì„Å®„Å®„ÄÅ
<strong>doË®òÊ≥ï</strong>„Å®„ÅÆÈñ¢‰øÇ„ÇíË™¨Êòé„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-5"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-5">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØ„ÄÅ‰ª•‰∏ã„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>effect</code>: Á´†„ÅÆÂæåÂçä„ÅÆ‰∏ªÈ°å„Åß„ÅÇ„Çã<code>Effect</code>„É¢„Éä„Éâ„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ‰æùÂ≠ò
Èñ¢‰øÇ„ÅØ„ÅÇ„Çâ„ÇÜ„Çã„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÂßã„ÇÅ„Å´Êé≤„Åí„Çâ„Çå„Çã„Åì„Å®„Åå„Çà„Åè„ÅÇ„Çã„ÅÆ„ÅßÔºà„Åì„Çå„Åæ
„Åß„ÅÆÂÖ®„Å¶„ÅÆÁ´†„Åß„ÇÇ‰æùÂ≠òÈñ¢‰øÇ„Å´„ÅÇ„Çä„Åæ„Åó„ÅüÔºâ„ÄÅÊòéÁ§∫ÁöÑ„Å´„Ç§„É≥„Çπ„Éà„Éº„É´„Åó„Å™„Åë„Çå„Å∞
„ÅÑ„Åë„Å™„ÅÑ„Åì„Å®„ÅØÁ®Ä„Åß„Åô„ÄÇ</li>
<li><code>react-basic-hooks</code>: „Ç¢„Éâ„É¨„ÇπÂ∏≥„Ç¢„Éó„É™„Å´‰Ωø„ÅÜWeb„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„Åß„Åô„ÄÇ</li>
</ul>
<h2 id="„É¢„Éä„Éâ„Å®doË®òÊ≥ï"><a class="header" href="#„É¢„Éä„Éâ„Å®doË®òÊ≥ï">„É¢„Éä„Éâ„Å®doË®òÊ≥ï</a></h2>
<p>doË®òÊ≥ï„ÅØ<strong>ÈÖçÂàóÂÜÖÂåÖË°®Ë®ò</strong>„ÇíÊâ±„ÅÜ„Å®„Åç„Å´ÊúÄÂàù„Å´Â∞éÂÖ•„Åï„Çå„Åæ„Åó„Åü„ÄÇÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„ÅØ <code>Data.Array</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ
<code>concatMap</code>Èñ¢Êï∞„ÅÆÊßãÊñáÁ≥ñ„Å®„Åó„Å¶Êèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„ÅÆ‰æã„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ2„Å§„ÅÆ„Çµ„Ç§„Ç≥„É≠„ÇíÊåØ„Å£„Å¶Âá∫„ÅüÁõÆ„ÇíÊï∞„Åà„ÄÅÂá∫„ÅüÁõÆ„ÅÆÂêàË®à„Åå
<code>n</code>„ÅÆ„Å®„Åç„Åù„Çå„ÇíÂæóÁÇπ„Å®„Åô„Çã„Åì„Å®„ÇíËÄÉ„Åà„Åæ„Åô„ÄÇÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÈùûÊ±∫ÂÆöÁöÑ„Å™„Ç¢„É´„Ç¥„É™„Ç∫„É†„Çí‰Ωø„ÅÜ„Å®„Åì„Çå„ÇíÂÆüÁèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<ul>
<li>ÊúÄÂàù„ÅÆÊäïÊì≤„ÅßÂÄ§ <code>x</code>„Çí<strong>ÈÅ∏Êäû</strong>„Åó„Åæ„Åô„ÄÇ</li>
<li>2ÂõûÁõÆ„ÅÆÊäïÊì≤„ÅßÂÄ§ <code>y</code>„Çí<strong>ÈÅ∏Êäû</strong>„Åó„Åæ„Åô„ÄÇ</li>
<li>„ÇÇ„Åó <code>x</code>„Å® <code>y</code>„ÅÆÂíå„Åå <code>n</code>„Å™„ÇâÁµÑ <code>[x, y]</code>„ÇíËøî„Åó„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞Â§±Êïó„Åó„Åæ
„Åô„ÄÇ</li>
</ul>
<p>ÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Åì„ÅÆÈùûÊ±∫ÂÆöÁöÑ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÇíËá™ÁÑ∂„Å´Êõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">import Prelude

import Control.Plus (empty)
import Data.Array ((..))

countThrows :: Int -&gt; Array (Array Int)
countThrows n = do
  x &lt;- 1 .. 6
  y &lt;- 1 .. 6
  if x + y == n
    then pure [ x, y ]
    else empty
</code></pre>
<p>PSCi„Åß„Åì„ÅÆÈñ¢Êï∞„ÅÆÂãï‰Ωú„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Test.Examples

&gt; countThrows 10
[[4,6],[5,5],[6,4]]

&gt; countThrows 12
[[6,6]]
</code></pre>
<p>Ââç„ÅÆÁ´†„Åß„ÅØ„ÄÅ<strong>„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÂÄ§</strong>„Å´ÂØæÂøú„Åó„Åü„Çà„ÇäÂ§ß„Åç„Å™„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„Å∏„Å®
PureScript„ÅÆÈñ¢Êï∞„ÇíÂüã„ÇÅËæº„ÇÄ„ÄÅ
<code>Maybe</code> „Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å´„Å§„ÅÑ„Å¶„ÅÆÁõ¥ÊÑüÁöÑÁêÜËß£„ÇíÈ§ä„ÅÑ„Åæ„Åó„Åü„ÄÇ
ÂêåÊßò„Å´<strong>ÈÖçÂàó„É¢„Éä„Éâ</strong>„Å´„Å§„ÅÑ„Å¶„ÇÇ„ÄÅ
<strong>ÈùûÊ±∫ÂÆöÈÅ∏Êäû</strong>„Å´ÂØæÂøú„Åó„Åü„Çà„ÇäÂ§ß„Åç„Å™„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„Å∏
PureScript„ÅÆÈñ¢Êï∞„ÇíÂüã„ÇÅËæº„ÇÄ„ÄÅ„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å™Áõ¥ÊÑüÁöÑÁêÜËß£„ÇíÂæó„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰∏ÄËà¨„Å´„ÄÅ„ÅÇ„ÇãÂûãÊßãÁØâÂ≠ê <code>m</code>„ÅÆ„É¢„Éä„Éâ„ÅØ„ÄÅÂûã <code>m a</code>„ÅÆÂÄ§„ÇíÊåÅ„Å§doË®òÊ≥ï„Çí‰Ωø„ÅÜÊñπÊ≥ï„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
‰∏ä„ÅÆÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Åß„ÅØ„ÄÅ„Åô„Åπ„Å¶„ÅÆË°å„Å´‰Ωï„Çâ„Åã„ÅÆÂûã <code>a</code>„Å´„Å§„ÅÑ„Å¶„ÅÆÂûã <code>Array a</code>„ÅÆË®àÁÆó„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰∏ÄËà¨„Å´„ÄÅdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„ÅÆ„Åô„Åπ„Å¶„ÅÆË°å„ÅØ„ÄÅ‰Ωï„Çâ„Åã„ÅÆÂûã <code>a</code>„Å®„É¢„Éä„Éâ <code>m</code>„Å´„Å§„ÅÑ„Å¶„ÄÅÂûã <code>m a</code>„ÅÆË®àÁÆó„ÇíÂê´„Çì„Åß„ÅÑ„Åæ„Åô„ÄÇ
„É¢„Éä„Éâ <code>m</code>„ÅØ„Åô„Åπ„Å¶„ÅÆË°å„ÅßÂêå„Åò„Åß„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„ÇìÔºà„Å§„Åæ„Çä„ÄÅÂâØ‰ΩúÁî®„ÅÆÁ®ÆÈ°û„ÅØÂõ∫ÂÆö„Åï„Çå„Åæ„ÅôÔºâ„Åå„ÄÅÂûã
<code>a</code>„ÅØÁï∞„Å™„Çã„Åì„Å®„ÇÇ„ÅÇ„Çä„Åæ„ÅôÔºàË®Ä„ÅÑÊèõ„Åà„Çã„Å®„ÄÅÂÄã„ÄÖ„ÅÆË®àÁÆó„ÅØÁï∞„Å™„ÇãÂûã„ÅÆÁµêÊûú„ÇíÊåÅ„Å§„Åì„Å®„Åå„Åß„Åç„Åæ„ÅôÔºâ„ÄÇ</p>
<p>‰ª•‰∏ã„ÅØdoË®òÊ≥ï„ÅÆÂà•„ÅÆ‰æã„Åß„Åô„ÄÇ
‰ªäÂõû„ÅØÂûãÊßãÁØâÂ≠ê <code>Maybe</code>„Å´ÈÅ©Áî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
XML„Éé„Éº„Éâ„ÇíË°®„ÅôÂûã <code>XML</code>„Å®Ê¨°„ÅÆÈñ¢Êï∞„Åå„ÅÇ„Çã„Å®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">child :: XML -&gt; String -&gt; Maybe XML
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„Éé„Éº„Éâ„ÅÆÂ≠ê„ÅÆË¶ÅÁ¥†„ÇíÊé¢„Åó„ÄÅ
„ÇÇ„Åó„Åù„ÅÆ„Çà„ÅÜ„Å™Ë¶ÅÁ¥†„ÅåÂ≠òÂú®„Åó„Å™„Åë„Çå„Å∞ <code>Nothing</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÂ†¥Âêà„ÄÅdoË®òÊ≥ï„Çí‰Ωø„ÅÜ„Å®Ê∑±„ÅÑÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„ÅüË¶ÅÁ¥†„ÇíÊ§úÁ¥¢„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇXMLÊñáÊõ∏„Å®„Åó„Å¶Á¨¶Âè∑Âåñ„Åï„Çå„ÅüÂà©Áî®ËÄÖÊÉÖÂ†±„Åã„Çâ„ÄÅÂà©Áî®ËÄÖ„ÅÆ‰Ωè„Çì„Åß„ÅÑ„ÇãÂ∏ÇÁî∫Êùë„ÇíË™≠„ÅøÂèñ„Çä„Åü„ÅÑ„Å®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p><code>userCity</code>Èñ¢Êï∞„ÅØÂ≠ê„ÅÆË¶ÅÁ¥†„Åß„ÅÇ„Çã <code>profile</code>„ÇíÊé¢„Åó„ÄÅ <code>profile</code>Ë¶ÅÁ¥†„ÅÆ‰∏≠„Å´„ÅÇ„Çã <code>address</code>Ë¶ÅÁ¥†„ÄÅÊúÄÂæå„Å´
<code>address</code>Ë¶ÅÁ¥†„Åã„Çâ <code>city</code>Ë¶ÅÁ¥†„ÇíÊé¢„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Çâ„ÅÆË¶ÅÁ¥†„ÅÆ„ÅÑ„Åö„Çå„Åã„ÅåÊ¨†ËêΩ„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅËøî„ÇäÂÄ§„ÅØ
<code>Nothing</code>„Å´„Å™„Çä„Åæ„Åô„ÄÇ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞„ÄÅËøî„ÇäÂÄ§„ÅØ <code>city</code>„Éé„Éº„Éâ„Åã„Çâ <code>Just</code>„Çí‰Ωø„Å£„Å¶ÊßãÁØâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂæå„ÅÆË°å„Å´„ÅÇ„Çã<code>pure</code>Èñ¢Êï∞„ÅØ„ÄÅ„Åô„Åπ„Å¶„ÅÆ<code>Applicative</code>Èñ¢Êâã„Å´„Å§„ÅÑ„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åó„Åü„ÄÇ<code>Maybe</code>„ÅÆ<code>Applicative</code>Èñ¢Êâã„ÅÆ<code>pure</code>Èñ¢Êï∞„ÅØ<code>Just</code>„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„Åä„Çä„ÄÅÊúÄÂæå„ÅÆË°å„Çí
<code>Just city</code>„Å∏Â§âÊõ¥„Åó„Å¶„ÇÇÂêå„Åò„Çà„ÅÜ„Å´Ê≠£„Åó„ÅèÂãï„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„É¢„Éä„ÉâÂûã„ÇØ„É©„Çπ"><a class="header" href="#„É¢„Éä„ÉâÂûã„ÇØ„É©„Çπ">„É¢„Éä„ÉâÂûã„ÇØ„É©„Çπ</a></h2>
<p><code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">class Apply m &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

class (Applicative m, Bind m) &lt;= Monad m
</code></pre>
<p>„Åì„Åì„ÅßÈçµ„Å®„Å™„ÇãÈñ¢Êï∞„ÅØ <code>Bind</code>Âûã„ÇØ„É©„Çπ„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÊºîÁÆóÂ≠ê <code>bind</code>„Åß„ÄÅ
<code>Functor</code>Âèä„Å≥ <code>Apply</code>Âûã„ÇØ„É©„Çπ„Å´„ÅÇ„Çã <code>&lt;$&gt;</code>„ÇÑ <code>&lt;*&gt;</code>„Å™„Å©„ÅÆÊºîÁÆóÂ≠ê„Å®Âêå„ÅòÊßò„Å´
<code>Prelude</code>„Åß„ÅØ <code>&gt;&gt;=</code>„Å®„Åó„Å¶ <code>bind</code>„ÅÆ‰∏≠ÁΩÆ„ÅÆÂà•Âêç„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅØ„ÄÅ„Åô„Åß„Å´Ë¶ã„Å¶„Åç„Åü <code>Applicative</code>Âûã„ÇØ„É©„Çπ„ÅÆÊìç‰Ωú„Åß <code>Bind</code>„ÇíÊã°Âºµ„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Bind</code>Âûã„ÇØ„É©„Çπ„ÅÆ‰æã„Çí„ÅÑ„Åè„Å§„ÅãË¶ã„Å¶„Åø„Çã„ÅÆ„Åå„Çè„Åã„Çä„ÇÑ„Åô„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇÈÖçÂàó„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>Bind</code>„ÅÆÂ¶•ÂΩì„Å™ÂÆöÁæ©„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">instance bindArray :: Bind Array where
  bind xs f = concatMap f xs
</code></pre>
<p>„Åì„Çå„ÅØ‰ª•Ââç„Å´„Åª„ÅÆ„ÇÅ„Åã„Åó„ÅüÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Å® <code>concatMap</code>Èñ¢Êï∞„ÅÆÈñ¢‰øÇ„ÇíË™¨Êòé„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Maybe</code>ÂûãÊßãÁØâÂ≠ê„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>Bind</code>„ÅÆÂÆüË£Ö„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">instance bindMaybe :: Bind Maybe where
  bind Nothing  _ = Nothing
  bind (Just a) f = f a
</code></pre>
<p>„Åì„ÅÆÂÆöÁæ©„ÅØÊ¨†ËêΩ„Åó„ÅüÂÄ§„ÅådoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„ÇíÈÄö„Åò„Å¶‰ºùÊí≠„Åô„Çã„Å®„ÅÑ„ÅÜÁõ¥ÊÑüÁöÑÁêÜËß£„ÇíË£è‰ªò„Åë„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<p><code>Bind</code>Âûã„ÇØ„É©„Çπ„Å®doË®òÊ≥ï„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´Èñ¢‰øÇ„Åó„Å¶„ÅÑ„Çã„Åã„ÇíË¶ã„Å¶Ë°å„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇÊúÄÂàù„Å´‰Ωï„Çâ„Åã„ÅÆË®àÁÆóÁµêÊûú„Åã„Çâ„ÅÆÂÄ§„ÅÆÊùüÁ∏õ„Åã„ÇâÂßã„Åæ„ÇãÁ∞°Âçò„Å™doË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-hs">do value &lt;- someComputation
   whatToDoNext
</code></pre>
<p>PureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØ„Åì„ÅÆ„Çà„ÅÜ„Å™„Éë„Çø„Éº„É≥„ÇíË¶ã„Å§„Åë„Çã„Åü„Å≥„Å´„Ç≥„Éº„Éâ„ÇíÊ¨°„Å´„Çà„ÅÜ„Å´ÁΩÆ„ÅçÊèõ„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">bind someComputation \value -&gt; whatToDoNext
</code></pre>
<p>„ÅÇ„Çã„ÅÑ„ÅØ‰∏≠ÁΩÆ„ÅßÊõ∏„Åè„Å®‰ª•‰∏ã„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">someComputation &gt;&gt;= \value -&gt; whatToDoNext
</code></pre>
<p>„Åì„ÅÆË®àÁÆó <code>whatToDoNext</code>„ÅØ <code>value</code>„Å´‰æùÂ≠ò„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>Ë§áÊï∞„ÅÆÊùüÁ∏õ„ÅåÈñ¢‰øÇ„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Åì„ÅÆË¶èÂâá„ÅØÂÖàÈ†≠„ÅÆ„Åª„ÅÜ„Åã„ÇâË§áÊï∞ÂõûÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ‰æã„Åà„Å∞„ÄÅÂÖà„Åª„Å©Ë¶ã„Åü <code>userCity</code>„ÅÆ‰æã„Åß„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ËÑ±Á≥ñ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root =
  child root &quot;profile&quot; &gt;&gt;= \prof -&gt;
    child prof &quot;address&quot; &gt;&gt;= \addr -&gt;
      child addr &quot;city&quot; &gt;&gt;= \city -&gt;
        pure city
</code></pre>
<p>doË®òÊ≥ï„Çí‰Ωø„Å£„Å¶Ë°®Áèæ„Åï„Çå„Åü„Ç≥„Éº„Éâ„ÅØ„ÄÅ
<code>&gt;&gt;=</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„Å£„Å¶Êõ∏„Åã„Çå„ÅüÂêå„ÅòÊÑèÂë≥„ÅÆ„Ç≥„Éº„Éâ„Çà„Çä„Åó„Å∞„Åó„Å∞Ë™≠„Åø„ÇÑ„Åô„Åè„Å™„Çã„Åì„Å®„ÇÇÁâπÁ≠Ü„Åô„Åπ„ÅçÁÇπ„Åß„Åô„ÄÇ
‰∏ÄÊñπ„Åß„ÄÅÊòéÁ§∫ÁöÑ„Å´ <code>&gt;&gt;=</code>„Çí‰Ωø„Å£„Å¶ÊùüÁ∏õ„ÅåÊõ∏„Åè„Å®„ÄÅ
„Çà„Åè<strong>„Éù„Ç§„É≥„Éà„Éï„É™„Éº</strong>ÂΩ¢Âºè„Åß„Ç≥„Éº„Éâ„ÅåÊõ∏„Åë„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ
„Åü„Å†„Åó„ÄÅË™≠„Åø„ÇÑ„Åô„Åï„Å´„ÅØ„ÇÑ„ÅØ„ÇäÊ≥®ÊÑè„Åå„ÅÑ„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="„É¢„Éä„ÉâÂâá"><a class="header" href="#„É¢„Éä„ÉâÂâá">„É¢„Éä„ÉâÂâá</a></h2>
<p><code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅØ<strong>„É¢„Éä„ÉâÂâá</strong> (monad laws) „Å®Âëº„Å∞„Çå„Çã3„Å§„ÅÆË¶èÂâá„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅØ <code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅÆÁêÜ„Å´„Åã„Å™„Å£„ÅüÂÆüË£Ö„Åã„Çâ‰Ωï„ÇíÊúüÂæÖ„Åß„Åç„Çã„Åã„ÇíÊïô„Åà„Å¶„Åè„Çå„Åæ„Åô„ÄÇ</p>
<p>doË®òÊ≥ï„Çí‰ΩøÁî®„Åó„Å¶„Åì„Çå„Çâ„ÅÆË¶èÂâá„ÇíË™¨Êòé„Åó„Å¶„ÅÑ„Åè„ÅÆ„ÅåÊúÄ„ÇÇÁ∞°Âçò„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h3 id="Âçò‰ΩçÂÖÉÂæã"><a class="header" href="#Âçò‰ΩçÂÖÉÂæã">Âçò‰ΩçÂÖÉÂæã</a></h3>
<p><strong>Âè≥Âçò‰ΩçÂÖÉÂâá</strong> (right-identity law) „Åå3„Å§„ÅÆË¶èÂâá„ÅÆ‰∏≠„ÅßÊúÄ„ÇÇÁ∞°Âçò„Åß„Åô„ÄÇ
„Åì„ÅÆË¶èÂâá„ÅØdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„ÅÆÊúÄÂæå„ÅÆÂºè„Åß„ÅÇ„Çå„Å∞„ÄÅ
<code>pure</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÇíÊéíÈô§„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Å®Ë®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">do
  x &lt;- expr
  pure x
</code></pre>
<p>Âè≥Âçò‰ΩçÂÖÉÂâá„ÅØ„ÄÅ„Åì„ÅÆÂºè„ÅØÂçò„Å™„Çã <code>expr</code>„Å®Âêå„Åò„Å†„Å®Ë®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><strong>Â∑¶Âçò‰ΩçÂÖÉÂâá</strong> (left-identity law) „ÅØ„ÄÅ„ÇÇ„Åó„Åù„Çå„ÅådoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„ÅÆÊúÄÂàù„ÅÆÂºè„Åß„ÅÇ„Çå„Å∞„ÄÅ
<code>pure</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÇíÈô§Âéª„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Å®Ëø∞„Åπ„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">do
  x &lt;- pure y
  next
</code></pre>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØ„ÄÅÂêçÂâç<code>x</code>„ÇíÂºè<code>y</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Åü<code>next</code>„Å®Âêå„Åò„Åß„Åô„ÄÇ</p>
<p>ÊúÄÂæå„ÅÆË¶èÂâá„ÅØ<strong>ÁµêÂêàÂâá</strong> (associativity law) „Åß„Åô„ÄÇ
„Åì„Çå„ÅØÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„ÅüdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„Çí„Å©„ÅÜÊâ±„ÅÜ„ÅÆ„Åã„Å´„Å§„ÅÑ„Å¶Êïô„Åà„Å¶„Åè„Çå„Åæ„Åô„ÄÇ
„Åì„ÅÆË¶èÂâá„ÅåËø∞„Åπ„Å¶„ÅÑ„Çã„ÅÆ„ÅØ‰ª•‰∏ã„ÅÆ„Ç≥„Éº„ÉâÁâá„ÅÆ„Åì„Å®„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">c1 = do
  y &lt;- do
    x &lt;- m1
    m2
  m3
</code></pre>
<p>‰∏äË®ò„ÅÆ„Ç≥„Éº„ÉâÁâá„ÅØ„ÄÅÊ¨°„ÅÆ„Ç≥„Éº„Éâ„Å®Âêå„Åò„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">c2 = do
  x &lt;- m1
  y &lt;- m2
  m3
</code></pre>
<p>„Åì„Çå„ÇâË®àÁÆó„Å´„ÅØ„Åù„Çå„Åû„Çå„ÄÅ3„Å§„ÅÆ„É¢„Éä„Éâ„ÅÆÂºè <code>m1</code>„ÄÅ <code>m2</code>„ÄÅ <code>m3</code>„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Å©„Å°„Çâ„ÅÆÂ†¥Âêà„Åß„ÇÇ <code>m1</code>„ÅÆÁµêÊûú„ÅØÂêçÂâç <code>x</code>„Å´ÊùüÁ∏õ„Åï„Çå„ÄÅ
<code>m2</code>„ÅÆÁµêÊûú„ÅØÂêçÂâç <code>y</code>„Å´ÊùüÁ∏õ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p><code>c1</code>„Åß„ÅØ2„Å§„ÅÆÂºè <code>m1</code>„Å® <code>m2</code>„Åå„Åù„Çå„Åû„Çå„ÅÆdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØÂÜÖ„Å´„Ç∞„É´„Éº„ÉóÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>c2</code>„Åß„ÅØ <code>m1</code>„ÄÅ <code>m2</code>„ÄÅ <code>m3</code>„ÅÆ3„Å§„Åô„Åπ„Å¶„ÅÆÂºè„ÅåÂêå„ÅòdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„Å´Áèæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÁµêÂêàË¶èÂâá„ÅØÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„ÅüdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„Çí„Åì„ÅÆ„Çà„ÅÜ„Å´ÂçòÁ¥îÂåñ„Åó„Å¶„ÇÇ
ÂïèÈ°å„Å™„ÅÑ„Åì„Å®„ÇíË®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><strong>Ê≥®ÊÑè</strong>: doË®òÊ≥ï„Çí<code>bind</code>„ÅÆÂëº„Å≥Âá∫„Åó„Å∏„Å®ËÑ±Á≥ñ„Åô„ÇãÂÆöÁæ©„Å´„Çà„Çä„ÄÅ <code>c1</code>„Å® <code>c2</code>„ÅØ„ÅÑ„Åö„Çå„ÇÇÊ¨°„ÅÆ„Ç≥„Éº„Éâ„Å®Âêå„Åò„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">c3 = do
  x &lt;- m1
  do
    y &lt;- m2
    m3
</code></pre>
<h2 id="„É¢„Éä„Éâ„ÅßÁï≥„ÅøËæº„ÇÄ"><a class="header" href="#„É¢„Éä„Éâ„ÅßÁï≥„ÅøËæº„ÇÄ">„É¢„Éä„Éâ„ÅßÁï≥„ÅøËæº„ÇÄ</a></h2>
<p>ÊäΩË±°ÁöÑ„Å´„É¢„Éä„Éâ„ÇíÊâ±„ÅÜ‰æã„Å®„Åó„Å¶„ÄÅ
„Åì„ÅÆÁØÄ„Åß„ÅØ <code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅÆ‰Ωï„Çâ„Åã„ÅÆÂûãÊßãÁØâÂ≠ê„Å´Ê©üËÉΩ„Åô„Çã„ÅÇ„ÇãÈñ¢Êï∞„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„É¢„Éä„Éâ„Å´„Çà„Çã„Ç≥„Éº„Éâ„ÅåÂâØ‰ΩúÁî®„Çí‰º¥„ÅÜ„Äå„Çà„ÇäÂ§ß„Åç„Å™Ë®ÄË™û„Äç„Åß„ÅÆ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Å®ÂØæÂøú„Åó„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜÁõ¥ÊÑüÁöÑÁêÜËß£„ÇíË£úÂº∑„Åó„Åæ„Åô„Åó„ÄÅ„É¢„Éä„Éâ„Å´„Çà„Çã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Åå„ÇÇ„Åü„Çâ„Åô‰∏ÄËà¨ÊÄß„ÇÇÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Åã„Çâ <code>foldM</code>„Å®Âëº„Å∞„Çå„ÇãÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ‰ª•ÂâçÊâ±„Å£„Åü
<code>foldl</code>Èñ¢Êï∞„Çí„É¢„Éä„Éâ„ÅÆÊñáËÑà„Å∏„Å®‰∏ÄËà¨Âåñ„Åó„Åæ„Åô„ÄÇÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foldM :: forall m a b. Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; List b -&gt; m a
foldl :: forall   a b.            (a -&gt; b -&gt;   a) -&gt; a -&gt; List b -&gt;   a
</code></pre>
<p>„É¢„Éä„Éâ <code>m</code>„ÅåÁèæ„Çå„Å¶„ÅÑ„ÇãÁÇπ„ÇíÈô§„ÅÑ„Å¶„ÄÅ <code>foldl</code>„ÅÆÂûã„Å®Âêå„Åò„Åß„ÅÇ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>Áõ¥ÊÑüÁöÑ„Å´„ÅØ„ÄÅ <code>foldM</code>„ÅØ„Åï„Åæ„Åñ„Åæ„Å™ÂâØ‰ΩúÁî®„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„Å´ÂØæÂøú„Åó„ÅüÊñáËÑà„Åß„ÅÆÈÖçÂàó„ÅÆÁï≥„ÅøËæº„Åø„ÇíË°å„ÅÜ„Å®Êçâ„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰æã„Å®„Åó„Å¶ <code>m</code>„Åå <code>Maybe</code>„Åß„ÅÇ„Çã„Å®„Åô„Çã„Å®„ÄÅ„Åì„ÅÆÁï≥„ÅøËæº„Åø„ÅØ„Åù„Çå„Åû„Çå„ÅÆÊÆµÈöé„Åß
<code>Nothing</code>„ÇíËøî„Åô„Åì„Å®„ÅßÂ§±Êïó„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åù„Çå„Åû„Çå„ÅÆÊÆµÈöé„Åß„ÅØ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÁµêÊûú„ÇíËøî„Åó„Åæ„Åô„Åã„Çâ„ÄÅ„Åù„Çå„ÇÜ„ÅàÁï≥„ÅøËæº„Åø„ÅÆÁµêÊûú„ÇÇ„Ç™„Éó„Ç∑„Éß„Éä„É´„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„ÇÇ„Åó <code>m</code>„Å®„Åó„Å¶ÈÖçÂàó„ÅÆÂûãÊßãÁØâÂ≠ê
<code>Array</code>„ÇíÈÅ∏„Å∂„Å®„Åô„Çã„Å®„ÄÅÁï≥„ÅøËæº„Åø„ÅÆ„Åù„Çå„Åû„Çå„ÅÆÊÆµÈöé„ÅßË§áÊï∞„ÅÆÁµêÊûú„ÇíËøî„Åô„Åì„Å®„Åå„Åß„Åç„ÄÅÁï≥„ÅøËæº„Åø„ÅØÁµêÊûú„Åù„Çå„Åû„Çå„Å´ÂØæ„Åó„Å¶Ê¨°„ÅÆÊâãÈ†Ü„ÇíÁ∂ôÁ∂ö„Åó„Åæ„Åô„ÄÇÊúÄÂæå„Å´„ÄÅÁµêÊûú„ÅÆÈõÜ„Åæ„Çä„ÅØ„ÄÅÂèØËÉΩ„Å™ÁµåË∑Ø„Åô„Åπ„Å¶„ÅÆÁï≥„ÅøËæº„Åø„Åã„ÇâÊßãÊàê„Åï„Çå„Çã„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„Ç∞„É©„Éï„ÅÆËµ∞Êüª„Å®ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„ÅôÔºÅ</p>
<p><code>foldM</code>„ÇíÊõ∏„Åè„Å´„ÅØ„ÄÅÂçò„Å´ÂÖ•Âäõ„ÅÆ„É™„Çπ„Éà„Å´„Å§„ÅÑ„Å¶Â†¥ÂêàÂàÜ„Åë„Çí„Åô„Çã„Å†„Åë„Åß„Åô„ÄÇ</p>
<p>„É™„Çπ„Éà„ÅåÁ©∫„Å™„Çâ„ÄÅÂûã <code>a</code>„ÅÆÁµêÊûú„ÇíÁîüÊàê„Åô„Çã„Åü„ÇÅ„ÅÆÈÅ∏ÊäûËÇ¢„ÅØ„Å≤„Å®„Å§„Åó„Åã„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
Á¨¨2ÂºïÊï∞„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foldM _ a Nil = pure a
</code></pre>
<p>„Å™„Åä<code>a</code>„Çí„É¢„Éä„Éâ <code>m</code>„Åæ„ÅßÊåÅ„Å°‰∏ä„Åí„Çã„Åü„ÇÅ„Å´ <code>pure</code>„Çí‰Ωø„Çè„Å™„Åè„Å¶„ÅØ„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</p>
<p>„É™„Çπ„Éà„ÅåÁ©∫„Åß„Å™„ÅÑÂ†¥Âêà„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„ÅãÔºü
„Åù„ÅÆÂ†¥Âêà„ÄÅÂûã <code>a</code>„ÅÆÂÄ§„ÄÅÂûã <code>b</code>„ÅÆÂÄ§„ÄÅÂûã <code>a -&gt; b -&gt; m a</code>„ÅÆÈñ¢Êï∞„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„ÇÇ„Åó„Åì„ÅÆÈñ¢Êï∞„ÇíÈÅ©Áî®„Åô„Çã„Å®„ÄÅÂûã <code>m a</code>„ÅÆ„É¢„Éä„Éâ„ÅÆÁµêÊûú„ÇíÊâã„Å´ÂÖ•„Çå„Çã„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆË®àÁÆó„ÅÆÁµêÊûú„ÇíÈÄÜÂêë„Åç„ÅÆÁü¢Âç∞ <code>&lt;-</code>„ÅßÊùüÁ∏õ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„ÅÇ„Å®„ÅØ„É™„Çπ„Éà„ÅÆÊÆã„Çä„Å´ÂØæ„Åó„Å¶ÂÜçÂ∏∞„Åô„Çã„Å†„Åë„Åß„Åô„ÄÇÂÆüË£Ö„ÅØÁ∞°Âçò„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">foldM f a (b : bs) = do
  a' &lt;- f a b
  foldM f a' bs
</code></pre>
<p>„Å™„Åä„ÄÅdoË®òÊ≥ï„ÇíÈô§„Åë„Å∞„ÄÅ„Åì„ÅÆÂÆüË£Ö„ÅØÈÖçÂàó„Å´ÂØæ„Åô„Çã <code>foldl</code>„ÅÆÂÆüË£Ö„Å®„Åª„Å®„Çì„Å©Âêå„Åò„Åß„Åô„ÄÇ</p>
<p>PSCi„Åß„Åì„Çå„ÇíÂÆöÁæ©„Åó„ÄÅË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
‰ª•‰∏ã„Åß„ÅØ‰æã„Å®„Åó„Å¶„ÄÅÈô§ÁÆóÂèØËÉΩ„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„Å¶„ÄÅÂ§±Êïó„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´ <code>Maybe</code>ÂûãÊßãÁØâÂ≠ê„Çí‰Ωø„ÅÜ„ÄÅ
Êï¥Êï∞„ÅÆ„ÄåÂÆâÂÖ®„Å™Èô§ÁÆó„ÄçÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-hs">safeDivide :: Int -&gt; Int -&gt; Maybe Int
safeDivide _ 0 = Nothing
safeDivide a b = Just (a / b)
</code></pre>
<p>„Åì„Çå„Åß„ÄÅ <code>foldM</code>„ÅßÂÆâÂÖ®„Å™Èô§ÁÆó„ÅÆÁπ∞„ÇäËøî„Åó„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Test.Examples
&gt; import Data.List (fromFoldable)

&gt; foldM safeDivide 100 (fromFoldable [5, 2, 2])
(Just 5)

&gt; foldM safeDivide 100 (fromFoldable [2, 0, 4])
Nothing
</code></pre>
<p>„ÇÇ„Åó„ÅÑ„Åö„Çå„Åã„ÅÆÊôÇÁÇπ„ÅßÊï¥Êï∞„Å´„Å™„Çâ„Å™„ÅÑÈô§ÁÆó„ÅåË°å„Çè„Çå„Çà„ÅÜ„Å®„Åó„Åü„Çâ„ÄÅ
<code>foldM safeDivide</code>Èñ¢Êï∞„ÅØ <code>Nothing</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞„ÄÅÈô§ÁÆó„ÇíÁπ∞„ÇäËøî„Åó„ÅüÁ¥ØÁ©ç„ÅÆÁµêÊûú„Çí<code>Just</code>ÊßãÁØâÂ≠ê„Å´ÂåÖ„Çì„ÅßËøî„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="„É¢„Éä„Éâ„Å®„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ"><a class="header" href="#„É¢„Éä„Éâ„Å®„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ">„É¢„Éä„Éâ„Å®„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ</a></h2>
<p>„ÇØ„É©„ÇπÈñì„Å´‰∏ä‰Ωç„ÇØ„É©„ÇπÈñ¢‰øÇ„ÅÆÂäπËÉΩ„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅ
<code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ <code>Apply</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅ„ÅÇ„Çâ„ÇÜ„Çã<code>Monad</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´
„ÄåÁÑ°Êñô„Åß„Äç„Å§„ÅÑ„Å¶„Åè„Çã<code>Apply</code>Âûã„ÇØ„É©„Çπ„ÅÆÂÆüË£Ö„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ<code>ap</code>Èñ¢Êï∞„Å´„Çà„Çä‰∏é„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">ap :: forall m a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
ap mf ma = do
  f &lt;- mf
  a &lt;- ma
  pure (f a)
</code></pre>
<p>„ÇÇ„Åó <code>m</code>„Åå <code>Monad</code>Âûã„ÇØ„É©„Çπ„Å´Âõ∫Âü∑„Åó„Å¶„ÅÑ„Çå„Å∞„ÄÅ
<code>ap</code>„Åß‰∏é„Åà„Çâ„Çå„Çã<code>m</code>„Å´„Å§„ÅÑ„Å¶Â¶•ÂΩì„Å™ <code>Apply</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂ≠òÂú®„Åó„Åæ„Åô„ÄÇ</p>
<p>ËààÂë≥„ÅÆ„ÅÇ„ÇãË™≠ËÄÖ„ÅØ„ÄÅ„Åì„Çå„Åæ„ÅßÁôªÂ†¥„Åó„Åü <code>Array</code>„ÄÅ <code>Maybe</code>„ÄÅ <code>Either e</code>„Å®„ÅÑ„Å£„Åü„É¢„Éä„Éâ„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åì„ÅÆ <code>ap</code>„Åå
<code>apply</code>„Å®‰∏ÄËá¥„Åô„Çã„Åì„Å®„ÇíÁ¢∫„Åã„ÇÅ„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„ÇÇ„Åó„Åô„Åπ„Å¶„ÅÆ„É¢„Éä„Éâ„Åå„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åß„ÇÇ„ÅÇ„Çã„Å™„Çâ„ÄÅ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å´„Å§„ÅÑ„Å¶„ÅÆÁõ¥ÊÑüÁöÑÁêÜËß£„Çí
„Åô„Åπ„Å¶„ÅÆ„É¢„Éä„Éâ„Å´„Å§„ÅÑ„Å¶„ÇÇÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅØ„Åö„Åß„Åô„ÄÇ
Áâπ„Å´„ÄÅ„É¢„Éä„Éâ„ÅåÊõ¥„Å™„ÇãÂâØ‰ΩúÁî®„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅßÂ¢óÂº∑„Åï„Çå„Åü„Äå„Çà„ÇäÂ§ß„Åç„Å™Ë®ÄË™û„Äç„Åß„ÅÆ
„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„Å®„ÅÑ„Çç„ÅÑ„Çç„Å™ÊÑèÂë≥„Åß‰∏ÄËá¥„Åô„Çã„Åì„Å®„Çí‰∫àÊÉ≥„Åô„Çã„ÅÆ„ÅØ„ÇÇ„Å£„Å®„ÇÇ„Åß„Åô„ÄÇ
<code>map</code>„Å® <code>apply</code>„Çí‰Ωø„Å£„Å¶„ÄÅ
ÂºïÊï∞„Åå‰ªªÊÑèÂÄã„ÅÆÈñ¢Êï∞„Çí„Åì„ÅÆÊñ∞„Åó„ÅÑË®ÄË™û„Å∏„Å®ÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅØ„Åö„Åß„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó„ÄÅ„É¢„Éä„Éâ„ÅØ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åß„Åß„Åç„Çã„Åì„Å®‰ª•‰∏ä„ÇíË°å„ÅÜ„Åì„Å®„Åå„Åß„Åç„ÄÅ
ÈáçË¶Å„Å™ÈÅï„ÅÑ„ÅØdoË®òÊ≥ï„ÅÆÊßãÊñá„ÅßÂº∑Ë™ø„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Âà©Áî®ËÄÖÊÉÖÂ†±„ÇíÁ¨¶Âè∑Âåñ„Åó„ÅüXMLÊñáÊõ∏„Åã„ÇâÂà©Áî®ËÄÖ„ÅÆÈÉΩÂ∏Ç„ÇíÊ§úÁ¥¢„Åô„Çã„ÄÅ
<code>userCity</code>„ÅÆ‰æã„Å´„Å§„ÅÑ„Å¶„ÇÇ„ÅÜ‰∏ÄÂ∫¶ËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-hs">userCity :: XML -&gt; Maybe XML
userCity root = do
  prof &lt;- child root &quot;profile&quot;
  addr &lt;- child prof &quot;address&quot;
  city &lt;- child addr &quot;city&quot;
  pure city
</code></pre>
<p>doË®òÊ≥ï„Åß„ÅØ2Áï™ÁõÆ„ÅÆË®àÁÆó„ÅåÊúÄÂàù„ÅÆÁµêÊûú <code>prof</code>„Å´‰æùÂ≠ò„Åó„ÄÅ
3Áï™ÁõÆ„ÅÆË®àÁÆó„Åå2Áï™ÁõÆ„ÅÆË®àÁÆó„ÅÆÁµêÊûú
<code>addr</code>„Å´‰æùÂ≠ò„Åô„Çã„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å™„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>Applicative</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„Å†„Åë„Çí‰Ωø„ÅÜ„ÅÆ„Åß„ÅØ„ÄÅ
„Åì„ÅÆ„Çà„ÅÜ„Å™‰ª•Ââç„ÅÆÂÄ§„Å∏„ÅÆ‰æùÂ≠ò„ÅØ‰∏çÂèØËÉΩ„Åß„Åô„ÄÇ</p>
<p><code>pure</code>„Å® <code>apply</code>„Å†„Åë„Çí‰Ωø„Å£„Å¶ <code>userCity</code>„ÇíÊõ∏„Åì„ÅÜ„Å®„Åó„Å¶„Åø„Çå„Å∞„ÄÅ
„Åì„Çå„Åå‰∏çÂèØËÉΩ„Åß„ÅÇ„Çã„Åì„Å®„Åå„Çè„Åã„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åå„Åß„Åç„Çã„ÅÆ„ÅØÈñ¢Êï∞„ÅÆ‰∫í„ÅÑ„Å´Áã¨Á´ã„Åó„ÅüÂºïÊï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„Å†„Åë„Åß„Åô„Åå„ÄÅ
„É¢„Éä„Éâ„ÅØ„ÇÇ„Å£„Å®ËààÂë≥Ê∑±„ÅÑ„Éá„Éº„Çø‰æùÂ≠òÈñ¢‰øÇ„Å´Èñ¢„Çè„ÇãË®àÁÆó„ÇíÊõ∏„Åè„Åì„Å®„ÇíÂèØËÉΩ„Å´„Åó„Åæ„Åô„ÄÇ</p>
<p>Ââç„ÅÆÁ´†„Åß„ÅØ <code>Applicative</code>Âûã„ÇØ„É©„Çπ„ÅØ‰∏¶ÂàóÂá¶ÁêÜ„ÇíË°®Áèæ„Åß„Åç„Çã„Åì„Å®„ÇíË¶ã„Åæ„Åó„Åü„ÄÇ
ÊåÅ„Å°‰∏ä„Åí„Çâ„Çå„ÅüÈñ¢Êï∞„ÅÆÂºïÊï∞„ÅØ‰∫í„ÅÑ„Å´Áã¨Á´ã„Åó„Å¶„ÅÑ„Åæ„Åô„Åã„Çâ„ÄÅ
„Åì„Çå„ÅØ„Åæ„Åï„Å´„Åù„ÅÆÈÄö„Çä„Åß„Åô„ÄÇ
<code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅØË®àÁÆó„ÅåÂâç„ÅÆË®àÁÆó„ÅÆÁµêÊûú„Å´‰æùÂ≠ò„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„Åã„Çâ„ÄÅ
Âêå„Åò„Çà„ÅÜ„Å´„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
„É¢„Éä„Éâ„ÅØÂâØ‰ΩúÁî®„ÇíÈ†ÜÁï™„Å´ÁµÑ„ÅøÂêà„Çè„Åõ„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</p>
<h2 id="ÊºîÁøí-21"><a class="header" href="#ÊºîÁøí-21">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ3„Å§‰ª•‰∏ä„ÅÆË¶ÅÁ¥†„Åå„ÅÇ„ÇãÈÖçÂàó„ÅÆ3„Å§ÁõÆ„ÅÆË¶ÅÁ¥†„ÇíËøî„ÅôÈñ¢Êï∞<code>third</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Èñ¢Êï∞„ÅØÈÅ©Âàá„Å™<code>Maybe</code>Âûã„ÅßËøî„Åó„Åæ„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>arrays</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ<code>Data.Array</code>„É¢„Ç∏„É•„Éº„É´„Åã„Çâ<code>head</code>„Å®<code>tail</code>Èñ¢Êï∞„ÅÆÂûã„ÇíË¶ã„Å§„ÅëÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÇíÁπã„Åí„Çã„Å´„ÅØ<code>Maybe</code>„É¢„Éä„Éâ„Å®ÂÖ±„Å´doË®òÊ≥ï„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ‰∏ÄÊé¥„Åø„ÅÆÁ°¨Ë≤®„Çí‰Ωø„Å£„Å¶„Åß„Åç„ÇãÂèØËÉΩ„Å™„Åô„Åπ„Å¶„ÅÆÂêàË®à„ÇíÊ±∫ÂÆö„Åô„ÇãÈñ¢Êï∞ <code>possibleSums</code>„Çí„ÄÅ
<code>foldM</code>„Çí‰Ωø„Å£„Å¶Êõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇÂÖ•Âäõ„ÅÆÁ°¨Ë≤®„ÅØ„ÄÅÁ°¨Ë≤®„ÅÆ‰æ°ÂÄ§„ÅÆÈÖçÂàó„Å®„Åó„Å¶‰∏é„Åà„Çâ„Çå„Åæ„Åô„ÄÇ„Åì„ÅÆÈñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÁµêÊûú„Å´„Å™„Çâ„Å™„Åè„Å¶„ÅØ„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; possibleSums []
[0]

&gt; possibleSums [1, 2, 10]
[0,1,2,3,10,11,12,13]
</code></pre>
<p><strong>„Éí„É≥„Éà</strong>Ôºö<code>foldM</code>„Çí‰Ωø„ÅÜ„Å®1Ë°å„Åß„Åì„ÅÆÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„ÅåÂèØËÉΩ„Åß„Åô„ÄÇ
ÈáçË§á„ÇíÂèñ„ÇäÈô§„ÅÑ„Åü„Çä„ÄÅÁµêÊûú„Çí‰∏¶„Å≥Êõø„Åà„Åü„Çä„Åô„Çã„ÅÆ„Å´„ÄÅ
<code>nub</code>Èñ¢Êï∞„ÇÑ <code>sort</code>Èñ¢Êï∞„Çí‰Ωø„ÅÑ„Åü„Åè„Å™„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Maybe</code>ÂûãÊßãÁØâÂ≠ê„Å´„Å§„ÅÑ„Å¶„ÄÅ <code>ap</code>Èñ¢Êï∞„Å® <code>apply</code>ÊºîÁÆóÂ≠ê„Åå‰∏ÄËá¥„Åô„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÅØ„ÉÜ„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>maybe</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã
<code>Maybe</code>Âûã„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>Monad</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÄÅ
„É¢„Éä„ÉâÂâá„ÇíÊ∫Ä„Åü„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÊ§úË®º„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÅØ„ÉÜ„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÈÖçÂàó‰∏ä„ÅÆ <code>filter</code>„ÅÆÈñ¢Êï∞„Çí‰∏ÄËà¨Âåñ„Åó„ÅüÈñ¢Êï∞ <code>filterM</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÊ¨°„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">filterM :: forall m a. Monad m =&gt; (a -&gt; m Boolean) -&gt; List a -&gt; m (List a)
</code></pre>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ„Åô„Åπ„Å¶„ÅÆ„É¢„Éä„Éâ„Å´„ÅØÊ¨°„Åß‰∏é„Åà„Çâ„Çå„Çã„Çà„ÅÜ„Å™Êó¢ÂÆö„ÅÆ<code>Functor</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">map f a = do
  x &lt;- a
  pure (f x)
</code></pre>
<p>„É¢„Éä„ÉâÂâá„Çí‰Ωø„Å£„Å¶„ÄÅ„Åô„Åπ„Å¶„ÅÆ„É¢„Éä„Éâ„ÅåÊ¨°„ÇíÊ∫Ä„Åü„Åô„Åì„Å®„ÇíË®ºÊòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-hs">lift2 f (pure a) (pure b) = pure (f a b)
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ <code>Applly</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ‰∏ä„ÅßÂÆöÁæ©„Åï„Çå„Åü <code>ap</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>lift2</code>„ÅåÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åü„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-hs">lift2 :: forall f a b c. Apply f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
lift2 f a b = f &lt;$&gt; a &lt;*&gt; b
</code></pre>
<p><strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÅØ„ÉÜ„Çπ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
</ol>
<h2 id="„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™‰ΩúÁî®"><a class="header" href="#„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™‰ΩúÁî®">„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™‰ΩúÁî®</a></h2>
<p>„Åì„Åì„Åß„ÅØPureScript„ÅÆ‰∏≠Ê†∏„Å®„Å™„ÇãÈáçË¶Å„Å™„É¢„Éä„Éâ„ÄÅ <code>Effect</code>„É¢„Éä„Éâ„Å´„Å§„ÅÑ„Å¶Ë¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Effect</code>„É¢„Éä„Éâ„ÅØ <code>Effect</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åã„Å§„Å¶„ÅØ„ÅÑ„Çè„ÇÜ„Çã<strong>„Éç„Ç§„ÉÜ„Ç£„Éñ</strong>ÂâØ‰ΩúÁî®„ÇíÁÆ°ÁêÜ„Åó„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ
Haskell„Å´È¶¥Êüì„Åø„Åå„ÅÇ„Çå„Å∞„ÄÅ„Åì„Çå„ÅØ<code>IO</code>„É¢„Éä„Éâ„Å®ÂêåÁ≠â„ÅÆ„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™ÂâØ‰ΩúÁî®„Å®„ÅØ‰Ωï„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
„Åì„ÅÆÂâØ‰ΩúÁî®„ÅØPureScriptÁâπÊúâ„ÅÆÂºè„Åã„ÇâJavaScript„ÅÆÂºè„ÇíÂå∫Âà•„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
PureScript„ÅÆÂºè„ÅØÊ¶Ç„Åó„Å¶ÂâØ‰ΩúÁî®„Å®„ÅØÁÑ°Á∏Å„Å™„ÅÆ„Åß„Åô„ÄÇ
„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™‰ΩúÁî®„ÅÆ‰æã„Çí‰ª•‰∏ã„Å´Á§∫„Åó„Åæ„Åô„ÄÇ</p>
<ul>
<li>„Ç≥„É≥„ÇΩ„Éº„É´ÂÖ•Âá∫Âäõ</li>
<li>‰π±Êï∞ÁîüÊàê</li>
<li>‰æãÂ§ñ</li>
<li>Â§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„ÅÆË™≠„ÅøÊõ∏„Åç</li>
</ul>
<p>„Åæ„Åü„ÄÅ„Éñ„É©„Ç¶„Ç∂„Åß„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li>DOMÊìç‰Ωú</li>
<li>XMLHttpRequest / AJAXÂëº„Å≥Âá∫„Åó</li>
<li>WebSocket„Å´„Çà„ÇãÁõ∏‰∫í‰ΩúÁî®</li>
<li>Local Storage„ÅÆË™≠„ÅøÊõ∏„Åç</li>
</ul>
<p>„Åô„Åß„Å´„Äå„Éç„Ç§„ÉÜ„Ç£„Éñ„Åß„Å™„ÅÑ„ÄçÂâØ‰ΩúÁî®„ÅÆ‰æã„Å´„Å§„ÅÑ„Å¶„ÅØÊï∞Â§ö„ÅèË¶ã„Å¶„Åç„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>Maybe</code>„Éá„Éº„ÇøÂûã„ÅßË°®Áèæ„Åï„Çå„ÇãÁúÅÁï•ÂèØËÉΩ„Å™ÂÄ§</li>
<li><code>Either</code>„Éá„Éº„ÇøÂûã„ÅßË°®Áèæ„Åï„Çå„Çã„Ç®„É©„Éº</li>
<li>ÈÖçÂàó„ÇÑ„É™„Çπ„Éà„ÅßË°®Áèæ„Åï„Çå„ÇãÂ§ö‰æ°Èñ¢Êï∞</li>
</ul>
<p>„Åì„Çå„Çâ„ÅÆÂå∫Âà•„ÅØ„Çè„Åã„Çä„Å´„Åè„ÅÑ„ÅÆ„ÅßÊ≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ‰æãÂ§ñ„ÅÆÂΩ¢„ÅßJavaScript„ÅÆÂºè„ÅÆÂâØ‰ΩúÁî®„Å®„Å™„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åù„ÅÆÊÑèÂë≥„Åß„ÅØ‰æãÂ§ñ„ÅØ„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™ÂâØ‰ΩúÁî®„ÇíË°®„Åó„Å¶„ÅÑ„Å¶„ÄÅ
<code>Effect</code>„Çí‰ΩøÁî®„Åó„Å¶Ë°®Áèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åó„Åã„Åó„ÄÅ
<code>Either</code>„Çí‰ΩøÁî®„Åó„Å¶ÂÆüË£Ö„Åï„Çå„Åü„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅØJavaScript„É©„É≥„Çø„Ç§„É†„ÅÆÂâØ‰ΩúÁî®„Åß„ÅØ„Å™„Åè„ÄÅ
<code>Effect</code>„Çí‰Ωø„ÅÜ„Çπ„Çø„Ç§„É´„Åß„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂÆüË£Ö„Åô„Çã„ÅÆ„ÅØÈÅ©Âàá„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Åù„ÅÆ„Åü„ÇÅ„ÄÅ„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™„ÅÆ„ÅØ‰ΩúÁî®Ëá™‰Ωì„Å®„ÅÑ„ÅÜ„Çà„Çä„ÄÅÂÆüË°åÊôÇ„Å´„Å©„ÅÆ„Çà„ÅÜ„Å´ÂÆüË£Ö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„Åß„Åô„ÄÇ</p>
<h2 id="ÂâØ‰ΩúÁî®„Å®Á¥îÁ≤ãÊÄß"><a class="header" href="#ÂâØ‰ΩúÁî®„Å®Á¥îÁ≤ãÊÄß">ÂâØ‰ΩúÁî®„Å®Á¥îÁ≤ãÊÄß</a></h2>
<p>PureScript„ÅÆ„Çà„ÅÜ„Å™Ë®ÄË™û„ÅåÁ¥îÁ≤ã„Åß„ÅÇ„Çã„Å®„Åô„Çã„Å®„ÄÅÁñëÂïè„ÅåÊµÆ„Åã„Çì„Åß„Åç„Åæ„Åô„ÄÇÂâØ‰ΩúÁî®„Åå„Å™„ÅÑ„Å™„Çâ„ÄÅ„Å©„ÅÜ„ÇÑ„Å£„Å¶ÂΩπ„Å´Á´ã„Å§ÂÆüÈöõ„ÅÆ„Ç≥„Éº„Éâ„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„Å®„ÅÑ„ÅÜ„ÅÆ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
<p>„Åù„ÅÆÁ≠î„Åà„ÅØPureScript„ÅÆÁõÆÁöÑ„ÅØÂâØ‰ΩúÁî®„ÇíÊéíÈô§„Åô„Çã„Åì„Å®„Åß„ÅØ„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅÁ¥îÁ≤ã„Å™Ë®àÁÆó„Å®ÂâØ‰ΩúÁî®„ÅÆ„ÅÇ„ÇãË®àÁÆó„Å®„ÇíÂûã„Ç∑„Çπ„ÉÜ„É†„Å´„Åä„ÅÑ„Å¶Âå∫Âà•„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å™ÊñπÊ≥ï„Åß„ÄÅÂâØ‰ΩúÁî®„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„ÇíÁõÆÁöÑ„Å®„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åô„ÄÇ„Åì„ÅÆÊÑèÂë≥„Åß„ÄÅË®ÄË™û„ÅØ„ÅÇ„Åè„Åæ„ÅßÁ¥îÁ≤ã„Å†„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>ÂâØ‰ΩúÁî®„ÅÆ„ÅÇ„ÇãÂÄ§„ÅØ„ÄÅÁ¥îÁ≤ã„Å™ÂÄ§„Å®„ÅØÁï∞„Å™„ÇãÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Çà„ÅÜ„Å´„ÄÅ‰æã„Åà„Å∞ÂâØ‰ΩúÁî®„ÅÆ„ÅÇ„ÇãÂºïÊï∞„ÇíÈñ¢Êï∞„Å´Ê∏°„Åô„Åì„Å®„ÅØ„Åß„Åç„Åö„ÄÅ
‰∫àÊúü„Åõ„ÅöÂâØ‰ΩúÁî®„ÇíÊåÅ„Å§„Çà„ÅÜ„Å™„Åì„Å®„ÅåËµ∑„Åì„Çâ„Å™„Åè„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p><code>Effect</code>„É¢„Éä„Éâ„ÅßÁÆ°ÁêÜ„Åï„Çå„ÅüÂâØ‰ΩúÁî®„ÇíÂÆüË°å„Åô„ÇãÂîØ‰∏Ä„ÅÆÊñπÊ≥ï„ÅØ„ÄÅ
Âûã <code>Effect a</code>„ÅÆË®àÁÆó„ÇíJavaScript„Åã„ÇâÂÆüË°å„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>Spago„Éì„É´„Éâ„ÉÑ„Éº„É´Ôºà„ÇÑ‰ªñ„ÅÆ„ÉÑ„Éº„É´Ôºâ„ÅØÊó©ÈÅì„ÇíÊèê‰æõ„Åó„Å¶„Åä„Çä„ÄÅ
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆËµ∑ÂãïÊôÇ„Å´<code>main</code>Ë®àÁÆó„ÇíÂëº„Å≥Âá∫„Åô„Åü„ÇÅ„ÅÆËøΩÂä†„ÅÆJavaScript„Ç≥„Éº„Éâ„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
<code>main</code>„ÅØ <code>Effect</code>„É¢„Éä„Éâ„Åß„ÅÆË®àÁÆó„Åß„ÅÇ„Çã„Åì„Å®„ÅåË¶ÅÊ±Ç„Åï„Çå„Åæ„Åô„ÄÇ</p>
<h2 id="‰ΩúÁî®„É¢„Éä„Éâ-1"><a class="header" href="#‰ΩúÁî®„É¢„Éä„Éâ-1">‰ΩúÁî®„É¢„Éä„Éâ</a></h2>
<p><code>Effect</code>„ÅØÂâØ‰ΩúÁî®„ÅÆ„ÅÇ„ÇãË®àÁÆó„ÇíÂÖÖÂàÜ„Å´Âûã‰ªò„Åë„Åô„ÇãAPI„ÇíÊèê‰æõ„Åô„Çã„Å®ÂêåÊôÇ„Å´„ÄÅ
ÂäπÁéáÁöÑ„Å™JavaScript„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
<p>È¶¥Êüì„Åø„ÅÆ„ÅÇ„Çã<code>log</code>Èñ¢Êï∞„Åã„ÇâËøî„ÇãÂûã„Çí„ÇÇ„ÅÜÂ∞ë„ÅóË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>Effect</code>„ÅØ„Åì„ÅÆÈñ¢Êï∞„Åå„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™‰ΩúÁî®„ÇíÁîü„ÅøÂá∫„Åô„Åì„Å®„ÇíÁ§∫„Åó„Å¶„Åä„Çä„ÄÅ
„Åì„ÅÆÂ†¥Âêà„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´IO„Åß„Åô„ÄÇ
<code>Unit</code>„ÅØ„ÅÑ„Åã„Å™„Çã<em>ÊÑèÂë≥„ÅÆ„ÅÇ„Çã</em>„Éá„Éº„Çø„ÇÇËøî„Çâ„Å™„ÅÑ„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Unit</code>„ÅØC„ÄÅJava„Å™„Å©‰ªñ„ÅÆË®ÄË™û„Åß„ÅÆ<code>void</code>„Ç≠„Éº„ÉØ„Éº„Éâ„Å®‰ºº„Åü„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Å®„Åó„Å¶ËÄÉ„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">log :: String -&gt; Effect Unit
</code></pre>
<blockquote>
<p><em>‰ΩôË´á</em> Ôºö„Çà„Çä‰∏ÄËà¨ÁöÑ„Å™Ôºà„Åù„Åó„Å¶„Çà„ÇäËæº„ÅøÂÖ•„Å£„ÅüÂûã„ÅÆÔºâ<code>Effect.Class.Console</code>„ÅÆ<code>log</code>Èñ¢Êï∞„ÇíIDE„Åã„ÇâÊèêÊ°à„Åï„Çå„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ
„Åì„Çå„ÅØÂü∫Êú¨ÁöÑ„Å™<code>Effect</code>„É¢„Éä„Éâ„ÇíÊâ±„ÅÜÈöõ„ÅØ<code>Effect.Console</code>„Åã„Çâ„ÅÆÈñ¢Êï∞„Å®‰∫§ÊèõÂèØËÉΩ„Åß„Åô„ÄÇ
„Çà„Çä‰∏ÄËà¨ÁöÑ„Å™„Éê„Éº„Ç∏„Éß„É≥„Åå„ÅÇ„Çã„Åì„Å®„ÅÆÁêÜÁî±„ÅØ„Äå„É¢„Éä„Éâ„Å™ÂÜíÈô∫„ÄçÁ´†„ÅÆ„Äå„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Äç„Å´„Å§„ÅÑ„Å¶Ë™≠„Çì„Å†„ÅÇ„Å®„Å´„Çà„ÇäÊòé„Çâ„Åã„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Åß„Åó„Çá„ÅÜ„ÄÇ
Â•ΩÂ•áÂøÉ„ÅÆ„ÅÇ„ÇãÔºà„Åù„Åó„Å¶„Åõ„Å£„Åã„Å°„Å™ÔºâË™≠ËÄÖ„ÅÆ„Åü„ÇÅ„Å´Ë®Ä„ÅÜ„Å®„ÄÅ„Åì„Çå„ÅØ<code>Effect</code>„Å´<code>MonadEffect</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çã„Åã„ÇâÊ©üËÉΩ„Åô„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">log :: forall m. MonadEffect m =&gt; String -&gt; m Unit
</code></pre>
</blockquote>
<p>„Åù„Çå„Åß„ÅØÊÑèÂë≥„ÅÆ„ÅÇ„Çã„Éá„Éº„Çø„ÇíËøî„Åô<code>Effect</code>„ÇíËÄÉ„Åà„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>Effect.Random</code>„ÅÆ<code>random</code>Èñ¢Êï∞„ÅØ„É©„É≥„ÉÄ„É†„Å™<code>Number</code>„ÇíÁîü„ÅøÂá∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">random :: Effect Number
</code></pre>
<p>‰ª•‰∏ã„ÅØÂÆåÂÖ®„Å™„Éó„É≠„Ç∞„É©„É†„ÅÆ‰æã„Åß„ÅôÔºà„Åì„ÅÆÁ´†„ÅÆÊºîÁøí„Éï„Ç©„É´„ÉÄ„ÅÆ<code>test/Random.purs</code>„Å´„ÅÇ„Çä„Åæ„ÅôÔºâ„ÄÇ</p>
<pre><code class="language-hs">module Test.Random where

import Prelude
import Effect (Effect)
import Effect.Random (random)
import Effect.Console (logShow)

main :: Effect Unit
main = do
  n &lt;- random
  logShow n
</code></pre>
<p><code>Effect</code>„ÅØ„É¢„Éä„Éâ„Å™„ÅÆ„Åß„ÄÅdoË®òÊ≥ï„Çí‰Ωø„Å£„Å¶Âê´„Åæ„Çå„Çã„Éá„Éº„Çø„ÇíÈñãÂ∞Å„Åó„ÄÅ
„Åù„Çå„Åã„Çâ„Åì„ÅÆ„Éá„Éº„Çø„Çí‰ΩúÁî®„ÅÆ„ÅÇ„Çã<code>logShow</code>Èñ¢Êï∞„Å´Ê∏°„Åó„Åæ„Åô„ÄÇ
Ê∞óÂàÜËª¢Êèõ„Å´„ÄÅ‰ª•‰∏ã„ÅØ<code>bind</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„Å£„Å¶Êõ∏„Åã„Çå„ÅüÂêåÁ≠â„Å™„Ç≥„Éº„Éâ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">main :: Effect Unit
main = random &gt;&gt;= logShow
</code></pre>
<p>„Åì„Çå„ÇíÊâãÂÖÉ„ÅßËµ∞„Çâ„Åõ„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-shell">spago run --main Test.Random
</code></pre>
<p>„Ç≥„É≥„ÇΩ„Éº„É´„Å´Âá∫Âäõ <code>0.0</code>„Å® <code>1.0</code>„ÅÆÈñì„ÅßÁÑ°‰ΩúÁÇ∫„Å´ÈÅ∏„Å∞„Çå„ÅüÊï∞„ÅåË°®Á§∫„Åï„Çå„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<blockquote>
<p>‰ΩôË´áÔºö<code>spago run</code>„ÅØÊó¢ÂÆö„Åß<code>Main</code>„É¢„Ç∏„É•„Éº„É´„Å®„Åù„ÅÆ‰∏≠„ÅÆ<code>main</code>Èñ¢Êï∞„ÇíÊé¢Á¥¢„Åó„Åæ„Åô„ÄÇ
<code>--main</code>„Éï„É©„Ç∞„Åß‰ª£Êõø„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÇíÂÖ•Âè£„Å®„Åó„Å¶ÊåáÂÆö„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„ÄÅ
‰∏ä„ÅÆ‰æã„Åß„ÅØ„Åù„ÅÜ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ‰ª£Êõø„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÇÇ„Åæ„Åü<code>main</code>Èñ¢Êï∞„ÇíÂê´„Çì„Åß„ÅÑ„Çã„Åì„Å®„Å´„ÅØÊ≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</blockquote>
<p>„Å™„Åä„Äå„É©„É≥„ÉÄ„É†„Å™„ÄçÔºàÊäÄË°ìÁöÑ„Å´„ÅØÁñë‰ºº„É©„É≥„ÉÄ„É†„Å™Ôºâ„Éá„Éº„Çø„Çí‰∏çÊµÑ„Å™‰ΩúÁî®‰ªò„Åç„ÅÆ„Ç≥„Éº„Éâ„Å´Ë®¥„Åà„Çã„Åì„Å®„Å™„ÅèÁîüÊàê„Åô„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô„ÄÇ
„Åì„ÅÆÊäÄÊ≥ï„ÅØ„Äå„ÉÜ„Çπ„Éà„ÇíÁîüÊàê„Åô„Çã„ÄçÁ´†„ÅßÊäº„Åï„Åà„Åæ„Åô„ÄÇ</p>
<p>‰ª•ÂâçË®ÄÂèä„Åó„Åü„Çà„ÅÜ„Å´<code>Effect</code>„É¢„Éä„Éâ„ÅØPureScript„ÅßÊ†∏ÂøÉÁöÑ„Å™ÈáçË¶Å„Åï„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Å™„ÅúÊ†∏ÂøÉ„Åã„Å®„ÅÑ„ÅÜ„Å®„ÄÅ„Åù„Çå„ÅØPureScript„ÅÆ<code>Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ</code>„Å®„ÇÑ„Çä„Å®„Çä„Åô„Çã‰∏ä„Åß„ÅÆÂ∏∏Â•óÊâãÊÆµ„Å†„Åã„Çâ„Åß„Åô„ÄÇ
<code>Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ</code>„ÅØ„Éó„É≠„Ç∞„É©„É†„ÇíÂÆüË°å„Åó„Åü„ÇäÂâØ‰ΩúÁî®„ÇíÁô∫Áîü„Åï„Åõ„Åü„Çä„Åô„Çã‰ªïÁµÑ„Åø„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
<code>Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ</code>„Çí‰Ωø„ÅÜ„Åì„Å®„ÅØÈÅø„Åë„Çã„ÅÆ„ÅåÊúõ„Åæ„Åó„ÅÑ„ÅÆ„Åß„Åô„Åå„ÄÅ
„Å©„ÅÜÂãï„Åç„Å©„ÅÜ‰Ωø„ÅÜ„ÅÆ„ÅãÁêÜËß£„Åô„Çã„Åì„Å®„ÇÇ„Åæ„ÅüÊ•µ„ÇÅ„Å¶Â§ß‰∫ã„Å™„Åì„Å®„Åß„Åô„ÅÆ„Åß„ÄÅ
ÂÆüÈöõ„Å´PureScript„Åß‰Ωï„ÅãÂãï„Åã„ÅôÂâç„Å´„Åù„ÅÆÁ´†„ÇíË™≠„Åæ„Çå„Çã„Åì„Å®„Çí„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ
Ë¶Å„ÅØ<code>Effect</code>„É¢„Éä„Éâ„ÅØÁµêÊßãÂçòÁ¥î„Å™„ÅÆ„Åß„Åô„ÄÇ
„ÅÑ„Åè„Å§„Åã„ÅÆ„ÅäÂä©„ÅëÈñ¢Êï∞„Åå„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ„Åù„Çå„ÇíÂ∑Æ„ÅóÁΩÆ„ÅÑ„Å¶„ÇÇÂâØ‰ΩúÁî®„ÇíÂÜÖÂåÖ„Åô„Çã„Åì„Å®‰ª•Â§ñ„Å´„ÅØÂ§ö„Åè„ÅÆ„Åì„Å®„Çí„Åó„Åæ„Åõ„Çì„ÄÇ</p>
<h2 id="‰æãÂ§ñ"><a class="header" href="#‰æãÂ§ñ">‰æãÂ§ñ</a></h2>
<p>2„Å§„ÅÆ<strong>„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™</strong>ÂâØ‰ΩúÁî®„ÅåÁµ°„ÇÄ<code>node-fs</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆÈñ¢Êï∞„ÇíË™ø„Åπ„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„Åì„Åß„ÅÆÂâØ‰ΩúÁî®„ÅØÂèØÂ§âÁä∂ÊÖã„ÅÆË™≠„ÅøÂèñ„Çä„Å®‰æãÂ§ñ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; String -&gt; Effect String
</code></pre>
<p>„ÇÇ„ÅóÂ≠òÂú®„Åó„Å™„ÅÑ„Éï„Ç°„Ç§„É´„ÇíË™≠„ÇÄ„Åì„Å®„ÇíË©¶„Åø„Çã„Å®‚Ä¶‚Ä¶</p>
<pre><code class="language-hs">import Node.Encoding (Encoding(..))
import Node.FS.Sync (readTextFile)

main :: Effect Unit
main = do
  lines &lt;- readTextFile UTF8 &quot;iDoNotExist.md&quot;
  log lines
</code></pre>
<p>‰ª•‰∏ã„ÅÆ‰æãÂ§ñ„Å´ÈÅ≠ÈÅá„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">    throw err;
    ^
Error: ENOENT: no such file or directory, open 'iDoNotExist.md'
...
  errno: -2,
  syscall: 'open',
  code: 'ENOENT',
  path: 'iDoNotExist.md'
</code></pre>
<p>„Åì„ÅÆ‰æãÂ§ñ„Çí„ÅÜ„Åæ„ÅèÁÆ°ÁêÜ„Åô„Çã„Å´„ÅØ„ÄÅ
ÊΩúÂú®ÁöÑ„Å´ÂïèÈ°å„Åå„ÅÇ„Çã„Ç≥„Éº„Éâ„Çí<code>try</code>„Å´ÂåÖ„ÇÅ„Å∞„ÅÑ„Åö„Çå„ÅÆÂá∫Âäõ„ÇÇÂà∂Âæ°„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  result &lt;- try $ readTextFile UTF8 &quot;iDoNotExist.md&quot;
  case result of
    Right lines -&gt; log $ &quot;Contents: \n&quot; &lt;&gt; lines
    Left  error -&gt; log $ &quot;Couldn't open file. Error was: &quot; &lt;&gt; message error
</code></pre>
<p><code>try</code>„ÅØ<code>Effect</code>„ÇíËµ∞„Çâ„Åõ„Å¶Ëµ∑„Åì„Çä„ÅÜ„Çã‰æãÂ§ñ„Çí<code>Left</code>ÂÄ§„Å®„Åó„Å¶Ëøî„Åó„Åæ„Åô„ÄÇ
„ÇÇ„ÅóË®àÁÆó„ÅåÊàêÂäü„Åô„Çå„Å∞ÁµêÊûú„ÅØ<code>Right</code>„Å´ÂåÖ„Åæ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">try :: forall a. Effect a -&gt; Effect (Either Error a)
</code></pre>
<p>Ëá™Ââç„ÅÆ‰æãÂ§ñ„ÇíÁîüÊàê„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅØ<code>Data.List.head</code>„ÅÆ‰ª£ÊõøÂÆüË£Ö„Åß„ÄÅ
<code>Maybe</code>„ÅÆÂÄ§„ÅÆ<code>Nothing</code>„ÇíËøî„Åô‰ª£„Çè„Çä„Å´„É™„Çπ„Éà„ÅåÁ©∫„ÅÆ„Å®„Åç‰æãÂ§ñ„ÇíÊäï„Åí„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">exceptionHead :: List Int -&gt; Effect Int
exceptionHead l = case l of
  x : _ -&gt; pure x
  Nil -&gt; throwException $ error &quot;empty list&quot;
</code></pre>
<p>„Åü„Å†„Åó<code>exceptionHead</code>Èñ¢Êï∞„ÅØ„Å©„Åì„Åã„Åó„ÇâÈùûÂÆüÁî®ÁöÑ„Å™‰æã„Åß„Åô„ÄÇ
„Å®„ÅÑ„ÅÜ„ÅÆ„ÇÇ„ÄÅPureScript„ÅÆ„Ç≥„Éº„Éâ„Åß‰æãÂ§ñ„ÇíÁîüÊàê„Åô„Çã„ÅÆ„ÅØÈÅø„Åë„ÄÅ
‰ª£„Çè„Çä„Å´<code>Either</code>„ÇÑ<code>Maybe</code>„ÅÆ„Çà„ÅÜ„Å™„Éç„Ç§„ÉÜ„Ç£„Éñ„Åß„Å™„ÅÑ‰ΩúÁî®„Åß
„Ç®„É©„Éº„ÇÑÊ¨†„Åë„ÅüÂÄ§„Çí‰Ωø„ÅÜ„ÅÆ„Åå‰∏ÄÁï™„Å†„Åã„Çâ„Åß„Åô„ÄÇ</p>
<h2 id="ÂèØÂ§âÁä∂ÊÖã"><a class="header" href="#ÂèØÂ§âÁä∂ÊÖã">ÂèØÂ§âÁä∂ÊÖã</a></h2>
<p>‰∏≠Ê†∏„É©„Ç§„Éñ„É©„É™„Å´„ÅØ <code>ST</code>‰ΩúÁî®„Å®„ÅÑ„ÅÜ„Åæ„ÅüÂà•„ÅÆ‰ΩúÁî®„ÇÇÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>ST</code>‰ΩúÁî®„ÅØÂ§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„ÇíÊìç‰Ωú„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇÁ¥îÁ≤ãÈñ¢Êï∞„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÇíÁü•„Å£„Å¶„ÅÑ„Çã„Å™„Çâ„ÄÅÂÖ±Êúâ„Åï„Çå„ÇãÂ§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„ÅØÂïèÈ°å„ÇíÂºï„ÅçËµ∑„Åì„Åó„ÇÑ„Åô„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇÇÁü•„Å£„Å¶„ÅÑ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅ
<code>ST</code>‰ΩúÁî®„ÅØÂûã„Ç∑„Çπ„ÉÜ„É†„Çí‰Ωø„Å£„Å¶ÂÆâÂÖ®„Åß<strong>Â±ÄÊâÄÁöÑ„Å™</strong>Áä∂ÊÖãÂ§âÂåñ„ÇíÂèØËÉΩ„Å´„Åó„ÄÅÁä∂ÊÖã„ÅÆÂÖ±Êúâ„ÇíÂà∂Èôê„Åô„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p><code>ST</code>‰ΩúÁî®„ÅØ
<code>Control.Monad.ST</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´Âãï‰Ωú„Åô„Çã„Åã„ÇíÁ¢∫Ë™ç„Åô„Çã„Å´„ÅØ„ÄÅ„Åù„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂûã„ÇíË¶ã„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">new :: forall a r. a -&gt; ST r (STRef r a)

read :: forall a r. STRef r a -&gt; ST r a

write :: forall a r. a -&gt; STRef r a -&gt; ST r a

modify :: forall r a. (a -&gt; a) -&gt; STRef r a -&gt; ST r a
</code></pre>
<p><code>new</code>„ÅØÂûã <code>STRef r a</code>„ÅÆÂ§âÊõ¥ÂèØËÉΩ„Å™ÂèÇÁÖßÂå∫Áîª„ÇíÊñ∞„Åó„Åè‰Ωú„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ
<code>STRef r a</code>„ÅØ <code>read</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶Áä∂ÊÖã„ÇíË™≠„ÅøÂèñ„Å£„Åü„Çä„ÄÅ
<code>write</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇÑ <code>modify</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅßÁä∂ÊÖã„ÇíÂ§âÊõ¥„Åô„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ
Âûã <code>a</code>„ÅØÂå∫Áîª„Å´Ê†ºÁ¥ç„Åï„Çå„ÅüÂÄ§„ÅÆÂûã„Åß„ÄÅ
Âûã <code>r</code>„ÅØÂûã„Ç∑„Çπ„ÉÜ„É†„Åß<strong>„É°„É¢„É™È†òÂüü</strong>Ôºà„Åæ„Åü„ÅØ<strong>„Éí„Éº„Éó</strong>Ôºâ„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰æã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇÂ∞è„Åï„Å™ÊôÇÈñìÂàª„Åø„ÅßÁ∞°Âçò„Å™Êõ¥Êñ∞Èñ¢Êï∞„ÅÆÂÆüË°å„Çí‰ΩïÂ∫¶„ÇÇÁπ∞„ÇäËøî„Åô„Åì„Å®„Å´„Çà„Å£„Å¶„ÄÅÈáçÂäõ„Å´Âæì„Å£„Å¶ËêΩ‰∏ã„Åô„ÇãÁ≤íÂ≠ê„ÅÆËêΩ‰∏ã„ÅÆÂãï„Åç„Çí„Ç∑„Éü„É•„É¨„Éº„Éà„Åó„Åü„ÅÑ„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>Á≤íÂ≠ê„ÅÆ‰ΩçÁΩÆ„Å®ÈÄüÂ∫¶„Çí‰øùÊåÅ„Åô„ÇãÂ§âÊõ¥ÂèØËÉΩ„Å™ÂèÇÁÖßÂå∫Áîª„Çí‰ΩúÊàê„Åó„ÄÅ
Âå∫Áîª„Å´Ê†ºÁ¥ç„Åï„Çå„ÅüÂÄ§„ÇíÊõ¥Êñ∞„Åô„Çã„ÅÆ„Å´for„É´„Éº„Éó„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„Åì„Çå„ÇíÂÆüÁèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">import Prelude

import Control.Monad.ST.Ref (modify, new, read)
import Control.Monad.ST (ST, for, run)

simulate :: forall r. Number -&gt; Number -&gt; Int -&gt; ST r Number
simulate x0 v0 time = do
  ref &lt;- new { x: x0, v: v0 }
  for 0 (time * 1000) \_ -&gt;
    modify
      ( \o -&gt;
          { v: o.v - 9.81 * 0.001
          , x: o.x + o.v * 0.001
          }
      )
      ref
  final &lt;- read ref
  pure final.x
</code></pre>
<p>Ë®àÁÆó„ÅÆÊúÄÂæå„Åß„ÅØ„ÄÅÂèÇÁÖßÂå∫Áîª„ÅÆÊúÄÁµÇÁöÑ„Å™ÂÄ§„ÇíË™≠„ÅøÂèñ„Çä„ÄÅÁ≤íÂ≠ê„ÅÆ‰ΩçÁΩÆ„ÇíËøî„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅåÂ§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„Çí‰Ωø„Å£„Å¶„ÅÑ„Å¶„ÇÇ„ÄÅ„Åù„ÅÆÂèÇÁÖßÂå∫Áîª
<code>ref</code>„Åå„Éó„É≠„Ç∞„É©„É†„ÅÆ‰ªñ„ÅÆÈÉ®ÂàÜ„Åß‰Ωø„Çè„Çå„Çã„ÅÆ„ÅåË®±„Åï„Çå„Å™„ÅÑÈôê„Çä„ÄÅ„Åì„Çå„ÅØÁ¥îÁ≤ã„Å™Èñ¢Êï∞„ÅÆ„Åæ„Åæ„Åß„ÅÇ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>ST</code>‰ΩúÁî®„ÅåÁ¶ÅÊ≠¢„Åô„Çã„ÇÇ„ÅÆ„ÅåÊ≠£Á¢∫„Å´„ÅØ‰Ωï„Åß„ÅÇ„Çã„ÅÆ„Åã„Å´„Å§„ÅÑ„Å¶„ÅØÂæå„Åª„Å©Ë¶ã„Åæ„Åô„ÄÇ</p>
<p><code>ST</code>‰ΩúÁî®‰ªò„Åç„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Å´„ÅØ„ÄÅ <code>run</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">run :: forall a. (forall r. ST r a) -&gt; a
</code></pre>
<p>„Åì„Åì„ÅßÊ≥®ÁõÆ„Åó„Å¶Ê¨≤„Åó„ÅÑ„ÅÆ„ÅØ„ÄÅ
È†òÂüüÂûã <code>r</code>„ÅåÈñ¢Êï∞Áü¢Âç∞„ÅÆÂ∑¶Ëæ∫„Å´„ÅÇ„Çã<strong>Êã¨Âºß„ÅÆÂÜÖÂÅ¥„Åß</strong>ÈáèÂåñ„Åï„Çå„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
<code>run</code>„Å´Ê∏°„Åó„Åü„Å©„Çì„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß„ÇÇ„ÄÅ
<strong>‰ªªÊÑè„ÅÆÈ†òÂüü</strong><code>r</code>„Åå„Å™„Çì„Åß„ÅÇ„ÇåÂãï‰Ωú„Åô„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅ
„Å≤„Å®„Åü„Å≥ÂèÇÁÖßÂå∫Áîª„Åå <code>new</code>„Å´„Çà„Å£„Å¶‰ΩúÊàê„Åï„Çå„Çã„Å®„ÄÅ
„Åù„ÅÆÈ†òÂüü„ÅÆÂûã„ÅØ„Åô„Åß„Å´Âõ∫ÂÆö„Åï„Çå„Å¶„Åä„Çä„ÄÅ
<code>run</code>„Å´„Çà„Å£„Å¶ÈôêÂÆö„Åï„Çå„Åü„Ç≥„Éº„Éâ„ÅÆÂ§ñÂÅ¥„ÅßÂèÇÁÖßÈ†òÂüü„Çí‰Ωø„Åä„ÅÜ„Å®„Åó„Å¶„ÇÇÂûã„Ç®„É©„Éº„Å´„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
<code>run</code>„ÅåÂÆâÂÖ®„Å´ <code>ST</code>‰ΩúÁî®„ÇíÈô§Âéª„Åß„Åç„ÄÅ<code>simulate</code>„ÇíÁ¥îÁ≤ãÈñ¢Êï∞„Å´„Åß„Åç„Çã„ÅÆ„ÅØ„Åì„Çå„ÅåÁêÜÁî±„Å™„ÅÆ„Åß„ÅôÔºÅ</p>
<pre><code class="language-hs">simulate' :: Number -&gt; Number -&gt; Int -&gt; Number
simulate' x0 v0 time = run (simulate x0 v0 time)
</code></pre>
<p>PSCi„Åß„ÇÇ„Åì„ÅÆÈñ¢Êï∞„ÇíÂÆüË°å„Åó„Å¶„Åø„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Main

&gt; simulate' 100.0 0.0 0
100.00

&gt; simulate' 100.0 0.0 1
95.10

&gt; simulate' 100.0 0.0 2
80.39

&gt; simulate' 100.0 0.0 3
55.87

&gt; simulate' 100.0 0.0 4
21.54
</code></pre>
<p>ÂÆü„ÅØ„ÄÅ„ÇÇ„Åó <code>simulate</code>„ÅÆÂÆöÁæ©„Çí <code>run</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÅÆ„Å®„Åì„Çç„Å∏Âüã„ÇÅËæº„ÇÄ„Å®„Åô„Çã„Å®„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">simulate :: Number -&gt; Number -&gt; Int -&gt; Number
simulate x0 v0 time =
  run do
    ref &lt;- new { x: x0, v: v0 }
    for 0 (time * 1000) \_ -&gt;
      modify
        ( \o -&gt;
            { v: o.v - 9.81 * 0.001
            , x: o.x + o.v * 0.001
            }
        )
        ref
    final &lt;- read ref
    pure final.x
</code></pre>
<p>ÂèÇÁÖßÂå∫Áîª„ÅØ„Åù„ÅÆ„Çπ„Ç≥„Éº„Éó„Åã„ÇâÈÄÉ„Çå„Çã„Åì„Å®„Åå„Åß„Åç„Å™„ÅÑ„Åì„Å®„Åå„Ç≥„É≥„Éë„Ç§„É©„Å´„Çè„Åã„Çä„Åæ„Åô„Åó„ÄÅ
ÂÆâÂÖ®„Å´<code>ref</code>„Çí<code>var</code>„Å´Â§âÊèõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>run</code>„ÅåÂüã„ÇÅËæº„Åæ„Çå„Åü<code>simulate</code>„Å´ÂØæ„Åó„Å¶ÁîüÊàê„Åï„Çå„ÅüJavaScript„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return (function __do() {

        var ref = { value: { x: x0, v: v0 } };

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        return ref.value.x;

      })();
    };
  };
};
</code></pre>
<p>„Å™„Åä„Åì„ÅÆÁµêÊûú„Å®„Åó„Å¶Âæó„Çâ„Çå„ÅüJavaScript„ÅØÊúÄÈÅ©Âåñ„ÅÆ‰ΩôÂú∞„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
Ë©≥Á¥∞„ÅØ<a href="https://github.com/purescript-contrib/purescript-book/issues/121">„Åì„ÅÆË™≤È°å</a>„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰∏äË®ò„ÅÆÊäúÁ≤ã„ÅØ„Åù„ÅÆË™≤È°å„ÅåËß£Ê±∫„Åï„Çå„Åü„ÇâÊõ¥Êñ∞„Åï„Çå„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>ÊØîËºÉ„Å®„Åó„Å¶„Åì„Å°„Çâ„ÅåÂüã„ÇÅËæº„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑÂΩ¢Âºè„ÅßÁîüÊàê„Åï„Çå„ÅüJavaScript„Åß„Åô„ÄÇ</p>
<pre><code class="language-js">var simulate = function (x0) {
  return function (v0) {
    return function (time) {
      return function __do() {

        var ref = Control_Monad_ST_Internal[&quot;new&quot;]({ x: x0, v: v0 })();

        Control_Monad_ST_Internal[&quot;for&quot;](0)(time * 1000 | 0)(function (v) {
          return Control_Monad_ST_Internal.modify(function (o) {
            return {
              v: o.v - 9.81 * 1.0e-3,
              x: o.x + o.v * 1.0e-3
            };
          })(ref);
        })();

        var $$final = Control_Monad_ST_Internal.read(ref)();
        return $$final.x;
      };
    };
  };
};
</code></pre>
<p>Â±ÄÊâÄÁöÑ„Å™Â§âÊõ¥ÂèØËÉΩÁä∂ÊÖã„ÇíÊâ±„ÅÜ„Å®„Åç„ÄÅ
Áâπ„Å´‰ΩúÁî®„ÅåÁµ°„ÇÄ„É´„Éº„Éó„ÇíÁîüÊàê„Åô„Çã
<code>for</code>„ÄÅ <code>foreach</code>„ÄÅ <code>while</code>„ÅÆ„Çà„ÅÜ„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰∏ÄÁ∑í„Å´‰Ωø„ÅÜ„Å®„Åç„Å´„ÅØ„ÄÅ
<code>ST</code>‰ΩúÁî®„ÅØÁü≠„ÅÑJavaScript„ÇíÁîüÊàê„Åô„ÇãËâØ„ÅÑÊñπÊ≥ï„Å®„Å™„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-22"><a class="header" href="#ÊºîÁøí-22">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ<code>safeDivide</code>Èñ¢Êï∞„ÇíÊõ∏„ÅçÁõ¥„Åó„ÄÅ
„ÇÇ„ÅóÂàÜÊØç„Åå„Çº„É≠„Å™„Çâ<code>throwException</code>„Çí‰Ωø„Å£„Å¶ÊñáË®Ä<code>&quot;div zero&quot;</code>„ÅÆ‰æãÂ§ñ„ÇíÊäï„Åí„Çã„Çà„ÅÜ„Å´„Åó„Åü„ÇÇ„ÅÆ„Çí
<code>exceptionDivide</code>„Å®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÈñ¢Êï∞<code>estimatePi :: Int -&gt; Number</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>n</code>È†Ö<a href="https://mathworld.wolfram.com/GregorySeries.html">Gregory
Series</a>„Çí‰Ωø„Å£„Å¶<code>pi</code>„ÅÆËøë‰ºº„ÇíË®àÁÆó„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöËß£Á≠î„ÅØ‰∏äË®ò„ÅÆ<code>simulate</code>„ÅÆÂÆöÁæ©„Å´ÂÄ£„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åæ„Åü<code>Data.Int</code>„ÅÆ<code>toNumber :: Int -&gt; Number</code>„Çí‰Ωø„Å£„Å¶„ÄÅ
<code>Int</code>„Çí<code>Number</code>„Å´Â§âÊèõ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>n</code>Áï™ÁõÆ„ÅÆ„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊï∞„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞<code>fibonacci :: Int -&gt; Int</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>ST</code>„Çí‰Ωø„Å£„Å¶Ââç„ÅÆ2„Å§„ÅÆ„Éï„Ç£„Éú„Éä„ÉÉ„ÉÅÊï∞„ÅÆÂÄ§„ÇíËøΩË∑°„Åó„Åæ„Åô„ÄÇ
Êñ∞„Åó„ÅÑ<code>ST</code>„Å´Âü∫„Å•„ÅèÂÆüË£Ö„ÅÆÈÄüÂ∫¶„ÇíÁ¨¨4Á´†„ÅÆÂÜçÂ∏∞ÂÆüË£Ö„Å´ÂØæ„Åó„Å¶ÊØîËºÉ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="dom‰ΩúÁî®"><a class="header" href="#dom‰ΩúÁî®">DOM‰ΩúÁî®</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆÊúÄÂæå„ÅÆÁØÄ„Åß„ÅØ„ÄÅ
<code>Effect</code>„É¢„Éä„Éâ„Åß„ÅÆ‰ΩúÁî®„Å´„Å§„ÅÑ„Å¶„Åì„Çå„Åæ„ÅßÂ≠¶„Çì„Å†„Åì„Å®„Çí„ÄÅ
ÂÆüÈöõ„ÅÆDOMÊìç‰Ωú„ÅÆÂïèÈ°å„Å´ÂøúÁî®„Åó„Åæ„Åô„ÄÇ</p>
<p>DOM„ÇíÁõ¥Êé•Êâ±„Å£„Åü„Çä„ÄÅ
„Ç™„Éº„Éó„É≥„ÇΩ„Éº„Çπ„ÅÆDOM„É©„Ç§„Éñ„É©„É™„ÇíÊâ±„Å£„Åü„Çä„Åô„Çã
PureScript„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅåÊ≤¢Â±±„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞‰ª•‰∏ã„Åß„Åô„ÄÇ</p>
<ul>
<li><a href="https://github.com/purescript-web/purescript-web-dom"><code>web-dom</code></a>„ÅØW3C
„ÅÆDOMË¶èÊ†º„Å´Âêë„Åë„ÅüÂûãÂÆöÁæ©„Å®‰ΩéÊ∞¥Ê∫ñ„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπÂÆüË£Ö„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</li>
<li><a href="https://github.com/purescript-web/purescript-web-html"><code>web-html</code></a>„ÅØ
W3C„ÅÆHTML5Ë¶èÊ†º„Å´Âêë„Åë„ÅüÂûãÂÆöÁæ©„Å®‰ΩéÊ∞¥Ê∫ñ„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπÂÆüË£Ö„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</li>
<li><a href="http://github.com/paf31/purescript-jquery"><code>jquery</code></a>„ÅØ
<a href="http://jquery.org">jQuery</a>„É©„Ç§„Éñ„É©„É™„ÅÆ„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞„ÅÆÈõÜ„Åæ„Çä„Åß„Åô„ÄÇ</li>
</ul>
<p>‰∏äË®ò„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíÊäΩË±°Âåñ„Åô„ÇãPureScript„É©„Ç§„Éñ„É©„É™„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<ul>
<li><a
href="http://github.com/paf31/purescript-thermite"><code>thermite</code></a>
„ÅØ<a
href="https://github.com/purescript-contrib/purescript-react"><code>react</code></a>
‰∏ä„ÅßÊßãÁØâ„Åï„Çå„Çã„É©„Ç§„Éñ„É©„É™„Åß„Åô„ÄÇ</li>
<li><a
href="https://github.com/megamaddu/purescript-react-basic-hooks"><code>react-basic-hooks</code></a>
„ÅØ<a
href="https://github.com/lumihq/purescript-react-basic"><code>react-basic</code></a>
‰∏ä„ÅßÊßãÁØâ„Åï„Çå„Çã„É©„Ç§„Éñ„É©„É™„Åß„Åô„ÄÇ</li>
<li><a
href="http://github.com/purescript-halogen/purescript-halogen"><code>halogen</code></a>
„ÅØËá™Ââç„ÅÆ‰ªÆÊÉ≥DOM„É©„Ç§„Éñ„É©„É™„ÇíÂúüÂè∞„Å®„Åó„ÅüÂûãÂÆâÂÖ®„Å™ÊäΩË±°Âåñ„ÅÆÈõÜ„Åæ„Çä„ÇíÊèê‰æõ„Åó„Åæ
„Åô„ÄÇ</li>
</ul>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ <code>react-basic-hooks</code>„É©„Ç§„Éñ„É©„É™„Çí‰ΩøÁî®„Åó„ÄÅ
‰ΩèÊâÄÁ∞ø„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å´„É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„ÇíËøΩÂä†„Åó„Åæ„Åô„Åå„ÄÅ
ËààÂë≥„ÅÆ„ÅÇ„Çã„É¶„Éº„Ç∂„ÅØÁï∞„Å™„Çã„Ç¢„Éó„É≠„Éº„ÉÅ„ÅßÈÄ≤„ÇÅ„Çã„Åì„Å®„Çí„Åä„Åô„Åô„ÇÅ„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="‰ΩèÊâÄÈå≤„ÅÆ„É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ"><a class="header" href="#‰ΩèÊâÄÈå≤„ÅÆ„É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ">‰ΩèÊâÄÈå≤„ÅÆ„É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ</a></h2>
<p><code>react-basic-hooks</code>„É©„Ç§„Éñ„É©„É™„Çí‰Ωø„ÅÑ„ÄÅ
„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíReact<strong>„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà</strong>„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
React„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅØHTMLË¶ÅÁ¥†„ÇíÁ¥îÁ≤ã„Å™„Éá„Éº„ÇøÊßãÈÄ†„Å®„Åó„Å¶„Ç≥„Éº„Éâ„ÅßË®òËø∞„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„ÅØ„Åù„Çå„Åã„ÇâÂäπÁéáÁöÑ„Å´DOM„Å´ÊèèÁîª„Åï„Çå„Åæ„Åô„ÄÇ
Âä†„Åà„Å¶„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅØ„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅÆ„Çà„ÅÜ„Å™„Ç§„Éô„É≥„Éà„Å´ÂøúÁ≠î„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>react-basic-hooks</code>„É©„Ç§„Éñ„É©„É™„ÅØ<code>Effect</code>„É¢„Éä„Éâ„Çí‰Ωø„Å£„Å¶„Åì„Çå„Çâ„ÅÆ„Ç§„Éô„É≥„Éà„ÅÆÂà∂Âæ°ÊñπÊ≥ï„ÇíË®òËø∞„Åó„Åæ„Åô„ÄÇ</p>
<p>React„É©„Ç§„Éñ„É©„É™„ÅÆÂÆåÂÖ®„Å™„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„ÅØ„Åì„ÅÆÁ´†„ÅÆÁØÑÂõ≤„Çí„ÅØ„Çã„Åã„Å´Ë∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
Ë™≠ËÄÖ„ÅØÂøÖË¶Å„Å´Âøú„Åò„Å¶„Éû„Éã„É•„Ç¢„É´„ÇíÂèÇÁÖß„Åô„Çã„Åì„Å®„Çí„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ
ÁõÆÁöÑ„Å´Âøú„Åò„Å¶„ÄÅReact„ÅØ <code>Effect</code>„É¢„Éä„Éâ„ÅÆÂÆüÁî®ÁöÑ„Å™‰æã„ÇíÊèê‰æõ„Åó„Å¶„Åè„Çå„Åæ„Åô„ÄÇ</p>
<p>Âà©Áî®ËÄÖ„Åå‰ΩèÊâÄÈå≤„Å´Êñ∞„Åó„ÅÑÈ†ÖÁõÆ„ÇíËøΩÂä†„Åß„Åç„Çã„Éï„Ç©„Éº„É†„ÇíÊßãÁØâ„Åô„Çã„Åì„Å®„Å´„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Éï„Ç©„Éº„É†„Å´„ÅØ„ÄÅ„Åï„Åæ„Åñ„Åæ„Å™„Éï„Ç£„Éº„É´„ÉâÔºàÂßì„ÄÅÂêçÂâç„ÄÅÈÉΩÂ∏Ç„ÄÅÂ∑û„Å™„Å©Ôºâ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Éú„ÉÉ„ÇØ„Çπ„ÄÅ
„Åä„Çà„Å≥Ê§úË®º„Ç®„É©„Éº„ÅåË°®Á§∫„Åï„Çå„ÇãÈ†òÂüü„ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇ
„ÉÜ„Ç≠„Çπ„Éà„Éú„ÉÉ„ÇØ„Çπ„Å´Âà©Áî®ËÄÖ„Åå„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åô„Çã„Å®„ÄÅÊ§úË®º„Ç®„É©„Éº„ÅåÊõ¥Êñ∞„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>„Ç∑„É≥„Éó„É´„Åï„Çí‰øù„Å§„Åü„ÇÅ„Å´„ÄÅ
„Éï„Ç©„Éº„É†„ÅØÂõ∫ÂÆö„ÅÆÂΩ¢Áä∂„Å®„Åó„Åæ„Åô„ÄÇ
ÈõªË©±Áï™Âè∑„ÅØÁ®ÆÈ°ûÔºàËá™ÂÆÖ„ÄÅÊê∫Â∏ØÈõªË©±„ÄÅ‰ªï‰∫ã„ÄÅ„Åù„ÅÆ‰ªñÔºâ„Åî„Å®„Å´
Âà•„ÄÖ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Éú„ÉÉ„ÇØ„Çπ„Å∏ÂàÜ„Åë„Çã„Åì„Å®„Å´„Åó„Åæ„Åô„ÄÇ</p>
<p><code>exercises/chapter8</code>„Éá„Ç£„É¨„ÇØ„Éà„É™„Åã„Çâ‰ª•‰∏ã„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅßWeb„Ç¢„Éó„É™„ÇíÁ´ã„Å°‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-shell">$ npm install
$ npx spago build
$ npx parcel src/index.html --open
</code></pre>
<p>„ÇÇ„Åó<code>spago</code>„ÇÑ<code>parcel</code>„ÅÆ„Çà„ÅÜ„Å™ÈñãÁô∫„ÉÑ„Éº„É´„ÅåÂ§ßÂüüÁöÑ„Å´„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Å¶„ÅÑ„Çå„Å∞„ÄÅ
<code>npx</code>„ÅÆÂâçÁΩÆ„ÅØÁúÅ„Åë„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
ÊÅê„Çâ„ÅèÊó¢„Å´<code>spago</code>„Çí<code>npm i -g spago</code>„ÅßÂ§ßÂüüÁöÑ„Å´„Ç§„É≥„Çπ„Éà„Éº„É´„Åó„Å¶„ÅÑ„Åæ„Åô„Åó„ÄÅ
<code>parcel</code>„Å´„Å§„ÅÑ„Å¶„ÇÇÂêå„Åò„Åì„Å®„Åå„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>parcel</code>„ÅØ„Äå„Ç¢„Éâ„É¨„ÇπÂ∏≥„Äç„Ç¢„Éó„É™„ÅÆ„Éñ„É©„Ç¶„Ç∂Á™ì„ÇíÁ´ã„Å°‰∏ä„Åí„Åæ„Åô„ÄÇ
<code>parcel</code>„ÅÆÁ´ØÊú´„ÇíÈñã„ÅÑ„Åü„Åæ„Åæ„Å´„Åó„ÄÅ‰ªñ„ÅÆÁ´ØÊú´„Åß<code>spago</code>„ÅßÂÜçÊßãÁØâ„Åô„Çã„Å®„ÄÅ
ÊúÄÊñ∞„ÅÆÁ∑®ÈõÜ„ÇíÂê´„ÇÄ„Éö„Éº„Ç∏„ÅåËá™ÂãïÁöÑ„Å´ÂÜçË™≠„ÅøËæº„Åø„Åï„Çå„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åæ„Åü„ÄÅ<a href="https://github.com/purescript/purescript/tree/master/psc-ide"><code>purs ide</code></a>„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åü„Çä<a href="https://github.com/kRITZCREEK/pscid"><code>pscid</code></a>„ÇíËµ∞„Çâ„Åõ„Å¶„ÅÑ„Åü„Çä„Åô„Çã
<a href="https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors">„Ç®„Éá„Ç£„Çø</a>„Çí‰Ωø„Å£„Å¶„ÅÑ„Çå„Å∞„ÄÅ
„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠ò„Åó„Åü„Å®„Åç„Å´Ëá™ÂãïÁöÑ„Å´„Éö„Éº„Ç∏„ÅåÂÜçÊßãÁØâ„Åï„Çå„ÇãÔºà„Åù„Åó„Å¶Ëá™ÂãïÁöÑ„Å´„Éö„Éº„Ç∏„ÅåÂÜçË™≠„ÅøËæº„Åø„Åï„Çå„ÇãÔºâ„Çà„ÅÜ„Å´Ë®≠ÂÆö„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç¢„Éâ„É¨„ÇπÂ∏≥„Ç¢„Éó„É™„Åß„Éï„Ç©„Éº„É†„Éï„Ç£„Éº„É´„Éâ„Å´„ÅÑ„Çç„ÅÑ„Çç„Å™ÂÄ§„ÇíÂÖ•Âäõ„Åô„Çã„Å®„ÄÅ
„Éö„Éº„Ç∏‰∏ä„Å´Âá∫Âäõ„Åï„Çå„ÅüÊ§úË®º„Ç®„É©„Éº„ÇíË¶ã„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>Âãï„Åè‰ªïÁµÑ„Åø„ÇíÊï£Á≠ñ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>src/index.html</code>„Éï„Ç°„Ç§„É´„ÅØÊúÄÂ∞èÈôê„Åß„Åô„ÄÇ</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Address Book&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>&lt;script</code>„ÅÆË°å„ÅØJavaScript„ÅÆÂÖ•Âè£„ÇíÂê´„Çì„Åß„Åä„Çä„ÄÅ
<code>index.js</code>„Å´„ÅØ„Åì„ÅÆ1Ë°å„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">import { main } from &quot;../output/Main/index.js&quot;;

main();
</code></pre>
<p><code>module Main</code> (<code>src/main.purs</code>) „ÅÆ<code>main</code>Èñ¢Êï∞„Å®Á≠â‰æ°„Å™„ÄÅ
ÁîüÊàê„Åó„ÅüJavaScript„ÇíÂëº„Å≥Âá∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>spago build</code>„ÅØÁîüÊàê„Åï„Çå„ÅüÂÖ®„Å¶„ÅÆJavaScript„Çí<code>output</code>„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´ÁΩÆ„Åè„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><code>main</code>Èñ¢Êï∞„ÅØDOM„Å®HTML API„Çí‰Ωø„ÅÑ„ÄÅ
<code>index.html</code>„Å´ÂÆöÁæ©„Åó„Åü<code>container</code>Ë¶ÅÁ¥†„ÅÆ‰∏≠„Å´„Ç¢„Éâ„É¨„ÇπÂ∏≥„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÊèèÁîª„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">main :: Effect Unit
main = do
  log &quot;Rendering address book component&quot;
  -- Get window object
  w &lt;- window
  -- Get window's HTML document
  doc &lt;- document w
  -- Get &quot;container&quot; element in HTML
  ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
  case ctr of
    Nothing -&gt; throw &quot;Container element not found.&quot;
    Just c -&gt; do
      -- Create AddressBook react component
      addressBookApp &lt;- mkAddressBookApp
      let
        -- Create JSX node from react component. Pass-in empty props
        app = element addressBookApp {}
      -- Render AddressBook JSX node in DOM &quot;container&quot; element
      D.render app c
</code></pre>
<p>„Åì„Çå„Çâ3Ë°å„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-hs">w &lt;- window
doc &lt;- document w
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>„Åì„Çå„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Áµ±Âêà„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">doc &lt;- document =&lt;&lt; window
ctr &lt;- getElementById &quot;container&quot; $ toNonElementParentNode doc
</code></pre>
<p>„ÅÇ„Çã„ÅÑ„ÅØ„Åï„Çâ„Å´Áµ±Âêà„Åô„Çã„Åì„Å®„Åï„Åà„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">ctr &lt;- getElementById &quot;container&quot; &lt;&lt;&lt; toNonElementParentNode =&lt;&lt; document =&lt;&lt; window
-- or, equivalently:
ctr &lt;- window &gt;&gt;= document &gt;&gt;= toNonElementParentNode &gt;&gt;&gt; getElementById &quot;container&quot;
</code></pre>
<p>ÈÄî‰∏≠„ÅÆ<code>w</code>„ÇÑ<code>doc</code>Â§âÊï∞„ÅåË™≠„Åø„ÇÑ„Åô„Åï„ÅÆÂä©„Åë„Å´„Å™„Çã„Åã„ÅØ‰∏ªË¶≥ÁöÑ„Å™ÂóúÂ•Ω„ÅÆÂïèÈ°å„Åß„Åô„ÄÇ</p>
<p>AddressBook„ÅÆ<code>reactComponent</code>„ÇíÊ∑±Â†Ä„Çä„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
ÂçòÁ¥îÂåñ„Åï„Çå„Åü„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Åã„ÇâÂßã„ÇÅ„ÄÅ„Åù„Çå„Åã„Çâ<code>Main.purs</code>„ÅßÂÆüÈöõ„ÅÆ„Ç≥„Éº„Éâ„Å´ÊßãÁØâ„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>‰ª•‰∏ã„ÅÆÊúÄÂ∞èÈôê„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Çí„ÅîË¶ß„Åè„Å†„Åï„ÅÑ„ÄÇ
ÈÅ†ÊÖÆ„Å™„ÅèÂÖ®‰Ωì„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Çí„Åì„Çå„Å´ÁΩÆ„ÅçÊèõ„Åà„Å¶ÂÆüË°å„ÅÆÊßòÂ≠ê„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp =
  reactComponent
    &quot;AddressBookApp&quot;
    (\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;)
</code></pre>
<p><code>reactComponent</code>„Å´„ÅØ„Åì„ÅÆ„Çà„ÅÜ„Å™Â®ÅÂúßÁöÑ„Å™„Ç∑„Ç∞„Éç„ÉÅ„É£„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">reactComponent ::
  forall hooks props.
  Lacks &quot;children&quot; props =&gt;
  Lacks &quot;key&quot; props =&gt;
  Lacks &quot;ref&quot; props =&gt;
  String -&gt;
  ({ | props } -&gt; Render Unit hooks JSX) -&gt;
  Effect (ReactComponent { | props })
</code></pre>
<p>ÈáçË¶Å„Å™Ê≥®ÊÑèÁÇπ„ÅØÂÖ®„Å¶„ÅÆÂûã„ÇØ„É©„ÇπÂà∂Á¥Ñ„ÅÆÂæå„ÅÆÂºïÊï∞„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ
<code>String</code>Ôºà‰ªªÊÑè„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂêçÔºâ„ÄÅ
<code>props</code>„ÇíÊèèÁîª„Åï„Çå„Åü<code>JSX</code>„Å´Â§âÊèõ„Åô„ÇãÊñπÊ≥ï„ÇíË®òËø∞„Åô„ÇãÈñ¢Êï∞„ÇíÂèñ„Çä„ÄÅ
„Åù„Åó„Å¶<code>Effect</code>„Å´ÂåÖ„Åæ„Çå„Åü<code>ReactComponent</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>props„Åã„ÇâJSX„Å∏„ÅÆÈñ¢Êï∞„ÅØÂçò„Å´„Åì„ÅÜ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">\props -&gt; pure $ D.text &quot;Hi! I'm an address book&quot;
</code></pre>
<p><code>props</code>„ÅØÁÑ°Ë¶ñ„Åï„Çå„Å¶„Åä„Çä„ÄÅ<code>D.text</code>„ÅØ<code>JSX</code>„ÇíËøî„Åó„ÄÅ
„Åù„Åó„Å¶<code>pure</code>„ÅØÊèèÁîª„Åï„Çå„ÅüJSX„Å´ÊåÅ„Å°‰∏ä„Åí„Åæ„Åô„ÄÇ
„Åì„Çå„Åß<code>component</code>„Å´„ÅØ<code>ReactComponent</code>„ÇíÁîüÊàê„Åô„Çã„ÅÆ„Å´ÂøÖË¶Å„Å™ÂÖ®„Å¶„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„Å´ÂÆåÂÖ®„Å™„Ç¢„Éâ„É¨„ÇπÂ∏≥„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Å´„ÅÇ„ÇãËøΩÂä†„ÅÆË§áÈõë„Å™‰∫ãÊüÑ„ÅÆ„ÅÑ„Åè„Å§„Åã„ÇíË™ø„Åπ„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Çâ„ÅØÂÆåÂÖ®„Å™„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆÊúÄÂàù„ÅÆÊï∞Ë°å„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent {})
mkAddressBookApp = do
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p><code>person</code>„Çí<code>useState</code>„Éï„ÉÉ„ÇØ„ÅÆÁä∂ÊÖã„ÅÆ‰∏ÄÈÉ®„Å®„Åó„Å¶ËøΩË∑°„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">Tuple person setPerson &lt;- useState examplePerson
</code></pre>
<p>„Å™„Åä„ÄÅË§áÊï∞Âõû<code>useState</code>„ÇíÂëº„Å≥Âá∫„Åô„Åì„Å®„Åß„ÄÅ
„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆÁä∂ÊÖã„ÇíË§áÊï∞„ÅÆÁä∂ÊÖã„ÅÆÈÉ®ÂìÅ„Å´ÂàÜËß£„Åô„Çã„Åì„Å®„ÅØËá™Áî±„Åß„Åô„ÄÇ
‰æã„Åà„Å∞<code>Person</code>„ÅÆ„Åù„Çå„Åû„Çå„ÅÆ„É¨„Ç≥„Éº„Éâ„Éï„Ç£„Éº„É´„Éâ„Å´„Å§„ÅÑ„Å¶ÂàÜÈõ¢„Åó„ÅüÁä∂ÊÖã„ÅÆÈÉ®ÂìÅ„Çí‰Ωø„Å£„Å¶„ÄÅ
„Åì„ÅÆ„Ç¢„Éó„É™„ÇíÊõ∏„ÅçÁõ¥„Åô„Åì„Å®„Åå„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åó„Åã„Åó„Åì„ÅÆÂ†¥Âêà„Å´„Åù„Çå„Çí„Åô„Çã„Å®ÂÉÖ„Åã„Å´Âà©‰æøÊÄß„ÇíÊêç„Å™„ÅÜ„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„Å´„Å™„Å£„Å¶„Åó„Åæ„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰ªñ„ÅÆ‰æã„Åß„ÅØ<code>Tuple</code>Áî®„ÅÆ<code>/\</code>‰∏≠ÁΩÆÊºîÁÆóÂ≠ê„Å´Âá∫Âñ∞„Çè„Åô„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ
„Åì„Çå„ÅØ‰∏ä„ÅÆË°å„Å®Á≠â„Åó„ÅÑ„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">firstName /\ setFirstName &lt;- useState p.firstName
</code></pre>
<p><code>useState</code>„ÅØÊó¢ÂÆö„ÅÆÂàùÊúüÂÄ§„ÇíÂèñ„ÇäÁèæÂú®„ÅÆÂÄ§„Å®ÂÄ§„ÇíÊõ¥Êñ∞„Åô„ÇãÊñπÊ≥ï„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ
<code>useState</code>„ÅÆÂûã„ÇíÁ¢∫Ë™ç„Åô„Çå„Å∞Âûã<code>person</code>„Å®<code>setPerson</code>„Å´„Å§„ÅÑ„Å¶„Çà„ÇäÊ∑±„ÅÑÊ¥ûÂØü„ÅåÂæó„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">useState ::
  forall state.
  state -&gt;
  Hook (UseState state) (Tuple state ((state -&gt; state) -&gt; Effect Unit))
</code></pre>
<p>ÁµêÊûú„ÅÆÂÄ§„ÅÆ<code>Hook (UseState state)</code>„É©„ÉÉ„Éë„Éº„ÇíÂèñ„ÇäÂéª„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„Åå„ÄÅ
„Åù„Çå„ÅØ<code>useState</code>„Åå<code>R.do</code>„Éñ„É≠„ÉÉ„ÇØ„ÅÆ‰∏≠„ÅßÂëº„Å∞„Çå„Å¶„ÅÑ„Çã„Åã„Çâ„Åß„Åô„ÄÇ
<code>R.do</code>„ÅØÂæå„ÅßË©≥Ëø∞„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åï„Å¶„Åì„Çå„Åß‰ª•‰∏ã„ÅÆ„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíË¶≥ÂØü„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">person :: state
setPerson :: (state -&gt; state) -&gt; Effect Unit
</code></pre>
<p><code>state</code>„ÅÆÈôêÂÆö„Åï„Çå„ÅüÂûã„ÅØÂàùÊúü„ÅÆÊó¢ÂÆöÂÄ§„Å´„Çà„Å£„Å¶Ê±∫ÂÆö„Åï„Çå„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ<code>examplePerson</code>„ÅÆÂûã„Å™„ÅÆ„Åß„Åì„ÅÆÂ†¥Âêà„ÅØ<code>Person</code> <code>Record</code>„Åß„Åô„ÄÇ</p>
<p><code>person</code>„ÅØ„Åù„Çå„Åû„Çå„ÅÆÂÜçÊèèÁîª„ÅÆÊôÇÁÇπ„ÅßÁèæÂú®„ÅÆÁä∂ÊÖã„Å´„Ç¢„ÇØ„Çª„Çπ„Åô„ÇãÊñπÊ≥ï„Åß„Åô„ÄÇ</p>
<p><code>setPerson</code>„ÅØÁä∂ÊÖã„ÇíÊõ¥Êñ∞„Åô„ÇãÊñπÊ≥ï„Åß„Åô„ÄÇ
ÁèæÂú®„ÅÆÁä∂ÊÖã„ÇíÊñ∞„Åó„ÅÑÁä∂ÊÖã„Å´Â§âÂΩ¢„Åô„ÇãÊñπÊ≥ï„ÇíË®òËø∞„Åô„ÇãÈñ¢Êï∞„ÇíÂçò„Å´Êèê‰æõ„Åó„Åæ„Åô„ÄÇ
<code>state</code>„ÅÆÂûã„ÅåÂÅ∂ÁÑ∂<code>Record</code>„ÅÆ„Å®„Åç„ÅØ„ÄÅ„É¨„Ç≥„Éº„ÉâÊõ¥Êñ∞ÊßãÊñá„ÅØ„Åì„Çå„Å´„Å¥„Å£„Åü„Çä„Åß„Åô„ÄÇ
‰æã„Åà„Å∞‰ª•‰∏ã„ÄÇ</p>
<pre><code class="language-hs">setPerson (\currentPerson -&gt; currentPerson {firstName = &quot;NewName&quot;})

</code></pre>
<p>„ÅÇ„Çã„ÅÑ„ÅØÁü≠„Åã„Åè‰ª•‰∏ã„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">setPerson _ {firstName = &quot;NewName&quot;}
</code></pre>
<p><code>Record</code>„Åß„Å™„ÅÑÁä∂ÊÖã„ÇÇ„Åæ„Åü„Åì„ÅÆÊõ¥Êñ∞„Éë„Çø„Éº„É≥„Å´„Åó„Åü„Åå„ÅÑ„Åæ„Åô„ÄÇ
„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ„Å´„Å§„ÅÑ„Å¶„ÅÆ„Çà„ÇäË©≥„Åó„ÅÑ„Åì„Å®„ÅØ<a href="https://github.com/megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541">„Åì„ÅÆ„Ç¨„Ç§„Éâ</a>„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><code>useState</code>„Åå<code>R.do</code>„Éñ„É≠„ÉÉ„ÇØ„ÅÆ‰∏≠„Åß‰Ωø„Çè„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>R.do</code>„ÅØ<code>do</code>„ÅÆÁâπÂà•„Å™react„Éï„ÉÉ„ÇØ„ÅÆÊ¥æÁîü„Åß„Åô„ÄÇ
<code>R.</code>„ÅÆÂâçÁΩÆ„ÅØ„Åì„Çå„Åå<code>React.Basic.Hooks</code>„Åã„ÇâÊù•„Åü„ÇÇ„ÅÆ„Å®„Åó„Å¶„ÄåÈôêÂÆö„Åô„Çã„Äç„ÇÇ„ÅÆ„Åß„ÄÅ
<code>R.do</code>„Éñ„É≠„ÉÉ„ÇØ„ÅÆ‰∏≠„Åß„Éï„ÉÉ„ÇØ‰∫íÊèõÁâà„ÅÆ<code>bind</code>„Çí‰Ωø„ÅÜ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄåÈôêÂÆö„Åï„Çå„Åüdo„Äç„Å®„Åó„Å¶Áü•„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Hook (UseState state)</code>„ÅÆ„É©„ÉÉ„Éî„É≥„Ç∞„ÇíÁÑ°Ë¶ñ„Åó„ÄÅ
ÂÜÖÈÉ®„ÅÆÂÄ§„ÅÆ<code>Tuple</code>„Å®Â§âÊï∞„Å´ÊùüÁ∏õ„Åó„Å¶„Åè„Çå„Åæ„Åô„ÄÇ</p>
<p>‰ªñ„ÅÆÁä∂ÊÖãÁÆ°ÁêÜÊà¶Áï•„Å®„Åó„Å¶Êåô„Åí„Çâ„Çå„Çã„ÅÆ„ÅØ<code>useReducer</code>„Åß„Åô„Åå„ÄÅ
„Åù„Çå„ÅØ„Åì„ÅÆÁ´†„ÅÆÁØÑÁñáÂ§ñ„Åß„Åô„ÄÇ</p>
<p>‰ª•‰∏ã„Åß„ÅØ<code>JSX</code>„ÅÆÊèèÁîª„ÅåË°å„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">pure
  $ D.div
      { className: &quot;container&quot;
      , children:
          renderValidationErrors errors
            &lt;&gt; [ D.div
                  { className: &quot;row&quot;
                  , children:
                      [ D.form_
                          $ [ D.h3_ [ D.text &quot;Basic Information&quot; ]
                            , formField &quot;First Name&quot; &quot;First Name&quot; person.firstName \s -&gt;
                                setPerson _ { firstName = s }
                            , formField &quot;Last Name&quot; &quot;Last Name&quot; person.lastName \s -&gt;
                                setPerson _ { lastName = s }
                            , D.h3_ [ D.text &quot;Address&quot; ]
                            , formField &quot;Street&quot; &quot;Street&quot; person.homeAddress.street \s -&gt;
                                setPerson _ { homeAddress { street = s } }
                            , formField &quot;City&quot; &quot;City&quot; person.homeAddress.city \s -&gt;
                                setPerson _ { homeAddress { city = s } }
                            , formField &quot;State&quot; &quot;State&quot; person.homeAddress.state \s -&gt;
                                setPerson _ { homeAddress { state = s } }
                            , D.h3_ [ D.text &quot;Contact Information&quot; ]
                            ]
                          &lt;&gt; renderPhoneNumbers
                      ]
                  }
              ]
      }
</code></pre>
<p>„Åì„Åì„ÅßDOM„ÅÆÊÑèÂõ≥„Åó„ÅüÁä∂ÊÖã„ÇíË°®Áèæ„Åô„Çã<code>JSX</code>„ÇíÁîüÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆJSX„ÅØHTML„Çø„Ç∞Ôºà‰æãÔºö<code>div</code>„ÄÅ<code>form</code>„ÄÅ<code>h3</code>„ÄÅ<code>li</code>„ÄÅ<code>ul</code>„ÄÅ<code>label</code>„ÄÅ<code>input</code>Ôºâ„Å´ÂØæÂøú„ÅóÂçò‰∏Ä„ÅÆHTMLË¶ÅÁ¥†„Çí‰Ωú„ÇãÈñ¢Êï∞„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åß‰Ωú„Çâ„Çå„Çã„ÅÆ„ÅåÂÖ∏ÂûãÁöÑ„Åß„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆHTMLË¶ÅÁ¥†„ÅØÂÆü„ÅØReact„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàËá™‰Ωì„ÅßJSX„Å´Â§âÊèõ„Åï„Çå„Åæ„Åô„ÄÇ
ÈÄöÂ∏∏„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„Å´„ÅØ„Åù„Çå„Åû„Çå3„Å§„ÅÆÁ®ÆÈ°û„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>div_</code>: Â≠êË¶ÅÁ¥†„ÅÆÈÖçÂàó„ÇíÂèó„Åë‰ªò„Åë„Åæ„Åô„ÄÇ
Êó¢ÂÆö„ÅÆÂ±ûÊÄß„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>div</code>: Â±ûÊÄß„ÅÆ<code>Record</code>„ÇíÂèó„Åë‰ªò„Åë„Åæ„Åô„ÄÇ
Â≠êË¶ÅÁ¥†„ÅÆÈÖçÂàó„Çí„Åì„ÅÆ„É¨„Ç≥„Éº„Éâ„ÅÆ<code>children</code>„Éï„Ç£„Éº„É´„Éâ„Å´Ê∏°„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</li>
<li><code>div'</code>: <code>div</code>„Å®Âêå„Åò„Åß„Åô„Åå„ÄÅ<code>JSX</code>„Å´Â§âÊèõ„Åô„ÇãÂâç„Å´<code>ReactComponent</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ</li>
</ul>
<p>Ê§úË®º„Ç®„É©„Éº„Çí„Éï„Ç©„Éº„É†„ÅÆ‰∏ÄÁï™‰∏ä„Å´Ôºà„ÇÇ„Åó„ÅÇ„Çå„Å∞ÔºâË°®Á§∫„Åô„Çã„ÅÆ„Å´„ÄÅ
<code>Errors</code>ÊßãÈÄ†‰Ωì„ÇíJSX„ÅÆÈÖçÂàó„Å´Â§â„Åà„Çã<code>renderValidationErrors</code>„ÅäÂä©„ÅëÈñ¢Êï∞„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆÈÖçÂàó„ÅØ„Éï„Ç©„Éº„É†„ÅÆÊÆã„ÇäÈÉ®ÂàÜ„ÅÆÂâç„Å´‰ªò„Åë„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">renderValidationErrors :: Errors -&gt; Array R.JSX
renderValidationErrors [] = []
renderValidationErrors xs =
  let
    renderError :: String -&gt; R.JSX
    renderError err = D.li_ [ D.text err ]
  in
    [ D.div
        { className: &quot;alert alert-danger row&quot;
        , children: [ D.ul_ (map renderError xs) ]
        }
    ]
</code></pre>
<p>„Å™„Åä„ÄÅ„Åì„Åì„Åß„ÅØÈÄöÂ∏∏„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†‰Ωì„ÇíÂçòÁ¥î„Å´Êìç‰Ωú„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ
<code>map</code>„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Çà„ÇäËààÂë≥Ê∑±„ÅÑË¶ÅÁ¥†„ÇíÊßãÁØâ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">children: [ D.ul_ (map renderError xs)]
</code></pre>
<p><code>className</code>„Éó„É≠„Éë„ÉÜ„Ç£„Çí‰Ωø„Å£„Å¶CSS„Çπ„Çø„Ç§„É´„ÅÆ„ÇØ„É©„Çπ„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØ<a href="https://getbootstrap.com/">Bootstrap</a>„ÅÆ<code>stylesheet</code>„Çí‰Ωø„Å£„Å¶„Åä„Çä„ÄÅ
„Åì„Çå„ÅØ<code>index.html</code>„Åß„Ç§„É≥„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞„Éï„Ç©„Éº„É†‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅØ<code>row</code>„Å®„Åó„Å¶ÈÖçÁΩÆ„Åï„Çå„Å¶„Åª„Åó„ÅÑ„Åß„Åô„Åó„ÄÅ
Ê§úË®º„Ç®„É©„Éº„ÅØ<code>alert-danger</code>„ÅÆË£ÖÈ£æ„ÅßÂº∑Ë™ø„Åï„Çå„Å¶„ÅÑ„Å¶„Åª„Åó„ÅÑ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">className: &quot;alert alert-danger row&quot;
</code></pre>
<p>2Áï™ÁõÆ„ÅÆË£úÂä©Èñ¢Êï∞„ÅØ <code>formField</code>„Åß„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅÂçò‰∏Ä„Éï„Ç©„Éº„É†„Éï„Ç£„Éº„É´„Éâ„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">formField :: String -&gt; String -&gt; String -&gt; (String -&gt; Effect Unit) -&gt; R.JSX
formField name placeholder value setValue =
  D.label
    { className: &quot;form-group row&quot;
    , children:
        [ D.div
            { className: &quot;col-sm col-form-label&quot;
            , children: [ D.text name ]
            }
        , D.div
            { className: &quot;col-sm&quot;
            , children:
                [ D.input
                    { className: &quot;form-control&quot;
                    , placeholder
                    , value
                    , onChange:
                        let
                          handleValue :: Maybe String -&gt; Effect Unit
                          handleValue (Just v) = setValue v
                          handleValue Nothing  = pure unit
                        in
                          handler targetValue handleValue
                    }
                ]
            }
        ]
    }
</code></pre>
<p><code>input</code>„ÇíÁΩÆ„ÅÑ„Å¶<code>label</code>„ÅÆ‰∏≠„Å´<code>text</code>„ÇíË°®Á§∫„Åô„Çã„Åì„Å®„ÅØ„ÄÅ
„Çπ„ÇØ„É™„Éº„É≥„É™„Éº„ÉÄ„Éº„ÅÆ„Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£„ÅÆÂä©„Åë„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p><code>onChange</code>Â±ûÊÄß„Åå„ÅÇ„Çå„Å∞Âà©Áî®ËÄÖ„ÅÆÂÖ•Âäõ„Å´ÂøúÁ≠î„Åô„ÇãÊñπÊ≥ï„ÇíË®òËø∞„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>handler</code>Èñ¢Êï∞„Çí‰Ωø„ÅÑ„Åæ„Åô„Åå„ÄÅ„Åì„Çå„ÅØ‰ª•‰∏ã„ÅÆÂûã„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">handler :: forall a. EventFn SyntheticEvent a -&gt; (a -&gt; Effect Unit) -&gt; EventHandler
</code></pre>
<p><code>handler</code>„Å∏„ÅÆÊúÄÂàù„ÅÆÂºïÊï∞„Å´„ÅØ<code>targetValue</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„Åå„ÄÅ
„Åì„Çå„ÅØHTML„ÅÆ<code>input</code>Ë¶ÅÁ¥†‰∏≠„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÅÆÂÄ§„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÂ†¥Âêà„ÅØÂûãÂ§âÊï∞<code>a</code>„Åå<code>Maybe String</code>„Åß„ÄÅ
<code>handler</code>„ÅåÊúüÂæÖ„Åô„Çã„Ç∑„Ç∞„Éç„ÉÅ„É£„Å´ÂêàËá¥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">targetValue :: EventFn SyntheticEvent (Maybe String)
</code></pre>
<p>JavaScript„Åß„ÅØ<code>input</code>Ë¶ÅÁ¥†„ÅÆ<code>onChange</code>„Ç§„Éô„É≥„Éà„ÅØÂÆü„ÅØ<code>String</code>ÂÄ§„Å®‰∏ÄÁ∑í„Å´„Å™„Å£„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åô„Åå„ÄÅ
JavaScript„ÅÆÊñáÂ≠óÂàó„ÅØnull„Å´„Å™„Çä„Åà„Çã„ÅÆ„Åß„ÄÅÂÆâÂÖ®„ÅÆ„Åü„ÇÅ„Å´<code>Maybe</code>„Åå‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>(a -&gt; Effect Unit)</code>„ÅÆ<code>handler</code>„Å∏„ÅÆ2„Å§ÁõÆ„ÅÆÂºïÊï∞„ÅØ„ÄÅ„Åó„Åü„Åå„Å£„Å¶„Åì„ÅÆ„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">Maybe String -&gt; Effect Unit
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>Maybe String</code>ÂÄ§„ÇíÊ±Ç„ÇÅ„Çã‰ΩúÁî®„Å´Â§âÊèõ„Åô„ÇãÊñπÊ≥ï„ÇíË®òËø∞„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÁõÆÁöÑ„ÅÆ„Åü„ÇÅ„Å´‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Ëá™Ââç„ÅÆ<code>handleValue</code>Èñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Å¶<code>handler</code>„ÇíÊ∏°„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">onChange:
  let
    handleValue :: Maybe String -&gt; Effect Unit
    handleValue (Just v) = setValue v
    handleValue Nothing  = pure unit
  in
    handler targetValue handleValue
</code></pre>
<p><code>setValue</code>„ÅØ„Åù„Çå„Åû„Çå„ÅÆ<code>formField</code>„ÅÆÂëº„Å≥Âá∫„Åó„Å´Êèê‰æõ„Åó„ÅüÈñ¢Êï∞„Åß
ÊñáÂ≠óÂàó„ÇíÂèñ„Çä<code>setPerson</code>„Éï„ÉÉ„ÇØ„Å´ÈÅ©Âàá„Å™„É¨„Ç≥„Éº„ÉâÊõ¥Êñ∞Âëº„Å≥Âá∫„Åó„ÇíÂÆüÊñΩ„Åó„Åæ„Åô„ÄÇ</p>
<p>„Å™„Åä<code>handleValue</code>„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„ÇÇÁΩÆ„ÅçÊèõ„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">onChange: handler targetValue $ traverse_ setValue
</code></pre>
<p>„Å©„ÅÜ„Åû<code>traverse_</code>„ÅÆÂÆöÁæ©„ÇíË™øÊüª„Åó„Å¶‰∏°Êñπ„ÅÆÂΩ¢Âºè„ÅåÁ¢∫„Åã„Å´Á≠â‰æ°„Åß„ÅÇ„Çã„Åì„Å®„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„Åì„Çå„ÅØ„ÄÅ„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂÆüË£Ö„ÅÆÂü∫Êú¨„Çí„Ç´„Éê„Éº„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆ‰ªïÁµÑ„Åø„ÇíÂÆåÂÖ®„Å´ÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÅØ„ÄÅ
„Åì„ÅÆÁ´†„Å´‰ªòÈöè„Åô„ÇãÊÉÖÂ†±„Çí„ÅäË™≠„Åø„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>Êòé„Çâ„Åã„Å´„ÄÅ„Åì„ÅÆ„É¶„Éº„Ç∂„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ„Å´„ÅØÊîπÂñÑ„Åô„Åπ„ÅçÁÇπ„Åå„Åü„Åè„Åï„Çì„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÊºîÁøí„Åß„ÅØ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Åå„Çà„Çä‰Ωø„ÅÑ„ÇÑ„Åô„Åè„Å™„Çã„Çà„ÅÜ„Å™ÊñπÊ≥ï„ÇíËøΩÁ©∂„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-23"><a class="header" href="#ÊºîÁøí-23">ÊºîÁøí</a></h2>
<p>‰ª•‰∏ã„ÅÆÊºîÁøí„Åß„ÅØ<code>src/Main.purs</code>„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„Çâ„ÅÆÊºîÁøí„Å´„ÅØÂçò‰ΩìË©¶È®ì„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ„Åì„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÂ§âÊõ¥„Åó„ÄÅ
ËÅ∑Â†¥„ÅÆÈõªË©±Áï™Âè∑„ÇíÂÖ•Âäõ„Åß„Åç„Çã„ÉÜ„Ç≠„Çπ„Éà„Éú„ÉÉ„ÇØ„Çπ„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÁèæÊôÇÁÇπ„Åß„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅØÊ§úË®º„Ç®„É©„Éº„Çí
Âçò‰∏Ä„ÅÆ„Äåpink-alert„ÄçËÉåÊôØ„Å´ÈõÜ„ÇÅ„Å¶Ë°®Á§∫„Åï„Åõ„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Á©∫„ÅÆÁ∑ö„ÅßÂàÜÂâ≤„Åô„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅ
„Åù„Çå„Åû„Çå„ÅÆÊ§úË®º„Ç®„É©„Éº„Å´pink-alertËÉåÊôØ„ÇíÊåÅ„Åü„Åõ„Çã„Çà„ÅÜ„Å´Â§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><strong>„Éí„É≥„Éà</strong>Ôºö„É™„Çπ„Éà‰∏≠„ÅÆÊ§úË®º„Ç®„É©„Éº„ÇíË°®Á§∫„Åô„Çã„ÅÆ„Å´<code>ul</code>Ë¶ÅÁ¥†„Çí‰Ωø„ÅÜ‰ª£„Çè„Çä„Å´„ÄÅ
„Ç≥„Éº„Éâ„ÇíÂ§âÊõ¥„Åó„ÄÅ
„Åù„Çå„Åû„Çå„ÅÆ„Ç®„É©„Éº„Å´<code>alert</code>„Å®<code>alert-danger</code>Ë£ÖÈ£æ„ÇíÊåÅ„Å§<code>div</code>„Çí‰Ωú„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑ„ÄÅÁô∫Â±ïÔºâ„Åì„ÅÆ„É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„ÅÆÂïèÈ°å„ÅÆ„Å≤„Å®„Å§„ÅØ„ÄÅ
Ê§úË®º„Ç®„É©„Éº„Åå„Åù„ÅÆÁô∫ÁîüÊ∫ê„Åß„ÅÇ„Çã„Éï„Ç©„Éº„É†„Éï„Ç£„Éº„É´„Éâ„ÅÆÈö£„Å´Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„Åß„Åô„ÄÇ
„Ç≥„Éº„Éâ„ÇíÂ§âÊõ¥„Åó„Å¶„Åì„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><strong>„Éí„É≥„Éà</strong>ÔºöÊ§úË®ºÂô®„Å´„Çà„Å£„Å¶Ëøî„Åï„Çå„Çã„Ç®„É©„Éº„ÅÆÂûã„ÅØ„ÄÅ
„Ç®„É©„Éº„ÅÆÂéüÂõ†„Å®„Å™„Å£„Å¶„ÅÑ„Çã„Éï„Ç£„Éº„É´„Éâ„ÇíÁ§∫„Åô„Åü„ÇÅ„Å´Êã°Âºµ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
Ê¨°„ÅÆ„Çà„ÅÜ„Å™Â§âÊõ¥„Åï„Çå„Åü„Ç®„É©„ÉºÂûã„Çí‰ΩøÁî®„Åó„Åü„Åè„Å™„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-hs">data Field = FirstNameField
           | LastNameField
           | StreetField
           | CityField
           | StateField
           | PhoneField PhoneType

data ValidationError = ValidationError String Field

type Errors = Array ValidationError
</code></pre>
<p><code>Error</code>ÊßãÈÄ†‰Ωì„Åã„ÇâÁâπÂÆö„ÅÆ<code>Field</code>„ÅÆ„Åü„ÇÅ„ÅÆÊ§úË®º„Ç®„É©„Éº„ÇíÂèñ„ÇäÂá∫„ÅôÈñ¢Êï∞„ÇíÊõ∏„ÅèÂøÖË¶Å„Åå„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-6"><a class="header" href="#„Åæ„Å®„ÇÅ-6">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØPureScript„Åß„ÅÆÂâØ‰ΩúÁî®„ÅÆÊâ±„ÅÑ„Å´„Å§„ÅÑ„Å¶„ÅÆÂ§ö„Åè„ÅÆËÄÉ„ÅàÊñπ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇ</p>
<ul>
<li><code>Monad</code>Âûã„ÇØ„É©„Çπ„Å®„ÄÅdoË®òÊ≥ï„Å®„ÅÆÈñ¢ÈÄ£„Å´Âá∫‰ºö„ÅÑ„Åæ„Åó„Åü„ÄÇ</li>
<li>„É¢„Éä„ÉâÂâá„ÇíÂ∞éÂÖ•„Åó„ÄÅdoË®òÊ≥ï„Çí‰Ωø„Å£„Å¶Êõ∏„Åã„Çå„Åü„Ç≥„Éº„Éâ„ÇíÂ§âÊèõ„Åô„ÇãÊñπÊ≥ï„ÇíË¶ã„Åæ„Åó„Åü„ÄÇ</li>
<li>Áï∞„Å™„ÇãÂâØ‰ΩúÁî®„ÅßÂãï‰Ωú„Åô„Çã„Ç≥„Éº„Éâ„ÇíÊõ∏„Åè„Åü„ÇÅ„Å´„ÄÅ„É¢„Éä„Éâ„ÇíÊäΩË±°ÁöÑ„Å´Êâ±„ÅÜÊñπÊ≥ï„ÇíË¶ã
„Åæ„Åó„Åü„ÄÇ</li>
<li>„É¢„Éä„Éâ„Åå„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÅÆ‰∏Ä‰æã„Åß„ÅÇ„Çã„Åì„Å®„ÄÅ‰∏°ËÄÖ„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´ÂâØ‰ΩúÁî®„ÅÆ„ÅÇ
„ÇãË®àÁÆó„ÇíÂèØËÉΩ„Å´„Åô„Çã„ÅÆ„Åã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÄÅ„Åù„Åó„Å¶2„Å§„ÅÆÊâãÊ≥ï„ÅÆÈÅï„ÅÑ„ÇíË™¨Êòé„Åó„Åæ„Åó„Åü„ÄÇ</li>
<li>„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™‰ΩúÁî®„ÅÆÊ¶ÇÂøµ„ÇíÂÆöÁæ©„Åó„ÄÅ„Éç„Ç§„ÉÜ„Ç£„Éñ„Å™ÂâØ‰ΩúÁî®„ÇíÂá¶ÁêÜ„Åô„Çã„Åü„ÇÅ„Å´‰ΩøÁî®
„Åô„Çã <code>Effect</code>„É¢„Éä„Éâ„ÇíÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇ</li>
<li>‰π±Êï∞ÁîüÊàê„ÄÅ‰æãÂ§ñ„ÄÅ„Ç≥„É≥„ÇΩ„Éº„É´ÂÖ•Âá∫Âäõ„ÄÅÂ§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„ÄÅ„Åä„Çà„Å≥React„Çí‰Ωø„Å£„Åü
DOMÊìç‰Ωú„Å®„ÅÑ„Å£„Åü„ÄÅ„Åï„Åæ„Åñ„Åæ„Å™‰ΩúÁî®„ÇíÊâ±„ÅÜ„Åü„ÇÅ„Å´ <code>Effect</code>„É¢„Éä„Éâ„Çí‰Ωø„ÅÑ„Åæ„Åó„Åü„ÄÇ</li>
</ul>
<p><code>Effect</code>„É¢„Éä„Éâ„ÅØÁèæÂÆü„ÅÆPureScript„Ç≥„Éº„Éâ„Å´„Åä„Åë„ÇãÂü∫Êú¨ÁöÑ„Å™„ÉÑ„Éº„É´„Åß„Åô„ÄÇ
Êú¨Êõ∏„Åß„ÅØ„Åì„ÅÆ„ÅÇ„Å®„ÇÇ„ÄÅÂ§ö„Åè„ÅÆÂ†¥Èù¢„ÅßÂâØ‰ΩúÁî®„ÇíÂá¶ÁêÜ„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Å£„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ÈùûÂêåÊúü‰ΩúÁî®"><a class="header" href="#ÈùûÂêåÊúü‰ΩúÁî®">ÈùûÂêåÊúü‰ΩúÁî®</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-7"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-7">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ<code>Aff</code>„É¢„Éä„Éâ„Å´ÈõÜ‰∏≠„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ<code>Effect</code>„É¢„Éä„Éâ„Å´‰ºº„Åü„ÇÇ„ÅÆ„Åß„Åô„Åå„ÄÅ<em>ÈùûÂêåÊúü</em>„Å™ÂâØ‰ΩúÁî®„ÇíË°®Áèæ„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†„Å®„ÇÑ„Çä„Å®„Çä„Åó„Å¶HTTP„É™„ÇØ„Ç®„Çπ„Éà„Çí‰Ωú„Çã„ÄÅÈùûÂêåÊúü„Å™‰æã„ÇíÂÆüÊºî„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
„Åæ„ÅüÈùûÂêåÊúü‰ΩúÁî®„ÅÆÁõ¥Âàó„Å™„ÅÑ„Åó‰∏¶Âàó„ÅÆÂÆüË°å„ÅÆÁÆ°ÁêÜÊñπÊ≥ï„ÇÇÊäº„Åï„Åà„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-6"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-6">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅßÂ∞éÂÖ•„Åô„ÇãÊñ∞„Åó„ÅÑPureScript„É©„Ç§„Éñ„É©„É™„ÅØ‰ª•‰∏ã„Åß„Åô„ÄÇ</p>
<ul>
<li><code>aff</code> - <code>Aff</code>„É¢„Éä„Éâ„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ</li>
<li><code>node-fs-aff</code> - <code>Aff</code>„Çí‰Ωø„Å£„ÅüÈùûÂêåÊúü„ÅÆ„Éï„Ç°„Ç§„É´„Ç∑„Çπ„ÉÜ„É†Êìç‰Ωú„ÄÇ</li>
<li><code>affjax</code> - AJAX„Å®<code>Aff</code>„Çí‰Ωø„Å£„ÅüHTTP„É™„ÇØ„Ç®„Çπ„Éà„ÄÇ</li>
<li><code>parallel</code> - <code>Aff</code>„ÅÆ‰∏¶ÂàóÂÆüË°å„ÄÇ</li>
</ul>
<p>ÔºàNode.jsÁí∞Â¢É„ÅÆ„Çà„ÅÜ„Å™Ôºâ„Éñ„É©„Ç¶„Ç∂Â§ñ„ÅßÂÆüË°å„Åô„ÇãÂ†¥Âêà„ÄÅ
<code>affjax</code>„É©„Ç§„Éñ„É©„É™„ÅØ<code>xhr2</code>NPM„É¢„Ç∏„É•„Éº„É´„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ
„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅØ„Åì„ÅÆÁ´†„ÅÆ<code>package.json</code>‰∏≠„ÅÆ‰æùÂ≠òÈñ¢‰øÇ„Å´Êåô„Åí„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÇíËµ∞„Çâ„Åõ„Å¶„Ç§„É≥„Çπ„Éà„Éº„É´„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-shell">$ npm install
</code></pre>
<h2 id="ÈùûÂêåÊúü„Å™javascript"><a class="header" href="#ÈùûÂêåÊúü„Å™javascript">ÈùûÂêåÊúü„Å™JavaScript</a></h2>
<p>JavaScript„ÅßÈùûÂêåÊúü„Å™„Ç≥„Éº„Éâ„Å´Âèñ„ÇäÁµÑ„ÇÄ‰∏ä„Åß‰æøÂà©„Å™ÊâãÊÆµ„ÅØ<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await"><code>async</code>„Å®<code>await</code></a>„Åß„Åô„ÄÇ
<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">ÈùûÂêåÊúü„Å™JavaScript„Å´Èñ¢„Åô„Çã„Åì„ÅÆË®ò‰∫ã</a>„ÇíË¶ã„Çã„Å®„Çà„ÇäËÉåÊôØÊÉÖÂ†±„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<p>‰ª•‰∏ã„ÅØ„Åì„ÅÆÊäÄÊ≥ï„Çí‰Ωø„Å£„Å¶„ÅÇ„Çã„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„ÇíÂà•„ÅÆ„Éï„Ç°„Ç§„É´„Å´Ë§áË£Ω„Åô„Çã‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-js">import { promises as fsPromises } from 'fs'

async function copyFile(file1, file2) {
  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });
  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });
}

copyFile('file1.txt', 'file2.txt')
.catch(e =&gt; {
  console.log('There was a problem with copyFile: ' + e.message);
});
</code></pre>
<p>„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇÑÂêåÊúüÈñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô„Åå„ÄÅ‰ª•‰∏ã„ÅÆÁêÜÁî±„Åã„ÇâÊúõ„Åæ„Åó„Åè„ÅÇ
„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<ul>
<li>„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÅØÈÅéÂâ∞„Å™ÂÖ•„ÇåÂ≠ê„Å´Áπã„Åå„Çä„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„Äå„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÂú∞ÁçÑ„Äç„ÇÑ„ÄåÊÇ™Â§¢„ÅÆ„Éî„É©„Éü„ÉÉ„Éâ„Äç„Å®„Åó„Å¶Áü•„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li>ÂêåÊúüÈñ¢Êï∞„ÅØ„Ç¢„Éó„É™‰∏≠„ÅÆ‰ªñ„ÅÆ„Ç≥„Éº„Éâ„ÅÆÂÆüË°å„ÇíÂ†∞„ÅçÊ≠¢„ÇÅ„Å¶„Åó„Åæ„ÅÑ„Åæ„Åô„ÄÇ</li>
</ul>
<h2 id="ÈùûÂêåÊúü„Å™purescript"><a class="header" href="#ÈùûÂêåÊúü„Å™purescript">ÈùûÂêåÊúü„Å™PureScript</a></h2>
<p>PureScript„Åß„Å´<code>Aff</code>„É¢„Éä„Éâ„ÅØJavaScript„ÅÆ<code>async</code>/<code>await</code>ÊßãÊñá„Å´‰ºº„Åü‰∫∫ÈñìÂ∑•Â≠¶„Çí‰æõ„Åó„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅØÂâç„Å®Âêå„Åò<code>copyFile</code>„ÅÆ‰æã„Åß„Åô„Åå„ÄÅ<code>Aff</code>„Çí‰Ωø„Å£„Å¶PureScript„ÅßÊõ∏„ÅçÊèõ„Åà„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">import Prelude
import Data.Either (Either(..))
import Effect.Aff (Aff, attempt, message)
import Effect.Class.Console (log)
import Node.Encoding (Encoding(..))
import Node.FS.Aff (readTextFile, writeTextFile)
import Node.Path (FilePath)

copyFile :: FilePath -&gt; FilePath -&gt; Aff Unit
copyFile file1 file2 = do
  my_data &lt;- readTextFile UTF8 file1
  writeTextFile UTF8 file2 my_data

main :: Aff Unit
main = do
  result &lt;- attempt $ copyFile &quot;file1.txt&quot; &quot;file2.txt&quot;
  case result of
    Left e -&gt; log $ &quot;There was a problem with copyFile: &quot; &lt;&gt; message e
    _ -&gt; pure unit
</code></pre>
<p>‰∏ä„ÅÆ„Ç≥„Éº„ÉâÁâá„Çí„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇÑÂêåÊúüÈñ¢Êï∞„Çí‰Ωø„Å£„Å¶Êõ∏„ÅçÊèõ„Åà„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åô„Åå
Ôºà‰æã„Åà„Å∞<code>Node.FS.Async</code>„ÇÑ<code>Node.FS.Sync</code>„Çí„Åù„Çå„Åû„Çå‰Ωø„ÅÑ„Åæ„ÅôÔºâ„ÄÅ
JavaScript„ÅßÂâç„Å´„ÅäË©±„Åó„Åó„Åü„Çà„ÅÜ„Å´Âêå„ÅòÁü≠ÊâÄ„Åå„Åì„Åì„Åß„ÇÇÈÄöÁî®„Åô„Çã„Åü„ÇÅ„ÄÅ
„Åù„Çå„Çâ„ÅÆ„Ç≥„Éº„Éá„Ç£„É≥„Ç∞ÂΩ¢Âºè„ÅØÊé®Â•®„Åï„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<p><code>Aff</code>„ÇíÊâ±„ÅÜÊñáÊ≥ï„ÅØ<code>Effect</code>„ÇíÊâ±„ÅÜ„ÇÇ„ÅÆ„Å®Â§ßÂ§â‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Å©„Å°„Çâ„ÇÇ„É¢„Éä„Éâ„Åß„Åô„Åó„ÄÅ„Åó„Åü„Åå„Å£„Å¶doË®òÊ≥ï„ÅßÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞<code>readTextFile</code>„ÅÆ„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíË¶ã„Çå„Å∞„ÄÅ
„Åì„Çå„Åå„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„Çí<code>String</code>„Å®„Åó„ÄÅ<code>Aff</code>„Å´ÂåÖ„Çì„ÅßËøî„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">readTextFile :: Encoding -&gt; FilePath -&gt; Aff String
</code></pre>
<p>doË®òÊ≥ï‰∏≠„Åß„ÅØÊùüÁ∏õÁü¢Âç∞ (<code>&lt;-</code>) „ÅßËøîÂç¥„Åï„Çå„ÅüÊñáÂ≠óÂàó„Çí„ÄåÈñãÂ∞Å„Äç„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">my_data &lt;- readTextFile UTF8 file1
</code></pre>
<p>„Åù„Çå„Åã„Çâ<code>writeTextFile</code>„Å´ÊñáÂ≠óÂàóÂºïÊï∞„Å®„Åó„Å¶Ê∏°„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">writeTextFile :: Encoding -&gt; FilePath -&gt; String -&gt; Aff Unit
</code></pre>
<p>‰∏ä„ÅÆ‰æã„Åß‰ªñ„Å´ÁõÆ„ÇíÂºï„Åè<code>Aff</code>Âõ∫Êúâ„ÅÆÁâπÂæ¥„ÅØ<code>attempt</code>„ÅÆ„Åø„Åß„Åô„ÄÇ
„Åì„Çå„ÅØ<code>Aff</code>„ÅÆ„Ç≥„Éº„Éâ„ÅÆÂÆüË°å‰∏≠„Å´ÈÅ≠ÈÅá„Åó„Åü„Ç®„É©„Éº„ÇÑ‰æãÂ§ñ„ÇíË£úË∂≥„Åó„Å¶<code>Either</code>ÂÜÖ„Å´‰øùÁÆ°„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">attempt :: forall a. Aff a -&gt; Aff (Either Error a)
</code></pre>
<p>Ë™≠ËÄÖ„Å™„Çâ„Åç„Å£„Å®„ÄÅÂâç„ÅÆÁ´†„Åã„ÇâÊ¶ÇÂøµ„ÅÆÁü•Ë≠ò„ÇíÂºï„ÅçÂá∫„Åó„ÄÅ
„Åù„ÅÆÁü•Ë≠ò„Å®‰∏ä„ÅÆ<code>copyFile</code>„ÅÆ‰æã„ÅßÂ≠¶„Çì„Å†Êñ∞„Åó„ÅÑ<code>Aff</code>„Éë„Çø„Éº„É≥„ÇíÁµêÂêà„Åô„Çã„Åì„Å®„Åß„ÄÅ
‰ª•‰∏ã„ÅÆÊºîÁøí„Å´ÊåëÊà¶„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="ÊºîÁøí-24"><a class="header" href="#ÊºîÁøí-24">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ2„Å§„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Éï‚Äã‚Äã„Ç°„Ç§„É´„ÇíÈÄ£Áµê„Åô„ÇãÈñ¢Êï∞<code>concatenateFiles</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÂÖ•Âäõ„Éï„Ç°„Ç§„É´Âêç„ÅÆÈÖçÂàó„Å®Âá∫Âäõ„Éï„Ç°„Ç§„É´Âêç„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åç„ÄÅ
Ë§áÊï∞„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Éï„Ç°„Ç§„É´„ÇíÈÄ£Áµê„Åô„ÇãÈñ¢Êï∞ <code>concatenateMany</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>traverse</code>„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ„Éï„Ç°„Ç§„É´‰∏≠„ÅÆÊñáÂ≠óÊï∞„ÇíËøî„Åô„Åã„Ç®„É©„Éº„Åå„ÅÇ„Çå„Å∞„Åù„Çå„ÇíËøî„ÅôÈñ¢Êï∞<code>countCharacters :: FilePath -&gt; Aff (Either Error Int)</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="Êõ¥„Å™„Çãaff„ÅÆË≥áÊñô"><a class="header" href="#Êõ¥„Å™„Çãaff„ÅÆË≥áÊñô">Êõ¥„Å™„ÇãAff„ÅÆË≥áÊñô</a></h2>
<p>„ÇÇ„Åó„Åæ„Å†<a href="https://pursuit.purescript.org/packages/purescript-aff/">ÂÖ¨Âºè„ÅÆAff„Ç¨„Ç§„Éâ</a>„ÇíË¶ã„Å¶„ÅÑ„Å™„Åë„Çå„Å∞„ÄÅ‰ªä„Åñ„Å£„Å®ÁõÆ„ÇíÈÄö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÁ´†„ÅÆÊÆã„Çä„ÅÆÊºîÁøí„ÇíÂÆå‰∫Ü„Åô„Çã„Åü„ÇÅ„ÅÆ‰∫ãÂâçË¶Å‰ª∂„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅ
Pursuit„Åß‰Ωï„Çâ„Åã„ÅÆÈñ¢Êï∞„ÇíË¶ã‰ªò„Åë„Å†„ÅôÂä©„Åë„Å´„Å™„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<p>„Åì„Çå„Çâ„ÅÆË£úË∂≥Ë≥áÊñô„Å´„Å§„ÅÑ„Å¶„ÇÇ„ÅÇ„Åü„Å£„Å¶„Åø„Çã„Å®„Çà„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ
„Åó„Åã„ÅóÁπ∞„ÇäËøî„Åó„Å´„Å™„Çä„Åæ„Åô„Åå„Åì„ÅÆÁ´†„ÅÆÊºîÁøí„ÅØ„Åù„Çå„Çâ„ÅÆÂÜÖÂÆπ„Å´‰æù„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<ul>
<li><a href="https://blog.drewolson.org/asynchronous-purescript">Drew„ÅÆAff„Å´Èñ¢„Åô„ÇãÊäïÁ®ø</a></li>
<li><a href="https://github.com/JordanMartinez/purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff">Êõ¥„Å™„ÇãAff„ÅÆË™¨Êòé„Å®‰æã</a></li>
</ul>
<h2 id="http„ÇØ„É©„Ç§„Ç¢„É≥„Éà"><a class="header" href="#http„ÇØ„É©„Ç§„Ç¢„É≥„Éà">HTTP„ÇØ„É©„Ç§„Ç¢„É≥„Éà</a></h2>
<p><code>affjax</code>„É©„Ç§„Éñ„É©„É™„ÅØ<code>Aff</code>„ÅßÈùûÂêåÊúüAJAX HTTPË¶ÅÊ±Ç„Çí‰Ωú„Çã‰æøÂà©„Å™ÊâãÊÆµ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
ÂØæË±°„Å®„Åó„Å¶„ÅÑ„ÇãÁí∞Â¢É„Åå‰Ωï„Åß„ÅÇ„Çã„Åã„Å´„Çà„Å£„Å¶„ÄÅ<a href="https://github.com/purescript-contrib/purescript-affjax-web">purescript-affjax-web</a>„Åæ„Åü„ÅØ<a href="https://github.com/purescript-contrib/purescript-affjax-node">purescript-affjax-node</a>„ÅÆ„Å©„Å°„Çâ„Åã„ÅÆ„É©„Ç§„Éñ„É©„É™„Çí‰Ωø„ÅÜÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆÁ´†„ÅÆ‰ª•Èôç„Åß„ÅØNode„ÇíÂØæË±°„Å®„Åó„Å¶„ÅÑ„Åè„ÅÆ„Åß„ÄÅ<code>purescript-affjax-node</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
„Çà„ÇäË©≥„Åó„ÅÑ‰ΩøÁî®‰∏ä„ÅÆÊÉÖÂ†±„ÅØ<a href="https://pursuit.purescript.org/packages/purescript-affjax">affjax„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà</a>„Å´„ÅÇ„Åü„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰ª•‰∏ã„ÅØ‰∏é„Åà„Çâ„Çå„ÅüURL„Å´Âêë„Åë„ÅüHTTP„ÅÆGETË¶ÅÊ±Ç„Çí„Åó„ÄÅÂøúÁ≠îÊú¨Êñá„Å™„ÅÑ„Åó„Ç®„É©„ÉºÊñáË®Ä„ÇíËøî„Åô‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">import Prelude
import Affjax.Node as AN
import Affjax.ResponseFormat as ResponseFormat
import Data.Either (Either(..))
import Effect.Aff (Aff)

getUrl :: String -&gt; Aff String
getUrl url = do
  result &lt;- AN.get ResponseFormat.string url
  pure case result of
    Left err -&gt; &quot;GET /api response failed to decode: &quot; &lt;&gt; AN.printError err
    Right response -&gt; response.body
</code></pre>
<p>„Åì„Çå„ÇíREPL„ÅßÂëº„Å≥Âá∫„ÅôÈöõ„ÅØ„ÄÅ<code>launchAff_</code>„Çí<code>Aff</code>„Åã„ÇâREPL„Å´‰∫íÊèõÊÄß„ÅÆ„ÅÇ„Çã<code>Effect</code>„Å∏„Å®Â§âÊèõ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-shell">$ spago repl

&gt; :pa
‚Ä¶ import Prelude
‚Ä¶ import Effect.Aff (launchAff_)
‚Ä¶ import Effect.Class.Console (log)
‚Ä¶ import Test.HTTP (getUrl)
‚Ä¶
‚Ä¶ launchAff_ do
‚Ä¶   str &lt;- getUrl &quot;https://reqres.in/api/users/1&quot;
‚Ä¶   log str
‚Ä¶
unit
{&quot;data&quot;:{&quot;id&quot;:1,&quot;email&quot;:&quot;george.bluth@reqres.in&quot;,&quot;first_name&quot;:&quot;George&quot;,&quot;last_name&quot;:&quot;Bluth&quot;, ...}}
</code></pre>
<h2 id="ÊºîÁøí-25"><a class="header" href="#ÊºîÁøí-25">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâHTTP„ÅÆ<code>GET</code>Ë¶ÅÊ±Ç„Çí‰∏é„Åà„Çâ„Çå„ÅüURL„Å´Ë°å„ÅÑ„ÄÅÂøúÁ≠îÊú¨Êñá„Çí„Éï„Ç°„Ç§„É´„Å´Êõ∏„ÅçËæº„ÇÄÈñ¢Êï∞<code>writeGet</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="‰∏¶ÂàóË®àÁÆó"><a class="header" href="#‰∏¶ÂàóË®àÁÆó">‰∏¶ÂàóË®àÁÆó</a></h2>
<p><code>Aff</code>„É¢„Éä„Éâ„Å®doË®òÊ≥ï„Çí‰Ωø„Å£„Å¶„ÄÅÈùûÂêåÊúüË®àÁÆó„ÇíÈ†ÜÁï™„Å´ÂÆüË°å„Åï„Çå„Çã„Çà„ÅÜ„Å´ÂêàÊàê„Åô„ÇãÊñπÊ≥ï„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ
ÈùûÂêåÊúüË®àÁÆó„Çí<strong>‰∏¶Âàó„Å´</strong>ÂêàÊàê„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åü„Çâ‰æøÂà©„Åß„Åó„Çá„ÅÜ„ÄÇ
<code>Aff</code>„Åå„ÅÇ„Çå„Å∞2„Å§„ÅÆË®àÁÆó„ÇíÊ¨°„ÄÖ„Å´ÈñãÂßã„Åô„Çã„Å†„Åë„Åß‰∏¶Âàó„Å´Ë®àÁÆó„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>parallel</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅØ<code>Aff</code>„ÅÆ„Çà„ÅÜ„Å™„É¢„Éä„Éâ„ÅÆ„Åü„ÇÅ„ÅÆÂûã„ÇØ„É©„Çπ<code>Parallel</code>„ÇíÂÆöÁæ©„Åó„Å¶„Åä„Çä„ÄÅ
‰∏¶ÂàóÂÆüË°å„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
‰ª•Ââç„Å´Êú¨Êõ∏„Åß„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Å´Âá∫‰ºö„Å£„Åü„Å®„Åç„ÄÅ
‰∏¶ÂàóË®àÁÆó„ÇíÂêàÊàê„Åô„Çã„Å®„Åç„Å´„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´‰æøÂà©„Å™„ÅÆ„Åã„ÇíË¶≥ÂØü„Åó„Åæ„Åó„Åü„ÄÇ
ÂÆü„ÅØ<code>Parallel</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ„ÄÅÔºà<code>Aff</code>„ÅÆ„Çà„ÅÜ„Å™Ôºâ„É¢„Éä„Éâ<code>m</code>„Å®„ÄÅ
‰∏¶Âàó„Å´Ë®àÁÆó„ÇíÂêàÊàê„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Çã„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã<code>f</code>„Å®„ÅÆÂØæÂøúÈñ¢‰øÇ„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">class (Monad m, Applicative f) &lt;= Parallel f m | m -&gt; f, f -&gt; m where
  sequential :: forall a. f a -&gt; m a
  parallel :: forall a. m a -&gt; f a
</code></pre>
<p>„Åì„ÅÆ„ÇØ„É©„Çπ„ÅØ2„Å§„ÅÆÈñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>parallel</code>Ôºö„É¢„Éä„Éâ <code>m</code>‰∏≠„ÅÆË®àÁÆó„ÇíÂèñ„Çä„ÄÅ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã<code>f</code>‰∏≠„ÅÆË®àÁÆó„Å´
Â§â„Åà„Åæ„Åô„ÄÇ</li>
<li><code>sequential</code>ÔºöÂèçÂØæÊñπÂêë„ÅÆÂ§âÊèõ„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ</li>
</ul>
<p><code>aff</code>„É©„Ç§„Éñ„É©„É™„ÅØ <code>Aff</code>„É¢„Éä„Éâ„ÅÆ <code>Parallel</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØ„ÄÅ2„Å§„ÅÆÁ∂ôÁ∂ö (continuation) „ÅÆ„Å©„Å°„Çâ„ÅåÂëº„Å≥Âá∫„Åï„Çå„Åü„Åã„ÇíÊääÊè°„Åô„Çã„Åì„Å®„Å´„Çà„Å£„Å¶„ÄÅ
Â§âÊõ¥ÂèØËÉΩ„Å™ÂèÇÁÖß„Çí‰ΩøÁî®„Åó„Å¶‰∏¶Âàó„Å´ <code>Aff</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Åæ„Åô„ÄÇ
‰∏°Êñπ„ÅÆÁµêÊûú„ÅåËøî„Åï„Çå„Åü„Çâ„ÄÅÊúÄÁµÇÁµêÊûú„ÇíË®àÁÆó„Åó„Å¶„É°„Ç§„É≥„ÅÆÁ∂ôÁ∂ö„Å´Ê∏°„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åß„ÅØ‰ªªÊÑèÂÄãÂºïÊï∞„ÅÆÈñ¢Êï∞„ÅÆÊåÅ„Å°‰∏ä„Åí„Åå„Åß„Åç„Çã„ÅÆ„Åß„ÄÅ
„Åì„ÅÆ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Ç≥„É≥„Éì„Éç„Éº„Çø„Çí‰Ωø„Å£„Å¶„Çà„ÇäÂ§ö„Åè„ÅÆË®àÁÆó„Çí‰∏¶Âàó„Å´ÂÆüË°å„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>traverse</code>„ÇÑ<code>sequence</code>„Å®„ÅÑ„Å£„Åü„ÄÅ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„ÇíÊâ±„ÅÜ
„Åô„Åπ„Å¶„ÅÆÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™Èñ¢Êï∞„Åã„ÇâÊÅ©ÊÅµ„ÇíÂèó„Åë„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÂøÖË¶Å„Å´Âøú„Åò„Å¶ <code>parralel</code>„Å®<code>sequential</code>„Çí‰Ωø„Å£„Å¶ÂûãÊßãÁØâÂ≠ê„ÇíÂ§âÊõ¥„Åô„Çã„Åì„Å®„Åß„ÄÅ
doË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ‰∏≠„Åß„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Ç≥„É≥„Éì„Éç„Éº„Çø„Çí‰Ωø„ÅÑ„ÄÅ
Áõ¥ÂàóÁöÑ„Å™„Ç≥„Éº„Éâ„ÅÆ‰∏ÄÈÉ®„Åß‰∏¶ÂàóË®àÁÆó„ÇíÁµêÂêà„Åó„Åü„Çä„ÄÅ
„Åæ„Åü„ÅØ„Åù„ÅÆÈÄÜ„ÇíË°å„Å£„Åü„Çä„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>Áõ¥ÂàóÂÆüË°å„Å®‰∏¶ÂàóÂÆüË°å„ÅÆÈñì„ÅÆÈÅï„ÅÑ„ÇíÂÆüÊºî„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ
100ÂÄã„ÅÆ10„Éü„É™Áßí„ÅÆÈÅÖÂª∂„Åã„Çâ„Å™„ÇãÈÖçÂàó„Çí„Å§„Åè„Çä„ÄÅ
„Åù„Çå„Åã„Çâ„Åù„ÅÆÈÅÖÂª∂„Çí‰∏°Êñπ„ÅÆÊâãÊ≥ï„ÅßÂÆüË°å„Åó„Åæ„Åô„ÄÇ
REPL„ÅßË©¶„Åô„Å®<code>seqDelay</code>„Åå<code>parDelay</code>„Çà„ÇäÈÅ•„Åã„Å´ÈÅÖ„ÅÑ„Åì„Å®„Å´Ê∞ó‰ªò„Åè„Åß„Åó„Çá„ÅÜ„ÄÇ
‰∏¶ÂàóÂÆüË°å„Åå<code>sequence_</code>„Çí<code>parSequence_</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Çã„Å†„Åë„ÅßÊúâÂäπ„Å´„Å™„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parSequence_)
import Data.Array (replicate)
import Data.Foldable (sequence_)
import Effect (Effect)
import Effect.Aff (Aff, Milliseconds(..), delay, launchAff_)

delayArray :: Array (Aff Unit)
delayArray = replicate 100 $ delay $ Milliseconds 10.0

seqDelay :: Effect Unit
seqDelay = launchAff_ $ sequence_ delayArray

parDelay :: Effect Unit
parDelay = launchAff_ $ parSequence_ delayArray
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelDelay

&gt; seqDelay -- This is slow
unit

&gt; parDelay -- This is fast
unit
</code></pre>
<p>‰ª•‰∏ã„ÅØË§áÊï∞„ÅÆHTTPË¶ÅÊ±Ç„Çí‰∏¶Âàó„ÅßË°å„ÅÜ„ÄÅ„Çà„ÇäÁèæÂÆüÂë≥„ÅÆ„ÅÇ„Çã‰æã„Åß„Åô„ÄÇ
<code>getUrl</code>Èñ¢Êï∞„ÇíÂÜçÂà©Áî®„Åó„Å¶2‰∫∫„ÅÆÂà©Áî®ËÄÖ„Åã„Çâ‰∏¶Âàó„ÅßÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆÂ†¥Âêà„Åß„ÅØ<code>parTarverse</code>Ôºà<code>traverse</code>„ÅÆ‰∏¶ÂàóÁâàÔºâ„Åå‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„Å≠„ÄÇ
„Åì„ÅÆ‰æã„ÅØ‰ª£„Çè„Çä„Å´<code>traverse</code>„Åß„ÇÇÂïèÈ°å„Å™„ÅèÂãï„Åç„Åæ„Åô„Åå„Çà„ÇäÈÅÖ„Åè„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-hs">import Prelude

import Control.Parallel (parTraverse)
import Effect (Effect)
import Effect.Aff (launchAff_)
import Effect.Class.Console (logShow)
import Test.HTTP (getUrl)

fetchPar :: Effect Unit
fetchPar =
  launchAff_ do
    let
      urls = map (\n -&gt; &quot;https://reqres.in/api/users/&quot; &lt;&gt; show n) [ 1, 2 ]
    res &lt;- parTraverse getUrl urls
    logShow res
</code></pre>
<pre><code class="language-shell">$ spago repl

&gt; import Test.ParallelFetch

&gt; fetchPar
unit
[&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:1,\&quot;email\&quot;:\&quot;george.bluth@reqres.in\&quot;, ... }&quot;
,&quot;{\&quot;data\&quot;:{\&quot;id\&quot;:2,\&quot;email\&quot;:\&quot;janet.weaver@reqres.in\&quot;, ... }&quot;
]
</code></pre>
<p>Âà©Áî®„Åß„Åç„Çã‰∏¶ÂàóÈñ¢Êï∞„ÅÆÂÆåÂÖ®„Å™‰∏ÄË¶ß„ÅØ<a href="https://pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel">Pursuit„ÅÆ<code>parallel</code>„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà</a>„ÅßË¶ã‰ªò„Åã„Çä„Åæ„Åô„ÄÇ
<a href="https://github.com/purescript-contrib/purescript-aff#parallel-execution">parallel„ÅÆaff„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÁØÄ</a>„Å´„ÇÇ„Çà„ÇäÂ§ö„Åè„ÅÆ‰æã„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-26"><a class="header" href="#ÊºîÁøí-26">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâÂâç„ÅÆ<code>concatenateMany</code>Èñ¢Êï∞„Å®Âêå„Åò„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊåÅ„Å§<code>concatenateManyParallel</code>Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åü„Å†„ÅóÂÖ®„Å¶„ÅÆÂÖ•Âäõ„Éï„Ç°„Ç§„É´„Çí‰∏¶Âàó„Å´Ë™≠„ÇÄ„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ‰∏é„Åà„Çâ„Çå„ÅüURL„Å∏HTTP <code>GET</code>Ë¶ÅÊ±Ç„ÇíË°å„ÅÑ‰ª•‰∏ã„ÅÆ„ÅÑ„Åö„Çå„Åã„ÇíËøî„Åô<code>getWithTimeout :: Number -&gt; String -&gt; Aff (Maybe String)</code>Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<ul>
<li><code>Nothing</code>: Ë¶ÅÊ±Ç„Åó„Å¶„Åã„Çâ‰∏é„Åà„Çâ„Çå„ÅüÊôÇÈñìÂà∂ÈôêÔºà„Éü„É™ÁßíÂçò‰ΩçÔºâ„Çà„ÇäÈï∑„ÅèÊéõ„Åã„Å£„ÅüÂ†¥Âêà„ÄÇ</li>
<li>ÊñáÂ≠óÂàó„ÅÆÂøúÁ≠îÔºöÊôÇÈñìÂà∂Èôê„ÇíË∂ä„Åà„ÇãÂâç„Å´Ë¶ÅÊ±Ç„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÄÇ</li>
</ul>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ„ÄåÊ†π„Äç„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÂèñ„Çä„ÄÅ„Åù„ÅÆ„Éï„Ç°„Ç§„É´„ÅÆ‰∏≠„ÅÆÂÖ®„Å¶„ÅÆ„Éë„Çπ„ÅÆ‰∏ÄË¶ßÔºà„Åù„Åó„Å¶‰∏ÄË¶ß„Å´„ÅÇ„Çã„Éï„Ç°„Ç§„É´„ÅÆ‰∏≠„ÅÆ‰∏ÄË¶ß„ÇÇÔºâ„ÅÆÈÖçÂàó„ÇíËøî„Åô<code>recurseFiles</code>Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰∏ÄË¶ß„Å´„Å™„Å£„Åü„Éï„Ç°„Ç§„É´„Çí‰∏¶Âàó„Å´Ë™≠„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
„Éë„Çπ„ÅØ„Åù„ÅÆ„Éï„Ç°„Ç§„É´„ÅåË°®„Çå„Åü„Éá„Ç£„É¨„ÇØ„Éà„É™„Åã„ÇâÁõ∏ÂØæÁöÑ„Å™„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>node_path</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ„Éá„Ç£„É¨„ÇØ„Éà„É™„Å®„ÇÑ„Çä„Å®„Çä„Åô„Çã‰∏ä„Åß‰æøÂà©„Å™Èñ¢Êï∞„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
</li>
</ol>
<p>„Åü„Å®„Åà„Å∞„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™<code>root.txt</code>„Éï„Ç°„Ç§„É´„Åã„ÇâÂßã„Åæ„Çã„Å®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-shell">$ cat root.txt
a.txt
b/a.txt
c/a/a.txt

$ cat a.txt
b/b.txt

$ cat b/b.txt
c/a.txt

$ cat b/c/a.txt

$ cat b/a.txt

$ cat c/a/a.txt
</code></pre>
<p>ÊúüÂæÖ„Åï„Çå„ÇãÂá∫Âäõ„ÅØÊ¨°„ÅÆÈÄö„Çä„ÄÇ</p>
<pre><code class="language-hs">[&quot;root.txt&quot;,&quot;a.txt&quot;,&quot;b/a.txt&quot;,&quot;b/b.txt&quot;,&quot;b/c/a.txt&quot;,&quot;c/a/a.txt&quot;]
</code></pre>
<h2 id="„Åæ„Å®„ÇÅ-7"><a class="header" href="#„Åæ„Å®„ÇÅ-7">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØÈùûÂêåÊúü„Ç®„Éï„Çß„ÇØ„Éà„Å®‰ª•‰∏ã„ÅÆÊñπÊ≥ï„ÇíÊäº„Åï„Åà„Åæ„Åó„Åü„ÄÇ</p>
<ul>
<li><code>aff</code>„É©„Ç§„Éñ„É©„É™„Çí‰Ωø„Å£„Å¶<code>Aff</code>„É¢„Éä„Éâ‰∏≠„ÅßÈùûÂêåÊúü„Ç≥„Éº„Éâ„ÇíËµ∞„Çâ„Åõ„Çã„ÄÇ</li>
<li><code>affjax</code>„É©„Ç§„Éñ„É©„É™„Çí‰Ωø„Å£„Å¶ÈùûÂêåÊúü„Å´HTTP„É™„ÇØ„Ç®„Çπ„Éà„ÇíË°å„ÅÜ„ÄÇ</li>
<li><code>parallel</code>„É©„Ç§„Éñ„É©„É™„Çí‰Ωø„Å£„Å¶‰∏¶Âàó„Å´ÈùûÂêåÊúü„Ç≥„Éº„Éâ„ÇíËµ∞„Çâ„Åõ„Çã„ÄÇ</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ"><a class="header" href="#Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ">Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-8"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-8">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅßPureScript„ÅÆ<strong>Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ</strong> (foreign function interface; FFI) „ÇíÁ¥π‰ªã„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„Å´„Çà„ÇäPureScript„Ç≥„Éº„Éâ„Åã„ÇâJavaScript„Ç≥„Éº„Éâ„Å∏„ÅÆÂëº„Å≥Âá∫„Åó„ÄÅ„Åä„Çà„Å≥„Åù„ÅÆÈÄÜ„ÅåÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„Åã„ÇâÊâ±„ÅÜ„ÅÆ„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<ul>
<li>Á¥îÁ≤ã„Åß„ÄÅ‰ΩúÁî®„ÅÆ„ÅÇ„Çã„ÄÅÈùûÂêåÊúü„Å™JavaScriptÈñ¢Êï∞„ÇíPureScript„Åã„ÇâÂëº„Å≥Âá∫„Åô„ÄÇ</li>
<li>Âûã‰ªò„Åë„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Éá„Éº„Çø„ÇíÊâ±„ÅÜ„ÄÇ</li>
<li><code>argonaut</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰Ωø„Å£„Å¶JSON„Å´Á¨¶Âè∑Âåñ„Åó„Åü„ÇäJSON„ÇíÊßãÊñáËß£Êûê„Åó„Åü„Çä„Åô„Çã„ÄÇ</li>
</ul>
<p>„Åì„ÅÆÁ´†„ÅÆÁµÇ„Çè„Çä„Å´„Åã„Åë„Å¶„ÄÅ‰ΩèÊâÄÈå≤„ÅÆ‰æã„Å´Á´ã„Å°Ëøî„Çä„Åæ„Åô„ÄÇ
„Åì„ÅÆÁ´†„ÅÆÁõÆÁöÑ„ÅØ„ÄÅFFI„Çí‰Ωø„Å£„Å¶„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å´Ê¨°„ÅÆÊñ∞„Åó„ÅÑÊ©üËÉΩ„ÇíËøΩÂä†„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<ul>
<li>Âà©Áî®ËÄÖ„Å´„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÈÄöÁü•„ÅßË≠¶Âëä„Åô„Çã„ÄÇ</li>
<li>„Éï„Ç©„Éº„É†„ÅÆ„Éá„Éº„Çø„ÇíÁõ¥ÂàóÂåñ„Åó„Å¶„Éñ„É©„Ç¶„Ç∂„ÅÆ„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò„Åó„ÄÅ„Ç¢„Éó
„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅåÂÜçËµ∑Âãï„Åó„Åü„Å®„Åç„Å´„Åù„Çå„ÇíÂÜçË™≠„ÅøËæº„Åø„Åô„Çã</li>
</ul>
<p>„ÅÑ„Åè„Å§„Åã„ÅÆ‰∏ÄËà¨„Å´„ÅØ„Åù„Åì„Åæ„ÅßÈáçÁî®„Åï„Çå„Å™„ÅÑËøΩÂä†„ÅÆË©±È°å„ÇíÊäº„Åï„Åà„ÅüË£úÈÅ∫„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
Ëá™Áî±„Å´„Åì„Çå„Çâ„ÅÆÁØÄ„ÇíË™≠„Çì„ÅßÊßã„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅ
Â≠¶ÁøíÁõÆÊ®ô„Å´„ÅÇ„Åæ„ÇäÈñ¢‰øÇ„Åó„Å™„Åë„Çå„Å∞Êú¨„ÅÆÊÆã„Çä„ÇíË™≠„ÅøÈÄ≤„ÇÅ„ÇãÂ¶®„Åí„Å´„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<ul>
<li>ÂÆüË°åÊôÇ„ÅÆPureScript„ÅÆÂÄ§„ÅÆË°®Áèæ„ÇíÁêÜËß£„Åô„Çã„ÄÇ</li>
<li>JavaScript„Åã„ÇâPureScript„ÇíÂëº„Å≥Âá∫„Åô„ÄÇ</li>
</ul>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-7"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-7">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ„ÄÅÁ¨¨3Á´†„ÄÅÁ¨¨7Á´†Âèä„Å≥Á¨¨8Á´†„ÅÆÁ∂ö„Åç„Å´„Å™„Çä„Åæ„Åô„ÄÇ
‰ªäÂõû„ÇÇ„Åù„Çå„Åû„Çå„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„Åã„ÇâÈÅ©Âàá„Å™„ÇΩ„Éº„Çπ„Éï„Ç°„Ç§„É´„Åå„ÇΩ„Éº„Çπ„Éï„Ç°„Ç§„É´„Å´Âê´„ÇÅ„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„ÅØ<code>argonaut</code>„É©„Ç§„Éñ„É©„É™„Çí‰æùÂ≠òÈñ¢‰øÇ„Å®„Åó„Å¶Â∞éÂÖ•„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅØJSON„Å´Á¨¶Âè∑Âåñ„Åó„Åü„ÇäJSON„ÇíÂæ©Âè∑Âåñ„Åó„Åü„Çä„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„ÅÆÊºîÁøí„ÅØ<code>test/MySolutions.purs</code>„Å´Êõ∏„Åç„ÄÅ
<code>spago test</code>„ÇíËµ∞„Çâ„Åõ„Çã„Åì„Å®„Å´„Çà„Å£„Å¶<code>test/Main.purs</code>‰∏≠„ÅÆÂçò‰ΩìË©¶È®ì„Å´ÂØæ„Åó„Å¶Á¢∫Ë™ç„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰ΩèÊâÄÈå≤„Ç¢„Éó„É™„ÅØ<code>parcel src/index.html --open</code>„ÅßÁ´ã„Å°‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
8Á´†„Å®Âêå„Åò‰ΩúÊ•≠„ÅÆÊµÅ„Çå„Çí‰Ωø„Å£„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„Çà„ÇäË©≥„Åó„ÅÑË™¨Êòé„Å´„Å§„ÅÑ„Å¶„ÅØ„Åù„Å°„Çâ„ÅÆÁ´†„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="ÂÖçË≤¨‰∫ãÈ†Ö"><a class="header" href="#ÂÖçË≤¨‰∫ãÈ†Ö">ÂÖçË≤¨‰∫ãÈ†Ö</a></h2>
<p>JavaScript„ÇíÊâ±„ÅÜ‰ΩúÊ•≠„Çí„Åß„Åç„ÇãÈôê„ÇäÁ∞°Âçò„Å´„Åô„Çã„Åü„ÇÅ„ÄÅ
PureScript„ÅØÁõ¥ÊÑüÁöÑ„Å™Â§ñÈÉ®Èñ¢Êï∞„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅFFI„ÅØPureScript„ÅÆ<strong>È´òÂ∫¶„Å™</strong>Ê©üËÉΩ„Åß„ÅÇ„Çã„Åì„Å®„Å´„ÅØÁïôÊÑè„Åó„Å¶„ÅÑ„Åü„Å†„Åç„Åü„ÅÑ„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ
FFI„ÇíÂÆâÂÖ®„Åã„Å§ÂäπÁéáÁöÑ„Å´‰ΩøÁî®„Åô„Çã„Å´„ÅØ„ÄÅ
Êâ±„ÅÜ„Å§„ÇÇ„Çä„Åß„ÅÇ„Çã„Éá„Éº„Çø„ÅÆÂÆüË°åÊôÇ„ÅÆË°®Áèæ„Å´„Å§„ÅÑ„Å¶„Çà„ÅèÁêÜËß£„Åó„Å¶„ÅÑ„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅPureScript„ÅÆÊ®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„ÅÆ„Ç≥„Éº„Éâ„Å´‰ªò„ÅÑ„Å¶Âõû„Çã
„Åù„ÅÆ„Çà„ÅÜ„Å™ÁêÜËß£„Çí‰∏é„Åà„Çã„Åì„Å®„ÇíÁõÆÊåá„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>PureScript„ÅÆFFI„ÅØ„Å®„Å¶„ÇÇÊüîËªü„Å´Ë®≠Ë®à„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂÆüÈöõ„Å´„ÅØ„ÄÅÂ§ñÈÉ®Èñ¢Êï∞„Å´ÊúÄ‰ΩéÈôê„ÅÆÂûã„Å†„Åë„Çí‰∏é„Åà„Çã„Åã„ÄÅ
„Åù„Çå„Å®„ÇÇÂûã„Ç∑„Çπ„ÉÜ„É†„ÇíÂà©Áî®„Åó„Å¶Â§ñÈÉ®„ÅÆ„Ç≥„Éº„Éâ„ÅÆË™§„Å£„Åü‰Ωø„ÅÑÊñπ„ÇíÈò≤„Åê„Çà„ÅÜ„Å´„Åô„Çã„Åã„ÄÅ
ÈñãÁô∫ËÄÖ„ÅåÈÅ∏„Å∂„Åì„Å®„Åå„Åß„Åç„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ê®ôÊ∫ñ„É©„Ç§„Éñ„É©„É™„ÅÆ„Ç≥„Éº„Éâ„ÅØ„ÄÅÂæåËÄÖ„ÅÆÊâãÊ≥ï„ÇíÂ•Ω„ÇÄÂÇæÂêë„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>Á∞°Âçò„Å™‰æã„Å®„Åó„Å¶„ÅØ„ÄÅ
JavaScript„ÅÆÈñ¢Êï∞„ÅßÊàª„ÇäÂÄ§„Åå <code>null</code>„Å´„Å™„Çâ„Å™„ÅÑ„Åì„Å®„Çí‰øùË®º„Åô„Çã„Åì„Å®„ÅØ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ
ÂÆü„ÅÆ„Å®„Åì„Çç„ÄÅJavaScript„Çâ„Åó„Åï„ÅÆ„ÅÇ„Çã„Ç≥„Éº„Éâ„ÅØ„Åã„Å™„ÇäÈ†ªÁπÅ„Å´ <code>null</code>„ÇíËøî„Åó„Åæ„ÅôÔºÅ
„Åó„Åã„Åó„ÄÅÂ§ßÊäµPureScript„ÅÆÂûã„Å´nullÂÄ§„ÅåÂ∑£Âñ∞„ÅÜ„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Åù„ÅÆ„Åü„ÇÅ„ÄÅFFI„Çí‰Ωø„Å£„Å¶JavaScript„Ç≥„Éº„Éâ„ÅÆ„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„ÇíË®≠Ë®à„Åô„Çã„Å®„Åç„ÅØ„ÄÅ
„Åì„Çå„Çâ„ÅÆÁâπÊÆä„Å™Â†¥Âêà„ÇíÈÅ©Âàá„Å´Âá¶ÁêÜ„Åô„Çã„ÅÆ„ÅØÈñãÁô∫ËÄÖ„ÅÆË≤¨‰ªª„Åß„Åô„ÄÇ</p>
<h2 id="purescript„Åã„Çâjavascript„ÇíÂëº„Å≥Âá∫„Åô"><a class="header" href="#purescript„Åã„Çâjavascript„ÇíÂëº„Å≥Âá∫„Åô">PureScript„Åã„ÇâJavaScript„ÇíÂëº„Å≥Âá∫„Åô</a></h2>
<p>PureScript„Åã„ÇâJavaScript„Ç≥„Éº„Éâ„Çí‰ΩøÁî®„Åô„ÇãÊúÄ„ÇÇÁ∞°Âçò„Å™ÊñπÊ≥ï„ÅØ„ÄÅ
<strong>Â§ñÈÉ®„Ç§„É≥„Éù„Éº„ÉàÂÆ£Ë®Ä</strong> (foreign import declaration) „Çí‰ΩøÁî®„Åó„ÄÅ
Êó¢Â≠ò„ÅÆJavaScript„ÅÆÂÄ§„Å´Âûã„Çí‰∏é„Åà„Çã„Åì„Å®„Åß„Åô„ÄÇ
Â§ñÈÉ®„Ç§„É≥„Éù„Éº„ÉàÂÆ£Ë®Ä„Å´„ÅØ<strong>Â§ñÈÉ®JavaScript„É¢„Ç∏„É•„Éº„É´</strong> (foreign JavaScript module) „Åã„Çâ
<strong>„Ç®„ÇØ„Çπ„Éù„Éº„Éà</strong>„Åï„Çå„ÅüÂØæÂøú„Åô„ÇãJavaScript„Åß„ÅÆÂÆ£Ë®Ä„Åå„Å™„Åè„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅÁâπÊÆäÊñáÂ≠ó„Çí„Ç®„Çπ„Ç±„Éº„Éó„Åô„Çã„Åì„Å®„Å´„Çà„ÇäURI„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÇíÁ¨¶Âè∑Âåñ„Åô„ÇãJavaScript„ÅÆ
<code>encodeURIComponent</code>Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p><code>null</code>„Åß„Å™„ÅÑÊñáÂ≠óÂàó„Åã„Çâ <code>null</code>„Åß„Å™„ÅÑÊñáÂ≠óÂàó„Å∏„ÅÆÈñ¢Êï∞„Åß„ÅÇ„Çä„ÄÅÂâØ‰ΩúÁî®„ÇíÊåÅ„Å£„Å¶„ÅÑ„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØ„Åù„ÅÆÂûã <code>String -&gt; String</code>„Å´„Å§„ÅÑ„Å¶ÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„ÅÆ„Çà„ÅÜ„Å™Â§ñÈÉ®„Ç§„É≥„Éù„Éº„ÉàÂÆ£Ë®Ä„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Åì„ÅÆÈñ¢Êï∞„Å´Âûã„ÇíÂâ≤„ÇäÂΩì„Å¶„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">module Test.URI where

foreign import _encodeURIComponent :: String -&gt; String
</code></pre>
<p>„Ç§„É≥„Éù„Éº„Éà„Åó„Å¶„Åè„Çã„Åü„ÇÅ„ÅÆÂ§ñÈÉ®JavaScript„É¢„Ç∏„É•„Éº„É´„ÇíÊõ∏„ÅèÂøÖË¶Å„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÂØæÂøú„Åô„ÇãÂ§ñÈÉ®JavaScript„É¢„Ç∏„É•„Éº„É´„ÅØÂêåÂêç„ÅßÊã°ÂºµÂ≠ê„Åå<code>.purs</code>„Åã„Çâ<code>.js</code>„Å´Â§â„Çè„Å£„Åü„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
‰∏ä„ÅÆPureScript„É¢„Ç∏„É•„Éº„É´„Åå<code>URI.purs</code>„Å®„Åó„Å¶‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Çã„Å™„Çâ„ÄÅ
Â§ñÈÉ®JavaScript„É¢„Ç∏„É•„Éº„É´„ÅØ<code>URI.js</code>„Å®„Åó„Å¶‰øùÂ≠ò„Åï„Çå„Åæ„Åô„ÄÇ
<code>encodeURIComponent</code>„ÅØÊó¢„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ<code>_encodeURIComponent</code>„Å®„Åó„Å¶„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åõ„Å≠„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

export const _encodeURIComponent = encodeURIComponent;
</code></pre>
<p>„Éê„Éº„Ç∏„Éß„É≥0.15„Åã„ÇâPureScript„ÅØJavaScript„Å®ÈÄöË®≥„Åô„ÇãÈöõ„Å´ES„É¢„Ç∏„É•„Éº„É´„Ç∑„Çπ„ÉÜ„É†„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
ES„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´<code>export</code>„Ç≠„Éº„ÉØ„Éº„Éâ„Çí‰∏é„Åà„Çã„Åì„Å®„ÅßÈñ¢Êï∞„Å®ÂÄ§„ÅØ„É¢„Ç∏„É•„Éº„É´„Åã„Çâ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Çâ2„Å§„ÅÆÈÉ®ÂìÅ„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„ÄÅPureScript„ÅßÊõ∏„Åã„Çå„ÅüÈñ¢Êï∞„ÅÆ„Çà„ÅÜ„Å´„ÄÅ
PureScript„Åã„Çâ<code>encodeURIComponent</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞PSCi„Åß‰∏äË®ò„ÅÆË®àÁÆó„ÇíÂÜçÁèæ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; _encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>Â§ñÈÉ®„É¢„Ç∏„É•„Éº„É´„Å´Ëá™Ââç„ÅÆÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅØ<code>Number</code>„ÇíÂπ≥Êñπ„Åô„ÇãËá™Ââç„ÅÆJavaScriptÈñ¢Êï∞„Çí‰Ωú„Å£„Å¶Âëº„Å≥Âá∫„ÅôÊñπÊ≥ï„ÅÆ‰∏Ä‰æã„Åß„Åô„ÄÇ</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

export const square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="Â§öÂ§âÊï∞Èñ¢Êï∞"><a class="header" href="#Â§öÂ§âÊï∞Èñ¢Êï∞">Â§öÂ§âÊï∞‚ÄãÈñ¢Êï∞</a></h2>
<p>Á¨¨2Á´†„ÅÆ<code>diagonal</code>Èñ¢Êï∞„ÇíÂ§ñÈÉ®„É¢„Ç∏„É•„Éº„É´„ÅßÊõ∏„ÅçÁõ¥„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÁõ¥Ëßí‰∏âËßíÂΩ¢„ÅÆÂØæËßíÁ∑ö„ÇíË®àÁÆó„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>PureScript„ÅÆÈñ¢Êï∞„ÅØ<strong>„Ç´„É™„ÉºÂåñ</strong>„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>diagonal</code>„ÅØ<code>Number</code>„ÇíÂèñ„Å£„Å¶<strong>Èñ¢Êï∞</strong>„ÇíËøî„ÅôÈñ¢Êï∞„Åß„Åô„ÄÇ
„Åù„Åó„Å¶Ëøî„Åï„Çå„ÅüÈñ¢Êï∞„ÅØ<code>Number</code>„ÇíÂèñ„Å£„Å¶<code>Number</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">export const diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>„ÇÇ„Åó„Åè„ÅØES6„ÅÆÁü¢Âç∞ÊßãÊñá„Åß„ÅØ„Åì„ÅÜ„Åß„ÅôÔºàÂæåËø∞„Åô„ÇãES6„Å´„Å§„ÅÑ„Å¶„ÅÆË£úË∂≥„ÇíÊüªË®º„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ„ÄÇ</p>
<pre><code class="language-js">export const diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞"><a class="header" href="#„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞">„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞</a></h2>
<p>JavaScript„Åß„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„ÅØ„ÄÅ
„Åü„Å†„Åß„Åï„ÅàJavaScript„Çâ„Åó„ÅÑ„ÇÇ„ÅÆ„Åß„ÅØ„Å™„ÅÑ‰∏ä„Å´„ÄÅÂ∏∏„Å´ÂèØËÉΩ„Å®„ÅÑ„ÅÜ„Çè„Åë„Åß„ÇÇ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Çà„Åè„ÅÇ„ÇãÂ§öÂ§âÊï∞„Å™JavaScript„ÅÆÈñ¢Êï∞„ÅØ<strong>„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ</strong>ÂΩ¢Âºè„ÇíÂèñ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-js">export const diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>„É¢„Ç∏„É•„Éº„É´<code>Data.Function.Uncurried</code>„ÅØ<strong>„É©„ÉÉ„Éë„Éº</strong>Âûã„Å®
„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„ÇíÂèñ„ÇäÊâ±„ÅÜÈñ¢Êï∞„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>ÂûãÊßãÁØâÂ≠ê<code>Fn2</code>„ÇíË™ø„Åπ„Çã„Å®‰ª•‰∏ã„Åß„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code>„ÅØ3„Å§„ÅÆÂûãÂºïÊï∞„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ
<code>Fn2 a b c</code>„ÅØ„ÄÅÂûã <code>a</code>„Å® <code>b</code>„ÅÆ2„Å§„ÅÆÂºïÊï∞„ÄÅ
Ëøî„ÇäÂÄ§„ÅÆÂûã <code>c</code>„Çí„ÇÇ„Å§„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„ÅÆÂûã„ÇíË°®Áèæ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çí‰Ωø„Å£„Å¶Â§ñÈÉ®„É¢„Ç∏„É•„Éº„É´„Åã„Çâ<code>diagonalUncurried</code>„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åó„Åü„ÄÇ</p>
<p>„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„Å®ÂºïÊï∞„ÇíÂèñ„Çã<code>runFn2</code>„ÅßÂëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p><code>functions</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÅØ0ÂºïÊï∞„Åã„Çâ10ÂºïÊï∞„Åæ„Åß„ÅÆÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶ÂêåÊßò„ÅÆÂûãÊßãÁØâÂ≠ê„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅÆË£úË∂≥"><a class="header" href="#„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅÆË£úË∂≥">„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅÆË£úË∂≥</a></h2>
<p>PureScript„ÅÆ„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„Å´„ÅØ„ÇÇ„Å°„Çç„ÇìÂà©ÁÇπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÈÉ®ÂàÜÁöÑ„Å´Èñ¢Êï∞„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅÈñ¢Êï∞Âûã„Å´Âûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰∏é„Åà„Çâ„Çå„Åæ„Åô„ÄÇ
„Åó„Åã„ÅóÂäπÁéá‰∏ä„ÅÆ‰ª£ÂÑü„ÇÇ‰ªò„ÅÑ„Å¶„Åè„Çã„ÅÆ„Åß„Åô„ÄÇ
ÂäπÁéáÊÄß„ÅåÊ±∫ÂÆöÁöÑ„Å´ÈáçË¶Å„Å™„Ç≥„Éº„Éâ„Åß„ÅØÂ§öÂ§âÊï∞„ÇíÂèó„Åë‰ªò„Åë„Çã„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑJavaScriptÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„ÇãÂøÖË¶Å„ÅåÊôÇ„ÄÖ„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>PureScript„Åß„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÈñ¢Êï∞„Çí‰Ωú„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
2ÂºïÊï∞„ÅÆÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅØ<code>mkFn2</code>Èñ¢Êï∞„Åå‰Ωø„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>Ââç„Å®ÂêåÊßò„Å´<code>runFn2</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ2ÂºïÊï∞„ÅÆÈñ¢Êï∞„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>„Åì„Åì„ÅßÈáçË¶Å„Å™„ÅÆ„ÅØ„ÄÅÂºïÊï∞„Åå„Åô„Åπ„Å¶ÈÅ©Áî®„Åï„Çå„Çã„Å™„Çâ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅØ <code>mkFn2</code>Èñ¢Êï∞„ÇÑ
<code>runFn2</code>Èñ¢Êï∞„Çí<strong>„Ç§„É≥„É©„Ç§„É≥Âåñ</strong>„Åô„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ„Åù„ÅÆ„Åü„ÇÅ„ÄÅÁîüÊàê„Åï„Çå„Çã„Ç≥„Éº„Éâ„ÅØ„Å®„Å¶„ÇÇ„Ç≥„É≥„Éë„ÇØ„Éà„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>ÂØæÁÖßÁöÑ„Å´„ÄÅ„Åì„Å°„Çâ„Åå„Åì„Çå„Åæ„Åß„ÅÆ„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>„Åù„Åó„Å¶ÁîüÊàêÁµêÊûú„ÅÆ„Ç≥„Éº„Éâ„Åå‰ª•‰∏ã„Åß„Åô„ÄÇ
ÂÖ•„ÇåÂ≠ê„ÅÆÈñ¢Êï∞„ÅÆ„Åü„ÇÅÊØîËºÉÁöÑÁ∞°ÊΩî„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="Áèæ‰ª£ÁöÑ„Å™javascript„ÅÆÊßãÊñá„Å´„Å§„ÅÑ„Å¶„ÅÆË£úË∂≥"><a class="header" href="#Áèæ‰ª£ÁöÑ„Å™javascript„ÅÆÊßãÊñá„Å´„Å§„ÅÑ„Å¶„ÅÆË£úË∂≥">Áèæ‰ª£ÁöÑ„Å™JavaScript„ÅÆÊßãÊñá„Å´„Å§„ÅÑ„Å¶„ÅÆË£úË∂≥</a></h2>
<p>Ââç„Å´Ë¶ã„ÅüÁü¢Âç∞Èñ¢Êï∞ÊßãÊñá„ÅØES6„ÅÆÊ©üËÉΩ„Åß„ÅÇ„Çä„ÄÅ„Åù„ÅÆ„Åü„ÇÅ„ÅÑ„Åè„Å§„Åã„ÅÆÂè§„ÅÑ„Éñ„É©„Ç¶„Ç∂ÔºàÂêçÊåá„Åó„Åô„Çå„Å∞IE11Ôºâ„Å®‰∫íÊèõÊÄß„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
Âü∑Á≠ÜÊôÇÁÇπ„ÅßWeb„Éñ„É©„Ç¶„Ç∂„Çí„Åæ„Å†Êõ¥Êñ∞„Åó„Å¶„ÅÑ„Å™„ÅÑ<a href="https://caniuse.com/#feat=arrow-functions">6%„ÅÆÂà©Áî®ËÄÖ„ÅåÁü¢Âç∞Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Å™„ÅÑ„Å®Êé®Ë®à</a>„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åª„Å®„Çì„Å©„ÅÆÂà©Áî®ËÄÖ„Å´„Å®„Å£„Å¶‰∫íÊèõÊÄß„Åå„ÅÇ„Çã„Çà„ÅÜ„Å´„Åô„Çã„Åü„ÇÅ„ÄÅ
PureScript„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶ÁîüÊàê„Åï„Çå„ÇãJavaScript„Ç≥„Éº„Éâ„ÅØÁü¢Âç∞Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ
„Åæ„Åü„ÄÅÂêå„ÅòÁêÜÁî±„Åß<strong>ÂÖ¨Èñã„Åô„Çã„É©„Ç§„Éñ„É©„É™„Åß„ÇÇÁü¢Âç∞Èñ¢Êï∞„ÇíÈÅø„Åë„Çã</strong>„Åì„Å®„ÅåÊé®Â•®„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÇÇËá™ÂàÜ„ÅÆFFI„Ç≥„Éº„Éâ„ÅßÁü¢Âç∞Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„Åå„ÄÅ
„Éá„Éó„É≠„Ç§„ÅÆ‰ΩúÊ•≠Â∑•Á®ã„ÅßES5„Å´‰∫íÊèõÊÄß„ÅÆ„ÅÇ„ÇãÈñ¢Êï∞„Å´Â§âÊèõ„Åô„Çã„Åü„ÇÅ„Å´<a href="https://github.com/babel/babel#intro">Babel</a>„Å™„Å©„ÅÆ„ÉÑ„Éº„É´„ÇíÂê´„ÇÅ„Çã„Åπ„Åç„Åß„Åô„ÄÇ</p>
<p>ES6„ÅÆÁü¢Âç∞Èñ¢Êï∞„Åå„Çà„ÇäË™≠„Åø„ÇÑ„Åô„ÅèÊÑü„Åò„Åü„Çâ<a href="https://github.com/lebab/lebab">Lebab</a>„ÅÆ„Çà„ÅÜ„Å™„ÉÑ„Éº„É´„Çí‰Ωø„Å£„Å¶„Ç≥„É≥„Éë„Ç§„É©„ÅÆ<code>output</code>„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´JavaScript„ÅÆ„Ç™„Éº„Éâ„ÇíÂ§âÊèõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>„Åì„ÅÆÊìç‰Ωú„Å´„Çà„Çä‰∏ä„ÅÆ<code>curriedAdd</code>Èñ¢Êï∞„ÅØ‰ª•‰∏ã„Å´Â§âÊèõ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>Êú¨Êõ∏„ÅÆÊÆã„Çä„ÅÆ‰æã„Åß„ÅØÂÖ•„ÇåÂ≠ê„ÅÆÈñ¢Êï∞„ÅÆ‰ª£„Çè„Çä„Å´Áü¢Âç∞Èñ¢Êï∞„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-27"><a class="header" href="#ÊºîÁøí-27">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ<code>Test.MySolutions</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ‰∏≠„Å´ÁÆ±„ÅÆ‰ΩìÁ©ç„ÇíÊ±Ç„ÇÅ„ÇãJavaScript„ÅÆÈñ¢Êï∞<code>volumeFn</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>Data.Function.Uncurried</code>„ÅÆ<code>Fn</code>„É©„ÉÉ„Éë„Éº„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>volumeFn</code>„ÇíÁü¢Âç∞Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Êõ∏„ÅçÁõ¥„Åó„ÄÅ<code>volumeArrow</code>„Å®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="ÂçòÁ¥î„Å™Âûã„ÇíÊ∏°„Åô"><a class="header" href="#ÂçòÁ¥î„Å™Âûã„ÇíÊ∏°„Åô">ÂçòÁ¥î„Å™Âûã„ÇíÊ∏°„Åô</a></h2>
<p>‰ª•‰∏ã„ÅÆ„Éá„Éº„ÇøÂûã„ÅØPureScript„Å®JavaScript„ÅÆÈñì„Åß„Åù„ÅÆ„Åæ„ÅæÊ∏°„ÅóÂêà„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<div class="table-wrapper"><table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
</div>
<p><code>String</code>„Å®<code>Number</code>„Å®„ÅÑ„ÅÜÂéüÂßãÂûã„ÅÆ‰æã„ÅØÊó¢„Å´Ë¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ
„Åì„Åì„Åã„Çâ<code>Array</code>„ÇÑ<code>Record</code>ÔºàJavaScript„Åß„ÅØ<code>Object</code>Ôºâ„Å®„ÅÑ„Å£„ÅüÊßãÈÄ†ÁöÑ„Å™Âûã„ÇíÁú∫„ÇÅ„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Array</code>„ÅÆÂèó„ÅëÊ∏°„Åó„ÇíÂÆüÊºî„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ
‰ª•‰∏ã„Å´<code>Int</code>„ÅÆ<code>Array</code>„ÇíÂèñ„Å£„Å¶Âà•„ÅÆÈÖçÂàó„Å®„Åó„Å¶Á¥ØË®à„ÅÆÂíå„ÇíËøî„ÅôJavaScript„ÅÆÈñ¢Êï∞„ÅÆÂëº„Å≥Âá∫„ÅóÊñπ„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ
JavaScript„ÅØ<code>Int</code>„ÅÆ„Åü„ÇÅ„ÅÆÂàÜÈõ¢„Åó„ÅüÂûã„ÇíÊåÅ„Åü„Å™„ÅÑ„Åü„ÇÅ„ÄÅPureScript„Åß„ÅÆ<code>Int</code>„Å®<code>Number</code>„ÅØJavaScript„Åß„ÅÆ<code>Number</code>„Å´ÁøªË®≥„Åï„Çå„ÇãÁÇπ„ÇíÊÄù„ÅÑËµ∑„Åì„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">export const cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p><code>Record</code>„ÅÆÂèó„ÅëÊ∏°„Åó„ÇíÂÆüÊºî„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ‰ª•‰∏ã„Å´2„Å§„ÅÆ<code>Complex</code>„Å™Êï∞„Çí„É¨„Ç≥„Éº„Éâ„Å®„Åó„Å¶Âèñ„Çä„ÄÅÂíå„ÇíÂà•„ÅÆ„É¨„Ç≥„Éº„Éâ„Å®„Åó„Å¶Ëøî„ÅôJavaScript„ÅÆÂëº„Å≥Âá∫„ÅóÊñπ„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ
PureScript„Åß„ÅÆ<code>Record</code>„ÅåJavaScript„Åß„ÅØ<code>Object</code>„Å®„Åó„Å¶Ë°®Áèæ„Åï„Çå„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">export const addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>„Å™„Åä„ÄÅ‰∏ä„ÅÆÊâãÊ≥ï„Å´„ÅØJavaScript„ÅåÊúüÂæÖÈÄö„Çä„ÅÆÂûã„ÇíËøî„Åô„Åì„Å®„Å∏„ÅÆ‰ø°È†º„ÇíË¶Å„Åó„Åæ„Åô„ÄÇ
PureScript„ÅØJavaScript„ÅÆ„Ç≥„Éº„Éâ„Å´ÂûãÊ§úÊüª„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Å™„ÅÑ„Åã„Çâ„Åß„Åô„ÄÇ
„Åì„ÅÆÂûãÂÆâÂÖ®ÊÄß„ÅÆÈÖçÊÖÆ„Å´„Å§„ÅÑ„Å¶Âæå„ÅÆJSON„ÅÆÁØÄ„Åß„Çà„ÇäË©≥„Åó„ÅèË®òËø∞„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
Âûã„ÅÆ‰∏çÊï¥Âêà„Åã„ÇâË∫´„ÇíÂÆà„ÇãÊâãÊ≥ï„Å´„Å§„ÅÑ„Å¶„ÇÇÊäº„Åï„Åà„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-28"><a class="header" href="#ÊºîÁøí-28">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ<code>Complex</code>„ÅÆÊï∞„ÅÆÈÖçÂàó„ÇíÂèñ„Å£„Å¶Âà•„ÅÆË§áÁ¥†Êï∞„ÅÆÈÖçÂàó„Å®„Åó„Å¶Á¥ØË®à„ÅÆÂíå„ÇíËøî„ÅôJavaScript„ÅÆÈñ¢Êï∞<code>cumulativeSumsComplex</code>Ôºà„Å®ÂØæÂøú„Åô„ÇãPureScript„ÅÆÂ§ñÈÉ®„Ç§„É≥„Éù„Éº„ÉàÔºâ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="ÂçòÁ¥î„Å™Âûã„ÇíË∂ä„Åà„Å¶"><a class="header" href="#ÂçòÁ¥î„Å™Âûã„ÇíË∂ä„Åà„Å¶">ÂçòÁ¥î„Å™Âûã„ÇíË∂ä„Åà„Å¶</a></h2>
<p><code>String</code>„ÄÅ<code>Number</code>„ÄÅ<code>Array</code>„ÄÅ„Åù„Åó„Å¶<code>Record</code>„Å®„ÅÑ„Å£„ÅüJavaScriptÂõ∫Êúâ„ÅÆË°®Áèæ„ÇíÊåÅ„Å§Âûã„ÇíFFIË∂ä„Åó„Å´ÈÄÅ„Å£„Åü„ÇäÂèó„ÅëÂèñ„Å£„Åü„Çä„Åô„ÇãÊñπÊ≥ï„ÇíÊï∞‰æãË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ
„Åì„Åì„Åã„Çâ<code>Maybe</code>„ÅÆ„Çà„ÅÜ„Å™PureScript„Åß‰Ωø„Åà„Çã„ÅÑ„Åè„Å§„Åã„ÅÆ‰ªñ„ÅÆÂûã„ÅÆ‰Ωø„ÅÑÊñπ„ÇíÊäº„Åï„Åà„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>Â§ñÈÉ®ÂÆ£Ë®Ä„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÈÖçÂàó„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>head</code>Èñ¢Êï∞„ÇíÊîπ„ÇÅ„Å¶‰ΩúÊàê„Åó„Åü„ÅÑ„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
JavaScript„Åß„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Å´„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-javascript">export const head = arr =&gt;
  arr[0];
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„Çí„Å©„ÅÜÂûã‰ªò„Åë„Åæ„Åó„Çá„ÅÜ„ÅãÔºü
Âûã <code>forall a. Array a -&gt; a</code>„Çí‰∏é„Åà„Çà„ÅÜ„Å®„Åó„Å¶„ÇÇ„ÄÅÁ©∫„ÅÆÈÖçÂàó„Å´ÂØæ„Åó„Å¶„Åì„ÅÆÈñ¢Êï∞„ÅØ <code>undefined</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åó„Åü„Åå„Å£„Å¶Âûã<code>forall a. Array a -&gt; a</code>„ÅØÊ≠£„Åó„Åè„Åì„ÅÆÂÆüË£Ö„ÇíË°®Áèæ„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰ª£„Çè„Çä„Å´„Åì„ÅÆ„Ç≥„Éº„Éä„Éº„Ç±„Éº„Çπ„ÇíÊâ±„ÅÜ„Åü„ÇÅ„Å´<code>Maybe</code>ÂÄ§„ÇíËøî„Åó„Åü„ÅÑ„Å®„Åì„Çç„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>„Åó„Åã„Åó„Å©„ÅÜ„ÇÑ„Å£„Å¶<code>Maybe</code>„ÇíËøî„Åó„Åæ„Åó„Çá„ÅÜ„Åã„ÄÇ
„Å§„ÅÑ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åç„Åü„Åè„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">// „Åì„ÅÜ„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ
import Data_Maybe from '../Data.Maybe'

export const maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>Â§ñÈÉ®„É¢„Ç∏„É•„Éº„É´„ÅßÁõ¥Êé•<code>Data.Maybe</code>„É¢„Ç∏„É•„Éº„É´„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Å¶‰Ωø„ÅÜ„Åì„Å®„ÅØ„ÅäÂãß„ÇÅ„Åó„Åæ„Åõ„Çì„ÄÇ
„Å®„ÅÑ„ÅÜ„ÅÆ„ÇÇ„Ç≥„Éº„Éâ„Åå„Ç≥„Éº„ÉâÁîüÊàêÂô®„ÅÆÂ§âÂåñ„Å´ÂØæ„Åó„Å¶ËÑÜ„Åè„Å™„Çã„Åã„Çâ„Åß„Åô„ÄÇ
<code>create</code>„ÇÑ<code>value</code>„ÅØÂÖ¨Èñã„ÅÆAPI„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
Âä†„Åà„Å¶„ÄÅ„Åì„ÅÆ„Çà„ÅÜ„Å´„Åô„Çã„Åì„Å®„ÅØ‰∏çË¶Å„Å™„Ç≥„Éº„Éâ„ÅÆÊ∂àÂéª„ÅÆ„Åü„ÇÅ„ÅÆ<code>purs bundle</code>„Çí‰Ωø„ÅÜÈöõ„Å´ÂïèÈ°å„ÇíÂºï„ÅçËµ∑„Åì„Åó„Åà„Åæ„Åô„ÄÇ</p>
<p>Êé®Â•®„Åï„Çå„Çã„ÇÑ„ÇäÊñπ„ÅØFFI„ÅßÂÆöÁæ©„Åï„Çå„ÅüÈñ¢Êï∞„Å´‰ΩôÂâ∞„ÅÆÂºïÊï∞„ÇíÂä†„Åà„Å¶ÂøÖË¶Å„Å™Èñ¢Êï∞„ÇíÂèó„Åë‰ªò„Åë„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<pre><code class="language-js">export const maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>„Åü„Å†„Åó„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åç„Åæ„Åô„Åå„ÄÅ</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>‰ª•‰∏ã„Åß„ÅØ„Å™„ÅÑ„Åì„Å®„Å´Ê≥®ÊÑè„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">forall a. ( a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>„Å©„Å°„Çâ„ÅÆÂΩ¢Âºè„Åß„ÇÇÂãï„Åç„Åæ„Åô„Åå„ÄÅÂæåËÄÖ„ÅØ<code>Just</code>„Å®<code>Nothing</code>„ÅÆÂ†¥ÊâÄ„Åß„ÅÆÊãõ„Åã„Çå„Åñ„ÇãÂÖ•Âäõ„Å´„Çà„ÇäÊôí„Åï„Çå„ÇÑ„Åô„Åè„Å™„Çä„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞„Çà„ÇäËÑÜÂº±„Å™Â†¥Âêà„Åß„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„Åó„Å¶Âëº„Å∂„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>„Åì„Çå„ÅØ„ÅÑ„Åã„Å™„ÇãÈÖçÂàó„Å´„Å§„ÅÑ„Å¶„ÇÇ<code>Just 1000</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åì„ÅÆËÑÜÂº±ÊÄß„ÅØ<code>a</code>„Åå<code>Int</code>„ÅÆ„Å®„Åç„Å´Ôºà„Åì„Çå„ÅØÂÖ•Âäõ„ÅÆÈÖçÂàó„Å´Âü∫„Å•„Åç„Åæ„ÅôÔºâ<code>(\_ -&gt; Just 1000)</code>„Å®<code>Just 1000</code>„Åå„Ç∑„Ç∞„Éç„ÉÅ„É£<code>(a -&gt; Maybe a)</code>„Å®<code>Maybe a</code>„Å´„Åù„Çå„Åû„ÇåÂêàËá¥„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ„Å´Ë®±„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Çà„ÇäÂÆâÂÖ®„Å™Âûã„Ç∑„Ç∞„Éç„ÉÅ„É£„Åß„ÅØÂÖ•Âäõ„ÅÆÈÖçÂàó„Å´Âü∫„Å•„ÅÑ„Å¶<code>a</code>„Åå<code>Int</code>„Å´Ê±∫ÂÆö„Åï„Çå„Åü„Å®„Åó„Å¶„ÇÇ„ÄÅ<code>forall x</code>„Å´Áµ°„ÇÄ„Ç∑„Ç∞„Éç„ÉÅ„É£„Å´ÂêàËá¥„Åô„ÇãÂ¶•ÂΩì„Å™Èñ¢Êï∞„ÇíÊèê‰æõ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
<code>(forall x. Maybe x)</code>„ÅÆ <em>ÂîØ‰∏Ä</em> „ÅÆÈÅ∏ÊäûËÇ¢„ÅØ<code>Nothing</code>„Åß„Åô„Åå„ÄÅ„Åù„Çå„ÅØ<code>Just</code>ÂÄ§„Åå<code>x</code>„ÅÆÂûã„ÇíÂâçÊèê„Å´„Åó„Å¶„Åó„Åæ„ÅÑ„ÄÅ„Åô„Çã„Å®„ÇÇ„ÅØ„ÇÑÂÖ®„Å¶„ÅÆ<code>x</code>„Å´„Å§„ÅÑ„Å¶„ÅØÂ¶•ÂΩì„Åß„Å™„Åè„Å™„Å£„Å¶„Åó„Åæ„ÅÜ„Åã„Çâ„Åß„Åô„ÄÇ
<code>(forall x. x -&gt; Maybe x)</code>„ÅÆÂîØ‰∏Ä„ÅÆÈÅ∏ÊäûËÇ¢„ÅØ<code>Just</code>ÔºàÊúõ„Çì„Åß„ÅÑ„ÇãÂºïÊï∞Ôºâ„Å®<code>(\_ -&gt; Nothing)</code>„Åß„ÅÇ„Çä„ÄÅÂæåËÄÖ„ÅØÂîØ‰∏ÄÊÆã„Å£„Å¶„ÅÑ„ÇãËÑÜÂº±ÊÄß„Å´„Å™„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<h2 id="Â§ñÈÉ®Âûã„ÅÆÂÆöÁæ©"><a class="header" href="#Â§ñÈÉ®Âûã„ÅÆÂÆöÁæ©">Â§ñÈÉ®Âûã„ÅÆÂÆöÁæ©</a></h2>
<p><code>Maybe a</code>„ÇíËøî„Åô‰ª£„Çè„Çä„Å´ÂÆü„ÅØ<code>arr[0]</code>„ÇíËøî„Åó„Åü„ÅÑ„ÅÆ„Å†„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
Âûã<code>a</code>„Å™„ÅÑ„Åó<code>undefined</code>ÂÄ§Ôºà„Åü„Å†<code>null</code>„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„ÇìÔºâ„ÅÆ„ÅÑ„Åö„Çå„Åã„ÅÆÂÄ§„ÇíË°®Áèæ„Åô„ÇãÂûã„Åå„Åª„Åó„ÅÑ„Åß„Åô„ÄÇ
„Åì„ÅÆÂûã„Çí<code>Undefined a</code>„Å®Âëº„Å≥„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p><strong>Â§ñÈÉ®„Ç§„É≥„Éù„Éº„ÉàÂÆ£Ë®Ä</strong>„Çí‰Ωø„ÅÜ„Å®„ÄÅ<strong>Â§ñÈÉ®Âûã</strong> (foreign type) „ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
ÊßãÊñá„ÅØÂ§ñÈÉ®Èñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„ÅÆ„Å®‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>„Åì„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ<code>data</code>„ÅØÂûã„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂÄ§„Åß„ÅØ„ÅÇ„Çä„Åõ„Çì„ÄÇ
Âûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅÆ‰ª£„Çè„Çä„Å´„ÄÅÊñ∞„Åó„ÅÑÂûã„ÅÆ<strong>Á®Æ</strong>„Çí‰∏é„Åà„Åæ„Åô„ÄÇ
„Åì„ÅÆÂ†¥Âêà„ÅØ<code>Undefined</code>„ÅÆÁ®Æ„Åå <code>Type -&gt; Type</code>„Åß„ÅÇ„Çã„Å®ÂÆ£Ë®Ä„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ë®Ä„ÅÑÊèõ„Åà„Çå„Å∞<code>Undefined</code>„ÅØÂûãÊßãÁØâÂ≠ê„Åß„Åô„ÄÇ</p>
<p>„Åì„Çå„ÅßÂÖÉ„ÅÆ<code>head</code>„ÅÆÂÆöÁæ©„ÇíÂçò„Å´ÂÜçÂà©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">export const undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>PureScript„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ‰ª•‰∏ã„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p><code>undefinedHead</code>Èñ¢Êï∞„ÅÆÊú¨‰Ωì„ÅØ<code>undefined</code>„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ<code>arr[0]</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åù„Åó„Å¶„Åì„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØ„Åù„ÅÆ‰∫ãÂÆü„ÇíÊ≠£„Åó„ÅèÂèçÊò†„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„Åù„ÅÆÂûã„ÅÆÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
Âûã <code>Undefined a</code>„ÅÆÂÄ§„Çí‰ΩøÁî®„Åô„ÇãÊñπÊ≥ï„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÅÆ„Åß„ÄÅ„Åæ„Å£„Åü„ÅèÂΩπ„Å´Á´ã„Å°„Åæ„Åõ„Çì„ÄÇ
„ÅÑ„ÇÑ„ÄÅË®Ä„ÅÑÈÅé„Åé„Åæ„Åó„Åü„ÄÇ
Âà•„ÅÆFFI„Åß„Åì„ÅÆÂûã„Çí‰Ωø„Åà„Åæ„Åô„Åã„Çâ„Å≠„ÄÇ</p>
<p>ÂÄ§„ÅåÊú™ÂÆöÁæ©„Åã„Å©„ÅÜ„Åã„ÇíÊïô„Åà„Å¶„Åè„Çå„ÇãÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>Â§ñÈÉ®JavaScript„É¢„Ç∏„É•„Éº„É´„ÅßÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">export const isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>„Åì„Çå„ÅßPureScript„Åß <code>isUndefined</code>„Å® <code>undefinedHead</code>„Çí‰∏ÄÁ∑í„Å´‰ΩøÁî®„Åô„Çã„Å®„ÄÅ
‰æøÂà©„Å™Èñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>„Åì„ÅÆ„Çà„ÅÜ„Å´„ÄÅÂÆöÁæ©„Åó„Åü„Åì„ÅÆÂ§ñÈÉ®Èñ¢Êï∞„ÅØ„Å®„Å¶„ÇÇÁ∞°Âçò„Åß„Åô„ÄÇ
„Å§„Åæ„ÇäPureScript„ÅÆÂûãÊ§úÊüªÂô®„Çí‰Ωø„ÅÜ„Åì„Å®„Å´„Çà„ÇãÂà©Áõä„ÅåÊúÄÂ§ßÈôêÂæó„Çâ„Çå„Çã„ÅÆ„Åß„Åô„ÄÇ
‰∏ÄËà¨„Å´„ÄÅÂ§ñÈÉ®Èñ¢Êï∞„ÅØÂèØËÉΩ„Å™Èôê„ÇäÂ∞è„Åï„Åè‰øù„Å°„ÄÅ„Åß„Åç„Çã„Å†„Åë„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÂá¶ÁêÜ„ÅØPureScript„Ç≥„Éº„Éâ„Å∏ÁßªÂãï„Åó„Å¶„Åä„Åè„Åì„Å®„Çí„Åä„Åô„Åô„ÇÅ„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="‰æãÂ§ñ-1"><a class="header" href="#‰æãÂ§ñ-1">‰æãÂ§ñ</a></h2>
<p>‰ªñ„ÅÆÈÅ∏ÊäûËÇ¢„Å®„Åó„Å¶„ÅØ„ÄÅÁ©∫„ÅÆÈÖçÂàó„ÅÆÂ†¥Âêà„Å´‰æãÂ§ñ„ÇíÊäï„Åí„ÇãÊñπÊ≥ï„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
Âé≥ÂØÜ„Å´Ë®Ä„Åà„Å∞„ÄÅÁ¥îÁ≤ã„Å™Èñ¢Êï∞„ÅØ‰æãÂ§ñ„ÇíÊäï„Åí„Çã„Åπ„Åç„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅ„Åù„Çå„Çí„Åô„ÇãÊüîËªü„Åï„ÅØ„ÅÇ„Çä„Åæ„Åô„ÄÇ
ÂÆâÂÖ®ÊÄß„Å´Ê¨†„Åë„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÈñ¢Êï∞Âêç„ÅßÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>JavaScript„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„ÄÅ <code>unsafeHead</code>„Çí‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">export const unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="ÊºîÁøí-29"><a class="header" href="#ÊºîÁøí-29">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÊôÆÈÄöÔºâ‰∫åÊ¨°Â§öÈ†ÖÂºè<code>a*x^2 + b*x + c = 0</code>„ÇíË°®Áèæ„Åô„Çã„É¨„Ç≥„Éº„Éâ„Åå‰∏é„Åà„Çâ„Çå„Å¶„ÅÑ„Çã„Å®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>‰∫åÊ¨°Â§öÈ†ÖÂºè„Çí‰Ωø„Å£„Å¶„Åì„ÅÆÂ§öÈ†ÖÂºè„ÅÆÊ†π„ÇíÊ±Ç„ÇÅ„ÇãJavaScript„ÅÆÈñ¢Êï∞<code>quadraticRootsImpl</code>„Å®„Åù„ÅÆ„É©„ÉÉ„Éë„Éº„ÅÆ<code>quadraticRoots :: Quadratic -&gt; Pair Complex</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
2„Å§„ÅÆÊ†π„Çí<code>Complex</code>„ÅÆÊï∞„ÅÆ<code>Pair</code>„Å®„Åó„Å¶Ëøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<em>„Éí„É≥„Éà</em> Ôºö<code>quadraticRoots</code>„É©„ÉÉ„Éë„Éº„Çí‰Ωø„Å£„Å¶<code>Pair</code>„ÅÆÊßãÁØâÂ≠ê„Çí<code>quadraticRootsImpl</code>„Å´Ê∏°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÈñ¢Êï∞<code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>undefined</code>„Çí<code>Nothing</code>„Å´„ÄÅ<code>a</code>„ÅÆÂÄ§„Çí<code>Just a</code>„Å´Â§âÊèõ„Åó„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>toMaybe</code>„ÅåÂÇô„Çè„Å£„Å¶„ÅÑ„Çå„Å∞<code>maybeHead</code>„Çí‰ª•‰∏ã„Å´Êõ∏„ÅçÊèõ„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>„Åì„Çå„ÅØÂâç„ÅÆÂÆüË£Ö„Çà„Çä„ÇÇËâØ„ÅÑÊâãÊ≥ï„Å™„ÅÆ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„ÅÆ„Åü„ÇÅ„ÅÆÂçò‰ΩìË©¶È®ì„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
</ol>
<h2 id="Âûã„ÇØ„É©„Çπ„É°„É≥„Éê„ÉºÈñ¢Êï∞„Çí‰Ωø„ÅÜ"><a class="header" href="#Âûã„ÇØ„É©„Çπ„É°„É≥„Éê„ÉºÈñ¢Êï∞„Çí‰Ωø„ÅÜ">Âûã„ÇØ„É©„Çπ„É°„É≥„Éê„ÉºÈñ¢Êï∞„Çí‰Ωø„ÅÜ</a></h2>
<p>„Å°„Çá„ÅÜ„Å©Ââç„Å´FFI„ÇíË∂ä„Åà„Å¶<code>Maybe</code>„ÅÆÊßãÁØâÂ≠ê„ÇíÊ∏°„ÅôÊâãÂºï„Åç„Çí„Åó„Åæ„Åó„Åü„Åå„ÄÅ
‰ªäÂõû„ÅØJavaScript„ÇíÂëº„Å≥Âá∫„ÅôPureScript„ÇíÊõ∏„ÅèÂà•„ÅÆÂ†¥Âêà„Åß„Åô„ÄÇ
JavaScript„ÅÆÂëº„Å≥Âá∫„Åó„Åß„ÇÇÁ∂ö„Åë„Åñ„Åæ„Å´PureScript„ÅÆÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó„Åæ„Åô„ÄÇ
„Åì„Åì„Åß„ÅØÂûã„ÇØ„É©„Çπ„ÅÆ„É°„É≥„Éê„ÉºÈñ¢Êï∞„ÅÆFFI„ÇíË∂ä„Åà„ÅüÊ∏°„ÅóÊñπ„ÇíÊé¢„Çä„Åæ„Åô„ÄÇ</p>
<p>Âûã<code>x</code>„Å´Âêà„ÅÜÈÅ©Âàá„Å™<code>show</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊúüÂæÖ„Åô„ÇãÂ§ñÈÉ®JavaScriptÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">export const boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + &quot;!!!&quot;;
</code></pre>
<p>„Åù„Çå„Åã„ÇâÂØæÂøú„Åô„Çã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊõ∏„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>„Åù„Åó„Å¶<code>show</code>„ÅÆÊ≠£„Åó„ÅÑ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊ∏°„Åô„É©„ÉÉ„Éë„ÉºÈñ¢Êï∞„ÇÇÊõ∏„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>‰ª£„Çè„Çä„Å´„Éù„Ç§„É≥„Éà„Éï„É™„ÉºÂΩ¢Âºè„Å†„Å®„Åì„ÅÜ„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>„Åù„ÅÜ„Åó„Å¶„É©„ÉÉ„Éë„Éº„ÇíÂëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 &quot;Hat&quot;)
&quot;(TUPLE 1 \&quot;HAT\&quot;)!!!&quot;
</code></pre>
<p>‰ª•‰∏ã„ÅØË§áÊï∞„ÅÆÈñ¢Êï∞„ÇíÊ∏°„Åô„Åì„Å®„ÇíÂÆüÊºî„Åô„ÇãÂà•„ÅÆ‰æã„Åß„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„Å´„ÅØË§áÊï∞ÂºïÊï∞Èñ¢Êï∞ (<code>eq</code>) „ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">export const showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return &quot;Equivalent&quot;;
  } else {
    return show(a) + &quot; is not equal to &quot; + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
&quot;Nothing is not equal to (Just 5)&quot;
</code></pre>
<h2 id="‰ΩúÁî®„ÅÆ„ÅÇ„ÇãÈñ¢Êï∞"><a class="header" href="#‰ΩúÁî®„ÅÆ„ÅÇ„ÇãÈñ¢Êï∞">‰ΩúÁî®„ÅÆ„ÅÇ„ÇãÈñ¢Êï∞</a></h2>
<p><code>bold</code>Èñ¢Êï∞„ÇíÊã°Âºµ„Åó„Å¶„Ç≥„É≥„ÇΩ„Éº„É´„Å´„É≠„Ç∞Âá∫Âäõ„Åô„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
„É≠„Ç∞Âá∫Âäõ„ÅØ<code>Effect</code>„Åß„ÅÇ„Çä„ÄÅ<code>Effect</code>„ÅØJavaScript„ÅßÁÑ°ÂºïÊï∞Èñ¢Êï∞„Å®„Åó„Å¶Ë°®Áèæ„Åï„Çå„Åæ„Åô„ÄÇ
„Å§„Åæ„Çä<code>()</code>„Å®Áü¢Âç∞Ë®òÊ≥ï„Å†„Å®„Åì„ÅÜ„Åß„Åô„ÄÇ</p>
<pre><code class="language-js">export const yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + &quot;!!!&quot;);
</code></pre>
<p>Êñ∞„Åó„ÅÑÂ§ñÈÉ®„Ç§„É≥„Éù„Éº„Éà„ÅØËøî„ÇãÂûã„Åå<code>String</code>„Åã„Çâ<code>Effect Unit</code>„Å´Â§â„Çè„Å£„ÅüÁÇπ‰ª•Â§ñ„ÅØ‰ª•Ââç„Å®Âêå„Åò„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>REPL„ÅßË©¶„Åô„Å®ÊñáÂ≠óÂàó„ÅåÔºàÂºïÁî®Á¨¶„ÅßÂõ≤„Åæ„Çå„ÅöÔºâÁõ¥Êé•„Ç≥„É≥„ÇΩ„Éº„É´„Å´Âç∞Â≠ó„Åï„Çå<code>unit</code>ÂÄ§„ÅåËøî„Çã„Åì„Å®„Å´Ê∞ó‰ªò„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 &quot;Hat&quot;)
(TUPLE 1 &quot;HAT&quot;)!!!
unit
</code></pre>
<p><code>Effect.Uncurried</code>„Å´<code>EffectFn</code>„É©„ÉÉ„Éë„Éº„Å®„ÅÑ„ÅÜ„ÇÇ„ÅÆ„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅØÊó¢„Å´Ë¶ã„Åü<code>Data.Function.Uncurried</code>„ÅÆ<code>Fn</code>„É©„ÉÉ„Éë„Éº„Å´‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çâ„ÅÆ„É©„ÉÉ„Éë„Éº„Åå„ÅÇ„Çå„Å∞„Ç´„É™„ÉºÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ‰ΩúÁî®„ÅÆ„ÅÇ„ÇãÈñ¢Êï∞„ÇíPureScript„ÅßÂëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰∏ÄËà¨ÁöÑ„Å´„Åì„Çå„Çâ„Çí‰Ωø„ÅÜ„ÅÆ„ÅØ„ÄÅ
„Åì„ÅÜ„Åó„ÅüAPI„Çí„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„Å´ÂåÖ„ÇÄ„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ
Êó¢Â≠ò„ÅÆJavaScript„É©„Ç§„Éñ„É©„É™„ÅÆAPI„ÇíÁõ¥Êé•Âëº„Å≥Âá∫„Åó„Åü„ÅÑ„Å®„Åç„Åê„Çâ„ÅÑ„Åß„Åô„ÄÇ
„Åó„Åü„Åå„Å£„Å¶„Ç´„É™„ÉºÂåñ„Åó„Å¶„ÅÑ„Å™„ÅÑ<code>yell</code>„ÅÆ‰æã„ÇíË¶ã„Åõ„Å¶„ÇÇ„ÅÇ„Åæ„ÇäÊÑèÂë≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
„Å®„ÅÑ„ÅÜ„ÅÆ„ÇÇJavaScript„ÅåPureScript„ÅÆÂûã„ÇØ„É©„Çπ„ÅÆ„É°„É≥„Éê„Éº„Å´‰æù„Å£„Å¶„ÅÑ„Çã„Åã„Çâ„Åß„ÄÅ
„Åï„Çâ„Å´„Åù„Çå„ÅØÊó¢Â≠ò„ÅÆJavaScript„ÅÆÁîüÊÖãÁ≥ª„Å´„Åù„ÅÆ„É°„É≥„Éê„Éº„ÅåË¶ã‰ªò„Åã„Çâ„Å™„ÅÑ„Åü„ÇÅ„Åß„Åô„ÄÇ</p>
<p>„Åù„ÅÆ‰ª£„Çè„Çä„Å´‰ª•Ââç„ÅÆ<code>diagonal</code>„ÅÆ‰æã„ÇíÂ§âÊõ¥„Åó„ÄÅÁµêÊûú„ÇíËøî„Åô„Åì„Å®„Å´Âä†„Åà„Å¶„É≠„Ç∞Âá∫Âäõ„ÇíÂê´„ÇÅ„Çã„Å®„Åì„ÅÜ„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">export const diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log(&quot;Diagonal is &quot; + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="ÈùûÂêåÊúüÈñ¢Êï∞"><a class="header" href="#ÈùûÂêåÊúüÈñ¢Êï∞">ÈùûÂêåÊúüÈñ¢Êï∞</a></h2>
<p>JavaScript„ÅÆ„Éó„É≠„Éü„Çπ„ÅØ<code>aff-promise</code>„É©„Ç§„Éñ„É©„É™„ÅÆÂä©„Åë„ÇíÂÄü„Çä„Å¶Áõ¥Êé•PureScript„ÅÆÈùûÂêåÊúü‰ΩúÁî®„Å´ÁøªË®≥„Åï„Çå„Åæ„Åô„ÄÇ
„Çà„ÇäÂ§ö„Åè„ÅÆÊÉÖÂ†±„Å´„Å§„ÅÑ„Å¶„ÅØ„É©„Ç§„Éñ„É©„É™„ÅÆ<a href="https://pursuit.purescript.org/packages/purescript-aff-promise">„Éâ„Ç≠„É•„É°„É≥„Éà</a>„Çí„ÅÇ„Åü„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Åì„Åß„ÅØ„ÅÑ„Åè„Å§„Åã„ÅÆ‰æã„Å´Ëß¶„Çå„Çã„Å†„Åë„Å®„Åó„Åæ„Åô„ÄÇ</p>
<p>JavaScript„ÅÆ<code>wait</code>„Éó„É≠„Éü„ÇπÔºà„Åæ„Åü„ÅØÈùûÂêåÊúüÈñ¢Êï∞Ôºâ„ÇíPureScript„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß‰Ωø„ÅÑ„Åü„ÅÑ„Å®„Åó„Åæ„Åô„ÄÇ
<code>ms</code>„Éü„É™ÁßíÂàÜ„Å†„ÅëÈÄÅ„Çâ„Åõ„Å¶ÂÆüË°å„Åï„Åõ„Çã„ÅÆ„Å´‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>Âçò„Å´<code>Effect</code>ÔºàÁÑ°ÂºïÊï∞Èñ¢Êï∞Ôºâ„Å´ÂåÖ„Çì„ÅßÂÖ¨Èñã„Åô„Çã„Å†„Åë„Åß„Çà„ÅÑ„Åß„Åô„ÄÇ</p>
<pre><code class="language-js">export const sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>„Åù„Åó„Å¶‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>„Åù„ÅÜ„Åó„Å¶„Åì„ÅÆ<code>Promise</code>„Çí<code>Aff</code>„Éñ„É≠„ÉÉ„ÇØ‰∏≠„Åß‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Ëµ∞„Çâ„Åõ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
‚Ä¶ launchAff_ do
‚Ä¶   log &quot;waiting&quot;
‚Ä¶   sleep 300
‚Ä¶   log &quot;done waiting&quot;
‚Ä¶
waiting
unit
done waiting
</code></pre>
<p>REPL„Åß„ÅÆÈùûÂêåÊúü„É≠„Ç∞Âá∫Âäõ„ÅØ„Éñ„É≠„ÉÉ„ÇØÂÖ®‰Ωì„ÅåÂÆüË°å„ÇíÁµÇ‰∫Ü„Åô„Çã„Åæ„ÅßÂç∞Â≠ó„Åô„Çã„ÅÆ„ÇíÂæÖ„Å§ÁÇπ„Å´Ê≥®ÊÑè„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØ<code>spago test</code>„ÅßËµ∞„Çâ„Åõ„Åü„Å®„Åç„ÅØ„ÄÅÂç∞Â≠ó„ÅÆ <em>ÂêàÈñì„Å´</em> ÂÉÖ„Åã„Å™ÈÅÖÂª∂„Åå„ÅÇ„Çä„ÄÅ„Çà„Çä‰∫àÊ∏¨„Å´Ëøë„ÅÑÊåØËàû„ÅÑ„Çí„Åó„Åæ„Åô„ÄÇ</p>
<p>„Éó„É≠„Éü„Çπ„Åã„ÇâÂÄ§„ÇíËøî„ÅôÂà•„ÅÆ‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>async</code>„Å®<code>await</code>„Çí‰Ωø„Å£„Å¶Êõ∏„Åã„Çå„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
„Åì„Çå„ÅØ„Éó„É≠„Éü„Çπ„ÅÆÁ≥ñË°£ÊßãÊñá„Å´ÈÅé„Åé„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

export const diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p><code>Number</code>„ÇíËøî„Åô„Åü„ÇÅ„ÄÅ„Åì„ÅÆÂûã„Çí<code>Promise</code>„Å®<code>Aff</code>„ÅÆ„É©„ÉÉ„Éë„Éº„ÅÆ‰∏≠„Å´Ë°®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
‚Ä¶ launchAff_ do
‚Ä¶   res &lt;- diagonalAsync 300 3.0 4.0
‚Ä¶   logShow res
‚Ä¶
unit
5.0
</code></pre>
<h2 id="ÊºîÁøí-30"><a class="header" href="#ÊºîÁøí-30">ÊºîÁøí</a></h2>
<p>‰∏ä„ÅÆÁØÄ„ÅÆÊºîÁøí„ÅØ„Åæ„Å†„ÇÑ„Çã„Åπ„Åç„Åì„Å®‰∏ÄË¶ß„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ
„ÇÇ„Åó‰Ωï„ÅãËâØ„ÅÑÊºîÁøí„ÅÆËÄÉ„Åà„Åå„ÅÇ„Çå„Å∞„ÅîÊèêÊ°à„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="json-1"><a class="header" href="#json-1">JSON</a></h2>
<p>„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅßJSON„Çí‰Ωø„ÅÜ„Åì„Å®„Å´„ÅØÂ§ö„Åè„ÅÆÁêÜÁî±„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞Web„ÅÆAPI„Å®ÁñéÈÄö„Åô„Çã„Çà„Åè„ÅÇ„ÇãÊâãÊÆµ„Åß„ÅÇ„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ
„Åì„ÅÆÁØÄ„Åß„ÅØ‰ªñ„ÅÆÁî®‰æã„Å´„Å§„ÅÑ„Å¶„ÇÇ„ÅäË©±„Åó„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
ÊßãÈÄ†ÁöÑ„Å™„Éá„Éº„Çø„ÇíFFIË∂ä„Åó„Å´Ê∏°„ÅôÈöõ„ÅÆÂûãÂÆâÂÖ®ÊÄß„ÇíÂêë‰∏ä„Åï„Åõ„ÇãÊâãÊ≥ï„Åã„ÇâÂßã„ÇÅ„Åæ„Åô„ÄÇ</p>
<p>Â∞ë„ÅóÂâç„ÅÆFFIÈñ¢Êï∞<code>cumulativeSums</code>„Å®<code>addComplex</code>„ÇíÂÜçË®™„Åó„ÄÅ
„Åù„Çå„Åû„Çå„Å´1„Å§„Éê„Ç∞„ÇíÊ∑∑ÂÖ•„Åï„Åõ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-js">export const cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push(&quot;Broken&quot;); // Bug
  return sums;
};

export const addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>Ëøî„ÇãÂûã„ÅåÊ≠£„Åó„Åè„Å™„ÅÑ‰∫ãÂÆü„Åå„ÅÇ„Çã„Å´„ÇÇÈñ¢„Çè„Çâ„Åö„ÄÅ
ÂÖÉ„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„ÄÅ„Ç≥„Éº„Éâ„ÅØ„Åù„Çå„Åß„ÇÇ„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>„Ç≥„Éº„Éâ„ÇíÂÆüË°å„Åô„Çã„Åì„Å®„Åï„ÅàÂèØËÉΩ„Åß„ÄÅ„Åù„ÅÜ„Åô„Çã„Å®‰∫àÊúü„Åó„Å™„ÅÑÁµêÊûú„ÇíÁîü„ÅøÂá∫„Åô„ÅãÂÆüË°åÊôÇ„Ç®„É©„Éº„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>‰æã„Åà„Å∞ÁµêÊûú„ÅÆ<code>sums</code>„ÅØ„ÇÇ„ÅØ„ÇÑÊ≠£„Åó„ÅÑ<code>Array Int</code>„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅ
„Åì„Çå„ÅØ<code>String</code>„ÅåÈÖçÂàó„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„Çâ„Åß„Åô„ÄÇ
„Åù„Åó„Å¶Êõ¥„Å™„ÇãÊìç‰Ωú„ÅØÂç≥ÊôÇ„ÅÆ„Ç®„É©„Éº„Åß„ÅØ„Å™„Åè‰∫àÊúü„Åó„Å™„ÅÑÊåØËàû„ÅÑ„ÇíÁîü„ÅøÂá∫„Åó„Åæ„Åô„ÄÇ
„Å®„ÅÑ„ÅÜ„ÅÆ„ÇÇ„Åì„Çå„Çâ„ÅÆ<code>sums</code>„ÅÆ<code>sum</code>„ÅØ<code>10</code>„Åß„ÅØ„Å™„Åè<code>0</code>„Å†„Åã„Çâ„Åß„Åô„ÄÇ
„Åì„Çå„Åß„ÅØÊçúÁ¥¢„ÅÆÈõ£„Åó„ÅÑ„Éê„Ç∞„Å´„Å™„Çä„Åã„Å≠„Åæ„Åõ„Çì„Å≠„ÄÇ</p>
<p>ÂêåÊßò„Å´<code>addComplexBroken</code>„ÇíÂëº„Å≥Âá∫„Åô„Å®„Åç„ÅØ1„Å§„ÇÇ„Ç®„É©„Éº„ÅåÂá∫„Åæ„Åõ„Çì„ÄÇ
„Åó„Åã„Åó„Å™„Åå„Çâ<code>Complex</code>„ÅÆÁµêÊûú„ÅÆ<code>imag</code>„Éï„Ç£„Éº„É´„Éâ„Å´„Ç¢„ÇØ„Çª„Çπ„Åô„Çã„Å®‰∫àÊúü„Åó„Å™„ÅÑÊåØËàû„ÅÑÔºà<code>7.0</code>„Åß„ÅØ„Å™„Åè<code>Nan</code>„ÇíËøî„Åô„Åü„ÇÅÔºâ„ÇÑ„ÅØ„Å£„Åç„Çä„Åó„Å™„ÅÑÂÆüË°åÊôÇ„Ç®„É©„Éº„ÇíÁîü„Åò„Çã„Åì„Å®„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>PureScript„ÅÆ„Ç≥„Éº„Éâ„Å´„Éê„Ç∞‰∏ÄÂåπÈÄö„Åï„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã„Åü„ÇÅ„ÄÅJavaScript„ÅÆ„Ç≥„Éº„Éâ„ÅßJSON„Çí‰Ωø„ÅÑ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>argonaut</code>„É©„Ç§„Éñ„É©„É™„Å´„ÅØÂøÖË¶Å„Å®„Åó„Å¶„ÅÑ„ÇãJSON„ÅÆÂæ©Âè∑Âåñ„Å®Á¨¶Âè∑Âåñ„ÅÆÊ©üËÉΩ„ÅåÂÇô„Çè„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„Å´„ÅØÁ¥†Êô¥„Çâ„Åó„ÅÑ<a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">„Éâ„Ç≠„É•„É°„É≥„Éà</a>„Åå„ÅÇ„Çã„ÅÆ„Åß„ÄÅÊú¨Êõ∏„Åß„ÅØÂü∫Êú¨ÁöÑ„Å™Áî®Ê≥ï„Å†„Åë„ÇíÊäº„Åï„Åà„Åæ„Åô„ÄÇ</p>
<p>Ëøî„ÇãÂûã„Çí<code>Json</code>„Å®„Åó„Å¶ÂÆöÁæ©„Åô„Çã„Çà„ÅÜ„Å´„Åó„Å¶„ÄÅ‰ª£„Çè„Çä„Å®„Å™„ÇãÂ§ñÈÉ®„Ç§„É≥„Éù„Éº„Éà„Çí„Å§„Åè„Çã„Å®„Åì„ÅÜ„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>ÂçòÁ¥î„Å´Êó¢Â≠ò„ÅÆÂ£ä„Çå„ÅüÈñ¢Êï∞„ÇíÊåá„ÅóÁ§∫„Åó„Å¶„ÅÑ„Çã„Å†„Åë„Åß„ÅÇ„ÇãÁÇπ„Å´Ê≥®ÊÑè„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSumsBroken
export const addComplexJson = addComplexBroken
</code></pre>
<p>„Åù„Åó„Å¶Ëøî„Åï„Çå„Åü<code>Json</code>„ÅÆÂÄ§„ÇíÂæ©Âè∑Âåñ„Åô„Çã„É©„ÉÉ„Éë„Éº„ÇíÊõ∏„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>„Åù„Çå„Åã„ÇâËøî„ÇãÂûã„Å∏„ÅÆÂæ©Âè∑„ÅåÊàêÂäü„Åó„Å™„Åã„Å£„Åü„Å©„Çì„Å™ÂÄ§„ÇÇ<code>Left</code>„ÅÆ<code>String</code>„Å™„Ç®„É©„Éº„Å®„Åó„Å¶Ë°®„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left &quot;Couldn't decode Array (Failed at index 3): Value is not a Number&quot;)

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left &quot;JSON was missing expected field: imag&quot;)
</code></pre>
<p>„ÅÜ„Åæ„ÅèÂãï„Åè„Éê„Éº„Ç∏„Éß„É≥„ÅßÂëº„Å≥Âá∫„Åô„Å®<code>Right</code>„ÅÆÂÄ§„ÅåËøî„Çä„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„ÅÆREPL„Éñ„É≠„ÉÉ„ÇØ„ÇíËµ∞„Çâ„Åõ„ÇãÂâç„Å´„ÄÅ„ÅÜ„Åæ„ÅèÂãï„Åè„Éê„Éº„Ç∏„Éß„É≥„ÇíÊåá„ÅóÁ§∫„Åô„Çà„ÅÜ„Å´<code>test/Examples.js</code>„Å´‰ª•‰∏ã„ÅÆÂ§âÊõ¥„ÇíÂä†„Åà„Å¶„ÄÅ„Åì„Çå„ÇíÊâãÂÖÉ„ÅßË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSums
export const addComplexJson = addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>JSON„Çí‰Ωø„ÅÜ„Åì„Å®„ÅØ„ÄÅ<code>Map</code>„ÇÑ<code>Set</code>„ÅÆ„Çà„ÅÜ„Å™‰ªñ„ÅÆÊßãÈÄ†ÁöÑ„Å™Âûã„ÇíFFIË∂ä„Åó„Å´Ê∏°„ÅôÊúÄ„ÇÇÁ∞°Âçò„Å™ÊñπÊ≥ï„Åß„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åü„Å†„ÅóJSON„ÅØÁúüÂÅΩÂÄ§„ÄÅÊï∞ÂÄ§„ÄÅÊñáÂ≠óÂàó„ÄÅÈÖçÂàó„ÄÅ„Åù„Åó„Å¶‰ªñ„ÅÆJSON„ÅÆÂÄ§„Åã„Çâ„Å™„Çã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ„Åø„Åã„ÇâÊßãÊàê„Åï„Çå„Çã„Åü„ÇÅ„ÄÅJSON„Åß„ÅØÁõ¥Êé•<code>Map</code>„ÇÑ<code>Set</code>„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„ÄÇ
„Åó„Åã„Åó„Åì„Çå„Çâ„ÅÆÊßãÈÄ†„ÇíÈÖçÂàó„Å®„Åó„Å¶Ë°®Áèæ„Åô„Çã„Åì„Å®„ÅØ„Åß„ÅçÔºà„Ç≠„Éº„Å®„Éê„É™„É•„Éº„ÇÇ„Åæ„ÅüJSON„ÅßË°®Áèæ„Åï„Çå„Å¶„ÅÑ„Çã„Å®„Åó„Åæ„ÅôÔºâ„ÄÅ„Åù„Çå„Åã„Çâ<code>Map</code>„ÇÑ<code>Set</code>„Å´Âæ©Âè∑„ÅóÁõ¥„Åô„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰ª•‰∏ã„ÅØ<code>String</code>„ÅÆ„Ç≠„Éº„Å®<code>Int</code>„ÅÆ„Éê„É™„É•„Éº„Åã„Çâ„Å™„Çã<code>Map</code>„ÇíÂ§âÊõ¥„Åô„ÇãÂ§ñÈÉ®Èñ¢Êï∞„Ç∑„Ç∞„Éç„ÉÅ„É£„Å®„ÄÅ„Åù„Çå„Å´‰º¥„ÅÜJSON„ÅÆÁ¨¶Âè∑Âåñ„Å®Âæ©Âè∑Âåñ„ÇíÊâ±„ÅÜ„É©„ÉÉ„Éë„ÉºÈñ¢Êï∞„ÅÆ‰æã„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>Èñ¢Êï∞ÂêàÊàê„ÅÆÁµ∂Â•Ω„ÅÆÁî®‰æã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„Å≠„ÄÇ
„Åì„Çå„Çâ„ÅÆ‰∏°Êñπ„ÅÆ‰ª£ÊõøÊ°à„ÅØ‰∏ä„ÅÆ„ÇÇ„ÅÆ„Å®Á≠â‰æ°„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>‰ª•‰∏ã„ÅØJavaScript„Åß„ÅÆÂÆüË£Ö„Åß„Åô„ÄÇ
<code>Array.from</code>„ÅÆÂ∑•Á®ã„Åå„ÄÅÂæ©Âè∑„ÅÆÂâç„Å´JavaScript„ÅÆ<code>Map</code>„ÇíJSON„Å´Ë¶™ÂíåÊÄß„ÅÆ„ÅÇ„ÇãÂΩ¢Âºè„Å´Â§âÊèõ„Åó„ÄÅPureScript„ÅÆ<code>Map</code>„Å´Â§âÊèõ„ÅóÁõ¥„Åô„Åü„ÇÅ„Å´ÂøÖÈ†à„Åß„ÅÇ„ÇãÁÇπ„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-js">export const mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set(&quot;Foo&quot;, 42);
  return Array.from(m);
};
</code></pre>
<p>„Åì„Çå„Åß<code>Map</code>„ÇíFFIË∂ä„Åó„Å´ÈÄÅ„Å£„Åü„ÇäÂèó„ÅëÂèñ„Å£„Åü„Çä„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple &quot;hat&quot; 1, Tuple &quot;cat&quot; 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple &quot;Foo&quot; 42),(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)]))
</code></pre>
<h2 id="ÊºîÁøí-31"><a class="header" href="#ÊºîÁøí-31">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Map</code>‰∏≠„ÅÆÂÖ®„Å¶„ÅÆÂÄ§„ÅÆ<code>Set</code>„ÇíËøî„ÅôJavaScript„ÅÆÈñ¢Êï∞„Å®PureScript„ÅÆ„É©„ÉÉ„Éë„Éº<code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ„Çà„ÇäÂ∫É„ÅÑÁ®ÆÈ°û„ÅÆ„Éû„ÉÉ„Éó„Å´Èñ¢„Åó„Å¶Âãï‰Ωú„Åô„Çã„Çà„ÅÜ„ÄÅÂâç„ÅÆJavaScript„ÅÆÈñ¢Êï∞„ÅÆÊñ∞„Åó„ÅÑ„É©„ÉÉ„Éë„Éº„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØ<code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code>„Åß„Åô„ÄÇ
„Å™„Åä<code>k</code>„Å®<code>v</code>„Å´„ÅÑ„Åè„Å§„Åã„ÅÆÂûã„ÇØ„É©„ÇπÂà∂Á¥Ñ„ÇíÂä†„Åà„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
„Ç≥„É≥„Éë„Ç§„É©„ÅåÂ∞é„ÅÑ„Å¶„Åè„Çå„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÂ∞ë„ÅóÂâç„ÅÆ<code>quadraticRoots</code>„ÇíÊõ∏„ÅçÊèõ„Åà„Å¶<code>quadraticRootSet</code>„Å®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØ<code>Complex</code>„ÅÆÊ†π„ÇíJSON„Çí‰ªã„Åó„Å¶Ôºà<code>Pair</code>„ÅÆ‰ª£„Çè„Çä„Å´Ôºâ<code>Set</code>„Å®„Åó„Å¶Ëøî„Åó„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâÂ∞ë„ÅóÂâç„ÅÆ<code>quadraticRoots</code>„ÇíÊõ∏„ÅçÊèõ„Åà„Å¶<code>quadraticRootsSafe</code>„Å®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØJSON„Çí‰Ωø„Å£„Å¶<code>Complex</code>„ÅÆÊ†π„ÅÆ<code>Pair</code>„ÇíFFIË∂ä„Åó„Å´Ê∏°„Åó„Åæ„Åô„ÄÇ
JavaScript„Åß„ÅØ<code>Pair</code>ÊßãÁØâÂ≠ê„Çí‰Ωø„Çè„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åü„Å†„Åó„Åù„ÅÆ‰ª£„Çè„Çä„Å´Âæ©Âè∑Âô®„Å´‰∫íÊèõÊÄß„ÅÆ„ÅÇ„ÇãÂΩ¢Âºè„ÅßÂØæ„ÇíËøî„Åô„Å†„Åë„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>DecodeJson</code>„Ç§„É≥„Çø„É≥„Çπ„Çí<code>Pair</code>„Å´Êõ∏„ÅèÂøÖË¶Å„Åå„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ
Ëá™Ââç„ÅÆÂæ©Âè∑„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè‰∏ä„Åß„ÅÆË™¨Êòé„Å´„Å§„ÅÑ„Å¶„ÅØ<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonaut„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà</a>„Çí„ÅÇ„Åü„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇÇÂèÇËÄÉ„Å´„Å™„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ
„ÄåÂ≠§Á´ã„Ç§„É≥„Çπ„Çø„É≥„Çπ„Äç„Çí‰Ωú„Çã„Åì„Å®„ÇíÈÅø„Åë„Çã„Åü„ÇÅ„Å´„ÄÅ<code>Pair</code>„Å´<code>newtype</code>„É©„ÉÉ„Éë„Éº„ÅåÂøÖË¶Å„Å´„Å™„ÇãÁÇπ„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ2Ê¨°ÂÖÉÈÖçÂàó„ÇíÂê´„ÇÄJSONÊñáÂ≠óÂàó„ÇíÊßãÊñáËß£Êûê„Åó„Å¶Âæ©Âè∑„Åô„Çã<code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code>Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
‰æã„Åà„Å∞<code>&quot;[[1, 2, 3], [4, 5], [6]]&quot;</code>„Åß„Åô„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöÂæ©Âè∑„ÅÆÂâç„Å´<code>jsonParser</code>„Çí‰Ωø„Å£„Å¶<code>String</code>„Çí<code>Json</code>„Å´Â§âÊèõ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ‰ª•‰∏ã„ÅÆ„Éá„Éº„ÇøÂûã„ÅØÂÄ§„ÅåËëâ„Å´„ÅÇ„Çã‰∫åÂàÜÊú®„ÇíË°®Áèæ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>Ê±éÂåñ„Åï„Çå„Åü<code>EncodeJson</code>Âèä„Å≥<code>DecodeJson</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí<code>Tree</code>Âûã„Å´Â∞éÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆ„ÇÑ„ÇäÊñπ„Å´„Å§„ÅÑ„Å¶„ÅÆË™¨Êòé„ÅØ<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonaut„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà</a>„Çí„ÅÇ„Åü„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Å™„Åä„ÄÅ„Åì„ÅÆÊºîÁøí„ÅÆÂçò‰ΩìË©¶È®ì„ÇíÊúâÂäπ„Å´„Åô„Çã„Å´„ÅØÊ±éÂåñ„Åï„Çå„Åü<code>Show</code>Âèä„Å≥<code>Eq</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇÇÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ
„Åó„Åã„ÅóJSON„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å®Ê†ºÈóò„Åó„Åü„ÅÇ„Å®„Åß„ÅØ„Åì„Çå„Çâ„ÅÆÂÆüË£Ö„ÅØÁõ¥ÊÑüÁöÑ„Å´ÈÄ≤„ÇÄ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ‰ª•‰∏ã„ÅÆ<code>data</code>Âûã„ÅØÊï¥Êï∞„ÅãÊñáÂ≠óÂàó„Åã„ÅßJSON„ÅßÁï∞„Å™„Å£„Å¶Ë°®Áèæ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>„Åì„ÅÆÊåØËàû„ÅÑ„ÇíÂÆüË£Ö„Åô„Çã<code>IntOrString</code>„Éá„Éº„ÇøÂûã„Å´<code>EncodeJson</code>Âèä„Å≥<code>DecodeJson</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>Ôºö<code>Control.Alt</code>„ÅÆ<code>alt</code>ÊºîÁÆóÂ≠ê„ÅåÂΩπÁ´ã„Å§„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
</li>
</ol>
<h2 id="‰ΩèÊâÄÈå≤"><a class="header" href="#‰ΩèÊâÄÈå≤">‰ΩèÊâÄÈå≤</a></h2>
<p>„Åì„ÅÆÁØÄ„Åß„ÅØÊñ∞„Åó„ÅèÁç≤Âæó„Åó„ÅüFFI„Å®JSON„ÅÆÁü•Ë≠ò„ÇíÈÅ©Áî®„Åó„Å¶Á¨¨8Á´†„ÅÆ‰ΩèÊâÄÈå≤„ÅÆ‰æã„ÇíÊßãÁØâ„Åó„Å¶„ÅÑ„Åç„Åü„ÅÑ„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ‰ª•‰∏ã„ÅÆÊ©üËÉΩ„ÇíÂä†„Åà„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<ul>
<li>‰øùÂ≠ò„Éú„Çø„É≥„Çí„Éï„Ç©„Éº„É†„ÅÆÂ∫ï„Å´ÁΩÆ„Åç„ÄÅ„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„Å®„Åç„Å´„Éï„Ç©„Éº„É†„ÅÆÁä∂ÊÖã„ÇíJSON
„Å´Áõ¥ÂàóÂåñ„Åó„Å¶„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ</li>
<li>„Éö„Éº„Ç∏„ÅÆÂÜçË™≠„ÅøËæº„ÅøÊôÇ„Å´„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâJSONÊñáÊõ∏„ÇíËá™ÂãïÁöÑ„Å´ÂèñÂæó„Åó„Åæ
„Åô„ÄÇ„Éï„Ç©„Éº„É†„ÅÆ„Éï„Ç£„Éº„É´„Éâ„Å´„ÅØ„Åì„ÅÆÊñáÊõ∏„ÅÆÂÜÖÂÆπ„ÇíÂÖ•„Çå„Åæ„Åô„ÄÇ</li>
<li>„Éï„Ç©„Éº„É†„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò„Åó„Åü„ÇäË™≠„ÅøËæº„Çì„Å†„Çä„Åô„Çã„ÅÆ„Å´ÂïèÈ°å„Åå„ÅÇ„Çå„Å∞„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó
„ÅÆË≠¶Âëä„ÇíÂá∫„Åó„Åæ„Åô„ÄÇ</li>
</ul>
<p><code>Effect.Storage</code>„É¢„Ç∏„É•„Éº„É´„Å´‰ª•‰∏ã„ÅÆWeb„Çπ„Éà„É¨„Éº„Ç∏API„ÅÆ„Åü„ÇÅ„ÅÆFFI„É©„ÉÉ„Éë„Éº„Çí„Å§„Åè„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>setItem</code>„ÅØ„Ç≠„Éº„Å®ÂÄ§Ôºà‰∏°Êñπ„Å®„ÇÇÊñáÂ≠óÂàóÔºâ„ÇíÂèó„ÅëÂèñ„Çä„ÄÅÊåáÂÆö„Åï„Çå„Åü„Ç≠„Éº„Åß„É≠„Éº
„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´ÂÄ§„ÇíÊ†ºÁ¥ç„Åô„ÇãË®àÁÆó„ÇíËøî„Åó„Åæ„Åô„ÄÇ</li>
<li><code>getItem</code>„ÅØ„Ç≠„Éº„ÇíÂèñ„Çä„ÄÅ„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÈñ¢ÈÄ£‰ªò„Åë„Çâ„Çå„Åü„Éê„É™„É•„Éº„ÅÆ
ÂèñÂæó„ÇíË©¶„Åø„Åæ„Åô„ÄÇ„Åó„Åã„Åó<code>window.localStorage</code>„ÅÆ<code>getItem</code>„É°„ÇΩ„ÉÉ„Éâ„ÅØ
<code>null</code>„ÇíËøî„Åó„ÅÜ„Çã„ÅÆ„Åß„ÄÅËøî„ÇãÂûã„ÅØ<code>String</code>„Åß„ÅØ„Å™„Åè<code>Json</code>„Åß„Åô„ÄÇ</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>‰ª•‰∏ã„ÅØ„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„Å´ÂØæÂøú„Åô„ÇãJavaScript„ÅÆÂÆüË£Ö„Åß„ÄÅ<code>Effect/Storage.js</code>„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-js">export const setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

export const getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´‰øùÂ≠ò„Éú„Çø„É≥„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: &quot;form-group row col-form-label&quot;
    , children:
        [ D.button
            { className: &quot;btn-primary btn&quot;
            , onClick: handler_ validateAndSave
            , children: [ D.text &quot;Save&quot; ]
            }
        ]
    }
</code></pre>
<p>„Åù„Åó„Å¶<code>validateAndSave</code>Èñ¢Êï∞‰∏≠„Åß„ÅØ„ÄÅÊ§úË®º„Åï„Çå„Åü<code>person</code>„ÇíJSONÊñáÂ≠óÂàó„Å®„Åó„ÄÅ<code>setItem</code>„Çí‰Ωø„Å£„Å¶Êõ∏„ÅçËæº„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log &quot;Running validators&quot;
  case validatePerson' person of
    Left errs -&gt; log $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;
    Right validPerson -&gt; do
      setItem &quot;person&quot; $ stringify $ encodeJson validPerson
      log &quot;Saved&quot;
</code></pre>
<p>„Å™„Åä„Åì„ÅÆÊÆµÈöé„Åß„Ç≥„É≥„Éë„Ç§„É´„Åó„Çà„ÅÜ„Å®„Åô„Çã„Å®‰ª•‰∏ã„ÅÆ„Ç®„É©„Éº„Å´ÈÅ≠ÈÅá„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>„Åì„Çå„ÅØ„Å™„Åú„Åã„Å®„ÅÑ„ÅÜ„Å®<code>Person</code>„É¨„Ç≥„Éº„Éâ‰∏≠„ÅÆ<code>PhoneType</code>„Åå<code>EncodeJson</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂøÖË¶Å„Å®„Åó„Å¶„ÅÑ„Çã„Åã„Çâ„Åß„Åô„ÄÇ
ÂçòÁ¥î„Å´Ê±éÁî®Á¨¶Âè∑Âåñ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å®Âæ©Âè∑Âåñ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂ∞éÂá∫„Åô„Çå„Å∞ÂÆå‰∫Ü„Åß„Åô„ÄÇ
„Åì„ÅÆ‰ªïÁµÑ„Åø„Å´„Å§„ÅÑ„Å¶„Çà„ÇäË©≥„Åó„Åè„ÅØargonaut„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅßË¶ã„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance genericPhoneType :: Generic PhoneType _

instance encodeJsonPhoneType :: EncodeJson PhoneType where encodeJson = genericEncodeJson
instance decodeJsonPhoneType :: DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>„Åì„Çå„Åß<code>person</code>„Çí„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò„Åß„Åç„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„Éá„Éº„Çø„ÇíÂèñÂæó„Åß„Åç„Å™„ÅÑÈôê„Çä„ÅÇ„Åæ„Çä‰æøÂà©„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
Ê¨°„ÅØ„Åù„Çå„Å´Âèñ„ÇäÊéõ„Åã„Çä„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„Çâ„Äåperson„ÄçÊñáÂ≠óÂàó„ÇíÂèñÂæó„Åô„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-hs">item &lt;- getItem &quot;person&quot;
</code></pre>
<p>„Åù„Çå„Åã„Çâ„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„Çâ<code>Person</code>„É¨„Ç≥„Éº„Éâ„Å∏„ÅÆÊñáÂ≠óÂàó„ÅÆÂ§âÊèõ„ÇíÊâ±„ÅÜ„ÅäÂä©„ÅëÈñ¢Êï∞„Çí„Å§„Åè„Çä„Åæ„Åô„ÄÇ
„Å™„Åä„Åì„ÅÆ„Çπ„Éà„É¨„Éº„Ç∏‰∏≠„ÅÆÊñáÂ≠óÂàó„ÅØ<code>null</code>„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„ÅÜ„Åæ„Åè<code>String</code>„Å®„Åó„Å¶Âæ©Âè∑Âåñ„Åï„Çå„Çã„Åæ„Åß„ÅØÂ§ñÈÉ®„ÅÆ<code>Json</code>„Å®„Åó„Å¶Ë°®Áèæ„Åó„Åæ„Åô„ÄÇ
ÈÅì‰∏≠„Å´„ÅØ‰ªñ„Å´„ÇÇÂ§ö„Åè„ÅÆÂ§âÊèõÂ∑•Á®ã„Åå„ÅÇ„Çä„ÄÅ„Åù„Çå„Åû„Çå„Åß<code>Either</code>„ÅÆÂÄ§„ÇíËøî„Åó„Åæ„Åô„ÄÇ
„Åù„ÅÆ„Åü„ÇÅ„Åì„Çå„Çâ„Çí<code>do</code>„Éñ„É≠„ÉÉ„ÇØ„ÅÆ‰∏≠„Å´„Åæ„Å®„ÇÅ„Çã„ÅÆ„ÅØÁêÜ„Å´ÈÅ©„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>„Åù„ÅÜ„Åó„Å¶„Åì„ÅÆÁµêÊûú„ÅåÊàêÂäü„Åó„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„ÅãË™ø„Åπ„Åæ„Åô„ÄÇ
„ÇÇ„ÅóÂ§±Êïó„Åó„Å¶„ÅÑ„Çå„Å∞„Ç®„É©„Éº„Çí„É≠„Ç∞Âá∫Âäõ„ÅóÊó¢ÂÆö„ÅÆ<code>examplePerson</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÂèñÂæó„Åó„Åü‰∫∫Áâ©„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>ÊúÄÂæå„Å´„Åì„ÅÆ<code>initialPerson</code>„Çí<code>props</code>„É¨„Ç≥„Éº„Éâ„Çí‰ªã„Åó„Å¶„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Å´Ê∏°„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">-- Create JSX node from react component.
app = element addressBookApp { initialPerson }
</code></pre>
<p>„Åù„Åó„Å¶Áä∂ÊÖã„Éï„ÉÉ„ÇØ„Åß‰Ωø„ÅÜ„Åü„ÇÅ„Å´Âà•„ÅÆÊñπ„Åã„ÇâÊãæ„ÅÑ‰∏ä„Åí„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>‰ªï‰∏ä„Åí„Å®„Åó„Å¶„ÄÅ„Åù„Çå„Åû„Çå„ÅÆ<code>Left</code>ÂÄ§„ÅÆ<code>String</code>„Å´<code>lmap</code>„Çí‰Ωø„Å£„Å¶ÂâçÁΩÆ„Åó„ÄÅ„Ç®„É©„ÉºÊñáË®Ä„ÅÆË≥™„ÇíÂêë‰∏ä„Åï„Åõ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap (&quot;No string in local storage: &quot; &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap (&quot;Cannot parse JSON string: &quot;   &lt;&gt; _) $ jsonParser jsonString
  lmap               (&quot;Cannot decode Person: &quot;       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>ÊúÄÂàù„ÅÆ„Ç®„É©„Éº„ÅÆ„Åø„Åì„ÅÆ„Ç¢„Éó„É™„ÅÆÈÄöÂ∏∏„ÅÆÊìç‰ΩúÂÜÖ„ÅßËµ∑„Åì„Çä„Åæ„Åô„ÄÇ
‰ªñ„ÅÆ„Ç®„É©„Éº„ÅØWeb„Éñ„É©„Ç¶„Ç∂„ÅÆÈñãÁô∫„ÉÑ„Éº„É´„ÇíÈñã„ÅÑ„Å¶„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏‰∏≠„Å´‰øùÂ≠ò„Åï„Çå„Åü„Äåperson„ÄçÊñáÂ≠óÂàó„ÇíÁ∑®ÈõÜ„Åó„ÄÅ„Åù„ÅÆ„Éö„Éº„Ç∏„ÇíÂèÇÁÖß„Åô„Çã„Åì„Å®„ÅßÂºï„ÅçËµ∑„Åì„Åõ„Åæ„Åô„ÄÇ
„Å©„ÅÆ„Çà„ÅÜ„Å´JSONÊñáÂ≠óÂàó„ÇíÂ§âÊõ¥„Åó„Åü„Åã„Åå„ÄÅ„Å©„ÅÆ„Ç®„É©„Éº„ÅÆÂºï„ÅçÈáë„Å´„Å™„Çã„Åã„ÇíÊ±∫ÂÆö„Åó„Åæ„Åô„ÄÇ
„Åù„Çå„Åû„Çå„ÅÆ„Ç®„É©„Éº„ÇíÂºï„ÅçËµ∑„Åì„Åõ„Çã„Åã„Å©„ÅÜ„Åã„ÇÑ„Å£„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>„Åì„Çå„Åß„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´„Å§„ÅÑ„Å¶„ÅØÊäº„Åï„Åà„Åæ„Åó„Åü„ÄÇ
Ê¨°„Å´<code>alert</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË£Ö„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ<code>Effect.Console</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ<code>log</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´„Çà„Åè‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂîØ‰∏Ä„ÅÆÁõ∏ÈÅïÁÇπ„ÅØ<code>alert</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Åå<code>window.alert</code>„É°„ÇΩ„ÉÉ„Éâ„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„ÄÅ
ÂØæ„Åó„Å¶<code>log</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ<code>console.log</code>„É°„ÇΩ„ÉÉ„Éâ„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åù„ÅÜ„ÅÑ„ÅÜ„Çè„Åë„Åß<code>alert</code>„ÅØ<code>window.alert</code>„ÅåÂÆöÁæ©„Åï„Çå„ÅüÁí∞Â¢É„Åß„ÅÆ„Åø‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞Web„Éñ„É©„Ç¶„Ç∂„Å™„Å©„Åß„Åô„ÄÇ</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">export const alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>„Åì„ÅÆË≠¶Âëä„ÅåÊ¨°„ÅÆ„ÅÑ„Åö„Çå„Åã„ÅÆÂ†¥Âêà„Å´Áèæ„Çå„Çã„Çà„ÅÜ„Å´„Åó„Åü„ÅÑ„Åß„Åô„ÄÇ</p>
<ul>
<li>Âà©Áî®ËÄÖ„ÅåÊ§úË®º„Ç®„É©„Éº„ÇíÂê´„ÇÄ„Éï„Ç©„Éº„É†„Çí‰øùÂ≠ò„Åó„Çà„ÅÜ„Å®Ë©¶„Åø„Å¶„ÅÑ„Çã„ÄÇ</li>
<li>Áä∂ÊÖã„Åå„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâÂèñÂæó„Åß„Åç„Å™„ÅÑ„ÄÇ</li>
</ul>
<p>‰ª•‰∏ä„ÅØÂçò„Å´‰ª•‰∏ã„ÅÆË°å„Åß<code>log</code>„Çí<code>alert</code>„Å´ÁΩÆ„ÅçÊèõ„Åà„Çã„Å†„Åë„ÅßÈÅîÊàê„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-hs">Left errs -&gt; alert $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;

alert $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
</code></pre>
<h2 id="ÊºîÁøí-32"><a class="header" href="#ÊºîÁøí-32">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ<code>localStorage</code>„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ <code>removeItem</code>„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„É©„ÉÉ„Éë„Éº„ÇíÊõ∏„Åç„ÄÅ
<code>Effect.Storage</code>„É¢„Ç∏„É•„Éº„É´„Å´Â§ñÈÉ®Èñ¢Êï∞„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ</li>
<li>ÔºàÊôÆÈÄöÔºâ„Äå„É™„Çª„ÉÉ„Éà„Äç„Éú„Çø„É≥„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆ„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®Êñ∞„Åó„Åè‰Ωú„Å£„Åü<code>removeItem</code>Èñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó„Å¶
„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„Çâ„Äå‰∫∫Áâ©„Äç„ÅÆÈ†ÖÁõÆ„ÇíÂâäÈô§„Åó„Åæ„Åô„ÄÇ</li>
<li>ÔºàÁ∞°ÂçòÔºâJavaScript„ÅÆ <code>Window</code>„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ <code>confirm</code>„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„É©„ÉÉ„Éë„Éº„ÇíÊõ∏„Åç„ÄÅ
<code>Effect.Alert</code>„É¢„Ç∏„É•„Éº„É´„Å´„Åù„ÅÆÂ§ñÈÉ®Èñ¢Êï∞„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÂà©Áî®ËÄÖ„Åå„Äå„É™„Çª„ÉÉ„Éà„Äç„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„Å®„Åç„Å´„Åì„ÅÆ<code>confirm</code>Èñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó„ÄÅ
Êú¨ÂΩì„Å´„Ç¢„Éâ„É¨„ÇπÂ∏≥„ÇíÁôΩÁ¥ô„Å´„Åó„Åü„ÅÑ„ÅãÂ∞ã„Å≠„Çã„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-8"><a class="header" href="#„Åæ„Å®„ÇÅ-8">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅPureScript„Åã„ÇâÂ§ñÈÉ®„ÅÆJavaScript„Ç≥„Éº„Éâ„ÇíÊâ±„ÅÜÊñπÊ≥ï„ÇíÂ≠¶„Å≥„Åæ„Åó„Åü„ÄÇ„Åæ„Åü„ÄÅFFI„Çí‰ΩøÁî®„Åó„Å¶‰ø°È†º„Åß„Åç„Çã„Ç≥„Éº„Éâ„ÇíÊõ∏„ÅèÊôÇ„Å´Áîü„Åò„ÇãÂïèÈ°å„Å´„Å§„ÅÑ„Å¶Ë¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</p>
<ul>
<li>Â§ñÈÉ®Èñ¢Êï∞„ÅåÊ≠£„Åó„ÅÑË°®Áèæ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫„Åã„ÇÅ„ÇãÈáçË¶ÅÊÄß„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</li>
<li>Â§ñÈÉ®Âûã„ÇÑ<code>Json</code>„Éá„Éº„ÇøÂûã„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Å´„Çà„Å£„Å¶„ÄÅnullÂÄ§„ÇÑJavaScript„ÅÆ‰ªñ„ÅÆ
Âûã„ÅÆ„Éá„Éº„Çø„ÅÆ„Çà„ÅÜ„Å™ÁâπÊÆä„Å™Â†¥Âêà„Å´ÂØæÂá¶„Åô„ÇãÊñπÊ≥ï„ÇíÂ≠¶„Å≥„Åæ„Åó„Åü„ÄÇ</li>
<li>ÂÆâÂÖ®„Å´JSON„Éá„Éº„Çø„ÇíÁõ¥ÂàóÂåñ„ÉªÁõ¥ÂàóÂåñÂæ©ÂÖÉ„Åô„ÇãÊñπÊ≥ï„ÇíË¶ã„Åæ„Åó„Åü„ÄÇ</li>
</ul>
<p>„Çà„ÇäÂ§ö„Åè„ÅÆ‰æã„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅGithub„ÅÆ <code>purescript</code>ÁµÑÁπî„ÄÅ<code>purescript-contrib</code>ÁµÑÁπî„Åä„Çà„Å≥
<code>purescript-node</code>ÁµÑÁπî„Åå„ÄÅFFI„Çí‰ΩøÁî®„Åô„Çã„É©„Ç§„Éñ„É©„É™„ÅÆ‰æã„ÇíÂ§öÊï∞Êèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÊÆã„Çä„ÅÆÁ´†„Åß„ÅØ„ÄÅÂûãÂÆâÂÖ®„Å™ÊñπÊ≥ï„ÅßÁèæÂÆü‰∏ñÁïå„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„ÅÜ„É©„Ç§„Éñ„É©„É™„ÇíÂπæ„Å§„ÅãË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="Ë£úÈÅ∫"><a class="header" href="#Ë£úÈÅ∫">Ë£úÈÅ∫</a></h2>
<h3 id="javascript„Åã„Çâpurescript„ÇíÂëº„Å≥Âá∫„Åô"><a class="header" href="#javascript„Åã„Çâpurescript„ÇíÂëº„Å≥Âá∫„Åô">JavaScript„Åã„ÇâPureScript„ÇíÂëº„Å≥Âá∫„Åô</a></h3>
<p>Â∞ë„Å™„Åè„Å®„ÇÇÂçòÁ¥î„Å™Âûã„ÇíÊåÅ„Å£„ÅüÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅJavaScript„Åã„ÇâPureScriptÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô„ÅÆ„ÅØ„Å®„Å¶„ÇÇÁ∞°Âçò„Åß„Åô„ÄÇ</p>
<p>‰æã„Å®„Åó„Å¶‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™Á∞°Âçò„Å™„É¢„Ç∏„É•„Éº„É´„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„ÄÅÊ∏õÁÆó„ÇíÁπ∞„ÇäËøî„Åô„Åì„Å®„Å´„Çà„Å£„Å¶2„Å§„ÅÆÊï∞„ÅÆÊúÄÂ§ßÂÖ¨Á¥ÑÊï∞„ÇíË¶ã„Å§„Åë„Åæ„Åô„ÄÇ
Èñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„ÅÆ„Å´PureScript„Çí‰Ωø„ÅÑ„Åü„Åè„Å™„Çã„Åã„ÇÇ„Åó„Çå„Å™„ÅÑËâØ„ÅÑ‰æã„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
JavaScript„Åã„Çâ„Åù„Çå„ÇíÂëº„Å≥Âá∫„Åô„Åü„ÇÅ„Å´„ÅØÊù°‰ª∂„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
PureScript„Åß„Éë„Çø„Éº„É≥ÁÖßÂêà„Å®ÂÜçÂ∏∞„Çí‰ΩøÁî®„Åó„Å¶„Åì„ÅÆÈñ¢Êï∞„ÇíÂÆöÁæ©„Åô„Çã„ÅÆ„ÅØÁ∞°Âçò„Åß„ÄÅÂÆüË£Ö„Åô„ÇãÈñãÁô∫ËÄÖ„ÅØÂûãÊ§úË®ºÂô®„ÅÆÊÅ©ÊÅµ„ÇíÂèó„Åë„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÈñ¢Êï∞„ÇíJavaScript„Åã„ÇâÂëº„Å≥Âá∫„ÅôÊñπÊ≥ï„ÇíÁêÜËß£„Åô„Çã„Å´„ÅØ„ÄÅPureScript„ÅÆÈñ¢Êï∞„ÅØÂ∏∏„Å´ÂºïÊï∞„Åå„Å≤„Å®„Å§„ÅÆJavaScriptÈñ¢Êï∞„Å∏„Å®Â§âÊèõ„Åï„Çå„ÄÅÂºïÊï∞„Å∏„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å≤„Å®„Å§„Å•„Å§ÈÅ©Áî®„Åó„Å¶„ÅÑ„Åã„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„Åì„Å®„ÇíÁêÜËß£„Åô„Çã„ÅÆ„ÅåÈáçË¶Å„Åß„Åô„ÄÇ</p>
<pre><code class="language-javascript">import Test from 'Test.js';
Test.gcd(15)(20);
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅ„Ç≥„Éº„Éâ„ÅåPureScript„É¢„Ç∏„É•„Éº„É´„ÇíES„É¢„Ç∏„É•„Éº„É´„Å´„Ç≥„É≥„Éë„Ç§„É´„Åô„Çã <code>spago build</code>„Åß„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„Å¶„ÅÑ„Çã„Å®‰ªÆÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åù„ÅÆ„Åü„ÇÅ„ÄÅ <code>import</code>„Çí‰Ωø„Å£„Å¶ <code>Test</code>„É¢„Ç∏„É•„Éº„É´„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„ÅüÂæå„ÄÅ <code>Test</code>„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ <code>gcd</code>Èñ¢Êï∞„ÇíÂèÇÁÖß„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åó„Åü„ÄÇ</p>
<p><code>pulp build -O --to file.js</code>„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ„Éñ„É©„Ç¶„Ç∂Áî®„ÅÆJavaScript„Ç≥„Éº„Éâ„Çí„Éê„É≥„Éâ„É´„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
„Åù„ÅÆÂ†¥Âêà„ÄÅ„Ç∞„É≠„Éº„Éê„É´„Å™PureScriptÂêçÂâçÁ©∫Èñì„Åã„Çâ <code>Test</code>„É¢„Ç∏„É•„Éº„É´„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Åæ„Åô„ÄÇ„Éá„Éï„Ç©„É´„Éà„ÅØ <code>PS</code>„Åß„Åô„ÄÇ</p>
<pre><code class="language-javascript">var Test = PS.Test;
Test.gcd(15)(20);
</code></pre>
<h3 id="ÂêçÂâç„ÅÆÁîüÊàê„ÇíÁêÜËß£„Åô„Çã"><a class="header" href="#ÂêçÂâç„ÅÆÁîüÊàê„ÇíÁêÜËß£„Åô„Çã">ÂêçÂâç„ÅÆÁîüÊàê„ÇíÁêÜËß£„Åô„Çã</a></h3>
<p>PureScript„ÅØ„Ç≥„Éº„ÉâÁîüÊàêÊôÇ„Å´„Åß„Åç„Çã„Å†„ÅëÂêçÂâç„Çí‰øùÂ≠ò„Åô„Çã„Åì„Å®„ÇíÁõÆÁöÑ„Å®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÖ∑‰ΩìÁöÑ„Å´„ÅØ„ÄÅÂ∞ë„Å™„Åè„Å®„ÇÇ„Éà„ÉÉ„Éó„É¨„Éô„É´„ÅßÂÆ£Ë®Ä„Åï„Çå„ÇãÂêçÂâç„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅPureScript„ÇÑJavaScript„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Åß„Å™„Åë„Çå„Å∞„Åª„Å®„Çì„Å©„ÅÆË≠òÂà•Â≠ê„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>Ë≠òÂà•Â≠ê„Å®„Åó„Å¶JavaScript„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Çí‰Ωø„ÅÜÂ†¥Âêà„ÅØ„ÄÅÂêçÂâç„ÅØ„ÉÄ„Éñ„É´„ÉÄ„É©„ÉºË®òÂè∑„Åß„Ç®„Çπ„Ç±„Éº„Éó„Åï„Çå„Åæ„Åô„ÄÇ„Åü„Å®„Åà„Å∞„ÄÅÊ¨°„ÅÆPureScript„Ç≥„Éº„Éâ„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>„Åì„Çå„ÅØ‰ª•‰∏ã„ÅÆJavaScript„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>„Åæ„Åü„ÄÅË≠òÂà•Â≠ê„Å´ÁâπÊÆäÊñáÂ≠ó„Çí‰ΩøÁî®„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄÅÂçò‰∏Ä„ÅÆ„Éâ„É´Ë®òÂè∑„Çí‰ΩøÁî®„Åó„Å¶„Ç®„Çπ„Ç±„Éº„Éó„Åï„Çå„Åæ„Åô„ÄÇ„Åü„Å®„Åà„Å∞„ÄÅ„Åì„ÅÆPureScript„Ç≥„Éº„Éâ„ÇíËÄÉ„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>„Åì„Çå„ÅØ‰ª•‰∏ã„ÅÆJavaScript„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„ÅüPureScript„Ç≥„Éº„Éâ„ÅåJavaScript„Åã„ÇâÂëº„Å≥Âá∫„Åï„Çå„Çã„Åì„Å®„ÇíÊÑèÂõ≥„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅË≠òÂà•Â≠ê„ÅØËã±Êï∞Â≠ó„ÅÆ„Åø„Çí‰ΩøÁî®„Åó„ÄÅJavaScript„ÅÆ‰∫àÁ¥ÑË™û„ÇíÈÅø„Åë„Çã„Åì„Å®„Çí„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ
„É¶„Éº„Ç∂ÂÆöÁæ©ÊºîÁÆóÂ≠ê„ÅåPureScript„Ç≥„Éº„Éâ„Åß„ÅÆ‰ΩøÁî®„ÅÆ„Åü„ÇÅ„Å´Êèê‰æõ„Åï„Çå„ÇãÂ†¥Âêà„Åß„ÇÇ„ÄÅJavaScript„Åã„Çâ‰Ωø„ÅÜ„Åü„ÇÅ„ÅÆËã±Êï∞Â≠ó„ÅÆÂêçÂâç„ÇíÊåÅ„Å£„Åü‰ª£ÊõøÈñ¢Êï∞„ÇíÊèê‰æõ„Åó„Å¶„Åä„Åè„Åì„Å®„Çí„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ</p>
<h3 id="ÂÆüË°åÊôÇ„ÅÆ„Éá„Éº„ÇøË°®Áèæ"><a class="header" href="#ÂÆüË°åÊôÇ„ÅÆ„Éá„Éº„ÇøË°®Áèæ">ÂÆüË°åÊôÇ„ÅÆ„Éá„Éº„ÇøË°®Áèæ</a></h3>
<p>Âûã„ÅØ„Éó„É≠„Ç∞„É©„É†„Åå„ÅÇ„ÇãÊÑèÂë≥„Åß„ÄåÊ≠£„Åó„ÅÑ„Äç„Åì„Å®„Çí„Ç≥„É≥„Éë„Ç§„É´ÊôÇ„Å´Âà§Êñ≠„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ„Å§„Åæ„Çä„ÄÅ„Åù„ÅÆÁÇπ„Å´„Å§„ÅÑ„Å¶„ÅØÂ£ä„Çå„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Åó„Åã„Åó„ÄÅ„Åì„Çå„ÅØ‰Ωï„ÇíÊÑèÂë≥„Åô„Çã„ÅÆ„Åß„Åó„Çá„ÅÜ„ÅãÔºüPureScript„Åß„ÅØÂºè„ÅÆÂûã„ÅØÂÆüË°åÊôÇ„ÅÆË°®Áèæ„Å®‰∫íÊèõÊÄß„Åå„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åù„ÅÆ„Åü„ÇÅ„ÄÅPureScript„Å®JavaScript„Ç≥„Éº„Éâ„Çí‰∏ÄÁ∑í„Å´ÂäπÁéáÁöÑ„Å´‰ΩøÁî®„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅÂÆüË°åÊôÇ„ÅÆ„Éá„Éº„ÇøË°®Áèæ„Å´„Å§„ÅÑ„Å¶ÁêÜËß£„Åô„Çã„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅ‰∏é„Åà„Çâ„Çå„Åü‰ªªÊÑè„ÅÆPureScript„ÅÆÂºè„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åù„ÅÆÂÄ§„ÅåÂÆüË°åÊôÇ„Å´„Å©„ÅÆ„Çà„ÅÜ„Å´Ë©ï‰æ°„Åï„Çå„Çã„Åã„Å®„ÅÑ„ÅÜÊåôÂãï„ÇíÁêÜËß£„Åß„Åç„Çã„Åπ„Åç„Åß„ÅÇ„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>PureScript„ÅÆÂºè„ÅØ„ÄÅÂÆüË°åÊôÇ„Å´Áâπ„Å´ÂçòÁ¥î„Å™Ë°®Áèæ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„ÅØÊúóÂ†±„Åß„Åô„ÄÇÂûã„ÇíËÄÉÊÖÆ„Åô„Çå„Å∞Âºè„ÅÆÂÆüË°åÊôÇ„ÅÆ„Éá„Éº„ÇøË°®Áèæ„ÇíÊääÊè°„Åô„Çã„Åì„Å®„ÅåÂ∏∏„Å´ÂèØËÉΩ„Åß„Åô„ÄÇ</p>
<p>ÂçòÁ¥î„Å™Âûã„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅÂØæÂøúÈñ¢‰øÇ„ÅØ„Åª„Å®„Çì„Å©Ëá™Êòé„Åß„Åô„ÄÇ„Åü„Å®„Åà„Å∞„ÄÅÂºè„ÅåÂûã <code>Boolean</code>„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çå„Å∞„ÄÅÂÆüË°åÊôÇ„ÅÆ„Åù„ÅÆÂÄ§ <code>v</code>„ÅØ <code>typeof v === 'boolean'</code>„ÇíÊ∫Ä„Åü„Åó„Åæ„Åô„ÄÇ„Å§„Åæ„Çä„ÄÅÂûã <code>Boolean</code>„ÅÆÂºè„ÅØ <code>true</code>„ÇÇ„Åó„Åè„ÅØ
<code>false</code>„ÅÆ„Å©„Å°„Çâ„Åã‰∏ÄÊñπ„ÅÆÔºàJavaScript„ÅÆÔºâÂÄ§„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Åæ„Åô„ÄÇÁâπ„Å´<code>null</code>„ÇÑ <code>undefined</code>„Å´Ë©ï‰æ°„Åï„Çå„ÇãÂûã
<code>Boolean</code>„ÅÆPureScript„ÅÆÂºè„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p><code>Int</code>„ÇÑ<code>Number</code>„ÇÑ<code>String</code>„ÅÆÂûã„ÅÆÂºè„Å´„Å§„ÅÑ„Å¶„ÇÇÂêåÊßò„ÅÆ„Åì„Å®„ÅåÊàê„ÇäÁ´ã„Å°„Åæ„Åô„ÄÇ<code>Int</code>„ÇÑ<code>Number</code>Âûã„ÅÆÂºè„ÅØ
<code>null</code>„Åß„Å™„ÅÑJavaScript„ÅÆÊï∞„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Åæ„Åô„Åó„ÄÅ <code>String</code>Âûã„ÅÆÂºè„ÅØ
<code>null</code>„Åß„Å™„ÅÑJavaScript„ÅÆÊñáÂ≠óÂàó„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Åæ„Åô„ÄÇ„Åü„Å®„Åà<code>typeof</code>„Çí‰Ωø„ÅÜ„Åì„Å®„Å´„Çà„Å£„Å¶Âûã<code>Number</code>„ÅÆÂÄ§„Å®Ë¶ãÂàÜ„Åë„Åå„Å§„Åã„Å™„Åè„Å™„Å£„Å¶„ÇÇ„ÄÅÂûã<code>Int</code>„ÅÆÂºè„ÅØÂÆüË°åÊôÇ„Å´Êï¥Êï∞„Å´Ë©ï‰æ°„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p><code>Unit</code>„Å´„Å§„ÅÑ„Å¶„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„ÅãÔºü<code>Unit</code>„Å´„ÅØÁèæ‰Ωè (<code>unit</code>)
„Åå1„Å§„ÅÆ„Åø„ÅßÂÄ§„ÅåË¶≥Ê∏¨„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ„ÄÅÂÆü„ÅÆ„Å®„Åì„ÇçÂÆüË°åÊôÇ„Å´‰Ωï„ÅßË°®Áèæ„Åï„Çå„Çã„Åã„ÅØÈáçË¶Å„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂè§„ÅÑ„Ç≥„Éº„Éâ„ÅØ<code>{}</code>„Çí‰Ωø„Å£„Å¶Ë°®Áèæ„Åô„ÇãÂÇæÂêë„Åå„ÅÇ„Çä„Åæ„Åó„Åü„ÄÇ„Åó„Åã„ÅóÊØîËºÉÁöÑÊñ∞„Åó„ÅÑ„Ç≥„Éº„Éâ„Åß„ÅØ<code>undefined</code>„Çí‰Ωø„ÅÜÂÇæÂêë„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ„Å™„ÅÆ„Åß„ÄÅ<code>Unit</code>„ÇíË°®Áèæ„Åô„Çã„ÅÆ„Å´‰Ωø„ÅÜ„ÇÇ„ÅÆ„ÅØÊú¨ÂΩì„Å´‰Ωï„Åß„ÇÇÂïèÈ°å„Å´„Å™„Çâ„Å™„ÅÑ„ÅÆ„Åß„Åô„Åå„ÄÅ<code>undefined</code>„Çí‰Ωø„ÅÜ„Åì„Å®„ÅåÊé®Â•®„Åï„Çå„Åæ„ÅôÔºàÈñ¢Êï∞„Åã„Çâ‰Ωï„ÇÇËøî„Åï„Å™„ÅÑ„Å®„Åç„ÇÇ<code>undefined</code>„ÇíËøî„Åó„Åæ„ÅôÔºâ„ÄÇ</p>
<p>„ÇÇ„Å£„Å®Ë§áÈõë„Å™Âûã„Å´„Å§„ÅÑ„Å¶„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„ÅãÔºü</p>
<p>„Åô„Åß„Å´Ë¶ã„Å¶„Åç„Åü„Çà„ÅÜ„Å´„ÄÅPureScript„ÅÆÈñ¢Êï∞„ÅØÂºïÊï∞„Åå„Å≤„Å®„Å§„ÅÆJavaScript„ÅÆÈñ¢Êï∞„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂé≥ÂØÜ„Å´Ë®Ä„Åà„Å∞„ÄÅ‰ªªÊÑè„ÅÆÂûã <code>a</code>„ÄÅ <code>b</code>„Å´„Å§„ÅÑ„Å¶„ÄÅÂºè <code>f</code>„ÅÆÂûã„Åå <code>a -&gt; b</code>„Åß„ÄÅÂºè <code>x</code>„ÅåÂûã <code>a</code>„Å´„Å§„ÅÑ„Å¶„ÅÆÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÅÆÂÄ§„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Çã„Å™„Çâ„ÄÅ <code>f</code>„ÅØJavaScript„ÅÆÈñ¢Êï∞„Å∏„Å®Ë©ï‰æ°„Åï„Çå„ÄÅ <code>x</code>„ÇíË©ï‰æ°„Åó„ÅüÁµêÊûú„Å´ <code>f</code>„ÇíÈÅ©Áî®„Åô„Çã„Å®„ÄÅ„Åù„Çå„ÅØÂûã <code>b</code>„ÅÆÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇÁ∞°Âçò„Å™‰æã„Å®„Åó„Å¶„ÅØ„ÄÅ <code>String -&gt; String</code>Âûã„ÅÆÂºè„ÅØ„ÄÅ <code>null</code>„Åß„Å™„ÅÑJavaScriptÊñáÂ≠óÂàó„Åã„Çâ <code>null</code>„Åß„Å™„ÅÑJavaScriptÊñáÂ≠óÂàó„Å∏„ÅÆÈñ¢Êï∞„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>„ÅîÊÉ≥ÂÉè„ÅÆ„Å®„Åä„Çä„ÄÅPureScript„ÅÆÈÖçÂàó„ÅØJavaScript„ÅÆÈÖçÂàó„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åó„Åã„Åó„ÄÅPureScript„ÅÆÈÖçÂàó„ÅØÂùáË≥™„Åß„ÅÇ„Çä„ÄÅ„Å§„Åæ„Çä„Åô„Åπ„Å¶„ÅÆË¶ÅÁ¥†„ÅåÂêå„ÅòÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÅØË¶ö„Åà„Å¶„Åä„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂÖ∑‰ΩìÁöÑ„Å´„ÅØ„ÄÅ„ÇÇ„ÅóPureScript„ÅÆÂºè
<code>e</code>„Åå‰Ωï„Çâ„Åã„ÅÆÂûã <code>a</code>„Å´„Å§„ÅÑ„Å¶Âûã <code>Array a</code>„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Å™„Çâ„ÄÅ <code>e</code>„ÅØ„Åô„Åπ„Å¶„ÅÆË¶ÅÁ¥†„ÅåÂûã
<code>a</code>„ÅÆÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å£„ÅüÔºà<code>null</code>„Åß„Å™„ÅÑÔºâJavaScriptÈÖçÂàó„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>PureScript„ÅÆ„É¨„Ç≥„Éº„Éâ„ÅåJavaScript„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Çã„Åì„Å®„ÅØ„Åô„Åß„Å´Ë¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ„Å°„Çá„ÅÜ„Å©Èñ¢Êï∞„Å®ÈÖçÂàó„ÅÆÂ†¥Âêà„ÅÆ„Çà„ÅÜ„Å´„ÄÅ„Åù„ÅÆ„É©„Éô„É´„Å´Èñ¢ÈÄ£‰ªò„Åë„Çâ„Çå„Å¶„ÅÑ„ÇãÂûã„ÇíËÄÉÊÖÆ„Åô„Çå„Å∞„ÄÅ„É¨„Ç≥„Éº„Éâ„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅÆ„Éá„Éº„Çø„ÅÆÂÆüË°åÊôÇ„ÅÆË°®Áèæ„Å´„Å§„ÅÑ„Å¶„ÇÇÊé®Ë´ñ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„ÇÇ„Å°„Çç„Çì„ÄÅ„É¨„Ç≥„Éº„Éâ„ÅÆ„Åù„Çå„Åû„Çå„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅØ„ÄÅÂêå„ÅòÂûã„Åß„ÅÇ„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<h3 id="adt„ÅÆË°®Áèæ"><a class="header" href="#adt„ÅÆË°®Áèæ">ADT„ÅÆË°®Áèæ</a></h3>
<p>PureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØ„ÄÅ‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÅÆ„Åô„Åπ„Å¶„ÅÆÊßãÁØâÂ≠ê„Å´„Å§„ÅÑ„Å¶„Åù„Çå„Åû„ÇåÈñ¢Êï∞„ÇíÂÆöÁæ©„Åó„ÄÅÊñ∞„Åü„Å™JavaScript„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂûã„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Çâ„ÅÆÊßãÁØâÂ≠ê„ÅØ„Åì„Çå„Çâ„ÅÆ„Éó„É≠„Éà„Çø„Ç§„Éó„Å´Âü∫„Å•„ÅÑ„Å¶Êñ∞„Åó„ÅÑJavaScript„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê„Åô„ÇãÈñ¢Êï∞„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÂçòÁ¥î„Å™ADT„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>PureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™„Ç≥„Éº„Éâ„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>„Åì„Åì„Åß2„Å§„ÅÆJavaScript„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂûã <code>Zero</code>„Å®
<code>One</code>„ÇíË¶ã„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇJavaScript„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ<code>new</code>„Çí‰ΩøÁî®„Åô„Çã„Å®„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÂûã„ÅÆÂÄ§„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇÂºïÊï∞„ÇíÊåÅ„Å§ÊßãÁØâÂ≠ê„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅØ
<code>value0</code>„ÄÅ <code>value1</code>„Å™„Å©„Å®Âëº„Å∞„Çå„Çã„Éï„Ç£„Éº„É´„Éâ„Å´ÂØæÂøú„Åô„Çã„Éá„Éº„Çø„ÇíÊ†ºÁ¥ç„Åó„Åæ„Åô„ÄÇ</p>
<p>PureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØË£úÂä©Èñ¢Êï∞„ÇÇÁîüÊàê„Åó„Åæ„Åô„ÄÇÂºïÊï∞„ÅÆ„Å™„ÅÑÊßãÁØâÂ≠ê„Å´„Å§„ÅÑ„Å¶„ÅØ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅØÊßãÁØâÂ≠ê„Åå‰Ωø„Çè„Çå„Çã„Åü„Å≥„Å´
<code>new</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„ÅÜ„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ„Éá„Éº„Çø„ÇíÂÜçÂà©Áî®„Åß„Åç„Çã„Çà„ÅÜ„Å´
<code>value</code>„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ„Å≤„Å®„Å§‰ª•‰∏ä„ÅÆÂºïÊï∞„ÇíÊåÅ„Å§ÊßãÁØâÂ≠ê„Åß„ÅØ„ÄÅÈÅ©Âàá„Å™Ë°®Áèæ„ÇíÊåÅ„Å§ÂºïÊï∞„ÇíÂèñ„ÇäÈÅ©Âàá„Å™ÊßãÁØâÂ≠ê„ÇíÈÅ©Áî®„Åô„Çã
<code>create</code>Èñ¢Êï∞„Çí„Ç≥„É≥„Éë„Ç§„É©„ÅØÁîüÊàê„Åó„Åæ„Åô„ÄÇ</p>
<p>2ÂºïÊï∞‰ª•‰∏ä„ÅÆÊßãÁØâÂ≠ê„Å´„Å§„ÅÑ„Å¶„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Åù„ÅÆÂ†¥Âêà„Åß„ÇÇ„ÄÅPureScript„Ç≥„É≥„Éë„Ç§„É©„ÅØÊñ∞„Åó„ÅÑ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂûã„Å®Ë£úÂä©Èñ¢Êï∞„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ„Åó„Åã„Åó‰ªäÂõû„ÅØ„ÄÅË£úÂä©Èñ¢Êï∞„ÅØ2ÂºïÊï∞„ÅÆ„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÈñ¢Êï∞„Åß„Åô„ÄÇ„Åü„Å®„Åà„Å∞„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„ÇíËÄÉ„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ„Åã„Çâ„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™JavaScript„Ç≥„Éº„Éâ„ÅåÁîüÊàê„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂûã <code>Two</code>„ÅÆÂÄ§„ÅØ„Ç≠„Éº„ÉØ„Éº„Éâ<code>new</code>„Åæ„Åü„ÅØ <code>Two.create</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åô„Çã„Å®‰ΩúÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>newtype„ÅÆÂ†¥Âêà„ÅØ„Åæ„ÅüÂ∞ë„ÅóÁï∞„Å™„Çä„Åæ„Åô„ÄÇnewtype„ÅØÂçò‰∏Ä„ÅÆÂºïÊï∞„ÇíÂèñ„ÇãÂçò‰∏Ä„ÅÆÊßãÁØâÂ≠ê„ÇíÊåÅ„Å§„Çà„ÅÜÂà∂Èôê„Åï„Çå„Åü‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Åß„ÅÇ„Çã„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åì„ÅÆÂ†¥Âêà„Å´„ÅØ„ÄÅÂÆüÈöõ„ÅØnewtype„ÅÆÂÆüË°åÊôÇË°®Áèæ„ÅØ„ÄÅ„Åù„ÅÆÂºïÊï∞„ÅÆÂûã„Å®Âêå„Åò„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„ÄÅÈõªË©±Áï™Âè∑„ÇíË°®„ÅôÊ¨°„ÅÆ„Çà„ÅÜ„Å™newtype„ÇíËÄÉ„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>„Åì„Çå„ÅØÂÆüË°åÊôÇ„Å´„ÅØJavaScript„ÅÆÊñáÂ≠óÂàó„Å®„Åó„Å¶Ë°®„Åï„Çå„Åæ„Åô„ÄÇnewtype„ÅØÂûãÂÆâÂÖ®ÊÄß„ÅÆËøΩÂä†„ÅÆÂ±§„ÇíÊèê‰æõ„Åó„Åæ„Åô„Åå„ÄÅÂÆüË°åÊôÇ„ÅÆÈñ¢Êï∞Âëº„Å≥Âá∫„Åó„ÅÆ„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„Åå„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„É©„Ç§„Éñ„É©„É™„ÇíË®≠Ë®à„Åô„Çã„ÅÆ„Å´ÂΩπ„Å´Á´ã„Å°„Åæ„Åô„ÄÇ</p>
<h3 id="ÈáèÂåñ„Åï„Çå„ÅüÂûã„ÅÆË°®Áèæ"><a class="header" href="#ÈáèÂåñ„Åï„Çå„ÅüÂûã„ÅÆË°®Áèæ">ÈáèÂåñ„Åï„Çå„ÅüÂûã„ÅÆË°®Áèæ</a></h3>
<p>ÈáèÂåñ„Åï„Çå„ÅüÂûãÔºàÂ§öÁõ∏ÂûãÔºâ„ÅÆÂºè„ÅØ„ÄÅÂà∂Èôê„Åï„Çå„ÅüË°®Áèæ„ÇíÂÆüË°åÊôÇ„Å´ÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆüÈöõ„Å´„ÅØ„ÄÅÊâÄ‰∏é„ÅÆÈáèÂåñ„Åï„Çå„ÅüÂûã„ÇíÊåÅ„Å§Âºè„ÅåÊØîËºÉÁöÑÂ∞ë„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„Åå„ÄÅ„Åì„Çå„Å´„Çà„Å£„Å¶„Å®„Å¶„ÇÇÂäπÁéáÁöÑ„Å´Ëß£Ê±∫„Åß„Åç„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„ÄÅÊ¨°„ÅÆÂ§öÁõ∏Âûã„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>„Åì„ÅÆÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„ÇãÈñ¢Êï∞„Å´„ÅØ„Å©„Çì„Å™„ÇÇ„ÅÆ„Åå„ÅÇ„Çã„Åß„Åó„Çá„ÅÜ„Åã„ÄÇÂ∞ë„Å™„Åè„Å®„ÇÇ„Å≤„Å®„Å§„ÅØ„Åì„ÅÆÂûã„ÇíÊåÅ„Å§Èñ¢Êï∞„ÅåÂ≠òÂú®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åô„Å™„Çè„Å°„ÄÅ
<code>Prelude</code>„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÊÅíÁ≠âÈñ¢Êï∞ <code>id</code>„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">id :: forall a. a -&gt; a
id a = a
</code></pre>
<p>ÂÆü„ÅÆ„Å®„Åì„Çç„ÄÅ <code>id</code>„ÅÆÈñ¢Êï∞„ÅØ„Åì„ÅÆÂûã„ÅÆ<strong>ÂîØ‰∏Ä„ÅÆ</strong>ÔºàÂÖ®ÔºâÈñ¢Êï∞„Åß„ÅôÔºÅ„Åì„Çå„ÅØÁ¢∫„Åã„Å´ÈñìÈÅï„ÅÑ„Å™„Åï„Åù„ÅÜ„Å´Ë¶ã„Åà„Åæ„Åô„ÅåÔºà„Åì„ÅÆÂûã„ÇíÊåÅ„Å£„Åü
<code>id</code>„Å®„ÅØÊòé„Çâ„Åã„Å´Áï∞„Å™„ÇãÂºè„ÇíÊõ∏„Åì„ÅÜ„Å®„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑÔºâ„ÄÅ„Åì„Çå„ÇíÁ¢∫„Åã„ÇÅ„Çã„Å´„ÅØ„Å©„ÅÜ„Åó„Åü„Çâ„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ„Åì„Çå„ÅØÂûã„ÅÆÂÆüË°åÊôÇË°®Áèæ„ÇíËÄÉ„Åà„Çã„Åì„Å®„Å´„Çà„Å£„Å¶Á¢∫Ë™ç„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÈáèÂåñ„Åï„Çå„ÅüÂûã <code>forall a. t</code>„ÅÆÂÆüË°åÊôÇË°®Áèæ„ÅØ„Å©„ÅÜ„Å™„Å£„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ„Åï„Å¶„ÄÅ„Åì„ÅÆÂûã„ÅÆÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å§‰ªªÊÑè„ÅÆÂºè„ÅØ„ÄÅÂûã <code>a</code>„Çí„Å©„ÅÆ„Çà„ÅÜ„Å´ÈÅ∏„Çì„Åß„ÇÇÂûã <code>t</code>„ÅÆÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ‰∏ä„ÅÆ‰æã„Åß„ÅØ„ÄÅÂûã <code>forall a. a -&gt; a</code>„ÅÆÈñ¢Êï∞„ÅØ„ÄÅ <code>String -&gt; String</code>„ÄÅ <code>Number -&gt; Number</code>„ÄÅ <code>Array Boolean -&gt; Array Boolean</code>„Å™„Å©„Å®„ÅÑ„Å£„ÅüÂûã„Å´„Å§„ÅÑ„Å¶„ÄÅÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ „Åì„Çå„Çâ„ÅØ„ÄÅÊñáÂ≠óÂàó„Åã„ÇâÊñáÂ≠óÂàó„ÄÅÊï∞„Åã„ÇâÊï∞„ÅÆÈñ¢Êï∞„Åß„Å™„Åè„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>„Åó„Åã„Åó„ÄÅ„Åù„Çå„Å†„Åë„Åß„ÅØÂçÅÂàÜ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÈáèÂåñ„Åï„Çå„ÅüÂûã„ÅÆÂÆüË°åÊôÇË°®Áèæ„ÅØ„ÄÅ„Åì„Çå„Çà„Çä„ÇÇÊõ¥„Å´Âé≥„Åó„Åè„Å™„Çä„Åæ„Åô„ÄÇ‰ªªÊÑè„ÅÆÂºè„Åå<strong>„Éë„É©„É°„Éà„É™„ÉÉ„ÇØÂ§öÁõ∏ÁöÑ</strong>„Åß„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ„Å§„Åæ„Çä„ÄÅ„Åù„ÅÆÂÆüË£Ö„Å´„Åä„ÅÑ„Å¶„ÄÅÂºïÊï∞„ÅÆÂûã„Å´„Å§„ÅÑ„Å¶„ÅÆ„Å©„Çì„Å™ÊÉÖÂ†±„ÇÇ‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Å™„ÅÑ„ÅÆ„Åß„Åô„ÄÇ„Åì„ÅÆËøΩÂä†„ÅÆÊù°‰ª∂„ÅØ„ÄÅËÄÉ„Åà„Çâ„Çå„ÇãÂ§öÁõ∏Âûã„ÅÆ„ÅÜ„Å°„ÄÅ‰ª•‰∏ã„ÅÆJavaScript„ÅÆÈñ¢Êï∞„ÅÆ„Çà„ÅÜ„Å™ÂïèÈ°å„ÅÆ„ÅÇ„ÇãÂÆüË£Ö„ÇíÈò≤Ê≠¢„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>Á¢∫„Åã„Å´„Åì„ÅÆÈñ¢Êï∞„ÅØÊñáÂ≠óÂàó„Åã„ÇâÊñáÂ≠óÂàó„ÄÅÊï∞„Åã„ÇâÊï∞„Å∏„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å™Èñ¢Êï∞„Åß„ÅØ„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅËøΩÂä†„ÅÆÊù°‰ª∂„ÇíÊ∫Ä„Åü„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂºïÊï∞„ÅÆÂÆüË°åÊôÇ„ÅÆÂûã„ÇíË™ø„Åπ„Å¶„Åä„Çä„ÄÅ„Åó„Åü„Åå„Å£„Å¶„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØÂûã <code>forall a. a -&gt; a</code>„ÅÆÊ≠£„Åó„ÅÑÂÆüË£Ö„Å†„Å®„ÅØ„ÅÑ„Åà„Å™„ÅÑ„ÅÆ„Åß„Åô„ÄÇ</p>
<p>Èñ¢Êï∞„ÅÆÂºïÊï∞„ÅÆÂÆüË°åÊôÇ„ÅÆÂûã„ÇíÊ§úÊüª„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Å™„Åë„Çå„Å∞„ÄÅÂîØ‰∏Ä„ÅÆÈÅ∏ÊäûËÇ¢„ÅØÂºïÊï∞„Çí„Åù„ÅÆ„Åæ„ÅæËøî„Åô„Åì„Å®„Å†„Åë„Åß„ÅÇ„Çä„ÄÅ„Åó„Åü„Åå„Å£„Å¶ <code>id</code>„ÅØ„Åü„Åó„Åã„Å´ <code>forall a. a -&gt; a</code>„ÅÆÂîØ‰∏Ä„ÅÆÂÆüË£Ö„Å™„ÅÆ„Åß„Åô„ÄÇ</p>
<p><strong>„Éë„É©„É°„Éà„É™„ÉÉ„ÇØÂ§öÁõ∏</strong> (parametric polymorphism) „Å®<strong>„Éë„É©„É°„Éà„É™„ÉÉ„ÇØÊÄß</strong> (parametricity)
„Å´„Å§„ÅÑ„Å¶„ÅÆË©≥„Åó„ÅÑË≠∞Ë´ñ„ÅØÊú¨Êõ∏„ÅÆÁØÑÂõ≤„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åü„Å†Ê≥®ÁõÆ„Åó„Å¶„ÅÑ„Åü„Å†„Åç„Åü„ÅÑ„Åì„Å®„ÅØ„ÄÅPureScript„ÅÆÂûã„ÅØ„ÄÅÂÆüË°åÊôÇ„Å´<strong>Ê∂àÂéª</strong>„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅPureScript„ÅÆÂ§öÁõ∏Èñ¢Êï∞„ÅØÔºàFFI„Çí‰Ωø„Çè„Å™„ÅÑÈôê„ÇäÔºâÂºïÊï∞„ÅÆÂÆüË°åÊôÇË°®Áèæ„ÇíÊ§úÊüª„Åô„Çã„Åì„Å®„Åå<strong>„Åß„Åç„Åö</strong>„ÄÅ„Åù„ÅÆ„Åü„ÇÅ„Åì„ÅÆÂ§öÁõ∏ÁöÑ„Å™„Éá„Éº„Çø„ÅÆË°®Áèæ„ÅåÈÅ©Âàá„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Å™„ÅÆ„Åß„Åô„ÄÇ</p>
<h3 id="Âà∂Á¥Ñ„ÅÆ„ÅÇ„ÇãÂûã„ÅÆË°®Áèæ"><a class="header" href="#Âà∂Á¥Ñ„ÅÆ„ÅÇ„ÇãÂûã„ÅÆË°®Áèæ">Âà∂Á¥Ñ„ÅÆ„ÅÇ„ÇãÂûã„ÅÆË°®Áèæ</a></h3>
<p>Âûã„ÇØ„É©„ÇπÂà∂Á¥Ñ„ÇíÊåÅ„Å§Èñ¢Êï∞„ÅØ„ÄÅÂÆüË°åÊôÇ„Å´Èù¢ÁôΩ„ÅÑË°®Áèæ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÈñ¢Êï∞„ÅÆÊåØ„ÇãËàû„ÅÑ„ÅØ„Ç≥„É≥„Éë„Ç§„É©„Å´„Çà„Å£„Å¶ÈÅ∏„Å∞„Çå„ÅüÂûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´‰æùÂ≠ò„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅÈñ¢Êï∞„Å´„ÅØ<strong>Âûã„ÇØ„É©„ÇπËæûÊõ∏</strong>
(type class dictionary)
„Å®Âëº„Å∞„Çå„ÇãËøΩÂä†„ÅÆÂºïÊï∞„Åå‰∏é„Åà„Çâ„Çå„Åæ„Åô„ÄÇ„Åì„ÅÆËæûÊõ∏„Å´„ÅØÈÅ∏„Å∞„Çå„Åü„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åã„ÇâÊèê‰æõ„Åï„Çå„ÇãÂûã„ÇØ„É©„Çπ„ÅÆÈñ¢Êï∞„ÅÆÂÆüË£Ö„ÅåÂê´„Åæ„Çå„Åæ„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„ÄÅ <code>Show</code>Âûã„ÇØ„É©„Çπ„Çí‰Ωø„Å£„ÅüÂà∂Á¥Ñ„ÅÆ„ÅÇ„ÇãÂûã„ÇíÊåÅ„Å§„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÂçòÁ¥î„Å™PureScriptÈñ¢Êï∞„Å´„Å§„ÅÑ„Å¶ËÄÉ„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>ÁîüÊàê„Åï„Çå„ÇãJavaScript„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p><code>shout</code>„ÅØ1ÂºïÊï∞„Åß„ÅØ„Å™„Åè„ÄÅ2ÂºïÊï∞„ÅÆÔºà„Ç´„É™„ÉºÂåñ„Åï„Çå„ÅüÔºâÈñ¢Êï∞„Å´„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊúÄÂàù„ÅÆÂºïÊï∞ <code>dict</code>„ÅØ
<code>Show</code>Âà∂Á¥Ñ„ÅÆÂûã„ÇØ„É©„ÇπËæûÊõ∏„Åß„Åô„ÄÇ <code>dict</code>„Å´„ÅØÂûã <code>a</code>„ÅÆ <code>show</code>Èñ¢Êï∞„ÅÆÂÆüË£Ö„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂàù„ÅÆÂºïÊï∞„Å®„Åó„Å¶ÊòéÁ§∫ÁöÑ„Å´<code>Data.Show</code>„ÅÆÂûã„ÇØ„É©„ÇπËæûÊõ∏„ÇíÊ∏°„Åô„Å®„ÄÅJavaScript„Åã„Çâ„Åì„ÅÆÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">import { showNumber } from 'Data.Show'

shout(showNumber)(42);
</code></pre>
<h3 id="ÊºîÁøí-33"><a class="header" href="#ÊºîÁøí-33">ÊºîÁøí</a></h3>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ„Åì„Çå„Çâ„ÅÆÂûã„ÅÆÂÆüË°åÊôÇ„ÅÆË°®Áèæ„ÅØ‰Ωï„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>„Åì„Çå„Çâ„ÅÆÂûã„ÇíÊåÅ„Å§Âºè„Å´„Å§„ÅÑ„Å¶„Çè„Åã„Çã„Åì„Å®„ÅØ„Å™„Çì„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>spago build</code>„Çí‰Ωø„Å£„Å¶„Ç≥„É≥„Éë„Ç§„É´„Åó„ÄÅNodeJS„ÅÆ <code>import</code>Ê©üËÉΩ„Çí‰Ωø„Å£„Å¶„É¢„Ç∏„É•„Éº„É´„Çí„Ç§„É≥„Éù„Éº„Éà„Åô„Çã„Åì„Å®„Åß„ÄÅJavaScript„Åã„Çâ <code>arrays</code>„É©„Ç§„Éñ„É©„É™„ÅÆÈñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<strong>„Éí„É≥„Éà</strong>ÔºöÁîüÊàê„Åï„Çå„ÅüCommonJS„É¢„Ç∏„É•„Éº„É´„ÅåNodeJS„É¢„Ç∏„É•„Éº„É´„ÅÆ„Éë„Çπ„Åß‰ΩøÁî®„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅÂá∫Âäõ„Éë„Çπ„ÇíË®≠ÂÆö„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
</li>
</ol>
<h3 id="ÂâØ‰ΩúÁî®„ÅÆË°®Áèæ"><a class="header" href="#ÂâØ‰ΩúÁî®„ÅÆË°®Áèæ">ÂâØ‰ΩúÁî®„ÅÆË°®Áèæ</a></h3>
<p><code>Effect</code>„É¢„Éä„Éâ„ÇÇÂ§ñÈÉ®Âûã„Å®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åù„ÅÆÂÆüË°åÊôÇË°®Áèæ„ÅØ„Å®„Å¶„ÇÇÁ∞°Âçò„Åß„Åô„ÄÇÂûã <code>Effect a</code>„ÅÆÂºè„ÅØÂºïÊï∞„Å™„Åó„ÅÆJavaScriptÈñ¢Êï∞„Å∏„Å®Ë©ï‰æ°„Åï„Çå„Åæ„Åô„ÄÇ„Åì„ÅÆÈñ¢Êï∞„ÅØ„ÅÇ„Çâ„ÇÜ„ÇãÂâØ‰ΩúÁî®„ÇíÂÆüË°å„ÅóÂûã <code>a</code>„ÅÆÈÅ©Âàá„Å™ÂÆüË°åÊôÇË°®Áèæ„ÅßÂÄ§„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Effect</code>ÂûãÊßãÁØâÂ≠ê„ÅÆÂÆöÁæ©„ÅØ„ÄÅ <code>Effect</code>„É¢„Ç∏„É•„Éº„É´„ÅßÊ¨°„ÅÆ„Çà„ÅÜ„Å´‰∏é„Åà„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>Á∞°Âçò„Å™‰æã„Å®„Åó„Å¶„ÄÅ <code>random</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÂÆöÁæ©„Åï„Çå„Çã <code>random</code>Èñ¢Êï∞„ÇíËÄÉ„Åà„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åù„ÅÆÂûã„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™„ÇÇ„ÅÆ„Åß„Åó„Åü„ÄÇ</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p><code>random</code>Èñ¢Êï∞„ÅÆÂÆöÁæ©„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´‰∏é„Åà„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">export const random = Math.random;
</code></pre>
<p><code>random</code>Èñ¢Êï∞„ÅØÂÆüË°åÊôÇ„Å´„ÅØÂºïÊï∞„Å™„Åó„ÅÆÈñ¢Êï∞„Å®„Åó„Å¶Ë°®Áèæ„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åì„Çå„ÅØ‰π±Êï∞ÁîüÊàê„Å®„ÅÑ„ÅÜÂâØ‰ΩúÁî®„ÇíÂÆüË°å„Åó„Åù„Çå„ÇíËøî„Åó„Åæ„Åô„Åå„ÄÅËøî„ÇäÂÄ§„ÅØ
<code>Number</code>Âûã„ÅÆÂÆüË°åÊôÇË°®Áèæ„Å®‰∏ÄËá¥„Åó„Åæ„Åô„ÄÇ„Åù„Çå„ÅØ <code>null</code>„Åß„Å™„ÅÑJavaScript„ÅÆÊï∞„Åß„Åô„ÄÇ</p>
<p>„ÇÇ„ÅÜÂ∞ë„ÅóËààÂë≥Ê∑±„ÅÑ‰æã„Å®„Åó„Å¶„ÄÅ<code>console</code>„Éë„ÉÉ„Ç±„Éº„Ç∏‰∏≠„ÅÆ<code>Effect.Console</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Åü <code>log</code>Èñ¢Êï∞„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>log</code>Èñ¢Êï∞„ÅØÊ¨°„ÅÆÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>„Åì„ÅÆÂÆöÁæ©„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">export const log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>ÂÆüË°åÊôÇ„ÅÆ
<code>log</code>„ÅÆË°®Áèæ„ÅØ„ÄÅÂçò‰∏Ä„ÅÆÂºïÊï∞„ÅÆJavaScriptÈñ¢Êï∞„Åß„ÄÅÂºïÊï∞„Å™„Åó„ÅÆÈñ¢Êï∞„ÇíËøî„Åó„Åæ„Åô„ÄÇÂÜÖÂÅ¥„ÅÆÈñ¢Êï∞„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´„Å´„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊõ∏„ÅçËæº„ÇÄ„Å®„ÅÑ„ÅÜÂâØ‰ΩúÁî®„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Effect a</code>Âûã„ÅÆÂºè„ÅØ„ÄÅÈÄöÂ∏∏„ÅÆJavaScript„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„Çà„ÅÜ„Å´JavaScript„Åã„ÇâÂëº„Å≥Âá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ‰æã„Åà„Å∞„ÄÅ„Åì„ÅÆ
<code>main</code>Èñ¢Êï∞„ÅØ‰Ωï„Çâ„Åã„ÅÆÂûã <code>a</code>„Å´„Å§„ÅÑ„Å¶<code>Effect a</code>„Å®„ÅÑ„ÅÜÂûã„Åß„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„ÅÆ„Åß„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆüË°å„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-javascript">import { main } from 'Main'

main();
</code></pre>
<p><code>spago bundle-app --to</code>„Åæ„Åü„ÅØ <code>spago run</code>„Çí‰ΩøÁî®„Åô„Çã„Å®„Åç„ÅØ„ÄÅ<code>Main</code>„É¢„Ç∏„É•„Éº„É´„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂ∏∏„Å´„ÄÅ„Åì„ÅÆ
<code>main</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÇíËá™ÂãïÁöÑ„Å´ÁîüÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="„É¢„Éä„Éâ„Å™ÂÜíÈô∫"><a class="header" href="#„É¢„Éä„Éâ„Å™ÂÜíÈô∫">„É¢„Éä„Éâ„Å™ÂÜíÈô∫</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-9"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-9">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô„ÅØ<strong>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê</strong> (monad transformers) „Å´„Å§„ÅÑ„Å¶Â≠¶„Å∂„Åì„Å®„Åß
„Åô„ÄÇ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅØÁï∞„Å™„Çã„É¢„Éä„Éâ„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÂâØ‰ΩúÁî®„ÇíÂêàÊàê„Åô„ÇãÊñπÊ≥ï„ÇíÊèê‰æõ
„Åó„Åæ„Åô„ÄÇNodeJS„ÅÆ„Ç≥„É≥„ÇΩ„Éº„É´‰∏ä„ÅßÈÅä„Å∂„Åì„Å®„Åå„Åß„Åç„Çã„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„Ç¢„Éâ„Éô„É≥„ÉÅ„É£„Éº
„Ç≤„Éº„É†„ÇíÈ°åÊùê„Å®„Åó„Å¶Êâ±„ÅÑ„Åæ„Åô„ÄÇ„Ç≤„Éº„É†„ÅÆÊßò„ÄÖ„Å™ÂâØ‰ΩúÁî®Ôºà„É≠„ÇÆ„É≥„Ç∞„ÄÅÁä∂ÊÖã„ÄÅ„Åä„Çà
„Å≥Ë®≠ÂÆöÔºâ„Åå„Åô„Åπ„Å¶„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ„Å´„Çà„Å£„Å¶Êèê‰æõ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-8"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-8">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØ‰ª•‰∏ã„ÅÆÊñ∞„Åó„ÅÑ‰æùÂ≠òÈñ¢‰øÇ„ÅåÂ∞éÂÖ•„Åï„Çå„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>ordered-collections</code> „ÅØ‰∏çÂ§â„ÅÆ„Éû„ÉÉ„Éó„Å®ÈõÜÂêà„ÅÆ„Åü„ÇÅ„ÅÆ„Éá„Éº„ÇøÂûã„ÇíÊèê‰æõ„Åó„Åæ„Åô</li>
<li><code>transformers</code> „ÅØÊ®ôÊ∫ñ„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅÆÂÆüË£Ö„ÇíÊèê‰æõ„Åó„Åæ„Åô</li>
<li><code>node-readline</code> - NodeJS„ÅåÊèê‰æõ„Åô„Çã
<a href="http://nodejs.org/api/readline.html"><code>readline</code></a>„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„Å∏„ÅÆ
FFI„Éê„Ç§„É≥„Éá„Ç£„É≥„Ç∞„ÇíÊèê‰æõ„Åó„Åæ„Åô</li>
<li><code>optparse</code> „ÅØ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„ÇíÂá¶ÁêÜ„Åô„Çã„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÊßãÊñáËß£ÊûêÂô®„ÇíÊèê
‰æõ„Åó„Åæ„Åô</li>
</ul>
<h2 id="„Ç≤„Éº„É†„ÅÆÈÅä„Å≥„Åã„Åü"><a class="header" href="#„Ç≤„Éº„É†„ÅÆÈÅä„Å≥„Åã„Åü">„Ç≤„Éº„É†„ÅÆÈÅä„Å≥„Åã„Åü</a></h2>
<p>„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíËµ∞„Çâ„Åõ„Çã„Å´„ÅØ<code>spago run</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Êó¢ÂÆö„Åß„ÅØ‰Ωø„ÅÑÊñπ„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">Monadic Adventures! A game to learn monad transformers

Usage: run.js (-p|--player &lt;player name&gt;) [-d|--debug]
  Play the game as &lt;player name&gt;

Available options:
  -p,--player &lt;player name&gt;
                           The player's name &lt;String&gt;
  -d,--debug               Use debug mode
  -h,--help                Show this help text
</code></pre>
<p>„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„ÇíÊèê‰æõ„Åô„Çã„Åü„ÇÅ„Å´„ÅØ„ÄÅËøΩÂä†„ÅÆÂºïÊï∞„ÇíÁõ¥Êé•„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥
„Å´Ê∏°„Åô<code>-a</code>„Ç™„Éó„Ç∑„Éß„É≥‰ªò„Åç„Åß<code>spago run</code>„ÇíÂëº„Å≥Âá∫„Åô„Åã„ÄÅ
<code>spago bundle-app</code>„Å®„Åô„Çå„Å∞„Çà„ÅÑ„Åß„Åô„ÄÇ2„Å§ÁõÆ„ÅÆÊñπÊ≥ï„Åß„ÅØ<code>node</code>„ÅßÁõ¥Êé•Ëµ∞„Çâ„Åõ„Çâ„Çå„Çã
index.js„Éï„Ç°„Ç§„É´„Åå‰Ωú„Çâ„Çå„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞<code>-p</code>„Ç™„Éó„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶„Éó„É¨„Ç§„É§„ÉºÂêç„Çí‰∏é„Åà„Çã„Å´„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;
&gt;
</code></pre>
<pre><code class="language-text">$ spago bundle-app 
$ node index.js -p Phil
&gt;
</code></pre>
<p>„Éó„É≠„É≥„Éó„Éà„Åã„Çâ„ÅØ„ÄÅ <code>look</code>„ÄÅ <code>inventory</code>„ÄÅ <code>take</code>„ÄÅ <code>use</code>„ÄÅ <code>north</code>„ÄÅ
<code>south</code>„ÄÅ <code>east</code>„ÄÅ <code>west</code>„Å™„Å©„ÅÆ„Ç≥„Éû„É≥„Éâ„ÇíÂÖ•Âäõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
<code>debug</code>„Ç≥„Éû„É≥„Éâ„ÇÇ„ÅÇ„Çä„ÄÅ<code>--debug</code>„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®
„Åç„Å´„ÅØ„ÄÅ„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíÂá∫Âäõ„Åô„Çã„ÅÆ„Å´‰Ωø„Åà„Åæ„Åô„ÄÇ</p>
<p>„Ç≤„Éº„É†„ÅØ2Ê¨°ÂÖÉ„ÅÆÁ¢ÅÁõ§„ÅÆÁõÆ„ÅÆ‰∏ä„ÅåËàûÂè∞„Åß„ÄÅ„Ç≥„Éû„É≥„Éâ <code>north</code>„ÄÅ <code>south</code>„ÄÅ
<code>east</code>„ÄÅ <code>west</code>„ÇíÁô∫Ë°å„Åô„Çã„Åì„Å®„Å´„Çà„Å£„Å¶„Éó„É¨„Ç§„É§„Éº„ÅåÁßªÂãï„Åó„Åæ„Åô„ÄÇ„Ç≤„Éº„É†„Å´
„ÅØ„Ç¢„Ç§„ÉÜ„É†„ÅÆÈõÜ„Åæ„Çä„Åå„ÅÇ„Çä„ÄÅ„Éó„É¨„Ç§„É§„Éº„ÅÆÊâÄÊåÅ„Ç¢„Ç§„ÉÜ„É†‰∏ÄË¶ß„ÇíË°®„Åó„Åü„Çä„ÄÅ„Ç≤„Éº
„É†Áõ§‰∏ä„ÅÆ„Åù„ÅÆ‰ΩçÁΩÆ„Å´„ÅÇ„Çã„Ç¢„Ç§„ÉÜ„É†„ÅÆ‰∏ÄË¶ß„ÇíË°®„Åô„ÅÆ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ <code>take</code>„Ç≥„Éû
„É≥„Éâ„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Éó„É¨„Ç§„É§„Éº„ÅÆ‰ΩçÁΩÆ„Å´„ÅÇ„Çã„Ç¢„Ç§„ÉÜ„É†„ÇíÊãæ„ÅÑ‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÂèÇËÄÉ„Åæ„Åß„Å´„ÄÅ„Åì„ÅÆ„Ç≤„Éº„É†„ÅÆ„Å≤„Å®ÈÄö„Çä„ÅÆÊµÅ„Çå„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre>
<p>„Åì„ÅÆ„Ç≤„Éº„É†„ÅØ„Å®„Å¶„ÇÇÂçòÁ¥î„Åß„Åô„Åå„ÄÅ„Åì„ÅÆÁ´†„ÅÆÁõÆÁöÑ„ÅØ <code>transformers</code>„Éë„ÉÉ„Ç±„Éº„Ç∏
„Çí‰ΩøÁî®„Åó„Å¶„Åì„ÅÆ„Çà„ÅÜ„Å™„Ç≤„Éº„É†„ÇíÁ¥†Êó©„ÅèÈñãÁô∫„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã„É©„Ç§„Éñ„É©„É™„ÇíÊßãÁØâ
„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<h2 id="state„É¢„Éä„Éâ"><a class="header" href="#state„É¢„Éä„Éâ">State„É¢„Éä„Éâ</a></h2>
<p><code>transformers</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Çã„ÅÑ„Åè„Å§„Åã„ÅÆ„É¢„Éä„Éâ„ÇíË¶ã„Çã„Åì„Å®„Åã„Çâ
Âßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>ÊúÄÂàù„ÅÆ‰æã„ÅØ<code>State</code>„É¢„Éä„Éâ„Åß„ÄÅ„Åì„Çå„ÅØÁ¥îÁ≤ã„Å™„Ç≥„Éº„Éâ„Åß<strong>Â§âÊõ¥ÂèØËÉΩÁä∂ÊÖã</strong>„Çí„É¢„Éá
„É´Âåñ„Åô„ÇãÊâãÊÆµ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ„Åô„Åß„Å´ <code>Effect</code>„É¢„Éä„Éâ„Å´„Çà„Å£„Å¶Êèê‰æõ„Åï„Çå„ÇãÂ§âÊõ¥
ÂèØËÉΩÁä∂ÊÖã„ÅÆÊâãÊ≥ï„Å´„Å§„ÅÑ„Å¶Ë¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ<code>State</code>„ÅØ„Åù„ÅÆ‰ª£Êõø„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p><code>State</code>ÂûãÊßãÁØâÂ≠ê„ÅØ„ÄÅÁä∂ÊÖã„ÅÆÂûã <code>s</code>„ÄÅ„Åä„Çà„Å≥Ëøî„ÇäÂÄ§„ÅÆÂûã <code>a</code>„Å®„ÅÑ„ÅÜ2Á®ÆÈ°û„ÅÆÂºïÊï∞
„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ„Äå<code>State</code>„É¢„Éä„Éâ„Äç„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´Ë™¨Êòé„ÅØ„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
<code>Monad</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØÂÆüÈöõ„Å´„ÅØ‰ªªÊÑè„ÅÆÂûã <code>s</code>„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>State s</code>ÂûãÊßãÁØâÂ≠ê„Å´ÂØæ„Åó„Å¶Êèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Control.Monad.State</code>„É¢„Ç∏„É•„Éº„É´„ÅØ‰ª•‰∏ã„ÅÆAPI„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">get     :: forall s.             State s s
gets    :: forall s. (s -&gt; a) -&gt; State s a
put     :: forall s. s        -&gt; State s Unit
modify  :: forall s. (s -&gt; s) -&gt; State s s
modify_ :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>„Å™„Åä„Åì„Åì„Åß„ÅØ„Åì„Çå„Çâ„ÅÆAPI„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØ<code>State</code>ÂûãÊßãÁØâÂ≠ê„Çí‰Ωø„Å£„Åü„ÄÅÂçòÁ¥îÂåñ„Åï„Çå
„ÅüÂΩ¢Âºè„ÅßË°®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÆüÈöõ„ÅÆAPI„ÅØÊú¨Á´†„ÅÆÂæå„Å´„ÅÇ„Çã„ÄåÂûã„ÇØ„É©„Çπ„ÄçÁØÄ„ÅßÊäº„Åï
„Åà„Çã<code>MonadState</code>„ÅåÈñ¢„Çè„Å£„Å¶„Åç„Åæ„Åô„ÄÇ„Åß„Åô„Åã„ÇâIDE„ÅÆ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„ÇÑPursuit„Åß
Áï∞„Å™„Çã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíË¶ã„Åü„Å®„Åó„Å¶„ÇÇÂøÉÈÖç„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ <code>State</code>„É¢„Éä„Éâ„ÅÆ‰Ωø„ÅÑ„Åã„Åü„ÅÆ„Å≤„Å®„Å§„Å®„Åó„Å¶„ÅØ„ÄÅÊï¥Êï∞„ÅÆÈÖç
Âàó‰∏≠„ÅÆÂÄ§„ÇíÁèæÂú®„ÅÆÁä∂ÊÖã„Å´Âä†„Åà„Çã„ÇÇ„ÅÆ„ÅåËÄÉ„Åà„Çâ„Çå„Åæ„Åô„ÄÇÁä∂ÊÖã„ÅÆÂûã<code>s</code>„Å®„Åó„Å¶
<code>Int</code>„ÇíÈÅ∏Êäû„Åó„ÄÅÈÖçÂàó„ÅÆËµ∞Êüª„Å´ <code>traverse_</code>„Çí‰Ωø„Å£„Å¶„ÄÅÈÖçÂàó„ÅÆË¶ÅÁ¥†„Åù„Çå„Åû„Çå„Å´
„Å§„ÅÑ„Å¶ <code>modify</code>„ÇíÂëº„Å≥Âá∫„Åô„Å®„ÄÅ„Åì„Çå„ÇíÂÆüÁèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class

sumArray :: Array Int -&gt; State Int Unit
sumArray = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre>
<p><code>Control.Monad.State</code>„É¢„Ç∏„É•„Éº„É´„ÅØ <code>State</code>„É¢„Éä„Éâ„Åß„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Åü„ÇÅ„ÅÆÊ¨°„ÅÆ3„Å§„ÅÆÈñ¢Êï∞„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">evalState :: forall s a. State s a -&gt; s -&gt; a
execState :: forall s a. State s a -&gt; s -&gt; s
runState  :: forall s a. State s a -&gt; s -&gt; Tuple a s
</code></pre>
<p>3„Å§„ÅÆÈñ¢Êï∞„ÅØ„Åù„Çå„Åû„ÇåÂûã<code>s</code>„ÅÆÂàùÊúüÁä∂ÊÖã„Å®Âûã<code>State s a</code>„ÅÆË®àÁÆó„ÇíÂºïÊï∞„Å´„Å®„Çä„Åæ
„Åô„ÄÇ <code>evalState</code>„ÅØËøî„ÇäÂÄ§„Å†„Åë„ÇíËøî„Åó„ÄÅ <code>execState</code>„ÅØÊúÄÁµÇÁöÑ„Å™Áä∂ÊÖã„Å†„Åë„ÇíËøî
„Åó„ÄÅ <code>runState</code>„ÅØ <code>Tuple a s</code>Âûã„ÅÆÂÄ§„Å®„Åó„Å¶Ë°®Áèæ„Åï„Çå„Åü‰∏°Êñπ„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>ÂÖà„Åª„Å©„ÅÆ <code>sumArray</code>Èñ¢Êï∞„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åô„Çã„Å®„ÄÅPSCi„Åß <code>execState</code>„Çí‰Ωø„ÅÜ
„Å®Ê¨°„ÅÆ„Çà„ÅÜ„Å´Ë§áÊï∞„ÅÆÈÖçÂàóÂÜÖ„ÅÆÊï∞Â≠ó„ÇíÂêàË®à„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :paste
‚Ä¶ execState (do
‚Ä¶   sumArray [1, 2, 3]
‚Ä¶   sumArray [4, 5]
‚Ä¶   sumArray [6]) 0
‚Ä¶ ^D
21
</code></pre>
<h2 id="ÊºîÁøí-34"><a class="header" href="#ÊºîÁøí-34">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ‰∏ä„ÅÆ‰æã„Åß„ÄÅ<code>execState</code>„Çí<code>runState</code>„ÇÑ<code>evalState</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Çã„Å®ÁµêÊûú„ÅØ„Å©„ÅÜ„Å™„Çã„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÊã¨Âºß„Åã„Çâ„Å™„ÇãÊñáÂ≠óÂàó„Å´„Å§„ÅÑ„Å¶„ÄÅÊ¨°„ÅÆ„ÅÑ„Åö„Çå„Åã„Åß„ÅÇ„Çå„Å∞<strong>Âπ≥Ë°°„Åó„Å¶
„ÅÑ„Çã</strong>„Å®„Åó„Åæ„Åô„ÄÇ1„Å§„ÅØ0ÂÄã‰ª•‰∏ä„ÅÆ„Çà„ÇäÁü≠„ÅÑÂπ≥Ë°°„Åó„ÅüÊñáÂ≠óÂàó„ÇíÈÄ£Áµê„Åó„Åü„ÇÇ„ÅÆ
„Åß„ÄÅ„ÇÇ„ÅÜ1„Å§„ÅØ„Çà„ÇäÁü≠„ÅÑÂπ≥Ë°°„Åó„ÅüÊñáÂ≠óÂàó„Çí‰∏ÄÂØæ„ÅÆÊã¨Âºß„ÅßÂõ≤„Çì„Å†„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<p><code>State</code>„É¢„Éä„Éâ„Å® <code>traverse_</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">testParens :: String -&gt; Boolean
</code></pre>
<p>„Åì„Çå„ÅØ <code>String</code>„ÅåÊã¨Âºß„ÅÆÂØæÂøú„ÅåÊ≠£„Åó„Åè‰ªò„Åë„Çâ„Çå„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„Çã
Èñ¢Êï∞„Åß„Åô„ÄÇË™ø„ÅπÊñπ„ÅØ„Åæ„Å†Èñâ„Åò„Çâ„Çå„Å¶„ÅÑ„Å™„ÅÑÈñãÊã¨Âºß„ÅÆÊï∞„ÇíÊääÊè°„Åó„Å¶„Åä„Åè„Åì„Å®
„Åß„Åô„ÄÇ„Åì„ÅÆÈñ¢Êï∞„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Âãï‰Ωú„Åó„Å™„Åè„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false
</code></pre>
<p><strong>„Éí„É≥„Éà</strong>ÔºöÂÖ•Âäõ„ÅÆÊñáÂ≠óÂàó„ÇíÊñáÂ≠ó„ÅÆÈÖçÂàó„Å´Â§âÊèõ„Åô„Çã„ÅÆ„Å´„ÄÅ
<code>Data.String.CodeUnits</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ <code>toCharArray</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Å®ËâØ„ÅÑ
„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
</ol>
<h2 id="reader„É¢„Éä„Éâ"><a class="header" href="#reader„É¢„Éä„Éâ">Reader„É¢„Éä„Éâ</a></h2>
<p><code>transformers</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÅØ <code>Reader</code>„Å®„ÅÑ„ÅÜ„É¢„Éä„Éâ„ÇÇÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„É¢„Éä„Éâ„ÅØÂ§ßÂüüÁöÑ„Å™Ë®≠ÂÆö„ÇíË™≠„ÅøÂèñ„ÇãÊ©üËÉΩ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ <code>State</code>„É¢„Éä„Éâ„Åå„Å≤
„Å®„Å§„ÅÆÂèØÂ§âÁä∂ÊÖã„ÇíË™≠„ÅøÊõ∏„Åç„Åô„ÇãÊ©üËÉΩ„ÇíÊèê‰æõ„Åô„Çã„ÅÆ„Å´ÂØæ„Åó„ÄÅ <code>Reader</code>„É¢„Éä„Éâ„ÅØ
„Å≤„Å®„Å§„ÅÆ„Éá„Éº„Çø„ÅÆË™≠„ÅøÂèñ„Çä„ÅÆÊ©üËÉΩ„Å†„Åë„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Reader</code>ÂûãÊßãÁØâÂ≠ê„ÅØ„ÄÅË®≠ÂÆö„ÅÆÂûã„ÇíË°®„ÅôÂûã <code>r</code>„ÄÅ„Åä„Çà„Å≥Êàª„ÇäÂÄ§„ÅÆÂûã <code>a</code>„ÅÆ2„Å§„ÅÆ
ÂûãÂºïÊï∞„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ</p>
<p><code>Contro.Monad.Reader</code>„É¢„Ç∏„É•„Éº„É´„ÅØ‰ª•‰∏ã„ÅÆAPI„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">ask   :: forall r. Reader r r
local :: forall r a. (r -&gt; r) -&gt; Reader r a -&gt; Reader r a
</code></pre>
<p><code>ask</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØÁèæÂú®„ÅÆË®≠ÂÆö„ÇíË™≠„ÅøÂèñ„Çã„Åü„ÇÅ„Å´‰Ωø„ÅÑ„ÄÅ <code>local</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ
Â§âÊõ¥„Åï„Çå„ÅüË®≠ÂÆö„ÅßË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅÊ®©Èôê„ÅßÂà∂Âæ°„Åï„Çå„Åü„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÈñãÁô∫„Åó„Å¶„Åä„Çä„ÄÅÁèæÂú®„ÅÆÂà©Áî®ËÄÖ
„ÅÆÊ®©Èôê„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰øùÊåÅ„Åô„Çã„ÅÆ„Å´ <code>Reader</code>„É¢„Éä„Éâ„Çí‰Ωø„ÅÑ„Åü„ÅÑ„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ
Âûã <code>r</code>„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å™API„ÇíÂÇô„Åà„ÅüÂûã <code>Permission</code>„Å®„Åó„Å¶ÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">hasPermission :: String -&gt; Permissions -&gt; Boolean
addPermission :: String -&gt; Permissions -&gt; Permissions
</code></pre>
<p>Âà©Áî®ËÄÖ„ÅåÁâπÂÆö„ÅÆÊ®©Èôê„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„Åã„ÇíÁ¢∫Ë™ç„Åó„Åü„ÅÑ„Å®„Åç„ÅØ„ÄÅ <code>ask</code>„Çí‰Ωø„Å£
„Å¶ÁèæÂú®„ÅÆÊ®©Èôê„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂèñÂæó„Åô„Çå„Å∞„ÅÑ„Å§„Åß„ÇÇË™ø„Åπ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åü„Å®
„Åà„Å∞„ÄÅÁÆ°ÁêÜËÄÖ„Å†„Åë„ÅåÊñ∞„Åó„ÅÑÂà©Áî®ËÄÖ„ÅÆ‰ΩúÊàê„ÇíË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Çã„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">createUser :: Reader Permissions (Maybe User)
createUser = do
  permissions &lt;- ask
  if hasPermission &quot;admin&quot; permissions
    then map Just newUser
    else pure Nothing
</code></pre>
<p><code>local</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„ÅÜ„Å®„ÄÅË®àÁÆó„ÅÆÂÆüË°å‰∏≠„Å´ <code>Permissions</code>„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí
Â§âÊõ¥„Åó„ÄÅ„É¶„Éº„Ç∂„Éº„ÅÆÊ®©Èôê„ÇíÊòáÊ†º„Åï„Åõ„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">runAsAdmin :: forall a. Reader Permissions a -&gt; Reader Permissions a
runAsAdmin = local (addPermission &quot;admin&quot;)
</code></pre>
<p>„Åì„ÅÜ„Åô„Çã„Å®„ÄÅÂà©Áî®ËÄÖ„Åå <code>admin</code>Ê®©Èôê„ÇíÊåÅ„Å£„Å¶„ÅÑ„Å™„Åã„Å£„ÅüÂ†¥Âêà„Åß„ÅÇ„Å£„Å¶„ÇÇ„ÄÅÊñ∞„Åó
„ÅÑÂà©Áî®ËÄÖ„Çí‰ΩúÊàê„Åô„ÇãÈñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre>
<p><code>Reader</code>„É¢„Éä„Éâ„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Å´„ÅØ„ÄÅÂ§ßÂüüÁöÑ„Å™Ë®≠ÂÆö„Çí‰∏é„Åà„Çã <code>runReader</code>Èñ¢
Êï∞„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">runReader :: forall r a. Reader r a -&gt; r -&gt; a
</code></pre>
<h2 id="ÊºîÁøí-35"><a class="header" href="#ÊºîÁøí-35">ÊºîÁøí</a></h2>
<p>‰ª•‰∏ã„ÅÆÊºîÁøí„Åß„ÅØ„ÄÅ <code>Reader</code>„É¢„Éä„Éâ„Çí‰Ωø„Å£„Å¶„ÄÅÂ≠ó‰∏ã„Åí„ÅÆ„Å§„ÅÑ„ÅüÊñáÊõ∏„ÇíÂá∫Âäõ„Åô„Çã
„Åü„ÇÅ„ÅÆÂ∞è„Åï„Å™„É©„Ç§„Éñ„É©„É™„Çí‰Ωú„Å£„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ„ÄåÂ§ßÂüüÁöÑ„Å™Ë®≠ÂÆö„Äç„ÅØ„ÄÅÁèæÂú®„ÅÆÂ≠ó‰∏ã
„Åí„ÅÆÊ∑±„Åï„ÇíÁ§∫„ÅôÊï∞„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Level = Int

type Doc = Reader Level String
</code></pre>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâÁèæÂú®„ÅÆÂ≠ó‰∏ã„Åí„ÅÆÊ∑±„Åï„ÅßÊñáÂ≠óÂàó„ÇíÂá∫Âäõ„Åô„ÇãÈñ¢Êï∞ <code>line</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï
„ÅÑ„ÄÇÈñ¢Êï∞„ÅØ‰ª•‰∏ã„ÅÆÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">line :: String -&gt; Doc
</code></pre>
<p><strong>„Éí„É≥„Éà</strong>ÔºöÁèæÂú®„ÅÆÂ≠ó‰∏ã„Åí„ÅÆÊ∑±„Åï„ÇíË™≠„ÅøÂèñ„Çã„Åü„ÇÅ„Å´„ÅØ <code>ask</code>Èñ¢Êï∞„Çí‰ΩøÁî®
„Åó„Åæ„Åô„ÄÇ<code>Data.Monoid</code>„ÅÆ<code>power</code>Èñ¢Êï∞„ÇÇÂΩπ„Å´Á´ã„Å§„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>local</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶Ê¨°„ÅÆÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">indent :: Doc -&gt; Doc
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„Ç≥„Éº„Éâ„Éñ„É≠„ÉÉ„ÇØ„ÅÆÂ≠ó‰∏ã„Åí„ÅÆÊ∑±„Åï„ÇíÂ§ß„Åç„Åè„Åó„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Data.Traversable</code>„ÅßÂÆöÁæ©„Åï„Çå„Åü <code>sequence</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊ¨°
„ÅÆÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">cat :: Array Doc -&gt; Doc
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÊñáÊõ∏„ÅÆÈõÜ„Åæ„Çä„ÇíÊîπË°å„ÅßÂå∫Âàá„Å£„Å¶ÈÄ£Áµê„Åó„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>runReader</code>Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶Ê¨°„ÅÆÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">render :: Doc -&gt; String
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÊñáÊõ∏„ÇíÊñáÂ≠óÂàó„Å®„Åó„Å¶Âá∫Âäõ„Åó„Åæ„Åô„ÄÇ</p>
</li>
</ol>
<p>„Åì„Çå„Åß„ÄÅ„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´‰Ωø„ÅÜ„Å®„ÄÅÁ∞°Âçò„Å™ÊñáÊõ∏„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç
„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">render $ cat
  [ line &quot;Here is some indented text:&quot;
  , indent $ cat
      [ line &quot;I am indented&quot;
      , line &quot;So am I&quot;
      , indent $ line &quot;I am even more indented&quot;
      ]
  ]
</code></pre>
<h2 id="writer„É¢„Éä„Éâ"><a class="header" href="#writer„É¢„Éä„Éâ">Writer„É¢„Éä„Éâ</a></h2>
<p><code>Writer</code>„É¢„Éä„Éâ„ÅØ„ÄÅË®àÁÆó„ÅÆËøî„ÇäÂÄ§„Å´Âä†„Åà„Å¶„ÄÅ„ÇÇ„ÅÜ„Å≤„Å®„Å§„ÅÆÂÄ§„ÇíÁ¥ØÁ©ç„Åó„Å¶„ÅÑ„ÅèÊ©ü
ËÉΩ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p>„Çà„Åè„ÅÇ„Çã‰Ωø„ÅÑÊñπ„Å®„Åó„Å¶„ÅØÂûã <code>String</code>„ÇÇ„Åó„Åè„ÅØ <code>Array String</code>„Åß„É≠„Ç∞„ÇíÁ¥ØÁ©ç„Åó
„Å¶„ÅÑ„Åè„Å®„ÅÑ„ÅÜ„ÇÇ„ÅÆ„Å™„Å©„Åå„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ <code>Writer</code>„É¢„Éä„Éâ„ÅØ„Åì„Çå„Çà„Çä„ÇÇ„Å£„Å®‰∏ÄËà¨
ÁöÑ„Å™„ÇÇ„ÅÆ„Åß„Åô„ÄÇ„Åì„Çå„ÅØÁ¥ØÁ©ç„Åô„Çã„ÅÆ„Å´‰ªªÊÑè„ÅÆ„É¢„Éé„Ç§„Éâ„ÅÆÂÄ§„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„ÄÅ
<code>Additive Int</code>„É¢„Éé„Ç§„Éâ„Çí‰Ωø„Å£„Å¶„ÄÅÂêàË®à„ÇíËøΩË∑°„ÅóÁ∂ö„Åë„Çã„ÅÆ„Å´‰Ωø„Å£„Åü„Çä„ÄÅ <code>Disj Boolean</code>„É¢„Éé„Ç§„Éâ„Çí‰Ωø„Å£„Å¶ÈÄî‰∏≠„ÅÆ <code>Boolean</code>ÂÄ§„ÅÆ„ÅÑ„Åö„Çå„Åã„ÅåÁúü„Åß„ÅÇ„Çã„Åã„Å©„ÅÜ„Åã
„ÇíËøΩË∑°„Åô„Çã„ÅÆ„Å´‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Writer</code>Âûã„ÅÆÊßãÁØâÂ≠ê„ÅØ„ÄÅ <code>Monoid</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅÇ„ÇãÂûã <code>w</code>„ÄÅ„Åä
„Çà„Å≥Ëøî„ÇäÂÄ§„ÅÆÂûã <code>a</code>„Å®„ÅÑ„ÅÜ2„Å§„ÅÆÂûãÂºïÊï∞„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ</p>
<p><code>Writer</code>„ÅÆAPI„ÅßÈáçË¶Å„Å™„ÅÆ„ÅØ <code>tell</code>Èñ¢Êï∞„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">tell :: forall w a. Monoid w =&gt; w -&gt; Writer w Unit
</code></pre>
<p><code>tell</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ„ÄÅ‰∏é„Åà„Çâ„Çå„ÅüÂÄ§„ÇíÁèæÂú®„ÅÆÁ¥ØÁ©çÁµêÊûú„Å´Âä†ÁÆó„Åó„Åæ„Åô„ÄÇ</p>
<p>‰æã„Å®„Åó„Å¶„ÄÅ <code>Array String</code>„É¢„Éé„Ç§„Éâ„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÊó¢Â≠ò„ÅÆÈñ¢Êï∞„Å´„É≠„Ç∞Ê©üËÉΩ„ÇíËøΩ
Âä†„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ<strong>ÊúÄÂ§ßÂÖ¨Á¥ÑÊï∞</strong>Èñ¢Êï∞„ÅÆ‰ª•Ââç„ÅÆÂÆüË£Ö„ÇíËÄÉ„Åà„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p><code>Writer (Array String) Int</code>„Å´Ëøî„ÇäÂÄ§„ÅÆÂûã„ÇíÂ§âÊõ¥„Åô„Çã„Åì„Å®„Åß„ÄÅ„Åì„ÅÆÈñ¢Êï∞„Å´„É≠„Ç∞Ê©üËÉΩ„ÇíËøΩÂä†„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Control.Monad.Writer
import Control.Monad.Writer.Class

gcdLog :: Int -&gt; Int -&gt; Writer (Array String) Int
</code></pre>
<p>ÂêÑÊâãÈ†Ü„Åß„ÅÆ2„Å§„ÅÆÂÖ•Âäõ„ÇíË®òÈå≤„Åô„Çã„Åü„ÇÅ„Å´„ÅØ„ÄÅÂ∞ë„ÅóÈñ¢Êï∞„ÇíÂ§âÊõ¥„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    gcdLog n 0 = pure n
    gcdLog 0 m = pure m
    gcdLog n m = do
      tell [&quot;gcdLog &quot; &lt;&gt; show n &lt;&gt; &quot; &quot; &lt;&gt; show m]
      if n &gt; m
        then gcdLog (n - m) m
        else gcdLog n (m - n)
</code></pre>
<p><code>Writer</code>„É¢„Éä„Éâ„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Å´„ÅØ„ÄÅ <code>execWriter</code>Èñ¢Êï∞„Å® <code>runWriter</code>Èñ¢Êï∞„ÅÆ„ÅÑ„Åö„Çå„Åã„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">execWriter :: forall w a. Writer w a -&gt; w
runWriter  :: forall w a. Writer w a -&gt; Tuple a w
</code></pre>
<p>„Å°„Çá„ÅÜ„Å© <code>State</code>„É¢„Éä„Éâ„ÅÆÂ†¥Âêà„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅ <code>execWriter</code>„ÅåÁ¥ØÁ©ç„Åï„Çå„Åü„É≠„Ç∞„Å†„Åë„ÇíËøî„Åô„ÅÆ„Å´ÂØæ„Åó„Å¶„ÄÅ
<code>runWriter</code>„ÅØÁ¥ØÁ©ç„Åï„Çå„Åü„É≠„Ç∞„Å®ÁµêÊûú„ÅÆ‰∏°Êñπ„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>PSCi„Åß‰øÆÊ≠£„Åï„Çå„ÅüÈñ¢Êï∞„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Control.Monad.Writer
&gt; import Control.Monad.Writer.Class

&gt; runWriter (gcdLog 21 15)
Tuple 3 [&quot;gcdLog 21 15&quot;,&quot;gcdLog 6 15&quot;,&quot;gcdLog 6 9&quot;,&quot;gcdLog 6 3&quot;,&quot;gcdLog 3 3&quot;]
</code></pre>
<h2 id="ÊºîÁøí-36"><a class="header" href="#ÊºîÁøí-36">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>Writer</code>„É¢„Éä„Éâ„Å® <code>monoid</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ <code>Additive Int</code>„É¢„Éé„Ç§„Éâ„Çí
‰Ωø„ÅÜ„Çà„ÅÜ„Å´„ÄÅ‰∏ä„ÅÆ <code>sumArray</code>Èñ¢Êï∞„ÇíÊõ∏„ÅçÊèõ„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<strong>„Ç≥„É©„ÉÉ„ÉÑÈñ¢Êï∞</strong>„ÅØ„ÄÅËá™ÁÑ∂Êï∞ <code>n</code>„ÅåÂÅ∂Êï∞„Å™„Çâ <code>n / 2</code>„ÄÅ <code>n</code>„ÅåÂ•áÊï∞„Å™
„Çâ <code>3 * n + 1</code>„Åß„ÅÇ„Çã„Å®ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åü„Å®„Åà„Å∞„ÄÅ <code>10</code>„ÅßÂßã„Åæ„Çã„Ç≥„É©„ÉÉ
„ÉÑÊï∞Âàó„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>„Ç≥„É©„ÉÉ„ÉÑÈñ¢Êï∞„ÅÆÊúâÈôêÂõû„ÅÆÈÅ©Áî®„ÇíÁπ∞„ÇäËøî„Åô„Å®„ÄÅ„Ç≥„É©„ÉÉ„ÉÑÊï∞Âàó„ÅØÂøÖ„ÅöÊúÄÁµÇÁöÑ
„Å´ <code>1</code>„Å´„Å™„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åå‰∫àÊÉ≥„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Êï∞Âàó„Åå <code>1</code>„Å´Âà∞ÈÅî„Åô„Çã„Åæ„Åß„Å´‰ΩïÂõû„ÅÆ„Ç≥„É©„ÉÉ„ÉÑÈñ¢Êï∞„ÅÆÈÅ©Áî®„ÅåÂøÖË¶Å„Åã„ÇíË®àÁÆó
„Åô„ÇãÂÜçÂ∏∞ÁöÑ„Å™Èñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><code>Writer</code>„É¢„Éä„Éâ„Çí‰ΩøÁî®„Åó„Å¶„Ç≥„É©„ÉÉ„ÉÑÈñ¢Êï∞„ÅÆ„Åù„Çå„Åû„Çå„ÅÆÈÅ©Áî®„ÅÆÁµåÈÅé„ÇíË®òÈå≤
„Åô„Çã„Çà„ÅÜ„Å´„ÄÅÈñ¢Êï∞„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="„É¢„Éä„ÉâÂ§âÊèõÂ≠ê"><a class="header" href="#„É¢„Éä„ÉâÂ§âÊèõÂ≠ê">„É¢„Éä„ÉâÂ§âÊèõÂ≠ê</a></h2>
<p>‰∏ä„ÅÆ3„Å§„ÅÆ„É¢„Éä„Éâ„ÄÅ <code>State</code>„ÄÅ <code>Reader</code>„ÄÅ <code>Writer</code>„ÅØ„ÄÅ„ÅÑ„Åö„Çå„ÇÇ„ÅÑ„Çè„ÇÜ„Çã
<strong>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê</strong>Ôºàmonad transformersÔºâ„ÅÆ‰æã„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇÂØæÂøú„Åô„Çã„É¢„Éä„ÉâÂ§â
ÊèõÂ≠ê„ÅØ„Åù„Çå„Åû„Çå <code>StateT</code>„ÄÅ <code>ReaderT</code>„ÄÅ <code>WriterT</code>„Å®Âëº„Å∞„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Å®„ÅØ‰Ωï„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ„Åï„Å¶„ÄÅ„Åì„Çå„Åæ„ÅßË¶ã„Å¶„Åç„Åü„Çà„ÅÜ„Å´„ÄÅ„É¢„Éä„Éâ„ÅØ
PureScript„ÅÆ„Ç≥„Éº„Éâ„Çí‰Ωï„Çâ„Åã„ÅÆÁ®ÆÈ°û„ÅÆÂâØ‰ΩúÁî®„ÅßÊã°Âºµ„Åô„Çã„ÇÇ„ÅÆ„Åß„Åó„Åü„ÄÇ„Åì„ÅÆ„É¢„Éä
„Éâ„ÅØPureScript„ÅßÈÅ©Âàá„Å™„Éè„É≥„Éâ„É©Ôºà<code>runState</code>„ÄÅ <code>runReader</code>„ÄÅ
<code>runWriter</code>„Å™„Å©Ôºâ„Çí‰Ωø„Å£„Å¶Ëß£Èáà„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ‰ΩøÁî®„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„ÇãÂâØ
‰ΩúÁî®„Åå<strong>„Å≤„Å®„Å§„Å†„Åë</strong>„Å™„Çâ„ÄÅ„Åì„Çå„ÅßÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Åó„Åã„Åó„ÄÅÂêåÊôÇ„Å´Ë§áÊï∞„ÅÆÂâØ
‰ΩúÁî®„Çí‰ΩøÁî®„Åß„Åç„Çã„Å®‰æøÂà©„Å™„Åì„Å®„Åå„Çà„Åè„ÅÇ„Çä„Åæ„Åô„ÄÇ‰æã„Åà„Å∞„ÄÅ <code>Maybe</code>„Å®
<code>Reader</code>„Çí‰∏ÄÁ∑í„Å´‰ΩøÁî®„Åô„Çã„Å®„ÄÅ„ÅÇ„ÇãÂ§ßÂüüÁöÑ„Å™Ë®≠ÂÆö„ÅÆÊñáËÑà„Åß<strong>ÁúÅÁï•ÂèØËÉΩ„Å™ÁµêÊûú</strong>
„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„ÇÇ„Åó„Åè„ÅØ„ÄÅ <code>Either</code>„É¢„Éä„Éâ„ÅÆÁ¥îÁ≤ã„Å™„Ç®„É©„ÉºËøΩË∑°
Ê©üËÉΩ„Å®„ÄÅ <code>State</code>„É¢„Éä„Éâ„ÅåÊèê‰æõ„Åô„ÇãÂ§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„ÅåÂêåÊôÇ„Å´Ê¨≤„Åó„Åè„Å™„Çã„Åã„ÇÇ„Åó
„Çå„Åæ„Åõ„Çì„ÄÇ„Åì„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åô„Çã„ÅÆ„Åå<strong>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê</strong>„Åß„Åô„ÄÇ</p>
<p>„Åü„Å†„Åó<code>Effect</code>„É¢„Éä„Éâ„Åå„Åì„ÅÆÂïèÈ°å„Å´ÂØæ„Åô„ÇãÈÉ®ÂàÜÁöÑ„Å™Ëß£Ê±∫Á≠ñ„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åü„Åì„Å®
„ÅØÊó¢„Å´Ë¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅØ„Åæ„ÅüÁï∞„Å™„Å£„ÅüËß£Ê±∫Á≠ñ„ÇíÊèê‰æõ„Åó„Åæ„Åô„Åå„ÄÅ„Åì
„Çå„Çâ„ÅÆÊâãÊ≥ï„Å´„ÅØ„Åù„Çå„Åû„ÇåÂà©ÁÇπ„Å®ÈôêÁïå„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅØÂûã„Å†„Åë„Åß„Å™„ÅèÂà•„ÅÆÂûãÊßãÁØâÂ≠ê„ÇÇ„Éë„É©„É°„Éº„Çø„Å´Âèñ„ÇãÂûãÊßãÁØâÂ≠ê„Åß„Åô„ÄÇ
„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅØ„É¢„Éä„Éâ„Çí„Å≤„Å®„Å§Âèñ„Çä„ÄÅÁã¨Ëá™„ÅÆ„ÅÑ„Çç„ÅÑ„Çç„Å™ÂâØ‰ΩúÁî®„ÇíËøΩÂä†„Åó„ÅüÂà•„ÅÆ
„É¢„Éä„Éâ„Å∏„Å®Â§âÊèõ„Åó„Åæ„Åô„ÄÇ</p>
<p>‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ<code>State</code>„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠êÁâà„ÅØ
<code>Control.Monad.State.Trans</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã<code>StateT</code>„Åß„Åô„ÄÇ
PSCi„Çí‰Ωø„Å£„Å¶ <code>StateT</code>„ÅÆÁ®Æ„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; import Control.Monad.State.Trans
&gt; :kind StateT
Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>„Å®„Å¶„ÇÇË™≠„Åø„Å´„Åè„Åù„ÅÜ„Å´ÊÄù„ÅÜ„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åå„ÄÅ‰Ωø„ÅÑÊñπ„ÇíÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ
<code>StateT</code>„Å´„Å≤„Å®„Å§ÂºïÊï∞„Çí‰∏é„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>State</code>„ÅÆÂ†¥Âêà„ÄÅÊúÄÂàù„ÅÆÂûãÂºïÊï∞„ÅØ‰Ωø„ÅÑ„Åü„ÅÑÁä∂ÊÖã„ÅÆÂûã„Åß„Åô„ÄÇ„Åù„Çå„Åß„ÅØÂûã
<code>String</code>„Çí‰∏é„Åà„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; :kind StateT String
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>Ê¨°„ÅÆÂºïÊï∞„ÅØÁ®Æ <code>Type -&gt; Type</code>„ÅÆÂûãÊßãÁØâÂ≠ê„Åß„Åô„ÄÇ„Åì„Çå„ÅØ <code>StateT</code>„ÅÆÊ©üËÉΩ„ÇíËøΩÂä†
„Åó„Åü„ÅÑÂÖÉ„ÅÆ„É¢„Éä„Éâ„ÇíË°®„Åó„Åæ„Åô„ÄÇ‰æã„Å®„Åó„Å¶„ÄÅ <code>Either String</code>„É¢„Éä„Éâ„ÇíÈÅ∏„Çì„Åß„Åø
„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String)
Type -&gt; Type
</code></pre>
<p>ÂûãÊßãÁØâÂ≠ê„ÅåÊÆã„Çä„Åæ„Åó„Åü„ÄÇÊúÄÂæå„ÅÆÂºïÊï∞„ÅØÊàª„ÇäÂÄ§„ÅÆÂûã„ÇíË°®„Åó„Å¶„Åä„Çä„ÄÅ„Åü„Å®„Åà„Å∞„Åù„Çå
„Çí <code>Number</code>„Å´„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String) Number
Type
</code></pre>
<p>ÊúÄÂæå„Å´„ÄÅÁ®Æ <code>Type</code>„ÅÆ‰Ωï„Åã„ÅåÊÆã„Çä„Åæ„Åó„Åü„Åå„ÄÅ„Åì„Çå„ÅØ„Å§„Åæ„Çä„Åì„ÅÆÂûã„ÅÆÂÄ§„ÇíÊé¢„Åó„Å¶
„Åø„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ</p>
<p>ÊßãÁØâ„Åó„Åü„É¢„Éä„Éâ <code>StateT String (Either String)</code>„ÅØ„ÄÅ„Ç®„É©„Éº„ÅßÂ§±Êïó„Åô„ÇãÂèØËÉΩ
ÊÄß„Åå„ÅÇ„Çä„ÄÅÂ§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„Çí‰Ωø„Åà„ÇãË®àÁÆó„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Â§ñÂÅ¥„ÅÆ <code>StateT String (Either String)</code>„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥Ôºà<code>get</code>„ÄÅ<code>put</code>„ÄÅ<code>modify</code>Ôºâ„ÅØÁõ¥Êé•‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„Åå„ÄÅ„É©„ÉÉ„Éó„Åï„Çå„Å¶„ÅÑ„ÇãÂÜÖÂÅ¥„ÅÆ„É¢„Éä„Éâ (<code>Either String</code>)
„ÅÆ‰ΩúÁî®„Çí‰Ωø„ÅÜ„Åü„ÇÅ„Å´„ÅØ„ÄÅ„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„Çí„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Åæ„Åß„ÄåÊåÅ„Å°‰∏ä„Åí„Äç„Å™„Åè„Å¶„ÅØ„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ<code>Control.MonadTrans</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„ÄÅ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™ÂûãÊßãÁØâÂ≠ê„ÇíÊçïÊçâ„Åô„Çã<code>MonadTrans</code>Âûã„ÇØ„É©„Çπ„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>„Åì„ÅÆ„ÇØ„É©„Çπ„ÅØ„ÄÅÂü∫Á§é„Å®„Å™„Çã‰ªªÊÑè„ÅÆ„É¢„Éä„Éâ <code>m</code>„ÅÆË®àÁÆó„Çí„Å®„Çä„ÄÅ„Åù„Çå„Çí„É©„ÉÉ„Éó„Åï„Çå
„Åü„É¢„Éä„Éâ <code>t m</code>„Å∏„Å®ÊåÅ„Å°‰∏ä„Åí„Çã„ÄÅ <code>lift</code>„Å®„ÅÑ„ÅÜ„Å≤„Å®„Å§„ÅÆÈñ¢Êï∞„Å†„Åë„ÇíÊåÅ„Å£„Å¶„ÅÑ
„Åæ„Åô„ÄÇ‰ªäÂõû„ÅÆÂ†¥Âêà„ÄÅÂûãÊßãÁØâÂ≠ê <code>t</code>„ÅØ <code>StateT String</code>„Åß„ÄÅ <code>m</code>„ÅØ <code>Either String</code>„É¢„Éä„Éâ„Å®„Å™„Çä„ÄÅ <code>lift</code>„ÅØÂûã <code>Either String a</code>„ÅÆË®àÁÆó„Çí„ÄÅÂûã <code>State String (Either String) a</code>„ÅÆË®àÁÆó„Å∏„Å®ÊåÅ„Å°‰∏ä„Åí„ÇãÊñπÊ≥ï„ÇíÊèê‰æõ„Åô„Çã„Åì„Å®„Å´„Å™„Çä
„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅÂûã <code>Either String a</code>„ÅÆË®àÁÆó„Çí‰Ωø„ÅÜ„Å®„Åç„ÅØ„ÄÅ <code>lift</code>„Çí‰Ωø„Åà„Å∞
„ÅÑ„Å§„Åß„ÇÇ‰ΩúÁî® <code>StateT String</code>„Å® <code>Either String</code>„Çí‰∏ÄÁ∑í„Å´‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Çã
„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅÊ¨°„ÅÆË®àÁÆó„ÅØ <code>StateT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅßÂ∞éÂÖ•„Åï„Çå„Å¶„ÅÑ„ÇãÁä∂ÊÖã„ÇíË™≠„ÅøËæº
„Åø„ÄÅÁä∂ÊÖã„ÅåÁ©∫„ÅÆÊñáÂ≠óÂàó„Åß„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Ç®„É©„Éº„ÇíÊäï„Åí„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Data.String (drop, take)

split :: StateT String (Either String) String
split = do
  s &lt;- get
  case s of
    &quot;&quot; -&gt; lift $ Left &quot;Empty string&quot;
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>Áä∂ÊÖã„ÅåÁ©∫„Åß„Å™„Åë„Çå„Å∞„ÄÅ„Åì„ÅÆË®àÁÆó„ÅØ <code>put</code>„Çí‰Ωø„Å£„Å¶Áä∂ÊÖã„Çí <code>drop 1 s</code>ÔºàÊúÄÂàù„ÅÆ
ÊñáÂ≠ó„ÇíÂèñ„ÇäÈô§„ÅÑ„Åü <code>s</code>Ôºâ„Å∏„Å®Êõ¥Êñ∞„Åó„ÄÅ <code>take 1 s</code>Ôºà<code>s</code>„ÅÆÊúÄÂàù„ÅÆÊñáÂ≠óÔºâ„ÇíËøî„Åó
„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØPSCi„Åß„Åì„Çå„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;
</code></pre>
<p>„Åì„Çå„ÅØ <code>StateT</code>„Çí‰Ωø„Çè„Å™„Åè„Å¶„ÇÇÂÆüË£Ö„Åß„Åç„Çã„ÅÆ„Åß„ÄÅ„Åï„Åª„Å©È©ö„Åè„Çà„ÅÜ„Å™„Åì„Å®„Åß„ÅØ
„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Åó„Åã„Åó„ÄÅ„É¢„Éä„Éâ„Å®„Åó„Å¶Êâ±„Å£„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅdoË®òÊ≥ï„ÇÑ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ
„Ç≥„É≥„Éì„Éç„Éº„Çø„Çí‰Ωø„Å£„Å¶„ÄÅÂ∞è„Åï„Å™Ë®àÁÆó„Åã„ÇâÂ§ß„Åç„Å™Ë®àÁÆó„ÇíÊßãÁØâ„Åó„Å¶„ÅÑ„Åè„Åì„Å®„Åå„Åß„Åç
„Åæ„Åô„ÄÇ‰æã„Åà„Å∞„ÄÅ2Âõû <code>split</code>„ÇíÈÅ©Áî®„Åô„Çã„Å®„ÄÅÊñáÂ≠óÂàó„Åã„ÇâÊúÄÂàù„ÅÆ2ÊñáÂ≠ó„ÇíË™≠„ÇÄ„Åì„Å®
„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; runStateT ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple &quot;te&quot; &quot;st&quot;))
</code></pre>
<p>‰ªñ„Å´„ÇÇ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊ≤¢Â±±Áî®ÊÑè„Åô„Çå„Å∞„ÄÅ <code>split</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„ÄÅÂü∫Êú¨ÁöÑ„Å™ÊßãÊñáËß£
Êûê„É©„Ç§„Éñ„É©„É™„ÇíÊßãÁØâ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åì„Çå„ÅØÂÆüÈöõ„Å´ <code>parsing</code>„É©„Ç§„Éñ„É©„É™
„ÅßÊé°Áî®„Åï„Çå„Å¶„ÅÑ„ÇãÊâãÊ≥ï„Åß„Åô„ÄÇ„Åì„Çå„Åå„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅÆÂäõ„Å™„ÅÆ„Åß„Åô„ÄÇÂøÖË¶Å„Å™ÂâØ‰ΩúÁî®
„ÇíÈÅ∏Êäû„Åó„Å¶„ÄÅdoË®òÊ≥ï„Å®„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Ç≥„É≥„Éì„Éç„Éº„Çø„ÅßË°®ÁèæÂäõ„ÇíÁ∂≠ÊåÅ„Åó„Å™„Åå„Çâ„ÄÅ
Êßò„ÄÖ„Å™ÂïèÈ°å„ÅÆ„Åü„ÇÅ„ÅÆÁâπÊ≥®„ÅÆ„É¢„Éä„Éâ„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<h2 id="exceptt„É¢„Éä„ÉâÂ§âÊèõÂ≠ê"><a class="header" href="#exceptt„É¢„Éä„ÉâÂ§âÊèõÂ≠ê">ExceptT„É¢„Éä„ÉâÂ§âÊèõÂ≠ê</a></h2>
<p><code>transformers</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÅØ„ÄÅ <code>Either e</code>„É¢„Éä„Éâ„Å´ÂØæÂøú„Åô„ÇãÂ§âÊèõÂ≠ê„Åß„ÅÇ„Çã
<code>ExceptT e</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÇÇÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„ÅØÊ¨°„ÅÆAPI„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class MonadError e m where
  throwError :: forall a. e -&gt; m a
  catchError :: forall a. m a -&gt; (e -&gt; m a) -&gt; m a

instance monadErrorExceptT :: Monad m =&gt; MonadError e (ExceptT e m)

runExceptT :: forall e m a. ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p><code>MonadError</code>„ÇØ„É©„Çπ„ÅØ <code>e</code>Âûã„ÅÆ„Ç®„É©„Éº„ÅÆ„Çπ„É≠„Éº„Å®„Ç≠„É£„ÉÉ„ÉÅ„Çí„Çµ„Éù„Éº„Éà„Åô„Çã„É¢„Éä
„Éâ„ÇíÂèñÂæó„Åó„ÄÅ <code>ExceptT e</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÊèê‰æõ„Åï„Çå„Åæ„Åô„ÄÇ
<code>Either e</code>„É¢„Éä„Éâ„ÅÆ <code>Left</code>„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅ <code>throwError</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØÂ§±Êïó„Çí
Á§∫„Åô„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ <code>catchError</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„ÅÜ„Å®„ÄÅ <code>throwError</code>„Åß
„Ç®„É©„Éº„ÅåÊäï„Åí„Çâ„Çå„Åü„ÅÇ„Å®„Åß„ÇÇÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p><code>runExceptT</code>„Éè„É≥„Éâ„É©„Çí‰Ωø„ÅÜ„Å®„ÄÅÂûã <code>ExceptT e m a</code>„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Åì„Å®„Åå
„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆAPI„ÅØ <code>exceptions</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆ <code>Exception</code>‰ΩúÁî®„Å´„Çà„Å£„Å¶Êèê‰æõ„Åï„Çå„Å¶„ÅÑ
„Çã„ÇÇ„ÅÆ„Å®‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åó„Åã„Åó„ÄÅ„ÅÑ„Åè„Å§„Åã„ÅÆÈáçË¶Å„Å™ÈÅï„ÅÑ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>Exception</code>„ÅåÂÆüÈöõ„ÅÆJavaScript„ÅÆ‰æãÂ§ñ„Çí‰Ωø„Å£„Å¶„ÅÑ„Çã„ÅÆ„Å´ÂØæ„Åó„Å¶<code>ExceptT</code>„É¢„Éá
„É´„ÅØ‰ª£Êï∞ÁöÑ„Éá„Éº„ÇøÂûã„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><code>Exception</code>‰ΩúÁî®„ÅåJavaScript„ÅÆ <code>Error</code>Âûã„Å®„ÅÑ„ÅÜ„Å≤„Å®„Å§‰æãÂ§ñ„ÅÆÂûã„Å†„Åë„ÇíÊâ±„ÅÜ
„ÅÆ„Å´ÂØæ„Åó„Å¶<code>ExceptT</code>„ÅØ<code>Error</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Å©„Çì„Å™Âûã„ÅÆ„Ç®„É©„Éº„Åß„ÇÇÊâ±„ÅÑ„Åæ„Åô„ÄÇ„Å§
„Åæ„Çä„ÄÅ <code>ExceptT</code>„Åß„ÅØÊñ∞„Åü„Å™„Ç®„É©„ÉºÂûã„ÇíËá™Áî±„Å´ÂÆöÁæ©„Åß„Åç„Åæ„Åô„ÄÇ</li>
</ul>
<p>Ë©¶„Åó„Å´ <code>ExceptT</code>„Çí‰Ωø„Å£„Å¶ <code>Writer</code>„É¢„Éä„Éâ„ÇíÂåÖ„Çì„Åß„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ„Åì„Åì„Åß„ÇÇ„É¢
„Éä„ÉâÂ§âÊèõÂ≠ê <code>ExceptT e</code>„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíËá™Áî±„Å´Áõ¥Êé•‰Ωø„ÅÜ„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„Åå„ÄÅ
<code>Writer</code>„É¢„Éä„Éâ„ÅÆË®àÁÆó„ÅØ <code>lift</code>„Çí‰Ωø„Å£„Å¶ÊåÅ„Å°„ÅÇ„Åí„Çã„Åπ„Åç„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Control.Monad.Except
import Control.Monad.Writer

writerAndExceptT :: ExceptT String (Writer (Array String)) String
writerAndExceptT = do
  lift $ tell [&quot;Before the error&quot;]
  _ &lt;- throwError &quot;Error!&quot;
  lift $ tell [&quot;After the error&quot;]
  pure &quot;Return value&quot;
</code></pre>
<p>PSCi„Åß„Åì„ÅÆÈñ¢Êï∞„ÇíË©¶„Åô„Å®„ÄÅ„É≠„Ç∞„ÅÆËìÑÁ©ç„Å®„Ç®„É©„Éº„ÅÆÈÄÅÂá∫„Å®„ÅÑ„ÅÜ2„Å§„ÅÆ‰ΩúÁî®„Åå„Å©„ÅÆ
„Çà„ÅÜ„Å´Áõ∏‰∫í‰ΩúÁî®„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åã„ÇíË¶ã„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åæ„Åö„ÄÅ <code>runExceptT</code>„Çí
‰Ωø„Å£„Å¶Â§ñÂÅ¥„ÅÆ <code>ExceptT</code>Ë®àÁÆó„ÇíÂÆüË°å„Åó„ÄÅÂûã <code>Writer (Array String) (Either String String)</code>„ÅÆÁµêÊûú„ÇíÊÆã„Åó„Åæ„Åô„ÄÇ„Åù„Çå„Åã„Çâ„ÄÅ <code>runWriter</code>„ÅßÂÜÖÂÅ¥„ÅÆ
<code>Writer</code>Ë®àÁÆó„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; runWriter $ runExceptT writerAndExceptT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]
</code></pre>
<p>ÂÆüÈöõ„Å´ËøΩÂä†„Åï„Çå„Çã„É≠„Ç∞„ÅØ„ÄÅ„Ç®„É©„Éº„ÅåÊäï„Åí„Çâ„Çå„ÇãÂâç„Å´Êõ∏„Åã„Çå„Åü„É≠„Ç∞„É°„ÉÉ„Çª„Éº„Ç∏„Å†
„Åë„Åß„ÅÇ„Çã„Åì„Å®„Å´„ÇÇÊ≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ"><a class="header" href="#„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ">„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ</a></h2>
<p>„Åì„Çå„Åæ„ÅßË¶ã„Å¶„Åç„Åü„Çà„ÅÜ„Å´„ÄÅ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çí‰Ωø„ÅÜ„Å®Êó¢Â≠ò„ÅÆ„É¢„Éä„Éâ„ÅÆ‰∏ä„Å´Êñ∞„Åó„ÅÑ„É¢
„Éä„Éâ„ÇíÊßãÁØâ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ‰ªªÊÑè„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê <code>t1</code>„Å®‰ªªÊÑè„ÅÆ„É¢„Éä„Éâ
<code>m</code>„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åù„ÅÆÈÅ©Áî® <code>t1 m</code>„ÇÇ„Åæ„Åü„É¢„Éä„Éâ„Å´„Å™„Çä„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ<strong>2„Å§„ÇÅ„ÅÆ</strong>
„É¢„Éä„ÉâÂ§âÊèõÂ≠ê <code>t2</code>„ÇíÂÖà„Åª„Å©„ÅÆÁµêÊûú <code>t1 m</code>„Å´ÈÅ©Áî®„Åô„Çã„Å®„ÄÅ3„Å§ÁõÆ„ÅÆ„É¢„Éä„Éâ <code>t2 (t1 m)</code>„Çí‰Ωú„Çå„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ„Çà„ÅÜ„Å´„ÄÅÊßãÊàê„Åô„Çã„É¢„Éä„Éâ„Å´„Çà„Å£
„Å¶Êèê‰æõ„Åï„Çå„ÅüÂâØ‰ΩúÁî®„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„ÄÅ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅÆ<strong>„Çπ„Çø„ÉÉ„ÇØ</strong>„ÇíÊßãÁØâ„Åô„Çã
„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÂÆüÈöõ„Å´„ÅØ„ÄÅÂü∫Êú¨„Å®„Å™„Çã„É¢„Éä„Éâ <code>m</code>„ÅØ„ÄÅ„Éç„Ç§„ÉÜ„Ç£„Éñ„ÅÆÂâØ‰ΩúÁî®„ÅåÂøÖË¶Å„Å™„Çâ
<code>Effect</code>„É¢„Éä„Éâ„ÄÅ„Åï„ÇÇ„Å™„Åè„Å∞ <code>Data.Identity</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã
<code>Identity</code>„É¢„Éä„Éâ„Å´„Å™„Çä„Åæ„Åô„ÄÇ <code>Identity</code>„É¢„Éä„Éâ„ÅØ‰Ωï„ÅÆÊñ∞„Åó„ÅÑÂâØ‰ΩúÁî®„ÇÇËøΩÂä†
„Åó„Åæ„Åõ„Çì„Åã„Çâ„ÄÅ <code>Identity</code>„É¢„Éä„Éâ„ÅÆÂ§âÊèõ„ÅØ„ÄÅ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅÆ‰ΩúÁî®„Å†„Åë„ÇíÊèê‰æõ
„Åó„Åæ„Åô„ÄÇÂÆüÈöõ„Å´„ÄÅ <code>State</code>„É¢„Éä„Éâ„ÄÅ <code>Reader</code>„É¢„Éä„Éâ„ÄÅ <code>Writer</code>„É¢„Éä„Éâ„ÅØ„ÄÅ
<code>Identity</code>„É¢„Éä„Éâ„Çí„Åù„Çå„Åû„Çå <code>StateT</code>„ÄÅ <code>ReaderT</code>„ÄÅ <code>WriterT</code>„ÅßÂ§âÊèõ„Åô„Çã
„Åì„Å®„Å´„Çà„Å£„Å¶ÂÆüË£Ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØ3„Å§„ÅÆÂâØ‰ΩúÁî®„ÅåÁµÑ„ÅøÂêà„Çè„Åï„Çå„Å¶„ÅÑ„Çã‰æã„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>Identity</code>„É¢„Éä„Éâ„Çí„Çπ„Çø„ÉÉ„ÇØ„ÅÆÂ∫ï„Å´„Åó„Å¶„ÄÅ <code>StateT</code>‰ΩúÁî®„ÄÅ <code>WriterT</code>‰ΩúÁî®„ÄÅ
<code>ExceptT</code>‰ΩúÁî®„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ„ÅØ„ÄÅÂèØÂ§âÁä∂ÊÖã„ÄÅ„É≠„Ç∞„ÅÆ
ËìÑÁ©ç„ÄÅ„Åù„Åó„Å¶Á¥îÁ≤ã„Å™„Ç®„É©„Éº„ÅÆÂâØ‰ΩúÁî®„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ„Çí‰Ωø„ÅÜ„Å®„ÄÅ„É≠„ÇÆ„É≥„Ç∞„ÅÆÊ©üËÉΩ„ÅåËøΩÂä†„Åï„Çå„Åü <code>split</code>„Ç¢
„ÇØ„Ç∑„Éß„É≥„ÇíÂÜçÁèæ„Åï„Åõ„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Errors = Array String

type Log = Array String

type Parser = StateT String (WriterT Log (ExceptT Errors Identity))

split :: Parser String
split = do
  s &lt;- get
  lift $ tell [&quot;The state is &quot; &lt;&gt; s]
  case s of
    &quot;&quot; -&gt; lift $ lift $ throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>„Åì„ÅÆË®àÁÆó„ÇíPSCi„ÅßË©¶„Åó„Å¶„Åø„Çã„Å®„ÄÅ <code>split</code>„ÅåÂÆüË°å„Åï„Çå„Çã„Åü„Å≥„Å´Áä∂ÊÖã„Åå„É≠„Ç∞„Å´ËøΩ
Âä†„Åï„Çå„Çã„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<p>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ„Å´Áèæ„Çå„ÇãÈ†ÜÂ∫è„Å´Âæì„Å£„Å¶„ÄÅÂâØ‰ΩúÁî®„ÇíÂèñ„ÇäÈô§„ÅÑ„Å¶„ÅÑ„Åã„Å™„Åë„Çå
„Å∞„Å™„Çâ„Å™„ÅÑ„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊúÄÂàù„Å´ <code>StateT</code>ÂûãÊßãÁØâÂ≠ê„ÇíÂèñ„ÇäÈô§„Åè„Åü
„ÇÅ„Å´ <code>runStateT</code>„Çí‰Ωø„ÅÑ„ÄÅ„Åù„Çå„Åã„Çâ <code>runtWriteT</code>„Çí‰Ωø„ÅÑ„ÄÅ„Åù„ÅÆÂæå
<code>runExceptT</code>„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇÊúÄÂæå„Å´ <code>unwrap</code>„Çí‰ΩøÁî®„Åó„Å¶ <code>Identity</code>„É¢„Éä„Éâ„ÅÆÊºî
ÁÆó„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
(Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;]))

&gt; runParser ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;]))
</code></pre>
<p>„Åó„Åã„Åó„Å™„Åå„ÇâÁä∂ÊÖã„ÅåÁ©∫„Åß„ÅÇ„Çã„Åì„Å®„ÅåÁêÜÁî±„ÅßËß£Êûê„ÅåÂ§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØ„ÄÅ„É≠„Ç∞„ÅØ„Åæ„Å£
„Åü„ÅèÂá∫Âäõ„Åï„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">&gt; runParser split &quot;&quot;
(Left [&quot;Empty string&quot;])
</code></pre>
<p>„Åì„Çå„ÅØ„ÄÅ <code>ExceptT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅåÊèê‰æõ„Åô„ÇãÂâØ‰ΩúÁî®„Åå„ÄÅ <code>WriterT</code>„É¢„Éä„ÉâÂ§âÊèõ
Â≠ê„ÅåÊèê‰æõ„Åô„ÇãÂâØ‰ΩúÁî®„Å®Âπ≤Ê∏â„Åô„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ„Åì„Çå„ÅØ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ„ÅåÊßãÊàê
„Åï„Çå„Å¶„ÅÑ„ÇãÈ†ÜÂ∫è„ÇíÂ§âÊõ¥„Åô„Çã„Åì„Å®„ÅßËß£Ê±∫„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Çπ„Çø„ÉÉ„ÇØ„ÅÆÊúÄ‰∏äÈÉ®
„Å´ <code>ExceptT</code>Â§âÊèõÂ≠ê„ÇíÁßªÂãï„Åô„Çã„Å®„ÄÅÂÖà„Åª„Å© <code>Writer</code>„Çí <code>ExceptT</code>„Å´Â§âÊèõ„Åó„Åü
„Å®„Åç„Å®Âêå„Åò„Çà„ÅÜ„Å´„ÄÅÊúÄÂàù„ÅÆ„Ç®„É©„Éº„Åæ„Åß„Å´Êõ∏„Åã„Çå„Åü„Åô„Åπ„Å¶„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅåÂê´„Åæ„Çå
„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅÆÂïèÈ°å„ÅÆ„Å≤„Å®„Å§„ÅØ„ÄÅË§áÊï∞„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅÆ‰∏ä„Åæ„ÅßË®àÁÆó„ÇíÊåÅ„Å°‰∏ä„Åí„Çã
„Åü„ÇÅ„Å´„ÄÅ <code>lift</code>Èñ¢Êï∞„ÇíË§áÊï∞Âõû‰Ωø„Çè„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ„Åü„Å®„Åà
„Å∞„ÄÅ <code>throwError</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÅØ„ÄÅ1ÂõûÁõÆ„ÅØ <code>WriteT</code>„Å∏„ÄÅ2ÂõûÁõÆ„ÅØ <code>StateT</code>„Å∏
„Å®„ÄÅ2ÂõûÊåÅ„Å°„ÅÇ„Åí„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇÂ∞è„Åï„Å™„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ„Å™„Çâ„Å™„Çì
„Å®„Åã„Å™„Çä„Åæ„Åô„Åå„ÄÅ„Åù„ÅÆ„ÅÜ„Å°‰∏ç‰æø„Å†„Å®ÊÑü„Åò„Çã„Çà„ÅÜ„Å´„Å™„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>Âπ∏„ÅÑ„Å™„Åì„Å®„Å´„ÄÅ„Åì„Çå„Åã„ÇâË¶ã„Çã„Çà„ÅÜ„Å™Âûã„ÇØ„É©„ÇπÊé®Ë´ñ„Å´„Çà„Å£„Å¶Êèê‰æõ„Åï„Çå„Çã„Ç≥„Éº„Éâ„ÅÆ
Ëá™ÂãïÁîüÊàê„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Åª„Å®„Çì„Å©„ÅÆ„ÄåÈáçÂä¥ÂÉç„Äç„Çí‰ªª„Åõ„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-37"><a class="header" href="#ÊºîÁøí-37">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>Identity</code>Èñ¢Êâã„ÅÆ‰∏ä„ÅÆ <code>ExceptT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çí‰Ωø„Å£„Å¶„ÄÅÂàÜÊØç„Åå„Çº„É≠
„ÅÆÂ†¥Âêà„ÅØÔºàÊñáÂ≠óÂàó„ÄåDivide by zero!„Äç„ÅÆÔºâ„Ç®„É©„Éº„ÇíÊäï‚Äã‚Äã„Åí„Çã„ÄÅ2„Å§„ÅÆÊï∞„ÅÆÂïÜ„ÇíÊ±Ç
„ÇÅ„ÇãÈñ¢Êï∞ <code>safeDivide</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÊßãÊñáËß£ÊûêÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">string :: String -&gt; Parser String
</code></pre>
<p>„Åì„Çå„ÅØÁèæÂú®„ÅÆÁä∂ÊÖã„ÅåÊé•È†≠Ëæû„Å´ÈÅ©Âêà„Åô„Çã„Åã„ÄÅ„ÇÇ„Åó„Åè„ÅØ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Å®
„Å®„ÇÇ„Å´Â§±Êïó„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÊßãÊñáËß£ÊûêÂô®„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´Âãï‰Ωú„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;
(Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;]))
</code></pre>
<p><strong>„Éí„É≥„Éà</strong>ÔºöÂá∫Áô∫ÁÇπ„Å®„Åó„Å¶ <code>split</code>„ÅÆÂÆüË£Ö„Çí‰Ωø„ÅÜ„Å®„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ
<code>stripPrefix</code>Èñ¢Êï∞„ÇÇÂΩπ„Å´Á´ã„Å°„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ‰ª•Ââç <code>Reader</code>„É¢„Éä„Éâ„Çí‰ΩøÁî®„Åó„Å¶Êõ∏„ÅÑ„ÅüÊñáÊõ∏Ë°®Á§∫„É©„Ç§„Éñ„É©„É™„Çí„ÄÅ
<code>ReaderT</code>„Å® <code>WriterT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çí‰ΩøÁî®„Åó„Å¶ÂÜçÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>ÊñáÂ≠óÂàó„ÇíÂá∫Âäõ„Åô„Çã <code>line</code>„ÇÑÊñáÂ≠óÂàó„ÇíÈÄ£Áµê„Åô„Çã <code>cat</code>„Çí‰Ωø„ÅÜ„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ
<code>WriteT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Å®‰∏ÄÁ∑í„Å´ <code>Array String</code>„É¢„Éé„Ç§„Éâ„Çí‰Ωø„ÅÑ„ÄÅÁµêÊûú„Å∏
Ë°å„ÇíËøΩÂä†„Åô„Çã„ÅÆ„Å´ <code>tell</code>„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Ç¢„Éù„Çπ„Éà„É≠„Éï„Ç£ (<code>'</code>) „Åß
ÁµÇ„Çè„Çã‰ª•Â§ñ„ÅØÂÖÉ„ÅÆÂÆüË£Ö„Å®Âêå„ÅòÂêçÂâç„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="Âûã„ÇØ„É©„Çπ„ÅåÂä©„Åë„Å´Êù•„Åü„Åû"><a class="header" href="#Âûã„ÇØ„É©„Çπ„ÅåÂä©„Åë„Å´Êù•„Åü„Åû">Âûã„ÇØ„É©„Çπ„ÅåÂä©„Åë„Å´Êù•„Åü„ÅûÔºÅ</a></h2>
<p>Êú¨Á´†„ÅÆÊúÄÂàù„ÅßÊâ±„Å£„Åü <code>State</code>„É¢„Éä„Éâ„ÇíË¶ã„Å¶„Åø„Çã„Å®„ÄÅ <code>State</code>„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß
„É≥„Å´„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„Åå‰∏é„Åà„Çâ„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ</p>
<pre><code class="language-haskell">get    :: forall s.             State s s
put    :: forall s. s        -&gt; State s Unit
modify :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>„É¢„Ç∏„É•„Éº„É´„Åß‰∏é„Åà„Çâ„Çå„Å¶„ÅÑ„ÇãÂûã„ÅØ„ÄÅÂÆüÈöõ„Å´„ÅØ„Åì
„Çå„Çà„Çä„ÇÇ„Å£„Å®‰∏ÄËà¨ÁöÑ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">get    :: forall m s. MonadState s m =&gt;             m s
put    :: forall m s. MonadState s m =&gt; s        -&gt; m Unit
modify :: forall m s. MonadState s m =&gt; (s -&gt; s) -&gt; m Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ<code>MonadState</code>ÔºàÂ§öÂ§âÊï∞ÔºâÂûã„ÇØ„É©
„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆÂûã„ÇØ„É©„Çπ„ÅØ„ÄåÁ¥îÁ≤ã„Å™Â§âÊõ¥ÂèØËÉΩ„Å™Áä∂ÊÖã„ÇíÊèê‰æõ„Åô„Çã„É¢
„Éä„Éâ„Äç„Å∏„ÅÆÊäΩË±°Âåñ„ÇíÂèØËÉΩ„Å´„Åó„Åæ„Åô„ÄÇ‰∫àÊÉ≥„Åß„Åç„Çã„Å®ÊÄù„ÅÑ„Åæ„Åô„Åå„ÄÅ <code>State s</code>ÂûãÊßã
ÁØâÂ≠ê„ÅØ <code>MonadState s</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å´„Å™„Å£„Å¶„Åä„Çä„ÄÅ„Åì„ÅÆ„ÇØ„É©„Çπ„Å´
„ÅØ‰ªñ„Å´„ÇÇËààÂë≥Ê∑±„ÅÑ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÊï∞Â§ö„Åè„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>Áâπ„Å´„ÄÅ <code>transformers</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÅØ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê <code>WriterT</code>„ÄÅ <code>ReaderT</code>„ÄÅ
<code>ExceptT</code>„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>MonadState</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÈÄöÂ∫ï
„Åô„Çã<code>Monad</code>„Åå<code>MonadState</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çå„Å∞Â∏∏„Å´„ÄÅ„Åì„Çå„Çâ„ÅÆ„É¢„Éä
„ÉâÂ§âÊèõÂ≠ê„Å´„ÇÇ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂÆüË∑µÁöÑ„Å´„ÅØ„ÄÅ <code>StateT</code>„Åå„É¢„Éä„ÉâÂ§âÊèõ
Â≠ê„Çπ„Çø„ÉÉ„ÇØ„ÅÆ<strong>„Å©„Åì„Åã</strong>„Å´Áèæ„Çå„ÄÅ <code>StateT</code>„Çà„Çä‰∏ä„ÅÆ„Åô„Åπ„Å¶„Åå <code>MonadState</code>„ÅÆ
„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅÇ„Çå„Å∞„ÄÅ <code>get</code>„ÄÅ <code>put</code>„ÄÅ <code>modify</code>„ÇíÁõ¥Êé•Ëá™Áî±„Å´‰ΩøÁî®„Åô„Çã„Åì
„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÂΩìÁÑ∂„Åß„Åô„Åå„ÄÅ„Åì„Çå„Åæ„ÅßÊâ±„Å£„Å¶„Åç„Åü <code>ReaderT</code>„ÄÅ <code>WriterT</code>„ÄÅ <code>ExceptT</code>Â§âÊèõÂ≠ê
„Å´„Å§„ÅÑ„Å¶„ÇÇ„ÄÅÂêå„Åò„Åì„Å®„ÅåÊàê„ÇäÁ´ã„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ<code>transformers</code>„Åß„ÅØ‰∏ª„Å™Â§âÊèõÂ≠ê„Åù
„Çå„Åû„Çå„Å´„Å§„ÅÑ„Å¶„ÅÆÂûã„ÇØ„É©„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Çà„Çä„Åù„Çå„Çâ„ÅÆÊìç‰Ωú„Å´ÂØæ
Âøú„Åô„Çã„É¢„Éä„Éâ„ÅÆ‰∏ä„Å´ÊäΩË±°Âåñ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>‰∏ä„ÅÆ <code>split</code>Èñ¢Êï∞„ÅÆÂ†¥Âêà„ÄÅÊßãÁØâ„Åï„Çå„Åü„Åì„ÅÆ„É¢„Éä„Éâ„Çπ„Çø„ÉÉ„ÇØ„ÅØÂûã„ÇØ„É©„Çπ
<code>MonadState</code>„ÄÅ <code>MonadWriter</code>„ÄÅ <code>MonadError</code>„Åù„Çå„Åû„Çå„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„Åô„ÄÇ
„Åì„Çå„ÅØ„Å§„Åæ„Çä„ÄÅ <code>lift</code>„Çí„Åæ„Å£„Åü„ÅèÂëº„Å≥Âá∫„ÅôÂøÖË¶Å„Åå„Å™„ÅÑ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„ÅôÔºÅ„Åæ
„Çã„Åß„É¢„Éä„Éâ„Çπ„Çø„ÉÉ„ÇØËá™‰Ωì„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åü„Åã„ÅÆ„Çà„ÅÜ„Å´„ÄÅ„Ç¢„ÇØ„Ç∑„Éß„É≥ <code>get</code>„ÄÅ
<code>put</code>„ÄÅ <code>tell</code>„ÄÅ <code>throwError</code>„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">split :: Parser String
split = do
  s &lt;- get
  tell [&quot;The state is &quot; &lt;&gt; show s]
  case s of
    &quot;&quot; -&gt; throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>„Åì„ÅÆË®àÁÆó„ÅØ„Åæ„Çã„Åß„ÄÅÂèØÂ§âÁä∂ÊÖã„ÄÅ„É≠„ÇÆ„É≥„Ç∞„ÄÅ„Ç®„É©„ÉºÂá¶ÁêÜ„Å®„ÅÑ„ÅÜ3„Å§„ÅÆÂâØ‰ΩúÁî®„Å´ÂØæÂøú„Åó„Åü„ÄÅÁã¨Ëá™„ÅÆ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„ÇíÊã°Âºµ„Åó„Åü„Åã„ÅÆ„Çà„ÅÜ„Å´„Åø„Åà„Åæ„Åô„ÄÇ„Åó„Åã„Åó„Å™„Åå„Çâ„ÄÅÂÜÖÈÉ®ÁöÑ„Å´„ÅØ„Åô„Åπ„Å¶„ÅØ„ÅÇ„Åè„Åæ„ÅßÁ¥îÁ≤ã„Å™Èñ¢Êï∞„Å®ÊôÆÈÄö„ÅÆ„Éá„Éº„Çø„Çí‰Ωø„Å£„Å¶ÂÆüË£Ö„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<h2 id="alternatives-1"><a class="header" href="#alternatives-1">Alternatives</a></h2>
<p><code>control</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÅØÂ§±Êïó„Åó„ÅÜ„ÇãË®àÁÆó„ÇíÊìç‰Ωú„Åô„Çã„Åü„ÇÅ„ÅÆÊäΩË±°Âåñ„Åå„ÅÑ„Åè„Å§„Åã
ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åù„ÅÆ„Å≤„Å®„Å§„ÅØ <code>Alternative</code>Âûã„ÇØ„É©„Çπ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<p><code>Alternative</code>„ÅØ2„Å§„ÅÆÊñ∞„Åó„ÅÑ„Ç≥„É≥„Éì„Éç„Éº„Çø„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ1„Å§„ÅØÂ§±Êïó„Åó„ÅÜ
„ÇãË®àÁÆó„ÅÆ„Éó„É≠„Éà„Çø„Ç§„Éó„ÇíÊèê‰æõ„Åô„Çã <code>empty</code>ÂÄ§„Åß„ÄÅ„ÇÇ„ÅÜ1„Å§„ÅØ„Ç®„É©„Éº„ÅåËµ∑„Åç„Åü„Å®
„Åç„Å´<strong>‰ª£Êõø</strong> (Alternative) Ë®àÁÆó„Å∏Êàª„Å£„Å¶„ÇÑ„ÇäÁõ¥„ÅôÊ©üËÉΩ„ÇíÊèê‰æõ„Åô„Çã<code>alt</code>Èñ¢Êï∞
Ôºà„Åù„Åó„Å¶„Åù„ÅÆÂà•Âêç<code>&lt;|&gt;</code>ÔºâÊºîÁÆóÂ≠ê„Åß„Åô„ÄÇ</p>
<p><code>Data.Array</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ <code>Alternative</code>Âûã„ÇØ„É©„Çπ„ÅßÂûãÊßãÁØâÂ≠ê„ÇíÊìç‰Ωú„Åô„Çã2
„Å§„ÅÆ‰æøÂà©„Å™Èñ¢Êï∞„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">many :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
some :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
</code></pre>
<p><code>Data.List</code>„Å´„ÇÇÁ≠â‰æ°„Å™<code>many</code>„Å®<code>some</code>„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p><code>many</code>„Ç≥„É≥„Éì„Éç„Éº„Çø„ÅØË®àÁÆó„Çí<strong>„Çº„É≠Âõû‰ª•‰∏ä</strong>Áπ∞„ÇäËøî„ÅóÂÆüË°å„Åô„Çã„Åü„ÇÅ„Å´
<code>Alternative</code>Âûã„ÇØ„É©„Çπ„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ <code>some</code>„Ç≥„É≥„Éì„Éç„Éº„Çø„ÇÇ‰ºº„Å¶„ÅÑ„Åæ„Åô
„Åå„ÄÅÊàêÂäü„Åô„Çã„Åü„ÇÅ„Å´Â∞ë„Å™„Åè„Å®„ÇÇ1Âõû„ÅÆË®àÁÆó„ÇíÂøÖË¶Å„Å®„Åó„Åæ„Åô„ÄÇ</p>
<p><code>Parser</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ„ÇØ„ÅÆÂ†¥Âêà„ÅØ„ÄÅ<code>ExceptT</code>„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Å´„Çà„Çã
<code>Alternative</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Åß„ÅØÁï∞„Å™„ÇãÂàÜ
Êûù„ÅÆ„Ç®„É©„Éº„Å´<code>Monoid</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰Ωø„Å£„Å¶ÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Åì„Å®„Å´„Çà„Å£„Å¶ÂØæÂøú„Åó
„Å¶„ÅÑ„Åæ„ÅôÔºà„Å†„Åã„Çâ<code>Errors</code>Âûã„Å´<code>Array String</code>„ÇíÈÅ∏„Å∂ÂøÖË¶Å„Åå„ÅÇ„Å£„Åü„Çì„Åß„Åô„Å≠Ôºâ„ÄÇ
„Åì„Çå„ÅØ„ÄÅÊßãÊñáËß£ÊûêÂô®„ÇíË§áÊï∞ÂõûÂÆüË°å„Åô„Çã„ÅÆ„Å´<code>many</code>Èñ¢Êï∞„Å®<code>some</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®
„Åå„Åß„Åç„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Data.Array (many)

&gt; runParser (many split) &quot;test&quot;
(Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;)
              [ &quot;The state is \&quot;test\&quot;&quot;
              , &quot;The state is \&quot;est\&quot;&quot;
              , &quot;The state is \&quot;st\&quot;&quot;
              , &quot;The state is \&quot;t\&quot;&quot;
              ]))
</code></pre>
<p>„Åì„Åì„Åß„ÅØÂÖ•ÂäõÊñáÂ≠óÂàó <code>&quot;test&quot;</code>„ÅØ„ÄÅ1ÊñáÂ≠ó„Åã„Çâ„Å™„ÇãÊñáÂ≠óÂàó4„Å§„ÅÆÈÖçÂàó„ÇíËøî„Åô„Çà„ÅÜ
„Å´Áπ∞„ÇäËøî„ÅóÂàÜÂâ≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÊÆã„Å£„ÅüÁä∂ÊÖã„ÅØÁ©∫„Åß„ÄÅ„É≠„Ç∞„ÅØ <code>split</code>„Ç≥„É≥„Éì„Éç„Éº
„Çø„Åå4ÂõûÈÅ©Áî®„Åï„Çå„Åü„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="„É¢„Éä„ÉâÂÜÖÂåÖË°®Ë®ò"><a class="header" href="#„É¢„Éä„ÉâÂÜÖÂåÖË°®Ë®ò">„É¢„Éä„ÉâÂÜÖÂåÖË°®Ë®ò</a></h2>
<p><code>Control.MonadPlus</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ <code>MonadPlus</code>„Å®Âëº„Å∞„Çå„Çã
<code>Alternative</code>Âûã„ÇØ„É©„Çπ„ÅÆÂâØ„ÇØ„É©„Çπ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ <code>MonadPlus</code>„ÅØ„É¢„Éä
„Éâ„Å®<code>Alternative</code>‰∏°Êñπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅÇ„ÇãÂûãÊßãÁØâÂ≠ê„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class (Monad m, Alternative m) &lt;= MonadPlus m
</code></pre>
<p>ÂÆüÈöõ„ÄÅ<code>Parser</code>„É¢„Éä„Éâ„ÅØ <code>MonadPlus</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„Åô„ÄÇ</p>
<p>‰ª•Ââç„Å´Êú¨Êõ∏‰∏≠„ÅßÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„ÇíÊâ±„Å£„Åü„Å®„Åç„ÄÅ‰∏çË¶Å„Å™ÁµêÊûú„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åô„Çã
„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Çã<code>guard</code>Èñ¢Êï∞„ÇíÂ∞éÂÖ•„Åó„Åæ„Åó„Åü„ÄÇÂÆüÈöõ„ÅØ <code>guard</code>Èñ¢Êï∞„ÅØ„ÇÇ„Å£„Å®‰∏Ä
Ëà¨ÁöÑ„Åß„ÄÅ <code>MonadPlus</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅÇ„Çã„Åô„Åπ„Å¶„ÅÆ„É¢„Éä„Éâ„Å´ÂØæ„Åó„Å¶‰Ωø„ÅÜ„Åì„Å®
„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">guard :: forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p><code>&lt;|&gt;</code>ÊºîÁÆóÂ≠ê„ÅØÂ§±ÊïóÊôÇ„ÅÆ„Éê„ÉÉ„ÇØ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞„Çí„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Åå„Å©
„ÅÆ„Çà„ÅÜ„Å´ÂΩπÁ´ã„Å§„Åã„ÇíË¶ã„Çã„Åü„ÇÅ„Å´„ÄÅÂ§ßÊñáÂ≠ó„Å†„Åë„Å´ÈÅ©Âêà„Åô„Çã <code>split</code>„Ç≥„É≥„Éì„Éç„Éº„Çø
„ÅÆ‰∫úÁ®Æ„ÇíÂÆöÁæ©„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">upper :: Parser String
upper = do
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre>
<p>„Åì„Åì„Åß„ÄÅÊñáÂ≠óÂàó„ÅåÂ§ßÊñáÂ≠ó„Åß„Å™„ÅÑÂ†¥Âêà„Å´Â§±Êïó„Åô„Çã„Çà„ÅÜ <code>guard</code>„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØÂâç„Å´Ë¶ã„ÅüÈÖçÂàóÂÜÖÂåÖË°®Ë®ò„Å®„Çà„Åè‰ºº„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆ„Çà„ÅÜ„Å´<code>MonadPlus</code>„Çí‰Ωø„ÅÜ„Åì„Å®„ÅØ„ÄÅ<strong>„É¢„Éä„ÉâÂÜÖÂåÖË°®Ë®ò</strong> (monad
comprehensions) „ÅÆÊßãÁØâ„Å®Âëº„Å∞„Çå„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<h2 id="„Éê„ÉÉ„ÇØ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞"><a class="header" href="#„Éê„ÉÉ„ÇØ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞">„Éê„ÉÉ„ÇØ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞</a></h2>
<p><code>&lt;|&gt;</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„ÅÜ„Å®„ÄÅÂ§±Êïó„Åó„Åü„Å®„Åç„Å´Âà•„ÅÆ‰ª£ÊõøË®àÁÆó„Å∏„Å®„Éê„ÉÉ„ÇØ„Éà„É©„ÉÉ„ÇØ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åì„Çå„ÇíÁ¢∫„Åã„ÇÅ„Çã„Åü„ÇÅ„Å´„ÄÅÂ∞èÊñáÂ≠ó„Å´‰∏ÄËá¥„Åô„Çã„ÇÇ„ÅÜ1„Å§„ÅÆÊßãÊñáËß£ÊûêÂô®„ÇíÂÆöÁæ©„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">lower :: Parser String
lower = do
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre>
<p>„Åì„Çå„Å´„Çà„Çä„ÄÅ„Åæ„Åö„ÇÇ„ÅóÊúÄÂàù„ÅÆÊñáÂ≠ó„ÅåÂ§ßÊñáÂ≠ó„Å™„ÇâË§áÊï∞„ÅÆÂ§ßÊñáÂ≠ó„Å´ÈÅ©Âêà„Åó„ÄÅ„Åï„ÇÇ„Å™
„Åè„Å∞„ÇÇ„ÅóÊúÄÂàù„ÅÆÊñáÂ≠ó„ÅåÂ∞èÊñáÂ≠ó„Å™„ÇâË§áÊï∞„ÅÆÂ∞èÊñáÂ≠ó„Å´ÈÅ©Âêà„Åô„Çã„ÄÅ„Å®„ÅÑ„ÅÜÊßãÊñáËß£ÊûêÂô®
„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; upperOrLower = some upper &lt;|&gt; some lower
</code></pre>
<p>„Åì„ÅÆÊßãÊñáËß£ÊûêÂô®„ÅØ„ÄÅÂ§ßÊñáÂ≠ó„Å®Â∞èÊñáÂ≠ó„ÅåÂàá„ÇäÊõø„Çè„Çã„Åæ„Åß„ÄÅÊñáÂ≠ó„Å´ÈÅ©Âêà„ÅóÁ∂ö„Åë„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; runParser upperOrLower &quot;abcDEF&quot;
(Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;))
              [ &quot;The state is \&quot;abcDEF\&quot;&quot;
              , &quot;The state is \&quot;bcDEF\&quot;&quot;
              , &quot;The state is \&quot;cDEF\&quot;&quot;
              ]))
</code></pre>
<p><code>many</code>„Çí‰Ωø„ÅÜ„Å®„ÄÅÊñáÂ≠óÂàó„ÇíÂ∞èÊñáÂ≠ó„Å®Â§ßÊñáÂ≠ó„ÅÆË¶ÅÁ¥†„Å´ÂÆåÂÖ®„Å´ÂàÜÂâ≤„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
(Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;)
              [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;CDeFgh\&quot;&quot;
              , &quot;The state is \&quot;DeFgh\&quot;&quot;
              , &quot;The state is \&quot;eFgh\&quot;&quot;
              , &quot;The state is \&quot;Fgh\&quot;&quot;
              , &quot;The state is \&quot;gh\&quot;&quot;
              , &quot;The state is \&quot;h\&quot;&quot;
              ]))
</code></pre>
<p>Áπ∞„ÇäËøî„Åó„Å´„Å™„Çä„Åæ„Åô„Åå„ÄÅ„Åì„Çå„ÅØ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Åå„ÇÇ„Åü„Çâ„ÅôÂÜçÂà©Áî®ÊÄß„ÅÆÂ®ÅÂäõ„ÇíÁ§∫„Åó
„Å¶„ÅÑ„Åæ„Åô„ÄÇÊ®ôÊ∫ñÁöÑ„Å™ÊäΩË±°Âåñ„ÇíÂÜçÂà©Áî®„Åô„Çã„Åì„Å®„Åß„ÄÅÂÆ£Ë®ÄÂûã„Çπ„Çø„Ç§„É´„ÅÆ„Éê„ÉÉ„ÇØ„Éà„É©„ÉÉ
„ÇØÊßãÊñáËß£ÊûêÂô®„Çí„Çè„Åö„ÅãÊï∞Ë°å„ÅÆ„Ç≥„Éº„Éâ„ÅßÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åó„ÅüÔºÅ</p>
<h2 id="ÊºîÁøí-38"><a class="header" href="#ÊºîÁøí-38">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>string</code>ÊßãÊñáËß£ÊûêÂô®„ÅÆÂÆüË£Ö„Åã„Çâ <code>lift</code>Èñ¢Êï∞„ÅÆÂëº„Å≥Âá∫„Åó„ÇíÂèñ„ÇäÈô§„ÅÑ„Å¶
„Åè„Å†„Åï„ÅÑ„ÄÇÊñ∞„Åó„ÅÑÂÆüË£Ö„ÅÆÂûã„ÅåÊï¥Âêà„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„ÄÅ„Å™„Åú„Åù„ÅÆ„Çà„ÅÜ„Å´„Å™„Çã
„ÅÆ„Åã„Çí„Çà„ÅèÁ¥çÂæó„Åó„Å¶„Åä„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>string</code>ÊßãÊñáËß£ÊûêÂô®„Å® <code>many</code>„Ç≥„É≥„Éì„Éç„Éº„Çø„Çí‰Ωø„Å£„Å¶„ÄÅÊñáÂ≠óÂàó
<code>&quot;a&quot;</code>„ÅÆÈÄ£Á∂ö„Å®„ÄÅ„Åù„Çå„Å´Á∂ö„ÅèÊñáÂ≠óÂàó <code>&quot;b&quot;</code>„ÅÆÈÄ£Á∂ö„Åã„Çâ„Å™„ÇãÊñáÂ≠óÂàó„ÇíË™çË≠ò„Åô„ÇãÊßã
ÊñáËß£ÊûêÂô®<code>asFollowedByBs</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>&lt;|&gt;</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„Å£„Å¶„ÄÅÊñáÂ≠ó <code>a</code>„Å®ÊñáÂ≠ó <code>b</code>„Åå‰ªªÊÑè„ÅÆÈ†ÜÂ∫è„ÅßÁèæ„Çå„Çã„Çà
„ÅÜ„Å™ÊñáÂ≠óÂàó„ÇíË™çË≠ò„Åô„ÇãÊßãÊñáËß£ÊûêÂô®<code>asOrBs</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>Parser</code>„É¢„Éä„Éâ„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Parser = ExceptT Errors (StateT String (WriterT Log Identity))
</code></pre>
<p>„Åì„ÅÆ„Çà„ÅÜ„Å´Â§âÊõ¥„Åô„Çã„Å®„ÄÅÊßãÊñáËß£ÊûêÈñ¢Êï∞„Å´„Å©„ÅÆ„Çà„ÅÜ„Å™ÂΩ±Èüø„Çí‰∏é„Åà„Çã„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
</li>
</ol>
<h2 id="rws„É¢„Éä„Éâ"><a class="header" href="#rws„É¢„Éä„Éâ">RWS„É¢„Éä„Éâ</a></h2>
<p>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅÆ„ÅÇ„ÇãÁâπÂÆö„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÅØÈ†ªÂá∫„Å™„ÅÆ„Åß„ÄÅ<code>transformers</code>„Éë„ÉÉ„Ç±„Éº
„Ç∏ÂÜÖ„ÅÆÂçò‰∏Ä„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Å®„Åó„Å¶Êèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ<code>Reader</code>„ÄÅ <code>Writer</code>„ÄÅ
<code>State</code>„ÅÆ„É¢„Éä„Éâ„ÅØ„ÄÅ<strong>Reader-Writer-State</strong>„É¢„Éä„Éâ„Å´ÁµÑ„ÅøÂêà„Çè„Åï„Çä„ÄÅ„Çà„ÇäÂçò
Á¥î„Å´<code>RWS</code>„É¢„Éä„Éâ„Å®„ÇÇ„Åï„Çå„Åæ„Åô„ÄÇ„Åì„ÅÆ„É¢„Éä„Éâ„ÅØ <code>RWST</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Å®Âëº„Å∞„Çå„Çã„ÄÅ
ÂØæÂøú„Åô„Çã„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„Åì„Åß„ÅØ <code>RWS</code>„É¢„Éä„Éâ„Çí‰Ωø„Å£„Å¶„ÉÜ„Ç≠„Çπ„Éà„Ç¢„Éâ„Éô„É≥„ÉÅ„É£„Éº„Ç≤„Éº„É†„ÅÆÂá¶ÁêÜ„ÇíË®≠Ë®à„Åó
„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p><code>RWS</code>„É¢„Éä„Éâ„ÅØÔºàÊàª„ÇäÂÄ§„ÅÆÂûã„Å´Âä†„Åà„Å¶Ôºâ3„Å§„ÅÆÂûãÂ§âÊï∞„Çí‰Ωø„Å£„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type RWS r w s = RWST r w s Identity
</code></pre>
<p>ÂâØ‰ΩúÁî®„ÇíÊèê‰æõ„Åó„Å™„ÅÑ <code>Identity</code>„Å´Âü∫Â∫ï„ÅÆ„É¢„Éä„Éâ„ÇíË®≠ÂÆö„Åô„Çã„Åì„Å®„Åß„ÄÅ <code>RWS</code>„É¢
„Éä„Éâ„ÅåÁã¨Ëá™„ÅÆ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÇíÁî®„ÅÑ„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p>Á¨¨1ÂûãÂºïÊï∞ <code>r</code>„ÅØÂ§ßÂüüÁöÑ„Å™Ë®≠ÂÆö„ÅÆÂûã„ÇíË°®„Åó„Åæ„Åô„ÄÇÁ¨¨2ÂûãÂºïÊï∞ <code>w</code>„ÅØ„É≠„Ç∞„ÇíËìÑÁ©ç„Åô
„Çã„Åü„ÇÅ„Å´‰ΩøÁî®„Åô„Çã„É¢„Éé„Ç§„Éâ„ÄÅÁ¨¨3ÂûãÂºïÊï∞ <code>s</code>„ÅØÂèØÂ§âÁä∂ÊÖã„ÅÆÂûã„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç≤„Éº„É†„ÅÆÂ†¥Âêà„Å´„ÅØ„ÄÅÂ§ßÂüüÁöÑ„Å™Ë®≠ÂÆö„ÅØ <code>Data.GameEnvironment</code>„É¢„Ç∏„É•„Éº„É´
„ÅÆ <code>GameEnvironment</code>„Å®Âëº„Å∞„Çå„ÇãÂûã„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type PlayerName = String

newtype GameEnvironment = GameEnvironment
  { playerName    :: PlayerName
  , debugMode     :: Boolean
  }
</code></pre>
<p>„Éó„É¨„Ç§„É§„ÉºÂêç„Å®„ÄÅ„Ç≤„Éº„É†„Åå„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ„ÅßÂãï‰Ωú„Åó„Å¶„ÅÑ„Çã„ÅãÂê¶„Åã„ÇíÁ§∫„Åô„Éï„É©„Ç∞
„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„Çâ„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„ÅØ„ÄÅ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÇíÂÆüË°å„Åô„Çã„Å®„Åç„Å´
„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Åã„ÇâË®≠ÂÆö„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>ÂèØÂ§âÁä∂ÊÖã„ÅØ <code>Data.GameState</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ <code>GameState</code>„Å®Âëº„Å∞„Çå„ÇãÂûã„ÅßÂÆöÁæ©
„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Data.Map as M
import Data.Set as S

newtype GameState = GameState
  { items       :: M.Map Coords (S.Set GameItem)
  , player      :: Coords
  , inventory   :: S.Set GameItem
  }
</code></pre>
<p><code>Coords</code>„Éá„Éº„ÇøÂûã„ÅØ2Ê¨°ÂÖÉÂπ≥Èù¢„ÅÆÁÇπ„ÇíË°®„Åó„ÄÅ <code>GameItem</code>„Éá„Éº„ÇøÂûã„ÅØ„Ç≤„Éº„É†ÂÜÖ„ÅÆ
„Ç¢„Ç§„ÉÜ„É†„ÅÆÂàóÊåô„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">data GameItem = Candle | Matches
</code></pre>
<p><code>GameState</code>Âûã„ÅØ2„Å§„ÅÆÊñ∞„Åó„ÅÑ„Éá„Éº„ÇøÊßãÈÄ†„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ<code>Map</code>„Å®<code>Set</code>„ÅØ„Åù„Çå
„Åû„ÇåÊï¥Âàó„Åï„Çå„Åü„Éû„ÉÉ„Éó„Å®Êï¥Âàó„Åï„Çå„ÅüÈõÜÂêà„ÇíË°®„Åó„Åæ„Åô„ÄÇ<code>items</code>Â±ûÊÄß„ÅØ„ÄÅ„Åù„ÅÆ„Ç≤„Éº
„É†Âπ≥Èù¢‰∏ä„ÅÆÂ∫ßÊ®ô„Åã„Çâ„Ç≤„Éº„É†„Ç¢„Ç§„ÉÜ„É†„ÅÆÈõÜÂêà„Å∏„ÅÆÂØæÂøú‰ªò„Åë„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>player</code>Â±ûÊÄß„ÅØ„Éó„É¨„Ç§„É§„Éº„ÅÆÁèæÂú®„ÅÆÂ∫ßÊ®ô„ÇíÊ†ºÁ¥ç„Åó„Å¶„Åä„Çä„ÄÅ <code>inventory</code>Â±ûÊÄß„ÅØ
ÁèæÂú®„Éó„É¨„Ç§„É§„Éº„Åå‰øùÊúâ„Åô„Çã„Ç≤„Éº„É†„Ç¢„Ç§„ÉÜ„É†„ÅÆÈõÜÂêà„Åß„Åô„ÄÇ</p>
<p><code>Map</code>„Å® <code>Set</code>„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„ÅØ„Ç≠„Éº„Å´„Çà„Å£„Å¶Êï¥Âàó„Åï„Çå„ÄÅ <code>Ord</code>Âûã„ÇØ„É©„Çπ„ÅÆ‰ªªÊÑè
„ÅÆÂûã„Çí„Ç≠„Éº„Å®„Åó„Å¶‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ‰ªäÂõû„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„ÅÆ„Ç≠„Éº„Åå
ÂÆåÂÖ®„Å´È†ÜÂ∫è‰ªò„Åë„Åß„Åç„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ</p>
<p>„Ç≤„Éº„É†„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊõ∏„Åè‰∏ä„Åß<code>Map</code>„Å® <code>Set</code>ÊßãÈÄ†„Çí„Å©„ÅÆ„Çà„ÅÜ„Å´‰Ωø„Å£„Å¶„ÅÑ„Åè„ÅÆ
„Åã„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>„É≠„Ç∞„Å®„Åó„Å¶„ÅØ <code>List String</code>„É¢„Éé„Ç§„Éâ„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ<code>Game</code>„É¢„Éä„ÉâÁî®„ÅÆÂûãÂêåÁæ©Ë™û
„ÇíÂÆöÁæ©„Åó„ÄÅ<code>RWS</code>„Çí‰Ωø„Å£„Å¶ÂÆüË£Ö„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Log = L.List String

type Game = RWS GameEnvironment Log GameState
</code></pre>
<h2 id="„Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂÆüË£Ö"><a class="header" href="#„Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂÆüË£Ö">„Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂÆüË£Ö</a></h2>
<p>‰ªäÂõû„ÅØ„ÄÅ <code>Reader</code>„É¢„Éä„Éâ„ÄÅ <code>Writer</code>„É¢„Éä„Éâ„ÄÅ <code>State</code>„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí
ÂÜçÂà©Áî®„Åó„ÄÅ <code>Game</code>„É¢„Éä„Éâ„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„ÇãÂçòÁ¥î„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶
„Ç≤„Éº„É†„ÇíÊßãÁØâ„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ„Åì„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÊúÄ‰∏ä‰Ωç„Åß„ÅØ„ÄÅ <code>Game</code>„É¢
„Éä„Éâ„ÅßÁ¥îÁ≤ã„Å™Ë®àÁÆó„ÇíÂÆüË°å„Åó„Å¶„Åä„Çä„ÄÅ <code>Effect</code>„É¢„Éä„Éâ„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´„Å´„ÉÜ„Ç≠„Çπ„Éà
„ÇíÂá∫Âäõ„Åô„Çã„Çà„ÅÜ„Å™Ë¶≥Ê∏¨ÂèØËÉΩ„Å™ÂâØ‰ΩúÁî®„Å∏„Å®ÁµêÊûú„ÇíÂ§âÊèõ„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç≤„Éº„É†„ÅßÊúÄ„ÇÇÁ∞°Âçò„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ„Å≤„Å®„Å§„ÅØ <code>has</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß„Åô„ÄÇ„Åì„ÅÆ„Ç¢
„ÇØ„Ç∑„Éß„É≥„ÅØ„Éó„É¨„Ç§„É§„Éº„ÅÆÊåÅ„Å°Áâ©„Å´ÁâπÂÆö„ÅÆ„Ç≤„Éº„É†„Ç¢„Ç§„ÉÜ„É†„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ
„Åã„ÇíË™ø„Åπ„Åæ„Åô„ÄÇ„Åì„Çå„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">has :: GameItem -&gt; Game Boolean
has item = do
  GameState state &lt;- get
  pure $ item `S.member` state.inventory
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØ„ÄÅÁèæÂú®„ÅÆ„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíË™≠„ÅøÂèñ„Çã„Åü„ÇÅ„Å´ <code>MonadState</code>Âûã„ÇØ„É©„Çπ„Åß
ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã <code>get</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶„Åä„Çä„ÄÅ„Åù„Çå„Åã„ÇâÊåáÂÆö„Åó„Åü
<code>GameItem</code>„ÅåÊåÅ„Å°Áâ©„Ç¢„Ç§„ÉÜ„É†„ÅÆ<code>Set</code>„Å´Âá∫Áèæ„Åô„Çã„Åã„Å©„ÅÜ„Åã„ÇíË™ø„Åπ„Çã„Åü„ÇÅ„Å´
<code>Data.Set</code>„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã <code>member</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰ªñ„Å´„ÇÇ <code>pickUp</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÁèæÂú®„ÅÆ‰ΩçÁΩÆ„Å´„Ç≤„Éº„É†„Ç¢„Ç§„ÉÜ„É†„Åå„ÅÇ„Çã
Â†¥Âêà„ÄÅ„Éó„É¨„Ç§„É§„Éº„ÅÆÊåÅ„Å°Áâ©„Å´„Åù„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíËøΩÂä†„Åó„Åæ„Åô„ÄÇ„Åì„Çå„Å´„ÅØ
<code>MonadWriter</code>„Å® <code>MonadState</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ‰∏ÄÁï™ÊúÄ
Âàù„Å´ÁèæÂú®„ÅÆ„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíË™≠„ÅøÂèñ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">pickUp :: GameItem -&gt; Game Unit
pickUp item = do
  GameState state &lt;- get
</code></pre>
<p>Ê¨°„Å´ <code>pickUp</code>„ÅØÁèæÂú®„ÅÆ‰ΩçÁΩÆ„Å´„ÅÇ„Çã„Ç¢„Ç§„ÉÜ„É†„ÅÆÈõÜÂêà„ÇíÊ§úÁ¥¢„Åó„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ
<code>Data.Map</code>„ÅßÂÆöÁæ©„Åï„Çå„Åü <code>lookup</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Ë°å„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  case state.player `M.lookup` state.items of
</code></pre>
<p><code>lookup</code>Èñ¢Êï∞„ÅØ <code>Maybe</code>ÂûãÊßãÁØâÂ≠ê„ÅßÁ§∫„Åï„Çå„Åü„Ç™„Éó„Ç∑„Éß„Éä„É´„Å™ÁµêÊûú„ÇíËøî„Åó„Åæ„Åô„ÄÇ
<code>lookup</code>Èñ¢Êï∞„ÅØ„ÄÅ„Ç≠„Éº„Åå„Éû„ÉÉ„Éó„Å´„Å™„ÅÑÂ†¥Âêà„ÅØ <code>Nothing</code>„ÇíËøî„Åó„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅÆÂ†¥
Âêà„ÅØ <code>Just</code>ÊßãÁØâÂ≠ê„ÅßÂØæÂøú„Åô„ÇãÂÄ§„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>Èñ¢ÂøÉ„Åå„ÅÇ„Çã„ÅÆ„ÅØ„ÄÅÊåáÂÆö„Åï„Çå„Åü„Ç≤„Éº„É†„Ç¢„Ç§„ÉÜ„É†„ÅåÂØæÂøú„Åô„Çã„Ç¢„Ç§„ÉÜ„É†„ÅÆÈõÜÂêà„Å´Âê´„Åæ
„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„Åß„Åô„ÄÇ„Åì„Åì„Åß„ÇÇ<code>member</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Å®„Åì„Çå„ÇíË™ø„Åπ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    Just items | item `S.member` items -&gt; do
</code></pre>
<p>„Åì„ÅÆÂ†¥Âêà„ÄÅ <code>put</code>„Çí‰Ωø„Å£„Å¶„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞„Åó„ÄÅ <code>tell</code>„Çí‰Ωø„Å£„Å¶„É≠„Ç∞„Å´„É°„ÉÉ
„Çª„Éº„Ç∏„ÇíËøΩÂä†„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">          let newItems = M.update (Just &lt;&lt;&lt; S.delete item) state.player state.items
              newInventory = S.insert item state.inventory
          put $ GameState state { items     = newItems
                                , inventory = newInventory
                                }
          tell (L.singleton (&quot;You now have the &quot; &lt;&gt; show item))
</code></pre>
<p>„Åì„Åì„Åß2„Å§„ÅÆË®àÁÆó„ÅÆ„Å©„Å°„Çâ„ÇÇ<code>lift</code>„ÅåÂøÖË¶Å„Å™„ÅÑ„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Å™„Åú
„Å™„Çâ<code>MonadState</code>„Å® <code>MonadWriter</code>„ÅÆ‰∏°Êñπ„Å´„Å§„ÅÑ„Å¶ <code>Game</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çπ„Çø„ÉÉ
„ÇØÁî®„ÅÆÈÅ©Âàá„Å™„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂ≠òÂú®„Åô„Çã„Åã„Çâ„Åß„Åô„ÄÇ</p>
<p><code>put</code>„Å∏„ÅÆÂºïÊï∞„Åß„ÅØ„ÄÅ„É¨„Ç≥„Éº„ÉâÊõ¥Êñ∞„Çí‰Ωø„Å£„Å¶„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÅÆ <code>items</code>„Å®
<code>inventory</code>„Éï„Ç£„Éº„É´„Éâ„ÇíÂ§âÊõ¥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÁâπÂÆö„ÅÆ„Ç≠„Éº„ÅÆÂÄ§„ÇíÂ§âÊõ¥„Åô„Çã
<code>Data.Map</code>„ÅÆ <code>update</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆÂ†¥Âêà„ÄÅ„Éó„É¨„Ç§„É§„Éº„ÅÆÁèæÂú®„ÅÆ
‰ΩçÁΩÆ„Å´„ÅÇ„Çã„Ç¢„Ç§„ÉÜ„É†„ÅÆÈõÜÂêà„ÇíÂ§âÊõ¥„Åô„Çã„ÅÆ„Å´„ÄÅ<code>delete</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶ÊåáÂÆö„Åó„Åü„Ç¢
„Ç§„ÉÜ„É†„ÇíÈõÜÂêà„Åã„ÇâÂèñ„ÇäÈô§„ÅÑ„Å¶„ÅÑ„Åæ„Åô„ÄÇ<code>insert</code>„Çí‰Ωø„Å£„Å¶Êñ∞„Åó„ÅÑ„Ç¢„Ç§„ÉÜ„É†„Çí„Éó„É¨
„Ç§„É§„Éº„ÅÆÊåÅ„Å°Áâ©ÈõÜÂêà„Å´Âä†„Åà„Çã„Å®„Åç„Å´„ÇÇ„ÄÅ<code>inventory</code>„ÅØÊõ¥Êñ∞„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂæå„Å´„ÄÅ<code>pickUp</code>Èñ¢Êï∞„ÅØ <code>tell</code>„Çí‰Ωø„Å£„Å¶„É¶„Éº„Ç∂„Å´Ê¨°„ÅÆ„Çà„ÅÜ„Å´ÈÄöÁü•„Åô„Çã„Åì„Å®„Å´
„Çà„Çä„ÄÅÊÆã„Çä„ÅÆÂ†¥Âêà„ÇíÂá¶ÁêÜ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    _ -&gt; tell (L.singleton &quot;I don't see that item here.&quot;)
</code></pre>
<p><code>Reader</code>„É¢„Éä„Éâ„Çí‰Ωø„ÅÜ‰æã„Å®„Åó„Å¶„ÄÅ <code>debug</code>„Ç≥„Éû„É≥„Éâ„ÅÆ„Ç≥„Éº„Éâ„ÇíË¶ã„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
„Ç≤„Éº„É†„Åå„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ„ÅßÂÆüË°å„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Åì„ÅÆ„Ç≥„Éû„É≥„Éâ„Çí‰Ωø„ÅÜ„Å®„É¶„Éº„Ç∂
„ÅØÂÆüË°åÊôÇ„Å´„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíË™ø„Åπ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  GameEnvironment env &lt;- ask
  if env.debugMode
    then do
      state :: GameState &lt;- get
      tell (L.singleton (show state))
    else tell (L.singleton &quot;Not running in debug mode.&quot;)
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅ„Ç≤„Éº„É†„ÅÆË®≠ÂÆö„ÇíË™≠„ÅøËæº„ÇÄ„Åü„ÇÅ„Å´ <code>ask</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Áπ∞„ÇäËøî„Åó„Åæ„Åô„Åå„ÄÅ„Å©„ÅÆË®àÁÆó„Åß„ÇÇ<code>lift</code>„ÅØÂøÖË¶Å„Åå„Å™„Åè„ÄÅÂêå„ÅòdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØÂÜÖ„Åß
<code>MonadState</code>„ÄÅ <code>MonadReader</code>„ÄÅ <code>MonadWriter</code>Âûã„ÇØ„É©„Çπ„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„Ç¢
„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><code>debugMode</code>„Éï„É©„Ç∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ <code>tell</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶„É≠„Ç∞„Å´
Áä∂ÊÖã„ÅåËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞„ÄÅ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅåËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p><code>Game.purs</code>„É¢„Ç∏„É•„Éº„É´„ÅÆÊÆã„Çä„ÅÆÈÉ®ÂàÜ„Åß„ÅØ„ÄÅ <code>MonadState</code>Âûã„ÇØ„É©„Çπ„ÄÅ
<code>MonadReader</code>Âûã„ÇØ„É©„Çπ„ÄÅ <code>MonadWriter</code>Âûã„ÇØ„É©„Çπ„Åß„Åù„Çå„Åû„ÇåÂÆöÁæ©„Åï„Çå„Åü„Ç¢„ÇØ
„Ç∑„Éß„É≥„Å†„Åë„Çí‰Ωø„Å£„Å¶„ÄÅÂêåÊßò„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="Ë®àÁÆó„ÅÆÂÆüË°å"><a class="header" href="#Ë®àÁÆó„ÅÆÂÆüË°å">Ë®àÁÆó„ÅÆÂÆüË°å</a></h2>
<p>„Åì„ÅÆ„Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ„ÅØ <code>RWS</code>„É¢„Éä„Éâ„ÅßÂãï„Åè„Åü„ÇÅ„ÄÅ„É¶„Éº„Ç∂„ÅÆ„Ç≥„Éû„É≥„Éâ„Å´ÂøúÁ≠î„Åô„Çã
„Åü„ÇÅ„Å´„ÅØË®àÁÆó„ÇíÂÆüË°å„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç≤„Éº„É†„ÅÆ„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅØ2„Å§„ÅÆ„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÊßãÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Ç¢„Éó„É™
„Ç´„ÉÜ„Ç£„Éñ„Å™„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÊßãÊñáËß£Êûê„ÇíÊèê‰æõ„Åô„Çã<code>optparse</code>„Å®„ÄÅÂØæË©±ÁöÑ„Å™„Ç≥„É≥„ÇΩ„Éº
„É´„Éô„Éº„Çπ„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÇíÊõ∏„Åè„Åì„Å®„ÇíÂèØËÉΩ„Å´„Åô„ÇãNodeJS„ÅÆ <code>readline</code>„É¢
„Ç∏„É•„Éº„É´„Çí„É©„ÉÉ„Éó„Åô„Çã <code>node-readline</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ„Å∏„ÅÆ„Ç§„É≥„Çø„Éï„Çß„Éº„Çπ„ÅØ <code>Game</code>„É¢„Ç∏„É•„Éº„É´ÂÜÖ„ÅÆÈñ¢Êï∞
<code>game</code>„Å´„Çà„Å£„Å¶Êèê‰æõ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">game :: Array String -&gt; Game Unit
</code></pre>
<p>„Åì„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Å´„ÅØ„ÄÅ„É¶„Éº„Ç∂„ÅåÂÖ•Âäõ„Åó„ÅüÂçòË™û„ÅÆ„É™„Çπ„Éà„ÇíÊñáÂ≠óÂàó„ÅÆÈÖçÂàó„Å®„Åó
„Å¶Ê∏°„Åó„Å¶„Åã„Çâ„ÄÅ <code>runRWS</code>„Çí‰Ωø„Å£„Å¶ <code>RWS</code>„ÅÆË®àÁÆóÁµêÊûú„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data RWSResult state result writer = RWSResult state result writer

runRWS :: forall r w s a. RWS r w s a -&gt; r -&gt; s -&gt; RWSResult s a w
</code></pre>
<p><code>runRWS</code>„ÅØ <code>runReader</code>„ÄÅ <code>runWriter</code>„ÄÅ <code>runState</code>„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Åü„Çà„ÅÜ„Å´
Ë¶ã„Åà„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅÂºïÊï∞„Å®„Åó„Å¶Â§ßÂüüÁöÑ„Å™Ë®≠ÂÆö„Åä„Çà„Å≥ÂàùÊúüÁä∂ÊÖã„Çí„Å®„Çä„ÄÅ„É≠„Ç∞„ÄÅÁµê
Êûú„ÄÅÊúÄÁöÑ„Å™ÁµÇÁä∂ÊÖã„ÇíÂê´„ÇÄ„Éá„Éº„ÇøÊßãÈÄ†„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ„Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„ÅØ„ÄÅÊ¨°„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊåÅ„Å§Èñ¢Êï∞
<code>runGame</code>„Å´„Çà„Å£„Å¶ÂÆöÁæ©„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">runGame :: GameEnvironment -&gt; Effect Unit
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÔºà<code>node-readline</code>„Å®<code>console</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰Ωø„Å£„Å¶Ôºâ„Ç≥„É≥„ÇΩ„Éº„É´„Çí
‰ªã„Åó„Å¶„É¶„Éº„Ç∂„Å®„ÇÑ„ÇäÂèñ„Çä„Åó„Åæ„Åô„ÄÇ<code>runGame</code>„ÅØÈñ¢Êï∞„ÅÆÂºïÊï∞„Å®„Åó„Å¶„ÅÆ„Ç≤„Éº„É†„ÅÆË®≠
ÂÆö„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ</p>
<p><code>node-readline</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÅØ<code>LineHandler</code>Âûã„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ
Á´ØÊú´„Åã„Çâ„ÅÆ„É¶„Éº„Ç∂ÂÖ•Âäõ„ÇíÊâ±„ÅÜ <code>Effect</code>„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíË°®„Åó„Åæ„Åô„ÄÇÂØæÂøú
„Åô„ÇãAPI„ÅØÊ¨°„ÅÆÈÄö„Çä„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">type LineHandler a = String -&gt; Effect a

foreign import setLineHandler
  :: forall a
   . Interface
  -&gt; LineHandler a
  -&gt; Effect Unit
</code></pre>
<p><code>Interface</code>Âûã„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´„ÅÆ„Éè„É≥„Éâ„É´„ÇíË°®„Åó„Å¶„Åä„Çä„ÄÅ„Ç≥„É≥„ÇΩ„Éº„É´„Å®„ÇÑ„ÇäÂèñ„Çä
„Åô„ÇãÈñ¢Êï∞„Å∏„ÅÆÂºïÊï∞„Å®„Åó„Å¶Ê∏°„Åï„Çå„Åæ„Åô„ÄÇ <code>createConsoleInterface</code>Èñ¢Êï∞„Çí‰ΩøÁî®
„Åô„Çã„Å® <code>Interface</code>„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">import Node.ReadLine as RL

runGame env = do
  interface &lt;- RL.createConsoleInterface RL.noCompletion
</code></pre>
<p>ÊúÄÂàù„ÅÆÊâãÈ†Ü„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´„Å´„Éó„É≠„É≥„Éó„Éà„ÇíË®≠ÂÆö„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ <code>interface</code>„Éè„É≥
„Éâ„É´„ÇíÊ∏°„Åó„ÄÅ„Éó„É≠„É≥„Éó„ÉàÊñáÂ≠óÂàó„Å®Â≠ó‰∏ã„Åí„É¨„Éô„É´„Çí‰∏é„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  RL.setPrompt &quot;&gt; &quot; interface
</code></pre>
<p>‰ªäÂõû„ÅØË°åÂà∂Âæ°Èñ¢Êï∞„ÇíÂÆüË£Ö„Åô„Çã„Åì„Å®„Å´Èñ¢ÂøÉ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„Åì„Åß„ÅÆË°åÂà∂Âæ°„ÅØ
<code>let</code>ÂÆ£Ë®ÄÂÜÖ„ÅÆË£úÂä©Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Ê¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    lineHandler :: GameState -&gt; String -&gt; Effect Unit
    lineHandler currentState input = do
      case runRWS (game (split (wrap &quot; &quot;) input)) env currentState of
        RWSResult state _ written -&gt; do
          for_ written log
          RL.setLineHandler (lineHandler state) $ interface
      RL.prompt interface
      pure unit
</code></pre>
<p><code>let</code>ÊùüÁ∏õ„Åå<code>env</code>„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆ„Ç≤„Éº„É†ÊßãÊàê„ÇÑ<code>interface</code>„Å®„ÅÑ„ÅÜÂêçÂâç„ÅÆ„Ç≥„É≥„ÇΩ„Éº
„É´„Éè„É≥„Éâ„É´„ÇíÂåÖ„ÅøËæº„Çì„Åß„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Éè„É≥„Éâ„É©„ÅØËøΩÂä†„ÅÆÊúÄÂàù„ÅÆÂºïÊï∞„Å®„Åó„Å¶„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíÂèñ„Çä„Åæ„Åô„ÄÇ„Ç≤„Éº„É†„ÅÆ„É≠
„Ç∏„ÉÉ„ÇØ„ÇíÂÆüË°å„Åô„Çã„Åü„ÇÅ„Å´ <code>runRWS</code>„Å´„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíÊ∏°„Åï„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„ÅÆ
„Åß„ÄÅ„Åì„Çå„ÅØÂøÖË¶Å„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÊúÄÂàù„Å´Ë°å„ÅÜ„Åì„Å®„ÅØ„ÄÅ <code>Data.String</code>„É¢„Ç∏„É•„Éº„É´„ÅÆ <code>split</code>Èñ¢
Êï∞„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ„É¶„Éº„Ç∂„Éº„ÅÆÂÖ•Âäõ„ÇíÂçòË™û„Å´ÂàÜÂâ≤„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ„Åù„Çå„Åã„Çâ„ÄÅ„Ç≤„Éº„É†
Áí∞Â¢É„Å®ÁèæÂú®„ÅÆ„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíÊ∏°„Åó„ÄÅ <code>runRWS</code>„Çí‰ΩøÁî®„Åó„Å¶Ôºà<code>RWS</code>„É¢„Éä„Éâ„ÅßÔºâ
<code>game</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Á¥îÁ≤ã„Å™Ë®àÁÆó„Åß„ÅÇ„Çã„Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂÆüË°å„Åô„Çã„Å´„ÅØ„ÄÅÁîªÈù¢„Å´„Åô„Åπ„Å¶„ÅÆ„É≠„Ç∞„É°„ÉÉ„Çª„Éº
„Ç∏„ÇíÂá∫Âäõ„Åó„Å¶„ÄÅ„É¶„Éº„Ç∂„Å´Ê¨°„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅÆ„Åü„ÇÅ„ÅÆ„Éó„É≠„É≥„Éó„Éà„ÇíË°®Á§∫„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ
„Çä„Åæ„Åô„ÄÇ <code>for_</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÔºà<code>List String</code>Âûã„ÅÆÔºâ„É≠„Ç∞„ÇíËµ∞Êüª„Åó„ÄÅ„Ç≥„É≥„ÇΩ„Éº
„É´„Å´„Åù„ÅÆÂÜÖÂÆπ„ÇíÂá∫Âäõ„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÊúÄÂæå„Å´<code>setLineHandler</code>„Çí‰Ωø„Å£
„Å¶Ë°åÂà∂Âæ°Èñ¢Êï∞„ÇíÊõ¥Êñ∞„Åô„Çã„Åì„Å®„Åß„Ç≤„Éº„É†„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞„Åó„ÄÅ<code>prompt</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí
‰Ωø„Å£„Å¶„Éó„É≠„É≥„Éó„Éà„ÇíÂÜç„Å≥Ë°®Á§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>runGame</code>Èñ¢Êï∞„ÅØÊúÄÁµÇÁöÑ„Å´„Ç≥„É≥„ÇΩ„Éº„É´„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„Å´ÊúÄÂàù„ÅÆË°åÂà∂Âæ°Â≠ê„ÇíÂèñ
„Çä‰ªò„Åë„Å¶„ÄÅÊúÄÂàù„ÅÆ„Éó„É≠„É≥„Éó„Éà„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  RL.setLineHandler (lineHandler initialGameState) interface
  RL.prompt interface
</code></pre>
<h2 id="ÊºîÁøí-39"><a class="header" href="#ÊºîÁøí-39">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÊôÆÈÄöÔºâ„Ç≤„Éº„É†„ÅÆÊ†ºÂ≠ê‰∏ä„Å´„ÅÇ„ÇãÂÖ®„Å¶„ÅÆ„Ç≤„Éº„É†„Ç¢„Ç§„ÉÜ„É†„Çí„É¶„Éº„Ç∂„ÅÆÊåÅ„Å°„ÇÇ„ÅÆ„Å´Áßª
Âãï„Åô„ÇãÊñ∞„Åó„ÅÑ„Ç≥„Éû„É≥„Éâ <code>cheat</code>„ÇíÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÈñ¢Êï∞<code>cheat :: Game Unit</code>„Çí<code>Game</code>„É¢„Ç∏„É•„Éº„É´„Å´‰Ωú„Çä„ÄÅ„Åì„ÅÆÈñ¢Êï∞„Çí<code>game</code>„Åã„Çâ‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>RWS</code>„É¢„Éä„Éâ„ÅÆ <code> Writer</code>„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅØ„ÄÅ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Å®
ÊÉÖÂ†±„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ2„Å§„ÅÆÁ®ÆÈ°û„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ„Åü„ÇÅ„ÄÅ
„Ç≥„Éº„Éâ„ÅÆ„ÅÑ„Åè„Å§„Åã„ÅÆÁÆáÊâÄ„Åß„ÅØ„ÄÅ„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÇíÊâ±„ÅÜ„Åü„ÇÅ„Å´caseÂºè„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ
„Åæ„Åô„ÄÇ</p>
<p>„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊâ±„ÅÜ„ÅÆ„Å´ <code>ExceptT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çí‰Ωø„ÅÜ„Çà„ÅÜ„Å´„Åó„ÄÅ
ÊÉÖÂ†±„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊâ±„ÅÜ„ÅÆ„Å´ <code>RWS</code>„Çí‰Ωø„ÅÜ„Çà„ÅÜ„Å´„Åô„Çã„Çà„ÅÜ„ÄÅ„Ç≥„Éº„Éâ„Çí„É™„Éï„Ç°
„ÇØ„Çø„É™„É≥„Ç∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊºîÁøí„Å´„ÅØ„ÉÜ„Çπ„Éà„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
</ol>
<h2 id="„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÊâ±„ÅÑ"><a class="header" href="#„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÊâ±„ÅÑ">„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÊâ±„ÅÑ</a></h2>
<p>„Åì„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÊúÄÂæå„ÅÆÈÉ®ÂìÅ„ÅØ„ÄÅ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆËß£Êûê„Å®
<code>GameEnvironment</code>Ë®≠ÂÆö„É¨„Ç≥„Éº„Éâ„Çí‰ΩúÊàê„Åô„ÇãÂΩπÁõÆ„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆ„Åü„ÇÅ„Å´„ÅØ
<code>optparse</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ</p>
<p><code>optparse</code>„ÅØ<strong>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„Éñ„Å™„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥ÊßãÊñáËß£ÊûêÂô®</strong>„ÅÆ‰∏Ä
‰æã„Åß„Åô„ÄÇ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Çí‰Ωø„ÅÜ„Å®„ÄÅ„ÅÑ„Çç„ÅÑ„Çç„Å™ÂâØ‰ΩúÁî®„ÅÆÂûã„ÇíË°®„ÅôÂûãÊßãÁØâÂ≠ê
„Åæ„Åß‰ªªÊÑèÂÄãÊï∞„ÅÆÂºïÊï∞„ÅÆÈñ¢Êï∞„Çí„ÇíÊåÅ„Å°‰∏ä„Åí„Çâ„Çå„Çã„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>optparse</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅÆÂ†¥Âêà„Å´„ÅØ„ÄÅ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„Åã„Çâ„ÅÆË™≠„ÅøÂèñ„Çä
„ÅÆÂâØ‰ΩúÁî®„ÇíËøΩÂä†„Åô„Çã<code>Parser</code>Èñ¢ÊâãÔºàoptparse„ÅÆ„É¢„Ç∏„É•„Éº„É´
<code>Options.Applicative</code>„Åã„Çâ„Ç§„É≥„Éù„Éº„Éà„Åï„Çå„Åü„ÇÇ„ÅÆ„ÄÇ<code>Split</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©
„Åó„Åü<code>Parser</code>„Å®Ê∑∑Âêå„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´Ôºâ„ÅåËààÂë≥Ê∑±„ÅÑÈñ¢Êâã„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„ÅØÊ¨°
„ÅÆ„Çà„ÅÜ„Å™„Éè„É≥„Éâ„É©„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">customExecParser :: forall a. ParserPrefs ‚Üí ParserInfo a ‚Üí Effect a
</code></pre>
<p>ÂÆü‰æã„ÇíË¶ã„Çã„ÅÆ„Åå‰∏ÄÁï™„Åß„Åô„ÄÇ„Åì„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ <code>main</code>Èñ¢Êï∞„ÅØ
<code>customExecParser</code>„Çí‰Ωø„Å£„Å¶Ê¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">main = OP.customExecParser prefs argParser &gt;&gt;= runGame 
</code></pre>
<p>ÊúÄÂàù„ÅÆÂºïÊï∞„ÅØ<code>optparse</code>„É©„Ç§„Éñ„É©„É™„ÇíË®≠ÂÆö„Åô„Çã„Åü„ÇÅ„Å´‰ΩøÁî®„Åï„Çå„Åæ„Åô„ÄÇ‰ªäÂõû„ÅÆÂ†¥
Âêà„ÄÅ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅåÂºïÊï∞„Å™„Åó„ÅßËµ∞„Çâ„Åï„Çå„Åü„Å®„Åç„ÅØ„ÄÅÔºà„Äåmissing argument„Äç
„Ç®„É©„Éº„ÇíË°®Á§∫„Åô„Çã‰ª£„Çè„Çä„Å´Ôºâ<code>OP.prefs OP.showHelpOnEmpty</code>„Çí‰Ωø„Å£„Å¶‰ΩøÁî®Êñπ
Ê≥ï„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫„Åô„Çã„Çà„ÅÜ„Å´Ë®≠ÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
<code>Options.Applicative.Builder</code>„É¢„Ç∏„É•„Éº„É´„Å´„ÅØ‰ªñ„Å´„ÇÇ„ÅÑ„Åè„Å§„Åã„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥
„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>2„Å§ÁõÆ„ÅÆÂºïÊï∞„ÅØËß£Êûê„Éó„É≠„Ç∞„É©„É†„ÅÆÂÆåÂÖ®„Å™Ë™¨Êòé„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">  argParser :: OP.ParserInfo GameEnvironment
  argParser = OP.info (env &lt;**&gt; OP.helper) parserOptions

  parserOptions = fold 
    [ OP.fullDesc
    , OP.progDesc &quot;Play the game as &lt;player name&gt;&quot;
    , OP.header &quot;Monadic Adventures! A game to learn monad transformers&quot; 
    ]
</code></pre>
<p>„Åì„Åì„Åß<code>OP.info</code>„ÅØ‰ΩøÁî®ÊñπÊ≥ï„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅåÊõ∏ÂºèÂåñ„Åï„Çå„Åü„Çà„ÅÜ„Å´„Ç™„Éó„Ç∑„Éß„É≥„ÅÆ
ÈõÜÂêà„Å®ÂÖ±„Å´<code>Parser</code>„ÇíÁµêÂêà„Åó„Åæ„Åô„ÄÇ<code>env &lt;**&gt; OP.helper</code>„ÅØ<code>env</code>„Å®Âêç‰ªò„Åë„Çâ
„Çå„Åü‰ªªÊÑè„ÅÆ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞<code>Parser</code>„ÇíÂèñ„Çä„ÄÅËá™ÂãïÁöÑ„Å´<code>--help</code>„Ç™„Éó„Ç∑„Éß„É≥
„ÇíÂä†„Åà„Åæ„Åô„ÄÇ‰ΩøÁî®ÊñπÊ≥ï„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Áî®„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„ÅØÂûã„Åå<code>InfoMod</code>„Åß„ÅÇ„Çä„ÄÅ
„Åì„Çå„ÅØ„É¢„Éé„Ç§„Éâ„Å™„ÅÆ„Åß<code>fold</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Ë§áÊï∞„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„Çí‰∏ÄÁ∑í„Å´ËøΩÂä†„Åß„Åç
„Åæ„Åô„ÄÇ</p>
<p>Ëß£ÊûêÂô®„ÅÆÈù¢ÁôΩ„ÅÑÈÉ®ÂàÜ„ÅØ<code>GameEnvironment</code>„ÅÆÊßãÁØâ„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  env :: OP.Parser GameEnvironment
  env = gameEnvironment &lt;$&gt; player &lt;*&gt; debug

  player :: OP.Parser String
  player = OP.strOption $ fold 
    [ OP.long &quot;player&quot;
    , OP.short 'p'
    , OP.metavar &quot;&lt;player name&gt;&quot;
    , OP.help &quot;The player's name &lt;String&gt;&quot;
    ]

  debug :: OP.Parser Boolean
  debug = OP.switch $ fold 
    [ OP.long &quot;debug&quot;
    , OP.short 'd'
    , OP.help &quot;Use debug mode&quot;
    ]
</code></pre>
<p><code>player</code>„Å®<code>debug</code>„ÅØ‰∏°Êñπ„Å®„ÇÇ<code>Parser</code>„Å™„ÅÆ„Åß„ÄÅ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÊºîÁÆóÂ≠ê<code>&lt;$&gt;</code>„Å®
<code>&lt;*&gt;</code>„Çí‰Ωø„Å£„Å¶<code>gameEnvironment</code>Èñ¢Êï∞„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åì„ÅÆÈñ¢Êï∞
„ÅØ<code>Parser</code>‰∏ä„ÅßÂûã<code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code>„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ
<code>OP.strOption</code>„ÅØÊñáÂ≠óÂàóÂÄ§„ÇíÊúüÂæÖ„Åô„Çã„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÇíÊßãÁØâ„Åó„ÄÅ‰∏Ä
Á∑í„Å´Áï≥„ÅøËæº„Åæ„Çå„Åü<code>Mod</code>„ÅÆÈõÜ„Åæ„Çä„Çí‰ªã„Åó„Å¶Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ<code>OP.flag</code>„ÅØ‰ºº„Åü
„Çà„ÅÜ„Å™Âãï‰Ωú„Çí„Åó„Åæ„Åô„Åå„ÄÅÈñ¢ÈÄ£‰ªò„Åë„Çâ„Çå„ÅüÂÄ§„ÅØÊúüÂæÖ„Åó„Åæ„Åõ„Çì„ÄÇ<code>optparse</code>„ÅØÂ§öÁ®Æ
Â§öÊßò„Å™„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥Ëß£ÊûêÂô®„ÇíÊßãÁØâ„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Åà„ÇãÊßò„ÄÖ„Å™‰øÆÈ£æÂ≠ê„Å´„Å§„ÅÑ„Å¶„ÄÅ
Â§ßÈÉ®„ÅÆ<a href="https://pursuit.purescript.org/packages/purescript-optparse">„Éâ„Ç≠„É•„É°„É≥
„Éà</a>„ÇíÊèê‰æõ
„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÊºîÁÆóÂ≠ê„Å´„Çà„ÇãË®òÊ≥ï„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„ÄÅ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç§„É≥„Çø„Éº„Éï„Çß
„Ç§„Çπ„Å´ÂØæ„Åó„Å¶„Ç≥„É≥„Éë„ÇØ„Éà„ÅßÂÆ£Ë®ÄÁöÑ„Å™‰ªïÊßò„Çí‰∏é„Åà„Çã„Åì„Å®„ÅåÂèØËÉΩ„Å´„Å™„Å£„Åü„Åì„Å®„Å´Ê≥®
ÁõÆ„Åß„Åô„ÄÇ„Åæ„Åü„ÄÅ<code>runGame</code>„Å´Êñ∞„Åó„ÅÑÈñ¢Êï∞ÂºïÊï∞„ÇíËøΩÂä†„Åó„ÄÅ<code>env</code>„ÅÆÂÆöÁæ©‰∏≠„Åß
<code>&lt;*&gt;</code>„Çí‰Ωø„Å£„Å¶ËøΩÂä†„ÅÆÂºïÊï∞„Åæ„Åß <code>runGame</code>„ÇíÊåÅ„Å°‰∏ä„Åí„Çã„Å†„Åë„Åß„ÄÅÁ∞°Âçò„Å´Êñ∞„Åó„ÅÑ
„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„ÇíËøΩÂä†„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-40"><a class="header" href="#ÊºîÁøí-40">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ<code>GameEnvironment</code>„É¨„Ç≥„Éº„Éâ„Å´Êñ∞„Åó„ÅÑÁúüÂÅΩÂÄ§„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£
<code>cheatMode</code>„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ „Åæ„Åü„ÄÅ <code>optparse</code>Ë®≠ÂÆö„Å´„ÄÅ„ÉÅ„Éº„Éà„É¢„Éº„Éâ
„ÇíÊúâÂäπ„Å´„Åô„ÇãÊñ∞„Åó„ÅÑ„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Éï„É©„Ç∞ <code>-c</code>„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„ÉÅ„Éº„Éà
„É¢„Éº„Éâ„ÅåÊúâÂäπ„Å´„Å™„Å£„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÄÅ <code>cheat</code>„Ç≥„Éû„É≥„Éâ„ÅØÁ¶ÅÊ≠¢„Åï„Çå„Å™„Åë„Çå„Å∞„Å™„Çä
„Åæ„Åõ„Çì„ÄÇ</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-9"><a class="header" href="#„Åæ„Å®„ÇÅ-9">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„Åì„Çå„Åæ„ÅßÂ≠¶„Çì„Åß„Åç„ÅüÊäÄË°ì„ÅÆÂÆüË∑µÁöÑ„Å™ÂÆüÊºî„ÇíË°å„ÅÑ„Åæ„Åó„Åü„ÄÇ„É¢„Éä„ÉâÂ§âÊèõ
Â≠ê„Çí‰ΩøÁî®„Åó„Åü„Ç≤„Éº„É†„ÅÆÁ¥îÁ≤ã„Å™‰ªïÊßò„ÅÆÊßãÁØâ„ÄÅ„Ç≥„É≥„ÇΩ„Éº„É´„Çí‰ΩøÁî®„Åó„Åü„Éï„É≠„É≥„Éà„Ç®„É≥
„Éâ„ÇíÊßãÁØâ„Åô„Çã„Åü„ÇÅ„ÅÆ <code>Effect</code>„É¢„Éä„Éâ„Åå„Åù„Çå„Åß„Åô„ÄÇ</p>
<p>„É¶„Éº„Ç∂„Ç§„É≥„Çø„Éº„Éï„Çß„Ç§„Çπ„Åã„Çâ„ÅÆÂÆüË£Ö„ÇíÂàÜÈõ¢„Åó„Åü„ÅÆ„Åß„ÄÅ„Ç≤„Éº„É†„ÅÆÂà•„ÅÆ„Éï„É≠„É≥„Éà„Ç®
„É≥„Éâ„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„ÇÇÂèØËÉΩ„Åß„Åó„Çá„ÅÜ„ÄÇ‰æã„Åà„Å∞„ÄÅ <code>Effect</code>„É¢„Éä„Éâ„ÅßCanvas API
„ÇÑDOM„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ„Éñ„É©„Ç¶„Ç∂„Åß„Ç≤„Éº„É†„ÇíÊèèÁîª„Åô„Çã„Çà„ÅÜ„Å™„Åì„Å®„Åå„Åß„Åç„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Å´„Çà„Å£„Å¶ÂëΩ‰ª§Âûã„ÅÆ„Çπ„Çø„Ç§„É´„ÅßÂÆâÂÖ®„Å™„Ç≥„Éº„Éâ„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„Åì
„Å®„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ„Åì„ÅÆ„Çπ„Çø„Ç§„É´„Åß„ÅØÂûã„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„Å£„Å¶‰ΩúÁî®„ÅåËøΩË∑°„Åï„Çå„Å¶„ÅÑ
„Åæ„Åô„ÄÇ„Åæ„Åü„ÄÅÂûã„ÇØ„É©„Çπ„ÅØ„É¢„Éä„Éâ„ÅåÊèê‰æõ„Åô„Çã„Ç¢„ÇØ„Ç∑„Éß„É≥„Å∏„Å®ÊäΩË±°Âåñ„Åô„ÇãÂº∑Âäõ„Å™Êñπ
Ê≥ï„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆ„É¢„Éä„Éâ„ÅÆ„ÅäÈô∞„Åß„Ç≥„Éº„Éâ„ÅÆÂÜçÂà©Áî®„ÅåÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇÊ®ô
Ê∫ñÁöÑ„Å™„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅ <code>Alternative</code>„ÇÑ
<code>MonadPlus</code>„ÅÆ„Çà„ÅÜ„Å™Ê®ôÊ∫ñÁöÑ„Å™ÊäΩË±°Âåñ„Çí‰ΩøÁî®„Åó„Å¶„ÄÅÂΩπ„Å´Á´ã„Å§„É¢„Éä„Éâ„ÇíÊßãÁØâ„Åô„Çã
„Åì„Å®„Åå„Åß„Åç„Åæ„Åó„Åü„ÄÇ</p>
<p>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„ÅØ„ÄÅÈ´òÈöéÂ§öÁõ∏„ÇÑÂ§öÂ§âÊï∞Âûã„ÇØ„É©„Çπ„Å™„Å©„ÅÆÈ´òÂ∫¶„Å™Âûã„Ç∑„Çπ„ÉÜ„É†„ÅÆÊ©üËÉΩ„Çí
Âà©Áî®„Åô„Çã„Åì„Å®„Å´„Çà„Å£„Å¶Ë®òËø∞„Åô„Çã„Åì„Å®„Åå„Åß„Åç„ÄÅË°®ÁèæÂäõ„ÅÆÈ´ò„ÅÑ„Ç≥„Éº„Éâ„ÅÆÂÑ™„Çå„ÅüÂÆüÊºî
„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ"><a class="header" href="#canvas„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ">Canvas„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-10"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-10">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅØ<code>canvas</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Å´ÁÑ¶ÁÇπ„ÇíÂΩì„Å¶„ÇãÁô∫Â±ïÁöÑ„Å™‰æã„Å®„Å™„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆ„Éë„ÉÉ
„Ç±„Éº„Ç∏„ÅØPureScript„ÅßHTML5„ÅÆCanvas API„Çí‰ΩøÁî®„Åó„Å¶2D„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÁîüÊàê
„Åô„ÇãÊâãÊÆµ„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-9"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-9">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØ‰ª•‰∏ã„ÅÆÊñ∞„Åó„ÅÑ‰æùÂ≠òÈñ¢‰øÇ„ÅåÂ∞éÂÖ•„Åï„Çå„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>canvas</code>„ÅØHTML5„ÅÆCanvas API„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅÆÂûã„Çí‰∏é„Åà„Åæ„Åô„ÄÇ</li>
<li><code>refs</code>„ÅØ<strong>Â§ßÂüüÁöÑ„Å™Â§âÊõ¥ÂèØËÉΩÈ†òÂüü„Å∏„ÅÆÂèÇÁÖß</strong>„Çí‰Ωø„ÅÜ„Åü„ÇÅ„ÅÆÂâØ‰ΩúÁî®„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</li>
</ul>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅØ„ÄÅ„Åù„Çå„Åû„Çå„Å´ <code>main</code>„É°„ÇΩ„ÉÉ„Éâ„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„É¢„Ç∏„É•„Éº
„É´„ÅÆÈõÜÂêà„Å∏„Å®ÂàÜÂâ≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆÁ´†„ÅÆ„Åù„Çå„Åû„Çå„ÅÆÁØÄ„ÅÆÂÜÖÂÆπ„ÅØ„Åù„Çå„Åû„Çå„ÅÆÁï∞
„Å™„Çã„Éï„Ç°„Ç§„É´„ÅßÂÆüË£Ö„Åï„Çå„Å¶„Åä„Çä„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÊôÇÁÇπ„Åß„ÅÆÈÅ©Âàá„Å™„Éï„Ç°„Ç§„É´„ÅÆ
<code>main</code>„É°„ÇΩ„ÉÉ„Éâ„ÇíÂÆüË°å„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅSpago„Éì„É´„Éâ„Ç≥„Éû„É≥„Éâ„ÇíÂ§âÊõ¥„Åô„Çã„Åì„Å®„Åß
<code>Main</code>„É¢„Ç∏„É•„Éº„É´„ÅåÂ§âÊõ¥„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>HTML„Éï„Ç°„Ç§„É´ <code>html/index.html</code>„Å´„ÅØ„ÄÅÂêÑ‰æã„Åß‰ΩøÁî®„Åï„Çå„ÇãÂçò‰∏Ä„ÅÆ <code>canvas</code>Ë¶Å
Á¥†„ÄÅ„Åä„Çà„Å≥„Ç≥„É≥„Éë„Ç§„É´„Åï„Çå„ÅüPureScript„Ç≥„Éº„Éâ„ÇíË™≠„ÅøËæº„ÇÄ <code>script</code>Ë¶ÅÁ¥†„ÅåÂê´
„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åª„Å®„Çì„Å©„ÅÆÊºîÁøí„ÅØ„Éñ„É©„Ç¶„Ç∂„ÇíÂØæË±°„Å´„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ„Åì„ÅÆÁ´†„Å´„ÅØ
Âçò‰ΩìË©¶È®ì„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<h2 id="ÂçòÁ¥î„Å™Âõ≥ÂΩ¢"><a class="header" href="#ÂçòÁ¥î„Å™Âõ≥ÂΩ¢">ÂçòÁ¥î„Å™Âõ≥ÂΩ¢</a></h2>
<p><code>Example/Rectangle.purs</code>„Éï„Ç°„Ç§„É´„Å´„ÅØÁ∞°Âçò„Å™Â∞éÂÖ•‰æã„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ
‰æã„Åß„ÅØcanvas„ÅÆ‰∏≠ÂøÉ„Å´Èùí„ÅÑÂõõËßíÂΩ¢„Çí„Å≤„Å®„Å§ÊèèÁîª„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„ÅØ„ÄÅ
<code>Effect</code>„É¢„Ç∏„É•„Éº„É´„Åã„Çâ„ÅÆ<code>Effect</code>Âûã„Å®„ÄÅCanvas API„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆ<code>Effect</code>„É¢
„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂê´„ÇÄ<code>Graphics.Canvas</code>„É¢„Ç∏„É•„Éº„É´„Çí„Ç§„É≥„Éù„Éº„Éà„Åó„Åæ„Åô„ÄÇ</p>
<p>‰ªñ„ÅÆ„É¢„Ç∏„É•„Éº„É´„Åß„ÇÇÂêåÊßò„Åß„Åô„Åå„ÄÅ <code>main</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØÊúÄÂàù„Å´
<code>getCanvasElementById</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶canvas„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å∏„ÅÆÂèÇÁÖß„ÇíÂèñ
Âæó„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åæ„Åü„ÄÅ <code>getContext2D</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶„Ç≠„É£„É≥„Éê„Çπ„ÅÆ2DÊèè
Áîª„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèÇÁÖß„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>void</code>Èñ¢Êï∞„ÅØÈñ¢Êâã„ÇíÂèñ„ÇäÂÄ§„Çí<code>Unit</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Åæ„Åô„ÄÇ‰æã„Åß„ÅØ<code>main</code>„Åå„Ç∑„Ç∞„Éç„ÉÅ„É£
„Å´Ê≤ø„ÅÜ„Çà„ÅÜ„Å´„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><strong>Ê≥®ÊÑè</strong>Ôºö„Åì„ÅÆ<code>unsafePartial</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÅØÂøÖÈ†à„Åß„Åô„ÄÇ„Åì„Çå„ÅØ
<code>getCanvasElementById</code>„ÅÆÁµêÊûú„ÅÆ„Éë„Çø„Éº„É≥ÁÖßÂêàÈÉ®ÂàÜÁöÑ„Åß„ÄÅ<code>Just</code>ÂÄ§ÊßãÁØâÂ≠ê„Å†„Åë
„Å®ÁÖßÂêà„Åô„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ„Åì„Åì„Åß„ÅØ„Åì„Çå„ÅßÂïèÈ°å„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅÂÆüÈöõ„ÅÆË£ΩÂìÅ„ÅÆ„Ç≥„Éº„Éâ
„Åß„ÅØ„Åä„Åù„Çâ„Åè<code>Nothing</code>ÂÄ§ÊßãÁØâÂ≠ê„Å®ÁÖßÂêà„Åï„Åõ„ÄÅÈÅ©Âàá„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊèê‰æõ
„Åó„Åü„Åª„ÅÜ„Åå„Çà„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åì„Çå„Çâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂûã„ÅØ„ÄÅPSCi„Çí‰Ωø„ÅÜ„Åã„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíË¶ã„Çã„Å®Á¢∫Ë™ç„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code>„Å® <code>Context2D</code>„ÅØ <code>Graphics.Canvas</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå
„Å¶„ÅÑ„ÇãÂûã„Åß„Åô„ÄÇ„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ<code>Canvas</code>‰ΩúÁî®„ÇÇÂÆöÁæ©„Åï„Çå„Å¶„Åä„Çä„ÄÅ„É¢„Ç∏„É•„Éº
„É´ÂÜÖ„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà <code>ctx</code>„ÅØ„ÄÅcanvas„ÅÆÁä∂ÊÖã„ÇíÁÆ°ÁêÜ„Åó„ÄÅÂéüÂßãÁöÑ„Å™Âõ≥ÂΩ¢
„ÇíÊèèÁîª„Åó„Åü„Çä„ÄÅ„Çπ„Çø„Ç§„É´„ÇÑËâ≤„ÇíË®≠ÂÆö„Åó„Åü„Çä„ÄÅÂ∫ßÊ®ôÂ§âÊèõ„ÇíÈÅ©Áî®„Åô„Çã„Åü„ÇÅ„ÅÆ„É°„ÇΩ„ÉÉ
„Éâ„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Ë©±„ÇíÈÄ≤„ÇÅ„Çã„Å®„ÄÅ<code>setFillStyle</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„ÅÜ„Åì„Å®„ÅßÂ°ó„ÇäÊΩ∞„Åó„Çπ„Çø„Ç§„É´„ÇíÊøÉ
„ÅÑÈùí„Å´Ë®≠ÂÆö„Åß„Åç„Åæ„Åô„ÄÇ„Çà„ÇäÈï∑„ÅÑ16ÈÄ≤Êï∞Ë®òÊ≥ï„ÅÆ<code>#0000FF</code>„ÇÇÈùí„Å´„ÅØ‰Ωø„Åà„Åæ„Åô„Åå„ÄÅ
Áï•Ë®òÊ≥ï„ÅåÂçòÁ¥î„Å™Ëâ≤„Å´„Å§„ÅÑ„Å¶„ÅØ„Çà„ÇäÁ∞°Âçò„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p><code>setFillStyle</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Åå„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÂºïÊï∞„Å®„Åó„Å¶Âèñ„Å£„Å¶
„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åì„Çå„ÅØ <code>Graphics.Canvas</code>„Åß„ÅØ„Çà„Åè„ÅÇ„Çã„Éë„Çø„Éº
„É≥„Åß„Åô„ÄÇ</p>
<p>ÊúÄÂæå„Å´„ÄÅ <code>fillPath</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰ΩøÁî®„Åó„Å¶Áü©ÂΩ¢„ÇíÂ°ó„Çä„Å§„Å∂„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>fillPath</code>„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code>„ÅØ„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Å®ÊèèÁîª„Åô„Çã„Éë„Çπ„ÇíÊßãÁØâ„Åô„ÇãÂà•„ÅÆ„Ç¢„ÇØ
„Ç∑„Éß„É≥„ÇíÂºïÊï∞„Å´„Å®„Çä„Åæ„Åô„ÄÇ„Éë„Çπ„ÅØ <code>rect</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„ÅÜ„Å®ÊßãÁØâ„Åô„Çã„Åì„Å®„Åå
„Åß„Åç„Åæ„Åô„ÄÇ <code>rect</code>„ÅØ„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Å®Áü©ÂΩ¢„ÅÆ‰ΩçÁΩÆÂèä„Å≥„Çµ„Ç§„Ç∫„Çí
Ê†ºÁ¥ç„Åô„Çã„É¨„Ç≥„Éº„Éâ„ÇíÂºïÊï∞„Å´„Å®„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>main„É¢„Ç∏„É•„Éº„É´„ÅÆÂêçÂâç„Å®„Åó„Å¶<code>Example.Rectangle</code>„Çí‰∏é„Åà„Å¶„Åì„ÅÆÈï∑ÊñπÂΩ¢„ÅÆ„Ç≥„Éº
„Éâ‰æã„Çí„Éì„É´„Éâ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>„Åù„Çå„Åß„ÅØ <code>html/index.html</code>„Éï„Ç°„Ç§„É´„ÇíÈñã„Åç„ÄÅ„Åì„ÅÆ„Ç≥„Éº„Éâ„Å´„Çà„Å£„Å¶canvas„ÅÆ‰∏≠
Â§Æ„Å´Èùí„ÅÑÂõõËßíÂΩ¢„ÅåÊèèÁîª„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="Ë°åÂ§öÁõ∏„ÇíÂà©Áî®„Åô„Çã"><a class="header" href="#Ë°åÂ§öÁõ∏„ÇíÂà©Áî®„Åô„Çã">Ë°åÂ§öÁõ∏„ÇíÂà©Áî®„Åô„Çã</a></h2>
<p>„Éë„Çπ„ÇíÊèèÁîª„Åô„ÇãÊñπÊ≥ï„ÅØ‰ªñ„Å´„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ <code>arc</code>Èñ¢Êï∞„ÅØÂÜÜÂºß„ÇíÊèèÁîª„Åó„Åæ„Åô„ÄÇ
<code>moveTo</code>Èñ¢Êï∞„ÄÅ <code>lineTo</code>Èñ¢Êï∞„ÄÅ <code>closePath</code>Èñ¢Êï∞„ÅØÊñ≠ÁâáÁöÑ„Å™Á∑öÂàÜ„ÅÆ„Éë„Çπ„ÇíÊèè
Áîª„Åô„Çã„ÅÆ„Å´‰Ωø„Åà„Åæ„Åô„ÄÇ</p>
<p><code>Shapes.purs</code>„Éï„Ç°„Ç§„É´„Åß„ÅØÈï∑ÊñπÂΩ¢„Å®ÂÜÜÂºß„Å®‰∏âËßíÂΩ¢„ÅÆ„ÄÅ3„Å§„ÅÆÂõ≥ÂΩ¢„ÇíÊèèÁîª„Åó„Å¶„ÅÑ
„Åæ„Åô„ÄÇ</p>
<p><code>rect</code>Èñ¢Êï∞„ÅØÂºïÊï∞„Å®„Åó„Å¶„É¨„Ç≥„Éº„Éâ„Çí„Å®„Çã„Åì„Å®„ÇíË¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇÂÆüÈöõ„Å´„ÅØ„ÄÅÈï∑Êñπ
ÂΩ¢„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÅØÂûãÂêåÁæ©Ë™û„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p><code>x</code>„Å® <code>y</code>„Éó„É≠„Éë„ÉÜ„Ç£„ÅØÂ∑¶‰∏äÈöÖ„ÅÆ‰ΩçÁΩÆ„ÇíË°®„Åó„Å¶„Åä„Çä„ÄÅ <code>w</code>„Å® <code>h</code>„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£
„ÅØ„Åù„Çå„Åû„ÇåÂπÖ„Å®È´ò„Åï„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>arc</code>Èñ¢Êï∞„Å´‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å§„É¨„Ç≥„Éº„Éâ„ÇíÊ∏°„Åó„Å¶Âëº„Å≥Âá∫„Åô„Å®„ÄÅÂÜÜÂºß„ÇíÊèèÁîª
„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ <code>x</code>„Å® <code>y</code>„Éó„É≠„Éë„ÉÜ„Ç£„ÅØÂºß„ÅÆ‰∏≠ÂøÉ„ÄÅ <code>r</code>„ÅØÂçäÂæÑ„ÄÅ <code>start</code>„Å® <code>end</code>„ÅØ
Âºß„ÅÆ‰∏°Á´Ø„ÅÆËßíÂ∫¶„ÇíÂºßÂ∫¶Ê≥ï„ÅßË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„Åì„ÅÆ„Ç≥„Éº„Éâ„ÅØ‰∏≠ÂøÉ„Åå<code>(300, 300)</code>„Å´‰∏≠ÂøÉ„Åå„ÅÇ„ÇäÂçäÂæÑ<code>50</code>„ÅÆÂÜÜÂºß„ÇíÂ°ó„ÇäÊΩ∞
„Åó„Åæ„Åô„ÄÇÂºß„ÅØ1ÂõûËª¢„ÅÆ„ÅÜ„Å°2/3 rdsÂàÜ„ÅÇ„Çä„Åæ„Åô„ÄÇÂçò‰ΩçÂÜÜ„ÅåÈâõÁõ¥ÊñπÂêë„Å´ÂèçËª¢„Åô„Çã„Åì
„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åì„Çå„ÅØyËª∏„Ååcanvas„ÅÆ‰∏ãÂêë„Åç„Å´Â¢óÂä†„Åô„Çã„Åü„ÇÅ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p><code>Number</code>Âûã„ÅÆ <code>x</code>„Å® <code>y</code>„Å®„ÅÑ„ÅÜ„Éó„É≠„Éë„ÉÜ„Ç£„Åå <code>Rectangle</code>„É¨„Ç≥„Éº„ÉâÂûã„Å®
<code>Arc</code>„É¨„Ç≥„Éº„ÉâÂûã„ÅÆ‰∏°Êñπ„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Å©„Å°„Çâ„ÅÆÂ†¥
Âêà„Åß„ÇÇ„Åì„ÅÆÁµÑ„ÅØÁÇπ„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„ÄÅ„ÅÑ„Åö„Çå„ÅÆ„É¨„Ç≥„Éº„ÉâÂûã„Å´„ÇÇÈÅ©Áî®„Åß„Åç
„Çã„ÄÅË°åÂ§öÁõ∏„Å™Èñ¢Êï∞„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅ <code>Shapes</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ <code>x</code>„Å® <code>y</code>„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÂ§âÊõ¥„ÅóÂõ≥ÂΩ¢„Çí
‰∏¶Ë°åÁßªÂãï„Åô„Çã <code>translate</code>Èñ¢Êï∞„ÇíÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>„Åì„ÅÆË°åÂ§öÁõ∏Âûã„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åì„Çå„ÅØ <code>triangle</code>„Åå <code>x</code>„Å® <code>y</code>„Å®„ÅÑ„ÅÜ„Éó
„É≠„Éë„ÉÜ„Ç£„Å®„ÄÅ<strong>„Åù„Çå„Å´Âä†„Åà„Å¶‰ªñ„ÅÆ‰ªªÊÑè„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£</strong>„ÇíÊåÅ„Å£„Åü„Å©„Çì„Å™„É¨„Ç≥„Éº„Éâ
„Åß„ÇÇÂèó„ÅëÂÖ•„Çå„ÄÅÂêå„ÅòÂûã„ÅÆ„É¨„Ç≥„Éº„Éâ„ÇíËøî„Åô„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíË®Ä„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ <code>x</code>„Éï„Ç£„Éº
„É´„Éâ„Å® <code>y</code>„Éï„Ç£„Éº„É´„Éâ„ÅØÊõ¥Êñ∞„Åï„Çå„Åæ„Åô„Åå„ÄÅÊÆã„Çä„ÅÆ„Éï„Ç£„Éº„É´„Éâ„ÅØÂ§âÊõ¥„Åï„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<p>„Åì„Çå„ÅØ<strong>„É¨„Ç≥„Éº„ÉâÊõ¥Êñ∞ÊßãÊñá</strong>„ÅÆ‰æã„Åß„Åô„ÄÇ <code>shape { ... }</code>„Å®„ÅÑ„ÅÜÂºè„ÅØ„ÄÅ
<code>shape</code>„ÇíÂÖÉ„Å´„Åó„Å¶„ÄÅÊã¨Âºß„ÅÆ‰∏≠„ÅßÊåáÂÆö„Åï„Çå„ÅüÂÄ§„ÅßÊõ¥Êñ∞„Åï„Çå„Åü„Éï„Ç£„Éº„É´„Éâ„ÇíÊåÅ„Å§
Êñ∞„Åü„Å™„É¨„Ç≥„Éº„Éâ„Çí‰Ωú„Çä„Åæ„Åô„ÄÇÊ≥¢Êã¨Âºß„ÅÆ‰∏≠„ÅÆÂºè„ÅØ„É¨„Ç≥„Éº„Éâ„É™„ÉÜ„É©„É´„ÅÆ„Çà„ÅÜ„Å™„Ç≥„É≠
„É≥„Åß„ÅØ„Å™„Åè„ÄÅÁ≠âÂè∑„Åß„É©„Éô„É´„Å®Âºè„ÇíÂå∫Âàá„Å£„Å¶Êõ∏„Åè„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<p><code>Shapes</code>„ÅÆ‰æã„Åã„Çâ„Çè„Åã„Çã„Çà„ÅÜ„Å´„ÄÅ <code>translate</code>Èñ¢Êï∞„ÅØ <code>Rectangle</code>„É¨„Ç≥„Éº„Éâ„Å®
<code>Arc</code>„É¨„Ç≥„Éº„ÉâÂèåÊñπ„Å´ÂØæ„Åó„Å¶‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Shape</code>„ÅÆ‰æã„ÅßÊèèÁîª„Åï„Çå„Çã3„Å§„ÇÅ„ÅÆÂûã„ÅØÂå∫ÂàÜ„Åã„Çâ„Å™„ÇãÁ∑öÂàÜ„ÅÆ„Éë„Çπ„Åß„Åô„ÄÇÂØæÂøú„Åô„Çã
„Ç≥„Éº„Éâ„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>„Åì„Åì„Åß„ÅØ3„Å§„ÅÆÈñ¢Êï∞„Åå‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>moveTo</code>„ÅØ„Éë„Çπ„ÅÆÁèæÂú®Âú∞„ÇíÊåáÂÆö„Åï„Çå„ÅüÂ∫ßÊ®ô„Å´ÁßªÂãï„Åó„Åæ„Åô„ÄÇ</li>
<li><code>lineTo</code>„ÅØÁèæÂú®Âú∞„Å®ÊåáÂÆö„Åï„Çå„ÅüÂ∫ßÊ®ô„ÅÆÈñì„ÅÆÁ∑öÂàÜ„ÇíÊèèÁîª„Åó„ÄÅÁèæÂú®Âú∞„ÇíÊõ¥Êñ∞„Åó„Åæ„Åô„ÄÇ</li>
<li><code>closePath</code>„ÅØÁèæÂú®Âú∞„Å®ÈñãÂßãÂú∞ÁÇπ„Å®„ÇíÁµê„Å∂Á∑öÂàÜ„ÇíÊèèÁîª„Åó„Å¶„Éë„Çπ„ÇíÂÆåÁµê„Åó„Åæ„Åô„ÄÇ</li>
</ul>
<p>„Åì„ÅÆ„Ç≥„Éº„ÉâÁâá„ÅÆÁµêÊûú„ÅØ‰∫åÁ≠âËæ∫‰∏âËßíÂΩ¢„ÅÆÂ°ó„ÇäÊΩ∞„Åó„Åß„Åô„ÄÇ</p>
<p>main„É¢„Ç∏„É•„Éº„É´„Å®„Åó„Å¶<code>Example.Shapes</code>„ÇíÊåáÂÆö„Åó„Å¶„ÄÅ„Åì„ÅÆ‰æã„Çí„Éì„É´„Éâ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>„Åù„Åó„Å¶„ÇÇ„ÅÜ‰∏ÄÂ∫¶ <code>html/index.html</code>„ÇíÈñã„Åç„ÄÅÁµêÊûú„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇcanvas
„Å´3„Å§„ÅÆÁï∞„Å™„ÇãÂõ≥ÂΩ¢„ÅåÊèèÁîª„Åï„Çå„Çã„ÅØ„Åö„Åß„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-41"><a class="header" href="#ÊºîÁøí-41">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ„Åì„Çå„Åæ„Åß„ÅÆ‰æã„ÅÆ„Åù„Çå„Åû„Çå„Å´„Å§„ÅÑ„Å¶„ÄÅ <code>strokePath</code>Èñ¢Êï∞„ÇÑ
<code>setStrokeStyle</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÁ∞°ÂçòÔºâÈñ¢Êï∞„ÅÆÂºïÊï∞„ÅÆÂÜÖÈÉ®„ÅÆdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„Å´„Çà„Çä„ÄÅ<code>fillPath</code>Èñ¢Êï∞„Å®
<code>strokePath</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶ÂÖ±ÈÄö„ÅÆ„Çπ„Çø„Ç§„É´„ÇíÊåÅ„Å§Ë§áÈõë„Å™„Éë„Çπ„ÇíÊèèÁîª„Åô„Çã„Åì„Å®„Åå
„Åß„Åç„Åæ„Åô„ÄÇÂêå„Åò <code>fillPath</code>Âëº„Å≥Âá∫„Åó„ÅßÈö£„ÇäÂêà„Å£„Åü2„Å§„ÅÆÁü©ÂΩ¢„ÇíÊèèÁîª„Åô„Çã„Çà„ÅÜ„Å´„ÄÅ
<code>Rectangle</code>„ÅÆ„Ç≥„Éº„Éâ‰æã„ÇíÂ§âÊõ¥„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÁ∑öÂàÜ„Å®ÂÜÜÂºß„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶
„Çí„ÄÅÂÜÜ„ÅÆÊâáÂΩ¢„ÇíÊèèÁîª„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÊ¨°„ÅÆ„Çà„ÅÜ„Å™2Ê¨°ÂÖÉ„ÅÆÁÇπ„ÇíË°®„Åô„É¨„Ç≥„Éº„Éâ„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>„Åì„Çå„ÅØ2Ê¨°ÂÖÉ„ÅÆÁÇπ„ÇíË°®Áèæ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Â§öÊï∞„ÅÆÁÇπ„Åã„Çâ„Å™„ÇãÈñâ„Åò„Åü„Éë„Çπ„ÇíÁ∑öÊèè„Åç„Åô„ÇãÈñ¢Êï∞ <code>renderPath</code>„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>Ê¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„ÇíËÄÉ„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÂºïÊï∞„Å®„Åó„Å¶ <code>1</code>„Åã„Çâ <code>0</code>„ÅÆÈñì„ÅÆ <code>Number</code>„Çí„Å®„Çä„ÄÅ <code>Point</code>„Çí
Ëøî„Åó„Åæ„Åô„ÄÇ <code>renderPath</code>Èñ¢Êï∞„ÇíÂà©Áî®„Åó„Å¶Èñ¢Êï∞ <code>f</code>„ÅÆ„Ç∞„É©„Éï„ÇíÊèè„Åè„Ç¢„ÇØ„Ç∑„Éß
„É≥„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åù„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØÊúâÈôêÂÄã„ÅÆÁÇπ„Çí <code>f</code>„Åã„Çâ„Çµ„É≥„Éó„É™„É≥
„Ç∞„Åô„Çã„Åì„Å®„Å´„Çà„Å£„Å¶Ëøë‰ºº„Åó„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<p>Èñ¢Êï∞ <code>f</code>„ÇíÂ§âÊõ¥„Åó„ÄÅÊßò„ÄÖ„Å™„Éë„Çπ„ÅåÊèèÁîª„Åï„Çå„Çã„Åì„Å®„ÇíÁ¢∫„Åã„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="ÁÑ°‰ΩúÁÇ∫„Å´ÂÜÜ„ÇíÊèè„Åè"><a class="header" href="#ÁÑ°‰ΩúÁÇ∫„Å´ÂÜÜ„ÇíÊèè„Åè">ÁÑ°‰ΩúÁÇ∫„Å´ÂÜÜ„ÇíÊèè„Åè</a></h2>
<p><code>Example/Random.purs</code>„Éï„Ç°„Ç§„É´„Å´„ÅØ2Á®ÆÈ°û„ÅÆÁï∞„Å™„ÇãÂâØ‰ΩúÁî®„ÅåÊ∑∑Âú®„Åó„Åü
<code>Effect</code>„É¢„Éä„Éâ„Çí‰Ωø„ÅÜ‰æã„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ1„Å§„ÅØ‰π±Êï∞ÁîüÊàê„Åß„ÄÅ„ÇÇ„ÅÜ1„Å§„ÅØ
canvas„ÅÆÊìç‰Ωú„Åß„Åô„ÄÇ„Åì„ÅÆ‰æã„Åß„ÅØÁÑ°‰ΩúÁÇ∫„Å´ÁîüÊàê„Åï„Çå„ÅüÂÜÜ„Çí„Ç≠„É£„É≥„Éê„Çπ„Å´100ÂÄãÊèè
Áîª„Åó„Åæ„Åô„ÄÇ</p>
<p><code>main</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ„Åì„Çå„Åæ„Åß„ÅÆ„Çà„ÅÜ„Å´„Ç∞„É©„Éï„Ç£„ÉÉ„ÇØ„Çπ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Å∏„ÅÆÂèÇÁÖß„Çí
ÂèñÂæó„Åó„ÄÅ„Çπ„Éà„É≠„Éº„ÇØ„Å®Â°ó„Çä„Å§„Å∂„Åó„Çπ„Çø„Ç§„É´„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>Ê¨°„ÅÆ„Ç≥„Éº„Éâ„Åß„ÅØ <code>for_</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶ <code>0</code>„Åã„Çâ <code>100</code>„Åæ„Åß„ÅÆÊï¥Êï∞„Å´„Å§„ÅÑ
„Å¶Áπ∞„ÇäËøî„Åó„Çí„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>„Åù„Çå„Åû„Çå„ÅÆÁπ∞„ÇäËøî„Åó„Åß„ÅØdoË®òÊ≥ï„Éñ„É≠„ÉÉ„ÇØ„ÅØ<code>0</code>„Å®<code>1</code>„ÅÆÈñì„Å´ÂàÜÂ∏É„Åô„Çã3„Å§„ÅÆ‰π±Êï∞
„ÇíÁîüÊàê„Åô„Çã„Åì„Å®„Åã„ÇâÂßã„Åæ„Çä„Åæ„Åô„ÄÇ„Åì„Çå„Çâ„ÅÆÊï∞„ÅØ <code>0</code>„Åã„Çâ <code>1</code>„ÅÆÈñì„Å´ÁÑ°‰ΩúÁÇ∫„Å´ÂàÜ
Â∏É„Åó„Å¶„Åä„Çä„ÄÅ„Åù„Çå„Åû„Çå <code>x</code>Â∫ßÊ®ô„ÄÅ <code>y</code>Â∫ßÊ®ô„ÄÅÂçäÂæÑ <code>r</code>„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>Ê¨°„ÅÆ„Ç≥„Éº„Éâ„Åß„ÅØ„Åù„Çå„Åû„Çå„ÅÆÂÜÜ„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åì„Çå„Çâ„ÅÆÂ§âÊï∞„Å´Âü∫„Å•„ÅÑ„Å¶ <code>Arc</code>„Çí‰ΩúÊàê
„Åó„ÄÅÊúÄÂæå„Å´ÁèæÂú®„ÅÆ„Çπ„Çø„Ç§„É´„Å´Âæì„Å£„Å¶ÂÜÜÂºß„ÅÆÂ°ó„Çä„Å§„Å∂„Åó„Å®Á∑öÊèè„ÅåË°å„Çè„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x                  : x * 600.0
         , y                  : y * 600.0
         , radius             : r * 50.0
         , start              : 0.0
         , end                : Number.tau
         , useCounterClockwise: false
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>main„É¢„Ç∏„É•„Éº„É´„Å®„Åó„Å¶<code>Example.Random</code>„ÇíÊåáÂÆö„Åó„Å¶„ÄÅ„Åì„ÅÆ‰æã„Çí„Éì„É´„Éâ„Åó„Åæ„Åó„Çá
„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>„ÇíÈñã„ÅÑ„Å¶„ÄÅÁµêÊûú„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<h2 id="Â∫ßÊ®ôÂ§âÊèõ"><a class="header" href="#Â∫ßÊ®ôÂ§âÊèõ">Â∫ßÊ®ôÂ§âÊèõ</a></h2>
<p>„Ç≠„É£„É≥„Éê„Çπ„ÅØÁ∞°Âçò„Å™Âõ≥ÂΩ¢„ÇíÊèèÁîª„Åô„Çã„Å†„Åë„ÅÆ„ÇÇ„ÅÆ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Ç≠„É£„É≥„Éê„Çπ„ÅØ
Â§âÊèõË°åÂàó„ÇíÊâ±„ÅÜ„Åì„Å®„Åå„Åß„Åç„ÄÅÂõ≥ÂΩ¢„ÅØÊèèÁîª„ÅÆÂâç„Å´ÂΩ¢Áä∂„ÇíÂ§âÂΩ¢„Åó„Å¶„Åã„ÇâÊèèÁîª„Åï„Çå„Åæ
„Åô„ÄÇÂõ≥ÂΩ¢„ÅØÂπ≥Ë°åÁßªÂãï„ÄÅÂõûËª¢„ÄÅÊã°Â§ßÁ∏ÆÂ∞è„ÄÅ„Åä„Çà„Å≥Êñú„ÇÅ„Å´Â§âÂΩ¢„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>canvas</code>„É©„Ç§„Éñ„É©„É™„Åß„ÅØ„Åì„Çå„Çâ„ÅÆÂ§âÊèõ„Çí‰ª•‰∏ã„ÅÆÈñ¢Êï∞„ÅßÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p><code>translate</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ <code>TranslateTransform</code>„É¨„Ç≥„Éº„Éâ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÅßÊåáÂÆö
„Åó„ÅüÂ§ß„Åç„Åï„Å†„ÅëÂπ≥Ë°åÁßªÂãï„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>rotate</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØÊúÄÂàù„ÅÆÂºïÊï∞„ÅßÊåáÂÆö„Åï„Çå„Åü„É©„Ç∏„Ç¢„É≥„ÅÆÂÄ§„Å´Âøú„Åò„Å¶ÂéüÁÇπ„Çí‰∏≠
ÂøÉ„Å®„Åó„ÅüÂõûËª¢„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>scale</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØÂéüÁÇπ„Çí‰∏≠ÂøÉ„Å®„Åó„Å¶Êã°Â§ßÁ∏ÆÂ∞è„Åó„Åæ„Åô„ÄÇ <code>ScaleTransform</code>„É¨
„Ç≥„Éº„Éâ„ÅØ <code>X</code>Ëª∏„Å® <code>y</code>Ëª∏„Å´Ê≤ø„Å£„ÅüÊã°Â§ßÁéá„ÇíÊåáÂÆö„Åô„Çã„ÅÆ„Å´‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂæå„ÅÆ <code>transform</code>„ÅØ„Åì„ÅÆ4„Å§„ÅÆ„ÅÜ„Å°„ÅßÊúÄ„ÇÇ‰∏ÄËà¨ÁöÑ„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß„Åô„ÄÇ„Åì„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØË°åÂàó„Å´Âæì„Å£„Å¶„Ç¢„Éï„Ç£„É≥Â§âÊèõ„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Çâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÂëº„Å≥Âá∫„Åï„Çå„ÅüÂæå„Å´ÊèèÁîª„Åï„Çå„ÇãÂõ≥ÂΩ¢„ÅØ„ÄÅËá™ÂãïÁöÑ„Å´ÈÅ©Âàá„Å™Â∫ß
Ê®ôÂ§âÊèõ„ÅåÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>ÂÆüÈöõ„Å´„ÅØ„ÄÅ„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÅÆ„Åù„Çå„Åû„Çå„ÅÆ‰ΩúÁî®„ÅØ„ÄÅ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÁèæÂú®„ÅÆÂ§âÊèõË°åÂàó
„Å´ÂØæ„Åó„Å¶Â§âÊèõË°åÂàó„Çí<strong>Âè≥„Åã„Çâ‰πóÁÆó</strong>„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ„Å§„Åæ„Çä„ÄÅ„ÇÇ„Åó„ÅÇ„Çã‰ΩúÁî®„ÅÆÂ§â
Êèõ„Çí„Åó„Å¶„ÅÑ„Åè„Å®„ÄÅ„Åù„ÅÆ‰ΩúÁî®„ÅØÂÆüÈöõ„Å´„ÅØÈÄÜÈ†Ü„Å´ÈÅ©Áî®„Åï„Çå„Å¶„ÅÑ„Åç„Åæ„ÅôÔºö</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>„Åì„ÅÆ‰∏ÄÈÄ£„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ‰ΩúÁî®„Åß„ÅØ„ÄÅ„Åæ„Åö„Ç∑„Éº„É≥„ÅåÂõûËª¢„Åï„Çå„ÄÅ„Åù„Çå„Åã„ÇâÊã°Â§ßÁ∏ÆÂ∞è
„Åï„Çå„ÄÅÊúÄÂæå„Å´Âπ≥Ë°åÁßªÂãï„Åï„Çå„Åæ„Åô„ÄÇ</p>
<h2 id="„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆ‰øùÂ≠ò"><a class="header" href="#„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆ‰øùÂ≠ò">„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆ‰øùÂ≠ò</a></h2>
<p>Â§âÊèõ„ÇíÈÅ©Áî®„Åó„Å¶„Ç∑„Éº„É≥„ÅÆ‰∏ÄÈÉ®„ÇíÊèèÁîª„Åó„ÄÅ„Åù„Çå„Åã„Çâ„Åù„ÅÆÂ§âÊèõ„ÇíÂÖÉ„Å´Êàª„Åô„ÄÅ„Å®„ÅÑ„ÅÜ
‰Ωø„ÅÑÊñπ„ÅØ„Çà„Åè„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>Canvas API„Å´„ÅØ„Ç≠„É£„É≥„Éê„Çπ„ÅÆÁä∂ÊÖã„ÅÆ<strong>„Çπ„Çø„ÉÉ„ÇØ</strong>„ÇíÊìç‰Ωú„Åô„Çã <code>save</code>„Å®
<code>restore</code>„É°„ÇΩ„ÉÉ„Éâ„ÅåÂÇô„Çè„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ <code>canvas</code>„Åß„ÅØ„Åì„ÅÆÊ©üËÉΩ„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢
Êï∞„Åß„É©„ÉÉ„Éó„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p><code>save</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØÁèæÂú®„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÁä∂ÊÖãÔºàÁèæÂú®„ÅÆÂ§âÊèõË°åÂàó„ÇÑÊèèÁîª„Çπ„Çø„Ç§
„É´Ôºâ„Çí„Çπ„Çø„ÉÉ„ÇØ„Å´„Éó„ÉÉ„Ç∑„É•„Åó„ÄÅ <code>restore</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ„Çπ„Çø„ÉÉ„ÇØ„ÅÆ‰∏ÄÁï™‰∏ä„ÅÆÁä∂
ÊÖã„Çí„Éù„ÉÉ„Éó„Åó„ÄÅ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÁä∂ÊÖã„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Çâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´„Çà„Çä„ÄÅÁèæÂú®„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò„Åó„ÄÅ„ÅÑ„Çç„ÅÑ„Çç„Å™„Çπ„Çø„Ç§„É´„ÇÑÂ§âÊèõ
„ÇíÈÅ©Áî®„Åó„ÄÅÂéüÂßãÁöÑ„Å™Âõ≥ÂΩ¢„ÇíÊèèÁîª„Åó„ÄÅÊúÄÂæå„Å´ÂÖÉ„ÅÆÂ§âÊèõ„Å®Áä∂ÊÖã„ÇíÂæ©ÂÖÉ„Åô„Çã„Åì„Å®„ÅåÂèØ
ËÉΩ„Å´„Å™„Çä„Åæ„Åô„ÄÇ‰æã„Åà„Å∞„ÄÅÊ¨°„ÅÆÈñ¢Êï∞„ÅØ„ÅÑ„Åè„Å§„Åã„ÅÆ„Ç≠„É£„É≥„Éê„Çπ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å„Åó
„Åæ„Åô„Åå„ÄÅ„Åù„ÅÆÂâç„Å´ÂõûËª¢„ÇíÈÅ©Áî®„Åó„ÄÅ„Åù„ÅÆ„ÅÇ„Å®„Å´Â§âÊèõ„ÇíÂæ©ÂÖÉ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>„Åì„ÅÜ„ÅÑ„Å£„Åü„Çà„Åè„ÅÇ„Çã‰Ωø„ÅÑ„Åã„Åü„ÅÆÈ´òÈöéÈñ¢Êï∞„ÇíÂà©Áî®„Åó„ÅüÊäΩË±°Âåñ„Å®„Åó„Å¶„ÄÅ
<code>canvas</code>„É©„Ç§„Éñ„É©„É™„Åß„ÅØÂÖÉ„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÁä∂ÊÖã„Çí‰øùÂ≠ò„Åó„Å§„Å§„ÅÑ„Åè„Å§„Åã„ÅÆ„Ç≠„É£„É≥
„Éê„Çπ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å„Åô„Çã <code>withContext</code>Èñ¢Êï∞„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p><code>withContext</code>„Çí‰Ωø„ÅÜ„Å®„ÄÅÂÖà„Åª„Å©„ÅÆ <code>rotated</code>Èñ¢Êï∞„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êõ∏„ÅçÊèõ„Åà„Çã„Åì
„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="Â§ßÂüüÁöÑ„Å™Â§âÊõ¥ÂèØËÉΩÁä∂ÊÖã"><a class="header" href="#Â§ßÂüüÁöÑ„Å™Â§âÊõ¥ÂèØËÉΩÁä∂ÊÖã">Â§ßÂüüÁöÑ„Å™Â§âÊõ¥ÂèØËÉΩÁä∂ÊÖã</a></h2>
<p>„Åì„ÅÆÁØÄ„Åß„ÅØ <code>refs</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰Ωø„Å£„Å¶ <code>Effect</code>„É¢„Éä„Éâ„ÅÆÂà•„ÅÆ‰ΩúÁî®„Å´„Å§„ÅÑ„Å¶ÂÆü
Êºî„Åó„Å¶„Åø„Åæ„Åô„ÄÇ</p>
<p><code>Effect.Ref</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØÂ§ßÂüüÁöÑ„Å´Â§âÊõ¥ÂèØËÉΩ„Å™ÂèÇÁÖß„ÅÆ„Åü„ÇÅ„ÅÆÂûãÊßãÁØâÂ≠ê„ÄÅ„Åä„Çà
„Å≥Èñ¢ÈÄ£„Åô„Çã‰ΩúÁî®„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>Âûã<code>Ref a</code>„ÅÆÂÄ§„ÅØÂûã<code>a</code>„ÅÆÂÄ§„ÇíÂê´„ÇÄÂèØÂ§âÂèÇÁÖß„Çª„É´„Åß„ÅÇ„Çä„ÄÅÂ§ßÂüüÁöÑ„Å™Â§âÊõ¥„ÇíËøΩË∑°„Åô
„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ„Åù„ÅÜ„ÅÑ„Å£„Åü„Çè„Åë„Åß„Åì„Çå„ÅØÂ∞ë„Åó„Å†„Åë‰Ωø„ÅÜÂàÜ„Å´Áïô„ÇÅ„Å¶„Åä„Åè„Åπ„Åç
„Åß„Åô„ÄÇ</p>
<p><code>Example/Refs.purs</code>„Éï„Ç°„Ç§„É´„Å´„ÅØ <code>canvas</code>Ë¶ÅÁ¥†‰∏ä„ÅÆ„Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØ„ÇíËøΩË∑°„Åô
„Çã„ÅÆ„Å´ <code>Ref</code>‰ΩúÁî®„Çí‰ΩøÁî®„Åô„Çã‰æã„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç≥„Éº‚Äã‚Äã„Éâ„Åß„ÅØÊúÄÂàù„Å´ <code>new</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶ÂÄ§ <code>0</code>„ÇíÂê´„ÇÄÊñ∞„Åó„ÅÑÂèÇÁÖß„Çí‰Ωú
Êàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„ÅÆÂÜÖÈÉ®„Åß„ÅØ„ÄÅ <code>modify</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰ΩøÁî®„Åó„Å¶„ÇØ„É™„ÉÉ
„ÇØÊï∞„ÇíÊõ¥Êñ∞„Åó„ÄÅÊõ¥Êñ∞„Åï„Çå„ÅüÂÄ§„ÅåËøî„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p><code>render</code>Èñ¢Êï∞„Åß„ÅØ„ÄÅ„ÇØ„É™„ÉÉ„ÇØÊï∞„Å´Âøú„Åò„Å¶Â§âÊèõ„ÇíÁü©ÂΩ¢„Å´ÈÅ©Áî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Number.sin (toNumber count * Number.tau / 8.0) + 1.5
    let scaleY = Number.sin (toNumber count * Number.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Number.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>„Åì„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß„ÅØÂÖÉ„ÅÆÂ§âÊèõ„Çí‰øùÂ≠ò„Åô„Çã„Åü„ÇÅ„Å´ <code>withContext</code>„Çí‰ΩøÁî®„Åó„Å¶„Åä„Çä„ÄÅ
„Åù„Çå„Åã„Çâ‰∏ÄÈÄ£„ÅÆÂ§âÊèõ„ÇíÈÅ©Áî®„Åó„Å¶„ÅÑ„Åæ„ÅôÔºàÂ§âÊèõ„Åå‰∏ã„Åã„Çâ‰∏ä„Å´ÈÅ©Áî®„Åï„Çå„Çã„Åì„Å®„ÇíÊÄù
„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ„ÄÇ</p>
<ul>
<li>Áü©ÂΩ¢„ÅØ<code>(-100, -100)</code>„Å†„ÅëÂπ≥Ë°åÁßªÂãï„Åó‰∏≠ÂøÉ„ÅåÂéüÁÇπ„Å´Êù•„Åæ„Åô„ÄÇ</li>
<li>Áü©ÂΩ¢„ÅåÂéüÁÇπ„Çí‰∏≠ÂøÉ„Å´Êã°Â§ß„Åï„Çå„Åæ„Åô„ÄÇ</li>
<li>Áü©ÂΩ¢„ÅåÂéüÁÇπ„Çí‰∏≠ÂøÉ„Å´<code>10</code>„ÅÆÂÄçÊï∞ÂàÜ„ÅÆËßíÂ∫¶„ÅßÂõûËª¢„Åó„Åæ„Åô„ÄÇ</li>
<li>Áü©ÂΩ¢„Åå<code>(300, 300)</code>„Å†„ÅëÂπ≥Ë°åÁßªÂãï„Åó‰∏≠ÂøÉ„Ååcanvas„ÅÆ‰∏≠ÂøÉ„Å´Êù•„Åæ„Åô„ÄÇ</li>
</ul>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ‰æã„Çí„Éì„É´„Éâ„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>„Éï„Ç°„Ç§„É´„ÇíÈñã„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ‰ΩïÂ∫¶„Åã„Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„ÉÉ
„ÇØ„Åô„Çã„Å®„ÄÅ„Ç≠„É£„É≥„Éê„Çπ„ÅÆ‰∏≠ÂøÉ„ÅÆÂë®„Çä„ÇíÂõûËª¢„Åô„ÇãÁ∑ë„ÅÆÂõõËßíÂΩ¢„ÅåË°®Á§∫„Åï„Çå„Çã„ÅØ„Åö„Åß
„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-42"><a class="header" href="#ÊºîÁøí-42">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ„Éë„Çπ„ÅÆÁ∑öÊèè„Å®Â°ó„ÇäÊΩ∞„Åó„ÇíÂêåÊôÇ„Å´Ë°å„ÅÜÈ´òÈöéÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åù„ÅÆ
Èñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶ <code>Random.purs</code>‰æã„ÇíÊõ∏„ÅçÁõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ<code>Random</code>‰ΩúÁî®„Å® <code>Dom</code>‰ΩúÁî®„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ„Éû„Ç¶„Çπ„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åü„Å®„Åç
„Å´„ÄÅ„Ç≠„É£„É≥„Éê„Çπ„Å´ÁÑ°‰ΩúÁÇ∫„Å™‰ΩçÁΩÆ„ÄÅËâ≤„ÄÅÂçäÂæÑ„ÅÆÂÜÜ„ÇíÊèèÁîª„Åô„Çã„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Çí
‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâ„Ç∑„Éº„É≥„ÇíÊåáÂÆö„Åï„Çå„ÅüÂ∫ßÊ®ô„Çí‰∏≠ÂøÉ„Å´ÂõûËª¢„Åô„ÇãÈñ¢Êï∞„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>„Éí„É≥„Éà</strong>ÔºöÊúÄÂàù„Å´„Ç∑„Éº„É≥„ÇíÂéüÁÇπ„Åæ„ÅßÂπ≥Ë°åÁßªÂãï„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</li>
</ol>
<h2 id="l-system"><a class="header" href="#l-system">L-System</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆÊúÄÂæå„ÅÆ‰æã„Å®„Åó„Å¶„ÄÅ <code>canvas</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Çí‰ΩøÁî®„Åó„Å¶<strong>L-system</strong>
(Lindenmayer system) „ÇíÊèèÁîª„Åô„ÇãÈñ¢Êï∞„ÇíË®òËø∞„Åó„Åæ„Åô„ÄÇ</p>
<p>L-System„ÅØ<strong>„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà</strong>„ÄÅ„Å§„Åæ„ÇäÂàùÊúüÁä∂ÊÖã„Å®„Å™„Çã„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅÆÊñá
Â≠óÂàó„Å®„ÄÅ<strong>ÁîüÊàêË¶èÂâá</strong>„ÅÆÈõÜÂêà„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇÂêÑÁîüÊàêË¶èÂâá„ÅØ„ÄÅ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ
„Éà„ÅÆÊñáÂ≠ó„Çí„Å®„Çä„ÄÅ„Åù„Çå„ÇíÁΩÆ„ÅçÊèõ„Åà„ÇãÊñáÂ≠ó„ÅÆÈÖçÂàó„ÇíËøî„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆÂá¶ÁêÜ„ÅØÊñáÂ≠ó„ÅÆ
ÂàùÊúüÈÖçÂàó„Åã„ÇâÂßã„Åæ„Çä„ÄÅË§áÊï∞ÂõûÁπ∞„ÇäËøî„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>„ÇÇ„Åó„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅÆÂêÑÊñáÂ≠ó„Ååcanvas‰∏ä„ÅßÂÆüË°å„Åï„Çå„ÇãÂëΩ‰ª§„Å®ÂØæÂøú‰ªò„Åë„Çâ„Çå„Å¶„ÅÑ
„Çå„Å∞„ÄÅ„Åù„ÅÆÊåáÁ§∫„Å´È†ÜÁï™„Å´Âæì„ÅÜ„Åì„Å®„ÅßL-System„ÇíÊèèÁîª„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åü„Å®„Åà„Å∞„ÄÅ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅåÊñáÂ≠ó <code>L</code>ÔºàÂ∑¶ÂõûËª¢Ôºâ„ÄÅ <code>R</code>ÔºàÂè≥ÂõûËª¢Ôºâ„ÄÅ <code>F</code>ÔºàÂâç
ÈÄ≤Ôºâ„ÅßÊßãÊàê„Åï„Çå„Å¶„ÅÑ„Åü„Å®„Åó„Åæ„Åô„ÄÇ„Åæ„Åü„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÁîüÊàêË¶èÂâá„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>ÈÖçÂàó &quot;FRRFRRFRR&quot; „Åã„ÇâÂßã„ÇÅ„Å¶Âá¶ÁêÜ„ÇíÁπ∞„ÇäËøî„Åô„Å®„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™ÁµåÈÅé„ÇíËæø„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>„Åì„ÅÆÂëΩ‰ª§Áæ§„Å´ÂØæÂøú„Åô„ÇãÁ∑öÂàÜ„Éë„Çπ„Çí„Éó„É≠„ÉÉ„Éà„Åô„Çã„Å®„ÄÅ<strong>„Ç≥„ÉÉ„ÉõÊõ≤Á∑ö</strong>„Å®Âëº„Å∞„Çå„Çã
Êõ≤Á∑ö„Å´Ëøë‰ºº„Åó„Åæ„Åô„ÄÇÂèçÂæ©ÂõûÊï∞„ÇíÂ¢ó„ÇÑ„Åô„Å®„ÄÅÊõ≤Á∑ö„ÅÆËß£ÂÉèÂ∫¶„ÅåÂ¢óÂä†„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØÂûã„Å®Èñ¢Êï∞„ÅÆË®ÄË™û„Å∏„Å®„Åì„Çå„ÇíÁøªË®≥„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅÆÊñáÂ≠ó„ÅØ‰ª•‰∏ã„ÅÆADT„ÅßË°®Áèæ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>„Åì„ÅÆ„Éá„Éº„ÇøÂûã„Åß„ÅØ„ÄÅ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅÆÊñáÂ≠ó„Åî„Å®„Å´1„Å§„Åö„Å§„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÊñáÂ≠ó„ÅÆÂàùÊúüÈÖçÂàó„ÅØ„Å©„ÅÆ„Çà„ÅÜ„Å´Ë°®„Åó„Åü„Çâ„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇÂçò„Å™„Çã„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà
„ÅÆÈÖçÂàó„Åß„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ„Åì„Çå„Çí <code>Sentence</code>„Å®Âëº„Å∂„Åì„Å®„Å´„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>ÁîüÊàêË¶èÂâá„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´<code>Letter</code>„Åã„Çâ <code>Sentence</code>„Å∏„ÅÆÈñ¢Êï∞„Å®„Åó„Å¶Ë°®„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>„Åì„Çå„ÅØ„Åæ„Åï„Å´‰∏äË®ò„ÅÆ‰ªïÊßò„Çí„Åù„ÅÆ„Åæ„ÅæÊõ∏„ÅçÂÜô„Åó„Åü„ÇÇ„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Åì„Çå„Åß„ÄÅ„Åì„ÅÆÂΩ¢Âºè„ÅÆ‰ªïÊßò„ÇíÂèó„ÅëÂèñ„Çäcanvas„Å´ÊèèÁîª„Åô„ÇãÈñ¢Êï∞ <code>lsystem</code>„ÇíÂÆüË£Ö„Åô
„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ <code>lsystem</code>„ÅØ„Å©„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åπ„Åç„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅØÂàùÊúüÁä∂ÊÖã <code>initial</code>„Å®ÁîüÊàêË¶èÂâá <code>productions</code>„ÅÆ„Çà„ÅÜ„Å™ÂÄ§„Å†„Åë„Åß„Å™
„Åè„ÄÅ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅÆÊñáÂ≠ó„Çícanvas„Å´ÊèèÁîª„Åô„ÇãÈñ¢Êï∞„ÇíÂºïÊï∞„Å´Âèñ„ÇãÂøÖË¶Å„Åå„ÅÇ
„Çä„Åæ„Åô„ÄÇ</p>
<p><code>lsystem</code>„ÅÆÂûã„ÅÆÊúÄÂàù„ÅÆÂ§ß„Åæ„Åã„Å™Ë®≠Ë®à„ÅØ‰ª•‰∏ã„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>ÊúÄÂàù„ÅÆ2„Å§„ÅÆÂºïÊï∞„ÅÆÂûã„ÅØ„ÄÅÂÄ§ <code>initial</code>„Å® <code>productions</code>„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>3Áï™ÁõÆ„ÅÆÂºïÊï∞„ÅØ„ÄÅ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅÆÊñáÂ≠ó„ÇíÂèñ„Çä„ÄÅcanvas‰∏ä„ÅÆ„ÅÑ„Åè„Å§„Åã„ÅÆ„Ç¢„ÇØ„Ç∑„Éß
„É≥„ÇíÂÆüË°å„Åô„Çã„Åì„Å®„Å´„Çà„Å£„Å¶<strong>ÁøªË®≥</strong>„Åô„ÇãÈñ¢Êï∞„ÇíË°®„Åó„Åæ„Åô„ÄÇ„Åì„ÅÆ‰æã„Åß„ÅØ„ÄÅÊñáÂ≠ó
<code>L</code>„ÅØÂ∑¶ÂõûËª¢„ÄÅÊñáÂ≠ó <code>R</code>„ÅßÂè≥ÂõûËª¢„ÄÅÊñáÂ≠ó <code>F</code>„ÅØÂâçÈÄ≤„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂæå„ÅÆÂºïÊï∞„ÅØ„ÄÅÂÆüË°å„Åó„Åü„ÅÑÁîüÊàêË¶èÂâá„ÅÆÁπ∞„ÇäËøî„ÅóÂõûÊï∞„ÇíË°®„ÅôÊï∞„Åß„Åô„ÄÇ</p>
<p>ÊúÄÂàù„Å´Ê∞ó‰ªò„Åè„Åì„Å®„ÅØ„ÄÅ„Åì„ÅÆ<code>lsystem</code>Èñ¢Êï∞„ÅØ1„Å§„ÅÆÂûã<code>Letter</code>„Å´ÂØæ„Åó„Å¶„ÅÆ„ÅøÂãï‰Ωú
„Åô„Çã„ÅÆ„Åß„Åô„Åå„ÄÅ„Å©„Çì„Å™„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„Å´„Å§„ÅÑ„Å¶„ÇÇÊ©üËÉΩ„Åô„Åπ„Åç„Åß„Åô„Åã„Çâ„ÄÅ„Åì„ÅÆÂûã
„ÅØ„ÇÇ„Å£„Å®‰∏ÄËà¨Âåñ„Åï„Çå„Çã„Åπ„Åç„Åß„Åô„ÄÇ„Åù„Çå„Åß„ÅØ„ÄÅÈáèÂ≠êÂåñ„Åï„Çå„ÅüÂûãÂ§âÊï∞ <code>a</code>„Å´„Å§„ÅÑ„Å¶„ÄÅ
<code>Letter</code>„Å® <code>Sentence</code>„Çí <code>a</code>„Å® <code>Array a</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>Ê¨°„Å´Ê∞ó‰ªò„Åè„Åì„Å®„Å®„Åó„Å¶„ÅØ„ÄÅ„ÄåÂ∑¶ÂõûËª¢„Äç„Å®„ÄåÂè≥ÂõûËª¢„Äç„ÅÆ„Çà„ÅÜ„Å™ÂëΩ‰ª§„ÇíÂÆüË£Ö„Åô„Çã„Åü
„ÇÅ„Å´„ÅØ„ÄÅ„ÅÑ„Åè„Å§„Åã„ÅÆÁä∂ÊÖã„ÇíÁÆ°ÁêÜ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂÖ∑‰ΩìÁöÑ„Å´Ë®Ä„Åà„Å∞„ÄÅ„Åù„ÅÆÊôÇ
ÁÇπ„Åß„Éë„Çπ„ÅåÂêë„ÅÑ„Å¶„ÅÑ„ÇãÊñπÂêë„ÇíÁä∂ÊÖã„Å®„Åó„Å¶ÊåÅ„Åü„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇË®àÁÆó„ÇíÈÄö„Åò
„Å¶Áä∂ÊÖã„ÇíÈñ¢Êï∞„Å´Ê∏°„Åô„Çà„ÅÜ„Å´Â§âÊõ¥„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„Åì„Åß„ÇÇ <code>lsystem</code>Èñ¢Êï∞
„ÅØÁä∂ÊÖã„Åå„Å©„Çì„Å™Âûã„Åß„ÇÇÂãï‰Ωú„Åó„Åü„Åª„ÅÜ„Åå„Çà„ÅÑ„ÅÆ„Åß„ÄÅÂûãÂ§âÊï∞ <code>s</code>„Çí‰ΩøÁî®„Åó„Å¶„Åù„Çå„Çí
Ë°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Âûã <code>s</code>„ÇíËøΩÂä†„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÅÆ„ÅØ3ÁÆáÊâÄ„Åß„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>„Åæ„ÅöËøΩÂä†„ÅÆÂºïÊï∞„ÅÆÂûã„Å®„Åó„Å¶ <code>lsystem</code>„Å´Âûã <code>s</code>„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆÂºïÊï∞
„ÅØL-System„ÅÆÂàùÊúüÁä∂ÊÖã„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Âûã <code>s</code>„ÅØÂºïÊï∞„Å´„ÇÇÁèæ„Çå„Åæ„Åô„Åå„ÄÅÁøªË®≥Èñ¢Êï∞Ôºà<code>lsystem</code>„ÅÆÁ¨¨3ÂºïÊï∞Ôºâ„ÅÆËøî„ÇäÂÄ§„ÅÆÂûã„Å®
„Åó„Å¶„ÇÇÁèæ„Çå„Åæ„Åô„ÄÇÁøªË®≥Èñ¢Êï∞„ÅØ‰ªä„ÅÆ„Å®„Åì„Çç„ÄÅÂºïÊï∞„Å®„Åó„Å¶L-System„ÅÆÁèæÂú®„ÅÆÁä∂ÊÖã„Çí
Âèó„ÅëÂèñ„Çä„ÄÅËøî„ÇäÂÄ§„Å®„Åó„Å¶Êõ¥Êñ∞„Åï„Çå„ÅüÊñ∞„Åó„ÅÑÁä∂ÊÖã„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ‰æã„ÅÆÂ†¥Âêà„Åß„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„Çí‰Ωø„Å£„Å¶Áä∂ÊÖã„ÇíË°®„ÅôÂûã„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç
„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>„Éó„É≠„Éë„ÉÜ„Ç£ <code>x</code>„Å® <code>y</code>„ÅØ„Éë„Çπ„ÅÆÁèæÂú®„ÅÆ‰ΩçÁΩÆ„ÇíË°®„Åó„Å¶„Åä„Çä„ÄÅ„Éó„É≠„Éë„ÉÜ„Ç£
<code>theta</code>„ÅØ„Éë„Çπ„ÅÆÁèæÂú®„ÅÆÂêë„Åç„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ„É©„Ç∏„Ç¢„É≥„ÅßË°®„Åï„Çå„ÅüÊ∞¥Âπ≥
Á∑ö„Å´ÂØæ„Åô„Çã„Éë„Çπ„ÅÆËßíÂ∫¶„Å®„Åó„Å¶ÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Ç∑„Çπ„ÉÜ„É†„ÅÆÂàùÊúüÁä∂ÊÖã„Å®„Åó„Å¶„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÊåáÂÆö„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>„Åù„Çå„Åß„ÅØ„ÄÅ <code>lsystem</code>Èñ¢Êï∞„ÇíÂÆüË£Ö„Åó„Å¶„Åø„Åæ„Åô„ÄÇÂÆöÁæ©„ÅØ„Å®„Å¶„ÇÇÂçòÁ¥î„Åß„ÅÇ„Çã„Åì„Å®„Åå
„Çè„Åã„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p><code>lsystem</code>„ÅØÁ¨¨4ÂºïÊï∞„ÅÆÂÄ§ÔºàÂûã<code>Int</code>Ôºâ„Å´Âøú„Åò„Å¶ÂÜçÂ∏∞„Åô„Çã„ÅÆ„ÅåËâØ„Åï„Åù„ÅÜ„Åß„Åô„ÄÇÂÜçÂ∏∞„ÅÆÂêÑ„Çπ„ÉÜ„ÉÉ„Éó„Åß„ÅØ„ÄÅÁîüÊàêË¶èÂâá„Å´Âæì„Å£„Å¶Áä∂ÊÖã„ÅåÊõ¥Êñ∞„Åï„Çå„ÄÅÁèæÂú®„ÅÆÊñá„ÅåÂ§âÂåñ„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ„Åì„ÅÆ„Åì„Å®„ÇíÂøµÈ†≠„Å´ÁΩÆ„Åç„Å§„Å§„ÄÅ„Åæ„Åö„ÅØÈñ¢Êï∞„ÅÆÂºïÊï∞„ÅÆÂêçÂâç„ÇíÂ∞éÂÖ•„Åó„Å¶„ÄÅË£úÂä©Èñ¢Êï∞„Å´Âá¶ÁêÜ„ÇíÁßªË≠≤„Åô„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p><code>go</code>Èñ¢Êï∞„ÅØÁ¨¨2ÂºïÊï∞„Å´Âøú„Åò„Å¶ÂÜçÂ∏∞„Åô„Çã„Åì„Å®„ÅßÂãï„Åç„Åæ„Åô„ÄÇÂ†¥ÂêàÂàÜ„Åë„ÅØ2„Å§„Åß„ÅÇ„Çä„ÄÅ
<code>n</code>„Åå„Çº„É≠„Åß„ÅÇ„Çã„Å®„Åç„Å® <code>n</code>„Åå„Çº„É≠„Åß„Å™„ÅÑ„Å®„Åç„Åß„Åô„ÄÇ</p>
<p>1„Å§ÁõÆ„ÅÆÂ†¥Âêà„ÅØÂÜçÂ∏∞„ÅØÂÆå‰∫Ü„Åó„ÄÅÁøªË®≥Èñ¢Êï∞„Å´Âøú„Åò„Å¶ÁèæÂú®„ÅÆÊñá„ÇíÁøªË®≥„Åó„Åæ„Åô„ÄÇÂûã
<code>Array a</code>„ÅÆÊñá„ÄÅÂûã <code>s</code>„ÅÆÁä∂ÊÖã„ÄÅÂûã <code>s -&gt; a -&gt; Effect s</code>„ÅÆÈñ¢Êï∞„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰ª•ÂâçÂÆöÁæ©„Åó„Åü <code>foldM</code>„Åß„ÇÑ„Å£„Åü„Åì„Å®„ÅÆ„Çà„ÅÜ„Å´ËÅû„Åì„Åà„Åæ„Åô„ÄÇ„Åì„ÅÆÈñ¢Êï∞„ÅØ
<code>control</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅßÊâã„Å´ÂÖ•„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>„Çº„É≠„Åß„Å™„ÅÑÂ†¥Âêà„Åß„ÅØ„Å©„ÅÜ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ„Åù„ÅÆÂ†¥Âêà„ÅØ„ÄÅÂçò„Å´ÁîüÊàêË¶èÂâá„ÇíÁèæÂú®„ÅÆÊñá„ÅÆ
„Åù„Çå„Åû„Çå„ÅÆÊñáÂ≠ó„Å´ÈÅ©Áî®„Åó„Å¶„ÄÅ„Åù„ÅÆÁµêÊûú„ÇíÈÄ£Áµê„Åó„ÄÅ„Åù„Åó„Å¶ÂÜçÂ∏∞ÁöÑ„Å´<code>go</code>„ÇíÂëº„Å≥Âá∫
„Åô„Åì„Å®„Å´„Çà„Å£„Å¶Áπ∞„ÇäËøî„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>„Åì„Çå„Å†„Åë„Åß„ÅôÔºÅ<code>foldM</code>„ÇÑ <code>concatMap</code>„ÅÆ„Çà„ÅÜ„Å™È´òÈöéÈñ¢Êï∞„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Åì„ÅÆ„Çà„ÅÜ
„Å´„Ç¢„Ç§„Éá„Ç¢„ÇíÁ∞°ÊΩî„Å´Ë°®Áèæ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Åó„Åã„Åó„ÄÅË©±„ÅØ„Åì„Çå„ÅßÁµÇ„Çè„Çä„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„Åì„Åì„Åß‰∏é„Åà„ÅüÂûã„ÅØ„ÄÅÂÆüÈöõ„ÅØ„Åæ„Å†Áâπ
ÊÆäÂåñ„Åï„Çå„Åô„Åé„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆÂÆöÁæ©„Åß„ÅØcanvas„ÅÆÊìç‰Ωú„ÅåÂÆüË£Ö„ÅÆ„Å©„Åì„Å´„ÇÇ‰Ωø„Çè„Çå„Å¶
„ÅÑ„Å™„ÅÑ„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åù„Çå„Å´„ÄÅ„Åæ„Å£„Åü„Åè <code>Effecta</code>„É¢„Éä„Éâ„ÅÆÊßãÈÄ†„Çí
Âà©Áî®„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÂÆüÈöõ„Å´„ÅØ„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØ<strong>„Å©„Çì„Å™</strong>„É¢„Éä„Éâ <code>m</code>„Å´„Å§„ÅÑ„Å¶„ÇÇÂãï
‰Ωú„Åô„Çã„ÅÆ„Åß„ÅôÔºÅ</p>
<p>„Åì„ÅÆÁ´†„Å´Ê∑ª‰ªò„Åï„Çå„Åü„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅßÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÄÅ <code>lsystem</code>„ÅÆ„ÇÇ„Å£„Å®‰∏ÄËà¨
ÁöÑ„Å™Âûã„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>„Åì„ÅÆÂûã„ÅåË®Ä„Å£„Å¶„ÅÑ„Çã„ÅÆ„ÅØ„ÄÅ„Åì„ÅÆÁøªË®≥Èñ¢Êï∞„ÅØ„É¢„Éä„Éâ <code>m</code>„ÅåÊåÅ„Å§‰ªªÊÑè„ÅÆÂâØ‰ΩúÁî®„Çí„Åæ„Å£
„Åü„ÅèËá™Áî±„Å´ÊåÅ„Å§„Åì„Å®„Åå„Åß„Åç„Çã„ÄÅ„Å®„ÅÑ„ÅÜ„Åì„Å®„Å†„Å®ÁêÜËß£„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Ç≠„É£
„É≥„Éê„Çπ„Å´ÊèèÁîª„Åó„Åü„Çä„ÄÅ„Åæ„Åü„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´„Å´ÊÉÖÂ†±„ÇíÂá∫Âäõ„Åô„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åó„ÄÅ
Â§±Êïó„ÇÑË§áÊï∞„ÅÆÊàª„ÇäÂÄ§„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ„Åì„ÅÜ„ÅÑ„Å£„ÅüÊßò„ÄÖ„Å™Âûã„ÅÆÂâØ
‰ΩúÁî®„Çí‰Ωø„Å£„ÅüL-System„ÇíË®òËø∞„Åó„Å¶„Åø„Çã„Åì„Å®„ÇíË™≠ËÄÖ„Å´„ÅäÂãß„ÇÅ„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØÂÆüË£Ö„Åã„Çâ„Éá„Éº„Çø„ÇíÂàÜÈõ¢„Åô„Çã„Åì„Å®„ÅÆÂ®ÅÂäõ„ÇíÁ§∫„ÅôËâØ„ÅÑ‰æã„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÊâãÊ≥ï„ÅÆÂà©ÁÇπ„ÅØ„ÄÅË§áÊï∞„ÅÆÁï∞„Å™„ÇãÊñπÊ≥ï„Åß„Éá„Éº„Çø„ÇíËß£Èáà„Åô„ÇãËá™Áî±„ÅåÂæó„Çâ„Çå„Çã„Åì„Å®
„Åß„Åô„ÄÇ <code>lsystem</code>„ÅØ2„Å§„ÅÆÂ∞è„Åï„Å™Èñ¢Êï∞„Å∏„Å®ÂàÜËß£„Åô„Çã„Åì„Å®„Åï„Åà„Åß„Åç„Çã„Åã„ÇÇ„Åó„Çå„Åæ
„Åõ„Çì„ÄÇ1„Å§ÁõÆ„ÅØ <code>concatMap</code>„ÅÆÈÅ©Áî®„ÅÆÁπ∞„ÇäËøî„Åó„Çí‰Ωø„Å£„Å¶Êñá„ÇíÊßãÁØâ„Åô„Çã„ÇÇ„ÅÆ„Åß„ÄÅ2
„Å§ÁõÆ„ÅØ <code>foldM</code>„Çí‰Ωø„Å£„Å¶Êñá„ÇíÁøªË®≥„Åô„Çã„ÇÇ„ÅÆ„Åß„Åô„ÄÇ„Åì„Çå„ÅØË™≠ËÄÖ„ÅÆÊºîÁøí„Å®„Åó„Å¶ÊÆã„Åó
„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åù„Çå„Åß„ÅØÁøªË®≥Èñ¢Êï∞„ÇíÂÆüË£Ö„Åó„Å¶„ÄÅ„Åì„ÅÆÁ´†„ÅÆ‰æã„ÇíÂÆåÊàê„Åï„Åõ„Åæ„Åó„Çá„ÅÜ‚Äã‚Äã„ÄÇ <code>lsystem</code>„ÅÆ
Âûã„ÅØÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅåË®Ä„Å£„Å¶„ÅÑ„Çã„ÅÆ„ÅØ„ÄÅÁøªË®≥Èñ¢Êï∞„ÅÆÂûã„ÅØ„ÄÅ‰Ωï„Çâ„Åã„ÅÆÂûã <code>a</code>„Å® <code>s</code>„ÄÅ
ÂûãÊßãÁØâÂ≠ê <code>m</code>„Å´„Å§„ÅÑ„Å¶„ÄÅ <code>s -&gt; a -&gt; m s</code>„Åß„Å™„Åë„Çå„Å∞„Å™„Çâ„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
<code>a</code>„Çí <code>Letter</code>„ÄÅ <code>s</code>„Çí <code>State</code>„ÄÅ„É¢„Éä„Éâ <code>m</code>„Çí <code>Effect</code>„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å´ÈÅ∏„Å≥
„Åü„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åå„Çè„Åã„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Çà„ÇäÊ¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÇíÂÆüË£Ö„Åô„Çã„Å´„ÅØ„ÄÅ <code>Letter</code>Âûã„ÅÆ3„Å§„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„Åù„Çå„Åû„Çå„Å´„Å§„ÅÑ„Å¶
Âá¶ÁêÜ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÊñáÂ≠ó <code>L</code>ÔºàÂ∑¶ÂõûËª¢Ôºâ„Å® <code>R</code>ÔºàÂè≥ÂõûËª¢Ôºâ„ÅÆÁøªË®≥„Åß„ÅØ„ÄÅ
<code>theta</code>„ÇíÈÅ©Âàá„Å™ËßíÂ∫¶„Å∏Â§âÊõ¥„Åô„Çã„Çà„ÅÜ„Å´Áä∂ÊÖã„ÇíÊõ¥Êñ∞„Åô„Çã„Å†„Åë„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Number.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Number.tau / 6.0 }
</code></pre>
<p>ÊñáÂ≠ó <code>F</code>ÔºàÂâçÈÄ≤Ôºâ„ÇíÁøªË®≥„Åô„Çã„Å´„ÅØ„ÄÅ„Éë„Çπ„ÅÆÊñ∞„Åó„ÅÑ‰ΩçÁΩÆ„ÇíË®àÁÆó„Åó„ÄÅÁ∑öÂàÜ„ÇíÊèèÁîª„Åó„ÄÅ
Áä∂ÊÖã„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êõ¥Êñ∞„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Number.cos state.theta * 1.5
          y = state.y + Number.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>„Åì„ÅÆÁ´†„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Åß„ÅØ„ÄÅÂêçÂâç <code>ctx</code>„Åå„Çπ„Ç≥„Éº„ÉóÂÜÖ„Å´Êù•„Çã„Çà„ÅÜ„Å´„ÄÅ
<code>interpret</code>Èñ¢Êï∞„ÅØ <code>main</code>Èñ¢Êï∞ÂÜÖ„Åß <code>let</code>ÊùüÁ∏õ„Çí‰ΩøÁî®„Åó„Å¶ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®
„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ <code>State</code>Âûã„Åå„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÊåÅ„Å§„Çà„ÅÜ„Å´Â§âÊõ¥„Åô„Çã„Åì„Å®„ÅØ
ÂèØËÉΩ„Åß„Åó„Çá„ÅÜ„Åå„ÄÅ„Åù„Çå„ÅØ„Åì„ÅÆ„Ç∑„Çπ„ÉÜ„É†„ÅÆÁä∂ÊÖã„ÅÆÂ§âÂåñÈÉ®ÂàÜ„Åß„ÅØ„Å™„ÅÑ„ÅÆ„Åß‰∏çÈÅ©Âàá„Åß
„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åì„ÅÆL-System„ÇíÊèèÁîª„Åô„Çã„Å´„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™ <code>strokePath</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰ΩøÁî®„Åô„Çã„Å†„Åë„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>Ê¨°„ÅÆ„Ç≥„Éû„É≥„Éâ„Çí‰Ωø„Å£„Å¶L-System„Çí„Ç≥„É≥„Éë„Ç§„É´„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>„ÇíÈñã„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ„Ç≠„É£„É≥„Éê„Çπ„Å´„Ç≥„ÉÉ„ÉõÊõ≤Á∑ö„ÅåÊèèÁîª„Åï„Çå
„Çã„ÅÆ„Åå„Çè„Åã„Çã„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-43"><a class="header" href="#ÊºîÁøí-43">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>strokePath</code>„ÅÆ‰ª£„Çè„Çä„Å´ <code>fillPath</code>„Çí‰ΩøÁî®„Åô„Çã„Çà„ÅÜ„Å´„ÄÅ‰∏ä„ÅÆ
L-System„ÅÆ‰æã„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<strong>„Éí„É≥„Éà</strong>Ôºö<code>closePath</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÇíÂê´
„ÇÅ„ÄÅ <code>moveTo</code>„ÅÆÂëº„Å≥Âá∫„Åó„Çí <code>interpret</code>Èñ¢Êï∞„ÅÆÂ§ñÂÅ¥„Å´ÁßªÂãï„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ
„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÁ∞°ÂçòÔºâÊèèÁîª„Ç∑„Çπ„ÉÜ„É†„Å∏„ÅÆÂΩ±Èüø„ÇíÁêÜËß£„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ„Ç≥„Éº„Éâ‰∏≠„ÅÆÊßò„ÄÖ„Å™Êï∞ÂÄ§„ÅÆÂÆö
Êï∞„ÇíÂ§âÊõ¥„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>lsystem</code>Èñ¢Êï∞„Çí2„Å§„ÅÆÂ∞è„Åï„Å™Èñ¢Êï∞„Å´ÂàÜÂâ≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ1„Å§ÁõÆ„ÅØ
<code>concatMap</code>„ÅÆÈÅ©Áî®„ÅÆÁπ∞„ÇäËøî„Åó„Çí‰ΩøÁî®„Åó„Å¶ÊúÄÁµÇÁöÑ„Å™Êñá„ÇíÊßãÁØâ„Åô„Çã„ÇÇ„ÅÆ„Åß„ÄÅ2„Å§ÁõÆ
„ÅØ <code>foldM</code>„Çí‰ΩøÁî®„Åó„Å¶ÁµêÊûú„ÇíËß£Èáà„Åô„Çã„ÇÇ„ÅÆ„Åß„Å™„Åè„Å¶„ÅØ„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>setShadowOffsetX</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÄÅ <code>setShadowOffsetY</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÄÅ
<code>setShadowBlur</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÄÅ <code>setShadowColor</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„ÅÑ„ÄÅÂ°ó„Çä„Å§„Å∂
„Åï„Çå„ÅüÂõ≥ÂΩ¢„Å´„Éâ„É≠„ÉÉ„Éó„Ç∑„É£„Éâ„Ç¶„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<strong>„Éí„É≥„Éà</strong>ÔºöPSCi„Çí‰Ωø„Å£
„Å¶„ÄÅ„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„ÅÆÂûã„ÇíË™ø„Åπ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÂêë„Åç„ÇíÂ§â„Åà„Çã„Å®„Åç„ÅÆËßíÂ∫¶„ÅÆÂ§ß„Åç„Åï„ÅØ‰ªä„ÅÆ„Å®„Åì„Çç‰∏ÄÂÆö (<code>tau/6</code>) „Åß„Åô„ÄÇ
„Åù„ÅÆ‰ª£„Çè„Çä„Å´„ÄÅ<code>Letter</code>„Éá„Éº„ÇøÂûã„ÅÆ‰∏≠„Å´ËßíÂ∫¶„ÇíÁßªÂãï„Åï„Åõ„Çã„Åì„Å®„Åß„ÄÅÁîüÊàêË¶èÂâá„Å´
„Çà„Å£„Å¶Â§âÊõ¥„Åô„Çã„Çà„ÅÜ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>ÁîüÊàêË¶èÂâá„Åß„Åì„ÅÆÊñ∞„Åó„ÅÑÊÉÖÂ†±„Çí‰Ωø„ÅÜ„Å®„ÄÅ„Å©„Çì„Å™Èù¢ÁôΩ„ÅÑÂõ≥ÂΩ¢„Çí‰Ωú„Çã„Åì„Å®„Åå„Åß
„Åç„Çã„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>L</code>Ôºà60Â∫¶Â∑¶ÂõûËª¢Ôºâ„ÄÅ <code>R</code>Ôºà60Â∫¶Âè≥ÂõûËª¢Ôºâ„ÄÅ
<code>F</code>ÔºàÂâçÈÄ≤Ôºâ„ÄÅ <code>M</code>Ôºà„Åì„Çå„ÇÇÂâçÈÄ≤Ôºâ„Å®„ÅÑ„ÅÜ4„Å§„ÅÆÊñáÂ≠ó„Åã„Çâ„Å™„Çã„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà
„ÅßL-System„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç∑„Çπ„ÉÜ„É†„ÅÆÊñá„ÅÆÂàùÊúüÁä∂ÊÖã„ÅØ„ÄÅÂçò‰∏Ä„ÅÆÊñáÂ≠ó <code>M</code>„Åß„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Ç∑„Çπ„ÉÜ„É†„ÅÆÁîüÊàêË¶èÂâá„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>„Åì„ÅÆL-System„ÇíÊèèÁîª„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<strong>Ê≥®ÊÑè</strong>ÔºöÊúÄÂæå„ÅÆÊñá„ÅÆ„Çµ„Ç§„Ç∫„ÅØÂèçÂæ©
ÂõûÊï∞„Å´Âæì„Å£„Å¶ÊåáÊï∞Èñ¢Êï∞ÁöÑ„Å´Â¢óÂ§ß„Åô„Çã„ÅÆ„Åß„ÄÅÁîüÊàêË¶èÂâá„ÅÆÁπ∞„ÇäËøî„Åó„ÅÆÂõûÊï∞„Çí
ÂâäÊ∏õ„Åô„Çã„Åì„Å®„ÅåÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Åì„Åì„Åß„ÄÅÁîüÊàêË¶èÂâá„Å´„Åä„Åë„Çã <code>L</code>„Å® <code>M</code>„ÅÆÈñì„ÅÆÂØæÁß∞ÊÄß„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åµ„Åü„Å§„ÅÆ„ÄåÂâçÈÄ≤„ÄçÂëΩ‰ª§„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„ÉàÂûã„Çí‰ΩøÁî®„Åô„Çã„Å®„ÄÅ
<code>Boolean</code>ÂÄ§„Çí‰Ωø„Å£„Å¶Âå∫Âà•„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>„Åì„ÅÆ„Ç¢„É´„Éï„Ç°„Éô„ÉÉ„Éà„ÅÆË°®Áèæ„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Åì„ÅÆL-System„ÇíÂÆüË£Ö„Åó„Å¶
„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâÁøªË®≥Èñ¢Êï∞„ÅßÂà•„ÅÆ„É¢„Éä„Éâ <code>m</code>„Çí‰Ωø„Å£„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ
<code>Effect.Console</code>‰ΩúÁî®„ÇíÂà©Áî®„Åó„Å¶„Ç≥„É≥„ÇΩ„Éº„É´‰∏ä„Å´L-System„ÇíÂá∫Âäõ„Åó„Åü„Çä„ÄÅ
<code>Random</code>‰ΩúÁî®„ÇíÂà©Áî®„Åó„Å¶Áä∂ÊÖã„ÅÆÂûã„Å´ÁÑ°‰ΩúÁÇ∫„ÅÆ„ÄåÁ™ÅÁÑ∂Â§âÁï∞„Äç„ÇíÈÅ©Áî®„Åó„Åü„Çä„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-10"><a class="header" href="#„Åæ„Å®„ÇÅ-10">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ <code>canvas</code>„É©„Ç§„Éñ„É©„É™„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅPureScript„Åã„Çâ
HTML5 Canvas API„Çí‰Ωø„ÅÜÊñπÊ≥ï„Å´„Å§„ÅÑ„Å¶Â≠¶„Å≥„Åæ„Åó„Åü„ÄÇ„Åæ„Åü„ÄÅ„Åì„Çå„Åæ„ÅßÂ≠¶„Çì„Åß„Åç„Åü
ÊâãÊ≥ï„ÅÆÂ§ö„Åè„ÇíÂà©Áî®„Åó„ÅüÂÆüÁî®ÁöÑ„Å™‰æã„Å´„Å§„ÅÑ„Å¶Ë¶ã„Åæ„Åó„Åü„ÄÇ„Éû„ÉÉ„Éó„ÇÑÁï≥„ÅøËæº„Åø„ÄÅ„É¨„Ç≥„Éº
„Éâ„Å®Ë°åÂ§öÁõ∏„ÄÅÂâØ‰ΩúÁî®„ÇíÊâ±„ÅÜ„Åü„ÇÅ„ÅÆ <code>Effect</code>„É¢„Éä„Éâ„Å™„Å©„Åß„Åô„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„ÅÆ‰æã„Åß„ÅØ„ÄÅÈ´òÈöéÈñ¢Êï∞„ÅÆÂ®ÅÂäõ„ÇíÁ§∫„Åô„Å®„Å®„ÇÇ„Å´„ÄÅ<strong>ÂÆüË£Ö„Åã„Çâ„ÅÆ„Éá„Éº„Çø„ÅÆÂàÜÈõ¢</strong>
„ÇÇÂÆüÊºî„Åó„Å¶„Åø„Åõ„Åæ„Åó„Åü„ÄÇ„Åì„Çå„ÅØ‰æã„Åà„Å∞„ÄÅ‰ª£Êï∞„Éá„Éº„ÇøÂûã„Çí‰ΩøÁî®„Åó„Å¶„Åì„Çå„Çâ„ÅÆÊ¶Ç
Âøµ„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Êã°Âºµ„Åó„ÄÅÊèèÁîªÈñ¢Êï∞„Åã„Çâ„Ç∑„Éº„É≥„ÅÆË°®Áèæ„ÇíÂÆåÂÖ®„Å´ÂàÜÈõ¢„Åß„Åç„Çã„Çà„ÅÜ„Å´
„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>„Åì„ÅÆÊâãÊ≥ï„ÅØ <code>drawing</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åß„ÇÇÊé°Áî®„Åï„Çå„Å¶„Åä„Çä„ÄÅÊèèÁîªÂâç„Å´„Åï„Åæ„Åñ„Åæ„Å™Êñπ
Ê≥ï„Åß„Éá„Éº„Çø„Å®„Åó„Å¶„Ç∑„Éº„É≥„ÇíÊìç‰Ωú„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Å®„ÅÑ„ÅÜÊüîËªüÊÄß„Çí„ÇÇ„Åü„Çâ„Åó„Å¶„ÅÑ
„Åæ„Åô„ÄÇ</p>
<p>canvas„Å´ÊèèÁîª„Åï„Çå„Çã„Ç≤„Éº„É†„ÅÆ‰æã„Å´„Å§„ÅÑ„Å¶„ÅØ
<a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>
„ÅÆ„ÄåBehavior„Äç„Å®„ÄåSignal„Äç„ÅÆ„É¨„Ç∑„Éî„ÇíË¶ã„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="„ÉÜ„Çπ„Éà„ÅÆËá™ÂãïÁîüÊàê"><a class="header" href="#„ÉÜ„Çπ„Éà„ÅÆËá™ÂãïÁîüÊàê">„ÉÜ„Çπ„Éà„ÅÆËá™ÂãïÁîüÊàê</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-11"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-11">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ„ÉÜ„Çπ„ÉÜ„Ç£„É≥„Ç∞„ÅÆÂïèÈ°å„Å´ÂØæ„Åô„Çã„ÄÅÂûã„ÇØ„É©„Çπ„ÅÆÁâπ„Å´Ê¥óÁ∑¥„Åï„Çå„ÅüÂøúÁî®„Å´„Å§„ÅÑ„Å¶Á§∫„Åó„Åæ„Åô„ÄÇ<strong>„Å©„ÅÆ„Çà„ÅÜ„Å´</strong>„ÉÜ„Çπ„Éà„Åô„Çã„ÅÆ„Åã„Çí„Ç≥„É≥„Éë„Ç§„É©„Å´Êïô„Åà„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ„Ç≥„Éº„Éâ„Åå<strong>„Å©„ÅÆ„Çà„ÅÜ„Å™</strong>ÊÄßË≥™„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åπ„Åç„Åã„ÇíÊïô„Åà„Çã„Åì„Å®„Åß„ÉÜ„Çπ„Éà„Åó„Åæ„Åô„ÄÇÂûã„ÇØ„É©„Çπ„Çí‰Ωø„Å£„Å¶ÁÑ°‰ΩúÁÇ∫„Éá„Éº„ÇøÁîüÊàê„ÅÆ„Åü„ÇÅ„ÅÆÂÆöÂûã„Ç≥„Éº„Éâ„ÇíÈö†„Åó„ÄÅ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„Çí‰ªïÊßò„Åã„ÇâÁÑ°‰ΩúÁÇ∫„Å´ÁîüÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åì„Çå„ÅØ<strong>ÁîüÊàêÁöÑ„ÉÜ„Çπ„ÉÜ„Ç£„É≥„Ç∞</strong>Ôºàgenerative
testing„ÄÅ„Åæ„Åü„ÅØ<strong>property-based
testing</strong>Ôºâ„Å®Âëº„Å∞„Çå„ÄÅHaskell„ÅÆ<a href="http://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a>„É©„Ç§„Éñ„É©„É™„Å´„Çà„Å£„Å¶ÊôÆÂèä„Åó„ÅüÊâãÊ≥ï„Åß„Åô„ÄÇ</p>
<p><code>quickcheck</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅØHaskell„ÅÆQuickCheck„É©„Ç§„Éñ„É©„É™„ÇíPureScript„Å´„Éù„Éº„ÉÜ„Ç£„É≥„Ç∞„Åó„Åü„ÇÇ„ÅÆ„Åß„ÄÅÂûã„ÇÑÊßãÊñá„ÅØ„ÇÇ„Å®„ÅÆ„É©„Ç§„Éñ„É©„É™„Å®„Åª„Å®„Çì„Å©Âêå„Åò„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>quickcheck</code>„Çí‰Ωø„Å£„Å¶Á∞°Âçò„Å™„É©„Ç§„Éñ„É©„É™„Çí„ÉÜ„Çπ„Éà„Åó„ÄÅSpago„Åß„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà„ÇíËá™ÂãïÂåñ„Åï„Çå„Åü„Éì„É´„Éâ„Å´Áµ±Âêà„Åô„ÇãÊñπÊ≥ï„ÇíË¶ã„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-10"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-10">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´„ÅØ‰æùÂ≠òÈñ¢‰øÇ„Å®„Åó„Å¶ <code>quickcheck</code>„ÅåËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>Spago„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅØ„ÄÅ„ÉÜ„Çπ„Éà„ÇΩ„Éº„Çπ„ÅØ <code>test</code>„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´ÁΩÆ„Åã„Çå„ÄÅ„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà„ÅÆ„É°„Ç§„É≥„É¢„Ç∏„É•„Éº„É´„ÅØ
<code>Test.Main</code>„Å®Âêç„Å•„Åë„Çâ„Çå„Åæ„Åô„ÄÇ „ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà„ÅØ„ÄÅ <code>spago test</code>„Ç≥„Éû„É≥„Éâ„Çí‰ΩøÁî®„Åó„Å¶ÂÆüË°å„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="ÊÄßË≥™„ÇíÊõ∏„Åè"><a class="header" href="#ÊÄßË≥™„ÇíÊõ∏„Åè">ÊÄßË≥™„ÇíÊõ∏„Åè</a></h2>
<p><code>Merge</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØÁ∞°Âçò„Å™Èñ¢Êï∞ <code>merge</code>„ÅåÂÆüË£Ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„Çå„Çí<code>quickcheck</code>„É©„Ç§„Éñ„É©„É™„ÅÆÊ©üËÉΩ„ÇíÂÆüÊºî„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Å£„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">merge :: Array Int -&gt; Array Int -&gt; Array Int
</code></pre>
<p><code>merge</code>„ÅØ2„Å§„ÅÆÊï¥Âàó„Åï„Çå„ÅüÊï¥Êï∞„ÅÆÈÖçÂàó„ÇíÂèñ„Å£„Å¶„ÄÅÁµêÊûú„ÅåÊï¥Âàó„Åï„Çå„Çã„Çà„ÅÜ„Å´Ë¶ÅÁ¥†„ÇíÁµ±Âêà„Åó„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞Ê¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Merge
&gt; merge [1, 3, 5] [2, 4, 5]

[1, 2, 3, 4, 5, 5]
</code></pre>
<p>ÂÖ∏ÂûãÁöÑ„Å™„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà„Åß„ÅØ„ÄÅÊâã‰ΩúÊ•≠„Åß„Åì„ÅÆ„Çà„ÅÜ„Å™Â∞è„Åï„Å™„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„Çí„ÅÑ„Åè„Å§„ÇÇ‰ΩúÊàê„Åó„ÄÅÁµêÊûú„ÅåÊ≠£„Åó„ÅÑÂÄ§„Å®Á≠â„Åó„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç„Åô„Çã„Åì„Å®„Åß„ÉÜ„Çπ„Éà„ÇíÂÆüÊñΩ„Åó„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ <code>merge</code>Èñ¢Êï∞„Å´„Å§„ÅÑ„Å¶Áü•„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÇÇ„ÅÆ„ÅØ„Åô„Åπ„Å¶„ÄÅ„Åì„Å°„Çâ„ÅÆÊÄßË≥™„Å´Ë¶ÅÁ¥Ñ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<ul>
<li><code>xs</code>„Å® <code>ys</code>„Åå„ÇΩ„Éº„ÉàÊ∏à„Åø„Å™„Çâ„ÄÅ<code>merge xs ys</code>„ÅØ‰∏°Êñπ„ÅÆÈÖçÂàó„Åå‰∏ÄÁ∑í„Å´ÁµêÂêà„Åï„ÇåÊï¥Âàó„Åï„Çå„ÅüÁµêÊûú„Å´„Å™„Çä„Åæ„Åô„ÄÇ</li>
</ul>
<p><code>quickcheck</code>„Åß„ÅØ„ÄÅÁÑ°‰ΩúÁÇ∫„Å™„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÇíÁîüÊàê„Åô„Çã„Åì„Å®„Åß„ÄÅÁõ¥Êé•„Åì„ÅÆÊÄßË≥™„Çí„ÉÜ„Çπ„Éà„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Ç≥„Éº„Éâ„ÅåÊåÅ„Å§„Åπ„ÅçÊÄßË≥™„ÇíÈñ¢Êï∞„Å®„Åó„Å¶Ëø∞„Åπ„Çã„Å†„Åë„Åß„Åô„ÄÇ
„Åì„ÅÆÂ†¥Âêà„ÅØ1„Å§„ÅÆÊÄßË≥™„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">main = do
  quickCheck \xs ys -&gt;
    eq (merge (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>„Åì„ÅÆ„Ç≥„Éº„Éâ„ÇíÂÆüË°å„Åô„Çã„Å®„ÄÅ <code>quickcheck</code>„ÅØÁÑ°‰ΩúÁÇ∫„Å™ÂÖ•Âäõ <code>xs</code>„Å®
<code>ys</code>„ÇíÁîüÊàê„Åó„Å¶„Åì„ÅÆÈñ¢Êï∞„Å´Ê∏°„Åô„Åì„Å®„Åß„ÄÅ‰∏ªÂºµ„Åó„Çà„ÅÜ„Å®„Åó„Å¶„ÅÑ„ÇãÊÄßË≥™„ÇíÂèçË®º„Åó„Çà„ÅÜ„Å®„Åó„Åæ„Åô„ÄÇ
‰Ωï„Çâ„Åã„ÅÆÂÖ•Âäõ„Å´ÂØæ„Åó„Å¶Èñ¢Êï∞„Åå <code>false</code>„ÇíËøî„Åó„ÅüÂ†¥Âêà„ÄÅÊÄßË≥™„ÅØÊ≠£„Åó„Åè„Å™„ÅÑ„Åì„Å®„ÅåÁ§∫„Åï„Çå„ÄÅ„É©„Ç§„Éñ„É©„É™„ÅØ„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„Åæ„Åô„ÄÇ
Âπ∏„ÅÑ„Å™„Åì„Å®„Å´„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´100ÂÄã„ÅÆÁÑ°‰ΩúÁÇ∫„Å™„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÇíÁîüÊàê„Åó„Å¶„ÇÇ„ÄÅ„É©„Ç§„Éñ„É©„É™„ÅØ„Åì„ÅÆÊÄßË≥™„ÇíÂèçË®º„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-text">$ spago test

Installation complete.
Build succeeded.
100/100 test(s) passed.
...
Tests succeeded.
</code></pre>
<p>„ÇÇ„Åó
<code>merge</code>Èñ¢Êï∞„Å´ÊÑèÂõ≥ÁöÑ„Å´„Éê„Ç∞„ÇíÊ∑∑ÂÖ•„Åó„ÅüÂ†¥ÂêàÔºà‰æã„Åà„Å∞„ÄÅÂ§ß„Å™„Çä„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂ∞è„Å™„Çä„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Å∏„Å®Â§âÊõ¥„Åô„Çã„Å™„Å©Ôºâ„ÄÅÊúÄÂàù„Å´Â§±Êïó„Åó„Åü„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÅÆÂæå„Åß‰æãÂ§ñ„ÅåÂÆüË°åÊôÇ„Å´Êäï„Åí„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">Error: Test 1 failed:
Test returned false
</code></pre>
<p>Ë¶ã„Å¶„ÅÆÈÄö„Çä„Åì„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Åß„ÅØ„ÅÇ„Åæ„ÇäÂΩπ„Å´Á´ã„Å°„Åæ„Åõ„Çì„Åå„ÄÅÂ∞ë„ÅóÂ∑•Â§´„Åô„Çã„Å†„Åë„ÅßÊîπËâØ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÊîπÂñÑ"><a class="header" href="#„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÊîπÂñÑ">„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÊîπÂñÑ</a></h2>
<p>„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÅåÂ§±Êïó„Åó„ÅüÊôÇ„Å´ÂêåÊôÇ„Å´„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊèê‰æõ„Åô„Çã‰∏ä„Åß„ÄÅ
<code>quickcheck</code>„ÅØ<code>&lt;?&gt;</code>ÊºîÁÆóÂ≠ê„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ê¨°„ÅÆ„Çà„ÅÜ„Å´ÊÄßË≥™„ÅÆÂÆöÁæ©„Å®„Ç®„É©„ÉºÊñáË®Ä„Çí<code>&lt;?&gt;</code>„ÅßÂå∫Âàá„Å£„Å¶Êõ∏„Åè„Å†„Åë„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  let
    result = merge (sort xs) (sort ys)
    expected = sort $ xs &lt;&gt; ys
  in
    eq result expected &lt;?&gt; &quot;Result:\n&quot; &lt;&gt; show result &lt;&gt; &quot;\nnot equal to expected:\n&quot; &lt;&gt; show expected
</code></pre>
<p>„Åì„ÅÆ„Å®„Åç„ÄÅ„ÇÇ„Åó„Éê„Ç∞„ÇíÊ∑∑ÂÖ•„Åô„Çã„Çà„ÅÜ„Å´„Ç≥„Éº„Éâ„ÇíÂ§âÊõ¥„Åô„Çã„Å®„ÄÅÊúÄÂàù„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÅåÂ§±Êïó„Åó„Åü„Å®„Åç„Å´ÊîπËâØ„Åï„Çå„Åü„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">Error: Test 1 (seed 534161891) failed:
Result:
[-822215,-196136,-116841,618343,887447,-888285]
not equal to expected:
[-888285,-822215,-196136,-116841,618343,887447]
</code></pre>
<p>ÂÖ•Âäõ <code>xs</code>„ÅåÁÑ°‰ΩúÁÇ∫„Å´ÈÅ∏„Å∞„Çå„ÅüÊï∞„ÅÆÈÖçÂàó„Å®„Åó„Å¶ÁîüÊàê„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<h2 id="ÊºîÁøí-44"><a class="header" href="#ÊºîÁøí-44">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâÈÖçÂàó„Å´Á©∫„ÅÆÈÖçÂàó„ÇíÁµ±Âêà„Åó„Å¶„ÇÇÂÖÉ„ÅÆÈÖçÂàó„ÅØÂ§âÊõ¥„Åï„Çå„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫„Åã„ÇÅ„ÇãÊÄßË≥™„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<strong>Ë£úË∂≥</strong>Ôºö„Åì„ÅÆÊñ∞„Åó„ÅÑÊÄßË≥™„ÅØÂÜóÈï∑„Åß„Åô„ÄÇ
„Å®„ÅÑ„ÅÜ„ÅÆ„ÇÇ„Åì„ÅÆÁä∂Ê≥Å„ÅØÊó¢„Å´Êó¢Â≠ò„ÅÆÊÄßË≥™„ÅßÊäº„Åï„Åà„Çâ„Çå„Å¶„ÅÑ„Çã„Åã„Çâ„Åß„Åô„ÄÇ
Ë™≠ËÄÖ„ÅåQuickCheck„Çí‰Ωø„ÅÜÁ∑¥Áøí„Çí„Åô„Çã„Åü„ÇÅ„ÅÆÁ∞°Âçò„Å™ÊñπÊ≥ï„Çí‰∏é„Åà„Çà„ÅÜ„Å®„Åó„Å¶„ÅÑ„Çã„Å†„Åë„Åß„Åô„ÄÇ</li>
<li>ÔºàÁ∞°ÂçòÔºâ<code>merge</code>„ÅÆÊÆã„Çä„ÅÆÊÄßË≥™„Å´ÂØæ„Åó„Å¶„ÄÅÈÅ©Âàá„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="Â§öÁõ∏ÁöÑ„Å™„Ç≥„Éº„Éâ„ÅÆ„ÉÜ„Çπ„Éà"><a class="header" href="#Â§öÁõ∏ÁöÑ„Å™„Ç≥„Éº„Éâ„ÅÆ„ÉÜ„Çπ„Éà">Â§öÁõ∏ÁöÑ„Å™„Ç≥„Éº„Éâ„ÅÆ„ÉÜ„Çπ„Éà</a></h2>
<p><code>Merge</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„ÄÅÊï∞„ÅÆÈÖçÂàó„Å†„Åë„Åß„Å™„Åè„ÄÅ <code>Ord</code>Âûã„ÇØ„É©„Çπ„Å´Â±û„Åô„Çã„Å©„Çì„Å™Âûã„ÅÆÈÖçÂàó„Å´ÂØæ„Åó„Å¶„ÇÇÂãï‰Ωú„Åô„Çã„ÄÅ <code>merge</code>Èñ¢Êï∞„Çí‰∏ÄËà¨Âåñ„Åó„Åü
<code>mergePoly</code>„Å®„ÅÑ„ÅÜÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">mergePoly :: forall a. Ord a =&gt; Array a -&gt; Array a -&gt; Array a
</code></pre>
<p><code>merge</code>„ÅÆ‰ª£„Çè„Çä„Å´ <code>mergePoly</code>„Çí‰Ωø„ÅÜ„Çà„ÅÜ„Å´ÂÖÉ„ÅÆ„ÉÜ„Çπ„Éà„ÇíÂ§âÊõ¥„Åô„Çã„Å®„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">No type class instance was found for

  Test.QuickCheck.Arbitrary.Arbitrary t0

The instance head contains unknown type variables.
Consider adding a type annotation.
</code></pre>
<p>„Åì„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ„ÄÅÈÖçÂàó„Å´ÊåÅ„Åü„Åõ„Åü„ÅÑË¶ÅÁ¥†„ÅÆÂûã„Åå‰Ωï„Å™„ÅÆ„Åã„Çè„Åã„Çâ„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅåÁÑ°‰ΩúÁÇ∫„Å™„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÇíÁîüÊàê„Åß„Åç„Å™„Åã„Å£„Åü„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆ„Çà„ÅÜ„Å™Â†¥Âêà„ÄÅÂûãË®ªÈáà„Çí‰Ωø„Å£„Å¶„Ç≥„É≥„Éë„Ç§„É©„ÅåÁâπÂÆö„ÅÆÂûã„ÇíÊé®Ë´ñ„Åô„Çã„Çà„ÅÜ„Å´Âº∑Âà∂„Åß„Åç„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞<code>Array Int</code>„Å™„Å©„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>‰ª£ÊõøÊ°à„Å®„Åó„Å¶Âûã„ÇíÊåáÂÆö„Åô„ÇãË£úÂä©Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„ÅÜ„Åô„Çã„Å®„Çà„ÇäË¶ãÈÄö„Åó„ÅÆ„Çà„ÅÑ„Ç≥„Éº„Éâ„Å´„Å™„Çã„Åì„Å®„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰æã„Åà„Å∞ÂêåÂÄ§Èñ¢Êï∞„ÅÆÂêåÁæ©„Å™Èñ¢Êï∞<code>ints</code>„ÇíÂÆöÁæ©„Åó„Åü„Å®„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-haskell">ints :: Array Int -&gt; Array Int
ints = id
</code></pre>
<p>„Åù„Çå„Åã„Çâ„ÄÅ„Ç≥„É≥„Éë„Ç§„É©„ÅåÂºïÊï∞„ÅÆ2„Å§„ÅÆÈÖçÂàó„ÅÆÂûã <code>Array Int</code>„ÇíÊé®Ë´ñ„Åô„Çã„Çà„ÅÜ„Å´„ÄÅ„ÉÜ„Çπ„Éà„ÇíÂ§âÊõ¥„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ <code>ints</code>Èñ¢Êï∞„Åå‰∏çÊòé„Å™Âûã„ÇíËß£Ê∂à„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ <code>xs</code>„Å® <code>ys</code>„ÅØ„Å©„Å°„Çâ„ÇÇÂûã <code>Array Int</code>„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-45"><a class="header" href="#ÊºîÁøí-45">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÁ∞°ÂçòÔºâ<code>xs</code>„Å® <code>ys</code>„ÅÆÂûã„Çí <code>Array Boolean</code>„Å´Âº∑Âà∂„Åô„ÇãÈñ¢Êï∞ <code>bools</code>„ÇíÊõ∏„Åç„ÄÅ
<code>mergePoly</code>„Çí„Åù„ÅÆÂûã„Åß„ÉÜ„Çπ„Éà„Åô„ÇãÊÄßË≥™„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li>ÔºàÊôÆÈÄöÔºâÊ®ôÊ∫ñÈñ¢Êï∞„Åã„ÇâÔºà‰æã„Åà„Å∞
<code>arrays</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Åã„ÇâÔºâ„Å≤„Å®„Å§Èñ¢Êï∞„ÇíÈÅ∏„Å≥„ÄÅÈÅ©Âàá„Å™„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂê´„ÇÅ„Å¶QuickCheck„ÅÆÊÄßË≥™„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åù„ÅÆÊÄßË≥™„ÅØ„ÄÅË£úÂä©Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Â§öÁõ∏ÂûãÂºïÊï∞„Çí
<code>Int</code>„Åã <code>Boolean</code>„ÅÆ„Å©„Å°„Çâ„Åã„Å´Âõ∫ÂÆö„Åó„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</li>
</ol>
<h2 id="‰ªªÊÑè„ÅÆ„Éá„Éº„Çø„ÅÆÁîüÊàê"><a class="header" href="#‰ªªÊÑè„ÅÆ„Éá„Éº„Çø„ÅÆÁîüÊàê">‰ªªÊÑè„ÅÆ„Éá„Éº„Çø„ÅÆÁîüÊàê</a></h2>
<p><code>quickcheck</code>„É©„Ç§„Éñ„É©„É™„Çí‰Ωø„Å£„Å¶ÊÄßË≥™„Å´ÂØæ„Åô„Çã„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÁîüÊàê„Åô„ÇãÊñπÊ≥ï„Å´„Å§„ÅÑ„Å¶Ë™¨Êòé„Åó„Åæ„Åô„ÄÇ</p>
<p>ÁÑ°‰ΩúÁÇ∫„Å´ÂÄ§„ÇíÁîüÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å™Âûã„ÅØ„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å™Âûã„ÇØ„É©„Çπ <code>Arbitary</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Arbitrary t where
  arbitrary :: Gen t
</code></pre>
<p><code>Gen</code>ÂûãÊßãÁØâÂ≠ê„ÅØ<strong>Ê±∫ÂÆöÁöÑÁÑ°‰ΩúÁÇ∫„Éá„Éº„ÇøÁîüÊàê</strong>„ÅÆÂâØ‰ΩúÁî®„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ê±∫ÂÆöÁöÑÁÑ°‰ΩúÁÇ∫„Éá„Éº„ÇøÁîüÊàê„ÅØ„ÄÅÊì¨‰ºº‰π±Êï∞ÁîüÊàêÂô®„Çí‰Ωø„Å£„Å¶„ÄÅ„Ç∑„Éº„ÉâÂÄ§„Åã„ÇâÊ±∫ÂÆöÁöÑÁÑ°‰ΩúÁÇ∫Èñ¢Êï∞„ÅÆÂºïÊï∞„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ
<code>Test.QuickCheck.Gen</code>„É¢„Ç∏„É•„Éº„É´„ÅØ„ÄÅ„Ç∏„Çß„Éç„É¨„Éº„Çø„ÇíÊßãÁØâ„Åô„Çã„Åü„ÇÅ„ÅÆ„ÅÑ„Åè„Å§„Åã„ÅÆÊúâÁî®„Å™„Ç≥„É≥„Éì„Éç„Éº„Çø„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Gen</code>„ÅØ„É¢„Éä„Éâ„Åß„ÇÇ„Ç¢„Éó„É™„Ç´„ÉÜ„Ç£„ÉñÈñ¢Êâã„Åß„ÇÇ„ÅÇ„Çã„ÅÆ„Åß„ÄÅ
<code>Arbitary</code>Âûã„ÇØ„É©„Çπ„ÅÆÊñ∞„Åó„ÅÑ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê„Åô„Çã„ÅÆ„Å´„ÄÅ„ÅÑ„Å§„ÇÇ‰Ωø„Å£„Å¶„ÅÑ„Çã„Çà„ÅÜ„Å™„Ç≥„É≥„Éì„Éç„Éº„Çø„ÇíËá™Áî±„Å´‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞„ÄÅ <code>quickcheck</code>„É©„Ç§„Éñ„É©„É™„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Çã <code>Int</code>ÂûãÁî®„ÅÆ
<code>Arbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰Ωø„ÅÑ„ÄÅ256ÂÄã„ÅÆ„Éê„Ç§„ÉàÂÄ§‰∏ä„ÅÆÂàÜÂ∏É„Çí‰Ωú„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„Å´„ÅØ<code>Gen</code>Áî®„Å´<code>Functor</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰Ωø„Å£„Å¶Êï¥Êï∞„Åã„Çâ‰ªªÊÑè„ÅÆÊï¥Êï∞ÂÄ§„ÅÆ„Éê„Ç§„Éà„Åæ„Åß„Éû„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Byte = Byte Int

instance arbitraryByte :: Arbitrary Byte where
  arbitrary = map intToByte arbitrary
    where
    intToByte n | n &gt;= 0 = Byte (n `mod` 256)
                | otherwise = intToByte (-n)
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅ0„Åã„Çâ255„Åæ„Åß„ÅÆÈñì„ÅÆÊï¥Êï∞ÂÄ§„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™Âûã <code>Byte</code>„ÇíÂÆöÁæ©„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Arbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅØ <code>map</code>ÊºîÁÆóÂ≠ê„Çí‰Ωø„Å£„Å¶„ÄÅ <code>intToByte</code>Èñ¢Êï∞„Çí <code>arbitrary</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Åæ„ÅßÊåÅ„Å°‰∏ä„Åí„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>arbitrary</code>„Ç¢„ÇØ„Ç∑„Éß„É≥ÂÜÖÈÉ®„ÅÆÂûã„ÅØ <code>Gen Int</code>„Å®Êé®Ë´ñ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆËÄÉ„ÅàÊñπ„Çí <code>merge</code>Áî®„ÅÆ„ÉÜ„Çπ„Éà„Å´‰Ωø„ÅÜ„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>„Åì„ÅÆ„ÉÜ„Çπ„Éà„Åß„ÅØ„ÄÅ‰ªªÊÑè„ÅÆÈÖçÂàó <code>xs</code>„Å® <code>ys</code>„ÇíÁîüÊàê„Åó„Åæ„Åô„Åå„ÄÅ <code>merge</code>„ÅØ„ÇΩ„Éº„ÉàÊ∏à„Åø„ÅÆÂÖ•Âäõ„ÇíÊúüÂæÖ„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅ <code>xs</code>„Å®
<code>ys</code>„Çí„ÇΩ„Éº„Éà„Åó„Å¶„Åä„Åã„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ‰∏ÄÊñπ„Åß„ÄÅ„ÇΩ„Éº„Éà„Åï„Çå„ÅüÈÖçÂàó„ÇíË°®„Åônewtype„Çí‰ΩúÊàê„Åó„ÄÅ„ÇΩ„Éº„Éà„Åï„Çå„Åü„Éá„Éº„Çø„ÇíÁîüÊàê„Åô„Çã
<code>Arbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Sorted a = Sorted (Array a)

sorted :: forall a. Sorted a -&gt; Array a
sorted (Sorted xs) = xs

instance arbSorted :: (Arbitrary a, Ord a) =&gt; Arbitrary (Sorted a) where
  arbitrary = map (Sorted &lt;&lt;&lt; sort) arbitrary
</code></pre>
<p>„Åì„ÅÆÂûãÊßãÁØâÂ≠ê„Çí‰Ωø„ÅÜ„Å®„ÄÅ„ÉÜ„Çπ„Éà„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Â§âÊõ¥„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs &lt;&gt; sorted ys)
</code></pre>
<p>„Åì„Çå„ÅØ‰∫õÁ¥∞„Å™Â§âÊõ¥„Å´Ë¶ã„Åà„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„Åå„ÄÅ <code>xs</code>„Å® <code>ys</code>„ÅÆÂûã„ÅØ„Åü„Å†„ÅÆ <code>Array Int</code>„Åã„Çâ <code>Sorted Int</code>„Å∏„Å®Â§âÊõ¥„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Çà„Çä„ÄÅ
<code>mergePoly</code>Èñ¢Êï∞„ÅØ„ÇΩ„Éº„ÉàÊ∏à„Åø„ÅÆÂÖ•Âäõ„ÇíÂèñ„Çã„ÄÅ„Å®„ÅÑ„ÅÜ<strong>ÊÑèÂõ≥</strong>„Çí„ÄÅ„Çè„Åã„Çä„ÇÑ„Åô„ÅèÁ§∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇÁêÜÊÉ≥ÁöÑ„Å´„ÅØ„ÄÅ
<code>mergePoly</code>Èñ¢Êï∞Ëá™‰Ωì„ÅÆÂûã„Åå <code>Sorted</code>ÂûãÊßãÁØâÂ≠ê„Çí‰Ωø„ÅÜ„Çà„ÅÜ„Å´„Åô„Çã„Å®„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Çà„ÇäËààÂë≥Ê∑±„ÅÑ‰æã„Å®„Åó„Å¶„ÄÅ <code>Tree</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØÊûù„ÅÆÂÄ§„Åß„ÇΩ„Éº„Éà„Åï„Çå„Åü‰∫åÂàÜÊú®„ÅÆÂûã„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Tree a
  = Leaf
  | Branch (Tree a) a (Tree a)
</code></pre>
<p><code>Tree</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØÊ¨°„ÅÆAPI„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">insert    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Tree a
member    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Boolean
fromArray :: forall a. Ord a =&gt; Array a -&gt; Tree a
toArray   :: forall a. Tree a -&gt; Array a
</code></pre>
<p><code>insert</code>Èñ¢Êï∞„ÅØÊñ∞„Åó„ÅÑË¶ÅÁ¥†„Çí„ÇΩ„Éº„ÉàÊ∏à„Åø„ÅÆ‰∫åÂàÜÊú®„Å´ÊåøÂÖ•„Åô„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„ÄÅ
<code>member</code>Èñ¢Êï∞„ÅØÁâπÂÆö„ÅÆÂÄ§„ÅÆÊúâÁÑ°„ÇíÊú®„Å´Âïè„ÅÑÂêà„Çè„Åõ„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ‰æã„Åà„Å∞Ê¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false
</code></pre>
<p><code>toArray</code>Èñ¢Êï∞„Å® <code>fromArray</code>Èñ¢Êï∞„ÅØ„ÄÅ„ÇΩ„Éº„Éà„Åï„Çå„ÅüÊú®„Å®„ÇΩ„Éº„Éà„Åï„Çå„ÅüÈÖçÂàó„ÇíÁõ∏‰∫í„Å´Â§âÊèõ„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ
<code>fromArray</code>„Çí‰Ωø„ÅÜ„Å®„ÄÅÊú®„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>Arbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance arbTree :: (Arbitrary a, Ord a) =&gt; Arbitrary (Tree a) where
  arbitrary = map fromArray arbitrary
</code></pre>
<p>Âûã <code>a</code>„Å´„Å§„ÅÑ„Å¶„ÅÆ<code>Arbitary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åå‰Ωø„Åà„Çã„Å™„Çâ„ÄÅ„ÉÜ„Çπ„Éà„Åô„ÇãÊÄßË≥™„ÅÆÂºïÊï∞„ÅÆÂûã„Å®„Åó„Å¶ <code>Tree a</code>„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ‰æã„Åà„Å∞„ÄÅ
<code>member</code>„ÉÜ„Çπ„Éà„ÅØÂÄ§„ÇíÊåøÂÖ•„Åó„ÅüÂæå„ÅØÂ∏∏„Å´ <code>true</code>„ÇíËøî„Åô„Åì„Å®„Çí„ÉÜ„Çπ„Éà„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \t a -&gt;
  member a $ insert a $ treeOfInt t
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅÂºïÊï∞ <code>t</code>„ÅØ <code>Tree Number</code>Âûã„ÅÆÁÑ°‰ΩúÁÇ∫„Å´ÁîüÊàê„Åï„Çå„ÅüÊú®„Åß„Åô„ÄÇ
ÂûãÂºïÊï∞„ÅØ„ÄÅÂêåÂÄ§Èñ¢Êï∞ <code>treeOfInt</code>„Å´„Çà„Å£„Å¶ÊòéÁ¢∫Âåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-46"><a class="header" href="#ÊºîÁøí-46">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ<code>a-z</code>„ÅÆÁØÑÂõ≤„Åã„ÇâÁÑ°‰ΩúÁÇ∫„Å´ÈÅ∏„Å∞„Çå„ÅüÊñáÂ≠ó„ÅÆÈõÜ„Åæ„Çä„ÇíÁîüÊàê„Åô„Çã <code>Arbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊåÅ„Å£„Åü„ÄÅ
<code>String</code>„ÅÆnewtype„Çí‰Ωú„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<strong>„Éí„É≥„Éà</strong>Ôºö<code>Test.QuickCheck.Gen</code>„É¢„Ç∏„É•„Éº„É´„Åã„Çâ
<code>elements</code>„Å® <code>arrayOf</code>Èñ¢Êï∞„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</li>
<li>ÔºàÈõ£„Åó„ÅÑÔºâÊú®„Å´ÊåøÂÖ•„Åï„Çå„ÅüÂÄ§„ÅØ„ÄÅ„Å©„Çå„Å†„ÅëÊåøÂÖ•„Åå„ÅÇ„Å£„ÅüÂæå„Åß„ÇÇ„ÄÅ„Åù„ÅÆÊú®„ÅÆÊßãÊàêË¶ÅÁ¥†„Åß„ÅÇ„Çã„Åì„Å®„Çí‰∏ªÂºµ„Åô„ÇãÊÄßË≥™„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="È´òÈöéÈñ¢Êï∞„ÅÆ„ÉÜ„Çπ„Éà"><a class="header" href="#È´òÈöéÈñ¢Êï∞„ÅÆ„ÉÜ„Çπ„Éà">È´òÈöéÈñ¢Êï∞„ÅÆ„ÉÜ„Çπ„Éà</a></h2>
<p><code>Merge</code>„É¢„Ç∏„É•„Éº„É´„ÅØ <code>merge</code>Èñ¢Êï∞„ÅÆÂà•„ÅÆ‰∏ÄËà¨Âåñ„ÇÇÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ
<code>mergeAith</code>Èñ¢Êï∞„ÅØËøΩÂä†„ÅÆÈñ¢Êï∞„ÇíÂºïÊï∞„Å®„Åó„Å¶Âèñ„Çä„ÄÅÁµ±Âêà„Åï„Çå„ÇãË¶ÅÁ¥†„ÅÆÈ†ÜÂ∫è„ÇíÊ±∫
ÂÆö„Åô„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ„Å§„Åæ„Çä <code>mergeWith</code>„ÅØÈ´òÈöéÈñ¢Êï∞„Åß„Åô„ÄÇ</p>
<p>‰æã„Åà„Å∞<code>length</code>Èñ¢Êï∞„ÇíÊúÄÂàù„ÅÆÂºïÊï∞„Å®„Åó„Å¶Ê∏°„Åó„ÄÅÊó¢„Å´Èï∑„Åï„ÅÆÊòáÈ†Ü„Å´„Å™„Å£„Å¶„ÅÑ„Çã2
„Å§„ÅÆÈÖçÂàó„ÇíÁµ±Âêà„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åì„ÅÆ„Å®„Åç„ÄÅÁµêÊûú„ÇÇÈï∑„Åï„ÅÆÊòáÈ†Ü„Å´„Å™„Å£„Å¶„ÅÑ
„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">&gt; import Data.String

&gt; mergeWith length
    [&quot;&quot;, &quot;ab&quot;, &quot;abcd&quot;]
    [&quot;x&quot;, &quot;xyz&quot;]

[&quot;&quot;,&quot;x&quot;,&quot;ab&quot;,&quot;xyz&quot;,&quot;abcd&quot;]
</code></pre>
<p>„Åì„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„Çí„ÉÜ„Çπ„Éà„Åô„Çã„Å´„ÅØ„Å©„ÅÜ„Åó„Åü„Çâ„ÅÑ„ÅÑ„Åß„Åó„Çá„ÅÜ„Åã„ÄÇÁêÜÊÉ≥ÁöÑ„Å´„ÅØ„ÄÅÈñ¢
Êï∞„Åß„ÅÇ„ÇãÊúÄÂàù„ÅÆÂºïÊï∞„ÇíÂê´„ÇÅ„Åü„ÄÅ3„Å§„ÅÆÂºïÊï∞„Åô„Åπ„Å¶„Å´„Å§„ÅÑ„Å¶„ÄÅÂÄ§„ÇíÁîüÊàê„Åó„Åü„ÅÑ„Å®
ÊÄù„ÅÜ„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>Èñ¢Êï∞„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÁîüÊàê„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã„ÄÅ„ÇÇ„ÅÜ1„Å§„ÅÆÂûã„ÇØ„É©„Çπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆ
Âûã„ÇØ„É©„Çπ„ÅØ <code>Coarbitrary</code>„Å®Âëº„Å∞„Çå„Å¶„Åä„Çä„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class Coarbitrary t where
  coarbitrary :: forall r. t -&gt; Gen r -&gt; Gen r
</code></pre>
<p><code>coarbitrary</code>Èñ¢Êï∞„ÅØ„ÄÅÂûã <code>t</code>„Å®„ÄÅÈñ¢Êï∞„ÅÆÁµêÊûú„ÅÆÂûã <code>r</code>„Å´„Å§„ÅÑ„Å¶„ÅÆ‰π±Êï∞ÁîüÊàêÂô®
„ÇíÈñ¢Êï∞„ÅÆÂºïÊï∞„Å®„Åó„Å¶„Å®„Çä„ÄÅ‰π±Êï∞ÁîüÊàêÂô®„Çí<strong>„Åã„Åç‰π±„Åô</strong>„ÅÆ„Å´„Åì„ÅÆÂºïÊï∞„Çí‰Ωø„ÅÑ„Åæ„Åô„ÄÇ
„Å§„Åæ„ÇäÈñ¢Êï∞„ÅÆÂºïÊï∞„Çí‰Ωø„Å£„Å¶„ÄÅ‰π±Êï∞ÁîüÊàêÂô®„ÅÆÁÑ°‰ΩúÁÇ∫„Å™Âá∫Âäõ„ÇíÂ§âÊõ¥„Åó„Å¶„ÅÑ„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<p>„Åæ„Åü„ÄÅ„ÇÇ„ÅóÈñ¢Êï∞„ÅÆÂÆöÁæ©Âüü„Åå <code>Coarbitrary</code>„Åß„ÄÅÂÄ§Âüü„Åå <code>Arbitrary</code>„Å™„Çâ„ÄÅ
<code>Arbitrary</code>„ÅÆÈñ¢Êï∞„Çí‰∏é„Åà„ÇãÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂ≠òÂú®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance arbFunction :: (Coarbitrary a, Arbitrary b) =&gt; Arbitrary (a -&gt; b)
</code></pre>
<p>ÂÆü„ÅØ„ÄÅ„Åì„Çå„ÅåÊÑèÂë≥„Åó„Å¶„ÅÑ„Çã„ÅÆ„ÅØ„ÄÅÂºïÊï∞„Å®„Åó„Å¶Èñ¢Êï∞„ÇíÂèñ„Çã„Çà„ÅÜ„Å™ÊÄßË≥™„ÇíË®òËø∞„Åß„Åç
„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ <code>mergeWith</code>Èñ¢Êï∞„ÅÆÂ†¥Âêà„Åß„ÅØ„ÄÅÊñ∞„Åó„ÅÑÂºïÊï∞„ÇíËÄÉÊÖÆ„Åô„Çã„Çà„ÅÜ
„Å´„ÉÜ„Çπ„Éà„Çí‰øÆÊ≠£„Åô„Çã„Å®„ÄÅÊúÄÂàù„ÅÆÂºïÊï∞„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÁîüÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÁµêÊûú„ÅåÊï¥Âàó„Åï„Çå„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Çí‰øùË®º„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„ÄÇÂøÖ„Åö„Åó„ÇÇ
<code>Ord</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Å®„Åï„ÅàÈôê„Çâ„Å™„ÅÑ„ÅÆ„Åß„Åô„ÄÇ„Åó„Åã„Åó„ÄÅÂºïÊï∞„Å®„Åó„Å¶
Ê∏°„ÅôÈñ¢Êï∞ <code>f</code>„Å´„Åó„Åü„Åå„Å£„Å¶ÁµêÊûú„ÅåÊï¥Âàó„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÅØÊúüÂæÖ„Åï„Çå„Åæ„Åô„ÄÇ„Åï„Çâ„Å´„ÄÅ
2„Å§„ÅÆÂÖ•ÂäõÈÖçÂàó„Åå <code>f</code>„Å´Âæì„Å£„Å¶Êï¥Âàó„Åï„Çå„Å¶„ÅÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÅÆ„Åß„ÄÅ
<code>sortBy</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Èñ¢Êï∞ <code>f</code>„ÅåÈÅ©Áî®„Åï„Çå„Åü„ÅÇ„Å®„ÅÆÊØîËºÉ„Å´Âü∫„Å•„ÅÑ„Å¶ <code>xs</code>„Å®
<code>ys</code>„ÇíÊï¥Âàó„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \xs ys f -&gt;
  let
    result =
      map f $
        mergeWith (intToBool f)
                  (sortBy (compare `on` f) xs)
                  (sortBy (compare `on` f) ys)
    expected =
      map f $
        sortBy (compare `on` f) $ xs &lt;&gt; ys
  in
    eq result expected
</code></pre>
<p>„Åì„Åì„Åß„ÅØ„ÄÅÈñ¢Êï∞ <code>f</code>„ÅÆÂûã„ÇíÊòéÁ¢∫„Å´„Åô„Çã„Åü„ÇÅ„Å´„ÄÅÈñ¢Êï∞ <code>intToBool</code>„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">intToBool :: (Int -&gt; Boolean) -&gt; Int -&gt; Boolean
intToBool = id
</code></pre>
<p>Èñ¢Êï∞„ÅØ <code>Arbitrary</code>„Åß„ÅÇ„Çã„Å†„Åë„Åß„Å™„Åè <code>Coarbitrary</code>„Åß„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance coarbFunction :: (Arbitrary a, Coarbitrary b) =&gt; Coarbitrary (a -&gt; b)
</code></pre>
<p>„Åì„Çå„ÅØÂÄ§„ÅÆÁîüÊàê„ÅåÂçòÁ¥î„Å™Èñ¢Êï∞„Å†„Åë„Å´ÈôêÂÆö„Åï„Çå„Çã„ÇÇ„ÅÆ„Åß„ÅØ„Å™„ÅÑ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ
„Åæ„Åô„ÄÇ„Å§„Åæ„Çä„ÄÅ<strong>È´òÈöéÈñ¢Êï∞</strong>„ÇÑ„ÄÅÂºïÊï∞„ÅåÈ´òÈöéÈñ¢Êï∞„Åß„ÅÇ„Çã„Çà„ÅÜ„Å™Èñ¢Êï∞„ÇÇ„Åæ„ÅüÁÑ°‰Ωú
ÁÇ∫„Å´ÁîüÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<h2 id="coarbitrary„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè"><a class="header" href="#coarbitrary„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè">Coarbitrary„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè</a></h2>
<p><code>Gen</code>„ÅÆ <code>Monad</code>„ÇÑ <code>Applicative</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰Ωø„Å£„Å¶Áã¨Ëá™„ÅÆ„Éá„Éº„ÇøÂûã„Å´ÂØæ
„Åó„Å¶ <code>Arbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Å®„Å°„Çá„ÅÜ„Å©Âêå„Åò„Çà„ÅÜ„Å´„ÄÅ
Áã¨Ëá™„ÅÆ <code>Coarbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„Åè„Åì„Å®„ÇÇ„Åß„Åç„Åæ„Åô„ÄÇ„Åì„Çå„Å´„Çà„Çä„ÄÅÁÑ°‰Ωú
ÁÇ∫„Å´ÁîüÊàê„Åï„Çå„ÇãÈñ¢Êï∞„ÅÆÂÆöÁæ©Âüü„Å®„Åó„Å¶„ÄÅÁã¨Ëá™„ÅÆ„Éá„Éº„ÇøÂûã„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ
„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p><code>Tree</code>Âûã„ÅÆ <code>Coarbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇÊûù„Å´Ê†ºÁ¥ç„Åï„Çå„Å¶
„ÅÑ„ÇãË¶ÅÁ¥†„ÅÆÂûã„Å´ <code>Coarbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance coarbTree :: Coarbitrary a =&gt; Coarbitrary (Tree a) where
</code></pre>
<p>Âûã <code>Tree a</code>„ÅÆÂÄ§„Åå‰∏é„Åà„Çâ„Çå„Åü„Å®„Åç„Å´„ÄÅ‰π±Êï∞Áô∫ÁîüÂô®„Çí„Åã„Åç‰π±„ÅôÈñ¢Êï∞„ÇíË®òËø∞„Åô„Çã
ÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÂÖ•ÂäõÂÄ§„Åå <code>Leaf</code>„Åß„ÅÇ„Çå„Å∞„ÄÅ„Åù„ÅÆ„Åæ„Åæ„ÅÆÁîüÊàêÂô®„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  coarbitrary Leaf = id
</code></pre>
<p>„ÇÇ„ÅóÊú®„Åå <code>Branch</code>„Å™„Çâ„ÄÅÂ∑¶„ÅÆÈÉ®ÂàÜÊú®„ÄÅÂÄ§„ÄÅÂè≥„ÅÆÈÉ®ÂàÜÊú®„Çí‰Ωø„Å£„Å¶ÁîüÊàêÂô®„Çí„Åã„Åç‰π±„Åó„Åæ„Åô„ÄÇ
Èñ¢Êï∞ÂêàÊàê„Çí‰Ωø„Å£„Å¶Áã¨Ëá™„ÅÆ„Åã„Åç‰π±„ÅóÈñ¢Êï∞„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  coarbitrary (Branch l a r) =
    coarbitrary l &lt;&lt;&lt;
    coarbitrary a &lt;&lt;&lt;
    coarbitrary r
</code></pre>
<p>„Åì„Çå„Åß„ÄÅÊú®„ÇíÂºïÊï∞„Å´„Å®„Çã„Çà„ÅÜ„Å™Èñ¢Êï∞„ÇíÂºïÊï∞„Å´Âê´„ÇÄÊÄßË≥™„ÇíËá™Áî±„Å´Êõ∏„Åè„Åì„Å®„Åå„Åß„Åç
„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ„Åü„Å®„Åà„Å∞„ÄÅ <code>Tree</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ<code>anywhere</code>„ÅåÂÆöÁæ©„Åï
„Çå„Å¶„Åä„Çä„ÄÅ„Åì„Çå„ÅØËø∞Ë™û„ÅåÂºïÊï∞„ÅÆ„Å©„Çì„Å™ÈÉ®ÂàÜÊú®„Å´„Å§„ÅÑ„Å¶„ÇÇÊàê„ÇäÁ´ã„Å£„Å¶„ÅÑ„Çã„Åã„ÇíË™ø
„Åπ„ÇãÈñ¢Êï∞„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">anywhere :: forall a. (Tree a -&gt; Boolean) -&gt; Tree a -&gt; Boolean
</code></pre>
<p>„Åì„Çå„Åß„ÄÅÁÑ°‰ΩúÁÇ∫„Å´„Åì„ÅÆËø∞Ë™ûÈñ¢Êï∞ <code>anywhere</code>„ÇíÁîüÊàê„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™
„Çä„Åæ„Åó„Åü„ÄÇ‰æã„Åà„Å∞„ÄÅ <code>anywhere</code>Èñ¢Êï∞„ÅØ<strong>„ÅÇ„ÇãÂëΩÈ°å„ÅÆ„ÇÇ„Å®„Åß‰∏çÂ§â</strong>„Åß„ÅÇ„Çã„Åì„Å®
„ÅåÊúüÂæÖ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">quickCheck \f g t -&gt;
  anywhere (\s -&gt; f s || g s) t ==
    anywhere f (treeOfInt t) || anywhere g t
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ <code>treeOfInt</code>Èñ¢Êï∞„ÅØÊú®„Å´Âê´„Åæ„Çå„ÇãÂÄ§„ÅÆÂûã„ÇíÂûã <code>Int</code>„Å´Âõ∫ÂÆö„Åô„Çã„Åü„ÇÅ„Å´
‰Ωø„Çè„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">treeOfInt :: Tree Int -&gt; Tree Int
treeOfInt = id
</code></pre>
<h2 id="ÂâØ‰ΩúÁî®„ÅÆ„Å™„ÅÑ„ÉÜ„Çπ„Éà"><a class="header" href="#ÂâØ‰ΩúÁî®„ÅÆ„Å™„ÅÑ„ÉÜ„Çπ„Éà">ÂâØ‰ΩúÁî®„ÅÆ„Å™„ÅÑ„ÉÜ„Çπ„Éà</a></h2>
<p>„ÉÜ„Çπ„Éà„ÅÆÁõÆÁöÑ„Åß„ÅØÈÄöÂ∏∏„ÄÅ„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà„ÅÆ <code>main</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´„ÅØ
<code>quickCheck</code>Èñ¢Êï∞„ÅÆÂëº„Å≥Âá∫„Åó„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åó„Åã„Åó„ÄÅÂâØ‰ΩúÁî®„Çí‰Ωø„Çè„Å™„ÅÑ
<code>quickCheckPure</code>„Å®Âëº„Å∞„Çå„Çã <code>quickCheck</code>Èñ¢Êï∞„ÅÆ‰∫úÁ®Æ„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ
<code>quickCheckPure</code>„ÅØ„ÄÅÂÖ•Âäõ„Å®„Åó„Å¶‰π±Êï∞„ÅÆÁ®Æ„Çí„Å®„Çä„ÄÅ„ÉÜ„Çπ„ÉàÁµêÊûú„ÅÆÈÖçÂàó„ÇíËøî„ÅôÁ¥î
Á≤ã„Å™Èñ¢Êï∞„Åß„Åô„ÄÇ</p>
<p>PSCi„Çí‰ΩøÁî®„Åó„Å¶ <code>quickCheckPure</code>„ÇíË©¶„Åõ„Åæ„Åô„ÄÇ„Åì„Åì„Åß„ÅØ <code>merge</code>Êìç‰Ωú„ÅåÁµêÂêà
Ê≥ïÂâá„ÇíÊ∫Ä„Åü„Åô„Åì„Å®„Çí„ÉÜ„Çπ„Éà„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Merge
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.LCG (mkSeed)

&gt; :paste
‚Ä¶ quickCheckPure (mkSeed 12345) 10 \xs ys zs -&gt;
‚Ä¶   ((xs `merge` ys) `merge` zs) ==
‚Ä¶     (xs `merge` (ys `merge` zs))
‚Ä¶ ^D

Success : Success : ...
</code></pre>
<p><code>quickCheckPure</code>„ÅØ‰π±Êï∞„ÅÆÁ®Æ„ÄÅÁîüÊàê„Åô„Çã„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÅÆÊï∞„ÄÅ„ÉÜ„Çπ„Éà„Åô„ÇãÊÄßË≥™„ÅÆ
3„Å§„ÅÆÂºïÊï∞„Çí„Å®„Çä„Åæ„Åô„ÄÇ„ÇÇ„Åó„Åô„Åπ„Å¶„ÅÆ„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„Å´ÊàêÂäü„Åó„Åü„Çâ„ÄÅ
<code>Success</code>„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅÆÈÖçÂàó„Åå„Ç≥„É≥„ÇΩ„Éº„É´„Å´Âá∫Âäõ„Åï„Çå„Åæ„Åô„ÄÇ</p>
<p><code>quickCheckPure</code>„ÅØ„ÄÅÊÄßËÉΩ„Éô„É≥„ÉÅ„Éû„Éº„ÇØ„ÅÆÂÖ•Âäõ„Éá„Éº„ÇøÁîüÊàê„ÇÑ„ÄÅ„Ç¶„Çß„Éñ„Ç¢„Éó„É™„Ç±„Éº
„Ç∑„Éß„É≥„ÅÆ„Éï„Ç©„Éº„É†„Éá„Éº„Çø‰æã„ÇíÁÑ°‰ΩúÁÇ∫„Å´ÁîüÊàê„Åô„Çã„Å®„ÅÑ„ÅÜ„Çà„ÅÜ„Å™Áä∂Ê≥Å„Åß‰æøÂà©„Åã„ÇÇ„Åó
„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<h2 id="ÊºîÁøí-47"><a class="header" href="#ÊºîÁøí-47">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>Byte</code>„Å® <code>Sorted</code>ÂûãÊßãÁØâÂ≠ê„Å´„Å§„ÅÑ„Å¶„ÅÆ <code>Coarbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ‰ªªÊÑè„ÅÆÈñ¢Êï∞ <code>f</code>„Å´„Å§„ÅÑ„Å¶„ÄÅ <code>mergeWith f</code>Èñ¢Êï∞„ÅÆÁµêÂêàÊÄß„Çí‰∏ªÂºµ„Åô„ÇãÔºàÈ´òÈöéÔºâÊÄßË≥™„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>quickCheckPure</code>„Çí‰Ωø„Å£„Å¶PSCi„Åß„Åù„ÅÆÊÄßË≥™„Çí„ÉÜ„Çπ„Éà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÊ¨°„ÅÆ„Éá„Éº„ÇøÂûã„ÅÆ<code>Arbitrary</code>„Å®<code>Coarbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">data OneTwoThree a = One a | Two a a | Three a a a
</code></pre>
<p><strong>„Éí„É≥„Éà</strong>Ôºö<code>Test.QuickCheck.Gen</code>„ÅßÂÆöÁæ©„Åï„Çå„Åü <code>oneOf</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶ <code>Arbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>all</code>„Çí‰Ωø„Å£„Å¶ <code>quickCheckPure</code>Èñ¢Êï∞„ÅÆÁµêÊûú„ÇíÂçòÁ¥îÂåñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åù„ÅÆÊñ∞„Åó„ÅÑÈñ¢Êï∞„ÅØÂûã<code>List Result -&gt; Boolean</code>„ÇíÊåÅ„Å°„ÄÅÂÖ®„Å¶„ÅÆ„ÉÜ„Çπ„Éà„Åå„Å®„Åä„Åà„Å∞<code>true</code>„Çí„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞<code>false</code>„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>quickCheckPure</code>„ÅÆÁµêÊûú„ÇíÂçòÁ¥î„Å´„Åô„ÇãÂà•„ÅÆÊâãÊ≥ï„Å®„Åó„Å¶„ÄÅ
Èñ¢Êï∞<code>squashResults :: List Result -&gt; Result</code>„ÇíÊõ∏„ÅÑ„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>Data.Maybe.First</code>„ÅÆ<code>First</code>„É¢„Éé„Ç§„Éâ„Å®ÂÖ±„Å´<code>foldMap</code>Èñ¢Êï∞„Çí‰Ωø„ÅÜ„Åì„Å®„Åß
Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅÆÊúÄÂàù„ÅÆ„Ç®„É©„Éº„Çí‰øùÂ≠ò„Åô„Çã„Åì„Å®„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-11"><a class="header" href="#„Åæ„Å®„ÇÅ-11">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ<code>quickcheck</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„Å´Âá∫‰ºö„ÅÑ„Åæ„Åó„Åü„ÄÇ„Åì„Çå„Çí‰Ωø„Åà„Å∞<strong>ÁîüÊàêÁöÑ„ÉÜ
„Çπ„ÉÜ„Ç£„É≥„Ç∞</strong>„ÅÆ„Éë„É©„ÉÄ„Ç§„É†„Çí‰Ωø„Å£„Å¶ÂÆ£Ë®ÄÁöÑ„Å™ÊñπÊ≥ï„Åß„ÉÜ„Çπ„Éà„ÇíÊõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Åæ
„Åó„Åü„ÄÇÂÖ∑‰ΩìÁöÑ„Å´„ÅØ‰ª•‰∏ã„Åß„Åô„ÄÇ</p>
<ul>
<li><code>spago test</code>„Çí‰Ωø„Å£„Å¶QuickCheck„ÅÆ„ÉÜ„Çπ„Éà„ÇíËá™ÂãïÂåñ„Åô„ÇãÊñπÊ≥ï„ÇíË¶ã„Åæ„Åó„Åü„ÄÇ</li>
<li>ÊÄßË≥™„ÇíÈñ¢Êï∞„Å®„Åó„Å¶Êõ∏„ÅèÊñπÊ≥ï„Å®„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊîπËâØ„Åô„Çã <code>&lt;?&gt;</code>ÊºîÁÆóÂ≠ê„ÅÆ‰Ωø„ÅÑÊñπ„ÇíË™¨Êòé„Åó„Åæ„Åó„Åü„ÄÇ</li>
<li><code>Arbitrary</code>„Å® <code>Coarbitrary</code>Âûã„ÇØ„É©„Çπ„Å´„Çà„Å£„Å¶„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å´ÂÆöÂûãÁöÑ„Å™„ÉÜ„Çπ„Éà
„Ç≥„Éº„Éâ„ÅÆËá™ÂãïÁîüÊàê„ÇíÂèØËÉΩ„Å´„Åó„ÄÅ„Åæ„Åü„Å©„ÅÆ„Çà„ÅÜ„Å´È´òÈöéÊÄßË≥™Èñ¢Êï∞„ÅåÂèØËÉΩ„Å´„Å™„Çã„Åã„Çí
Ë¶ã„Å¶„Åç„Åæ„Åó„Åü„ÄÇ</li>
<li>Áã¨Ëá™„ÅÆ„Éá„Éº„ÇøÂûã„Å´ÂØæ„Åó„Å¶ <code>Arbitrary</code>„Å® <code>Coarbitrary</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆüË£Ö„Åô
„ÇãÊñπÊ≥ï„ÇíË¶ã„Åæ„Åó„Åü„ÄÇ</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="È†òÂüüÁâπÂåñË®ÄË™û"><a class="header" href="#È†òÂüüÁâπÂåñË®ÄË™û">È†òÂüüÁâπÂåñË®ÄË™û</a></h1>
<h2 id="„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-12"><a class="header" href="#„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô-12">„Åì„ÅÆÁ´†„ÅÆÁõÆÊ®ô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅÂ§öÊï∞„ÅÆÊ®ôÊ∫ñÁöÑ„Å™ÊâãÊ≥ï„Çí‰Ωø„Å£„ÅüPureScript„Å´„Åä„Åë„Çã<strong>È†òÂüüÁâπÂåñË®ÄË™û</strong>
(domain-specific language, DSL) „ÅÆÂÆüË£Ö„Å´„Å§„ÅÑ„Å¶Êé¢Ê±Ç„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>È†òÂüüÁâπÂåñË®ÄË™û„Å®„ÅØ„ÄÅÁâπÂÆö„ÅÆÂïèÈ°åÈ†òÂüü„Åß„ÅÆÈñãÁô∫„Å´ÈÅ©„Åó„ÅüË®ÄË™û„ÅÆ„Åì„Å®„Åß„Åô„ÄÇÈ†òÂüüÁâπ
ÂåñË®ÄË™û„ÅÆÊßãÊñá„Åä„Çà„Å≥Ê©üËÉΩ„ÅØ„ÄÅ„Åù„ÅÆÈ†òÂüüÂÜÖ„ÅÆËÄÉ„ÅàÊñπ„ÇíË°®Áèæ„Åô„Çã„Ç≥„Éº„Éâ„ÅÆË™≠„Åø„ÇÑ„Åô
„Åï„ÇíÊúÄÂ§ßÈôê„Å´Áô∫ÊèÆ„Åô„Åπ„ÅèÈÅ∏Êäû„Åï„Çå„Åæ„Åô„ÄÇÊú¨Êõ∏„ÅÆ‰∏≠„Åß„ÅØ„ÄÅ„Åô„Åß„Å´È†òÂüüÁâπÂåñË®ÄË™û„ÅÆ
‰æã„ÇíÂπæ„Å§„ÅãË¶ã„Å¶„Åç„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<ul>
<li>Á¨¨11Á´†„ÅßÈñãÁô∫„Åï„Çå„Åü <code>Game</code>„É¢„Éä„Éâ„Å®Èñ¢ÈÄ£„Åô„Çã„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ„ÄÅ
<strong>„ÉÜ„Ç≠„Çπ„Éà„Ç¢„Éâ„Éô„É≥„ÉÅ„É£„Éº„Ç≤„Éº„É†ÈñãÁô∫</strong>„Å®„ÅÑ„ÅÜÈ†òÂüü„Å´ÂØæ„Åó„Å¶„ÅÆÈ†òÂüüÁâπÂåñË®ÄË™û„ÇíÊßãÊàê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</li>
<li>Á¨¨13Á´†„ÅßÊâ±„Å£„Åü <code>quickcheck</code>„Éë„ÉÉ„Ç±„Éº„Ç∏„ÅØ„ÄÅ<strong>ÁîüÊàêÁöÑ„ÉÜ„Çπ„ÉÜ„Ç£„É≥„Ç∞</strong>„ÅÆÈ†òÂüü
„ÅÆÈ†òÂüüÁâπÂåñË®ÄË™û„Åß„Åô„ÄÇ„Åì„ÅÆ„Ç≥„É≥„Éì„Éç„Éº„Çø„ÅØ„ÉÜ„Çπ„Éà„ÅÆÊÄßË≥™„Å´ÂØæ„Åó„Å¶Áâπ„Å´Ë°®ÁèæÂäõ„ÅÆ
È´ò„ÅÑË®òÊ≥ï„ÇíÂèØËÉΩ„Å´„Åó„Åæ„Åô„ÄÇ</li>
</ul>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅÈ†òÂüüÁâπÂåñË®ÄË™û„ÅÆÂÆüË£Ö„Å´„Åä„ÅÑ„Å¶„ÄÅ„ÅÑ„Åè„Å§„Åã„ÅÆÊ®ôÊ∫ñÁöÑ„Å™ÊâãÊ≥ï„Å´„Çà„ÇãÊßã
ÈÄ†ÁöÑ„Å™ÊâãÊ≥ï„Å´Ëø´„Çä„Åæ„Åô„ÄÇ„Åì„Çå„Åå„Åì„ÅÆË©±È°å„ÅÆÂÆåÂÖ®„Å™Ë™¨Êòé„Å†„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„ÅØÊ±∫„Åó„Å¶
„ÅÇ„Çä„Åæ„Åõ„Çì„Åå„ÄÅÁã¨Ëá™„ÅÆÁõÆÁöÑ„Å´ÂØæ„Åô„ÇãÂÖ∑‰ΩìÁöÑ„Å™DSL„ÇíÊßãÁØâ„Åô„Çã„ÅÆ„Å´ÂçÅÂàÜ„Å™Áü•Ë≠ò„Çí
‰∏é„Åà„Å¶„Åè„Çå„Çã„Åß„Åó„Çá„ÅÜ„ÄÇ</p>
<p>„Åì„ÅÆÁ´†„ÅßÂÆüË°å„Åó„Å¶„ÅÑ„Çã‰æã„ÅØ„ÄÅHTMLÊñáÊõ∏„Çí‰ΩúÊàê„Åô„Çã„Åü„ÇÅ„ÅÆÈ†òÂüüÁâπÂåñË®ÄË™û„Å´„Å™„Çä„Åæ
„Åô„ÄÇÊ≠£„Åó„ÅÑHTMLÊñáÊõ∏„ÇíË®òËø∞„Åô„Çã„Åü„ÇÅ„ÅÆÂûãÂÆâÂÖ®„Å™Ë®ÄË™û„ÇíÈñãÁô∫„Åô„Çã„Åì„Å®„ÅåÁõÆÁöÑ„Åß„ÄÅ
Á¥†Êú¥„Å™ÂÆüË£Ö„ÇíÂæê„ÄÖ„Å´ÊîπÂñÑ„Åó„Å§„Å§ÈÄ≤„ÇÅ„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-11"><a class="header" href="#„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô-11">„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆÊ∫ñÂÇô</a></h2>
<p>„Åì„ÅÆÁ´†„Åß‰Ωø„ÅÜ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´„ÅØÊñ∞„Åó„ÅÑ‰æùÂ≠òÊÄß„Åå1„Å§ËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ„Åì„Çå„Åã„Çâ‰Ωø
„ÅÜÈÅìÂÖ∑„ÅÆ„Å≤„Å®„Å§„Åß„ÅÇ„Çã<strong>Free„É¢„Éä„Éâ</strong>„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Çã <code>free</code>„É©„Ç§„Éñ„É©„É™„Åß
„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíPSCi„Çí‰Ωø„Å£„Å¶Ë©¶„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="html„Éá„Éº„ÇøÂûã"><a class="header" href="#html„Éá„Éº„ÇøÂûã">HTML„Éá„Éº„ÇøÂûã</a></h2>
<p>„Åì„ÅÆHTML„É©„Ç§„Éñ„É©„É™„ÅÆÊúÄ„ÇÇÂü∫Êú¨ÁöÑ„Å™„Éê„Éº„Ç∏„Éß„É≥„ÅØ
<code>Data.DOM.Simple</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆ„É¢„Ç∏„É•„Éº„É´„Å´„ÅØÊ¨°„ÅÆÂûãÂÆöÁæ©„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Array Content)
  }

data Content
  = TextContent String
  | ElementContent Element

newtype Attribute = Attribute
  { key          :: String
  , value        :: String
  }
</code></pre>
<p><code>Element</code>Âûã„ÅØHTML„ÅÆË¶ÅÁ¥†„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂêÑË¶ÅÁ¥†„ÅØË¶ÅÁ¥†Âêç„ÄÅÂ±ûÊÄß„ÅÆ„Éö„Ç¢‚Äã‚Äã„ÅÆÈÖç
Âàó„Å®„ÄÅË¶ÅÁ¥†„ÅÆÂÜÖÂÆπ„Åß„ÅßÊßãÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇcontent„Éó„É≠„Éë„ÉÜ„Ç£„ÅØ„ÄÅ<code>Maybe</code>„Çø„Ç§
„Éó„ÇíÈÅ©Âàá„Å´‰Ωø„Å£„Å¶„ÄÅË¶ÅÁ¥†„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÔºà‰ªñ„ÅÆË¶ÅÁ¥†„ÇÑ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂê´„ÇÄÔºâ„ÅãÈñâ„Åò„Å¶
„ÅÑ„Çã„Åã„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅÆÈçµ„Å®„Å™„ÇãÊ©üËÉΩ„ÅØÊ¨°„ÅÆÈñ¢Êï∞„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">render :: Element -&gt; String
</code></pre>
<p>„Åì„ÅÆÈñ¢Êï∞„ÅØHTMLË¶ÅÁ¥†„ÇíHTMLÊñáÂ≠óÂàó„Å®„Åó„Å¶Âá∫Âäõ„Åó„Åæ„Åô„ÄÇPSCi„ÅßÊòéÁ§∫ÁöÑ„Å´ÈÅ©ÂΩì„Å™Âûã
„ÅÆÂÄ§„ÇíÊßãÁØâ„Åó„ÄÅ„É©„Ç§„Éñ„É©„É™„ÅÆ„Åì„ÅÆ„Éê„Éº„Ç∏„Éß„É≥„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Simple
&gt; import Data.Maybe
&gt; import Effect.Console

&gt; :paste
‚Ä¶ log $ render $ Element
‚Ä¶   { name: &quot;p&quot;
‚Ä¶   , attribs: [
‚Ä¶       Attribute
‚Ä¶         { key: &quot;class&quot;
‚Ä¶         , value: &quot;main&quot;
‚Ä¶         }
‚Ä¶     ]
‚Ä¶   , content: Just [
‚Ä¶       TextContent &quot;Hello World!&quot;
‚Ä¶     ]
‚Ä¶   }
‚Ä¶ ^D

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>ÁèæÁä∂„ÅÆ„É©„Ç§„Éñ„É©„É™„Å´„ÅØ„ÅÑ„Åè„Å§„Åã„ÅÆÂïèÈ°å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li>HTMLÊñáÊõ∏„ÅÆ‰ΩúÊàê„Å´Êâã„Åå„Åã„Åã„Çä„Åæ„Åô„ÄÇ„Åô„Åπ„Å¶„ÅÆÊñ∞„Åó„ÅÑË¶ÅÁ¥†„Å´Â∞ë„Å™„Åè„Å®„ÇÇ1„Å§„ÅÆ„É¨
„Ç≥„Éº„Éâ„Å®1„Å§„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ</li>
<li>ÁÑ°Âäπ„Å™ÊñáÊõ∏„ÇíË°®Áèæ„Åß„Åç„Å¶„Åó„Åæ„ÅÑ„Åæ„Åô„ÄÇ
<ul>
<li>ÈñãÁô∫ËÄÖ„ÅåË¶ÅÁ¥†Âêç„ÅÆÂÖ•Âäõ„ÇíÈñìÈÅï„Åà„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì</li>
<li>ÈñãÁô∫ËÄÖ„ÅåÂ±ûÊÄß„ÇíÈñìÈÅï„Å£„ÅüË¶ÅÁ¥†„Å´Èñ¢ÈÄ£‰ªò„Åë„Çã„Åì„Å®„Åå„Åß„Åç„Å¶„Åó„Åæ„ÅÑ„Åæ„Åô</li>
<li>ÈñãÁô∫ËÄÖ„ÅåÈñã„ÅÑ„ÅüË¶ÅÁ¥†„ÅåÊ≠£„Åó„ÅÑÂ†¥Âêà„Å´Èñâ„Åò„ÅüË¶ÅÁ¥†„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Å¶„Åó„Åæ„ÅÑ„Åæ„Åô</li>
</ul>
</li>
</ul>
<p>ÊÆã„Çä„ÅÆÁ´†„Åß„ÅØ„Å®„ÅÇ„ÇãÊâãÊ≥ï„ÇíÁî®„ÅÑ„Å¶„Åì„Çå„Çâ„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åó„ÄÅ„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„Éº„Çí
HTMLÊñáÊõ∏„Çí‰ΩúÊàê„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Åà„ÇãÈ†òÂüüÁâπÂåñË®ÄË™û„Å´„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<h2 id="„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê"><a class="header" href="#„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê">„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê</a></h2>
<p>ÊúÄÂàù„Å´Â∞éÂÖ•„Åô„ÇãÊâãÊ≥ï„ÅØÊñπÊ≥ï„ÅØÂçòÁ¥î„Å™„ÇÇ„ÅÆ„Åß„Åô„Åå„ÄÅ„Å®„Å¶„ÇÇÂäπÊûúÁöÑ„Åß„Åô„ÄÇ„É¢„Ç∏„É•„Éº„É´„ÅÆ‰ΩøÁî®ËÄÖ„Å´„Éá„Éº„Çø„ÅÆË°®Áèæ„ÇíÈú≤Âá∫„Åô„Çã‰ª£„Çè„Çä„Å´„ÄÅ„É¢„Ç∏„É•„Éº„É´„Ç®„ÇØ„Çπ„Éù„Éº„Éà„É™„Çπ„Éà„Çí‰Ωø„Å£„Å¶„Éá„Éº„ÇøÊßãÁØâÂ≠ê
<code>Element</code>„ÄÅ <code>Content</code>„ÄÅ <code>Attribute</code>„ÇíÈö†ËîΩ„Åó„ÄÅÊ≠£„Åó„ÅÑ„Åì„Å®„ÅåÊòé„Çâ„Åã„Å™„Éá„Éº„Çø„Å†„ÅëÊßãÁØâ„Åô„Çã„ÄÅ„ÅÑ„Çè„ÇÜ„Çã<strong>„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê</strong>
(smart constructors) „Å†„Åë„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Åæ„Åô„ÄÇ</p>
<p>‰æã„ÇíÁ§∫„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ„Åæ„Åö„ÄÅHTMLË¶ÅÁ¥†„Çí‰ΩúÊàê„Åô„Çã„Åü„ÇÅ„ÅÆ‰æøÂà©„Å™Èñ¢Êï∞„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">element :: String -&gt; Array Attribute -&gt; Maybe (Array Content) -&gt; Element
element name attribs content = Element
  { name:      name
  , attribs:   attribs
  , content:   content
  }
</code></pre>
<p>Ê¨°„Å´„ÄÅÊ¨≤„Åó„ÅÑHTMLË¶ÅÁ¥†„ÇíÂà©Áî®ËÄÖ„Åå‰Ωú„Çå„Çã„Çà„ÅÜ„Å´„ÄÅ„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„Å´„ÅØ<code>element</code>Èñ¢Êï∞„ÇíÈÅ©Áî®„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">a :: Array Attribute -&gt; Array Content -&gt; Element
a attribs content = element &quot;a&quot; attribs (Just content)

p :: Array Attribute -&gt; Array Content -&gt; Element
p attribs content = element &quot;p&quot; attribs (Just content)

img :: Array Attribute -&gt; Element
img attribs = element &quot;img&quot; attribs Nothing
</code></pre>
<p>ÊúÄÂæå„Å´„ÄÅÊ≠£„Åó„ÅÑ„Éá„Éº„ÇøÊßãÈÄ†„Å†„Åë„ÇíÊßãÁØâ„Åô„Çã„Åì„Å®„Åå„Çè„Åã„Å£„Å¶„ÅÑ„Çã„Åì„Çå„Çâ„ÅÆÈñ¢Êï∞„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„Çã„Çà„ÅÜ„Å´„ÄÅ„É¢„Ç∏„É•„Éº„É´„Ç®„ÇØ„Çπ„Éù„Éº„Éà„É™„Çπ„Éà„ÇíÊõ¥Êñ∞„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute(..)
  , Content(..)

  , a
  , p
  , img

  , render
  ) where
</code></pre>
<p>„É¢„Ç∏„É•„Éº„É´„Ç®„ÇØ„Çπ„Éù„Éº„Éà„É™„Çπ„Éà„ÅØ„É¢„Ç∏„É•„Éº„É´Âêç„ÅÆÁõ¥Âæå„ÅÆÊã¨ÂºßÂÜÖ„Å´Êõ∏„Åç„Åæ„Åô„ÄÇÂêÑ„É¢„Ç∏„É•„Éº„É´„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÅØÊ¨°„ÅÆ3Á®ÆÈ°û„ÅÆ„ÅÑ„Åö„Çå„Åã„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li>ÂÄ§Ôºà„Å™„ÅÑ„ÅóÈñ¢Êï∞Ôºâ„ÄÇ„Åù„ÅÆÂÄ§„ÅÆÂêçÂâç„Å´„Çà„ÇäÊåáÂÆö„Åï„Çå„Åæ„Åô„ÄÇ</li>
<li>Âûã„ÇØ„É©„Çπ„ÄÇ„ÇØ„É©„ÇπÂêç„Å´„Çà„ÇäÊåáÂÆö„Åï„Çå„Åæ„Åô„ÄÇ</li>
<li>ÂûãÊßãÁØâÂ≠ê„Å®Èñ¢ÈÄ£„Åô„Çã„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÄÇÂûãÂêç„Å®„Åù„Çå„Å´Á∂ö„Åè„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åï„Çå„Çã„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅÆÊã¨Âºß„ÅßÂõ≤„Åæ„Çå„Åü„É™„Çπ„Éà„ÅßÊåáÂÆö„Åï„Çå„Åæ„Åô„ÄÇ</li>
</ul>
<p>„Åì„Åì„Åß„ÅØ„ÄÅ
<code>Element</code>„ÅÆ<strong>Âûã</strong>„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅØ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„ÇÇ„Åó„Éá„Éº„ÇøÊßãÁØâÂ≠ê„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„Çã„Å®„ÄÅ„É¢„Ç∏„É•„Éº„É´„ÅÆ‰ΩøÁî®ËÄÖ„Åå‰∏çÊ≠£„Å™HTMLË¶ÅÁ¥†„ÇíÊßãÁØâ„Åß„Åç„Å¶„Åó„Åæ„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>Attribute</code>„Å® <code>Content</code>Âûã„Å´„Å§„ÅÑ„Å¶„ÅØ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„Çí„Åô„Åπ„Å¶„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„ÅôÔºà„Ç®„ÇØ„Çπ„Éù„Éº„Éà„É™„Çπ„Éà„ÅÆË®òÂè∑
<code>..</code>„ÅßÁ§∫„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºâ„ÄÇ
„Åô„ÅêÂæå„Åß„ÄÅ„Åì„Çå„Çâ„ÅÆÂûã„Å´„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê„ÅÆÊâãÊ≥ï„ÇíÈÅ©Áî®„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åô„Åß„Å´„É©„Ç§„Éñ„É©„É™„Å´„ÅÑ„Åè„Å§„Åã„ÅÆÂ§ß„Åç„Å™ÊîπËâØ„ÇíÂä†„Çè„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÁõÆ„Åß„Åô„ÄÇ</p>
<ul>
<li>‰∏çÊ≠£„Å™ÂêçÂâç„ÇíÊåÅ„Å§HTMLË¶ÅÁ¥†„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„ÅØ‰∏çÂèØËÉΩ„Åß„ÅôÔºà„ÇÇ„Å°„Çç„Çì„ÄÅ„É©„Ç§„Éñ„É©„É™„ÅåÊèê‰æõ„Åô„ÇãË¶ÅÁ¥†Âêç„Å´Âà∂Èôê„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºâ„ÄÇ</li>
<li>Èñâ„Åò„ÅüË¶ÅÁ¥†„ÅØÊßãÁØâ„Åô„Çã„Å®„Åç„Å´ÂÜÖÂÆπ„ÇíÂê´„ÇÅ„Çâ„Çå„Åæ„Åõ„Çì„ÄÇ</li>
</ul>
<p><code>Content</code>Âûã„Å´„Å®„Å¶„ÇÇÁ∞°Âçò„Å´„Åì„ÅÆÊâãÊ≥ï„ÇíÈÅ©Áî®„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇÂçò„Å´„Ç®„ÇØ„Çπ„Éù„Éº„Éà„É™„Çπ„Éà„Åã„Çâ
<code>Content</code>Âûã„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇíÂèñ„ÇäÈô§„Åç„ÄÅÊ¨°„ÅÆ„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê„ÇíÊèê‰æõ„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">text :: String -&gt; Content
text = TextContent

elem :: Element -&gt; Content
elem = ElementContent
</code></pre>
<p><code>Attribute</code>Âûã„Å´„ÇÇÂêå„ÅòÊâãÊ≥ï„ÇíÈÅ©Áî®„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ„Åæ„Åö„ÄÅÂ±ûÊÄß„ÅÆ„Åü„ÇÅ„ÅÆÊ±éÁî®„ÅÆ„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê„ÇíÁî®ÊÑè„Åó„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅØÊúÄÂàù„ÅÆË©¶„Åø„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">attribute :: String -&gt; String -&gt; Attribute
attribute key value = Attribute
  { key: key
  , value: value
  }

infix 4 attribute as :=
</code></pre>
<p>„Åì„ÅÆÂÆöÁæ©„Åß„ÅØÂÖÉ„ÅÆ <code>Element</code>Âûã„Å®Âêå„ÅòÂïèÈ°å„Å´Áõ¥Èù¢„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Â≠òÂú®„Åó„Å™„Åã„Å£„Åü„Çä„ÄÅÂêçÂâç„ÅåÈñìÈÅï„Å£„Å¶„ÅÑ„Çã„Çà„ÅÜ„Å™Â±ûÊÄß„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„ÅåÂèØËÉΩ„Åß„Åô„ÄÇ„Åì„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åô„Çã„Åü„ÇÅ„Å´„ÄÅÂ±ûÊÄßÂêç„ÇíË°®„Åônewtype„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype AttributeKey = AttributeKey String
</code></pre>
<p>„Åì„Çå„Çí‰Ωø„Åà„Å∞ÊºîÁÆóÂ≠ê„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Â§âÊõ¥„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">attribute :: AttributeKey -&gt; String -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: value
  }
</code></pre>
<p><code>AttributeKey</code>„Éá„Éº„ÇøÊßãÁØâÂ≠ê„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Å™„Åë„Çå„Å∞„ÄÅÊòéÁ§∫ÁöÑ„Å´„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åï„Çå„ÅüÊ¨°„ÅÆ„Çà„ÅÜ„Å™Èñ¢Êï∞„Çí‰Ωø„ÅÜ‰ª•Â§ñ„Å´„ÄÅ‰ΩøÁî®ËÄÖ„ÅåÂûã
<code>AttributeKey</code>„ÅÆÂÄ§„ÇíÊßãÁØâ„Åô„ÇãÊñπÊ≥ï„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
‰ª•‰∏ã„Å´„ÅÑ„Åè„Å§„Åã„ÅÆ‰æã„ÇíÁ§∫„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">href :: AttributeKey
href = AttributeKey &quot;href&quot;

_class :: AttributeKey
_class = AttributeKey &quot;class&quot;

src :: AttributeKey
src = AttributeKey &quot;src&quot;

width :: AttributeKey
width = AttributeKey &quot;width&quot;

height :: AttributeKey
height = AttributeKey &quot;height&quot;
</code></pre>
<p>Êñ∞„Åó„ÅÑ„É¢„Ç∏„É•„Éº„É´„ÅÆÊúÄÁµÇÁöÑ„Å™„Ç®„ÇØ„Çπ„Éù„Éº„Éà„É™„Çπ„Éà„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ
ÊúÄÊó©„Å©„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇÇÁõ¥Êé•„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Å™„ÅÑÁÇπ„Å´Ê≥®ÁõÆ„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">module Data.DOM.Smart
  ( Element
  , Attribute
  , Content
  , AttributeKey

  , a
  , p
  , img

  , href
  , _class
  , src
  , width
  , height

  , attribute, (:=)
  , text
  , elem

  , render
  ) where
</code></pre>
<p>PSCi„Åß„Åì„ÅÆÊñ∞„Åó„ÅÑ„É¢„Ç∏„É•„Éº„É´„ÇíË©¶„Åó„Å¶„Åø„Çã„Å®„ÄÅÊó¢„Å´„Ç≥„Éº„Éâ„ÅÆÁ∞°ÊΩî„Åï„Å´„Åä„ÅÑ„Å¶Â§ßÂπÖ„Å™Âêë‰∏ä„ÅåË¶ã„Å¶Âèñ„Çå„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Data.DOM.Smart
&gt; import Effect.Console
&gt; log $ render $ p [ _class := &quot;main&quot; ] [ text &quot;Hello World!&quot; ]

&lt;p class=&quot;main&quot;&gt;Hello World!&lt;/p&gt;
unit
</code></pre>
<p>„Åó„Åã„Åó„ÄÅÂü∫Á§é„ÅÆ„Éá„Éº„ÇøË°®Áèæ„ÅåÂ§âÊõ¥„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„ÅÆ„Åß„ÄÅ
<code>render</code>Èñ¢Êï∞„ÇíÂ§âÊõ¥„Åô„ÇãÂøÖË¶Å„ÅØ„Å™„Åã„Å£„Åü„Åì„Å®„Å´„ÇÇÊ≥®ÁõÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Åì„Çå„ÅØ„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê„Å´„Çà„ÇãÊâãÊ≥ï„ÅÆÂà©ÁÇπ„ÅÆ„Å≤„Å®„Å§„Åß„Åô„ÄÇÂ§ñÈÉ®API„ÅÆ‰ΩøÁî®ËÄÖ„Å´„Çà„Å£„Å¶Ë™çË≠ò„Åï„Çå„ÇãË°®Áèæ„Åã„Çâ„ÄÅ„É¢„Ç∏„É•„Éº„É´„ÅÆÂÜÖÈÉ®„Éá„Éº„ÇøË°®Áèæ„ÇíÂàÜÈõ¢„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„Åß„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-48"><a class="header" href="#ÊºîÁøí-48">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ<code>Data.DOM.Smart</code>„É¢„Ç∏„É•„Éº„É´„Åß <code>render</code>„Çí‰Ωø„Å£„ÅüÊñ∞„Åó„ÅÑHTMLÊñáÊõ∏„ÅÆ‰ΩúÊàê„ÇíË©¶„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâ<code>checked</code>„Å®
<code>disabled</code>„Å™„Å©„ÄÅÂÄ§„ÇíË¶ÅÊ±Ç„Åó„Å™„ÅÑHTMLÂ±ûÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ„Åì„Çå„Çâ„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å™<strong>Á©∫„ÅÆÂ±ûÊÄß</strong>„Å®„Åó„Å¶Ë°®Á§∫„Åï„Çå„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-html">&lt;input disabled&gt;
</code></pre>
<p>Á©∫„ÅÆÂ±ûÊÄß„ÇíÊâ±„Åà„Çã„Çà„ÅÜ„Å´ <code>Attribute</code>„ÅÆË°®Áèæ„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Ë¶ÅÁ¥†„Å´Á©∫„ÅÆÂ±ûÊÄß„ÇíËøΩÂä†„Åô„Çã„Åü„ÇÅ„ÅÆ<code>attribute</code>„Åæ„Åü„ÅØ<code>:=</code>„ÅÆ‰ª£„Çè„Çä„Å´‰Ωø„Åà„ÇãÈñ¢Êï∞„ÇíË®òËø∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="ÂπªÂΩ±Âûã"><a class="header" href="#ÂπªÂΩ±Âûã">ÂπªÂΩ±Âûã</a></h2>
<p>Ê¨°„ÅÆÊâãÊ≥ï„ÅÆÂãïÊ©ü‰ªò„Åë„Å®„Åó„Å¶„ÄÅ‰ª•‰∏ã„ÅÆ„Ç≥„Éº„Éâ„ÇíËÄÉ„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; log $ render $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := &quot;foo&quot;
    , height := &quot;bar&quot;
    ]

&lt;img src=&quot;cat.jpg&quot; width=&quot;foo&quot; height=&quot;bar&quot; /&gt;
unit
</code></pre>
<p>„Åì„Åì„Åß„ÅÆÂïèÈ°å„ÅØ„ÄÅ <code>width</code>Â±ûÊÄß„Å®<code>height</code>Â±ûÊÄß„Å´ÊñáÂ≠óÂàóÂÄ§„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Çã„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
„Åì„Åì„Åß‰∏é„Åà„Çã„Åì„Å®„Åå„Åß„Åç„Çã„ÅÆ„ÅØ„Éî„ÇØ„Çª„É´Âçò‰Ωç„Å™„ÅÑ„Åó„Éë„Éº„Çª„É≥„Éà„ÅÆÊï∞ÂÄ§„Å†„Åë„Åß„ÅÇ„Çã„Åπ„Åç„Åß„Åô„ÄÇ</p>
<p><code>AttributeKey</code>Âûã„Å´„ÅÑ„Çè„ÇÜ„Çã<strong>ÂπªÂΩ±Âûã</strong> (phantom type) ÂºïÊï∞„ÇíÂ∞éÂÖ•„Åô„Çã„Å®„ÄÅ„Åì„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype AttributeKey a = AttributeKey String
</code></pre>
<p>ÂÆöÁæ©„ÅÆÂè≥Ëæ∫„Å´ÂØæÂøú„Åô„ÇãÂûã <code>a</code>„ÅÆÂÄ§„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„Åì„ÅÆÂûãÂ§âÊï∞ <code>a</code>„ÅØ<strong>ÂπªÂΩ±Âûã</strong>„Å®Âëº„Å∞„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åì„ÅÆÂûã <code>a</code>„ÅØ„Ç≥„É≥„Éë„Ç§„É´ÊôÇ„Å´ËøΩÂä†„ÅÆÊÉÖÂ†±„ÇíÊèê‰æõ„Åô„Çã„Åü„ÇÅ„Å†„Åë„Å´Â≠òÂú®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Âûã <code>AttributeKey a</code>„ÅÆ‰ªªÊÑè„ÅÆÂÄ§„ÅØÂÆüË°åÊôÇ„Å´„ÅØÂçò„Å™„ÇãÊñáÂ≠óÂàó„Åß„Åô„Åå„ÄÅ„Ç≥„É≥„Éë„Ç§„É´ÊôÇ„Å´„Åù„ÅÆÂÄ§„ÅÆÂûã„Å´„Çà„Çä„Åì„ÅÆ„Ç≠„Éº„Å´Èñ¢ÈÄ£‰ªò„Åë„Çâ„Çå„ÅüÂÄ§„ÅßÊ±Ç„ÇÅ„Å¶„ÅÑ„ÇãÂûã„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<p><code>attribute</code>Èñ¢Êï∞„ÅÆÂûã„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Â§âÊõ¥„Åô„Çå„Å∞„ÄÅ<code>AttributeKey</code>„ÅÆÊñ∞„Åó„ÅÑÂΩ¢Âºè„ÇíËÄÉÊÖÆ„Åô„Çã„Çà„ÅÜ„Å´„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">attribute :: forall a. IsValue a =&gt; AttributeKey a -&gt; a -&gt; Attribute
attribute (AttributeKey key) value = Attribute
  { key: key
  , value: toValue value
  }
</code></pre>
<p>„Åì„Åì„Åß„ÄÅÂπªÂΩ±Âûã„ÅÆÂºïÊï∞ <code>a</code>„ÅØ„ÄÅÂ±ûÊÄß„Ç≠„Éº„Å®Â±ûÊÄßÂÄ§„ÅåÁÖßÂøú„Åô„ÇãÂûã„ÇíÊåÅ„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ
‰ΩøÁî®ËÄÖ„ÅØ <code>AttributeKey a</code>„ÇíÂûã„ÅÆÂÄ§„ÇíÁõ¥Êé•‰ΩúÊàê„Åß„Åç„Å™„ÅÑ„ÅÆ„ÅßÔºà„É©„Ç§„Éñ„É©„É™„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„ÇãÂÆöÊï∞„Çí‰ªã„Åó„Å¶„ÅÆ„ÅøÂæó„Çâ„Çå„Åæ„ÅôÔºâ„ÄÅ„Åô„Åπ„Å¶„ÅÆÂ±ûÊÄß„ÅåÊßãÁØâ„Å´„Çà„ÇäÊ≠£„Åó„Åè„Å™„Çä„Åæ„Åô„ÄÇ</p>
<p>„Å™„Åä„ÄÅ<code>IsValue</code>Âà∂Á¥Ñ„ÅØ„ÄÅ„Ç≠„Éº„Å´Èñ¢ÈÄ£‰ªò„Åë„Çâ„Çå„ÅüÂÄ§„ÅÆÂûã„Åå„Å™„Çì„Åß„ÅÇ„Çå„ÄÅ„Åù„ÅÆÂÄ§„ÇíÊñáÂ≠óÂàó„Å´Â§âÊèõ„Åó„ÄÅÁîüÊàê„Åó„ÅüHTMLÂÜÖ„Å´Âá∫Âäõ„Åß„Åç„Çã„Åì„Å®„Çí‰øùË®º„Åó„Åæ„Åô„ÄÇ
<code>IsValue</code>Âûã„ÇØ„É©„Çπ„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">class IsValue a where
  toValue :: a -&gt; String
</code></pre>
<p><code>String</code>„Å® <code>Int</code>Âûã„Å´„Å§„ÅÑ„Å¶„ÅÆÂûã„ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇÇÊèê‰æõ„Åó„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance stringIsValue :: IsValue String where
  toValue = id

instance intIsValue :: IsValue Int where
  toValue = show
</code></pre>
<p>„Åæ„Åü„ÄÅ„Åì„Çå„Çâ„ÅÆÂûã„ÅåÊñ∞„Åó„ÅÑÂûãÂ§âÊï∞„ÇíÂèçÊò†„Åô„Çã„Çà„ÅÜ„Å´„ÄÅ <code>AttributeKey</code>ÂÆöÊï∞„ÇíÊõ¥Êñ∞„Åó„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">href :: AttributeKey String
href = AttributeKey &quot;href&quot;

_class :: AttributeKey String
_class = AttributeKey &quot;class&quot;

src :: AttributeKey String
src = AttributeKey &quot;src&quot;

width :: AttributeKey Int
width = AttributeKey &quot;width&quot;

height :: AttributeKey Int
height = AttributeKey &quot;height&quot;
</code></pre>
<p>„Åì„Çå„Åß„ÄÅ‰∏çÊ≠£„Å™HTMLÊñáÊõ∏„ÇíË°®Áèæ„Åô„Çã„Åì„Å®„Åå‰∏çÂèØËÉΩ„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ
„Åæ„Åü„ÄÅ<code>width</code>„Å® <code>height</code>Â±ûÊÄß„ÇíË°®Áèæ„Åô„Çã„ÅÆ„Å´ÊñáÂ≠óÂàó„Åß„ÅØ„Å™„ÅèÊï∞„Çí‰Ωø„ÅÜ„Åì„Å®„ÅåÂº∑Âà∂„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Phantom
&gt; import Effect.Console

&gt; :paste
‚Ä¶ log $ render $ img
‚Ä¶   [ src    := &quot;cat.jpg&quot;
‚Ä¶   , width  := 100
‚Ä¶   , height := 200
‚Ä¶   ]
‚Ä¶ ^D

&lt;img src=&quot;cat.jpg&quot; width=&quot;100&quot; height=&quot;200&quot; /&gt;
unit
</code></pre>
<h2 id="ÊºîÁøí-49"><a class="header" href="#ÊºîÁøí-49">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÁ∞°ÂçòÔºâ„Éî„ÇØ„Çª„É´„Åæ„Åü„ÅØ„Éë„Éº„Çª„É≥„Éà„ÅÆÈï∑„Åï„ÅÆ„ÅÑ„Åö„Çå„Åã„ÇíË°®„Åô„Éá„Éº„ÇøÂûã„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åù„ÅÆÂûã„Å´„Å§„ÅÑ„Å¶ <code>IsValue</code>„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ∏„ÅÑ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆÂûã„Çí‰Ωø„ÅÜ„Çà„ÅÜ„Å´ <code>width</code>„Å® <code>height</code>Â±ûÊÄß„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâÂπªÂΩ±Âûã„Çí‰Ωø„Å£„Å¶ÁúüÂÅΩÂÄ§ <code>true</code>„ÄÅ <code>false</code>Áî®„ÅÆÊúÄ‰∏ä‰Ωç„ÅÆË°®Áèæ„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åß„ÄÅ <code>AttributeKey</code>„Åå
<code>disabled</code>„ÇÑ <code>checked</code>„ÅÆ„Çà„ÅÜ„Å™<strong>Á©∫„ÅÆÂ±ûÊÄß</strong>„ÇíË°®Áèæ„Åó„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„Åã„ÇíÁ¨¶Âè∑Âåñ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data True
data False
</code></pre>
<p>ÂπªÂΩ±Âûã„Çí‰Ωø„Å£„Å¶„ÄÅ‰ΩøÁî®ËÄÖ„Åå <code>attribute</code>ÊºîÁÆóÂ≠ê„ÇíÁ©∫„ÅÆÂ±ûÊÄß„Å´ÂØæ„Åó„Å¶‰Ωø„ÅÜ„Åì„Å®„ÇíÈò≤„Åê„Çà„ÅÜ„Å´„ÄÅÂâç„ÅÆÊºîÁøí„ÅÆËß£Á≠î„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
</li>
</ol>
<h2 id="free„É¢„Éä„Éâ"><a class="header" href="#free„É¢„Éä„Éâ">Free„É¢„Éä„Éâ</a></h2>
<p>API„Å´ÊñΩ„ÅôÊúÄÂæå„ÅÆÂ§âÊõ¥„ÅØ„ÄÅ <code>Content</code>Âûã„Çí„É¢„Éä„Éâ„Å´„Åó„Å¶doË®òÊ≥ï„Çí‰Ωø„Åà„Çã„Çà„ÅÜ„Å´„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ<strong>Free„É¢„Éä„Éâ</strong>„Å®Âëº„Å∞„Çå„ÇãÊßãÈÄ†„Çí‰Ωø„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
„Åì„Çå„Å´„Çà„Å£„Å¶ÂÖ•„ÇåÂ≠ê„Å´„Å™„Å£„ÅüË¶ÅÁ¥†„Åå„Çè„Åã„Çä„ÇÑ„Åô„Åè„Å™„Çã„Çà„ÅÜ„Å´HTMLÊñáÊõ∏„ÇíÊßãÈÄ†Âåñ„Åß„Åç„Åæ„Åô„ÄÇ
‰ª•‰∏ã„ÅÆ‰ª£„Çè„Çä„Å´‚Ä¶‚Ä¶</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ]
  [ elem $ img
      [ src    := &quot;cat.jpg&quot;
      , width  := 100
      , height := 200
      ]
  , text &quot;A cat&quot;
  ]
</code></pre>
<p>„Åì„ÅÆ„Çà„ÅÜ„Å´Êõ∏„Åè„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">p [ _class := &quot;main&quot; ] $ do
  elem $ img
    [ src    := &quot;cat.jpg&quot;
    , width  := 100
    , height := 200
    ]
  text &quot;A cat&quot;
</code></pre>
<p>„Åó„Åã„Åó„ÄÅdoË®òÊ≥ï„Å†„Åë„ÅåFree„É¢„Éä„Éâ„ÅÆÊÅ©ÊÅµ„Å†„Å®„ÅÑ„ÅÜ„Çè„Åë„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
Free„É¢„Éä„Éâ„Åå„ÅÇ„Çå„Å∞„ÄÅ„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ<strong>Ë°®Áèæ</strong>„Çí„Åù„ÅÆ<strong>Ëß£Èáà</strong>„Åã„ÇâÂàÜÈõ¢„Åó„ÄÅÂêå„Åò„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´<strong>Ë§áÊï∞„ÅÆËß£Èáà</strong>„ÇíÊåÅ„Åü„Åõ„Çã„Åì„Å®„Åï„Åà„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p><code>Free</code>„É¢„Éä„Éâ„ÅØ <code>free</code>„É©„Ç§„Éñ„É©„É™„ÅÆ <code>Control.Monad.Free</code>„É¢„Ç∏„É•„Éº„É´„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
PSCi„Çí‰Ωø„ÅÜ„Å®„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´Free„É¢„Éä„Éâ„Å´„Å§„ÅÑ„Å¶„ÅÆÂü∫Êú¨ÁöÑ„Å™ÊÉÖÂ†±„ÇíË¶ã„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Control.Monad.Free

&gt; :kind Free
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p><code>Free</code>„ÅÆÁ®Æ„ÅØ„ÄÅÂºïÊï∞„Å®„Åó„Å¶ÂûãÊßãÁØâÂ≠ê„ÇíÂèñ„Çä„ÄÅÂà•„ÅÆÂûãÊßãÁØâÂ≠ê„ÇíËøî„Åô„Åì„Å®„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂÆü„ÅØ„ÄÅ <code>Free</code>„É¢„Éä„Éâ„Çí‰Ωø„Åà„Å∞‰ªªÊÑè„ÅÆ <code>Functor</code>„Çí <code>Monad</code>„Å´„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„ÅôÔºÅ</p>
<p>„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆ<strong>Ë°®Áèæ</strong>„ÇíÂÆöÁæ©„Åô„Çã„Åì„Å®„Åã„ÇâÂßã„ÇÅ„Åæ„Åô„ÄÇ
„Åì„Çå„ÇíË°å„ÅÜ„Å´„ÅØ„ÄÅ„Çµ„Éù„Éº„Éà„Åô„ÇãÂêÑ„É¢„Éä„Éâ„Ç¢„ÇØ„Ç∑„Éß„É≥„Åù„Çå„Åû„Çå„Å´„Å§„ÅÑ„Å¶„ÄÅ„Å≤„Å®„Å§„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇíÊåÅ„Å§ <code>Functor</code>„Çí‰ΩúÊàê„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰ªäÂõû„ÅÆÂ†¥Âêà„ÄÅ2„Å§„ÅÆ„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ <code>elem</code>„Å® <code>text</code>„Å´„Å™„Çä„Åæ„Åô„ÄÇ
ÂÆüÈöõ„Å´„ÅØ„ÄÅ <code>Content</code>Âûã„ÇíÊ¨°„ÅÆ„Çà„ÅÜ„Å´Â§âÊõ¥„Åô„Çã„Å†„Åë„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a

instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ„Åì„ÅÆ <code>ContentF</code>ÂûãÊßãÁØâÂ≠ê„ÅØ‰ª•Ââç„ÅÆ <code>Content</code>„Éá„Éº„ÇøÂûã„Å®„Çà„Åè‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åì„Åì„Åß„ÅØÂûãÂºïÊï∞<code>a</code>„ÇíÂèñ„Çä„ÄÅ„Åù„Çå„Åû„Çå„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅØÂûã<code>a</code>„ÅÆÂÄ§„ÇíËøΩÂä†„ÅÆÂºïÊï∞„Å®„Åó„Å¶Âèñ„Çã„Çà„ÅÜ„Å´Â§âÊõ¥„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>Functor</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„Åß„ÅØ„ÄÅÂçò„Å´ÂêÑ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅßÂûã <code>a</code>„ÅÆÊßãÊàêË¶ÅÁ¥†„Å´Èñ¢Êï∞ <code>f</code>„ÇíÈÅ©Áî®„Åó„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„Å´„Çà„Çä„ÄÅÊñ∞„Åó„ÅÑ<code>Content</code>„É¢„Éä„Éâ„Çí<code>Free</code>„É¢„Éä„ÉâÁî®„ÅÆÂûã„Ç∑„Éé„Éã„É†„Å®„Åó„Å¶ÂÆöÁæ©„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÊúÄÂàù„ÅÆÂûãÂºïÊï∞„Å®„Åó„Å¶ <code>ContentF</code>ÂûãÊßãÁØâÂ≠ê„Çí‰Ωø„ÅÜ„Åì„Å®„ÅßÊßãÁØâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Content = Free ContentF
</code></pre>
<p>Âûã„Ç∑„Éé„Éã„É†„ÅÆ‰ª£„Çè„Çä„Å´newtype„Çí‰ΩøÁî®„Åó„Å¶„ÄÅ‰ΩøÁî®ËÄÖ„Å´ÂØæ„Åó„Å¶„É©„Ç§„Éñ„É©„É™„ÅÆÂÜÖÈÉ®Ë°®Áèæ„ÇíÈú≤Âá∫„Åô„Çã„Åì„Å®„ÇíÈÅø„Åë„Çâ„Çå„Åæ„Åô„ÄÇ
<code>Content</code>„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇíÈö†„Åô„Åì„Å®„Åß„ÄÅÊèê‰æõ„Åó„Å¶„ÅÑ„Çã„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å†„Åë„Çí‰Ωø„ÅÜ„Åì„Å®„Çí‰ΩøÁî®ËÄÖ„Å´Âà∂Èôê„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p><code>ContentF</code>„ÅØ <code>Functor</code>„Å™„ÅÆ„Åß„ÄÅ <code>Free ContentF</code>Áî®„ÅÆ<code>Monad</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅåËá™ÂãïÁöÑ„Å´Êâã„Å´ÂÖ•„Çä„Åæ„Åô„ÄÇ</p>
<p><code>Content</code>„ÅÆÊñ∞„Åó„ÅÑÂûãÂºïÊï∞„ÇíËÄÉÊÖÆ„Åô„Çã„Çà„ÅÜ„Å´<code>Element</code>„Éá„Éº„ÇøÂûã„ÇíÂÉÖ„Åã„Å´Â§âÊõ¥„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„É¢„Éä„Éâ„ÅÆË®àÁÆó„ÅÆÊàª„ÇäÂÄ§„ÅÆÂûã„Åå <code>Unit</code>„Åß„ÅÇ„Çã„Åì„Å®„Å†„Åë„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Element = Element
  { name         :: String
  , attribs      :: Array Attribute
  , content      :: Maybe (Content Unit)
  }
</code></pre>
<p>„Åæ„Åü„ÄÅ <code>Content</code>„É¢„Éä„Éâ„Å´„Å§„ÅÑ„Å¶„ÅÆÊñ∞„Åó„ÅÑ„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´„Å™„Çã <code>elem</code>„Å® <code>text</code>Èñ¢Êï∞„ÇíÂ§âÊõ¥„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Çå„Å´„ÅØ<code>Control.Monad.Free</code>„É¢„Ç∏„É•„Éº„É´„ÅßÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Çã <code>liftF</code>Èñ¢Êï∞„Åå‰Ωø„Åà„Åæ„Åô„ÄÇ
„Åì„ÅÆÈñ¢Êï∞„ÅÆÂûã„ÅØÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">liftF :: forall f a. f a -&gt; Free f a
</code></pre>
<p><code>liftF</code>„Å´„Çà„Çä„ÄÅ‰Ωï„Çâ„Åã„ÅÆÂûã <code>a</code>„Å´„Å§„ÅÑ„Å¶„ÄÅÂûã <code>f a</code>„ÅÆÂÄ§„Åã„ÇâFree„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊßãÁØâ„Åß„Åç„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åô„ÄÇ
‰ªäÂõû„ÅÆÂ†¥Âêà„ÄÅ <code>ContentF</code>ÂûãÊßãÁØâÂ≠ê„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„Çí„Åù„ÅÆ„Åæ„Åæ‰Ωø„ÅÜ„Å†„Åë„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">text :: String -&gt; Content Unit
text s = liftF $ TextContent s unit

elem :: Element -&gt; Content Unit
elem e = liftF $ ElementContent e unit
</code></pre>
<p>‰ªñ„Å´„ÇÇÂêå„Åò„Çà„ÅÜ„Å™„Ç≥„Éº„Éâ„ÅÆÂ§âÊõ¥„ÅØ„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅËààÂë≥Ê∑±„ÅÑÂ§âÊõ¥„ÅØ <code>render</code>Èñ¢Êï∞„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åì„Åì„Åß„ÅØ„ÄÅ„Åì„ÅÆFree„É¢„Éä„Éâ„Çí<strong>Ëß£Èáà</strong>„Åó„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</p>
<h2 id="„É¢„Éä„Éâ„ÅÆËß£Èáà"><a class="header" href="#„É¢„Éä„Éâ„ÅÆËß£Èáà">„É¢„Éä„Éâ„ÅÆËß£Èáà</a></h2>
<p><code>Control.Monad.Free</code>„É¢„Ç∏„É•„Éº„É´„Åß„ÅØ„ÄÅFree„É¢„Éä„Éâ„ÅßË®àÁÆó„ÇíËß£Èáà„Åô„Çã„Åü„ÇÅ„ÅÆÂ§öÊï∞„ÅÆÈñ¢Êï∞„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">runFree
  :: forall f a
   . Functor f
  =&gt; (f (Free f a) -&gt; Free f a)
  -&gt; Free f a
  -&gt; a

runFreeM
  :: forall f m a
   . (Functor f, MonadRec m)
  =&gt; (f (Free f a) -&gt; m (Free f a))
  -&gt; Free f a
  -&gt; m a
</code></pre>
<p><code>runFree</code>Èñ¢Êï∞„ÅØ„ÄÅ<strong>Á¥îÁ≤ã„Å™</strong>ÁµêÊûú„ÇíË®àÁÆó„Åô„Çã„Åü„ÇÅ„Å´‰ΩøÁî®„Åï„Çå„Åæ„Åô„ÄÇ
<code>runFreeM</code>Èñ¢Êï∞„Åå„ÅÇ„Çå„Å∞Free„É¢„Éä„Éâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíËß£Èáà„Åô„Çã„Åü„ÇÅ„Å´„É¢„Éä„Éâ„Åå‰Ωø„Åà„Åæ„Åô„ÄÇ</p>
<p><strong>Ë£úË∂≥</strong>ÔºöÂé≥ÂØÜ„Å´„ÅØ„ÄÅ„Çà„ÇäÂº∑„ÅÑ<code>MonadRec</code>Âà∂Á¥Ñ„ÇíÊ∫Ä„Åü„Åô„É¢„Éä„Éâ <code>m</code>„Çí‰ΩøÁî®„Åô„Çã„Çà„ÅÜÂà∂Èôê„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
ÂÆüÈöõ„Å´„ÅØ„ÄÅ„Åì„Çå„ÅØ„Çπ„Çø„ÉÉ„ÇØ„Ç™„Éº„Éê„Éº„Éï„É≠„Éº„ÇíÂøÉÈÖç„Åô„ÇãÂøÖË¶Å„Åå„Å™„ÅÑ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Åæ„Åô„ÄÇ
„Å™„Åú„Å™„Çâ <code>m</code>„ÅØÂÆâÂÖ®„Å™<strong>Êú´Â∞æÂÜçÂ∏∞„É¢„Éä„Éâ</strong> (monadic tail recursion) „Çí„Çµ„Éù„Éº„Éà„Åô„Çã„Åã„Çâ„Åß„Åô„ÄÇ</p>
<p>„Åæ„Åö„ÄÅ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíËß£Èáà„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Çã„É¢„Éä„Éâ„ÇíÈÅ∏„Å∞„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
<code>Writer String</code>„É¢„Éä„Éâ„Çí‰Ωø„Å£„Å¶„ÄÅÁµêÊûú„ÅÆHTMLÊñáÂ≠óÂàó„ÇíÁ¥ØÁ©ç„Åô„Çã„Åì„Å®„Å´„Åó„Åæ„Åô„ÄÇ</p>
<p>Êñ∞„Åó„ÅÑ <code>render</code>„É°„ÇΩ„ÉÉ„Éâ„ÅØË£úÂä©Èñ¢Êï∞
<code>renderElement</code>„Å´ÁßªË≠≤„Åó„Å¶ÈñãÂßã„Åó„ÄÅ<code>execWriter</code>„Çí‰Ωø„Å£„Å¶<code>Writer</code>„É¢„Éä„Éâ„ÅßË®àÁÆó„ÇíËµ∞„Çâ„Åõ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render = execWriter &lt;&lt;&lt; renderElement
</code></pre>
<p><code>renderElement</code>„ÅØwhere„Éñ„É≠„ÉÉ„ÇØ„ÅßÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">  where
    renderElement :: Element -&gt; Writer String Unit
    renderElement (Element e) = do
</code></pre>
<p><code>renderElement</code>„ÅÆÂÆöÁæ©„ÅØÁõ¥ÊÑüÁöÑ„Åß„ÄÅË§áÊï∞„ÅÆÂ∞è„Åï„Å™ÊñáÂ≠óÂàó„ÇíÁ¥ØÁ©ç„Åô„Çã„Åü„ÇÅ„Å´ <code>Writer</code>„É¢„Éä„Éâ„ÅÆ <code>tell</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">      tell &quot;&lt;&quot;
      tell e.name
      for_ e.attribs $ \x -&gt; do
        tell &quot; &quot;
        renderAttribute x
      renderContent e.content
</code></pre>
<p>Ê¨°„Å´„ÄÅ<code>renderAttribute</code>Èñ¢Êï∞„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ
„Åì„Å°„Çâ„ÇÇÂêå„Åò„Åè„Çâ„ÅÑÂçòÁ¥î„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">    where
      renderAttribute :: Attribute -&gt; Writer String Unit
      renderAttribute (Attribute x) = do
        tell x.key
        tell &quot;=\&quot;&quot;
        tell x.value
        tell &quot;\&quot;&quot;
</code></pre>
<p><code>renderContent</code>Èñ¢Êï∞„ÅØ„ÄÅ„ÇÇ„Å£„Å®ËààÂë≥Ê∑±„ÅÑ„ÇÇ„ÅÆ„Åß„Åô„ÄÇ
„Åì„Åì„Åß„ÅØ<code>runFreeM</code>Èñ¢Êï∞„Çí‰Ωø„ÅÑ„ÄÅFree„É¢„Éä„Éâ„ÅÆÂÜÖÈÉ®„ÅßË®àÁÆó„ÇíËß£Èáà„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Ë®àÁÆó„ÅØË£úÂä©Èñ¢Êï∞ <code>renderContentItem</code>„Å´ÁßªË≠≤„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">      renderContent :: Maybe (Content Unit) -&gt; Writer String Unit
      renderContent Nothing = tell &quot; /&gt;&quot;
      renderContent (Just content) = do
        tell &quot;&gt;&quot;
        runFreeM renderContentItem content
        tell &quot;&lt;/&quot;
        tell e.name
        tell &quot;&gt;&quot;
</code></pre>
<p><code>renderContentItem</code>„ÅÆÂûã„ÅØ <code>runFreeM</code>„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„Åã„ÇâÊé®Ê∏¨„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
Èñ¢Êâã <code>f</code>„ÅØÂûãÊßãÁØâÂ≠ê <code>ContentF</code>„Åß„ÄÅ„É¢„Éä„Éâ <code>m</code>„ÅØËß£Èáà„Åó„Å¶„ÅÑ„ÇãË®àÁÆó„ÅÆ„É¢„Éä„Éâ„ÄÅ„Å§„Åæ„Çä <code>Writer String</code>„Åß„Åô„ÄÇ
„Åì„Çå„Å´„Çà„Çä <code>renderContentItem</code>„Å´„Å§„ÅÑ„Å¶Ê¨°„ÅÆÂûã„Ç∑„Ç∞„Éç„ÉÅ„É£„Åå„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">      renderContentItem :: ContentF (Content Unit) -&gt; Writer String (Content Unit)
</code></pre>
<p><code>ContentF</code>„ÅÆ2„Å§„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„Åß„Éë„Çø„Éº„É≥ÁÖßÂêà„Åô„Çã„Å†„Åë„Åß„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÇíÂÆüË£Ö„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">      renderContentItem (TextContent s rest) = do
        tell s
        pure rest
      renderContentItem (ElementContent e rest) = do
        renderElement e
        pure rest
</code></pre>
<p>„Åù„Çå„Åû„Çå„ÅÆÂ†¥Âêà„Å´„Åä„ÅÑ„Å¶„ÄÅÂºè <code>rest</code>„ÅØÂûã <code>Content Unit</code>„ÇíÊåÅ„Å£„Å¶„Åä„Çä„ÄÅËß£ÈáàË®àÁÆó„ÅÆÊÆã„Çä„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
<code>rest</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂëº„Å≥Âá∫„Åô„Åì„Å®„Å´„Çà„Å£„Å¶„ÄÅ„Åù„Çå„Åû„Çå„ÅÆÂ†¥Âêà„ÇíÂÆå‰∫Ü„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>„Åì„Çå„ÅßÂÆå‰∫Ü„Åß„ÅôÔºÅ
PSCi„Åß„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Åô„Çå„Å∞Êñ∞„Åó„ÅÑ„É¢„Éä„Éâ„ÅÆAPI„ÇíË©¶„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Free
&gt; import Effect.Console

&gt; :paste
‚Ä¶ log $ render $ p [] $ do
‚Ä¶   elem $ img [ src := &quot;cat.jpg&quot; ]
‚Ä¶   text &quot;A cat&quot;
‚Ä¶ ^D

&lt;p&gt;&lt;img src=&quot;cat.jpg&quot; /&gt;A cat&lt;/p&gt;
unit
</code></pre>
<h2 id="ÊºîÁøí-50"><a class="header" href="#ÊºîÁøí-50">ÊºîÁøí</a></h2>
<ol>
<li>ÔºàÊôÆÈÄöÔºâ<code>ContentF</code>Âûã„Å´Êñ∞„Åó„ÅÑ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇíËøΩÂä†„Åó„Å¶„ÄÅÁîüÊàê„Åï„Çå„ÅüHTML„Å´„Ç≥„É°„É≥„Éà„ÇíÂá∫Âäõ„Åô„ÇãÊñ∞„Åó„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥
<code>comment</code>„Å´ÂØæÂøú„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>liftF</code>„Çí‰Ωø„Å£„Å¶„Åì„ÅÆÊñ∞„Åó„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Êñ∞„Åó„ÅÑÊßãÁØâÂ≠ê„ÇíÈÅ©Âàá„Å´Ëß£Èáà„Åô„Çã„Çà„ÅÜ„Å´„ÄÅËß£Èáà <code>renderContentItem</code>„ÇíÊõ¥Êñ∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ol>
<h2 id="Ë®ÄË™û„ÅÆÊã°Âºµ"><a class="header" href="#Ë®ÄË™û„ÅÆÊã°Âºµ">Ë®ÄË™û„ÅÆÊã°Âºµ</a></h2>
<p>„Åô„Åπ„Å¶„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅåÂûã <code>Unit</code>„ÅÆ‰Ωï„Åã„ÇíËøî„Åô„Çà„ÅÜ„Å™„É¢„Éä„Éâ„ÅØ„ÄÅ„Åï„Åª„Å©ËààÂë≥Ê∑±„ÅÑ„ÇÇ„ÅÆ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
ÂÆüÈöõ„ÅÆ„Å®„Åì„Çç„ÄÅÊ¶Ç„Å≠ËâØ„Åè„Å™„Å£„Åü„Å®ÊÄù„Çè„Çå„ÇãÊßãÊñá„ÅØÂà•„Å®„Åó„Å¶„ÄÅ„Åì„ÅÆ„É¢„Éä„Éâ„ÅØ <code>Monoid</code>‰ª•‰∏ä„ÅÆÊ©üËÉΩ„Çí‰Ωï„ÇâËøΩÂä†„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</p>
<p>ÈùûËá™Êòé„Å™ÁµêÊûú„ÇíËøî„ÅôÊñ∞„Åó„ÅÑ„É¢„Éä„Éâ„Ç¢„ÇØ„Ç∑„Éß„É≥„Åß„Åì„ÅÆË®ÄË™û„ÇíÊã°Âºµ„Åô„Çã„Åì„Å®„Åß„ÄÅFree„É¢„Éä„ÉâÊßãÈÄ†„ÅÆÂ®ÅÂäõ„Çí„ÅäË¶ã„Åõ„Åó„Åæ„Åó„Çá„ÅÜ‚Äã‚Äã„ÄÇ</p>
<p><strong>„Ç¢„É≥„Ç´„Éº</strong>„Çí‰ΩøÁî®„Åó„Å¶ÊñáÊõ∏„ÅÆ„Åï„Åæ„Åñ„Åæ„Å™ÁØÄ„Å∏„ÅÆ„Éè„Ç§„Éë„Éº„É™„É≥„ÇØ„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãHTMLÊñáÊõ∏„ÇíÁîüÊàê„Åô„Çã„Å®„Åó„Åæ„Åô„ÄÇ
„Åì„Çå„ÅØÊó¢„Å´ÈÅîÊàê„Åß„Åç„Å¶„ÅÑ„Åæ„Åô„ÄÇ
Êâã‰ΩúÊ•≠„Åß„Ç¢„É≥„Ç´„Éº„ÅÆÂêçÂâç„ÇíÁîüÊàê„Åó„Å¶ÊñáÊõ∏‰∏≠„ÅßÂ∞ë„Å™„Åè„Å®„ÇÇ2Âõû„Åù„Çå„Çâ„ÇíÂê´„ÇÅ„Çå„Å∞„Çà„ÅÑ„ÅÆ„Åß„Åô„ÄÇ
1„Å§„ÅØ„Ç¢„É≥„Ç´„Éº„ÅÆÂÆöÁæ©Ëá™Ë∫´„Å´„ÄÅ„ÇÇ„ÅÜ1„Å§„ÅØ„Åù„Çå„Åû„Çå„ÅÆ„Éè„Ç§„Éë„Éº„É™„É≥„ÇØ„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åì„ÅÆÊñπÊ≥ï„Å´„ÅØÊ†πÊú¨ÁöÑ„Å™ÂïèÈ°å„Åå„ÅÑ„Åè„Å§„Åã„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<ul>
<li>ÈñãÁô∫ËÄÖ„Åå‰∏ÄÊÑè„Å™„Ç¢„É≥„Ç´„ÉºÂêç„ÅÆÁîüÊàê„Çí„ÅóÊêç„Å™„ÅÜ„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</li>
<li>ÈñãÁô∫ËÄÖ„Åå„Ç¢„É≥„Ç´„ÉºÂêç„Çí1„Å§‰ª•‰∏ä„ÅÆÁÆáÊâÄ„ÅßÊâì„Å°ÈñìÈÅï„ÅÜ„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</li>
</ul>
<p>ÈñãÁô∫ËÄÖ„ÅåË™§„Å°„ÇíÁäØ„Åô„Åì„Å®„ÇíÈò≤„Åê„Åü„ÇÅ„Å´„ÄÅ„Ç¢„É≥„Ç´„ÉºÂêç„ÇíË°®„ÅôÊñ∞„Åó„ÅÑÂûã„ÇíÂ∞éÂÖ•„Åó„ÄÅÊñ∞„Åó„ÅÑ‰∏ÄÊÑè„Å™ÂêçÂâç„ÇíÁîüÊàê„Åô„Çã„Åü„ÇÅ„ÅÆ„É¢„Éä„Éâ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊèê‰æõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂàù„ÅÆÊâãÈ†Ü„ÅØ„ÄÅÂêçÂâç„ÅÆÂûã„ÇíÊñ∞„Åó„ÅèËøΩÂä†„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ</p>
<pre><code class="language-haskell">newtype Name = Name String

runName :: Name -&gt; String
runName (Name n) = n
</code></pre>
<p>Áπ∞„ÇäËøî„Åó„Å´„Å™„Çä„Åæ„Åô„Åå„ÄÅ<code>Name</code>„ÅØ
<code>String</code>„ÅÆnewtype„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÅÆ„ÄÅ„É¢„Ç∏„É•„Éº„É´„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„É™„Çπ„ÉàÂÜÖ„Åß„Éá„Éº„ÇøÊßãÁØâÂ≠ê„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´Ê≥®ÊÑè„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<p>Ê¨°„Å´„ÄÅÂ±ûÊÄßÂÄ§„Å®„Åó„Å¶ <code>Name</code>„Çí‰Ωø„ÅÜ„Åì„Å®„Åå„Åß„Åç„Çã„Çà„ÅÜ„Å´„ÄÅÊñ∞„Åó„ÅÑÂûã„Å´<code>IsValue</code>Âûã„ÇØ„É©„Çπ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance nameIsValue :: IsValue Name where
  toValue (Name n) = n
</code></pre>
<p>„Åæ„Åü„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´ <code>a</code>Ë¶ÅÁ¥†„Å´Áèæ„Çå„Çã„Éè„Ç§„Éë„Éº„É™„É≥„ÇØÁî®„ÅÆÊñ∞„Åó„ÅÑ„Éá„Éº„ÇøÂûã„ÇíÂÆöÁæ©„Åó„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data Href
  = URLHref String
  | AnchorHref Name

instance hrefIsValue :: IsValue Href where
  toValue (URLHref url) = url
  toValue (AnchorHref (Name nm)) = &quot;#&quot; &lt;&gt; nm
</code></pre>
<p>„Åì„ÅÆÊñ∞„Åó„ÅÑÂûã„Å´„Çà„Çä„ÄÅ<code>href</code>Â±ûÊÄß„ÅÆÂûã„ÅÆÂÄ§„ÇíÂ§âÊõ¥„Åó„Å¶„ÄÅÂà©Áî®ËÄÖ„Å´„Åì„ÅÆÊñ∞„Åó„ÅÑ <code>Href</code>Âûã„ÅÆ‰ΩøÁî®„ÇíÂº∑Âà∂„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åæ„Åü„ÄÅÊñ∞„Åó„ÅÑ <code>name</code>Â±ûÊÄß„Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„ÇÇ„Åß„Åç„ÄÅË¶ÅÁ¥†„Çí„Ç¢„É≥„Ç´„Éº„Å´Â§âÊèõ„Åô„Çã„ÅÆ„Å´‰Ωø„Åà„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">href :: AttributeKey Href
href = AttributeKey &quot;href&quot;

name :: AttributeKey Name
name = AttributeKey &quot;name&quot;
</code></pre>
<p>ÊÆã„Å£„Å¶„ÅÑ„ÇãÂïèÈ°å„ÅØ„ÄÅÁèæÂú®„É¢„Ç∏„É•„Éº„É´„ÅÆ‰ΩøÁî®ËÄÖ„ÅåÊñ∞„Åó„ÅÑÂêçÂâç„ÇíÁîüÊàê„Åô„ÇãÊñπÊ≥ï„Åå„Å™„ÅÑ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Åô„ÄÇ
<code>Content</code>„É¢„Éä„Éâ„Åß„Åì„ÅÆÊ©üËÉΩ„ÇíÊèê‰æõ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ„Åæ„Åö„ÄÅ <code>ContentF</code>ÂûãÊßãÁØâÂ≠ê„Å´Êñ∞„Åó„ÅÑ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇíËøΩÂä†„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">data ContentF a
  = TextContent String a
  | ElementContent Element a
  | NewName (Name -&gt; a)
</code></pre>
<p><code>NewName</code>„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅØÂûã <code>Name</code>„ÅÆÂÄ§„ÇíËøî„Åô„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´ÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅÆÂºïÊï∞„Å®„Åó„Å¶ <code>Name</code>„ÇíË¶ÅÊ±Ç„Åô„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅÂûã <code>Name -&gt; a</code>„ÅÆ<strong>Èñ¢Êï∞</strong>„ÇíÊèê‰æõ„Åô„Çã„Çà„ÅÜ„Å´‰ΩøÁî®ËÄÖ„Å´Ë¶ÅÊ±Ç„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Âûã <code>a</code>„ÅØ<strong>Ë®àÁÆó„ÅÆÊÆã„Çä</strong>„ÇíË°®„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÊÄù„ÅÑÂá∫„Åô„Å®„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØ„ÄÅÂûã <code>Name</code>„ÅÆÂÄ§„ÅåËøî„Åï„Çå„Åü„ÅÇ„Å®„Åß„ÄÅË®àÁÆó„ÇíÁ∂ôÁ∂ö„Åô„ÇãÊñπÊ≥ï„ÇíÊèê‰æõ„Åó„Å¶„ÅÑ„Çã„ÅÆ„Å†„Å®„Çè„Åã„Çä„Åæ„Åô„ÄÇ</p>
<p>Êñ∞„Åó„ÅÑ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇíËÄÉÊÖÆ„Åô„Çã„Çà„ÅÜ„Å´„ÄÅÊ¨°„ÅÆ„Çà„ÅÜ„Å´<code>ContentF</code>Áî®„ÅÆ<code>Functor</code>„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊõ¥Êñ∞„Åô„ÇãÂøÖË¶Å„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">instance functorContentF :: Functor ContentF where
  map f (TextContent s x) = TextContent s (f x)
  map f (ElementContent e x) = ElementContent e (f x)
  map f (NewName k) = NewName (f &lt;&lt;&lt; k)
</code></pre>
<p>„Åì„Çå„Åß„ÄÅ‰ª•Ââç„Å®Âêå„Åò„Çà„ÅÜ„Å´<code>liftF</code>Èñ¢Êï∞„Çí‰Ωø„Å£„Å¶Êñ∞„Åó„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊßãÁØâ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">newName :: Content Name
newName = liftF $ NewName id
</code></pre>
<p><code>id</code>Èñ¢Êï∞„ÇíÁ∂ôÁ∂ö„Å®„Åó„Å¶Êèê‰æõ„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„Çå„ÅØÂûã <code>Name</code>„ÅÆÁµêÊûú„ÇíÂ§âÊõ¥„Åõ„Åö„Å´Ëøî„Åô„Å®„ÅÑ„ÅÜ„Åì„Å®„ÇíÊÑèÂë≥„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>ÊúÄÂæå„Å´„ÄÅÊñ∞„Åó„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíËß£Èáà„Åô„Çã„Åü„ÇÅ„Å´„ÄÅËß£ÈáàÈñ¢Êï∞„ÇíÊõ¥Êñ∞„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
‰ª•Ââç„ÅØË®àÁÆó„ÇíËß£Èáà„Åô„Çã„Åü„ÇÅ„Å´ <code>Writer String</code>„É¢„Éä„Éâ„Çí‰Ωø„Å£„Å¶„ÅÑ„Åæ„Åó„Åü„Åå„ÄÅ„Åì„ÅÆ„É¢„Éä„Éâ„ÅØÊñ∞„Åó„ÅÑÂêçÂâç„ÇíÁîüÊàê„Åô„ÇãËÉΩÂäõ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Å™„ÅÑ„ÅÆ„Åß„ÄÅ‰Ωï„Åã‰ªñ„ÅÆ„ÇÇ„ÅÆ„Å´Âàá„ÇäÊõø„Åà„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ
<code>WriterT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çí<code>State</code>„É¢„Éä„Éâ„Å®‰∏ÄÁ∑í„Å´‰Ωø„ÅÜ„Å®„ÄÅÂøÖË¶Å„Å™‰ΩúÁî®„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
ÂûãÊ≥®Èáà„ÇíÁü≠„Åè‰øù„Å¶„Çã„Çà„ÅÜ„Å´„ÄÅ„Åì„ÅÆËß£Èáà„É¢„Éä„Éâ„ÇíÂûãÂêåÁæ©Ë™û„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Å¶„Åä„Åç„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">type Interp = WriterT String (State Int)
</code></pre>
<p>„Åì„Åì„Åß„ÄÅ<code>Int</code>Âûã„ÅÆÁä∂ÊÖã„ÅØÂ¢óÂä†„Åó„Å¶„ÅÑ„Åè„Ç´„Ç¶„É≥„Çø„Å®„Åó„Å¶ÊåØ„ÇãËàû„ÅÑ„ÄÅ‰∏ÄÊÑè„Å™ÂêçÂâç„ÇíÁîüÊàê„Åô„Çã„ÅÆ„Å´‰Ωø„Çè„Çå„Åæ„Åô„ÄÇ</p>
<p><code>Writer</code>„Å® <code>WriterT</code>„É¢„Éä„Éâ„ÅØ„Åù„Çå„Çâ„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÊäΩË±°Âåñ„Åô„Çã„ÅÆ„Å´Âêå„ÅòÂûã„ÇØ„É©„Çπ„É°„É≥„Éê„Çí‰Ωø„ÅÜ„ÅÆ„Åß„ÄÅ„Å©„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇÇÂ§âÊõ¥„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
ÂøÖË¶Å„Å™„ÅÆ„ÅØ„ÄÅ <code>Writer String</code>„Å∏„ÅÆÂèÇÁÖß„Åô„Åπ„Å¶„Çí <code>Interp</code>„ÅßÁΩÆ„ÅçÊèõ„Åà„Çã„Åì„Å®„Å†„Åë„Åß„Åô„ÄÇ
„Åó„Åã„Åó„ÄÅ„Åì„ÅÆË®àÁÆó„ÇíÂÆüË°å„Åô„Çã„Åü„ÇÅ„Å´‰Ωø„Çè„Çå„Çã„Éè„É≥„Éâ„É©„ÇíÂ§âÊõ¥„Åó„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ
Âçò„Å™„Çã<code>execWriter</code>„ÅÆ‰ª£„Çè„Çä„Å´„ÄÅ‰ªä„ÇÑ„Åì„Åì„Åß„ÇÇ<code>evalState</code>„Çí‰Ωø„ÅÜÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ</p>
<pre><code class="language-haskell">render :: Element -&gt; String
render e = evalState (execWriterT (renderElement e)) 0
</code></pre>
<p>„Åæ„Åü„ÄÅÊñ∞„Åó„ÅÑ <code>NewName</code>„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÇíËß£Èáà„Åô„Çã„Åü„ÇÅ„Å´„ÄÅ <code>renderContentItem</code>„Å´Êñ∞„Åó„ÅÑÂ†¥Âêà„ÇíËøΩÂä†„Åó„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ</p>
<pre><code class="language-haskell">renderContentItem (NewName k) = do
  n &lt;- get
  let fresh = Name $ &quot;name&quot; &lt;&gt; show n
  put $ n + 1
  pure (k fresh)
</code></pre>
<p>„Åì„Åì„Åß„ÄÅÂûã <code>Name -&gt; Content a</code>„ÅÆÁ∂ôÁ∂ö <code>k</code>„Åå‰∏é„Åà„Çâ„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß„ÄÅÂûã <code>Content a</code>„ÅÆËß£Èáà„ÇíÊßãÁØâ„Åó„Å™„Åë„Çå„Å∞„ÅÑ„Åë„Åæ„Åõ„Çì„ÄÇ
„Åì„ÅÆËß£Èáà„ÅØÂçòÁ¥î„Åß„Åô„ÄÇ
<code>get</code>„Çí‰Ωø„Å£„Å¶Áä∂ÊÖã„ÇíË™≠„Åø„ÄÅ„Åù„ÅÆÁä∂ÊÖã„Çí‰Ωø„Å£„Å¶‰∏ÄÊÑè„Å™ÂêçÂâç„ÇíÁîüÊàê„Åó„ÄÅ„Åù„Çå„Åã„Çâ <code>put</code>„ÅßÁä∂ÊÖã„Çí„Ç§„É≥„ÇØ„É™„É°„É≥„Éà„Åô„Çã„ÅÆ„Åß„Åô„ÄÇ
ÊúÄÂæå„Å´„ÄÅÁ∂ôÁ∂ö„Å´„Åì„ÅÆÊñ∞„Åó„ÅÑÂêçÂâç„ÇíÊ∏°„Åó„Å¶„ÄÅË®àÁÆó„ÇíÂÆå‰∫Ü„Åó„Åæ„Åô„ÄÇ</p>
<p>‰ª•‰∏ä„Çí„ÇÇ„Å£„Å¶„ÄÅ„Åì„ÅÆÊñ∞„Åó„ÅÑÊ©üËÉΩ„ÇíPSCi„ÅßË©¶„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
„Åì„Çå„Å´„ÅØ<code>Content</code>„É¢„Éä„Éâ„ÅÆÂÜÖÈÉ®„Åß‰∏ÄÊÑè„Å™ÂêçÂâç„ÇíÁîüÊàê„Åó„ÄÅË¶ÅÁ¥†„ÅÆÂêçÂâç„Å®„Éè„Ç§„Éë„Éº„É™„É≥„ÇØ„ÅÆ„É™„É≥„ÇØÂÖà„ÅÆ‰∏°Êñπ„Å®„Åó„Å¶‰Ωø„ÅÑ„Åæ„Åô„ÄÇ</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Data.DOM.Name
&gt; import Effect.Console

&gt; :paste
‚Ä¶ render $ p [ ] $ do
‚Ä¶   top &lt;- newName
‚Ä¶   elem $ a [ name := top ] $
‚Ä¶     text &quot;Top&quot;
‚Ä¶   elem $ a [ href := AnchorHref top ] $
‚Ä¶     text &quot;Back to top&quot;
‚Ä¶ ^D

&lt;p&gt;&lt;a name=&quot;name0&quot;&gt;Top&lt;/a&gt;&lt;a href=&quot;#name0&quot;&gt;Back to top&lt;/a&gt;&lt;/p&gt;
unit
</code></pre>
<p>Ë§áÊï∞Âõû„ÅÆ <code>newName</code>„ÅÆÂëº„Å≥Âá∫„Åó„ÅÆÁµêÊûú„Åå„ÄÅÂÆüÈöõ„Å´‰∏ÄÊÑè„Å™ÂêçÂâç„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫„Åã„ÇÅ„Çâ„Çå„Åæ„Åô„ÄÇ</p>
<h2 id="ÊºîÁøí-51"><a class="header" href="#ÊºîÁøí-51">ÊºîÁøí</a></h2>
<ol>
<li>
<p>ÔºàÊôÆÈÄöÔºâ‰ΩøÁî®ËÄÖ„Åã„Çâ <code>Element</code>Âûã„ÇíÈö†ËîΩ„Åô„Çã„Å®„ÄÅ„Åï„Çâ„Å´API„ÇíÁ∞°Á¥†Âåñ„Åô„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
Ê¨°„ÅÆÊâãÈ†Ü„Å´Âæì„Å£„Å¶„ÄÅ„Åì„ÅÆÂ§âÊõ¥„ÇíÂä†„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<ul>
<li><code>p</code>„ÇÑ <code>img</code>„ÅÆ„Çà„ÅÜ„Å™ÔºàËøî„ÇãÂûã„Åå <code>Element</code>„ÅÆÔºâÈñ¢Êï∞„Çí <code>elem</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®ÁµêÂêà„Åó„Å¶„ÄÅÂûã <code>Content Unit</code>„ÇíËøî„ÅôÊñ∞„Åó„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰Ωú„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
<li><code>Element</code>„ÅÆ‰ª£„Çè„Çä„Å´Âûã<code>Content Unit</code>„ÅÆÂºïÊï∞„ÇíÂèó„Åë‰ªò„Åë„Çã„Çà„ÅÜ„Å´<code>render</code>Èñ¢Êï∞„ÇíÂ§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</li>
</ul>
</li>
<li>
<p>ÔºàÊôÆÈÄöÔºâÂûãÂêåÁæ©Ë™û„ÅÆ‰ª£„Çè„Çä„Å´<code>newtype</code>„Çí‰Ωø„ÅÜ„Åì„Å®„Å´„Çà„Å£„Å¶<code>Content</code>„É¢„Éä„Éâ„ÅÆÂÆüË£Ö„ÇíÈö†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
<code>newtype</code>Áî®„ÅÆ„Éá„Éº„ÇøÊßãÁØâÂ≠ê„ÅØ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åô„Åπ„Åç„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
</li>
<li>
<p>ÔºàÈõ£„Åó„ÅÑÔºâ<code>ContentF</code>Âûã„ÇíÂ§âÊõ¥„Åó„Å¶‰ª•‰∏ã„ÅÆÊñ∞„Åó„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´ÂØæÂøú„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
<pre><code class="language-haskell">isMobile :: Content Boolean
</code></pre>
<p>„Åì„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅØ„ÄÅ„Åì„ÅÆÊñáÊõ∏„Åå„É¢„Éê„Ç§„É´„Éá„Éê„Ç§„Çπ‰∏ä„Åß„ÅÆË°®Á§∫„ÅÆ„Åü„ÇÅ„Å´„É¨„É≥„ÉÄ„É™„É≥„Ç∞„Åï„Çå„Å¶„ÅÑ„Çã„Åã„Å©„ÅÜ„Åã„ÇíÁ§∫„ÅôÁúüÂÅΩÂÄ§„ÇíËøî„Åó„Åæ„Åô„ÄÇ</p>
<p><strong>„Éí„É≥„Éà</strong>Ôºö<code>ask</code>„Ç¢„ÇØ„Ç∑„Éß„É≥„Å®<code>ReaderT</code>„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çí‰Ωø„Å£„Å¶„ÄÅ„Åì„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíËß£Èáà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„ÅÇ„Çã„ÅÑ„ÅØ„ÄÅ<code>RWS</code>„É¢„Éä„Éâ„Çí‰Ωø„ÅÜ„Åª„ÅÜ„ÅåÂ•Ω„Åø„ÅÆ‰∫∫„ÇÇ„ÅÑ„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ</p>
</li>
</ol>
<h2 id="„Åæ„Å®„ÇÅ-12"><a class="header" href="#„Åæ„Å®„ÇÅ-12">„Åæ„Å®„ÇÅ</a></h2>
<p>„Åì„ÅÆÁ´†„Åß„ÅØ„ÄÅ„ÅÑ„Åè„Å§„Åã„ÅÆÊ®ôÊ∫ñÁöÑ„Å™ÊäÄË°ì„Çí‰Ωø„Å£„Å¶„ÄÅÁ¥†Êú¥„Å™ÂÆüË£Ö„ÇíÊÆµÈöéÁöÑ„Å´ÊîπÂñÑ„Åô„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅHTMLÊñáÊõ∏„Çí‰ΩúÊàê„Åô„Çã„Åü„ÇÅ„ÅÆÈ†òÂüüÁâπÂåñË®ÄË™û„ÇíÈñãÁô∫„Åó„Åæ„Åó„Åü„ÄÇ</p>
<ul>
<li><strong>„Çπ„Éû„Éº„ÉàÊßãÁØâÂ≠ê</strong>„Çí‰Ωø„Å£„Å¶„Éá„Éº„ÇøË°®Áèæ„ÅÆË©≥Á¥∞„ÇíÈö†„Åó„ÄÅÂà©Áî®ËÄÖ„Å´„ÅØ<strong>ÊßãÁØâ„Å´„Çà„ÇäÊ≠£„Åó„ÅÑ</strong>ÊñáÊõ∏„Å†„Åë„Çí‰Ωú„Çã„Åì„Å®„ÇíË®±„Åó„Åæ„Åó„Åü„ÄÇ</li>
<li><strong>Áã¨Ëá™„Å´ÂÆöÁæ©„Åï„Çå„Åü‰∏≠ÁΩÆ2ÂºïÊï∞ÊºîÁÆóÂ≠ê</strong>„Çí‰Ωø„ÅÑË®ÄË™û„ÅÆÊßãÊñá„ÇíÊîπÂñÑ„Åó„Åæ„Åó„Åü„ÄÇ</li>
<li><strong>ÂπªÂΩ±Âûã</strong>„Çí‰Ωø„Å£„Å¶„Éá„Éº„Çø„ÅÆÂûã„ÅÆ‰∏≠„Å´ËøΩÂä†„ÅÆÊÉÖÂ†±„ÇíÊäò„ÇäËæº„Åø„Åæ„Åó„Åü„ÄÇ
„Åì„Çå„Å´„Çà„ÇäÂà©Áî®ËÄÖ„ÅåË™§„Å£„ÅüÂûã„ÅÆÂ±ûÊÄßÂÄ§„Çí‰∏é„Åà„Çã„Åì„Å®„ÇíÈò≤„ÅÑ„Åß„ÅÑ„Åæ„Åô„ÄÇ</li>
<li><strong>Free„É¢„Éä„Éâ</strong>„Çí‰Ωø„Å£„Å¶ÂÜÖÂÆπ„ÅÆÈõÜ„Åæ„Çä„ÅÆÈÖçÂàóË°®Áèæ„ÇídoË®òÊ≥ï„Å´ÂØæÂøú„Åó„Åü„É¢„Éä„Éâ„Å™Ë°®Áèæ„Å´Â§â„Åà„Åæ„Åó„Åü„ÄÇ
„Åù„Çå„Åã„Çâ„Åì„ÅÆË°®Áèæ„ÇíÊñ∞„Åó„ÅÑ„É¢„Éä„Éâ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å´ÂØæÂøú„Åô„Çã„Çà„ÅÜÊã°Âºµ„Åó„ÄÅÊ®ôÊ∫ñ„É¢„Éä„ÉâÂ§âÊèõÂ≠ê„Çí‰Ωø„Å£„Å¶„É¢„Éä„Éâ„ÅÆË®àÁÆó„ÇíËß£Èáà„Åó„Åæ„Åó„Åü„ÄÇ</li>
</ul>
<p>„Åì„Çå„Çâ„ÅÆÊâãÊ≥ï„ÅØ„Åô„Åπ„Å¶„ÄÅ‰ΩøÁî®ËÄÖ„ÅåÈñìÈÅï„ÅÑ„ÇíÁäØ„Åô„ÅÆ„ÇíÈò≤„ÅÑ„Å†„ÇäÈ†òÂüüÁâπÂåñË®ÄË™û„ÅÆÊßãÊñá„ÇíÊîπËâØ„Åó„Åü„Çä„Åô„Çã„Åü„ÇÅ„Å´„ÄÅPureScript„ÅÆ„É¢„Ç∏„É•„Éº„É´„Å®Âûã„Ç∑„Çπ„ÉÜ„É†„ÇíÊ¥ªÁî®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ</p>
<p>Èñ¢Êï∞Âûã„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û„Å´„Çà„ÇãÈ†òÂüüÁâπÂåñË®ÄË™û„ÅÆÂÆüË£Ö„ÅØÊ¥ªÁô∫„Å´Á†îÁ©∂„Åï„Çå„Å¶„ÅÑ„ÇãÂàÜÈáé„Åß„Åô„Åå„ÄÅ„ÅÑ„Åè„Å§„Åã„ÅÆÁ∞°Âçò„Å™ÊäÄÊ≥ï„Å´ÂØæ„Åó„Å¶ÂΩπ„Å´Á´ã„Å§Â∞éÂÖ•„ÇíÊèê‰æõ„Åó„ÄÅË°®ÁèæÂäõË±ä„Åã„Å™Âûã„ÇíÊåÅ„Å§Ë®ÄË™û„Åß‰ΩúÊ•≠„Åô„Çã„Åì„Å®„ÅÆÂ®ÅÂäõ„ÇíÁ§∫„Åô„Åì„Å®„Åå„Åß„Åç„Å¶„ÅÑ„Çå„Å∞Âπ∏„ÅÑ„Åß„Åô„ÄÇ</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>

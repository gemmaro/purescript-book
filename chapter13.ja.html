<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>テストの自動生成 - PureScript by Example</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.ja.html"><strong aria-hidden="true">15.</strong> 序文 (Foreword)</a></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">16.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">17.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">18.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">19.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html"><strong aria-hidden="true">20.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html"><strong aria-hidden="true">21.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">22.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">23.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">24.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.ja.html"><strong aria-hidden="true">25.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.ja.html"><strong aria-hidden="true">26.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.ja.html"><strong aria-hidden="true">27.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.ja.html" class="active"><strong aria-hidden="true">28.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.ja.html"><strong aria-hidden="true">29.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="テストの自動生成"><a class="header" href="#テストの自動生成">テストの自動生成</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章では、テスティングの問題に対する、型クラスの特に洗練された応用について示します。<strong>どのように</strong>テストするのかをコンパイラに教えるのではなく、コードが<strong>どのような</strong>性質を持っているべきかを教えることでテストします。型クラスを使って無作為データ生成のための定型コードを隠し、テストケースを仕様から無作為に生成することができます。これは<strong>生成的テスティング</strong>（generative
testing、または<strong>property-based
testing</strong>）と呼ばれ、Haskellの<a href="http://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a>ライブラリによって普及した手法です。</p>
<p><code>quickcheck</code>パッケージはHaskellのQuickCheckライブラリをPureScriptにポーティングしたもので、型や構文はもとのライブラリとほとんど同じようになっています。
<code>quickcheck</code>を使って簡単なライブラリをテストし、Spagoでテストスイートを自動化されたビルドに統合する方法を見ていきます。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>この章のプロジェクトには依存関係として <code>quickcheck</code>が追加されます。</p>
<p>Spagoプロジェクトでは、テストソースは <code>test</code>ディレクトリに置かれ、テストスイートのメインモジュールは
<code>Test.Main</code>と名づけられます。 テストスイートは、 <code>spago test</code>コマンドを使用して実行できます。</p>
<h2 id="性質を書く"><a class="header" href="#性質を書く">性質を書く</a></h2>
<p><code>Merge</code>モジュールでは簡単な関数 <code>merge</code>が実装されています。
これを<code>quickcheck</code>ライブラリの機能を実演するために使っていきます。</p>
<pre><code class="language-haskell">merge :: Array Int -&gt; Array Int -&gt; Array Int
</code></pre>
<p><code>merge</code>は2つの整列された整数の配列を取って、結果が整列されるように要素を統合します。
例えば次のようになります。</p>
<pre><code class="language-text">&gt; import Merge
&gt; merge [1, 3, 5] [2, 4, 5]

[1, 2, 3, 4, 5, 5]
</code></pre>
<p>典型的なテストスイートでは、手作業でこのような小さなテストケースをいくつも作成し、結果が正しい値と等しいことを確認することでテストを実施します。
しかし、 <code>merge</code>関数について知る必要があるものはすべて、こちらの性質に要約することができます。</p>
<ul>
<li><code>xs</code>と <code>ys</code>がソート済みなら、<code>merge xs ys</code>は両方の配列が一緒に結合され整列された結果になります。</li>
</ul>
<p><code>quickcheck</code>では、無作為なテストケースを生成することで、直接この性質をテストすることができます。コードが持つべき性質を関数として述べるだけです。
この場合は1つの性質があります。</p>
<pre><code class="language-haskell">main = do
  quickCheck \xs ys -&gt;
    eq (merge (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>このコードを実行すると、 <code>quickcheck</code>は無作為な入力 <code>xs</code>と
<code>ys</code>を生成してこの関数に渡すことで、主張しようとしている性質を反証しようとします。
何らかの入力に対して関数が <code>false</code>を返した場合、性質は正しくないことが示され、ライブラリはエラーを発生させます。
幸いなことに、次のように100個の無作為なテストケースを生成しても、ライブラリはこの性質を反証することができません。</p>
<pre><code class="language-text">$ spago test

Installation complete.
Build succeeded.
100/100 test(s) passed.
...
Tests succeeded.
</code></pre>
<p>もし
<code>merge</code>関数に意図的にバグを混入した場合（例えば、大なりのチェックを小なりのチェックへと変更するなど）、最初に失敗したテストケースの後で例外が実行時に投げられます。</p>
<pre><code class="language-text">Error: Test 1 failed:
Test returned false
</code></pre>
<p>見ての通りこのエラーメッセージではあまり役に立ちませんが、少し工夫するだけで改良することができます。</p>
<h2 id="エラーメッセージの改善"><a class="header" href="#エラーメッセージの改善">エラーメッセージの改善</a></h2>
<p>テストケースが失敗した時に同時にエラーメッセージを提供する上で、
<code>quickcheck</code>は<code>&lt;?&gt;</code>演算子を提供しています。
次のように性質の定義とエラー文言を<code>&lt;?&gt;</code>で区切って書くだけです。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  let
    result = merge (sort xs) (sort ys)
    expected = sort $ xs &lt;&gt; ys
  in
    eq result expected &lt;?&gt; &quot;Result:\n&quot; &lt;&gt; show result &lt;&gt; &quot;\nnot equal to expected:\n&quot; &lt;&gt; show expected
</code></pre>
<p>このとき、もしバグを混入するようにコードを変更すると、最初のテストケースが失敗したときに改良されたエラーメッセージが表示されます。</p>
<pre><code class="language-text">Error: Test 1 (seed 534161891) failed:
Result:
[-822215,-196136,-116841,618343,887447,-888285]
not equal to expected:
[-888285,-822215,-196136,-116841,618343,887447]
</code></pre>
<p>入力 <code>xs</code>が無作為に選ばれた数の配列として生成されていることに注目してください。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>（簡単）配列に空の配列を統合しても元の配列は変更されないことを確かめる性質を書いてください。
<strong>補足</strong>：この新しい性質は冗長です。
というのもこの状況は既に既存の性質で押さえられているからです。
読者がQuickCheckを使う練習をするための簡単な方法を与えようとしているだけです。</li>
<li>（簡単） <code>merge</code>の残りの性質に対して、適切なエラーメッセージを追加してください。</li>
</ol>
<h2 id="多相的なコードのテスト"><a class="header" href="#多相的なコードのテスト">多相的なコードのテスト</a></h2>
<p><code>Merge</code>モジュールでは、数の配列だけでなく、 <code>Ord</code>型クラスに属するどんな型の配列に対しても動作する、 <code>merge</code>関数を一般化した
<code>mergePoly</code>という関数が定義されています。</p>
<pre><code class="language-haskell">mergePoly :: forall a. Ord a =&gt; Array a -&gt; Array a -&gt; Array a
</code></pre>
<p><code>merge</code>の代わりに <code>mergePoly</code>を使うように元のテストを変更すると、次のようなエラーメッセージが表示されます。</p>
<pre><code class="language-text">No type class instance was found for

  Test.QuickCheck.Arbitrary.Arbitrary t0

The instance head contains unknown type variables.
Consider adding a type annotation.
</code></pre>
<p>このエラーメッセージは、配列に持たせたい要素の型が何なのかわからないので、コンパイラが無作為なテストケースを生成できなかったということを示しています。
このような場合、型註釈を使ってコンパイラが特定の型を推論するように強制できます。
例えば<code>Array Int</code>などです。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>代替案として型を指定する補助関数を使うこともできます。
こうするとより見通しのよいコードになることがあります。
例えば同値関数の同義な関数<code>ints</code>を定義したとしましょう。</p>
<pre><code class="language-haskell">ints :: Array Int -&gt; Array Int
ints = id
</code></pre>
<p>それから、コンパイラが引数の2つの配列の型 <code>Array Int</code>を推論するように、テストを変更します。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>ここで、 <code>ints</code>関数が不明な型を解消するために使われているため、 <code>xs</code>と <code>ys</code>はどちらも型 <code>Array Int</code>を持っています。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（簡単）<code>xs</code>と <code>ys</code>の型を <code>Array Boolean</code>に強制する関数 <code>bools</code>を書き、
<code>mergePoly</code>をその型でテストする性質を追加してください。</li>
<li>（普通）標準関数から（例えば
<code>arrays</code>パッケージから）ひとつ関数を選び、適切なエラーメッセージを含めてQuickCheckの性質を書いてください。その性質は、補助関数を使って多相型引数を
<code>Int</code>か <code>Boolean</code>のどちらかに固定しなければいけません。</li>
</ol>
<h2 id="任意のデータの生成"><a class="header" href="#任意のデータの生成">任意のデータの生成</a></h2>
<p><code>quickcheck</code>ライブラリを使って性質に対するテストケースを無作為に生成する方法について説明します。</p>
<p>無作為に値を生成することができるような型は、次のような型クラス <code>Arbitary</code>のインスタンスを持っています。</p>
<pre><code class="language-haskell">class Arbitrary t where
  arbitrary :: Gen t
</code></pre>
<p><code>Gen</code>型構築子は<strong>決定的無作為データ生成</strong>の副作用を表しています。
決定的無作為データ生成は、擬似乱数生成器を使って、シード値から決定的無作為関数の引数を生成します。
<code>Test.QuickCheck.Gen</code>モジュールは、ジェネレータを構築するためのいくつかの有用なコンビネータを定義しています。</p>
<p><code>Gen</code>はモナドでもアプリカティブ関手でもあるので、
<code>Arbitary</code>型クラスの新しいインスタンスを作成するのに、いつも使っているようなコンビネータを自由に使うことができます。</p>
<p>例えば、 <code>quickcheck</code>ライブラリで提供されている <code>Int</code>型用の
<code>Arbitrary</code>インスタンスを使い、256個のバイト値上の分布を作ることができます。
これには<code>Gen</code>用に<code>Functor</code>インスタンスを使って整数から任意の整数値のバイトまでマップします。</p>
<pre><code class="language-haskell">newtype Byte = Byte Int

instance arbitraryByte :: Arbitrary Byte where
  arbitrary = map intToByte arbitrary
    where
    intToByte n | n &gt;= 0 = Byte (n `mod` 256)
                | otherwise = intToByte (-n)
</code></pre>
<p>ここでは、0から255までの間の整数値であるような型 <code>Byte</code>を定義しています。
<code>Arbitrary</code>インスタンスは <code>map</code>演算子を使って、 <code>intToByte</code>関数を <code>arbitrary</code>アクションまで持ち上げています。
<code>arbitrary</code>アクション内部の型は <code>Gen Int</code>と推論されます。</p>
<p>この考え方を <code>merge</code>用のテストに使うこともできます。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs &lt;&gt; ys)
</code></pre>
<p>このテストでは、任意の配列 <code>xs</code>と <code>ys</code>を生成しますが、 <code>merge</code>はソート済みの入力を期待しているので、 <code>xs</code>と
<code>ys</code>をソートしておかなければなりません。一方で、ソートされた配列を表すnewtypeを作成し、ソートされたデータを生成する
<code>Arbitrary</code>インスタンスを書くこともできます。</p>
<pre><code class="language-haskell">newtype Sorted a = Sorted (Array a)

sorted :: forall a. Sorted a -&gt; Array a
sorted (Sorted xs) = xs

instance arbSorted :: (Arbitrary a, Ord a) =&gt; Arbitrary (Sorted a) where
  arbitrary = map (Sorted &lt;&lt;&lt; sort) arbitrary
</code></pre>
<p>この型構築子を使うと、テストを次のように変更することができます。</p>
<pre><code class="language-haskell">quickCheck \xs ys -&gt;
  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs &lt;&gt; sorted ys)
</code></pre>
<p>これは些細な変更に見えるかもしれませんが、 <code>xs</code>と <code>ys</code>の型はただの <code>Array Int</code>から <code>Sorted Int</code>へと変更されています。これにより、
<code>mergePoly</code>関数はソート済みの入力を取る、という<strong>意図</strong>を、わかりやすく示すことができます。理想的には、
<code>mergePoly</code>関数自体の型が <code>Sorted</code>型構築子を使うようにするといいでしょう。</p>
<p>より興味深い例として、 <code>Tree</code>モジュールでは枝の値でソートされた二分木の型が定義されています。</p>
<pre><code class="language-haskell">data Tree a
  = Leaf
  | Branch (Tree a) a (Tree a)
</code></pre>
<p><code>Tree</code>モジュールでは次のAPIが定義されています。</p>
<pre><code class="language-haskell">insert    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Tree a
member    :: forall a. Ord a =&gt; a -&gt; Tree a -&gt; Boolean
fromArray :: forall a. Ord a =&gt; Array a -&gt; Tree a
toArray   :: forall a. Tree a -&gt; Array a
</code></pre>
<p><code>insert</code>関数は新しい要素をソート済みの二分木に挿入するのに使われ、
<code>member</code>関数は特定の値の有無を木に問い合わせるのに使われます。例えば次のようになります。</p>
<pre><code class="language-text">&gt; import Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false
</code></pre>
<p><code>toArray</code>関数と <code>fromArray</code>関数は、ソートされた木とソートされた配列を相互に変換するために使われます。
<code>fromArray</code>を使うと、木についての <code>Arbitrary</code>インスタンスを書くことができます。</p>
<pre><code class="language-haskell">instance arbTree :: (Arbitrary a, Ord a) =&gt; Arbitrary (Tree a) where
  arbitrary = map fromArray arbitrary
</code></pre>
<p>型 <code>a</code>についての<code>Arbitary</code>インスタンスが使えるなら、テストする性質の引数の型として <code>Tree a</code>を使うことができます。例えば、
<code>member</code>テストは値を挿入した後は常に <code>true</code>を返すことをテストできます。</p>
<pre><code class="language-haskell">quickCheck \t a -&gt;
  member a $ insert a $ treeOfInt t
</code></pre>
<p>ここでは、引数 <code>t</code>は <code>Tree Number</code>型の無作為に生成された木です。
型引数は、同値関数 <code>treeOfInt</code>によって明確化されています。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>（普通） <code>a-z</code>の範囲から無作為に選ばれた文字の集まりを生成する <code>Arbitrary</code>インスタンスを持った、
<code>String</code>のnewtypeを作ってください。<strong>ヒント</strong>：<code>Test.QuickCheck.Gen</code>モジュールから
<code>elements</code>と <code>arrayOf</code>関数を使います。</li>
<li>（難しい） 木に挿入された値は、どれだけ挿入があった後でも、その木の構成要素であることを主張する性質を書いてください。</li>
</ol>
<h2 id="高階関数のテスト"><a class="header" href="#高階関数のテスト">高階関数のテスト</a></h2>
<p><code>Merge</code>モジュールは <code>merge</code>関数の別の一般化も定義します。
<code>mergeAith</code>関数は追加の関数を引数として取り、統合される要素の順序を決
定するのに使われます。つまり <code>mergeWith</code>は高階関数です。</p>
<p>例えば<code>length</code>関数を最初の引数として渡し、既に長さの昇順になっている2
つの配列を統合することができます。このとき、結果も長さの昇順になってい
なければなりません。</p>
<pre><code class="language-haskell">&gt; import Data.String

&gt; mergeWith length
    [&quot;&quot;, &quot;ab&quot;, &quot;abcd&quot;]
    [&quot;x&quot;, &quot;xyz&quot;]

[&quot;&quot;,&quot;x&quot;,&quot;ab&quot;,&quot;xyz&quot;,&quot;abcd&quot;]
</code></pre>
<p>このような関数をテストするにはどうしたらいいでしょうか。理想的には、関
数である最初の引数を含めた、3つの引数すべてについて、値を生成したいと
思うでしょう。</p>
<p>関数を無作為に生成できるようにする、もう1つの型クラスがあります。この
型クラスは <code>Coarbitrary</code>と呼ばれており、次のように定義されています。</p>
<pre><code class="language-haskell">class Coarbitrary t where
  coarbitrary :: forall r. t -&gt; Gen r -&gt; Gen r
</code></pre>
<p><code>coarbitrary</code>関数は、型 <code>t</code>と、関数の結果の型 <code>r</code>についての乱数生成器
を関数の引数としてとり、乱数生成器を<strong>かき乱す</strong>のにこの引数を使います。
つまり関数の引数を使って、乱数生成器の無作為な出力を変更しているのです。</p>
<p>また、もし関数の定義域が <code>Coarbitrary</code>で、値域が <code>Arbitrary</code>なら、
<code>Arbitrary</code>の関数を与える型クラスインスタンスが存在しています。</p>
<pre><code class="language-haskell">instance arbFunction :: (Coarbitrary a, Arbitrary b) =&gt; Arbitrary (a -&gt; b)
</code></pre>
<p>実は、これが意味しているのは、引数として関数を取るような性質を記述でき
るということです。 <code>mergeWith</code>関数の場合では、新しい引数を考慮するよう
にテストを修正すると、最初の引数を無作為に生成することができます。</p>
<p>結果が整列されているということを保証することができません。必ずしも
<code>Ord</code>インスタンスを持っているとさえ限らないのです。しかし、引数として
渡す関数 <code>f</code>にしたがって結果が整列されていることは期待されます。さらに、
2つの入力配列が <code>f</code>に従って整列されている必要がありますので、
<code>sortBy</code>関数を使って関数 <code>f</code>が適用されたあとの比較に基づいて <code>xs</code>と
<code>ys</code>を整列します。</p>
<pre><code class="language-haskell">quickCheck \xs ys f -&gt;
  let
    result =
      map f $
        mergeWith (intToBool f)
                  (sortBy (compare `on` f) xs)
                  (sortBy (compare `on` f) ys)
    expected =
      map f $
        sortBy (compare `on` f) $ xs &lt;&gt; ys
  in
    eq result expected
</code></pre>
<p>ここでは、関数 <code>f</code>の型を明確にするために、関数 <code>intToBool</code>を使用しています。</p>
<pre><code class="language-haskell">intToBool :: (Int -&gt; Boolean) -&gt; Int -&gt; Boolean
intToBool = id
</code></pre>
<p>関数は <code>Arbitrary</code>であるだけでなく <code>Coarbitrary</code>でもあります。</p>
<pre><code class="language-haskell">instance coarbFunction :: (Arbitrary a, Coarbitrary b) =&gt; Coarbitrary (a -&gt; b)
</code></pre>
<p>これは値の生成が単純な関数だけに限定されるものではないことを意味してい
ます。つまり、<strong>高階関数</strong>や、引数が高階関数であるような関数もまた無作
為に生成することができるのです。</p>
<h2 id="coarbitraryのインスタンスを書く"><a class="header" href="#coarbitraryのインスタンスを書く">Coarbitraryのインスタンスを書く</a></h2>
<p><code>Gen</code>の <code>Monad</code>や <code>Applicative</code>インスタンスを使って独自のデータ型に対
して <code>Arbitrary</code>インスタンスを書くことができるのとちょうど同じように、
独自の <code>Coarbitrary</code>インスタンスを書くこともできます。これにより、無作
為に生成される関数の定義域として、独自のデータ型を使うことができるよう
になります。</p>
<p><code>Tree</code>型の <code>Coarbitrary</code>インスタンスを書いてみましょう。枝に格納されて
いる要素の型に <code>Coarbitrary</code>インスタンスが必要になります。</p>
<pre><code class="language-haskell">instance coarbTree :: Coarbitrary a =&gt; Coarbitrary (Tree a) where
</code></pre>
<p>型 <code>Tree a</code>の値が与えられたときに、乱数発生器をかき乱す関数を記述する
必要があります。入力値が <code>Leaf</code>であれば、そのままの生成器を返します。</p>
<pre><code class="language-haskell">  coarbitrary Leaf = id
</code></pre>
<p>もし木が <code>Branch</code>なら、左の部分木、値、右の部分木を使って生成器をかき乱します。
関数合成を使って独自のかき乱し関数を作ります。</p>
<pre><code class="language-haskell">  coarbitrary (Branch l a r) =
    coarbitrary l &lt;&lt;&lt;
    coarbitrary a &lt;&lt;&lt;
    coarbitrary r
</code></pre>
<p>これで、木を引数にとるような関数を引数に含む性質を自由に書くことができ
るようになりました。たとえば、 <code>Tree</code>モジュールでは<code>anywhere</code>が定義さ
れており、これは述語が引数のどんな部分木についても成り立っているかを調
べる関数です。</p>
<pre><code class="language-haskell">anywhere :: forall a. (Tree a -&gt; Boolean) -&gt; Tree a -&gt; Boolean
</code></pre>
<p>これで、無作為にこの述語関数 <code>anywhere</code>を生成することができるようにな
りました。例えば、 <code>anywhere</code>関数は<strong>ある命題のもとで不変</strong>であること
が期待されます。</p>
<pre><code class="language-haskell">quickCheck \f g t -&gt;
  anywhere (\s -&gt; f s || g s) t ==
    anywhere f (treeOfInt t) || anywhere g t
</code></pre>
<p>ここで、 <code>treeOfInt</code>関数は木に含まれる値の型を型 <code>Int</code>に固定するために
使われています。</p>
<pre><code class="language-haskell">treeOfInt :: Tree Int -&gt; Tree Int
treeOfInt = id
</code></pre>
<h2 id="副作用のないテスト"><a class="header" href="#副作用のないテスト">副作用のないテスト</a></h2>
<p>テストの目的では通常、テストスイートの <code>main</code>アクションには
<code>quickCheck</code>関数の呼び出しが含まれています。しかし、副作用を使わない
<code>quickCheckPure</code>と呼ばれる <code>quickCheck</code>関数の亜種もあります。
<code>quickCheckPure</code>は、入力として乱数の種をとり、テスト結果の配列を返す純
粋な関数です。</p>
<p>PSCiを使用して <code>quickCheckPure</code>を試せます。ここでは <code>merge</code>操作が結合
法則を満たすことをテストします。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Merge
&gt; import Test.QuickCheck
&gt; import Test.QuickCheck.LCG (mkSeed)

&gt; :paste
… quickCheckPure (mkSeed 12345) 10 \xs ys zs -&gt;
…   ((xs `merge` ys) `merge` zs) ==
…     (xs `merge` (ys `merge` zs))
… ^D

Success : Success : ...
</code></pre>
<p><code>quickCheckPure</code>は乱数の種、生成するテストケースの数、テストする性質の
3つの引数をとります。もしすべてのテストケースに成功したら、
<code>Success</code>データ構築子の配列がコンソールに出力されます。</p>
<p><code>quickCheckPure</code>は、性能ベンチマークの入力データ生成や、ウェブアプリケー
ションのフォームデータ例を無作為に生成するというような状況で便利かもし
れません。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>
<p>（簡単） <code>Byte</code>と <code>Sorted</code>型構築子についての <code>Coarbitrary</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）任意の関数 <code>f</code>について、 <code>mergeWith f</code>関数の結合性を主張する（高階）性質を書いてください。
<code>quickCheckPure</code>を使ってPSCiでその性質をテストしてください。</p>
</li>
<li>
<p>（普通）次のデータ型の<code>Arbitrary</code>と<code>Coarbitrary</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">data OneTwoThree a = One a | Two a a | Three a a a
</code></pre>
<p><strong>ヒント</strong>：<code>Test.QuickCheck.Gen</code>で定義された <code>oneOf</code>関数を使って <code>Arbitrary</code>インスタンスを定義してください。</p>
</li>
<li>
<p>（普通）<code>all</code>を使って <code>quickCheckPure</code>関数の結果を単純化してください。
その新しい関数は型<code>List Result -&gt; Boolean</code>を持ち、全てのテストがとおえば<code>true</code>を、そうでなければ<code>false</code>を返します。</p>
</li>
<li>
<p>（普通）<code>quickCheckPure</code>の結果を単純にする別の手法として、
関数<code>squashResults :: List Result -&gt; Result</code>を書いてみてください。
<code>Data.Maybe.First</code>の<code>First</code>モノイドと共に<code>foldMap</code>関数を使うことで
失敗した場合の最初のエラーを保存することを検討してください。</p>
</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では<code>quickcheck</code>パッケージに出会いました。これを使えば<strong>生成的テ
スティング</strong>のパラダイムを使って宣言的な方法でテストを書くことができま
した。具体的には以下です。</p>
<ul>
<li><code>spago test</code>を使ってQuickCheckのテストを自動化する方法を見ました。</li>
<li>性質を関数として書く方法とエラーメッセージを改良する <code>&lt;?&gt;</code>演算子の使い方を説明しました。</li>
<li><code>Arbitrary</code>と <code>Coarbitrary</code>型クラスによって、どのように定型的なテスト
コードの自動生成を可能にし、またどのように高階性質関数が可能になるかを
見てきました。</li>
<li>独自のデータ型に対して <code>Arbitrary</code>と <code>Coarbitrary</code>インスタンスを実装す
る方法を見ました。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter12.ja.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter14.ja.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter12.ja.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter14.ja.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

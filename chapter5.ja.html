<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>パターン照合 - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">15.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">16.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">17.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">18.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html" class="active"><strong aria-hidden="true">19.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html"><strong aria-hidden="true">20.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">21.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">22.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">23.</strong> 非同期作用</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="パターン照合"><a class="header" href="#パターン照合">パターン照合</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章では、代数的データ型とパターン照合という、ふたつの新しい概念を導入します。
また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱います。</p>
<p><strong>パターン照合</strong> (pattern matching) は関数​​型プログラミングにおける一般的な手法で、
複数の場合に実装を分解することにより、開発者は潜在的に複雑な動作の関数を簡潔に書くことができます。</p>
<p>代数的データ型はPureScriptの型システムの機能であり、
型のある言語において同様の水準の表現力を可能にしています。
パターン照合とも密接に関連しています。</p>
<p>この章の目的は、代数的データ型やパターン照合を使用して、
単純なベクターグラフィックスを描画し操作するためのライブラリを書くことです。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>この章のソースコードはファイル <code>src/Data/Picture.purs</code>で定義されています。</p>
<p><code>Data.Picture</code>モジュールは、簡単な図形を表すデータ型 <code>Shape</code>や、図形の集合である型
<code>Picture</code>、及びこれらの型を扱うための関数を定義しています。</p>
<p>このモジュールでは、データ構造の畳込みを行う関数を提供する <code>Data.Foldable</code>モジュールもインポートします。</p>
<pre><code class="language-haskell">module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
</code></pre>
<p><code>Data.Picture</code>モジュールは<code>Number</code>モジュールもインポートしますが、こちらは<code>as</code>キーワードを使います。</p>
<pre><code class="language-haskell">import Data.Number as Number
</code></pre>
<p>これは型や関数をモジュール内で使用できるようにしますが、
それは<code>Number.max</code>のように<strong>修飾名</strong>を使ったときのみです。
これは重複したインポートを避けたり、
何らかのものがどのモジュールからインポートされたのかを明らかにするのに役立ちます。</p>
<p><strong>注意</strong>：元のモジュールと同じモジュール名を修飾名に使用するのは不要です。
<code>import Math as M</code>などのより短い名前にすることは可能ですし、かなりよくあります。</p>
<h2 id="単純なパターン照合"><a class="header" href="#単純なパターン照合">単純なパターン照合</a></h2>
<p>それではコード例を見ることから始めましょう。
パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになります。</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>このアルゴリズムはユークリッドの互除法と呼ばれています。
その定義をオンラインで検索すると、
おそらく上記のコードによく似た数学の方程式が見つかるでしょう。
パターン照合の利点のひとつは、
上記のようにコードを場合分けして定義することができ、
数学関数の定義と似たような簡潔で宣言型なコードを書くことができることです。</p>
<p>パターン照合を使用して書かれた関数は、
条件と結果の組み合わせによって動作します。
この定義の各行は<strong>選択肢</strong> (alternative) や<strong>場合</strong> (case) と呼ばれています。
等号の左辺の式は<strong>パターン</strong>と呼ばれており、
それぞれの場合は空白で区切られた1つ以上のパターンで構成されています。
場合の集まりは、等号の右側の式が評価され値が返される前に、
引数が満たさなければならないどれかの条件を表現しています。
それぞれの場合は上からこの順番に試されていき、
最初に入力に適合した場合が返り値を決定します。</p>
<p>たとえば、 <code>gcd</code>関数は次の手順で評価されます。</p>
<ul>
<li>まず最初の場合が試されます。第2引数がゼロの場合、関数は <code>n</code>（最初の引数）を返します。</li>
<li>そうでなければ、2番目の場合が試されます。
最初の引数がゼロの場合、関数は <code>m</code>（第2引数）を返します。</li>
<li>それ以外の場合、関数は最後の行の式を評価して返します。</li>
</ul>
<p>パターンは値を名前に束縛することができることに注意してください。
この例の各行では <code>n</code>という名前と <code>m</code>という名前の両方、
またはどちらか一方に、入力された値を束縛しています。
これよりさまざまな種類のパターンについて学びますが、
これらのパターンは入力の引数から名前を選ぶさまざまな方法に対応付けられることがわかるでしょう。</p>
<h2 id="単純なパターン"><a class="header" href="#単純なパターン">単純なパターン</a></h2>
<p>上記のコード例では、2種類のパターンを示しました。</p>
<ul>
<li><code>Int</code>型の値が正確に一致する場合にのみ適合する、整数リテラルパターン</li>
<li>引数を名前に束縛する、変数パターン</li>
</ul>
<p>単純なパターンには他にも種類があります。</p>
<ul>
<li><code>Number</code>、<code>String</code>、<code>Char</code>、そして<code>Boolean</code>といったリテラル</li>
<li>どんな引数とも適合するが名前に束縛はしない、
アンダースコア (<code>_</code>) で表されるワイルドカードパターン</li>
</ul>
<p>ここではこれらの単純なパターンを使用した、さらに2つの例を示します。</p>
<pre><code class="language-haskell">fromString :: String -&gt; Boolean
fromString &quot;true&quot; = true
fromString _      = false

toString :: Boolean -&gt; String
toString true  = &quot;true&quot;
toString false = &quot;false&quot;
</code></pre>
<p>PSCiでこれらの関数を試してみてください。</p>
<h2 id="ガード"><a class="header" href="#ガード">ガード</a></h2>
<p>ユークリッドの互除法の例では、
<code>m &gt; n</code>のときと <code>m &lt;= n</code>のときの２つに分岐するために <code>if .. then .. else</code>式を使っていました。
こういうときには他に<strong>ガード</strong> (guard) を使うという選択肢もあります。</p>
<p>ガードはパターンによる制約に加えて満たされなくてはいけない真偽値の式です。
ガードを使用してユークリッドの互除法を書き直すと、次のようになります。</p>
<pre><code class="language-haskell">gcdV2 :: Int -&gt; Int -&gt; Int
gcdV2 n 0 = n
gcdV2 0 n = n
gcdV2 n m | n &gt; m     = gcdV2 (n - m) m
          | otherwise = gcdV2 n (m - n)
</code></pre>
<p>この場合、3行目ではガードを使用して、最初の引数が第2引数よりも厳密に大きいという条件を付け加えています。
最後の行でのガードは式<code>otherwise</code>を使っており、キーワードのようにも見えますが、
実際にはただの<code>Prelude</code>における通常の束縛なのです。</p>
<pre><code class="language-text">&gt; :type otherwise
Boolean

&gt; otherwise
true
</code></pre>
<p>この例が示すように、ガードは等号の左側に現れ、パイプ文字 (<code>|</code>) でパターンのリストと区切られています。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>（簡単）パターン照合を使用して、階乗関数<code>factorial</code>を書いてみましょう。
<strong>ヒント</strong>:入力がゼロのときとゼロでないときの、ふたつのコーナーケースを考えてみてください。
<strong>補足</strong>：これは前の章からの例の繰り返しですが、ここでは自力で書き直せるかやってみてください。</li>
<li>（普通）\( (1 + x) ^ n \)を多項式展開した式にある
\( x ^ k \)の項の係数を求める関数<code>binomial</code>を書いてください。
これは<code>n</code>要素の集合から<code>k</code>要素の部分集合を選ぶ方法の数と同じです。
数式\( n! / k! (n - k)! \)を使ってください。
ここで \( ! \) は前に書いた階乗関数です。
<strong>ヒント</strong>：パターン照合を使ってコーナーケースを制御してください。
長い時間が掛かったりコールスタックのエラーでクラッシュしたりしたら、
もっとコーナーケースを追加してみてください。</li>
<li>（普通）<a href="https://en.wikipedia.org/wiki/Pascal%27s_rule"><strong>パスカルの法則</strong></a>を使って
前の演習の同じ2項係数を計算する関数<code>pascal</code>を書いてください。</li>
</ol>
<h2 id="配列パターン"><a class="header" href="#配列パターン">配列パターン</a></h2>
<p><strong>配列リテラルパターン</strong> (array literal patterns) は、固定長の配列に対して照合を行う方法を提供します。
たとえば、空の配列であることを特定する関数 <code>isEmpty</code>を書きたいとします。
最初の選択肢に空の配列パターン (<code>[]</code>) を用いるとこれを実現できます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty [] = true
isEmpty _ = false
</code></pre>
<p>次の関数では、長さ5の配列と適合し、配列の5つの要素をそれぞれ異なった方法で束縛しています。</p>
<pre><code class="language-haskell">takeFive :: Array Int -&gt; Int
takeFive [0, 1, a, b, _] = a * b
takeFive _ = 0
</code></pre>
<p>最初のパターンは、第1要素と第2要素がそれぞれ0と1であるような、5要素の配列にのみ適合します。
その場合、関数は第3要素と第4要素の積を返します。
それ以外の場合は、関数は0を返します。
PSCiで試してみると、たとえば次のようになります。</p>
<pre><code class="language-text">&gt; :paste
… takeFive [0, 1, a, b, _] = a * b
… takeFive _ = 0
… ^D

&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0
</code></pre>
<p>配列のリテラルパターンでは、固定長の配列と一致させることはできますが、
PureScriptは不特定の長さの配列を照合させる手段を提供していません。
そのような方法で不変な配列を分解すると、
実行速度が低下する可能性があるためです。
この種の照合を行うことができるデータ構造が必要な場合は、
<code>Data.List</code>を使うことをお勧めします。
そのほかの操作について、
より優れた漸近性能を提供するデータ構造も存在します。</p>
<h2 id="レコードパターンと行多相"><a class="header" href="#レコードパターンと行多相">レコードパターンと行多相</a></h2>
<p><strong>レコードパターン</strong> (Record patterns) は（ご想像のとおり）レコードに照合します。</p>
<p>レコードパターンはレコードリテラルに見た目が似ていますが、
レコードリテラルでラベルと式を<strong>コロン</strong>で区切るのとは異なり、
レコードパターンではラベルとパターンを<strong>等号</strong>で区切ります。</p>
<p>たとえば、次のパターンは <code>first</code>と <code>last</code>と呼ばれるフィールドが含まれた任意のレコードにマッチし、
これらのフィールドの値はそれぞれ <code>x</code>と <code>y</code>という名前に束縛されます。</p>
<pre><code class="language-haskell">showPerson :: { first :: String, last :: String } -&gt; String
showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x
</code></pre>
<p>レコードパターンはPureScriptの型システムの興味深い機能である
<strong>行多相</strong> (row polymorphism) の良い例となっています。
もし上の<code>showPerson</code>を型シグネチャなしで定義していたとすると、
この型はどのように推論されるのでしょうか？
面白いことに、推論される型は上で与えた型とは同じではありません。</p>
<pre><code class="language-text">&gt; showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x

&gt; :type showPerson
forall r. { first :: String, last :: String | r } -&gt; String
</code></pre>
<p>この型変数 <code>r</code>とは何でしょうか？
PSCiで <code>showPerson</code>を使ってみると、面白いことがわかります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;
</code></pre>
<p>レコードにそれ以外のフィールドが追加されていても、
<code>showPerson</code>関数はそのまま動作するのです。
型が <code>String</code>であるようなフィールド <code>first</code>と <code>last</code>がレコードに少なくとも含まれていれば、
関数適用は正しく型付けされます。
しかし、フィールドが<strong>不足</strong>していると、 <code>showPerson</code>の呼び出しは<strong>不正</strong>となります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot; }

Type of expression lacks required label &quot;last&quot;
</code></pre>
<p><code>showPerson</code>の新しい型シグネチャを読むとこうです。
「<code>String</code>な<code>first</code>と<code>last</code>フィールド<strong>と他のフィールドを何でも</strong>持つあらゆるレコードを取り、
<code>String</code>を返す。」
なお、この振舞いは元の<code>showPerson</code>のものとは異なります。
行変数<code>r</code>がなければ<code>showPerson</code>は<strong>厳密に</strong><code>first</code>と<code>last</code>フィールドしかないレコードのみを受け付けます。</p>
<p>次のように書くことができることにも注意してください。</p>
<pre><code class="language-haskell">&gt; showPerson p = p.last &lt;&gt; &quot;, &quot; &lt;&gt; p.first
</code></pre>
<p>この場合も、 PSCiは先ほどと同じ型を推論するでしょう。</p>
<h2 id="レコード同名利用"><a class="header" href="#レコード同名利用">レコード同名利用</a></h2>
<p><code>showPerson</code>関数は引数内のレコードと一致し、
<code>first</code>と<code>last</code>フィールドを<code>x</code>と <code>y</code>という名前の値に束縛していたのでした。
別の方法として、フィールド名自体を再利用するだけで、このようなパターン一致を次のように単純化できます。</p>
<pre><code class="language-haskell">showPersonV2 :: { first :: String, last :: String } -&gt; String
showPersonV2 { first, last } = last &lt;&gt; &quot;, &quot; &lt;&gt; first
</code></pre>
<p>ここでは、プロパティの名前のみを指定し、名前に導入したい値を指定する必要はありません。
これは<strong>レコード同名利用</strong> (record pun) と呼ばれます。</p>
<p>レコード同名利用をレコードの<strong>構築</strong>に使用することもできます。
例えば、スコープ内に <code>first</code>と <code>last</code>という名前の値があれば、
<code>{ first, last }</code>を使って人物レコードを作ることができます。</p>
<pre><code class="language-haskell">unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = &quot;Jane&quot;
    last  = &quot;Doe&quot;
</code></pre>
<p>これは、状況によってはコードの可読性を向上させるのに役立ちます。</p>
<h2 id="入れ子になったパターン"><a class="header" href="#入れ子になったパターン">入れ子になったパターン</a></h2>
<p>配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大きなパターンを構成しています。
これまでの例ではほとんどの場合で配列パターンとレコードパターンの内部に単純なパターンを使用していましたが、
パターンが自由に<strong>入れ子</strong>にすることができることも知っておくのが大切です。
入れ子になったパターンを使うと、
潜在的に複雑なデータ型に対しての条件分岐を用いて関数を定義できるようになります。</p>
<p>たとえば、このコードは2つのレコードパターンを結合します。</p>
<pre><code class="language-haskell">type Address = { street :: String, city :: String }

type Person = { name :: String, address :: Address }

livesInLA :: Person -&gt; Boolean
livesInLA { address: { city: &quot;Los Angeles&quot; } } = true
livesInLA _ = false
</code></pre>
<h2 id="名前付きパターン"><a class="header" href="#名前付きパターン">名前付きパターン</a></h2>
<p>入れ子のパターンを使う場合、パターンには<strong>名前を付け</strong>て追加で名前をスコープに持ち込むことができます。
任意のパターンに名前を付けるには、 <code>@</code>記号を使います。</p>
<p>たとえば、次の関数は2要素配列を整列するもので、2つの要素の名前を付けていますが、
配列自身にも名前を付けています。</p>
<pre><code class="language-haskell">sortPair :: Array Int -&gt; Array Int
sortPair arr@[x, y]
  | x &lt;= y = arr
  | otherwise = [y, x]
sortPair arr = arr
</code></pre>
<p>このようにすれば対が既に整列されているときに新しい配列を割り当てなくて済みます。
なおもし入力の配列が<strong>厳密に</strong>2つの要素を含んでいなければ、
たとえ整列されていなかったとしても、この関数は単に元のまま変えずに返しています。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（簡単）レコードパターンを使って、
2つの <code>Person</code>レコードが同じ都市にいるか探す関数 <code>sameCity</code>を定義してみましょう。</li>
<li>（普通）行多相を考慮すると、 <code>sameCity</code>関数の最も一般的な型は何でしょうか？
先ほど定義した <code>livesInLA</code>関数についてはどうでしょうか？
<strong>補足</strong>：この演習にテストはありません。</li>
<li>（普通）配列リテラルパターンを使って、
1要素の配列の唯一のメンバーを抽出する関数<code>fromSingleton</code>を書いてみましょう。
1要素だけを持つ配列でない場合、
関数は指定されたデフォルト値を返さなければなりません。
この関数は <code>forall a. a -&gt; Array a -&gt; a</code>という型を持っていなければなりません。</li>
</ol>
<h2 id="case式"><a class="header" href="#case式">Case式</a></h2>
<p>パターンは最上位にある関数宣言だけに現れるわけではありません。
<code>case</code>式を使って計算の途中の値に対してパターン照合を使うことができます。
case式には無名関数に似た種類の便利さがあります。
関数に名前を与えることがいつも望ましいわけではないように、
パターン照合を使いたいためだけに関数に名前をつけるようなことを避けられるようになります。</p>
<p>例を示しましょう。
次の関数は、配列の「最長ゼロ末尾」（和がゼロであるような、最も長い配列の末尾）を計算します。</p>
<pre><code class="language-haskell">import Data.Array (tail)
import Data.Foldable (sum)
import Data.Maybe (fromMaybe)

lzs :: Array Int -&gt; Array Int
lzs [] = []
lzs xs = case sum xs of
           0 -&gt; xs
           _ -&gt; lzs (fromMaybe [] $ tail xs)
</code></pre>
<p>以下は例です。</p>
<pre><code class="language-text">&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]
</code></pre>
<p>この関数は場合ごとの分析によって動作します。
もし配列が空なら、唯一の選択肢は空の配列を返すことです。
配列が空でない場合は、さらに2つの場合に分けるためにまず <code>case</code>式を使用します。
配列の合計がゼロであれば、配列全体を返します。
そうでなければ、配列の残りに対して再帰します。</p>
<h2 id="パターン照合の失敗と部分関数"><a class="header" href="#パターン照合の失敗と部分関数">パターン照合の失敗と部分関数</a></h2>
<p>case式のパターンを順番に照合していって、
もし選択肢のいずれの場合も入力が適合しなかった時は何が起こるのでしょうか？
この場合、<strong>パターン照合失敗</strong>によって、case式は実行時に失敗します。</p>
<p>簡単な例でこの動作を見てみましょう。</p>
<pre><code class="language-haskell">import Partial.Unsafe (unsafePartial)

partialFunction :: Boolean -&gt; Boolean
partialFunction = unsafePartial \true -&gt; true
</code></pre>
<p>この関数は単一の場合しか含んでおらず、その場合では単一の入力である<code>true</code>にのみ照合します。
このファイルをコンパイルして PSCiでそれ以外の値を与えてテストすると、実行時エラーが発生します。</p>
<pre><code class="language-text">&gt; partialFunction false

Failed pattern match
</code></pre>
<p>どんな入力の組み合わせに対しても値を返すような関数は<strong>全関数</strong> (total function) と呼ばれ、
そうでない関数は<strong>部分的</strong> (partial) であると呼ばれます。</p>
<p>一般的には、可能な限り全関数として定義したほうが良いと考えられています。
もし関数が何らかの妥当な入力の集合について結果を返さないことがわかっているなら、
大抵は失敗であることを示すことができる値を返すほうがよいでしょう。
例えば何らかの<code>a</code>についての型<code>Maybe a</code>で、妥当な結果を返せないときは<code>Nothing</code>を使います。
この方法なら、型安全な方法で値の有無を示すことができます。</p>
<p>PureScriptコンパイラは、
パターンマッチが不完全で関数が全関数ではないことを検出するとエラーを生成します。
部分関数が安全である場合、
<code>unsafePartial</code>関数を使ってこれらのエラーを抑制することができます。
（その部分関数が安全だと言い切れるなら！）
もし上記の <code>unsafePartial</code>関数の呼び出しを取り除くと、コンパイラは次のエラーを生成します。</p>
<pre><code class="language-text">A case expression could not be determined to cover all inputs.
The following additional cases are required to cover all inputs:

  false
</code></pre>
<p>これは値<code>false</code>が、定義されたどのパターンとも一致しないことを示しています。
一般的にこれらの警告には、複数の不一致のケースが含まれることがあります。</p>
<p>上記の型シグネチャも省略した場合は、次のようになります。</p>
<pre><code class="language-haskell">partialFunction true = true
</code></pre>
<p>このとき、PSCiは興味深い型を推論します｡</p>
<pre><code class="language-text">&gt; :type partialFunction

Partial =&gt; Boolean -&gt; Boolean
</code></pre>
<p>本書ではのちに<code>=&gt;</code>記号を含むいろいろな型を見ることになります。
（これらは<strong>型クラス</strong>に関連しています。）
しかし、今のところは、PureScriptは型システムを使って部分関数を追跡していることと、
安全な場合に型検証器に明示する必要があることを確認すれば十分です。</p>
<p>コンパイラは、定義されたパターンが<strong>冗長</strong>であることを検出した場合
（前の方に定義されたパターンに一致するケースのみ）でも警告を生成します。</p>
<pre><code class="language-haskell">redundantCase :: Boolean -&gt; Boolean
redundantCase true = true
redundantCase false = false
redundantCase false = false
</code></pre>
<p>このとき、最後のケースは冗長であると正しく検出されます。</p>
<pre><code class="language-text">A case expression contains unreachable cases:

  false
</code></pre>
<p><strong>注意</strong>：PSCiは警告を表示しないので、
この例を再現するには、この関数をファイルとして保存し、 <code>pulp build</code>を使ってコンパイルします。</p>
<h2 id="代数的データ型"><a class="header" href="#代数的データ型">代数的データ型</a></h2>
<p>この節では<strong>代数的データ型</strong> (algebraic data type, ADT) と呼ばれる、
PureScriptの型システムの機能を導入します。
この機能はパターン照合と地続きの関係があります。</p>
<p>しかしまずは切り口となる例について考えていきます。
この例では単純なベクターグラフィックスライブラリの実装というこの章の課題を解決する基礎を提供します。</p>
<p>直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとします。
オブジェクト指向言語では、おそらくインタフェースもしくは抽象クラス <code>Shape</code>を定義し、
使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。</p>
<p>しかしながら、この方針は大きな欠点をひとつ抱えています。
<code>Shape</code>を抽象的に扱うためには、実行したいと思う可能性のあるすべての操作を事前に把握し、
<code>Shape</code>インタフェースに定義する必要があるのです。
このため、モジュール性を壊さずに新しい操作を追加することが難しくなります。</p>
<p>もし図形の種類が事前にわかっているなら、
代数的データ型はこうした問題を解決する型安全な方法を提供します。
モジュール性のある方法で <code>Shape</code>に新たな操作を定義し、
型安全性が維持できます。</p>
<p>代数的データ型としてどのように<code>Shape</code>が表現されるかを次に示します。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String

type Point =
  { x :: Number
  , y :: Number
  }
</code></pre>
<p>この宣言では<code>Shape</code>をそれぞれの構築子の和として定義しており、
各構築子では含まれるデータを指定します。
<code>Shape</code>は、中央 <code>Point</code>と半径（数値）を持つ <code>Circle</code>か、
<code>Rectangle</code>、 <code>Line</code>、 <code>Text</code>のいずれかです。
他には <code>Shape</code>型の値を構築する方法はありません。</p>
<p>代数的データ型の定義はキーワード <code>data</code>から始まり、
それに新しい型の名前と任意個の型引数が続きます。
その型の構築子（あるいは<strong>データ構築子</strong> (data constructor)）は等号の後に定義され、
パイプ文字 (<code>|</code>) で区切られます。
ADTの構築子が持つデータは原始型に限りません。
構築子にはレコード、配列、また他のADTさえも含むことができます。</p>
<p>それではPureScriptの標準ライブラリから別の例を見てみましょう。
オプショナルな値を定義するのに使われる <code>Maybe</code>型を本書の冒頭で扱いました。
<code>maybe</code>パッケージでは <code>Maybe</code>を次のように定義しています。</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>この例では型引数 <code>a</code>の使用方法を示しています。
パイプ文字を「または」と読むことにすると、
この定義は「 <code>Maybe a</code>型の値は、無い (<code>Nothing</code>) か、
またはただの (<code>Just</code>) 型 <code>a</code>の値だ」とほぼ英語のように読むことができます。</p>
<p>なおデータ定義のどこにも構文<code>forall a</code>を使っていません。
<code>forall</code>構文は関数には必須ですが、<code>data</code>によるADTや<code>type</code>での型別称を定義するときは使われません。</p>
<p>データ構築子は再帰的なデータ構造を定義するために使用することもできます。
更に例を挙げると、要素が型 <code>a</code>の単方向連結リストのデータ型を定義はこのようになります。</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
</code></pre>
<p>この例は <code>lists</code>パッケージから持ってきました。
ここで <code>Nil</code>構築子は空のリストを表しており、
<code>Cons</code>は先頭となる要素と尾鰭から空でないリストを作成するために使われます。
<code>Cons</code>の2つ目のフィールドでデータ型 <code>List a</code>を使用しており、
再帰的なデータ型になっていることに注目してください。</p>
<h2 id="adtの使用"><a class="header" href="#adtの使用">ADTの使用</a></h2>
<p>代数的データ型の構築子を使用して値を構築するのはとても簡単です。
対応する構築子に含まれるデータに応じた引数を用意し、
その構築子を単に関数のように適用するだけです。</p>
<p>例えば、上で定義した <code>Line</code>構築子は2つの <code>Point</code>を必要としていますので、
<code>Line</code>構築子を使って <code>Shape</code>を構築するには、
型 <code>Point</code>のふたつの引数を与えなければなりません。</p>
<pre><code class="language-haskell">exampleLine :: Shape
exampleLine = Line p1 p2
  where
    p1 :: Point
    p1 = { x: 0.0, y: 0.0 }

    p2 :: Point
    p2 = { x: 100.0, y: 50.0 }
</code></pre>
<p>さて、代数的データ型で値を構築することは簡単ですが、
これをどうやって使ったらよいのでしょうか？
ここで代数的データ型とパターン照合との重要な接点が見えてきます。
代数的データ型の値を消費する唯一の方法は構築子に照合するパターンを使うことです。</p>
<p>例を見てみましょう。
<code>Shape</code>を <code>String</code>に変換したいとします。
<code>Shape</code>を構築するのにどの構築子が使用されたかを調べるには、
パターン照合を使用しなければなりません。
これには次のようにします。</p>
<pre><code class="language-haskell">showShape :: Shape -&gt; String
showShape (Circle c r) =
  &quot;Circle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, radius: &quot; &lt;&gt; show r &lt;&gt; &quot;]&quot;
showShape (Rectangle c w h) =
  &quot;Rectangle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, width: &quot; &lt;&gt; show w &lt;&gt; &quot;, height: &quot; &lt;&gt; show h &lt;&gt; &quot;]&quot;
showShape (Line start end) =
  &quot;Line [start: &quot; &lt;&gt; showPoint start &lt;&gt; &quot;, end: &quot; &lt;&gt; showPoint end &lt;&gt; &quot;]&quot;
showShape (Text loc text) =
  &quot;Text [location: &quot; &lt;&gt; showPoint loc &lt;&gt; &quot;, text: &quot; &lt;&gt; show text &lt;&gt; &quot;]&quot;

showPoint :: Point -&gt; String
showPoint { x, y } =
  &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot;, &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>各構築子はパターンとして使用することができ、
構築子への引数はそのパターンで束縛することができます。
<code>showShape</code>の最初の場合を考えてみましょう。
もし <code>Shape</code>が <code>Circle</code>構築子適合した場合、
2つの変数パターン <code>c</code>と <code>r</code>を使って
<code>Circle</code>の引数（中心と半径）がスコープに導入されます。
その他の場合も同様です。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>（簡単）<code>Circle</code>（型は<code>Shape</code>）を構築する関数<code>circleAtOrigin</code>を書いてください。
中心は原点にあり、半径は<code>10.0</code>です。</li>
<li>（普通）<code>Shape</code>を、原点を中心として<code>2.0</code>倍に拡大する関数<code>doubleScaleAndCenter</code>を書いてみましょう。</li>
<li>（普通） <code>Shape</code>からテキストを抽出する関数<code>shapeText</code>を書いてください。
この関数は <code>Maybe String</code>を返しますが、
もし入力が <code>Text</code>を使用して構築されたのでなければ、返り値には <code>Nothing</code>構築子を使ってください。</li>
</ol>
<h2 id="newtype"><a class="header" href="#newtype">Newtype</a></h2>
<p>代数的データ型の特別な場合として、<strong>newtype</strong>と呼ばれるものがあります。
newtypeはキーワード <code>data</code>の代わりにキーワード <code>newtype</code>を使用して導入します。</p>
<p>newtype宣言では<strong>過不足なくひとつだけの</strong>構築子を定義しなければならず、
その構築子は<strong>過不足なくひとつだけの</strong>引数を取る必要があります。
つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。
実際、newtypeの値は、元の型と同じ実行時表現を持ってるので、実行時性能のオーバーヘッドがありません。
しかし、これらは型システムの観点から区別されます。
これは型安全性の追加の層を提供するのです。</p>
<p>例として、ボルト、アンペア、オームのような単位を表現するために、
<code>Number</code>の型レベルの別名を定義したくなる場合があるかもしれません。</p>
<pre><code class="language-haskell">newtype Volt = Volt Number
newtype Ohm = Ohm Number
newtype Amp = Amp Number
</code></pre>
<p>それからこれらの型を使う関数と値を定義します。</p>
<pre><code class="language-haskell">calculateCurrent :: Volt -&gt; Ohm -&gt; Amp
calculateCurrent (Volt v) (Ohm r) = Amp (v / r)

battery :: Volt
battery = Volt 1.5

lightbulb :: Ohm
lightbulb = Ohm 500.0

current :: Amp
current = calculateCurrent battery lightbulb
</code></pre>
<p>これによりつまらないミスを防ぐことができます。
例えば電源<strong>なし</strong>に<strong>2つ</strong>の電球により生み出される電流を計算しようとするなどです。</p>
<pre><code class="language-haskell">current :: Amp
current = calculateCurrent lightbulb lightbulb
{-
TypesDoNotUnify:
  current = calculateCurrent lightbulb lightbulb
                             ^^^^^^^^^
  Could not match type
    Ohm
  with type
    Volt
-}
</code></pre>
<p>もし<code>newtype</code>なしに単に<code>Numebr</code>を使っていたら、コンパイラはこのミスを補足できません。</p>
<pre><code class="language-haskell">-- これもコンパイルできますが、型安全ではありません。
calculateCurrent :: Number -&gt; Number -&gt; Number
calculateCurrent v r = v / r

battery :: Number
battery = 1.5

lightbulb :: Number
lightbulb = 500.0

current :: Number
current = calculateCurrent lightbulb lightbulb -- 補足されないミス
</code></pre>
<p>なお、newtypeは単一の構築子しかとれず、構築子は単一の値でなくてはなりませんが、
newtypeは任意の数の型変数を取ることが<strong>できます</strong>。
例えば以下のnewtypeは妥当な定義です。
（<code>err</code>と<code>a</code>は型変数で、<code>CouldError</code>構築子は型<code>Either err a</code>の<strong>単一</strong>の値を期待します。）</p>
<pre><code class="language-Haskell">newtype CouldError err a = CouldError (Either err a)
</code></pre>
<p>また、newtypeの構築子はよくnewtype自身と同じ名前を持つことがあることにも注意してください。
ただこれは必須ではありません。
例えば固有の名前であっても妥当です。</p>
<pre><code class="language-haskell">newtype Coulomb = MakeCoulomb Number
</code></pre>
<p>この場合<code>Coulomb</code>は<strong>型構築子</strong>（引数はゼロ）で<code>MakeCoulomb</code>は<strong>データ構築子</strong>です。
これらの構築子は異なる名前空間に属しており、<code>Volt</code>の例でそうだったように、名前に一意性があります。
これは全てのADTについて言えることです。
なお、型構築子とデータ構築子は異なる名前を持つことができますが、
実際には同じ名前を共有するのが普通です。
上の<code>Amp</code>と<code>Volt</code>の場合がこれです。</p>
<p>newtypeの別の応用は、実行時表現を変えることなく、既存の型に異なる<strong>振舞い</strong>を付加することです。
その利用例については次章で<strong>型クラス</strong>をお話しするときに押さえます。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>（簡単）<code>Watt</code>を<code>Number</code>の<code>newtype</code>として定義してください。
それからこの新しい<code>Watt</code>型と上の<code>Amp</code>と<code>Volt</code>の定義を使って<code>calculateWattage</code>関数を定義してください。</li>
</ol>
<pre><code class="language-haskell">calculateWattage :: Amp -&gt; Volt -&gt; Watt
</code></pre>
<p><code>Watt</code>中のワット数は与えられた<code>Amp</code>中の電流と与えられた<code>Volt</code>の電圧の積で計算できます。</p>
<h2 id="ベクターグラフィックスライブラリ"><a class="header" href="#ベクターグラフィックスライブラリ">ベクターグラフィックスライブラリ</a></h2>
<p>これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライブラリを作成していきましょう。</p>
<p>ただの <code>Shape</code>の配列であるような、 <code>Picture</code>という型同義語を定義しておきます。</p>
<pre><code class="language-haskell">type Picture = Array Shape
</code></pre>
<p>デバッグしていると <code>Picture</code>を <code>String</code>として表示できるようにしたくなることもあるでしょう。
これはパターン照合を使用して定義された <code>showPicture</code>関数で行うことができます。</p>
<pre><code class="language-haskell">showPicture :: Picture -&gt; Array String
showPicture = map showShape
</code></pre>
<p>試してみましょう。
モジュールを <code>spago build</code>でコンパイルし、 <code>spago repl</code>でPSCiを開きます。</p>
<pre><code class="language-text">$ spago build
$ spago repl

&gt; import Data.Picture

&gt; showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]

[&quot;Line [start: (0.0, 0.0), end: (1.0, 1.0)]&quot;]
</code></pre>
<h2 id="外接矩形の算出"><a class="header" href="#外接矩形の算出">外接矩形の算出</a></h2>
<p>このモジュールのコード例には、 <code>Picture</code>の最小外接矩形を計算する関数 <code>bounds</code>が含まれています。</p>
<p><code>Bounds</code>型は外接矩形を定義します。</p>
<pre><code class="language-haskell">type Bounds =
  { top    :: Number
  , left   :: Number
  , bottom :: Number
  , right  :: Number
  }
</code></pre>
<p><code>Picture</code>内の <code>Shape</code>の配列を走査し、最小の外接矩形を累積するため、
<code>bounds</code>は <code>Data.Foldable</code>の <code>foldl</code>関数を使用しています。</p>
<pre><code class="language-haskell">bounds :: Picture -&gt; Bounds
bounds = foldl combine emptyBounds
  where
  combine :: Bounds -&gt; Shape -&gt; Bounds
  combine b shape = union (shapeBounds shape) b
</code></pre>
<p>基底の場合では、空の <code>Picture</code>の最小外接矩形を求める必要がありますが、
<code>emptyBounds</code>で定義される空の外接矩形がその条件を満たしています。</p>
<p>累積関数 <code>combine</code>は <code>where</code>ブロックで定義されています。
<code>combine</code>は <code>foldl</code>の再帰呼び出しで計算された外接矩形と、
配列内の次の <code>Shape</code>を引数にとり、
ユーザ定義の演算子 <code>union</code>を使ってふたつの外接矩形の和を計算しています。
<code>shapeBounds</code>関数は、パターン照合を使用して、単一の図形の外接矩形を計算します。</p>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>（普通） ベクターグラフィックライブラリを拡張し、
<code>Shape</code>の面積を計算する新しい操作 <code>area</code>を追加してください。
この演習では、テキストの面積は0であるものとしてください。</li>
<li>（難しい） <code>Shape</code>を拡張し、新しいデータ構築子 <code>Clipped</code>を追加してください。
<code>Clipped</code>は他の <code>Picture</code>を矩形に切り抜きます。
切り抜いてきた<code>Picture</code>の境界を計算できるよう、
<code>shapeBounds</code>関数を拡張してください。
なお、これにより<code>Shape</code>は再帰的なデータ型になります。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、関数型プログラミングから基本だが強力なテクニックであるパターン照合を扱いました。
複雑なデータ構造の部分と照合するために、
簡単なパターンの使い方だけではなく、
配列パターンやレコードパターンを使った深いデータ構造の一部の照合方法を見てきました。</p>
<p>またこの章では、パターン照合に密接に関連する代数的データ型を紹介しました。
代数的データ型のおかげでデータ構造を簡潔に記述することができ、
新たな操作でデータ型を拡張するためのモジュール性のある方法が提供されることを見てきました。</p>
<p>最後に強力な抽象化である<strong>行多相</strong>を扱いました。
これにより多くの既存のJavaScript関数に型を与えられます。</p>
<p>本書では今後も代数的データ型とパターン照合をいろんなところで使用するので、
今のうちにこれらに習熟しておくと後で実を結ぶことでしょう。
これ以外にも独自の代数的データ型を作成し、
パターン照合を使用してそれらを使う関数を書くことを試してみてください。</p>
<hr />
<small>
<p>この翻訳は<a href="https://github.com/aratama">aratama</a>氏による翻訳を元に改変を加えています。
同氏の翻訳リポジトリは<a href="https://github.com/aratama/purescript-book-ja"><code>aratama/purescript-book-ja</code></a>に、Webサイトは<a href="http://aratama.github.io/purescript/">実例によるPureScript</a>にあります。</p>
<p><a href="https://book.purescript.org/">原文の使用許諾</a>：</p>
<blockquote>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation Repo</a>, which uses the same license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various contributors</a>.</p>
<p>The exercises are licensed under the MIT license.</p>
</blockquote>
<p><a href="http://aratama.github.io/purescript/">aratama氏訳の使用許諾</a>：</p>
<blockquote>
<p>This book is licensed under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</p>
<p>本書は<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">クリエイティブコモンズ 表示 - 非営利 - 継承 3.0 非移植ライセンス</a>でライセンスされています。</p>
</blockquote>
<p>本翻訳の使用許諾：</p>
<p>本翻訳も原文と原翻訳にしたがい、
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>の下に提供されています。</p>
</small>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter4.ja.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter6.ja.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter4.ja.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter6.ja.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>

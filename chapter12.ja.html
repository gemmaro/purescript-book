<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Canvasグラフィックス - PureScript by Example</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.ja.html"><strong aria-hidden="true">15.</strong> 序文 (Foreword)</a></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">16.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">17.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">18.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">19.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html"><strong aria-hidden="true">20.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html"><strong aria-hidden="true">21.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">22.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">23.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">24.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.ja.html"><strong aria-hidden="true">25.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.ja.html"><strong aria-hidden="true">26.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.ja.html" class="active"><strong aria-hidden="true">27.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.ja.html"><strong aria-hidden="true">28.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.ja.html"><strong aria-hidden="true">29.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="canvasグラフィックス"><a class="header" href="#canvasグラフィックス">Canvasグラフィックス</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章は<code>canvas</code>パッケージに焦点を当てる発展的な例となります。このパッ
ケージはPureScriptでHTML5のCanvas APIを使用して2Dグラフィックスを生成
する手段を提供します。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。</p>
<ul>
<li><code>canvas</code>はHTML5のCanvas APIのメソッドの型を与えます。</li>
<li><code>refs</code>は <em>大域的な変更可能領域への参照</em> を使うための副作用を提供します。</li>
</ul>
<p>この章のソースコードは、それぞれに <code>main</code>メソッドが定義されているモジュー
ルの集合へと分割されています。この章のそれぞれの節の内容はそれぞれの異
なるファイルで実装されており、それぞれの時点での適切なファイルの
<code>main</code>メソッドを実行できるように、Spagoビルドコマンドを変更することで
<code>Main</code>モジュールが変更できるようになっています。</p>
<p>HTMLファイル <code>html/index.html</code>には、各例で使用される単一の <code>canvas</code>要
素、およびコンパイルされたPureScriptコードを読み込む <code>script</code>要素が含
まれています。ほとんどの演習はブラウザを対象にしているので、この章には
単体試験はありません。</p>
<h2 id="単純な図形"><a class="header" href="#単純な図形">単純な図形</a></h2>
<p><code>Example/Rectangle.purs</code>ファイルには簡単な導入例が含まれています。この
例ではcanvasの中心に青い四角形をひとつ描画します。このモジュールは、
<code>Effect</code>モジュールからの<code>Effect</code>型と、Canvas APIを扱うための<code>Effect</code>モ
ナドのアクションを含む<code>Graphics.Canvas</code>モジュールをインポートします。</p>
<p>他のモジュールでも同様ですが、 <code>main</code>アクションは最初に
<code>getCanvasElementById</code>アクションを使ってcanvasオブジェクトへの参照を取
得しています。また、 <code>getContext2D</code>アクションを使ってキャンバスの2D描
画コンテキストを参照しています。</p>
<p><code>void</code>関数は関手を取り値を<code>Unit</code>で置き換えます。例では<code>main</code>がシグネチャ
に沿うようにするために使われています。</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><em>注意</em>
：この<code>unsafePartial</code>の呼び出しは必須です。これは<code>getCanvasElementById</code>の結果のパターン照合部分的で、<code>Just</code>値構築子だけと照合するためです。ここではこれで問題ありませんが、実際の製品のコードではおそらく<code>Nothing</code>値構築子と照合させ、適切なエラーメッセージを提供したほうがよいでしょう。</p>
<p>これらのアクションの型は、PSCiを使うかドキュメントを見ると確認できます。</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code>と <code>Context2D</code>は <code>Graphics.Canvas</code>モジュールで定義され
ている型です。このモジュールでは<code>Canvas</code>作用も定義されており、モジュー
ル内のすべてのアクションで使用されています。</p>
<p>グラフィックスコンテキスト <code>ctx</code>は、canvasの状態を管理し、原始的な図形
を描画したり、スタイルや色を設定したり、座標変換を適用するためのメソッ
ドを提供しています。</p>
<p>話を進めると、<code>setFillStyle</code>アクションを使うことで塗り潰しスタイルを濃
い青に設定できます。より長い16進数記法の<code>#0000FF</code>も青には使えますが、
略記法が単純な色についてはより簡単です。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p><code>setFillStyle</code>アクションがグラフィックスコンテキストを引数として取って
いることに注意してください。これは <code>Graphics.Canvas</code>ではよくあるパター
ンです。</p>
<p>最後に、 <code>fillPath</code>アクションを使用して矩形を塗りつぶしています。
<code>fillPath</code>は次のような型を持っています。</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code>はグラフィックスコンテキストと描画するパスを構築する別のアク
ションを引数にとります。パスは <code>rect</code>アクションを使うと構築することが
できます。 <code>rect</code>はグラフィックスコンテキストと矩形の位置及びサイズを
格納するレコードを引数にとります。</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>mainモジュールの名前として<code>Example.Rectangle</code>を与えてこの長方形のコー
ド例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>それでは <code>html/index.html</code>ファイルを開き、このコードによってcanvasの中
央に青い四角形が描画されていることを確認してみましょう。</p>
<h2 id="行多相を利用する"><a class="header" href="#行多相を利用する">行多相を利用する</a></h2>
<p>パスを描画する方法は他にもあります。 <code>arc</code>関数は円弧を描画します。
<code>moveTo</code>関数、 <code>lineTo</code>関数、 <code>closePath</code>関数は断片的な線分のパスを描
画するのに使えます。</p>
<p><code>Shapes.purs</code>ファイルでは長方形と円弧と三角形の、3つの図形を描画してい
ます。</p>
<p><code>rect</code>関数は引数としてレコードをとることを見てきました。実際には、長方
形のプロパティは型同義語で定義されています。</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p><code>x</code>と <code>y</code>プロパティは左上隅の位置を表しており、 <code>w</code>と <code>h</code>のプロパティ
はそれぞれ幅と高さを表しています。</p>
<p><code>arc</code>関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画
することができます。</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>ここで、 <code>x</code>と <code>y</code>プロパティは弧の中心、 <code>r</code>は半径、 <code>start</code>と <code>end</code>は
弧の両端の角度を弧度法で表しています。</p>
<p>例えばこのコードは中心が<code>(300, 300)</code>に中心があり半径<code>50</code>の円弧を塗り潰
します。弧は1回転のうち2/3 rds分あります。単位円が鉛直方向に反転するこ
とに注意してください。これはy軸がcanvasの下向きに増加するためです。</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p><code>Number</code>型の <code>x</code>と <code>y</code>というプロパティが <code>Rectangle</code>レコード型と
<code>Arc</code>レコード型の両方に含まれていることに注意してください。どちらの場
合でもこの組は点を表しています。これは、いずれのレコード型にも適用でき
る、行多相な関数を書くことができることを意味します。</p>
<p>たとえば、 <code>Shapes</code>モジュールでは <code>x</code>と <code>y</code>のプロパティを変更し図形を
並行移動する <code>translate</code>関数を定義されています。</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>この行多相型に注目してください。これは <code>triangle</code>が <code>x</code>と <code>y</code>というプロパティと、 <em>それに加えて他の任意のプロパティ</em>
を持ったどんなレコードでも受け入れ、同じ型のレコードを返すということを言っています。 <code>x</code>フィールドと
<code>y</code>フィールドは更新されますが、残りのフィールドは変更されません。</p>
<p>これは <em>レコード更新構文</em> の例です。 <code>shape { ... }</code>という式は、<code>shape</code>を元にして、括弧の中で指定された値で更新されたフィールドを持つ新たなレコードを作ります。波括弧の中の式はレコードリテラルのようなコロンではなく、等号でラベルと式を区切って書くことに注意してください。</p>
<p><code>Shapes</code>の例からわかるように、 <code>translate</code>関数は <code>Rectangle</code>レコードと
<code>Arc</code>レコード双方に対して使うことができます。</p>
<p><code>Shape</code>の例で描画される3つめの型は区分からなる線分のパスです。対応する
コードは次のようになります。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>ここでは3つの関数が使われています。</p>
<ul>
<li><code>moveTo</code>はパスの現在地を指定された座標に移動します。</li>
<li><code>lineTo</code>は現在地と指定された座標の間の線分を描画し、現在地を更新します。</li>
<li><code>closePath</code>は現在地と開始地点とを結ぶ線分を描画してパスを完結します。</li>
</ul>
<p>このコード片の結果は二等辺三角形の塗り潰しです。</p>
<p>mainモジュールとして<code>Example.Shapes</code>を指定して、この例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>そしてもう一度 <code>html/index.html</code>を開き、結果を確認してください。canvas
に3つの異なる図形が描画されるはずです。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>
<p>（簡単）これまでの例のそれぞれについて、 <code>strokePath</code>関数や
<code>setStrokeStyle</code>関数を使ってみましょう。</p>
</li>
<li>
<p>（簡単）関数の引数の内部のdo記法ブロックにより、<code>fillPath</code>関数と
<code>strokePath</code>関数を使って共通のスタイルを持つ複雑なパスを描画することが
できます。同じ <code>fillPath</code>呼び出しで隣り合った2つの矩形を描画するように、
<code>Rectangle</code>のコード例を変更してみてください。線分と円弧を組み合わせて
を、円の扇形を描画してみてください。</p>
</li>
<li>
<p>（普通）次のような2次元の点を表すレコードが与えられたとします。</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>これは2次元の点を表現しています。
多数の点からなる閉じたパスを線描きする関数 <code>renderPath</code>を書いてください。</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>次のような関数を考えます。</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>この関数は引数として <code>1</code>から <code>0</code>の間の <code>Number</code>をとり、 <code>Point</code>を
返します。 <code>renderPath</code>関数を利用して関数 <code>f</code>のグラフを描くアクショ
ンを書いてください。そのアクションは有限個の点を <code>f</code>からサンプリン
グすることによって近似しなければなりません。</p>
<p>関数 <code>f</code>を変更し、様々なパスが描画されることを確かめてください。</p>
</li>
</ol>
<h2 id="無作為に円を描く"><a class="header" href="#無作為に円を描く">無作為に円を描く</a></h2>
<p><code>Example/Random.purs</code>ファイルには2種類の異なる副作用が混在した
<code>Effect</code>モナドを使う例が含まれています。1つは乱数生成で、もう1つは
canvasの操作です。この例では無作為に生成された円をキャンバスに100個描
画します。</p>
<p><code>main</code>アクションはこれまでのようにグラフィックスコンテキストへの参照を
取得し、ストロークと塗りつぶしスタイルを設定します。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>次のコードでは <code>for_</code>アクションを使って <code>0</code>から <code>100</code>までの整数につい
て繰り返しをしています。</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>それぞれの繰り返しではdo記法ブロックは<code>0</code>と<code>1</code>の間に分布する3つの乱数
を生成することから始まります。これらの数は <code>0</code>から <code>1</code>の間に無作為に分
布しており、それぞれ <code>x</code>座標、 <code>y</code>座標、半径 <code>r</code>を表しています。</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>次のコードではそれぞれの円について、これらの変数に基づいて <code>Arc</code>を作成
し、最後に現在のスタイルに従って円弧の塗りつぶしと線描が行われます。</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x                  : x * 600.0
         , y                  : y * 600.0
         , radius             : r * 50.0
         , start              : 0.0
         , end                : Number.tau
         , useCounterClockwise: false
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>mainモジュールとして<code>Example.Random</code>を指定して、この例をビルドしましょ
う。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いて、結果を確認してみましょう。</p>
<h2 id="座標変換"><a class="header" href="#座標変換">座標変換</a></h2>
<p>キャンバスは簡単な図形を描画するだけのものではありません。キャンバスは
変換行列を扱うことができ、図形は描画の前に形状を変形してから描画されま
す。図形は平行移動、回転、拡大縮小、および斜めに変形することができます。</p>
<p><code>canvas</code>ライブラリではこれらの変換を以下の関数で提供しています。</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p><code>translate</code>アクションは <code>TranslateTransform</code>レコードのプロパティで指定
した大きさだけ平行移動を行います。</p>
<p><code>rotate</code>アクションは最初の引数で指定されたラジアンの値に応じて原点を中
心とした回転を行います。</p>
<p><code>scale</code>アクションは原点を中心として拡大縮小します。 <code>ScaleTransform</code>レ
コードは <code>X</code>軸と <code>y</code>軸に沿った拡大率を指定するのに使います。</p>
<p>最後の <code>transform</code>はこの4つのうちで最も一般的なアクションです。このアクションは行列に従ってアフィン変換を行います。</p>
<p>これらのアクションが呼び出された後に描画される図形は、自動的に適切な座
標変換が適用されます。</p>
<p>実際には、これらの関数のそれぞれの作用は、コンテキストの現在の変換行列に対して変換行列を <em>右から乗算</em>
していきます。つまり、もしある作用の変換をしていくと、その作用は実際には逆順に適用されていきます：</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>この一連のアクションの作用では、まずシーンが回転され、それから拡大縮小
され、最後に平行移動されます。</p>
<h2 id="コンテキストの保存"><a class="header" href="#コンテキストの保存">コンテキストの保存</a></h2>
<p>変換を適用してシーンの一部を描画し、それからその変換を元に戻す、という
使い方はよくあります。</p>
<p>Canvas APIにはキャンバスの状態の <em>スタック</em> を操作する <code>save</code>と<code>restore</code>メソッドが備わっています。
<code>canvas</code>ではこの機能を次のような関数でラップしています。</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p><code>save</code>アクションは現在のコンテキストの状態（現在の変換行列や描画スタイ
ル）をスタックにプッシュし、 <code>restore</code>アクションはスタックの一番上の状
態をポップし、コンテキストの状態を復元します。</p>
<p>これらのアクションにより、現在の状態を保存し、いろいろなスタイルや変換
を適用し、原始的な図形を描画し、最後に元の変換と状態を復元することが可
能になります。例えば、次の関数はいくつかのキャンバスアクションを実行し
ますが、その前に回転を適用し、そのあとに変換を復元します。</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>こういったよくある使いかたの高階関数を利用した抽象化として、
<code>canvas</code>ライブラリでは元のコンテキスト状態を保存しつついくつかのキャン
バスアクションを実行する <code>withContext</code>関数が提供されています。</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p><code>withContext</code>を使うと、先ほどの <code>rotated</code>関数を次のように書き換えるこ
とができます。</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="大域的な変更可能状態"><a class="header" href="#大域的な変更可能状態">大域的な変更可能状態</a></h2>
<p>この節では <code>refs</code>パッケージを使って <code>Effect</code>モナドの別の作用について実
演してみます。</p>
<p><code>Effect.Ref</code>モジュールでは大域的に変更可能な参照のための型構築子、およ
び関連する作用を提供します。</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>型<code>Ref a</code>の値は型<code>a</code>の値を含む可変参照セルであり、大域的な変更を追跡す
るのに使われます。そういったわけでこれは少しだけ使う分に留めておくべき
です。</p>
<p><code>Example/Refs.purs</code>ファイルには <code>canvas</code>要素上のマウスクリックを追跡す
るのに <code>Ref</code>作用を使用する例が含まれています。</p>
<p>このコー​​ドでは最初に <code>new</code>アクションを使って値 <code>0</code>を含む新しい参照を作
成しています。</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>クリックイベントハンドラの内部では、 <code>modify</code>アクションを使用してクリッ
ク数を更新し、更新された値が返されています。</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p><code>render</code>関数では、クリック数に応じて変換を矩形に適用しています。</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Number.sin (toNumber count * Number.tau / 8.0) + 1.5
    let scaleY = Number.sin (toNumber count * Number.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Number.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>このアクションでは元の変換を保存するために <code>withContext</code>を使用しており、
それから一連の変換を適用しています（変換が下から上に適用されることを思
い出してください）。</p>
<ul>
<li>矩形は<code>(-100, -100)</code>だけ平行移動し中心が原点に来ます。</li>
<li>矩形が原点を中心に拡大されます。</li>
<li>矩形が原点を中心に<code>10</code>の倍数分の角度で回転します。</li>
<li>矩形が<code>(300, 300)</code>だけ平行移動し中心がcanvasの中心に来ます。</li>
</ul>
<p>このコード例をビルドしてみましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>ファイルを開いてみましょう。何度かキャンバスをクリッ
クすると、キャンバスの中心の周りを回転する緑の四角形が表示されるはずで
す。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（簡単）パスの線描と塗り潰しを同時に行う高階関数を書いてください。その
関数を使用して <code>Random.purs</code>例を書き直してください。</li>
<li>（普通）<code>Random</code>作用と <code>Dom</code>作用を使用して、マウスがクリックされたとき
に、キャンバスに無作為な位置、色、半径の円を描画するアプリケーションを
作成してください。</li>
<li>（普通）シーンを指定された座標を中心に回転する関数を書いてください。 <em>ヒント</em> ：最初にシーンを原点まで平行移動しましょう。</li>
</ol>
<h2 id="l-system"><a class="header" href="#l-system">L-System</a></h2>
<p>この章の最後の例として、 <code>canvas</code>パッケージを使用して<em>L-system</em>（またの名を<em>Lindenmayer
system</em>）を描画する関数を記述します。</p>
<p>L-Systemは<em>アルファベット</em>、つまり初期状態となるアルファベットの文字列と、 <em>生成規則</em>
の集合で定義されています。各生成規則は、アルファベットの文字をとり、それを置き換える文字の配列を返します。この処理は文字の初期配列から始まり、複数回繰り返されます。</p>
<p>もしアルファベットの各文字がcanvas上で実行される命令と対応付けられてい
れば、その指示に順番に従うことでL-Systemを描画することができます。</p>
<p>たとえば、アルファベットが文字 <code>L</code>（左回転）、 <code>R</code>（右回転）、 <code>F</code>（前
進）で構成されていたとします。また、次のような生成規則を定義します。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>配列 &quot;FRRFRRFRR&quot; から始めて処理を繰り返すと、次のような経過を辿ります。</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>この命令群に対応する線分パスをプロットすると、 <em>コッホ曲線</em> と呼ばれる曲線に近似します。反復回数を増やすと、曲線の解像度が増加していきます。</p>
<p>それでは型と関数の言語へとこれを翻訳してみましょう。</p>
<p>アルファベットの文字は以下のADTで表現できます。</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>このデータ型では、アルファベットの文字ごとに1つずつデータ構築子が定義されています。</p>
<p>文字の初期配列はどのように表したらいいでしょうか。単なるアルファベット
の配列でいいでしょう。これを <code>Sentence</code>と呼ぶことにします。</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>生成規則は以下のように<code>Letter</code>から <code>Sentence</code>への関数として表すことができます。</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>これはまさに上記の仕様をそのまま書き写したものです。</p>
<p>これで、この形式の仕様を受け取りcanvasに描画する関数 <code>lsystem</code>を実装す
ることができます。 <code>lsystem</code>はどのような型を持っているべきでしょうか。
この関数は初期状態 <code>initial</code>と生成規則 <code>productions</code>のような値だけでな
く、アルファベットの文字をcanvasに描画する関数を引数に取る必要があ
ります。</p>
<p><code>lsystem</code>の型の最初の大まかな設計は以下です。</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>最初の2つの引数の型は、値 <code>initial</code>と <code>productions</code>に対応しています。</p>
<p>3番目の引数は、アルファベットの文字を取り、canvas上のいくつかのアクションを実行することによって <em>解釈</em>
する関数を表します。この例では、文字<code>L</code>は左回転、文字 <code>R</code>で右回転、文字 <code>F</code>は前進を意味します。</p>
<p>最後の引数は、実行したい生成規則の繰り返し回数を表す数です。</p>
<p>最初に気付くことは、この<code>lsystem</code>関数は1つの型<code>Letter</code>に対してのみ動作
するのですが、どんなアルファベットについても機能すべきですから、この型
はもっと一般化されるべきです。それでは、量子化された型変数 <code>a</code>について、
<code>Letter</code>と <code>Sentence</code>を <code>a</code>と <code>Array a</code>で置き換えましょう。</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>次に気付くこととしては、「左回転」と「右回転」のような命令を実装するた
めには、いくつかの状態を管理する必要があります。具体的に言えば、その時
点でパスが向いている方向を状態として持たなければなりません。計算を通じ
て状態を関数に渡すように変更する必要があります。ここでも <code>lsystem</code>関数
は状態がどんな型でも動作したほうがよいので、型変数 <code>s</code>を使用してそれを
表しています。</p>
<p>型 <code>s</code>を追加する必要があるのは3箇所で、次のようになります。</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>まず追加の引数の型として <code>lsystem</code>に型 <code>s</code>が追加されています。この引数
はL-Systemの初期状態を表しています。</p>
<p>型
<code>s</code>は引数にも現れますが、解釈関数（<code>lsystem</code>の第3引数）の返り値の型としても現れます。解釈関数は今のところ、引数としてL-Systemの現在の状態を受け取り、返り値として更新された新しい状態を返します。</p>
<p>この例の場合では、次のような型を使って状態を表す型を定義することができ
ます。</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>プロパティ <code>x</code>と <code>y</code>はパスの現在の位置を表しており、プロパティ
<code>theta</code>はパスの現在の向きを表しています。これはラジアンで表された水平
線に対するパスの角度として指定されています。</p>
<p>システムの初期状態としては次のように指定されます。</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>それでは、 <code>lsystem</code>関数を実装してみます。定義はとても単純であることが
わかるでしょう。</p>
<p><code>lsystem</code>は第4引数の値（型<code>Int</code>）に応じて再帰するのが良さそうです。再帰の各ステップでは、生成規則に従って状態が更新され、現在の文が変化していきます。このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を移譲することから始めましょう。</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p><code>go</code>関数は第2引数に応じて再帰することで動きます。場合分けは2つであり、
<code>n</code>がゼロであるときと <code>n</code>がゼロでないときです。</p>
<p>1つ目の場合は再帰は完了し、解釈関数に応じて現在の文を解釈します。型<code>Array a</code>の文、型 <code>s</code>の状態、型 <code>s -&gt; a -&gt; Effect s</code>の関数があります。以前定義した <code>foldM</code>でやったことのように聞こえます。この関数は<code>control</code>パッケージで手に入ります。</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>ゼロでない場合ではどうでしょうか。その場合は、単に生成規則を現在の文の
それぞれの文字に適用して、その結果を連結し、そして再帰的に<code>go</code>を呼び出
すことによって繰り返します。</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>これだけです！<code>foldM</code>や <code>concatMap</code>のような高階関数を使うと、このよう
にアイデアを簡潔に表現することができるのです。</p>
<p>しかし、話はこれで終わりではありません。ここで与えた型は、実際はまだ特殊化されすぎています。この定義ではcanvasの操作が実装のどこにも使われていないことに注目してください。それに、まったく
<code>Effecta</code>モナドの構造を利用していません。実際には、この関数は <em>どんな</em> モナド <code>m</code>についても動作するのです！</p>
<p>この章に添付されたソースコードで指定されている、 <code>lsystem</code>のもっと一般
的な型は次のようになっています。</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>この型が言っているのは、この解釈関数はモナド
<code>m</code>が持つ任意の副作用をまったく自由に持つことができる、ということだと理解することができます。キャンバスに描画したり、またはコンソールに情報を出力するかもしれませんし、失敗や複数の戻り値に対応しているかもしれません。こういった様々な型の副作用を使ったL-Systemを記述してみることを読者にお勧めします。</p>
<p>この関数は実装からデータを分離することの威力を示す良い例となっています。この手法の利点は、複数の異なる方法でデータを解釈する自由が得られることです。
<code>lsystem</code>は2つの小さな関数へと分解することさえできるかもしれません。1つ目は
<code>concatMap</code>の適用の繰り返しを使って文を構築するもので、2つ目は
<code>foldM</code>を使って文を解釈するものです。これは読者の演習として残しておきます。</p>
<p>それでは解釈関数を実装して、この章の例を完成させましょう​​。 <code>lsystem</code>の型は型シグネチャが言っているのは、解釈関数の型は、何らかの型 <code>a</code>と <code>s</code>、型構築子 <code>m</code>について、 <code>s -&gt; a -&gt; m s</code>でなければならないということです。<code>a</code>を <code>Letter</code>、 <code>s</code>を <code>State</code>、モナド <code>m</code>を <code>Effect</code>というように選びたいということがわかっています。これにより次のような型になります。</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>この関数を実装するには、 <code>Letter</code>型の3つのデータ構築子それぞれについて処理する必要があります。文字 <code>L</code>（左回転）と
<code>R</code>（右回転）の解釈では、<code>theta</code>を適切な角度へ変更するように状態を更新するだけです。</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Number.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Number.tau / 6.0 }
</code></pre>
<p>文字 <code>F</code>（前進）を解釈するには、パスの新しい位置を計算し、線分を描画し、状態を次のように更新します。</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Number.cos state.theta * 1.5
          y = state.y + Number.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>この章のソースコードでは、名前 <code>ctx</code>がスコープ内に来るように、
<code>interpret</code>関数は <code>main</code>関数内で <code>let</code>束縛を使用して定義されていること
に注意してください。 <code>State</code>型がコンテキストを持つように変更することは
可能でしょうが、それはこのシステムの状態の変化部分ではないので不適切で
しょう。</p>
<p>このL-Systemを描画するには、次のような <code>strokePath</code>アクションを使用するだけです。</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>次のコマンドを使ってL-Systemをコンパイルします。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いてみましょう。キャンバスにコッホ曲線が描画され
るのがわかると思います。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>strokePath</code>の代わりに <code>fillPath</code>を使用するように、上のL-Systemの例を変更してください。 <em>ヒント</em>
：<code>closePath</code>の呼び出しを含め、 <code>moveTo</code>の呼び出しを <code>interpret</code>関数の外側に移動する必要があります。</p>
</li>
<li>
<p>（簡単）描画システムへの影響を理解するために、コード中の様々な数値の定
数を変更してみてください。</p>
</li>
<li>
<p>（普通）<code>lsystem</code>関数を2つの小さな関数に分割してください。1つ目は
<code>concatMap</code>の適用の繰り返しを使用して最終的な文を構築するもので、2つ目
は <code>foldM</code>を使用して結果を解釈するものでなくてはなりません。</p>
</li>
<li>
<p>（普通）<code>setShadowOffsetX</code>アクション、
<code>setShadowOffsetY</code>アクション、<code>setShadowBlur</code>アクション、
<code>setShadowColor</code>アクションを使い、塗りつぶされた図形にドロップシャドウを追加してください。 <em>ヒント</em>
：PSCiを使って、これらの関数の型を調べてみましょう。</p>
</li>
<li>
<p>（普通）向きを変えるときの角度の大きさは今のところ一定 (<code>tau/6</code>) です。
その代わりに、<code>Letter</code>データ型の中に角度を移動させることで、生成規則に
よって変更するようにしてください。</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>生成規則でこの新しい情報を使うと、どんな面白い図形を作ることがで
きるでしょうか。</p>
</li>
<li>
<p>（難しい）<code>L</code>（60度左回転）、 <code>R</code>（60度右回転）、
<code>F</code>（前進）、 <code>M</code>（これも前進）という4つの文字からなるアルファベット
でL-Systemが与えられたとします。</p>
<p>このシステムの文の初期状態は、単一の文字 <code>M</code>です。</p>
<p>このシステムの生成規則は次のように指定されています。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>このL-Systemを描画してください。 <em>注意</em> ：最後の文のサイズは反復回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を削減することが必要になります。</p>
<p>ここで、生成規則における <code>L</code>と <code>M</code>の間の対称性に注目してください。
ふたつの「前進」命令は、次のようなアルファベット型を使用すると、
<code>Boolean</code>値を使って区別することができます。</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>このアルファベットの表現を使用して、もう一度このL-Systemを実装して
ください。</p>
</li>
<li>
<p>（難しい）解釈関数で別のモナド <code>m</code>を使ってみましょう。<code>Effect.Console</code>作用を利用してコンソール上にL-Systemを出力したり、<code>Random</code>作用を利用して状態の型に無作為の「突然変異」を適用したりしてみてください。</p>
</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、 <code>canvas</code>ライブラリを使用することにより、PureScriptから
HTML5 Canvas APIを使う方法について学びました。また、これまで学んできた
手法の多くを利用した実用的な例について見ました。マップや畳み込み、レコー
ドと行多相、副作用を扱うための <code>Effect</code>モナドなどです。</p>
<p>この章の例では、高階関数の威力を示すとともに、 <em>実装からのデータの分離</em>
も実演してみせました。これは例えば、代数データ型を使用してこれらの概念を次のように拡張し、描画関数からシーンの表現を完全に分離できるようになります。</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>この手法は <code>drawing</code>パッケージでも採用されており、描画前にさまざまな方
法でデータとしてシーンを操作することができるという柔軟性をもたらしてい
ます。</p>
<p>canvasに描画されるゲームの例については
<a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>
の「Behavior」と「Signal」のレシピを見てください。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter11.ja.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter13.ja.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter11.ja.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter13.ja.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

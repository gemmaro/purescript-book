<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>型クラス - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">15.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">16.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">17.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">18.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html"><strong aria-hidden="true">19.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html" class="active"><strong aria-hidden="true">20.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">21.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">22.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">23.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.ja.html"><strong aria-hidden="true">24.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.ja.html"><strong aria-hidden="true">25.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.ja.html"><strong aria-hidden="true">26.</strong> Canvasグラフィックス</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="型クラス"><a class="header" href="#型クラス">型クラス</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章では、PureScriptの型システムによって可能になる強力な抽象化の手法である、型クラスを導入します。</p>
<p>この章ではデータ構造をハッシュするためのライブラリを題材に説明していきます。データ自身の構造について直接考えることなく複雑な構造のデータのハッシュ値を求めるために、型クラスの仕組みがどのようにして働くのかを見ていきます。</p>
<p>また、PureScriptのPreludeや標準ライブラリに含まれる、標準的な型クラスも見ていきます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大きく依存しているので、これらのクラスに慣れておくと役に立つでしょう。</p>
<p>オブジェクト指向の方面から入って来た方は、
「クラス」という単語がそれまで馴染みのあるものとこの文脈とでは
<strong>かなり</strong>異なるものを意味していることに注意してください。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>この章のソースコードは、ファイル <code>src/data/Hashable.purs</code>で定義されています。</p>
<p>このプロジェクトには以下の依存関係があります。</p>
<ul>
<li><code>maybe</code>: オプショナルな値を表す <code>Maybe</code>データ型が定義されています。</li>
<li><code>tuples</code>: 値の組を表す <code>Tuple</code>データ型が定義されています。</li>
<li><code>either</code>: 非交和を表す <code>Either</code>データ型が定義されています。</li>
<li><code>strings</code>: 文字列を操作する関数が定義されています。</li>
<li><code>functions</code>: PureScriptの記述用の補助関数が定義されています。</li>
</ul>
<p>モジュール <code>Data.Hashable</code>では、これらのパッケージによって提供されるモジュールのいくつかをインポートしています。</p>
<h2 id="見せてください"><a class="header" href="#見せてください">見せてください！</a></h2>
<p>型クラスの最初の簡単な例は、すでに何回か見たことがある関数で提供されています。
<code>show</code>は、何らかの値を取り、それを文字列として表示する関数です。</p>
<p><code>show</code>は <code>Prelude</code>モジュールの <code>Show</code>と呼ばれる型クラスで次のように定義されています。</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String
</code></pre>
<p>このコードでは、型変数 <code>a</code>でパラメータ化された、
<code>Show</code>という新しい<strong>型クラス</strong> (type class) を宣言しています。</p>
<p>型クラス<strong>インスタンス</strong>には、型クラスで定義された関数の、その型に特殊化された実装が含まれています。</p>
<p>例えば、Preludeにある <code>Boolean</code>値に対する <code>Show</code>型クラスインスタンスの定義は次の通りです。</p>
<pre><code class="language-haskell">instance showBoolean :: Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<p>このコードは <code>showBool​​ean</code>という名前の型クラスのインスタンスを宣言します。
PureScriptでは、生成されたJavaScriptの可読性を良くするために、型クラスインスタンスに名前をつけます。このとき、<strong><code>Boolean</code>型は
<code>Show</code>型クラスに属している</strong>といいます。</p>
<p>PSCiで、いろいろな型の値を<code>Show</code>型クラスを利用して表示してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; show true
&quot;true&quot;

&gt; show 1.0
&quot;1.0&quot;

&gt; show &quot;Hello World&quot;
&quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>この例ではさまざまなプリミティブ型の値を <code>show</code>しましたが、もっと複雑な型を持つ値を <code>show</code>することもできます。</p>
<pre><code class="language-text">&gt; import Data.Tuple

&gt; show (Tuple 1 true)
&quot;(Tuple 1 true)&quot;

&gt; import Data.Maybe

&gt; show (Just &quot;testing&quot;)
&quot;(Just \&quot;testing\&quot;)&quot;
</code></pre>
<p><code>show</code>の出力は、REPLに（あるいは<code>.purs</code>ファイルに）もう一度貼り付ければ、
表示されるものを再作成できるような文字列であるべきです。
以下では<code>logShow</code>を使っていますが、これは単に<code>show</code>と<code>log</code>を順に呼び出して、
引用符なしに文字列を表示するものです。
<code>unit</code>の表示は無視してください。
第8章で、<code>log</code>のような<code>Effect</code>を調べるときに押さえます。</p>
<pre><code class="language-text">&gt; import Effect.Console

&gt; logShow (Tuple 1 true)
(Tuple 1 true)
unit

&gt; logShow (Just &quot;testing&quot;)
(Just &quot;testing&quot;)
unit
</code></pre>
<p>型 <code>Data.Either</code>の値を表示しようとすると、興味深いエラーメッセージが表示されます。</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; show (Left 10)

The inferred type

    forall a. Show a =&gt; String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでの問題は <code>show</code>しようとしている型に対する <code>Show</code>インスタンスが存在しないということではなく、
PSCiがこの型を推論できなかったということです。
このエラーメッセージで<strong>未知の型</strong><code>a</code>と表示されているのがそれです。</p>
<p><code>::</code>演算子を使って式に対して型注釈を加えると、
PSCiが正しい型クラスインスタンスを選ぶことができるようになります。</p>
<pre><code class="language-text">&gt; show (Left 10 :: Either Int String)
&quot;(Left 10)&quot;
</code></pre>
<p><code>Show</code>インスタンスをまったく持っていない型もあります。
関数の型 <code>-&gt;</code>がその一例です。
<code>Int</code>から <code>Int</code>への関数を <code>show</code>しようとすると、
型検証器によってその通りのエラーメッセージが表示されます。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; show $ \n -&gt; n + 1

No type class instance was found for

  Data.Show.Show (Int -&gt; Int)
</code></pre>
<p>型クラスインスタンスは次の2つのうちいずれかの形で定義されます。
型クラスが定義されている同じモジュールで定義するか、
型クラスに「属して」いる型と同じモジュールで定義するかです。
これらとは別の場所で定義されるインスタンスは<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">「孤立インスタンス」</a>と呼ばれ、PureScriptコンパイラによって許されていません。
この章の演習のいくつかでは、
その型の型クラスインスタンスを定義できるように、
型の定義を自分の<code>MySolutions</code>モジュールに複製する必要があります。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Show</code>インスタンスを<code>Point</code>に定義してください。
前の章の<code>showPoint</code>関数と同じ出力に一致するようにしてください。
<strong>補足</strong>：<code>Point</code>はここでは（<code>type</code>同義語ではなく）<code>newtype</code>です。
そのため<code>show</code>の仕方を変えられます。
こうでもしないとレコードへの既定の<code>Show</code>インスタンスから逃れられません。</p>
<pre><code class="language-haskell">newtype Point
  = Point
  { x :: Number
  , y :: Number
  }
</code></pre>
</li>
</ol>
<h2 id="よく見かける型クラス"><a class="header" href="#よく見かける型クラス">よく見かける型クラス</a></h2>
<p>この節では、Preludeや標準ライブラリで定義されている標準的な型クラスをいくつか見ていきましょう。
これらの型クラスはPureScript特有の抽象化の多くのよくあるパターンの基礎を形成しているため、
これらの関数の基本についてよく理解しておくことを強くお勧めします。</p>
<h3 id="eq"><a class="header" href="#eq">Eq</a></h3>
<p><code>Eq</code>型クラスは、2つの値が等しいかどうかを調べる<code>eq</code>関数を定義しています。
等値演算子(<code>==</code>)は<code>eq</code>の別名にすぎません。</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>異なる型の2つの値を比較しても意味がありませんから、
いずれの演算子も2つの引数が同じ型を持つ必要があることに注意してください。</p>
<p>PSCiで <code>Eq</code>型クラスを試してみましょう。</p>
<pre><code class="language-text">&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true
</code></pre>
<h3 id="ord"><a class="header" href="#ord">Ord</a></h3>
<p><code>Ord</code>型クラスは順序付け可能な型に対して2つの値を比較する <code>compare</code>関数を定義します。
比較演算子 <code>&lt;</code>、 <code>&gt;</code>と、その仲間の厳密な比較ではない<code>&lt;=</code>、 <code>&gt;=</code>も、<code>compare</code>を使って定義されます。</p>
<pre><code class="language-haskell">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p><code>compare</code>関数は2つの値を比較して <code>Ordering</code>の3つの値のうちいずれかを返します。</p>
<ul>
<li><code>LT</code>- 最初の引数が2番目の値より小さいとき</li>
<li><code>EQ</code>- 最初の引数が2番目の値と等しい（または比較できない）とき</li>
<li><code>GT</code>- 最初の引数が2番目の値より大きいとき</li>
</ul>
<p>ここでも<code>compare</code>関数についてPSCiで試してみましょう。</p>
<pre><code class="language-text">&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<p><code>Field</code>型クラスは加算、減算、乗算、除算などの数値演算子を使用可能な型を示します。
必要に応じて再利用できるように、これらの演算子を抽象化するわけです。</p>
<p><strong>注意</strong>：型クラス <code>Eq</code>や <code>Ord</code>のクラスとちょうど同じように、
<code>Field</code>型のクラスはPureScriptコンパイラで特別に扱われ、
<code>1 + 2 * 3</code>のような単純な式は単純なJavaScriptへと変換されます。
型クラスの実装に基いて呼び出される関数呼び出しとは対照的です。</p>
<pre><code class="language-haskell">class EuclideanRing a &lt;= Field a
</code></pre>
<p><code>Field</code>型クラスは、いくつかのより抽象的な<strong>上位クラス</strong> (Super Class) が組み合わさってできています。
これは、その型は<code>Field</code>型クラスの操作をすべてを提供しているわけではないが、
その一部を提供する、というように抽象的に説明することができます。
この型クラスは抽象的なすべてではないいくつかの数値演算子をサポートしています。
例えば、自然数の型は加算および乗算については閉じていますが、
減算については閉じていないため、
この型は<code>Semiring</code>クラス（これは<code>Num</code>の上位クラスです）のインスタンスですが、
<code>Ring</code>や<code>Field</code>のインスタンスではありません。</p>
<p>上位クラスについては、この章の後半で詳しく説明します。
しかし、すべての<a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">数値型クラスの階層</a>（<a href="https://harry.garrood.me/numeric-hierarchy-overview/">チートシート</a>）について述べるのはこの章の目的から外れています。
この内容に興味のある読者は<code>prelude</code>内の <code>Field</code>に関するドキュメントを参照してください。</p>
<h3 id="半群とモノイド"><a class="header" href="#半群とモノイド">半群とモノイド</a></h3>
<p><code>Semigroup</code>（半群）型クラスは、2つの値を連結する演算子 <code>append</code>を提供する型を示します。</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a
</code></pre>
<p>普通の文字列連結について文字列は半群をなし、同様に配列も半群をなします。
その他の標準的なインスタンスの幾つかは、 <code>prelude</code>パッケージで提供されています。</p>
<p>以前に見た <code>&lt;&gt;</code>連結演算子は、 <code>append</code>の別名として提供されています。</p>
<p>（<code>prelude</code>パッケージで提供されている）<code>Monoid</code>型クラスは、
<code>mempty</code>と呼ばれる空の値の概念で <code>Semigroup</code>型クラスを拡張します。</p>
<pre><code class="language-haskell">class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>ここでも文字列や配列はモノイドの簡単な例になっています。</p>
<p><code>Monoid</code>型クラスインスタンスでは、
「空」の値から始めて新たな値を合成していき、
その型で<strong>累積</strong>した結果を返すにはどうするかを記述する型クラスです。
例えば、畳み込みを使っていくつかのモノイドの値の配列を連結する関数を書くことができます。
PSCiで試すと次のようになります。</p>
<pre><code class="language-haskell">&gt; import Prelude
&gt; import Data.Monoid
&gt; import Data.Foldable

&gt; foldl append mempty [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&quot;Hello World&quot;

&gt; foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
</code></pre>
<p><code>prelude</code>パッケージにはモノイドと半群の多くの例を提供しており、
以降もこれらを本書で扱っていきます。</p>
<h3 id="foldable"><a class="header" href="#foldable">Foldable</a></h3>
<p><code>Monoid</code>型クラスは畳み込みの結果になるような型を示しますが、
<code>Foldable</code>型クラスは、畳み込みの元のデータとして使えるような型構築子を示しています。</p>
<p>また、 <code>Foldable</code>型クラスは、
配列や <code>Maybe</code>などのいくつかの標準的なコンテナのインスタンスを含む
<code>foldable-traversable</code>パッケージで提供されています。</p>
<p><code>Foldable</code>クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し複雑です。</p>
<pre><code class="language-haskell">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p>この定義は <code>f</code>を配列の型構築子として特殊化して考えてみるとわかりやすくなります。
この場合、すべての <code>a</code>について <code>f a</code>を <code>Array a</code>に置き換える事ができますが、
<code>foldl</code>と <code>foldr</code>の型が、最初に見た配列に対する畳み込みの型になるとわかります。</p>
<p><code>foldMap</code>についてはどうでしょうか？
これは <code>forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Array a -&gt; m</code>になります。
この型シグネチャは、型 <code>m</code>が <code>Monoid</code>型クラスのインスタンスであれば
どんな型でも返り値の型として選ぶことができると言っています。
配列の要素をそのモノイドの値へと変換する関数を提供すれば、
そのモノイドの構造を利用して配列を畳み込み、ひとつの値にして返すことができます。</p>
<p>それではPSCiで <code>foldMap</code>を試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;
</code></pre>
<p>ここでは繋ぎ合わせるためのモノイドとして文字列を、
そして<code>Int</code>を文字列として表示する <code>show</code>関数を選びました。
それから、数の配列を渡すと、それぞれの数を <code>show</code>してひとつの文字列へと連結した結果が出力されました。</p>
<p>しかし畳み込み可能な型は配列だけではありません。
<code>foldable-traversable</code>では <code>Maybe</code>や <code>Tuple</code>のような型の <code>Foldable</code>インスタンスが定義されており、
<code>lists</code>のような他のライブラリでは、
そのライブラリのそれぞれのデータ型に対して <code>Foldable</code>インスタンスが定義されています。
<code>Foldable</code>は<strong>順序付きコンテナ</strong> (ordered container) の概念を捉えたものなのです。</p>
<h3 id="関手と型クラス則"><a class="header" href="#関手と型クラス則">関手と型クラス則</a></h3>
<p>PureScriptで副作用を伴う関数型プログラミングのスタイルを可能にするための
<code>Functor</code>と <code>Applicative</code>、 <code>Monad</code>といった型クラスがPreludeでは定義されています。
これらの抽象については本書で後ほど扱いますが、
まずは<code>map</code>関数の形ですでに見てきた <code>Functor</code>型クラスの定義を見てみましょう。</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>map</code>関数（別名<code>&lt;$&gt;</code>）は関数をそのデータ構造まで「持ち上げる」(lift) ことができます。
ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、
すでにいくつかの単純な型についてその動作を見てきました。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; map (\n -&gt; n &lt; 3) [1, 2, 3, 4, 5]
[true, true, false, false, false]

&gt; import Data.Maybe
&gt; import Data.String (length)

&gt; map length (Just &quot;testing&quot;)
(Just 7)
</code></pre>
<p><code>map</code>演算子は様々な構造の上でそれぞれ異なる振る舞いをしますが、 <code>map</code>演算子の意味はどのように理解すればいいのでしょうか。</p>
<p>直感的には、 <code>map</code>演算子はコンテナのそれぞれの要素へ関数を適用し、
その結果から元のデータと同じ形状を持った新しいコンテナを構築するものとできます。
しかし、この着想を精密にするにはどうしたらいいでしょうか？</p>
<p><code>Functor</code>の型クラスのインスタンスは、
<strong>関手則</strong> (functor laws) と呼ばれる法則を順守するものと期待されています。</p>
<ul>
<li><code>map identity xs = xs</code></li>
<li><code>map g (map f xs) = map (g &lt;&lt;&lt; f) xs</code></li>
</ul>
<p>最初の法則は<strong>恒等射律</strong> (identity law) です。
これは、恒等関数（引数を変えずに返す関数）をその構造まで持ち上げると、
元の構造をそのまま返すという意味です。
恒等関数は入力を変更しませんから、これは理にかなっています。</p>
<p>第二の法則は<strong>合成律</strong> (composition law) です。
構造をひとつの関数で写してから2つめの関数で写すのは、
2つの関数の合成で構造を写すのと同じだ、と言っています。</p>
<p>「持ち上げ」の一般的な意味が何であれ、
データ構造に対する持ち上げ関数の正しい定義はこれらの法則に従っていなければなりません。</p>
<p>標準の型クラスの多くには、
このような法則が付随しています。
一般に、型クラスに与えられた法則は、
型クラスの関数に構造を与え、
普遍的にインスタンスについて調べられるようにします。
興味のある読者は、すでに見てきた標準の型クラスに属する法則について調べてみてもよいでしょう。</p>
<h3 id="インスタンスの導出"><a class="header" href="#インスタンスの導出">インスタンスの導出</a></h3>
<p>インスタンスを手作業で描く代わりに、ほとんどの作業をコンパイラにさせることができます。
この<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出手引き</a>を見てください。
そちらの情報が以下の演習を解く手助けになることでしょう。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<p>（簡単）次のnewtypeは複素数を表します。</p>
<pre><code class="language-haskell">newtype Complex
  = Complex
  { real :: Number
  , imaginary :: Number
  }
</code></pre>
<ol>
<li>
<p>（簡単）<code>Complex</code>に<code>Show</code>インスタンスを定義してください。
出力の形式はテストで期待される形式と一致させてください。
（例：<code>1.2+3.4i</code>、<code>5.6-7.7i</code>など）</p>
</li>
<li>
<p>（簡単）<code>Eq</code>インスタンスを<code>Complex</code>に導出してください。
<strong>補足</strong>：代わりにこのインスタンスを手作業で書いてもよいですが、しなくていいのになぜするのですか？</p>
</li>
<li>
<p>（普通）<code>Semiring</code>インタンスを<code>Complex</code>に定義してください。
<strong>補足</strong>：<a href="https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype"><code>Data.Newtype</code></a>の<code>wrap</code>と<code>over2</code>を使ってより簡潔な解法をつくることができます。
もしそうするのでしたら、<code>Data.Newtype</code>から<code>class Newtype</code>をインポートしたり、
<code>Newtype</code>インスタンスを<code>Complex</code>に導出したりする必要も出てくるでしょう。</p>
</li>
<li>
<p>（簡単）（<code>newtype</code>を介して）<code>Ring</code>インスタンスを<code>Complex</code>に導出してください。
<strong>補足</strong>：代わりにこのインスタンスを手作業で書くこともできますが、
そう手軽にはできません。</p>
<p>以下は前章からの<code>Shape</code>のADTです。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String
</code></pre>
</li>
<li>
<p>（普通）（<code>Generic</code>を介して）<code>Show</code>インスタンスを<code>Shape</code>に導出してください。
コードの量はどのくらいになりましたか？
また、前の章の<code>showShape</code>と比較して<code>String</code>の出力はどうなりましたか？
<strong>ヒント</strong>：<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出</a>手引きの<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic"><code>Generic</code>から導出する</a>節を見てください。</p>
</li>
</ol>
<h2 id="型クラス制約"><a class="header" href="#型クラス制約">型クラス制約</a></h2>
<p>型クラスを使うと、関数の型に制約を加えることができます。
例を示しましょう。
<code>Eq</code>型クラスのインスタンスで定義された等値性を使って、3つの値が等しいかどうかを調べる関数を書きたいとします。</p>
<pre><code class="language-haskell">threeAreEqual :: forall a. Eq a =&gt; a -&gt; a -&gt; a -&gt; Boolean
threeAreEqual a1 a2 a3 = a1 == a2 &amp;&amp; a2 == a3
</code></pre>
<p>この型宣言は <code>forall</code>を使って定義された通常の多相型のようにも見えます。
しかし、二重線矢印 <code>=&gt;</code>で型の残りの部分から区切られた、型クラス制約 (type class constraint) <code>Eq a</code>があります。</p>
<p>インポートされたモジュールのどれかに <code>a</code>に対する <code>Eq</code>インスタンスが存在するなら、
どんな型 <code>a</code>を選んでも <code>threeAsEqual</code>を呼び出すことができる、とこの型は言っています。</p>
<p>制約された型には複数の型クラスインスタンスを含めることができますし、インスタンスの型は単純な型変数に限定されません。 <code>Ord</code>と
<code>Show</code>のインスタンスを使って2つの値を比較する例を次に示します。</p>
<pre><code class="language-haskell">showCompare :: forall a. Ord a =&gt; Show a =&gt; a -&gt; a -&gt; String
showCompare a1 a2 | a1 &lt; a2 =
  show a1 &lt;&gt; &quot; is less than &quot; &lt;&gt; show a2
showCompare a1 a2 | a1 &gt; a2 =
  show a1 &lt;&gt; &quot; is greater than &quot; &lt;&gt; show a2
showCompare a1 a2 =
  show a1 &lt;&gt; &quot; is equal to &quot; &lt;&gt; show a2
</code></pre>
<p><code>=&gt;</code>シンボルを複数回使って複数の制約を指定できることに注意してください。
複数の引数のカリー化された関数を定義するのと同様です。
しかし、2つの記号を混同しないように注意してください。</p>
<ul>
<li><code>a -&gt; b</code>は<strong>型</strong><code>a</code>から<strong>型</strong><code>b</code>への関数の型を表します。一方で、</li>
<li><code>a =&gt; b</code>は<strong>制約</strong><code>a</code>を型<code>b</code>に適用します。</li>
</ul>
<p>PureScriptコンパイラは、型の注釈が提供されていない場合、制約付き型を推測しようとします。
これは、関数に対して可能な最も一般的な型を使用したい場合に便利です。</p>
<p>PSCiで <code>Semiring</code>のような標準の型クラスのいずれかを使って、このことを試してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; :type \x -&gt; x + x
forall a. Semiring a =&gt; a -&gt; a
</code></pre>
<p>ここで、この関数には<code>Int -&gt; Int</code>または<code>Number -&gt; Number</code>と注釈を付けることが考えられますが、
最も一般的な型が<code>Semiring</code>で動作するため、
PSCiでは<code>Int</code>と <code>Number</code>の両方で関数を実行させることができます。</p>
<h2 id="インスタンスの依存関係"><a class="header" href="#インスタンスの依存関係">インスタンスの依存関係</a></h2>
<p>制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、
型クラスインスタンスの実装は他の型クラスインスタンスに依存することができます。
これにより、型を使ってプログラムの実装を推論するという、プログラム推論の強力な形式を提供します。</p>
<p><code>Show</code>型クラスを例に考えてみましょう。
それぞれの要素を <code>show</code>する方法がある限り、
その要素の配列を <code>show</code>する型クラスインスタンスを書くことができます。</p>
<pre><code class="language-haskell">instance showArray :: Show a =&gt; Show (Array a) where
  ...
</code></pre>
<p>型クラスインスタンスが複数の他のインスタンスに依存する場合、
括弧で囲んでそれらのインスタンスをコンマで区切り、
それを<code>=&gt;</code>シンボルの左側に置く必要があります。</p>
<pre><code class="language-haskell">instance showEither :: (Show a, Show b) =&gt; Show (Either a b) where
  ...
</code></pre>
<p>これらの2つの型クラスインスタンスは <code>prelude</code>ライブラリにあります。</p>
<p>プログラムがコンパイルされると、
<code>Show</code>の正しい型クラスのインスタンスは <code>show</code>の引数の推論された型に基づいて選ばれます。
選択されたインスタンスが沢山のそうしたインスタンスの関係に依存しているかもしれませんが、
このあたりの複雑さに開発者が関与することはありません。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>
<p>（簡単）以下の宣言では型 <code>a</code>の要素の空でない配列の型を定義しています。</p>
<pre><code class="language-haskell">data NonEmpty a = NonEmpty a (Array a)
</code></pre>
<p><code>Eq a</code>と<code>Eq (Array a)</code>へのインスタンスを再利用し、型<code>NonEmpty</code>に<code>Eq</code>インスタンスを書いてください。
<strong>補足</strong>：代わりに<code>Eq</code>インスタンスは導出することもできます。</p>
</li>
<li>
<p>（普通）<code>Array</code>への<code>Semigroup</code>インスタンスを再利用して、
<code>NonEmpty</code>への<code>Semigroup</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>NonEmpty</code>に<code>Functor</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>Ord</code>のインスタンス付きのあらゆる型<code>a</code>が与えられているとすると、
新しくそれ以外のどんな値よりも大きい「無限の」値を付け加えられます。</p>
<pre><code class="language-haskell">data Extended a = Infinite | Finite a 
</code></pre>
<p><code>a</code>への<code>Ord</code>インスタンスを再利用して、<code>Extended a</code>に<code>Ord</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（難しい）<code>NonEmpty</code>に<code>Foldable</code>インスタンスを書いてください。
<strong>ヒント</strong>：配列への<code>Foldable</code>インスタンスを再利用してください。</p>
</li>
<li>
<p>（難しい）順序付きコンテナを定義する（そして <code>Foldable</code>のインスタンスを持っている）ような型構築子 <code>f</code>が与えられたとき、
追加の要素を先頭に含めるような新たなコンテナ型を作ることができます。</p>
<pre><code class="language-haskell">data OneMore f a = OneMore a (f a)
</code></pre>
<p>このコンテナ <code>OneMore f</code>もまた順序を持っています。
ここで、新しい要素は任意の <code>f</code>の要素よりも前にきます。
この <code>OneMore f</code>の <code>Foldable</code>インスタンスを書いてみましょう。</p>
<pre><code class="language-haskell">instance foldableOneMore :: Foldable f =&gt; Foldable (OneMore f) where
  ...
</code></pre>
</li>
<li>
<p>（普通）<code>nubEq</code>関数を使い、
配列から重複する<code>Shape</code>を削除する
<code>dedupShapes :: Array Shape -&gt; Array Shape</code>関数を書いてください。</p>
</li>
<li>
<p>（普通）<code>dedupShapesFast</code>関数を書いてください。
<code>dedupShapes</code>とほぼ同じですが、より効率の良い<code>nub</code>関数を使います。</p>
</li>
</ol>
<h2 id="多変数型クラス"><a class="header" href="#多変数型クラス">多変数型クラス</a></h2>
<p>型クラスは必ずしもひとつの型だけを型変数としてとるわけではありません。
型変数がひとつだけなのが最も一般的ですが、
実際には型クラスは<strong>ゼロ個以上の</strong>型変数を持つことができます。</p>
<p>それでは2つの型引数を持つ型クラスの例を見てみましょう。</p>
<pre><code class="language-haskell">module Stream where

import Data.Array as Array
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String

class Stream stream element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }

instance streamArray :: Stream (Array a) a where
  uncons = Array.uncons

instance streamString :: Stream String Char where
  uncons = String.uncons
</code></pre>
<p>この <code>Stream</code>モジュールでは、
要素のストリームのような型を示すクラス <code>Stream</code>が定義されています。
<code>uncons</code>関数を使ってストリームの先頭から要素を取り出すことができます。</p>
<p><code>Stream</code>型クラスは、
ストリーム自身の型だけでなくその要素の型も型変数として持っていることに注意してください。
これによって、ストリームの型が同じでも要素の型について異なる型クラスインスタンスを定義することができます。</p>
<p>このモジュールでは2つの型クラスインスタンスが定義されています。
<code>uncons</code>がパターン照合で配列の先頭の要素を取り除くような配列のインスタンスと、
文字列から最初の文字を取り除くような文字列のインスタンスです。</p>
<p>任意のストリーム上で動作する関数を記述することができます。
例えば、ストリームの要素に基づいて <code>Monoid</code>に結果を累積する関数は次のようになります。</p>
<pre><code class="language-haskell">import Prelude
import Data.Monoid (class Monoid, mempty)

foldStream :: forall l e m. Stream l e =&gt; Monoid m =&gt; (e -&gt; m) -&gt; l -&gt; m
foldStream f list =
  case uncons list of
    Nothing -&gt; mempty
    Just cons -&gt; f cons.head &lt;&gt; foldStream f cons.tail
</code></pre>
<p>PSCiで使って、異なる <code>Stream</code>の型や異なる <code>Monoid</code>の型について <code>foldStream</code>を呼び出してみましょう。</p>
<h2 id="関数従属性"><a class="header" href="#関数従属性">関数従属性</a></h2>
<p>多変数型クラスは非常に便利ですが、
混乱しやすい型や型推論の問題にもつながります。
簡単な例として、上記の <code>Stream</code>クラスを使って汎用的な<code>tail</code>関数をストリームに書くことを考えてみましょう。</p>
<pre><code class="language-haskell">genericTail xs = map _.tail (uncons xs)
</code></pre>
<p>これはやや複雑なエラーメッセージを出力します。</p>
<pre><code class="language-text">The inferred type

  forall stream a. Stream stream a =&gt; stream -&gt; Maybe stream

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>エラーは、 <code>genericTail</code>関数が <code>Stream</code>型クラスの定義で言及された <code>element</code>型を使用しないので、
その型は未解決のままであることを指しています。</p>
<p>さらに、特定の型のストリームに <code>genericTail</code>を適用することができません。</p>
<pre><code class="language-text">&gt; map _.tail (uncons &quot;testing&quot;)

The inferred type

  forall a. Stream String a =&gt; Maybe String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでは、コンパイラが <code>streamString</code>インスタンスを選択することを期待しています。
結局のところ、 <code>String</code>は <code>Char</code>のストリームであり、他の型のストリームであってはなりません。</p>
<p>コンパイラは自動的にその推論を行うことができず、
<code>streamString</code>インスタンスを割り当てることができません。
しかし、型クラス定義にヒントを追加すると、コンパイラを助けることができます。</p>
<pre><code class="language-haskell">class Stream stream element | stream -&gt; element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }
</code></pre>
<p>ここで、 <code>stream -&gt; element</code>は<strong>関数従属性</strong> (functional dependency) と呼ばれます。
関数従属性は、多変数型クラスの型引数間の関数関係を宣言します。
この関数の依存関係は、ストリーム型から（一意の）要素型への関数があることをコンパイラに伝えるので、
コンパイラがストリーム型を知っていれば要素の型を割り当てられます。</p>
<p>このヒントは、コンパイラが上記の汎用的な尾鰭関数の正しい型を推論するのに十分です。</p>
<pre><code class="language-text">&gt; :type genericTail
forall stream element. Stream stream element =&gt; stream -&gt; Maybe stream

&gt; genericTail &quot;testing&quot;
(Just &quot;esting&quot;)
</code></pre>
<p>多種の型のクラスを使用して何らかのAPIを設計する場合、関数従属性は非常に有用です。</p>
<h2 id="型変数のない型クラス"><a class="header" href="#型変数のない型クラス">型変数のない型クラス</a></h2>
<p>ゼロ個の型変数を持つ型クラスを定義することもできます！
これらは関数に対するコンパイル時のアサーションに対応しており、
型システム内のコードの大域的な性質を追跡することができます。</p>
<p>重要な一例として、前に部分関数についてお話しした際に見た<code>Partial</code>クラスがあります。
<code>Data.Array.Partial</code>に定義されている関数<code>head</code>と<code>tail</code>を例に取りましょう。
この関数は配列の先頭と尾鰭を<code>Maybe</code>に包むことなく取得することができます。
なので配列が空のときに失敗する可能性があります。</p>
<pre><code class="language-haskell">head :: forall a. Partial =&gt; Array a -&gt; a

tail :: forall a. Partial =&gt; Array a -&gt; Array a
</code></pre>
<p><code>Partial</code>モジュールの <code>Partial</code>型クラスのインスタンスを定義していないことに注意してください。
こうすると目的を達成できます。
このままの定義では <code>head</code>関数を使用しようとすると型エラーになるのです。</p>
<pre><code class="language-text">&gt; head [1, 2, 3]

No type class instance was found for

  Prim.Partial
</code></pre>
<p>代わりに、これらの部分関数を利用するすべての関数で <code>Partial</code>制約を再発行することができます。</p>
<pre><code class="language-haskell">secondElement :: forall a. Partial =&gt; Array a -&gt; a
secondElement xs = head (tail xs)
</code></pre>
<p>前章で見た <code>unsafePartial</code>関数を使用し、
部分関数を通常の関数（unsafely）として扱うことができます。
この関数は <code>Partial.Unsafe</code>モジュールで定義されています。</p>
<pre><code class="language-haskell">unsafePartial :: forall a. (Partial =&gt; a) -&gt; a
</code></pre>
<p><code>Partial</code>制約は関数の矢印の左側の括弧の中に現れますが、
外側の <code>forall</code>では現れません。
つまり、 <code>unsafePartial</code>は部分的な値から通常の値への関数です。</p>
<pre><code class="language-text">&gt; unsafePartial head [1, 2, 3]
1

&gt; unsafePartial secondElement [1, 2, 3]
2
</code></pre>
<h2 id="上位クラス"><a class="header" href="#上位クラス">上位クラス</a></h2>
<p>インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス間の関係を表現することができるように、
いわゆる<strong>上位クラス</strong> (superclass) を使って型クラス間の関係を表現することができます。</p>
<p>あるクラスのどんなインスタンスも、
別のクラスのインスタンスである必要があるとき、
後者の型クラスは前者の型クラスの上位クラスであるといい、
クラス定義で逆向きの太い矢印を使って上位クラス関係を示します。</p>
<p>すでに上位クラスの関係の例を見掛けています。
<code>Eq</code>クラスは <code>Ord</code>の上位クラスですし、<code>Semigroup</code>クラスは<code>Monoid</code>の上位クラスです。
<code>Ord</code>クラスのすべての型クラスインスタンスについて、
その同じ型に対応する <code>Eq</code>インスタンスが存在しなければなりません。
<code>compare</code>関数が2つの値が比較できないと報告した時は、
それらが実は同値であるかどうかを決定するために <code>Eq</code>クラスを使いたくなることが多いでしょうから、
これは理にかなっています。</p>
<p>一般に、下位クラスの法則が上位クラスのメンバに言及しているとき、
上位クラス関係を定義するのは理にかなっています。
例えば、 <code>Ord</code>と <code>Eq</code>のインスタンスのどんな組についても、
もしふたつの値が <code>Eq</code>インスタンスのもとで同値であるなら、
<code>compare</code>関数は <code>EQ</code>を返すはずだとみなすのは妥当です。
言い換えれば、まさしく<code>a == b</code>ならば <code>compare a b == EQ</code>です。
法則の階層上のこの関係は、 <code>Eq</code>と <code>Ord</code>の間の上位クラス関係を説明します。</p>
<p>上位クラス関係を定義する別の理由となるのは、
この2つのクラスの間に明らかに &quot;is-a&quot; の関係があることです。
下位クラスのすべてのメンバは、上位クラスのメンバでもあるということです。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>
<p>（普通）部分関数<code>unsafeMaximum :: Partial =&gt; Array Int -&gt; Int</code>を定義してください。
この関数は整数の空でない配列の最大値を求めます。
<code>unsafePartial</code>を使ってPSCiで関数をテストしてください。
<strong>ヒント</strong>：<code>Data.Foldable</code>の <code>maximum</code>関数を使います。</p>
</li>
<li>
<p>（普通）次の <code>Action</code>クラスは、ある型の別の型での動作 (action) を定義する、多変数型クラスです。</p>
<pre><code class="language-haskell">class Monoid m &lt;= Action m a where
  act :: m -&gt; a -&gt; a
</code></pre>
<p><strong>動作</strong>はどのようにモノイドな値を使って他の型の値を変更する方法を決められるのかを記述する関数です。
<code>Action</code>型クラスには2つの法則があります。</p>
<ul>
<li><code>act mempty a = a</code></li>
<li><code>act (m1 &lt;&gt; m2) a = act m1 (act m2 a)</code></li>
</ul>
<p>空の動作を提供しても何も起こりません。
そして2つの動作を連続で適用することは結合した動作を適用することと同じです。
つまり、動作は<code>Monoid</code>クラスで定義される操作に倣っています。</p>
<p>たとえば、自然数は乗算のもとでモノイドを形成します。</p>
<pre><code class="language-haskell">newtype Multiply = Multiply Int

instance semigroupMultiply :: Semigroup Multiply where
  append (Multiply n) (Multiply m) = Multiply (n * m)

instance monoidMultiply :: Monoid Multiply where
  mempty = Multiply 1
</code></pre>
<p>この動作を実装するインスタンスを書いてください。</p>
<pre><code class="language-haskell">instance actionMultiplyInt :: Action Multiply Int where
  ...
</code></pre>
<p>インスタンスが上で挙げた法則を見たさなくてはならないことを思い出してください。</p>
</li>
<li>
<p>（難しい）実は<code>Action Multiply Int</code>のインスタンスを実装するには複数の方法があります。
どれだけ思い付きますか？
PureScriptは同じインスタンスの複数の実装を許さないため、
元の実装を置き換える必要があります。
<strong>補足</strong>：テストでは4つの実装を押さえています。</p>
</li>
<li>
<p>（普通）入力の文字列を何回か繰り返す<code>Action</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">instance actionMultiplyString :: Action Multiply String where
  ...
</code></pre>
<p><strong>ヒント</strong>：Pursuitでシグネチャが<a href="https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String"><code>String -&gt; Int -&gt; String</code></a>のお助け関数を検索してください。
なお<code>String</code>は（<code>Monoid</code>のような）より汎用的な型として現れます。</p>
<p>このインスタンスは上に挙げた法則を満たすでしょうか？</p>
</li>
<li>
<p>（普通）インスタンス <code>Action m a =&gt; Action m (Array a)</code>を書いてみましょう。
ここで、 配列上の動作はそれぞれの要素を独立に実行するものとして定義されます。</p>
</li>
<li>
<p>（難しい）以下のnewtypeが与えらえているとき、
<code>Action m (Self m)</code>のインスタンスを書いてください。
ここでモノイド<code>m</code>は<code>append</code>を用いて自力で動作します。</p>
<pre><code class="language-haskell">newtype Self m = Self m
</code></pre>
<p><strong>補足</strong>：テストフレームワークでは<code>Self</code>と<code>Multiply</code>型に<code>Show</code>と<code>Eq</code>インスタンスが必要になります。
手作業でこれらのインスタンスを書いてもよいですし、
<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype"><code>derive newtype instance</code></a>と書くだけでコンパイラに取り仕切ってもらうこともできます。</p>
</li>
<li>
<p>（難しい）多変数型のクラス <code>Action</code>の引数は、何らかの関数従属性によって関連づけられるべきですか。
なぜそうすべき、あるいはそうすべきでないでしょうか？
<strong>補足</strong>：この演習にはテストがありません。</p>
</li>
</ol>
<h2 id="ハッシュの型クラス"><a class="header" href="#ハッシュの型クラス">ハッシュの型クラス</a></h2>
<p>この最後の節では、章の残りを使ってデータ構造をハッシュするライブラリを作ります。</p>
<p>このライブラリの目的は説明だけであり、
堅牢なハッシングの仕組みの提供を目的としていないことに注意してください。</p>
<p>ハッシュ関数に期待される性質とはどのようなものでしょうか？</p>
<ul>
<li>ハッシュ関数は決定的でなくてはなりません。つまり、同じ値には同じハッシュ
値を対応させなければなりません。</li>
<li>ハッシュ関数はいろいろなハッシュ値の集合で結果が一様に分布しなければな
りません。</li>
</ul>
<p>最初の性質はまさに型クラスの法則のように見える一方で、
2番目の性質はよりくだけた規約の条項のようなもので、
PureScriptの型システムによって確実に強制できるようなものではなさそうです。
しかし、これは型クラスについて次のような直感的理解を与えるはずです。</p>
<pre><code class="language-haskell">newtype HashCode = HashCode Int

instance hashCodeEq :: Eq HashCode where
  eq (HashCode a) (HashCode b) = a == b

hashCode :: Int -&gt; HashCode
hashCode h = HashCode (h `mod` 65535)

class Eq a &lt;= Hashable a where
  hash :: a -&gt; HashCode
</code></pre>
<p>これに、 <code>a == b</code>ならば <code>hash a == hash b</code>を示唆するという関係性の法則が付随しています。</p>
<p>この節の残りの部分を費やして、
<code>Hashable</code>型クラスに関連付けられているインスタンスと関数のライブラリを構築していきます。</p>
<p>決定的な方法でハッシュ値を結合する方法が必要になります。</p>
<pre><code class="language-haskell">combineHashes :: HashCode -&gt; HashCode -&gt; HashCode
combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)
</code></pre>
<p><code>combineHashes</code>関数は2つのハッシュ値を混ぜて結果を0-65535の間に分布します。</p>
<p>それでは、入力の種類を制限する <code>Hashable</code>制約を使う関数を書いてみましょう。
ハッシュ関数を必要とするよくある目的としては、
2つの値が同じハッシュ値にハッシュされるかどうかを決定することです。
<code>hashEqual</code>関係はそのような機能を提供します。</p>
<pre><code class="language-haskell">hashEqual :: forall a. Hashable a =&gt; a -&gt; a -&gt; Boolean
hashEqual = eq `on` hash
</code></pre>
<p>この関数はハッシュコードの等値性を利用したハッシュ同値性を定義するために
<code>Data.Function</code>の <code>on</code>関数を使っていますが、
これはハッシュ同値性の宣言的な定義として読めるはずです。
つまり、それぞれの値が <code>hash</code>関数に渡されたあとで2つの値が等しいなら、
それらの値は「ハッシュ同値」です。</p>
<p>原始型の <code>Hashable</code>インスタンスをいくつか書いてみましょう。
まずは整数のインスタンスです。
<code>HashCode</code>は実際には単なるラップされた整数なので、これは簡単です。
<code>hashCode</code>ヘルパー関数を使うことができます。</p>
<pre><code class="language-haskell">instance hashInt :: Hashable Int where
  hash = hashCode
</code></pre>
<p>パターン照合を使うと、<code>Boolean</code>値の単純なインスタンスを定義することもできます。</p>
<pre><code class="language-haskell">instance hashBoolean :: Hashable Boolean where
  hash false = hashCode 0
  hash true  = hashCode 1
</code></pre>
<p>整数のインスタンスでは、
<code>Data.Char</code>の <code>toCharCode</code>関数を使うと<code>Char</code>をハッシュするインスタンスを作成できます。</p>
<pre><code class="language-haskell">instance hashChar :: Hashable Char where
  hash = hash &lt;&lt;&lt; toCharCode
</code></pre>
<p>（要素型が <code>Hashable</code>のインスタンスでもあるならば）配列の要素に <code>hash</code>関数を <code>map</code>してから、
<code>combineHashes</code>関数を使って結果のハッシュを左側に畳み込むことで、
配列のインスタンスを定義します。</p>
<pre><code class="language-haskell">instance hashArray :: Hashable a =&gt; Hashable (Array a) where
  hash = foldl combineHashes (hashCode 0) &lt;&lt;&lt; map hash
</code></pre>
<p>すでに書いたものより単純なインスタンスを使用して、
新たなインスタンスを構築しているやり方に注目してください。
<code>String</code>を<code>Char</code>の配列に変換し、
この新たな<code>Array</code>インスタンスを使って<code>String</code>のインスタンスを定義しましょう。</p>
<pre><code class="language-haskell">instance hashString :: Hashable String where
  hash = hash &lt;&lt;&lt; toCharArray
</code></pre>
<p>これらの <code>Hashable</code>インスタンスが
先ほどの型クラスの法則を満たしていることを証明するにはどうしたらいいでしょうか。
同じ値が等しいハッシュ値を持っていることを確認する必要があります。
<code>Int</code>、 <code>Char</code>、 <code>String</code>、 <code>Boolean</code>の場合は、
<code>Eq</code>の意味では同じ値でも厳密には同じではない、
というような型の値は存在しないので簡単です。</p>
<p>もっと面白い型についてはどうでしょうか。
この場合、配列の長さに関する帰納を使うと、
型クラスの法則を証明することができます。
長さゼロの唯一の配列は <code>[]</code>です。
配列の <code>Eq</code>の定義により、任意の二つの空でない配列は、
それらの先頭の要素が同じで配列の残りの部分が等しいとき、
またその時に限り等しくなります。
この帰納的な仮定により、
配列の残りの部分は同じハッシュ値を持ちますし、
もし <code>Hashable a</code>インスタンスがこの法則を満たすなら、
先頭の要素も同じハッシュ値をもつことがわかります。
したがって、2つの配列は同じハッシュ値を持ち、
<code>Hashable (Array a)</code>も同様に型クラス法則を満たしています。</p>
<p>この章のソースコードには、 <code>Maybe</code>と <code>Tuple</code>型のインスタンスなど、
他にも <code>Hashable</code>インスタンスの例が含まれています。</p>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>
<p>（簡単）PSCiを使って、定義した各インスタンスのハッシュ関数をテストしてください。
<strong>補足</strong>：この演習には単体試験がありません。</p>
</li>
<li>
<p>（普通）ハッシュと値の同値性に基づいて
配列が重複する要素を持っているかどうかを調べる関数<code>arrayHasDuplicates</code>を書いてください。
まずハッシュ同値性を<code>hashEqual</code>関数で確認し、
それからもし重複するハッシュの対が見付かったら<code>==</code>で値の同値性を確認してください。
<strong>ヒント</strong>：<code>Data.Array</code>の <code>nubByEq</code>関数はこの問題をずっと簡単にしてくれるでしょう。</p>
</li>
<li>
<p>（普通）型クラスの法則を満たす、次のnewtypeの <code>Hashable</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">newtype Hour = Hour Int

instance eqHour :: Eq Hour where
  eq (Hour n) (Hour m) = mod n 12 == mod m 12
</code></pre>
</li>
</ol>
<p>newtypeの <code>Hour</code>とその <code>Eq</code>インスタンスは、
12を法とする整数の型を表します。
したがって、例えば1と13は等しいと見なされます。
そのインスタンスが型クラスの法則を満たしていることを証明してください。</p>
<ol>
<li>（難しい）<code>Maybe</code>、<code>Either</code>そして<code>Tuple</code>への<code>Hashable</code>インスタンスについて
型クラスの法則を証明してください。
<strong>補足</strong>：この演習にテストはありません。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、型に基づく抽象化で、
コードの再利用のための強力な形式化を可能にする<strong>型クラス</strong>を導入しました。
PureScriptの標準ライブラリから標準の型クラスを幾つか見てきました。
また、ハッシュ値を計算する型クラスに基づく独自のライブラリを定義しました。</p>
<p>この章では型クラス法則の考え方も導入しましたが、
これは抽象化に型クラスを使うコードについての性質を証明する手法でした。
型クラス法則は<strong>等式推論</strong> (equational reasoning) と呼ばれる大きな分野の一部であり、
プログラミング言語の性質と型システムはプログラムについて論理的な推論をできるようにするために使われています。
これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話題となるでしょう。</p>
<hr />
<small>
<p>この翻訳は<a href="https://github.com/aratama">aratama</a>氏による翻訳を元に改変を加えています。
同氏の翻訳リポジトリは<a href="https://github.com/aratama/purescript-book-ja"><code>aratama/purescript-book-ja</code></a>に、Webサイトは<a href="http://aratama.github.io/purescript/">実例によるPureScript</a>にあります。</p>
<p><a href="https://book.purescript.org/">原文の使用許諾</a>：</p>
<blockquote>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation Repo</a>, which uses the same license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various contributors</a>.</p>
<p>The exercises are licensed under the MIT license.</p>
</blockquote>
<p><a href="http://aratama.github.io/purescript/">aratama氏訳の使用許諾</a>：</p>
<blockquote>
<p>This book is licensed under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</p>
<p>本書は<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">クリエイティブコモンズ 表示 - 非営利 - 継承 3.0 非移植ライセンス</a>でライセンスされています。</p>
</blockquote>
<p>本翻訳の使用許諾：</p>
<p>本翻訳も原文と原翻訳にしたがい、
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>の下に提供されています。</p>
</small>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter5.ja.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter7.ja.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter5.ja.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter7.ja.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>

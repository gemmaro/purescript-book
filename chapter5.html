<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>パターン照合 - 実例によるPureScript</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">序文</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.html" class="active"><strong aria-hidden="true">5.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">実例によるPureScript</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gemmaro/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="パターン照合"><a class="header" href="#パターン照合">パターン照合</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章では、代数的データ型とパターン照合という、2つの新しい概念を導入します。
また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱います。</p>
<p>パターン照合は関数型プログラミングにおける一般的な手法であり、開発者が簡潔に関数を書けるようになります。
関数の実装を複数の場合に分解することにより、水面下の複雑なアイディアが表現されるのです。</p>
<p>代数的データ型はPureScriptの型システムの機能であり、型のある言語において同等の水準の表現力を可能にしています。
パターン照合とも密接に関連しています。</p>
<p>この章の目的は、代数的データ型やパターン照合を使用して、単純なベクターグラフィックスを記述し操作するためのライブラリを書くことです。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>この章のソースコードはファイル <code>src/Data/Picture.purs</code>で定義されています。</p>
<p><code>Data.Picture</code>モジュールは簡単な図形を表すデータ型<code>Shape</code>やその図形の集合である型<code>Picture</code>を定義します。
また、これらの型を扱うための関数もあります。</p>
<p>このモジュールでは、データ構造を畳込む関数を提供する<code>Data.Foldable</code>モジュールもインポートします。</p>
<pre><code class="language-haskell">module Data.Picture where

import Prelude
import Data.Foldable (foldl)
import Data.Number (infinity)
</code></pre>
<p><code>Data.Picture</code>モジュールは<code>Number</code>モジュールもインポートしますが、こちらは<code>as</code>キーワードを使います。</p>
<pre><code class="language-haskell">import Data.Number as Number
</code></pre>
<p>こうすると型や関数をモジュール内で使用できるようになりますが、
<code>Number.max</code>のように<em>修飾名</em>を使ったときに限定されます。
重複したインポートを避けたり、どのモジュールからインポートされたのかを明らかにするのに役立ちます。</p>
<blockquote>
<p><em>補足</em>：元のモジュールと同じモジュール名を修飾名に使用する必要はありません。
<code>import Math as M</code>などのより短い名前にできますし、かなりよく見掛けます。</p>
</blockquote>
<h2 id="単純なパターン照合"><a class="header" href="#単純なパターン照合">単純なパターン照合</a></h2>
<p>例を見ることから始めましょう。
パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになります。</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p>このアルゴリズムはユークリッドの互除法と呼ばれています。
その定義をオンラインで検索すると、恐らく上記のコードによく似た数学の方程式が見つかるでしょう。
パターン照合の利点の1つは、コードを場合分けして定義でき、数学関数の仕様に似た単純で宣言型なコードを定義できることです。</p>
<p>パターン照合を使用して書かれた関数は、条件と結果の組み合わせによって動作します。
この定義の各行は<em>選択肢</em>や<em>場合</em>と呼ばれています。
等号の左辺の式は<em>パターン</em>と呼ばれており、それぞれの場合は空白で区切られた1つ以上のパターンで構成されています。
場合の集まりは、等号の右側の式が評価され値が返される前に、引数が満たさなければならない条件を表現しています。
それぞれの場合は上からこの順番に試されていき、最初にパターンが入力に照合した場合が返り値を決定します。</p>
<p>例えば<code>gcd</code>関数は次の手順で評価されます。</p>
<ul>
<li>まず最初の場合が試されます。
第2引数がゼロの場合、関数は <code>n</code>（最初の引数）を返します。</li>
<li>そうでなければ、2番目の場合が試されます。
最初の引数がゼロの場合、関数は <code>m</code>（第2引数）を返します。</li>
<li>それ以外の場合、関数は最後の行の式を評価して返します。</li>
</ul>
<p>なお、パターンでは値を名前に束縛できます。
この例の各行では <code>n</code>や<code>m</code>という名前の何れかまたは両方に入力された値を束縛しています。
様々な種類のパターンについて学んでいくうちに、それぞれの種類のパターンが入力の引数から名前を選ぶ様々な方法に対応することがわかるでしょう。</p>
<h2 id="単純なパターン"><a class="header" href="#単純なパターン">単純なパターン</a></h2>
<p>上記のコード例では、2種類のパターンを示しました。</p>
<ul>
<li><code>Int</code>型の値が正確に一致する場合にのみ照合する、整数直値パターン</li>
<li>引数を名前に束縛する、変数パターン</li>
</ul>
<p>単純なパターンには他にも種類があります。</p>
<ul>
<li><code>Number</code>、<code>String</code>、<code>Char</code>、そして<code>Boolean</code>といった直値</li>
<li>どんな引数とも照合するが名前に束縛はしない、アンダースコア (<code>_</code>) で表されるワイルドカードパターン</li>
</ul>
<p>これらの単純なパターンを使用する実演として、もう2つの例が以下です。</p>
<pre><code class="language-haskell">fromString :: String -&gt; Boolean
fromString &quot;true&quot; = true
fromString _      = false

toString :: Boolean -&gt; String
toString true  = &quot;true&quot;
toString false = &quot;false&quot;
</code></pre>
<p>PSCiでこれらの関数を試してみてください。</p>
<h2 id="ガード"><a class="header" href="#ガード">ガード</a></h2>
<p>ユークリッドの互除法の例では、<code>m &gt; n</code>のときと<code>m &lt;= n</code>のときの2つの選択肢の間を切り替えるために<code>if .. then .. else</code>式を使いました。
こういうときには<em>ガード</em>を使うという他の選択肢もあります。</p>
<p>ガードとは、パターンにより課された制約に加えて満たされなくてはいけない真偽値の式です。
ガードを使用してユークリッドのアルゴリズムを書き直すと、次のようになります。</p>
<pre><code class="language-haskell">gcdV2 :: Int -&gt; Int -&gt; Int
gcdV2 n 0 = n
gcdV2 0 n = n
gcdV2 n m | n &gt; m     = gcdV2 (n - m) m
          | otherwise = gcdV2 n (m - n)
</code></pre>
<p>この場合、3行目ではガードを使用して、最初の引数が第2引数よりも厳密に大きいという条件を課しています。
最後の行でのガードは式<code>otherwise</code>を使っています。
これはキーワードのようにも見えますが、実際はただの<code>Prelude</code>にある普通の束縛です。</p>
<pre><code class="language-text">&gt; :type otherwise
Boolean

&gt; otherwise
true
</code></pre>
<p>この例が示すように、ガードは等号の左側に現れ、パイプ文字 (<code>|</code>) でパターンのリストと区切られています。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>（簡単）パターン照合を使用して、階乗関数<code>factorial</code>を書いてみましょう。
<em>手掛かり</em>：入力がゼロのときとゼロでないときの、2つの特殊な場合を考えてみてください。
<em>補足</em>：これは前の章の例の反復ですが、ここでは自力で書き直せるかやってみてください。</li>
<li>（普通）\( (1 + x) ^ n \)を多項式展開した式にある\( x ^ k
\)の項の係数を求める関数<code>binomial</code>を書いてください。
これは<code>n</code>要素の集合から<code>k</code>要素の部分集合を選ぶ方法の数と同じです。
数式\( n! / k! (n - k)! \)を使ってください。
ここで \( ! \) は前に書いた階乗関数です。
<em>手掛かり</em>：パターン照合を使って特殊な場合を取り扱ってください。
長い時間が掛かったりコールスタックのエラーでクラッシュしたりしたら、特殊な場合を更に追加してみてください。</li>
<li>（普通）<a href="https://en.wikipedia.org/wiki/Pascal%27s_rule"><em>パスカルの法則</em></a>を使って前の演習と同じ2項係数を計算する関数<code>pascal</code>を書いてください。</li>
</ol>
<h2 id="配列パターン"><a class="header" href="#配列パターン">配列パターン</a></h2>
<p><em>配列直値パターン</em>は、固定長の配列に対して照合する方法を提供します。
例えば空の配列であるか判定する関数<code>isEmpty</code>を書きたいとします。
最初の選択肢に空の配列パターン (<code>[]</code>) を用いるとこれを実現できます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty [] = true
isEmpty _ = false
</code></pre>
<p>次の関数では、長さ5の配列と照合し、配列の5つの要素をそれぞれ違った方法で束縛しています。</p>
<pre><code class="language-haskell">takeFive :: Array Int -&gt; Int
takeFive [0, 1, a, b, _] = a * b
takeFive _ = 0
</code></pre>
<p>最初のパターンは、第1要素と第2要素がそれぞれ0と1であるような、5要素の配列にのみ照合します。
その場合、関数は第3要素と第4要素の積を返します。
それ以外の場合は、関数は0を返します。
例えばPSCiで試してみると次のようになります。</p>
<pre><code class="language-text">&gt; :paste
… takeFive [0, 1, a, b, _] = a * b
… takeFive _ = 0
… ^D

&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0
</code></pre>
<p>配列の直値パターンでは、固定長の配列と一致させることはできます。
しかしPureScriptは不特定の長さの配列を照合させる手段は全く提供して<em>いません</em>。
そのような類の方法で不変な配列を分解すると、実行速度が低下する可能性があるためです。
このように照合できるデータ構造が必要な場合は、<code>Data.List</code>を使うことをお勧めします。
その他の操作について、より優れた漸近性能を提供するデータ構造も存在します。</p>
<h2 id="レコードパターンと行多相"><a class="header" href="#レコードパターンと行多相">レコードパターンと行多相</a></h2>
<p><em>レコードパターン</em>は（ご想像の通り）レコードに照合します。</p>
<p>レコードパターンはレコード直値にほぼ見た目が似ていますが、コロンの右に値を置くのではなく、それぞれのフィールドで束縛子を指定します。</p>
<p>例えば次のパターンは<code>first</code>と<code>last</code>という名前のフィールドが含まれた任意のレコードに照合し、これらのフィールドの値はそれぞれ <code>x</code>と
<code>y</code>という名前に束縛されます。</p>
<pre><code class="language-haskell">showPerson :: { first :: String, last :: String } -&gt; String
showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x
</code></pre>
<p>レコードパターンはPureScriptの型システムの興味深い機能である<em>行多相</em>の良い例となっています。
もし上の<code>showPerson</code>を型シグネチャなしで定義していたとすると、この型はどのように推論されるのでしょうか。
面白いことに、推論される型は上で与えた型とは同じではありません。</p>
<pre><code class="language-text">&gt; showPerson { first: x, last: y } = y &lt;&gt; &quot;, &quot; &lt;&gt; x

&gt; :type showPerson
forall (r :: Row Type). { first :: String, last :: String | r } -&gt; String
</code></pre>
<p>この型変数 <code>r</code>は何でしょうか。
PSCiで<code>showPerson</code>を使ってみると、面白いことがわかります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;
</code></pre>
<p>レコードにそれ以外のフィールドが追加されていても、<code>showPerson</code>関数はそのまま動作するのです。
レコードに少なくとも型が<code>String</code>であるようなフィールド<code>first</code>と<code>last</code>が含まれていれば、関数適用は正しく型付けされます。
しかし、フィールドが<em>不足</em>していると、<code>showPerson</code>の呼び出しは<em>不正</em>となります。</p>
<pre><code class="language-text">&gt; showPerson { first: &quot;Phil&quot; }

Type of expression lacks required label &quot;last&quot;
</code></pre>
<p><code>showPerson</code>の新しい型シグネチャを読むと、「<code>String</code>な<code>first</code>と<code>last</code>フィールド <em>と他のフィールドを何でも</em>
持つあらゆるレコードを取り、<code>String</code>を返す」となります。なお、この挙動は元の<code>showPerson</code>のものとは異なります。行変数<code>r</code>がなければ<code>showPerson</code>は
<em>厳密に</em> <code>first</code>と<code>last</code>フィールドしかないレコードのみを受け付けます。</p>
<p>なお、次のように書くこともできます。</p>
<pre><code class="language-haskell">&gt; showPerson p = p.last &lt;&gt; &quot;, &quot; &lt;&gt; p.first
</code></pre>
<p>そしてPSCiは同じ型を推論することでしょう。</p>
<h2 id="レコード同名利用"><a class="header" href="#レコード同名利用">レコード同名利用</a></h2>
<p><code>showPerson</code>関数は引数内のレコードと照合し、<code>first</code>と<code>last</code>フィールドを<code>x</code>と<code>y</code>という名前の値に束縛していたのでした。
別の方法として、フィールド名自体を再利用してこのような類のパターン照合を次のように単純化できます。</p>
<pre><code class="language-haskell">showPersonV2 :: { first :: String, last :: String } -&gt; String
showPersonV2 { first, last } = last &lt;&gt; &quot;, &quot; &lt;&gt; first
</code></pre>
<p>ここでは、プロパティの名前のみを指定し、名前に導入したい値を指定する必要はありません。これは <em>レコード同名利用</em> (record pun)
と呼ばれます。</p>
<p>レコード同名利用はレコードの<em>構築</em>にも使用できます。
例えば、スコープに <code>first</code>と <code>last</code>という名前の値があれば、<code>{ first, last }</code>を使って人物レコードを作ることができます。</p>
<pre><code class="language-haskell">unknownPerson :: { first :: String, last :: String }
unknownPerson = { first, last }
  where
    first = &quot;Jane&quot;
    last  = &quot;Doe&quot;
</code></pre>
<p>こうすると、状況によってはコードの可読性が向上します。</p>
<h2 id="入れ子になったパターン"><a class="header" href="#入れ子になったパターン">入れ子になったパターン</a></h2>
<p>配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大きなパターンを構築しています。
これまでのほとんどの例では配列パターンとレコードパターンの内部で単純なパターンを使用していました。
しかし特筆すべきこととして、パターンは自由に<em>入れ子</em>にできます。
これにより潜在的に複雑なデータ型についての条件を使って関数を定義できます。</p>
<p>例えばこのコードは2つのレコードパターンを組み合わせています。</p>
<pre><code class="language-haskell">type Address = { street :: String, city :: String }

type Person = { name :: String, address :: Address }

livesInLA :: Person -&gt; Boolean
livesInLA { address: { city: &quot;Los Angeles&quot; } } = true
livesInLA _ = false
</code></pre>
<h2 id="名前付きパターン"><a class="header" href="#名前付きパターン">名前付きパターン</a></h2>
<p>入れ子のパターンを使う場合、パターンには<em>名前を付け</em>てスコープに名前を追加で持ち込むことができます。
任意のパターンに名前を付けるには、 <code>@</code>記号を使います。</p>
<p>例えば次の関数は2要素配列を整列するもので、2つの要素に名前を付けていますが、配列自身にも名前を付けています。</p>
<pre><code class="language-haskell">sortPair :: Array Int -&gt; Array Int
sortPair arr@[x, y]
  | x &lt;= y = arr
  | otherwise = [y, x]
sortPair arr = arr
</code></pre>
<p>このようにすれば対が既に整列されているときに新しい配列を割り当てなくて済みます。
なお、もし入力の配列が<em>厳密に</em>2つの要素を含んでいなければ、たとえ整列されていなかったとしても、この関数は単に元のまま変えずに返します。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（簡単）レコードパターンを使って、2つの <code>Person</code>レコードが同じ都市にいるか調べる関数 <code>sameCity</code>を定義してみましょう。</li>
<li>（普通）行多相を考慮すると、 <code>sameCity</code>関数の最も一般的な型は何でしょうか。
先ほど定義した<code>livesInLA</code>関数についてはどうでしょうか。
<em>補足</em>：この演習にテストはありません。</li>
<li>（普通）配列直値パターンを使って、1要素の配列の唯一のメンバーを抽出する関数<code>fromSingleton</code>を書いてみましょう。
1要素だけを持つ配列でない場合、関数は与えられた既定値を返します。
この関数は<code>forall a. a -&gt; Array a -&gt; a</code>という型を持ちます。</li>
</ol>
<h2 id="case式"><a class="header" href="#case式">case式</a></h2>
<p>パターンが現れるのは最上位にある関数宣言だけではありません。
<code>case</code>式を使う計算中の途中の値に対してパターン照合を使えます。
case式には無名関数に似た便利さがあります。
関数に名前を与えることがいつも望ましいわけではないように、パターンを使いたいためだけに関数に名前をつけるようなことを避けられるようになります。</p>
<p>例を示しましょう。
次の関数は、配列の「最長ゼロ末尾」（和がゼロであるような、最も長い配列の末尾）を計算します。</p>
<pre><code class="language-haskell">import Data.Array (tail)
import Data.Foldable (sum)
import Data.Maybe (fromMaybe)

lzs :: Array Int -&gt; Array Int
lzs [] = []
lzs xs = case sum xs of
           0 -&gt; xs
           _ -&gt; lzs (fromMaybe [] $ tail xs)
</code></pre>
<p>以下は一例です。</p>
<pre><code class="language-text">&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]
</code></pre>
<p>この関数は場合毎の分析によって動作します。
もし配列が空なら、唯一の選択肢は空の配列を返すことです。
配列が空でない場合は、更に2つの場合に分けるためにまず<code>case</code>式を使用します。
配列の合計がゼロであれば、配列全体を返します。
そうでなければ、配列の残りに対して再帰します。</p>
<h2 id="パターン照合の失敗と部分関数"><a class="header" href="#パターン照合の失敗と部分関数">パターン照合の失敗と部分関数</a></h2>
<p>case式のパターンを順番に照合していって、どの選択肢の場合も入力が照合しなかった時はどうなるのでしょう。
この場合、<em>パターン照合失敗</em>によって、case式は実行時に失敗します。</p>
<p>簡単な例でこの動作を見てみましょう。</p>
<pre><code class="language-haskell">import Partial.Unsafe (unsafePartial)

partialFunction :: Boolean -&gt; Boolean
partialFunction = unsafePartial \true -&gt; true
</code></pre>
<p>この関数は単一の場合しか含んでいません。
そしてその場合は単一の入力である<code>true</code>にのみ照合します。
このファイルをコンパイルしてPSCiでそれ以外の値を与えて試すと実行時エラーが発生します。</p>
<pre><code class="language-text">&gt; partialFunction false

Failed pattern match
</code></pre>
<p>どんな入力の組み合わせに対しても値を返すような関数は<em>全関数</em>と呼ばれ、そうでない関数は<em>部分的</em>であると呼ばれます。</p>
<p>一般的には、可能な限り全関数として定義したほうが良いと考えられています。
もし関数が何らかの妥当な入力の集合について結果を返さないことがわかっているなら、大抵は失敗であることを示すことができる値を返すほうがよいでしょう。
例えば何らかの<code>a</code>についての型<code>Maybe a</code>で、妥当な結果を返せないときは<code>Nothing</code>を使います。
この方法なら、型安全な方法で値の有無を示すことができます。</p>
<p>PureScriptコンパイラは、パターン照合が不完全であるために関数が全関数ではないことが検出されると、エラーを出します。
<code>unsafePartial</code>関数を使うとこうしたエラーを抑制できます（ただしその部分関数が安全だと言い切れるなら）。
もし上記の<code>unsafePartial</code>関数の呼び出しを取り除くと、コンパイラは次のエラーを出します。</p>
<pre><code class="language-text">A case expression could not be determined to cover all inputs.
The following additional cases are required to cover all inputs:

  false
</code></pre>
<p>これは値<code>false</code>が、定義されたどのパターンとも一致しないことを示しています。
一般にこれらの警告には、複数の不一致な場合が含まれることがあります。</p>
<p>上記の型シグネチャも省略した場合は、次のようになります。</p>
<pre><code class="language-haskell">partialFunction true = true
</code></pre>
<p>このとき、PSCiは興味深い型を推論します。</p>
<pre><code class="language-text">&gt; :type partialFunction

Partial =&gt; Boolean -&gt; Boolean
</code></pre>
<p>本書では以降、<code>=&gt;</code>記号が絡む（<em>型クラス</em>に関連する）型をもっと見ていきます。
しかし現時点では、PureScriptは型システムを使って部分関数を把握していることと、安全な場合に型検証器に明示する必要があることを確認すれば充分です。</p>
<p>コンパイラは、<em>冗長</em>な場合を検出したとき（つまり、その場合より前の方に定義された場合にのみ一致するとき）などにも警告を出します。</p>
<pre><code class="language-haskell">redundantCase :: Boolean -&gt; Boolean
redundantCase true = true
redundantCase false = false
redundantCase false = false
</code></pre>
<p>このとき、最後の場合は冗長であると正しく検出されます。</p>
<pre><code class="language-text">A case expression contains unreachable cases:

  false
</code></pre>
<blockquote>
<p><em>補足</em>：PSCiは警告を表示しません。
そのため、この例を再現するには、この関数をファイルとして保存し、<code>spago build</code>を使ってコンパイルします。</p>
</blockquote>
<h2 id="代数的データ型"><a class="header" href="#代数的データ型">代数的データ型</a></h2>
<p>この節では <em>代数的データ型</em> (algebraic data type, <em>ADT</em>)
と呼ばれる、PureScriptの型システムの機能を導入します。この機能はパターン照合と地続きの関係があります。</p>
<p>しかしまずは切り口となる例について考えていきます。この例では単純なベクターグラフィックスライブラリの実装というこの章の課題を解決する基礎を与えます。</p>
<p>直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとします。
オブジェクト指向言語では、恐らくインターフェースもしくは抽象クラス
<code>Shape</code>を定義し、使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。</p>
<p>しかし、この方針は大きな欠点を1つ抱えています。
<code>Shape</code>を抽象的に扱うためには、実行したいと思う可能性のある全ての操作を事前に把握し、<code>Shape</code>インターフェースに定義する必要があるのです。
モジュール性を壊さずに新しい操作を追加することが難しくなります。</p>
<p>もし図形の種類が事前にわかっているなら、代数的データ型はこうした問題を解決する型安全な方法を提供します。
モジュール性のある方法で <code>Shape</code>に新たな操作を定義しつつ、型安全性を維持できます。</p>
<p>代数的データ型としてどのように<code>Shape</code>が表現されるかを次に示します。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String

type Point =
  { x :: Number
  , y :: Number
  }
</code></pre>
<p>この宣言では<code>Shape</code>をそれぞれの構築子の直和として定義しており、各構築子では含まれるデータを指定します。
<code>Shape</code>は、中央 <code>Point</code>と半径（数値）を持つ <code>Circle</code>か、<code>Rectangle</code>、 <code>Line</code>、 <code>Text</code>の何れかです。
他に<code>Shape</code>型の値を構築する方法はありません。</p>
<p>代数的データ型 (algebraic data type; ADT)
の定義はキーワード<code>data</code>から始まり、それに新しい型の名前と任意個の型引数が続きます。
その型の構築子（これを<em>データ構築子</em>と言います）は等号の後に定義され、パイプ文字 (<code>|</code>) で区切られます。
ADTの構築子が持つデータは原始型に限りません。
構築子にはレコード、配列、また他のADTさえも含められます。</p>
<p>それではPureScriptの標準ライブラリから別の例を見てみましょう。
省略可能な値を定義するのに使われる <code>Maybe</code>型を本書の冒頭で扱いました。
<code>maybe</code>パッケージでは <code>Maybe</code>を次のように定義しています。</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>この例では型引数 <code>a</code>の使用方法を示しています。パイプ文字を「または」と読むことにすると、この定義は「<code>Maybe a</code>型の値は、無い
(<code>Nothing</code>) か、ただの (<code>Just</code>) 型 <code>a</code>の値だ」とほぼ英語のように読むことができます。</p>
<p>なお、データ定義のどこにも構文<code>forall a</code>を使っていません。
<code>forall</code>構文は関数には必須ですが、<code>data</code>によるADTや<code>type</code>での型別称を定義するときは使われません。</p>
<p>データ構築子は再帰的なデータ構造を定義するためにも使用できます。更に例を挙げると、要素が型
<code>a</code>の単方向連結リストのデータ型の定義はこのようになります。</p>
<pre><code class="language-haskell">data List a = Nil | Cons a (List a)
</code></pre>
<p>この例は <code>lists</code>パッケージから持ってきました。
ここで <code>Nil</code>構築子は空のリストを表しており、<code>Cons</code>は先頭となる要素と尾鰭から空でないリストを作成するために使われます。
<code>Cons</code>の2つ目のフィールドでデータ型 <code>List a</code>を使用しており、再帰的なデータ型になっていることに注目してください。</p>
<h2 id="adtの使用"><a class="header" href="#adtの使用">ADTの使用</a></h2>
<p>代数的データ型の構築子を使用して値を構築するのはとても簡単です。
対応する構築子に含まれるデータに応じた引数を用意し、その構築子を単に関数のように適用するだけです。</p>
<p>例えば、上で定義した <code>Line</code>構築子は2つの <code>Point</code>を必要としていますので、<code>Line</code>構築子を使って <code>Shape</code>を構築するには、型
<code>Point</code>の2つの引数を与えなければなりません。</p>
<pre><code class="language-haskell">exampleLine :: Shape
exampleLine = Line p1 p2
  where
    p1 :: Point
    p1 = { x: 0.0, y: 0.0 }

    p2 :: Point
    p2 = { x: 100.0, y: 50.0 }
</code></pre>
<p>さて、代数的データ型で値を構築することは簡単ですが、これをどうやって使ったらよいのでしょうか。
ここで代数的データ型とパターン照合との重要な接点が見えてきます。
代数的データ型の値を消費する唯一の方法は構築子に照合するパターンを使うことです。</p>
<p>例を見てみましょう。
<code>Shape</code>を <code>String</code>に変換したいとします。
<code>Shape</code>を構築するのにどの構築子が使用されたかを調べるには、パターン照合を使用しなければなりません。
これには次のようにします。</p>
<pre><code class="language-haskell">showShape :: Shape -&gt; String
showShape (Circle c r) =
  &quot;Circle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, radius: &quot; &lt;&gt; show r &lt;&gt; &quot;]&quot;
showShape (Rectangle c w h) =
  &quot;Rectangle [center: &quot; &lt;&gt; showPoint c &lt;&gt; &quot;, width: &quot; &lt;&gt; show w &lt;&gt; &quot;, height: &quot; &lt;&gt; show h &lt;&gt; &quot;]&quot;
showShape (Line start end) =
  &quot;Line [start: &quot; &lt;&gt; showPoint start &lt;&gt; &quot;, end: &quot; &lt;&gt; showPoint end &lt;&gt; &quot;]&quot;
showShape (Text loc text) =
  &quot;Text [location: &quot; &lt;&gt; showPoint loc &lt;&gt; &quot;, text: &quot; &lt;&gt; show text &lt;&gt; &quot;]&quot;

showPoint :: Point -&gt; String
showPoint { x, y } =
  &quot;(&quot; &lt;&gt; show x &lt;&gt; &quot;, &quot; &lt;&gt; show y &lt;&gt; &quot;)&quot;
</code></pre>
<p>各構築子はパターンとして使用でき、構築子への引数はそのパターンで束縛できます。
<code>showShape</code>の最初の場合を考えてみましょう。
もし <code>Shape</code>が <code>Circle</code>構築子に照合した場合、2つの変数パターン <code>c</code>と
<code>r</code>を使って<code>Circle</code>の引数（中心と半径）がスコープに導入されます。
その他の場合も同様です。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>（簡単）<code>Circle</code>（型は<code>Shape</code>）を構築する関数<code>circleAtOrigin</code>を書いてください。
中心は原点にあり、半径は<code>10.0</code>です。</li>
<li>（普通）原点を中心として<code>Shape</code>の大きさを<code>2.0</code>倍に拡大する関数<code>doubleScaleAndCenter</code>を書いてみましょう。</li>
<li>（普通）<code>Shape</code>からテキストを抽出する関数<code>shapeText</code>を書いてください。
この関数は<code>Maybe String</code>を返しますが、もし入力が<code>Text</code>を使用して構築されたのでなければ、返り値には<code>Nothing</code>構築子を使ってください。</li>
</ol>
<h2 id="newtype"><a class="header" href="#newtype">newtype</a></h2>
<p>代数的データ型の特殊な場合として、 <em>newtype</em> と呼ばれるものがあります。newtypeはキーワード <code>data</code>の代わりにキーワード
<code>newtype</code>を使用して導入します。</p>
<p>newtype宣言では<em>過不足なく1つだけの</em>構築子を定義しなければならず、その構築子は<em>過不足なく1つだけの</em>引数を取る必要があります。
つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。
実際、newtypeの値は、元の型と同じ実行時表現を持ってるので、実行時性能のオーバーヘッドがありません。
しかし、これらは型システムの観点から区別されます。
型安全性に追加の層を与えるのです。</p>
<p>例として、ボルト、アンペア、オームのような単位を表現するために、<code>Number</code>の型レベルの別名を定義したくなる場合があるかもしれません。</p>
<pre><code class="language-haskell">newtype Volt = Volt Number
newtype Ohm = Ohm Number
newtype Amp = Amp Number
</code></pre>
<p>それからこれらの型を使う関数と値を定義します。</p>
<pre><code class="language-haskell">calculateCurrent :: Volt -&gt; Ohm -&gt; Amp
calculateCurrent (Volt v) (Ohm r) = Amp (v / r)

battery :: Volt
battery = Volt 1.5

lightbulb :: Ohm
lightbulb = Ohm 500.0

current :: Amp
current = calculateCurrent battery lightbulb
</code></pre>
<p>これによりつまらないミスを防ぐことができます。
例えば電源<em>なし</em>に<em>2つ</em>の電球により生み出される電流を計算しようとするなどです。</p>
<pre><code class="language-haskell">current :: Amp
current = calculateCurrent lightbulb lightbulb
{-
TypesDoNotUnify:
  current = calculateCurrent lightbulb lightbulb
                             ^^^^^^^^^
  Could not match type
    Ohm
  with type
    Volt
-}
</code></pre>
<p>もし<code>newtype</code>なしに単なる<code>Number</code>を使っていたら、コンパイラはこのミスを捕捉できません。</p>
<pre><code class="language-haskell">-- これもコンパイルできますが、型安全ではありません。
calculateCurrent :: Number -&gt; Number -&gt; Number
calculateCurrent v r = v / r

battery :: Number
battery = 1.5

lightbulb :: Number
lightbulb = 500.0

current :: Number
current = calculateCurrent lightbulb lightbulb -- 捕捉されないミス
</code></pre>
<p>なお、newtypeは単一の構築子しかとれず、構築子は単一の値でなくてはなりませんが、newtypeは任意の数の型変数を取ることが<em>できます</em>。
例えば以下のnewtypeは妥当な定義です（<code>err</code>と<code>a</code>は型変数で、<code>CouldError</code>構築子は型<code>Either err a</code>の<em>単一</em>の値を期待します）。</p>
<pre><code class="language-Haskell">newtype CouldError err a = CouldError (Either err a)
</code></pre>
<p>また、newtypeの構築子はよくnewtype自身と同じ名前を持つことがあります。
ただこれは必須ではありません。
例えば別個の名前であっても正しいものです。</p>
<pre><code class="language-haskell">newtype Coulomb = MakeCoulomb Number
</code></pre>
<p>この場合<code>Coulomb</code>は（引数ゼロの）<em>型構築子</em>で、<code>MakeCoulomb</code>は<em>データ構築子</em>です。
これらの構築子は異なる名前空間に属しており、<code>Volt</code>の例でそうだったように、名前には一意性があります。
これは全てのADTについて言えることです。
なお、型構築子とデータ構築子には異なる名前を付けられますが、実際には同じ名前を共有するのが普通です。
前述の<code>Amp</code>と<code>Volt</code>の場合がこれです。</p>
<p>newtypeの別の応用は、実行時表現を変えることなく、既存の型に異なる <em>挙動</em> を加えることです。その利用例については次章で <em>型クラス</em>
をお話しするときに押さえます。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>（簡単）<code>Watt</code>を<code>Number</code>の<code>newtype</code>として定義してください。それからこの新しい<code>Watt</code>型と前述の<code>Amp</code>と<code>Volt</code>の定義を使って<code>calculateWattage</code>関数を定義してください。</li>
</ol>
<pre><code class="language-haskell">calculateWattage :: Amp -&gt; Volt -&gt; Watt
</code></pre>
<p><code>Watt</code>中のワット数は与えられた<code>Amp</code>中の電流と与えられた<code>Volt</code>の電圧の積で計算できます。</p>
<h2 id="ベクターグラフィックスライブラリ"><a class="header" href="#ベクターグラフィックスライブラリ">ベクターグラフィックスライブラリ</a></h2>
<p>これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライブラリを作成していきましょう。</p>
<p><code>Picture</code>という型同義語を定義しておきます。
これはただの<code>Shape</code>の配列です。</p>
<pre><code class="language-haskell">type Picture = Array Shape
</code></pre>
<p>不具合を修正していると<code>Picture</code>を<code>String</code>として表示できるようにしたくなることもあるでしょう。
これはパターン照合を使用して定義された<code>showPicture</code>関数でできます。</p>
<pre><code class="language-haskell">showPicture :: Picture -&gt; Array String
showPicture = map showShape
</code></pre>
<p>試してみましょう。
モジュールを <code>spago build</code>でコンパイルし、 <code>spago repl</code>でPSCiを開きます。</p>
<pre><code class="language-text">$ spago build
$ spago repl

&gt; import Data.Picture

&gt; showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]

[&quot;Line [start: (0.0, 0.0), end: (1.0, 1.0)]&quot;]
</code></pre>
<h2 id="外接矩形の算出"><a class="header" href="#外接矩形の算出">外接矩形の算出</a></h2>
<p>このモジュールのコード例には、 <code>Picture</code>の最小外接矩形を計算する関数 <code>bounds</code>が含まれています。</p>
<p><code>Bounds</code>型は外接矩形を定義します。</p>
<pre><code class="language-haskell">type Bounds =
  { top    :: Number
  , left   :: Number
  , bottom :: Number
  , right  :: Number
  }
</code></pre>
<p><code>Picture</code>内の <code>Shape</code>の配列を走査し、最小の外接矩形を累算するため、<code>bounds</code>には <code>Data.Foldable</code>の
<code>foldl</code>関数を使用しています。</p>
<pre><code class="language-haskell">bounds :: Picture -&gt; Bounds
bounds = foldl combine emptyBounds
  where
  combine :: Bounds -&gt; Shape -&gt; Bounds
  combine b shape = union (shapeBounds shape) b
</code></pre>
<p>基底の場合では、空の
<code>Picture</code>の最小外接矩形を求める必要がありますが、<code>emptyBounds</code>で定義される空の外接矩形がその条件を満たしています。</p>
<p>累算関数<code>combine</code>は<code>where</code>ブロックで定義されています。
<code>combine</code>は<code>foldl</code>の再帰呼び出しで計算された外接矩形と、配列内の次の
<code>Shape</code>を引数に取り、ユーザ定義の演算子<code>union</code>を使って2つの外接矩形の和を計算しています。
<code>shapeBounds</code>関数は、パターン照合を使用して、単一の図形の外接矩形を計算します。</p>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>（普通）ベクターグラフィックライブラリを拡張し、<code>Shape</code>の面積を計算する新しい操作 <code>area</code>を追加してください。
この演習の目的上は、線分やテキストの面積は0であるものとしてください。</li>
<li>（難しい）<code>Shape</code>型を新しいデータ構築子 <code>Clipped</code>で拡張してください。
<code>Clipped</code>は他の <code>Picture</code>を矩形に切り抜きます。
切り抜かれた図形の境界を計算できるよう、<code>shapeBounds</code>関数を拡張してください。
なお、これにより<code>Shape</code>は再帰的なデータ型になります。
<em>手掛かり</em> ：コンパイラは必要に応じて他の関数を拡張するのに付き添ってくれるでしょう。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、関数型プログラミングから基本的ながら強力なテクニックであるパターン照合を扱いました。複雑なデータ構造の一部分と照合するために、簡単なパターンの使い方だけではなく、配列パターンやレコードパターンを使った深さのあるデータ構造の一部分との照合方法を見てきました。</p>
<p>また、この章ではパターン照合に密接に関連する代数的データ型も紹介しました。
代数的データ型のおかげでデータ構造を簡潔に記述でき、新たな操作でデータ型を拡張する上で、モジュール性のある方法が得られるのでした。</p>
<p>最後に<em>行多相</em>を扱いました。
これは強力な抽象化をする型であり、これにより多くの既存のJavaScript関数に型を与えられます。</p>
<p>本書では今後も代数的データ型とパターン照合をいろんなところで使用するので、今のうちにこれらに習熟しておくと後で実を結ぶことでしょう。これ以外にも独自の代数的データ型を作成し、パターン照合を使用してそれらの型を使う関数を書いてみてください。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

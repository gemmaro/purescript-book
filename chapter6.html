<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>型クラス - 実例によるPureScript</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">序文</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.html" class="active"><strong aria-hidden="true">6.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">実例によるPureScript</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gemmaro/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="型クラス"><a class="header" href="#型クラス">型クラス</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章では、PureScriptの型システムによって可能になる強力な抽象化の手法である、型クラスを導入します。</p>
<p>この章ではデータ構造をハッシュ化するためのライブラリを題材に説明していきます。データ自身の構造について直接考えることなく複雑な構造のデータのハッシュ値を求める上で、型クラスの仕組みがどのようにして働くのかを見ていきます。</p>
<p>また、PureScriptのPreludeや標準ライブラリに含まれる、標準的な型クラスも見ていきます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大きく依存しているので、これらのクラスに慣れておくと役に立つでしょう。</p>
<p>オブジェクト指向の方面から入って来た方は、「クラス」という単語がそれまで馴染みのあるものとこの文脈とでは <em>かなり</em>
異なるものを意味していることに注意してください。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>この章のソースコードは、ファイル <code>src/data/Hashable.purs</code>で定義されています。</p>
<p>このプロジェクトには以下の依存関係があります。</p>
<ul>
<li><code>maybe</code>: オプショナルな値を表す <code>Maybe</code>データ型が定義されています。</li>
<li><code>tuples</code>: 値の組を表す <code>Tuple</code>データ型が定義されています。</li>
<li><code>either</code>: 非交和を表す <code>Either</code>データ型が定義されています。</li>
<li><code>strings</code>: 文字列を操作する関数が定義されています。</li>
<li><code>functions</code>: PureScriptの関数を定義するための補助関数が定義されています。</li>
</ul>
<p>モジュール <code>Data.Hashable</code>では、これらのパッケージによって提供されるモジュールの幾つかをインポートしています。</p>
<h2 id="見せて"><a class="header" href="#見せて">見せて！</a></h2>
<p>型クラスの最初の簡単な例は、既に何回か見たことがある関数で提供されています。
<code>show</code>は何らかの値を取り、文字列として表示する関数です。</p>
<p><code>show</code>は <code>Prelude</code>モジュールの <code>Show</code>と呼ばれる型クラスで次のように定義されています。</p>
<pre><code class="language-haskell">class Show a where
  show :: a -&gt; String
</code></pre>
<p>このコードでは、型変数 <code>a</code>でパラメータ化された、<code>Show</code>という新しい <em>型クラス</em> (type class) を宣言しています。</p>
<p>型クラス <em>インスタンス</em> には、型クラスで定義された関数の、その型に特殊化された実装が含まれています。</p>
<p>例えば、Preludeにある <code>Boolean</code>値に対する <code>Show</code>型クラスインスタンスの定義は次の通りです。</p>
<pre><code class="language-haskell">instance Show Boolean where
  show true = &quot;true&quot;
  show false = &quot;false&quot;
</code></pre>
<p>このコードは <code>showBool​​ean</code>という名前の型クラスのインスタンスを宣言します。
PureScriptでは、生成されたJavaScriptの可読性を良くするために、型クラスインスタンスに名前をつけます。このとき、
<em><code>Boolean</code>型は <code>Show</code>型クラスに属している</em> といいます。</p>
<p>PSCiで、いろいろな型の値を<code>Show</code>型クラスを使って表示してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; show true
&quot;true&quot;

&gt; show 1.0
&quot;1.0&quot;

&gt; show &quot;Hello World&quot;
&quot;\&quot;Hello World\&quot;&quot;
</code></pre>
<p>この例ではさまざまなプリミティブ型の値を <code>show</code>しましたが、もっと複雑な型を持つ値も<code>show</code>できます。</p>
<pre><code class="language-text">&gt; import Data.Tuple

&gt; show (Tuple 1 true)
&quot;(Tuple 1 true)&quot;

&gt; import Data.Maybe

&gt; show (Just &quot;testing&quot;)
&quot;(Just \&quot;testing\&quot;)&quot;
</code></pre>
<p><code>show</code>の出力は、REPLに（あるいは<code>.purs</code>ファイルに）もう一度貼り付ければ、表示されたものを再作成できるような文字列であるべきです。以下では<code>logShow</code>を使っていますが、これは単に<code>show</code>と<code>log</code>を順に呼び出して、引用符なしに文字列を表示するものです。<code>unit</code>の表示は無視してください。第8章で<code>Effect</code>を調べるときに押さえます。<code>Effect</code>を持つものには<code>log</code>などがあります。</p>
<pre><code class="language-text">&gt; import Effect.Console

&gt; logShow (Tuple 1 true)
(Tuple 1 true)
unit

&gt; logShow (Just &quot;testing&quot;)
(Just &quot;testing&quot;)
unit
</code></pre>
<p>型 <code>Data.Either</code>の値を表示しようとすると、興味深いエラーメッセージが表示されます。</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; show (Left 10)

The inferred type

    forall a. Show a =&gt; String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでの問題は <code>show</code>しようとしている型に対する
<code>Show</code>インスタンスが存在しないということではなく、PSCiがこの型を推論できなかったということです。このエラーメッセージで <em>未知の型</em>
<code>a</code>と表示されているのがそれです。</p>
<p><code>::</code>演算子を使って式に対して型注釈を加えると、PSCiが正しい型クラスインスタンスを選ぶことができるようになります。</p>
<pre><code class="language-text">&gt; show (Left 10 :: Either Int String)
&quot;(Left 10)&quot;
</code></pre>
<p><code>Show</code>インスタンスを全く持っていない型もあります。
関数の型 <code>-&gt;</code>がその一例です。
<code>Int</code>から <code>Int</code>への関数を <code>show</code>しようとすると、型検証器によってその旨のエラーメッセージが表示されます。</p>
<pre><code class="language-text">&gt; import Prelude
&gt; show $ \n -&gt; n + 1

No type class instance was found for

  Data.Show.Show (Int -&gt; Int)
</code></pre>
<p>型クラスインスタンスは次の2つのうち何れかの形で定義されます。
型クラスが定義されている同じモジュールで定義するか、型クラスに「属して」いる型と同じモジュールで定義するかです。
これらとは別の場所で定義されるインスタンスは<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances">「孤立インスタンス」</a>と呼ばれ、PureScriptコンパイラでは許されていません。
この章の演習の幾つかでは、その型の型クラスインスタンスを定義できるように、型の定義を自分の<code>MySolutions</code>モジュールに複製する必要があります。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Show</code>インスタンスを<code>Point</code>に定義してください。
前の章の<code>showPoint</code>関数と同じ出力に一致するようにしてください。
<em>補足</em>：<code>Point</code>はここでは（<code>type</code>同義語ではなく）<code>newtype</code>です。
そのため<code>show</code>の仕方を変えられます。
こうでもしないとレコードへの既定の<code>Show</code>インスタンスから逃れられません。</p>
<pre><code class="language-haskell">newtype Point
  = Point
  { x :: Number
  , y :: Number
  }
</code></pre>
</li>
</ol>
<h2 id="よく見かける型クラス"><a class="header" href="#よく見かける型クラス">よく見かける型クラス</a></h2>
<p>この節では、Preludeや標準ライブラリで定義されている標準的な型クラスを幾つか見ていきましょう。
これらの型クラスはPureScript特有の抽象化をする上で多くのよくあるパターンの基礎を形成しています。
そのため、これらの関数の基本についてよく理解しておくことを強くお勧めします。</p>
<h3 id="eq"><a class="header" href="#eq">Eq</a></h3>
<p><code>Eq</code>型クラスは、2つの値が等しいかどうかを調べる<code>eq</code>関数を定義しています。
等値演算子 (<code>==</code>) は<code>eq</code>の別名にすぎません。</p>
<pre><code class="language-haskell">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>なお、異なる型の2つの値を比較しても意味がありませんから、等しいにせよ等しくないにせよ2つの引数は同じ型を持つ必要があります。</p>
<p>PSCiで <code>Eq</code>型クラスを試してみましょう。</p>
<pre><code class="language-text">&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true
</code></pre>
<h3 id="ord"><a class="header" href="#ord">Ord</a></h3>
<p><code>Ord</code>型クラスは順序付け可能な型に対して2つの値を比較する <code>compare</code>関数を定義します。比較演算子 <code>&lt;</code>、 <code>&gt;</code>と、その仲間の厳密な大小比較ではない<code>&lt;=</code>、 <code>&gt;=</code>も、<code>compare</code>を使って定義されます。</p>
<p><em>補足</em>：以下の例ではクラスシグネチャに<code>&lt;=</code>が含まれています。
この文脈での<code>&lt;=</code>の使われ方はEqがOrdの上位クラスであり、比較演算子としての<code>&lt;=</code>の用途を表す意図はありません。
後述の<a href="#%E4%B8%8A%E4%BD%8D%E3%82%AF%E3%83%A9%E3%82%B9">上位クラス</a>の節を参照してください。</p>
<pre><code class="language-haskell">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p><code>compare</code>関数は2つの値を比較して <code>Ordering</code>の3つの値のうち何れかを返します。</p>
<ul>
<li><code>LT</code>- 最初の引数が2番目の値より小さいとき</li>
<li><code>EQ</code>- 最初の引数が2番目の値と等しい（または比較できない）とき</li>
<li><code>GT</code>- 最初の引数が2番目の値より大きいとき</li>
</ul>
<p>ここでも<code>compare</code>関数についてPSCiで試してみましょう。</p>
<pre><code class="language-text">&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<p><code>Field</code>型クラスは加算、減算、乗算、除算などの数値演算子が使える型を示します。必要に応じて再利用できるように、これらの演算子を抽象化するわけです。</p>
<p><em>補足</em>：型クラス <code>Eq</code>や <code>Ord</code>のクラスとちょうど同じように、<code>Field</code>型のクラスはPureScriptコンパイラで特別に扱われ、<code>1 + 2 * 3</code>のような単純な式は単純なJavaScriptへと変換されます。
型クラスの実装に基いて呼び出される関数呼び出しとは対照的です。</p>
<pre><code class="language-haskell">class EuclideanRing a &lt;= Field a
</code></pre>
<p><code>Field</code>型クラスは、幾つかのより抽象的な<em>上位クラス</em> (Super Class) が組み合わさってできています。
これは、その型は<code>Field</code>型クラスの操作の全てを提供しているわけではないが、その一部を提供する、というように抽象的に説明できます。
例えば、自然数の型は加算及び乗算については閉じていますが、減算については閉じていません。
そのため、この型は<code>Semiring</code>クラス（これは<code>Num</code>の上位クラスです）のインスタンスですが、<code>Ring</code>や<code>Field</code>のインスタンスではありません。</p>
<p>上位クラスについては、この章の後半で詳しく説明します。
しかし、全ての<a href="https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html">数値型クラスの階層</a>（<a href="https://harry.garrood.me/numeric-hierarchy-overview/">チートシート</a>）について述べるのはこの章の目的から外れています。
この内容に興味のある読者は<code>prelude</code>内の <code>Field</code>に関するドキュメントを参照してください。</p>
<h3 id="半群とモノイド"><a class="header" href="#半群とモノイド">半群とモノイド</a></h3>
<p><code>Semigroup</code>（半群）型クラスは、2つの値を連結する演算子 <code>append</code>を提供する型を示します。</p>
<pre><code class="language-haskell">class Semigroup a where
  append :: a -&gt; a -&gt; a
</code></pre>
<p>文字列は普通の文字列連結について半群をなし、同様に配列も半群をなします。その他の標準的なインスタンスの幾つかは、
<code>prelude</code>パッケージで提供されています。</p>
<p>以前に見た <code>&lt;&gt;</code>連結演算子は、 <code>append</code>の別名として提供されています。</p>
<p>（<code>prelude</code>パッケージで提供されている）<code>Monoid</code>型クラスには<code>mempty</code>という名前の空の値の概念があり、<code>Semigroup</code>型クラスを拡張します。</p>
<pre><code class="language-haskell">class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>ここでも文字列や配列はモノイドの簡単な例になっています。</p>
<p><code>Monoid</code>型クラスインスタンスでは、「空」の値から始めて新たな値を合成していき、その型で<em>累積</em>した結果を返すにはどうするかを記述する型クラスです。
例えば、畳み込みを使って幾つかのモノイドの値の配列を連結する関数を書くことができます。
PSCiで試すと次のようになります。</p>
<pre><code class="language-haskell">&gt; import Prelude
&gt; import Data.Monoid
&gt; import Data.Foldable

&gt; foldl append mempty [&quot;Hello&quot;, &quot; &quot;, &quot;World&quot;]
&quot;Hello World&quot;

&gt; foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
</code></pre>
<p><code>prelude</code>パッケージにはモノイドと半群の多くの例を提供しており、以降もこれらを本書で扱っていきます。</p>
<h3 id="foldable"><a class="header" href="#foldable">Foldable</a></h3>
<p><code>Monoid</code>型クラスが畳み込みの結果になるような型を示す一方、<code>Foldable</code>型クラスは畳み込みの元のデータとして使えるような型構築子を示しています。</p>
<p>また、 <code>Foldable</code>型クラスは配列や
<code>Maybe</code>などの幾つかの標準的なコンテナのインスタンスを含む<code>foldable-traversable</code>パッケージで提供されています。</p>
<p><code>Foldable</code>クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し複雑です。</p>
<pre><code class="language-haskell">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p>この定義は <code>f</code>を配列の型構築子として特殊化して考えてみるとわかりやすくなります。
この場合、全ての <code>a</code>について <code>f a</code>を <code>Array a</code>に置き換える事ができますが、<code>foldl</code>と
<code>foldr</code>の型が、最初に見た配列に対する畳み込みの型になるとわかります。</p>
<p><code>foldMap</code>についてはどうでしょうか。
これは <code>forall a m. Monoid m =&gt; (a -&gt; m) -&gt; Array a -&gt; m</code>になります。
この型シグネチャは、型 <code>m</code>が <code>Monoid</code>型クラスのインスタンスであればどんな型でも返り値の型として選ぶことができると言っています。
配列の要素をそのモノイドの値へと変換する関数を与えれば、そのモノイドの構造を利用して配列を畳み込み、1つの値にして返すことができます。</p>
<p>それではPSCiで <code>foldMap</code>を試してみましょう。</p>
<pre><code class="language-text">&gt; import Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;
</code></pre>
<p>ここでは繋ぎ合わせるためのモノイドとして文字列を、そして<code>Int</code>を文字列として表示する
<code>show</code>関数を選びました。そうして数の配列を渡すと、それぞれの数を <code>show</code>して1つの文字列へと連結した結果が出力されました。</p>
<p>しかし畳み込み可能な型は配列だけではありません。<code>foldable-traversable</code>では <code>Maybe</code>や <code>Tuple</code>のような型の
<code>Foldable</code>インスタンスが定義されており、<code>lists</code>のような他のライブラリでは、そのライブラリのそれぞれのデータ型に対して
<code>Foldable</code>インスタンスが定義されています。<code>Foldable</code>は <em>順序付きコンテナ</em> (ordered container)
の概念を見据えたものなのです。</p>
<h3 id="関手と型クラス則"><a class="header" href="#関手と型クラス則">関手と型クラス則</a></h3>
<p>PureScriptで副作用を伴う関数型プログラミングのスタイルを可能にするための<code>Functor</code>と <code>Applicative</code>、
<code>Monad</code>といった型クラスがPreludeでは定義されています。これらの抽象化については後ほど本書で扱いますが、まずは<code>map</code>関数の形で既に見てきた<code>Functor</code>型クラスの定義を見てみましょう。</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><code>map</code>関数（別名<code>&lt;$&gt;</code>）は関数をそのデータ構造まで「持ち上げる」(lift) ことができます。
ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、既に幾つかの単純な型についてその動作を見てきました。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; map (\n -&gt; n &lt; 3) [1, 2, 3, 4, 5]
[true, true, false, false, false]

&gt; import Data.Maybe
&gt; import Data.String (length)

&gt; map length (Just &quot;testing&quot;)
(Just 7)
</code></pre>
<p><code>map</code>演算子は様々な構造の上でそれぞれ異なる挙動をしますが、 <code>map</code>演算子の意味はどのように理解すればいいのでしょうか。</p>
<p>直感的には、 <code>map</code>演算子はコンテナのそれぞれの要素へ関数を適用し、その結果から元のデータと同じ形状を持った新しいコンテナを構築するものとできます。
しかし、この着想を精密にするにはどうしたらいいでしょうか。</p>
<p><code>Functor</code>の型クラスのインスタンスは、<em>関手則</em>と呼ばれる法則を順守するものと期待されています。</p>
<ul>
<li><code>map identity xs = xs</code></li>
<li><code>map g (map f xs) = map (g &lt;&lt;&lt; f) xs</code></li>
</ul>
<p>最初の法則は <em>恒等射律</em> (identity law)
です。これは、恒等関数（引数を変えずに返す関数）をその構造まで持ち上げると、元の構造をそのまま返すという意味です。恒等関数は入力を変更しませんから、これは理にかなっています。</p>
<p>第二の法則は <em>合成律</em> (composition law)
です。構造を1つの関数で写してから2つめの関数で写すのは、2つの関数の合成で構造を写すのと同じだ、と言っています。</p>
<p>「持ち上げ」の一般的な意味が何であれ、データ構造に対する持ち上げ関数の正しい定義はこれらの法則に従っていなければなりません。</p>
<p>標準の型クラスの多くには、このような法則が付随しています。
一般に、型クラスに与えられた法則は、型クラスの関数に構造を与え、普遍的にインスタンスについて調べられるようにします。
興味のある読者は、既に見てきた標準の型クラスに属する法則について調べてみてもよいでしょう。</p>
<h3 id="インスタンスの導出"><a class="header" href="#インスタンスの導出">インスタンスの導出</a></h3>
<p>インスタンスを手作業で描く代わりに、ほとんどの作業をコンパイラにさせることができます。
この<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出手引き</a>を見てください。
そちらの情報が以下の演習を解く手助けになることでしょう。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<p>（簡単）次のnewtypeは複素数を表します。</p>
<pre><code class="language-haskell">newtype Complex
  = Complex
  { real :: Number
  , imaginary :: Number
  }
</code></pre>
<ol>
<li>
<p>（簡単）<code>Complex</code>に<code>Show</code>インスタンスを定義してください。
出力の形式はテストで期待される形式と一致させてください（例：<code>1.2+3.4i</code>、<code>5.6-7.7i</code>など）。</p>
</li>
<li>
<p>（簡単）<code>Eq</code>インスタンスを<code>Complex</code>に導出してください。
<em>補足</em>：代わりにこのインスタンスを手作業で書いてもよいですが、しなくていいのになぜすることがありましょう。</p>
</li>
<li>
<p>（普通）<code>Semiring</code>インタンスを<code>Complex</code>に定義してください。<em>補足</em>：<a href="https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype"><code>Data.Newtype</code></a>の<code>wrap</code>と<code>over2</code>を使ってより簡潔な解答をつくることができます。もしそうするのでしたら、<code>Data.Newtype</code>から<code>class Newtype</code>をインポートしたり、<code>Newtype</code>インスタンスを<code>Complex</code>に導出したりする必要も出てくるでしょう。</p>
</li>
<li>
<p>（簡単）（<code>newtype</code>を介して）<code>Ring</code>インスタンスを<code>Complex</code>に導出してください。
<em>補足</em>：代わりにこのインスタンスを手作業で書くこともできますが、そう手軽にはできません。</p>
<p>以下は前章からの<code>Shape</code>のADTです。</p>
<pre><code class="language-haskell">data Shape
  = Circle Point Number
  | Rectangle Point Number Number
  | Line Point Point
  | Text Point String
</code></pre>
</li>
<li>
<p>（普通）（<code>Generic</code>を介して）<code>Show</code>インスタンスを<code>Shape</code>に導出してください。
コードの量はどのくらいになりましたか。
また、前の章の<code>showShape</code>と比較して<code>String</code>の出力はどうなりましたか。
<em>手掛かり</em>：<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md">型クラス導出</a>手引きの<a href="https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic"><code>Generic</code>から導出する</a>節を見てください。</p>
</li>
</ol>
<h2 id="型クラス制約"><a class="header" href="#型クラス制約">型クラス制約</a></h2>
<p>型クラスを使うと、関数の型に制約を加えることができます。
例を示しましょう。
<code>Eq</code>型クラスのインスタンスで定義された等値性を使って、3つの値が等しいかどうかを調べる関数を書きたいとします。</p>
<pre><code class="language-haskell">threeAreEqual :: forall a. Eq a =&gt; a -&gt; a -&gt; a -&gt; Boolean
threeAreEqual a1 a2 a3 = a1 == a2 &amp;&amp; a2 == a3
</code></pre>
<p>この型宣言は <code>forall</code>を使って定義された通常の多相型のようにも見えます。
しかし、二重線矢印 <code>=&gt;</code>で型の残りの部分から区切られた、型クラス制約 (type class constraint) <code>Eq a</code>があります。</p>
<p>インポートされたモジュールのどれかに <code>a</code>に対する <code>Eq</code>インスタンスが存在するなら、どんな型 <code>a</code>を選んでも
<code>threeAsEqual</code>を呼び出すことができる、とこの型は言っています。</p>
<p>制約された型には複数の型クラスインスタンスを含めることができますし、インスタンスの型は単純な型変数に限定されません。 <code>Ord</code>と
<code>Show</code>のインスタンスを使って2つの値を比較する例を次に示します。</p>
<pre><code class="language-haskell">showCompare :: forall a. Ord a =&gt; Show a =&gt; a -&gt; a -&gt; String
showCompare a1 a2 | a1 &lt; a2 =
  show a1 &lt;&gt; &quot; is less than &quot; &lt;&gt; show a2
showCompare a1 a2 | a1 &gt; a2 =
  show a1 &lt;&gt; &quot; is greater than &quot; &lt;&gt; show a2
showCompare a1 a2 =
  show a1 &lt;&gt; &quot; is equal to &quot; &lt;&gt; show a2
</code></pre>
<p><code>=&gt;</code>シンボルを複数回使って複数の制約を指定できることに注意してください。
複数の引数のカリー化された関数を定義するのと同様です。
しかし、2つの記号を混同しないように注意してください。</p>
<ul>
<li><code>a -&gt; b</code>は <em>型</em> <code>a</code>から <em>型</em> <code>b</code>への関数の型を表します。</li>
<li>一方で、<code>a =&gt; b</code>は <em>制約</em> <code>a</code>を型<code>b</code>に適用します。</li>
</ul>
<p>PureScriptコンパイラは、型の注釈が提供されていない場合、制約付きの型を推論しようとします。これは、関数に対してできる限り最も一般的な型を使用したい場合に便利です。</p>
<p>PSCiで <code>Semiring</code>のような標準の型クラスの何れかを使って、このことを試してみましょう。</p>
<pre><code class="language-text">&gt; import Prelude

&gt; :type \x -&gt; x + x
forall a. Semiring a =&gt; a -&gt; a
</code></pre>
<p>ここで、この関数には<code>Int -&gt; Int</code>または<code>Number -&gt; Number</code>と注釈を付けることが考えられますが、最も一般的な型が<code>Semiring</code>で動作するため、PSCiでは<code>Int</code>と <code>Number</code>の両方で関数を実行させることができます。</p>
<h2 id="インスタンスの依存関係"><a class="header" href="#インスタンスの依存関係">インスタンスの依存関係</a></h2>
<p>制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、型クラスインスタンスの実装は他の型クラスインスタンスに依存できます。これにより、型を使ってプログラムの実装を推論するという、プログラム推論の強力な形式を提供します。</p>
<p><code>Show</code>型クラスを例に考えてみましょう。
それぞれの要素を <code>show</code>する方法がある限り、その要素の配列を <code>show</code>する型クラスインスタンスを書くことができます。</p>
<pre><code class="language-haskell">instance Show a =&gt; Show (Array a) where
  ...
</code></pre>
<p>型クラスインスタンスが複数の他のインスタンスに依存する場合、括弧で囲んでそれらのインスタンスをコンマで区切り、それを<code>=&gt;</code>シンボルの左側に置く必要があります。</p>
<pre><code class="language-haskell">instance (Show a, Show b) =&gt; Show (Either a b) where
  ...
</code></pre>
<p>これらの2つの型クラスインスタンスは <code>prelude</code>ライブラリにあります。</p>
<p>プログラムがコンパイルされると、<code>Show</code>の正しい型クラスのインスタンスは <code>show</code>の引数の推論された型に基づいて選ばれます。
選択されたインスタンスが沢山のそうしたインスタンスの関係に依存しているかもしれませんが、このあたりの複雑さに開発者が関与することはありません。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>
<p>（簡単）以下の宣言では型 <code>a</code>の要素の空でない配列の型を定義しています。</p>
<pre><code class="language-haskell">data NonEmpty a = NonEmpty a (Array a)
</code></pre>
<p><code>Eq a</code>と<code>Eq (Array a)</code>のインスタンスを再利用し、型<code>NonEmpty</code>に<code>Eq</code>インスタンスを書いてください。
<em>補足</em>：代わりに<code>Eq</code>インスタンスも導出できます。</p>
</li>
<li>
<p>（普通）<code>Array</code>の<code>Semigroup</code>インスタンスを再利用して、<code>NonEmpty</code>への<code>Semigroup</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>NonEmpty</code>に<code>Functor</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（普通）<code>Ord</code>のインスタンス付きの任意の型<code>a</code>が与えられているとすると、新しくそれ以外のどんな値よりも大きい「無限の」値を付け加えられます。</p>
<pre><code class="language-haskell">data Extended a = Infinite | Finite a 
</code></pre>
<p><code>a</code>への<code>Ord</code>インスタンスを再利用して、<code>Extended a</code>に<code>Ord</code>インスタンスを書いてください。</p>
</li>
<li>
<p>（難しい）<code>NonEmpty</code>に<code>Foldable</code>インスタンスを書いてください。
<em>手掛かり</em>：配列への<code>Foldable</code>インスタンスを再利用してください。</p>
</li>
<li>
<p>（難しい）順序付きコンテナを定義する（そして <code>Foldable</code>のインスタンスを持っている）ような型構築子
<code>f</code>が与えられたとき、追加の要素を先頭に含めるような新たなコンテナ型を作ることができます。</p>
<pre><code class="language-haskell">data OneMore f a = OneMore a (f a)
</code></pre>
<p>このコンテナ <code>OneMore f</code>もまた順序を持っています。
ここで、新しい要素は任意の <code>f</code>の要素よりも前にきます。
この <code>OneMore f</code>の <code>Foldable</code>インスタンスを書いてみましょう。</p>
<pre><code class="language-haskell">instance Foldable f =&gt; Foldable (OneMore f) where
  ...
</code></pre>
</li>
<li>
<p>（普通）<code>nubEq</code>関数を使い、配列から重複する<code>Shape</code>を削除する<code>dedupShapes :: Array Shape -&gt; Array Shape</code>関数を書いてください。</p>
</li>
<li>
<p>（普通）<code>dedupShapesFast</code>関数を書いてください。
<code>dedupShapes</code>とほぼ同じですが、より効率の良い<code>nub</code>関数を使います。</p>
</li>
</ol>
<h2 id="多変数型クラス"><a class="header" href="#多変数型クラス">多変数型クラス</a></h2>
<p>型クラスは必ずしも1つの型だけを型変数としてとるわけではありません。型変数が1つだけなのが最も一般的ですが、実際には型クラスは<em>ゼロ個以上の</em>型変数を持つことができます。</p>
<p>それでは2つの型引数を持つ型クラスの例を見てみましょう。</p>
<pre><code class="language-haskell">module Stream where

import Data.Array as Array
import Data.Maybe (Maybe)
import Data.String.CodeUnits as String

class Stream stream element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }

instance Stream (Array a) a where
  uncons = Array.uncons

instance Stream String Char where
  uncons = String.uncons
</code></pre>
<p>この <code>Stream</code>モジュールでは、要素のストリームのような型を示すクラス <code>Stream</code>が定義されています。
<code>uncons</code>関数を使ってストリームの先頭から要素を取り出すことができます。</p>
<p><code>Stream</code>型クラスは、ストリーム自身の型だけでなくその要素の型も型変数として持っていることに注意してください。これによって、ストリームの型が同じでも要素の型について異なる型クラスインスタンスを定義できます。</p>
<p>このモジュールでは2つの型クラスインスタンスが定義されています。
<code>uncons</code>がパターン照合で配列の先頭の要素を取り除くような配列のインスタンスと、文字列から最初の文字を取り除くような文字列のインスタンスです。</p>
<p>任意のストリーム上で動作する関数を記述できます。例えば、ストリームの要素に基づいて <code>Monoid</code>に結果を累積する関数は次のようになります。</p>
<pre><code class="language-haskell">import Prelude
import Data.Monoid (class Monoid, mempty)

foldStream :: forall l e m. Stream l e =&gt; Monoid m =&gt; (e -&gt; m) -&gt; l -&gt; m
foldStream f list =
  case uncons list of
    Nothing -&gt; mempty
    Just cons -&gt; f cons.head &lt;&gt; foldStream f cons.tail
</code></pre>
<p>PSCiで使って、異なる <code>Stream</code>の型や異なる <code>Monoid</code>の型について <code>foldStream</code>を呼び出してみましょう。</p>
<h2 id="関数従属性"><a class="header" href="#関数従属性">関数従属性</a></h2>
<p>多変数型クラスは非常に便利ですが、混乱しやすい型や型推論の問題にも繋がります。
簡単な例として、上記の <code>Stream</code>クラスを使って汎用的な<code>tail</code>関数をストリームに書くことを考えてみましょう。</p>
<pre><code class="language-haskell">genericTail xs = map _.tail (uncons xs)
</code></pre>
<p>これはやや複雑なエラーメッセージを出力します。</p>
<pre><code class="language-text">The inferred type

  forall stream a. Stream stream a =&gt; stream -&gt; Maybe stream

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>エラーは、 <code>genericTail</code>関数が <code>Stream</code>型クラスの定義で言及された
<code>element</code>型を使用しないので、その型は未解決のままであることを指しています。</p>
<p>更に残念なことに、特定の型のストリームに<code>genericTail</code>を適用できません。</p>
<pre><code class="language-text">&gt; map _.tail (uncons &quot;testing&quot;)

The inferred type

  forall a. Stream String a =&gt; Maybe String

has type variables which are not mentioned in the body of the type. Consider adding a type annotation.
</code></pre>
<p>ここでは、コンパイラが <code>streamString</code>インスタンスを選択することを期待しています。
結局のところ、 <code>String</code>は <code>Char</code>のストリームであり、他の型のストリームであってはなりません。</p>
<p>コンパイラは自動的にそう推論できず、<code>streamString</code>インスタンスを割り当てることができません。
しかし、型クラス定義に手掛かりを追加すると、コンパイラを助けることができます。</p>
<pre><code class="language-haskell">class Stream stream element | stream -&gt; element where
  uncons :: stream -&gt; Maybe { head :: element, tail :: stream }
</code></pre>
<p>ここで、 <code>stream -&gt; element</code>は <em>関数従属性</em> (functional dependency) と呼ばれます。関数従属性は、多変数型クラスの型引数間の関数関係を宣言します。この関数の依存関係は、ストリーム型から（一意の）要素型への関数があることをコンパイラに伝えるので、コンパイラがストリーム型を知っていれば要素の型を割り当てられます。</p>
<p>この手掛かりがあれば、コンパイラが上記の汎用的な尾鰭関数の正しい型を推論するのに充分です。</p>
<pre><code class="language-text">&gt; :type genericTail
forall stream element. Stream stream element =&gt; stream -&gt; Maybe stream

&gt; genericTail &quot;testing&quot;
(Just &quot;esting&quot;)
</code></pre>
<p>多種の型のクラスを使用して何らかのAPIを設計する場合、関数従属性は非常に有用です。</p>
<h2 id="型変数のない型クラス"><a class="header" href="#型変数のない型クラス">型変数のない型クラス</a></h2>
<p>ゼロ個の型変数を持つ型クラスさえも定義できます。
これらは関数に対するコンパイル時のアサーションに対応しており、型システム内のコードの大域的な性質を把握できます。</p>
<p>重要な一例として、前に部分関数についてお話しした際に見た<code>Partial</code>クラスがあります。<code>Data.Array.Partial</code>に定義されている関数<code>head</code>と<code>tail</code>を例に取りましょう。この関数は配列の先頭と尾鰭を<code>Maybe</code>に包むことなく取得できます。なので配列が空のときに失敗する可能性があります。</p>
<pre><code class="language-haskell">head :: forall a. Partial =&gt; Array a -&gt; a

tail :: forall a. Partial =&gt; Array a -&gt; Array a
</code></pre>
<p><code>Partial</code>モジュールの <code>Partial</code>型クラスのインスタンスを定義していないことに注意してください。
こうすると目的を達成できます。
このままの定義では <code>head</code>関数を使用しようとすると型エラーになるのです。</p>
<pre><code class="language-text">&gt; head [1, 2, 3]

No type class instance was found for

  Prim.Partial
</code></pre>
<p>代わりに、これらの部分関数を利用する全ての関数で <code>Partial</code>制約を再発行できます。</p>
<pre><code class="language-haskell">secondElement :: forall a. Partial =&gt; Array a -&gt; a
secondElement xs = head (tail xs)
</code></pre>
<p>前章で見た<code>unsafePartial</code>関数を使用し、部分関数を通常の関数として（不用心に）扱うことができます。この関数は
<code>Partial.Unsafe</code>モジュールで定義されています。</p>
<pre><code class="language-haskell">unsafePartial :: forall a. (Partial =&gt; a) -&gt; a
</code></pre>
<p><code>Partial</code>制約は関数の矢印の左側の括弧の中に現れますが、外側の <code>forall</code>では現れません。
つまり、 <code>unsafePartial</code>は部分的な値から通常の値への関数です。</p>
<pre><code class="language-text">&gt; unsafePartial head [1, 2, 3]
1

&gt; unsafePartial secondElement [1, 2, 3]
2
</code></pre>
<h2 id="上位クラス"><a class="header" href="#上位クラス">上位クラス</a></h2>
<p>インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス間の関係を表現できるように、いわゆる<em>上位クラス</em>を使って型クラス間の関係を表現できます。</p>
<p>あるクラスのどんなインスタンスも、別のクラスのインスタンスである必要があるとき、後者の型クラスは前者の型クラスの上位クラスであるといいます。
そしてクラス定義で逆向きの太い矢印 (<code>&lt;=</code>) を使って上位クラス関係を示します。</p>
<p><a href="#ord">既に上位クラスの関係の例を目にしました</a>。
<code>Eq</code>クラスは <code>Ord</code>の上位クラスですし、<code>Semigroup</code>クラスは<code>Monoid</code>の上位クラスです。
<code>Ord</code>クラスの全ての型クラスインスタンスについて、その同じ型に対応する <code>Eq</code>インスタンスが存在しなければなりません。
これは理に適っています。
<code>compare</code>関数が2つの値の大小を付けられないと報告した時は、それらが実は同値であるかどうかを判定するために
<code>Eq</code>クラスを使いたいことが多いでしょうから。</p>
<p>一般に、下位クラスの法則が上位クラスのメンバに言及しているとき、上位クラス関係を定義するのは筋が通っています。
例えば、任意の<code>Ord</code>と<code>Eq</code>のインスタンスの対について、もし2つの値が<code>Eq</code>インスタンスの下で同値であるなら、<code>compare</code>関数は
<code>EQ</code>を返すはずだと見做すのは理に適っています。
言い換えれば、<code>a == b</code>が真であるのはちょうど<code>compare a b</code>が<code>EQ</code>に評価されるときなのです。
法則のレベルでのこの関係は<code>Eq</code>と<code>Ord</code>の間の上位クラス関係の正当性を示します。</p>
<p>上位クラス関係を定義する別の理由となるのは、この2つのクラスの間に明らかに &quot;is-a&quot; の関係があることです。
下位クラスの全てのメンバは、上位クラスのメンバでもあるということです。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>
<p>（普通）部分関数<code>unsafeMaximum :: Partial =&gt; Array Int -&gt; Int</code>を定義してください。この関数は空でない整数の配列の最大値を求めます。<code>unsafePartial</code>を使ってPSCiで関数をテストしてください。<em>手掛かり</em>：<code>Data.Foldable</code>の
<code>maximum</code>関数を使います。</p>
</li>
<li>
<p>（普通）次の <code>Action</code>クラスは、ある型の別の型での動作 (action) を定義する、多変数型クラスです。</p>
<pre><code class="language-haskell">class Monoid m &lt;= Action m a where
  act :: m -&gt; a -&gt; a
</code></pre>
<p><em>動作</em>はモノイドな値を使って他の型の値を変更する方法を決めるやり方を記述する関数です。<code>Action</code>型クラスには2つの法則があります。</p>
<ul>
<li><code>act mempty a = a</code></li>
<li><code>act (m1 &lt;&gt; m2) a = act m1 (act m2 a)</code></li>
</ul>
<p>空の動作を提供しても何も起こりません。
そして2つの動作を連続で適用することは結合した動作を適用することと同じです。
つまり、動作は<code>Monoid</code>クラスで定義される操作に倣っています。</p>
<p>例えば自然数は乗算のもとでモノイドを形成します。</p>
<pre><code class="language-haskell">newtype Multiply = Multiply Int

instance Semigroup Multiply where
  append (Multiply n) (Multiply m) = Multiply (n * m)

instance Monoid Multiply where
  mempty = Multiply 1
</code></pre>
<p>この動作を実装するインスタンスを書いてください。</p>
<pre><code class="language-haskell">instance Action Multiply Int where
  ...
</code></pre>
<p>インスタンスが上で挙げた法則を見たさなくてはならないことを思い出してください。</p>
</li>
<li>
<p>（難しい）実は<code>Action Multiply Int</code>のインスタンスを実装するには複数の方法があります。
どれだけ思い付きますか。
PureScriptは同じインスタンスの複数の実装を許さないため、元の実装を置き換える必要があります。
<em>補足</em>：テストでは4つの実装を押さえています。</p>
</li>
<li>
<p>（普通）入力の文字列を何回か繰り返す<code>Action</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">instance Action Multiply String where
  ...
</code></pre>
<p><em>手掛かり</em>：Pursuitでシグネチャが<a href="https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String"><code>String -&gt; Int -&gt; String</code></a>の補助関数を検索してください。
なお<code>String</code>は（<code>Monoid</code>のような）より汎用的な型として現れます。</p>
<p>このインスタンスは上に挙げた法則を満たすでしょうか。</p>
</li>
<li>
<p>（普通）インスタンス <code>Action m a =&gt; Action m (Array a)</code>を書いてみましょう。
ここで、 配列上の動作はそれぞれの要素を独立に実行するものとして定義されます。</p>
</li>
<li>
<p>（難しい）以下のnewtypeが与えらえているとき、<code>Action m (Self m)</code>のインスタンスを書いてください。
ここでモノイド<code>m</code>はそれ自体が持つ<code>append</code>を用いて動作します。</p>
<pre><code class="language-haskell">newtype Self m = Self m
</code></pre>
<p><em>補足</em>：テストフレームワークでは<code>Self</code>と<code>Multiply</code>型に<code>Show</code>と<code>Eq</code>インスタンスが必要になります。
手作業でこれらのインスタンスを書いてもよいですし、<a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype"><code>derive newtype instance</code></a>と書くだけでコンパイラに取り仕切ってもらうこともできます。</p>
</li>
<li>
<p>（難しい）多変数型のクラス <code>Action</code>の引数は、何らかの関数従属性によって関連づけられるべきですか。
なぜそうすべき、あるいはそうすべきでないでしょうか。
<em>補足</em>：この演習にはテストがありません。</p>
</li>
</ol>
<h2 id="ハッシュの型クラス"><a class="header" href="#ハッシュの型クラス">ハッシュの型クラス</a></h2>
<p>この最後の節では、章の残りを使ってデータ構造をハッシュ化するライブラリを作ります。</p>
<p>なお、このライブラリの説明だけを目的としており、堅牢なハッシュ化の仕組みの提供は目的としていません。</p>
<p>ハッシュ関数に期待される性質とはどのようなものでしょうか。</p>
<ul>
<li>ハッシュ関数は決定的でなくてはなりません。
つまり、同じ値には同じハッシュ値を対応させなければなりません。</li>
<li>ハッシュ関数はいろいろなハッシュ値の集合で結果が一様に分布しなければなりません。</li>
</ul>
<p>最初の性質はまさに型クラスの法則のように見える一方で、2番目の性質はよりくだけた規約の条項のようなもので、PureScriptの型システムによって確実に強制できるようなものではなさそうです。
しかし、これは型クラスについて次のような直感的理解を与えるはずです。</p>
<pre><code class="language-haskell">newtype HashCode = HashCode Int

instance Eq HashCode where
  eq (HashCode a) (HashCode b) = a == b

hashCode :: Int -&gt; HashCode
hashCode h = HashCode (h `mod` 65535)

class Eq a &lt;= Hashable a where
  hash :: a -&gt; HashCode
</code></pre>
<p>これに、 <code>a == b</code>ならば <code>hash a == hash b</code>を示唆するという関係性の法則が付随しています。</p>
<p>この節の残りの部分を費やして、<code>Hashable</code>型クラスに関連付けられているインスタンスと関数のライブラリを構築していきます。</p>
<p>決定的な方法でハッシュ値を結合する方法が必要になります。</p>
<pre><code class="language-haskell">combineHashes :: HashCode -&gt; HashCode -&gt; HashCode
combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)
</code></pre>
<p><code>combineHashes</code>関数は2つのハッシュ値を混ぜて結果を0-65535の間に分布します。</p>
<p>それでは、入力の種類を制限する <code>Hashable</code>制約を使う関数を書いてみましょう。
ハッシュ関数を必要とするよくある目的としては、2つの値が同じハッシュ値にハッシュ化されるかどうかを決定することです。
<code>hashEqual</code>関係はそのような機能を提供します。</p>
<pre><code class="language-haskell">hashEqual :: forall a. Hashable a =&gt; a -&gt; a -&gt; Boolean
hashEqual = eq `on` hash
</code></pre>
<p>この関数はハッシュコードの等値性を利用したハッシュ同値性を定義するために<code>Data.Function</code>の
<code>on</code>関数を使っていますが、これはハッシュ同値性の宣言的な定義として読めるはずです。
つまり、それぞれの値が <code>hash</code>関数に渡されたあとで2つの値が等しいなら、それらの値は「ハッシュ同値」です。</p>
<p>原始型の <code>Hashable</code>インスタンスを幾つか書いてみましょう。
まずは整数のインスタンスです。
<code>HashCode</code>は実際には単なる梱包された整数なので、これは簡単です。
<code>hashCode</code>補助関数を使うことができます。</p>
<pre><code class="language-haskell">instance Hashable Int where
  hash = hashCode
</code></pre>
<p>パターン照合を使うと、<code>Boolean</code>値の単純なインスタンスも定義できます。</p>
<pre><code class="language-haskell">instance Hashable Boolean where
  hash false = hashCode 0
  hash true  = hashCode 1
</code></pre>
<p>整数のインスタンスでは、<code>Data.Char</code>の <code>toCharCode</code>関数を使うと<code>Char</code>をハッシュ化するインスタンスを作成できます。</p>
<pre><code class="language-haskell">instance Hashable Char where
  hash = hash &lt;&lt;&lt; toCharCode
</code></pre>
<p>（要素型が <code>Hashable</code>のインスタンスでもあるならば）配列の要素に <code>hash</code>関数を
<code>map</code>してから、<code>combineHashes</code>関数を使って結果のハッシュを左側に畳み込むことで、配列のインスタンスを定義します。</p>
<pre><code class="language-haskell">instance Hashable a =&gt; Hashable (Array a) where
  hash = foldl combineHashes (hashCode 0) &lt;&lt;&lt; map hash
</code></pre>
<p>既に書いたものより単純なインスタンスを使用して、新たなインスタンスを構築しているやり方に注目してください。
<code>String</code>を<code>Char</code>の配列に変換し、この新たな<code>Array</code>インスタンスを使って<code>String</code>のインスタンスを定義しましょう。</p>
<pre><code class="language-haskell">instance Hashable String where
  hash = hash &lt;&lt;&lt; toCharArray
</code></pre>
<p>これらの <code>Hashable</code>インスタンスが先ほどの型クラスの法則を満たしていることを証明するにはどうしたらいいでしょうか。
同じ値が等しいハッシュ値を持っていることを確認する必要があります。
<code>Int</code>、 <code>Char</code>、 <code>String</code>、
<code>Boolean</code>の場合は、<code>Eq</code>の意味では同じ値でも厳密には同じではない、というような型の値は存在しないので簡単です。</p>
<p>もっと面白い型についてはどうでしょうか。
この場合、配列の長さに関する帰納を使うと、型クラスの法則を証明できます。
長さゼロの唯一の配列は <code>[]</code>です。
配列の <code>Eq</code>の定義により、任意の2つの空でない配列は、それらの先頭の要素が同じで配列の残りの部分が等しいとき、またその時に限り等しくなります。
この帰納的な仮定により、配列の残りの部分は同じハッシュ値を持ちますし、もし <code>Hashable a</code>インスタンスがこの法則を満たすなら、先頭の要素も同じハッシュ値をもつことがわかります。
したがって、2つの配列は同じハッシュ値を持ち、<code>Hashable (Array a)</code>も同様に型クラス法則を満たしています。</p>
<p>この章のソースコードには、 <code>Maybe</code>と <code>Tuple</code>型のインスタンスなど、他にも <code>Hashable</code>インスタンスの例が含まれています。</p>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>
<p>（簡単）PSCiを使って、定義した各インスタンスのハッシュ関数をテストしてください。
<em>補足</em>：この演習には単体試験がありません。</p>
</li>
<li>
<p>（普通）ハッシュと値の同値性に基づいて配列が重複する要素を持っているかどうかを調べる関数<code>arrayHasDuplicates</code>を書いてください。
まずハッシュ同値性を<code>hashEqual</code>関数で確認し、それからもし重複するハッシュの対が見付かったら<code>==</code>で値の同値性を確認してください。
<em>手掛かり</em>：<code>Data.Array</code>の <code>nubByEq</code>関数はこの問題をずっと簡単にしてくれるでしょう。</p>
</li>
<li>
<p>（普通）型クラスの法則を満たす、次のnewtypeの <code>Hashable</code>インスタンスを書いてください。</p>
<pre><code class="language-haskell">newtype Hour = Hour Int

instance Eq Hour where
  eq (Hour n) (Hour m) = mod n 12 == mod m 12
</code></pre>
</li>
</ol>
<p>newtypeの <code>Hour</code>とその <code>Eq</code>インスタンスは、12を法とする整数の型を表します。
したがって、例えば1と13は等しいと見なされます。
そのインスタンスが型クラスの法則を満たしていることを証明してください。</p>
<ol>
<li>（難しい）<code>Maybe</code>、<code>Either</code>そして<code>Tuple</code>への<code>Hashable</code>インスタンスについて型クラスの法則を証明してください。
<em>補足</em>：この演習にテストはありません。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、型に基づく抽象化で、コードの再利用のための強力な形式化を可能にする <em>型クラス</em>
を導入しました。PureScriptの標準ライブラリから標準の型クラスを幾つか見てきました。また、ハッシュ値を計算する型クラスに基づく独自のライブラリを定義しました。</p>
<p>この章では型クラス法則の考え方も導入しましたが、これは抽象化に型クラスを使うコードについての性質を証明する手法でした。
型クラス法則は<em>等式推論</em>と呼ばれる大きな分野の一部であり、プログラミング言語の性質と型システムがプログラムを論理的に推論するために使われています。
これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話題となるでしょう。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

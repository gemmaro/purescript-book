# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Phil
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-11-30 19:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: ../text/SUMMARY.md:1
#, markdown-text, no-wrap
msgid "Summary"
msgstr ""

#. type: Plain text
#: ../text/SUMMARY.md:4
#, markdown-text
msgid "[Foreword](../README.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Introduction](chapter1.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Getting Started](chapter2.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Functions and Records](chapter3.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Pattern Matching](chapter4.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Recursion, Maps And Folds](chapter5.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Type Classes](chapter6.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Applicative Validation](chapter7.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[The Effect Monad](chapter8.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Asynchronous Effects](chapter9.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[The Foreign Function Interface](chapter10.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Monadic Adventures](chapter11.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Canvas Graphics](chapter12.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Generative Testing](chapter13.md)"
msgstr ""

#. type: Bullet: '* '
#: ../text/SUMMARY.md:18
#, markdown-text
msgid "[Domain-Specific Languages](chapter14.md)"
msgstr ""

#. type: Title #
#: ../README.md:1
#, markdown-text, no-wrap
msgid "PureScript by Example"
msgstr ""

#. type: Plain text
#: ../README.md:4
#, markdown-text
msgid ""
"This repository contains a [community "
"fork](https://github.com/purescript-contrib/purescript-book/) of _PureScript "
"by Example_ by Phil Freeman, also known as \"the PureScript book\". This "
"version differs from the original in that it has been updated so that the "
"code and exercises work with up-to-date versions of the compiler, libraries, "
"and tools. Some chapters have also been rewritten to showcase the latest "
"features of the PureScript ecosystem."
msgstr ""

#. type: Plain text
#: ../README.md:6
#, markdown-text
msgid ""
"If you enjoyed the book or found it useful, please consider buying a copy of "
"[the original on Leanpub](https://leanpub.com/purescript)."
msgstr ""

#. type: Plain text
#: ../README.md:8
#, markdown-text
msgid "Translations: [日本語 (Japanese)](https://gemmaro.github.io/purescript-book/)"
msgstr ""

#. type: Title ##
#: ../README.md:9
#, markdown-text, no-wrap
msgid "Status"
msgstr ""

#. type: Plain text
#: ../README.md:12
#, markdown-text
msgid ""
"This book is being continuously updated as the language evolves, so please "
"report any "
"[issues](https://github.com/purescript-contrib/purescript-book/issues) you "
"discover with the material. We appreciate any feedback you have to share, "
"even if it's as simple as pointing out a confusing section that we could "
"make more beginner-friendly."
msgstr ""

#. type: Plain text
#: ../README.md:14
#, markdown-text
msgid ""
"Unit tests are also being added to each chapter so you can check if your "
"answers to the exercises are correct. See "
"[#79](https://github.com/purescript-contrib/purescript-book/issues/79) for "
"the latest status on tests."
msgstr ""

#. type: Title ##
#: ../README.md:15
#, markdown-text, no-wrap
msgid "About the Book"
msgstr ""

#. type: Plain text
#: ../README.md:18
#, markdown-text
msgid ""
"PureScript is a small, strongly, statically typed programming language with "
"expressive types, written in and inspired by Haskell, and compiling to "
"Javascript."
msgstr ""

#. type: Plain text
#: ../README.md:20
#, markdown-text
msgid ""
"Functional programming in JavaScript has seen quite a lot of popularity "
"recently, but large-scale application development is hindered by the lack of "
"a disciplined environment in which to write code. PureScript aims to solve "
"that problem by bringing the power of strongly-typed functional programming "
"to the world of JavaScript development."
msgstr ""

#. type: Plain text
#: ../README.md:22
#, markdown-text
msgid ""
"This book will show you how to get started with the PureScript programming "
"language, from the basics (setting up a development environment) to the "
"advanced."
msgstr ""

#. type: Plain text
#: ../README.md:24
#, markdown-text
msgid ""
"Each chapter will be motivated by a particular problem, and in the course of "
"solving that problem, new functional programming tools and techniques will "
"be introduced. Here are some examples of problems that will be solved in "
"this book:"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "Transforming data structures with maps and folds"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "Form field validation using applicative functors"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "Testing code with QuickCheck"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "Using the canvas"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "Domain specific language implementation"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "Working with the DOM"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "JavaScript interoperability"
msgstr ""

#. type: Bullet: '- '
#: ../README.md:33
#, markdown-text
msgid "Parallel asynchronous execution"
msgstr ""

#. type: Title ##
#: ../README.md:34
#, markdown-text, no-wrap
msgid "License"
msgstr ""

#. type: Plain text
#: ../README.md:37
#, markdown-text
msgid "Copyright (c) 2014-2017 Phil Freeman."
msgstr ""

#. type: Plain text
#: ../README.md:39
#, markdown-text
msgid ""
"The text of this book is licensed under the Creative Commons "
"Attribution-NonCommercial-ShareAlike 3.0 Unported License: "
"<https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US>."
msgstr ""

#. type: Plain text
#: ../README.md:41
#, markdown-text
msgid ""
"Some text is derived from the [PureScript Documentation "
"Repo](https://github.com/purescript/documentation), which uses the same "
"license, and is copyright [various "
"contributors](https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md)."
msgstr ""

#. type: Plain text
#: ../README.md:42
#, markdown-text
msgid "The exercises are licensed under the MIT license."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:1 ../text/chapter5.md:25
#, markdown-text, no-wrap
msgid "Introduction"
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:3
#, markdown-text, no-wrap
msgid "Functional JavaScript"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:6
#, markdown-text
msgid ""
"Functional programming techniques have been making appearances in JavaScript "
"for some time now:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:8
#, markdown-text
msgid ""
"Libraries such as [UnderscoreJS](https://underscorejs.org) allow the "
"developer to leverage tried-and-trusted functions such as `map`, `filter`, "
"and `reduce` to create larger programs from smaller programs by composition:"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:18
#, markdown-text, no-wrap
msgid ""
"    ```javascript\n"
"    var sumOfPrimes =\n"
"        _.chain(_.range(1000))\n"
"         .filter(isPrime)\n"
"         .reduce(function(x, y) {\n"
"             return x + y;\n"
"         })\n"
"         .value();\n"
"    ```\n"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:20
#, markdown-text
msgid ""
"Asynchronous programming in NodeJS leans heavily on functions as first-class "
"values to define callbacks."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:23
#, markdown-text, no-wrap
msgid ""
"    ```javascript\n"
"    import { readFile, writeFile } from 'fs'\n"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:34
#, markdown-text, no-wrap
msgid ""
"    readFile(sourceFile, function (error, data) {\n"
"      if (!error) {\n"
"        writeFile(destFile, data, function (error) {\n"
"          if (!error) {\n"
"            console.log(\"File copied\");\n"
"          }\n"
"        });\n"
"      }\n"
"    });\n"
"    ```\n"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:36
#, markdown-text
msgid ""
"Libraries such as [React](https://reactjs.org) and "
"[virtual-dom](https://github.com/Matt-Esch/virtual-dom) model views as pure "
"functions of application state."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:38
#, markdown-text
msgid ""
"Functions enable a simple form of abstraction that can yield great "
"productivity gains. However, functional programming in JavaScript has "
"disadvantages: JavaScript is verbose, untyped, and lacks powerful forms of "
"abstraction. Unrestricted JavaScript code also makes equational reasoning "
"very difficult."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:40
#, markdown-text
msgid ""
"PureScript is a programming language that aims to address these issues. It "
"features lightweight syntax, which allows us to write very expressive code "
"which is still clear and readable. It uses a rich type system to support "
"powerful abstractions. It also generates fast, understandable code, which is "
"important when interoperating with JavaScript or other languages that "
"compile to JavaScript. All in all, I hope to convince you that PureScript "
"strikes a very practical balance between the theoretical power of purely "
"functional programming and the fast-and-loose programming style of "
"JavaScript."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:42
#, markdown-text, no-wrap
msgid ""
"> Note that PureScript can target other backends, not only JavaScript, but "
"this book focuses on targeting web browser and node environments.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:43
#, markdown-text, no-wrap
msgid "Types and Type Inference"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:46
#, markdown-text
msgid ""
"The debate over statically typed languages versus dynamically typed "
"languages is well-documented. PureScript is a _statically typed_ language, "
"meaning that a correct program can be given a _type_ by the compiler, which "
"indicates its behavior. Conversely, programs that cannot be given a type are "
"_incorrect programs_, and will be rejected by the compiler. In PureScript, "
"unlike in dynamically typed languages, types exist only at _compile-time_ "
"and have no representation at runtime."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:48
#, markdown-text
msgid ""
"It is important to note that, in many ways, the types in PureScript are "
"unlike the types that you might have seen in other languages like Java or "
"C#. While they serve the same purpose at a high level, the types in "
"PureScript are inspired by languages like ML and Haskell. PureScript's types "
"are expressive, allowing the developer to assert strong claims about their "
"programs. Most importantly, PureScript's type system supports _type "
"inference_ – it requires far fewer explicit type annotations than other "
"languages, making the type system a _tool_ rather than a hindrance. As a "
"simple example, the following code defines a _number_, but there is no "
"mention of the `Number` type anywhere in the code:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter1.md:49
#, no-wrap
msgid ""
"iAmANumber =\n"
"  let square x = x * x\n"
"  in square 42.0\n"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:56
#, markdown-text
msgid ""
"A more involved example shows that type-correctness can be confirmed without "
"type annotations, even when there exist types that are _unknown to the "
"compiler_:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter1.md:57
#, no-wrap
msgid ""
"iterate f 0 x = x\n"
"iterate f n x = iterate f (n - 1) (f x)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:63
#, markdown-text
msgid ""
"Here, the type of `x` is unknown, but the compiler can still verify that "
"`iterate` obeys the rules of the type system, no matter what type `x` might "
"have."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:65
#, markdown-text
msgid ""
"In this book, I will try to convince you (or reaffirm your belief) that "
"static types are not only a means of gaining confidence in the correctness "
"of your programs, but also an aid to development in their own "
"right. Refactoring a large body of code in JavaScript can be difficult when "
"using any but the simplest of abstractions, but an expressive type system "
"together with a type checker can even make refactoring into an enjoyable, "
"interactive experience."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:67
#, markdown-text
msgid ""
"In addition, the safety net provided by a type system enables more advanced "
"forms of abstraction. In fact, PureScript provides a powerful form of "
"abstraction that is fundamentally type-driven: type classes, made popular in "
"the functional programming language Haskell."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:68
#, markdown-text, no-wrap
msgid "Polyglot Web Programming"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:71
#, markdown-text
msgid ""
"Functional programming has its success stories – applications where it has "
"been particularly successful: data analysis, parsing, compiler "
"implementation, generic programming, parallelism, to name a few."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:73
#, markdown-text
msgid ""
"It would be possible to practice end-to-end application development in a "
"functional language like PureScript. PureScript provides the ability to "
"import existing JavaScript code, by providing types for its values and "
"functions, and then to use those functions in regular PureScript code. We'll "
"see this approach later in the book."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:75
#, markdown-text
msgid ""
"However, one of PureScript's strengths is its interoperability with other "
"languages which target JavaScript. Another approach would be to use "
"PureScript for a subset of your application's development and to use one or "
"more other languages to write the rest of the JavaScript."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:77
#, markdown-text
msgid "Here are some examples:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:81
#, markdown-text
msgid ""
"Core logic written in PureScript, with the user interface written in "
"JavaScript."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:81
#, markdown-text
msgid ""
"Application written in JavaScript or another compile-to-JS language, with "
"tests written in PureScript."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:81
#, markdown-text
msgid ""
"PureScript used to automate user interface tests for an existing "
"application."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:83
#, markdown-text
msgid ""
"In this book, we'll focus on solving small problems with PureScript. The "
"solutions could be integrated into a larger application, but we will also "
"look at how to call PureScript code from JavaScript, and vice versa."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:84
#, markdown-text, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:87
#, markdown-text
msgid ""
"The software requirements for this book are minimal: the first chapter will "
"guide you through setting up a development environment from scratch, and the "
"tools we will use are available in the standard repositories of most modern "
"operating systems."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:89
#, markdown-text
msgid ""
"The PureScript compiler itself can be downloaded as a binary distribution or "
"built from source on any system running an up-to-date installation of the "
"GHC Haskell compiler, and we will walk through this process in the next "
"chapter."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:92
#, markdown-text
msgid ""
"The code in this version of the book is compatible with versions `0.15.*` of "
"the PureScript compiler."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:93
#, markdown-text, no-wrap
msgid "About You"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:96
#, markdown-text
msgid ""
"I will assume that you are familiar with the basics of JavaScript. Any prior "
"familiarity with common tools from the JavaScript ecosystem, such as NPM and "
"Gulp, will be beneficial if you wish to customize the standard setup to your "
"own needs, but such knowledge is not necessary."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:98
#, markdown-text
msgid ""
"No prior knowledge of functional programming is required, but it certainly "
"won't hurt. New ideas will be accompanied by practical examples, so you "
"should be able to form an intuition for the concepts from the functional "
"programming that we will use."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:100
#, markdown-text
msgid ""
"Readers who are familiar with the Haskell programming language will "
"recognize a lot of the ideas and syntax presented in this book because "
"PureScript is heavily influenced by Haskell. However, those readers should "
"understand that there are a number of important differences between "
"PureScript and Haskell. It is not necessarily always appropriate to try to "
"apply ideas from one language in the other, although many of the concepts "
"presented here will have some interpretation in Haskell."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:101
#, markdown-text, no-wrap
msgid "How to Read This Book"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:104
#, markdown-text
msgid ""
"The chapters in this book are largely self-contained. A beginner with little "
"functional programming experience would be well-advised, however, to work "
"through the chapters in order. The first few chapters lay the groundwork "
"required to understand the material later on in the book. A reader who is "
"comfortable with the ideas of functional programming (especially one with "
"experience in a strongly-typed language like ML or Haskell) will probably be "
"able to gain a general understanding of the code in the later chapters of "
"the book without reading the preceding chapters."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:106
#, markdown-text
msgid ""
"Each chapter will focus on a single practical example, providing the "
"motivation for any new ideas introduced. Code for each chapter is available "
"from the book's [GitHub "
"repository](https://github.com/purescript-contrib/purescript-book). Some "
"chapters will include code snippets taken from the chapter's source code, "
"but for a full understanding, you should read the source code from the "
"repository alongside the material from the book. Longer sections will "
"contain shorter snippets which you can execute in the interactive mode PSCi "
"to test your understanding."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:108
#, markdown-text
msgid "Code samples will appear in a monospaced font as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter1.md:109
#, no-wrap
msgid ""
"module Example where\n"
"\n"
"import Effect.Console (log)\n"
"\n"
"main = log \"Hello, World!\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:118
#, markdown-text
msgid ""
"Commands which should be typed at the command line will be preceded by a "
"dollar symbol:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter1.md:119 ../text/chapter3.md:330
#, no-wrap
msgid "$ spago build\n"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:124
#, markdown-text
msgid ""
"Usually, these commands will be tailored to Linux/Mac OS users, so Windows "
"users may need to make small changes, such as modifying the file separator "
"or replacing shell built-ins with their Windows equivalents."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:126
#, markdown-text
msgid ""
"Commands which should be typed at the PSCi interactive mode prompt will be "
"preceded by an angle bracket:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter1.md:127
#, no-wrap
msgid ""
"> 1 + 2\n"
"3\n"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:133
#, markdown-text
msgid ""
"Each chapter will contain exercises labelled with their difficulty level. It "
"is strongly recommended that you attempt the exercises in each chapter to "
"fully understand the material."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:135
#, markdown-text
msgid ""
"This book aims to provide an introduction to the PureScript language for "
"beginners, but it is not the sort of book that provides a list of template "
"solutions to problems. For beginners, this book should be a fun challenge, "
"and you will get the most benefit if you read the material, attempt the "
"exercises, and, most importantly of all, try to write some code of your own."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:136
#, markdown-text, no-wrap
msgid "Getting Help"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:139
#, markdown-text
msgid ""
"If you get stuck at any point, there are a number of resources available "
"online for learning PureScript:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"The [PureScript Discord server](https://discord.gg/vKn9up84bp) is a great "
"place to chat about issues you may be having. The server is dedicated to "
"chatting about PureScript"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"The [PureScript Discourse Forum](https://discourse.purescript.org/) is "
"another good place to search for solutions to common problems."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"[PureScript: Jordan's "
"Reference](https://github.com/jordanmartinez/purescript-jordans-reference)  "
"is an alternative learning resource that goes into great depth. If a concept "
"in this book is difficult to understand, consider reading the corresponding "
"section in that reference."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"[Pursuit](https://pursuit.purescript.org) is a searchable database of "
"PureScript types and functions. Read Pursuit's help page to [learn what "
"kinds of searches you can do](https://pursuit.purescript.org/help/users)."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"The unofficial [PureScript "
"Cookbook](https://github.com/JordanMartinez/purescript-cookbook) provides "
"answers via code to \"How do I do X?\"-type questions."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"The [PureScript documentation "
"repository](https://github.com/purescript/documentation) collects articles "
"and examples on a wide variety of topics written by PureScript developers "
"and users."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"The [PureScript website](https://www.purescript.org) contains links to "
"several learning resources, including code samples, videos, and other "
"resources for beginners."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter1.md:148
#, markdown-text
msgid ""
"[Try PureScript!](https://try.purescript.org) is a website that allows users "
"to compile PureScript code in the web browser and contains several simple "
"examples of code."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:150
#, markdown-text
msgid ""
"If you prefer to learn by reading examples, the "
"[purescript](https://github.com/purescript), "
"[purescript-node](https://github.com/purescript-node), and "
"[purescript-contrib](https://github.com/purescript-contrib) GitHub "
"organizations contain plenty of examples of PureScript code."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:151
#, markdown-text, no-wrap
msgid "About the Author"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:154
#, markdown-text
msgid ""
"I am the original developer of the PureScript compiler. I'm based in Los "
"Angeles, California, and started programming at an early age in BASIC on an "
"8-bit personal computer, the Amstrad CPC. Since then, I have worked "
"professionally in a variety of programming languages (including Java, Scala, "
"C#, F#, Haskell and PureScript)."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:156
#, markdown-text
msgid ""
"Not long into my professional career, I began to appreciate functional "
"programming and its connections with mathematics, and enjoyed learning "
"functional concepts using the Haskell programming language."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:158
#, markdown-text
msgid ""
"I started working on the PureScript compiler in response to my experience "
"with JavaScript. I found myself using functional programming techniques that "
"I had picked up in languages like Haskell, but wanted a more principled "
"environment in which to apply them. Solutions at the time included various "
"attempts to compile Haskell to JavaScript while preserving its semantics "
"(Fay, Haste, GHCJS), but I was interested to see how successful I could be "
"by approaching the problem from the other side – attempting to keep the "
"semantics of JavaScript, while enjoying the syntax and type system of a "
"language like Haskell."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:160
#, markdown-text
msgid ""
"I maintain [a blog](https://blog.functorial.com), and can be [reached on "
"Twitter](https://twitter.com/paf31)."
msgstr ""

#. type: Title ##
#: ../text/chapter1.md:161
#, markdown-text, no-wrap
msgid "Acknowledgements"
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:164
#, markdown-text
msgid ""
"I would like to thank the many contributors who helped PureScript to reach "
"its current state. Without the huge collective effort which has been made on "
"the compiler, tools, libraries, documentation, and tests, the project would "
"certainly have failed."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:166
#, markdown-text
msgid ""
"The PureScript logo which appears on the cover of this book was created by "
"Gareth Hughes and is gratefully reused here under the terms of the [Creative "
"Commons Attribution 4.0 "
"license](https://creativecommons.org/licenses/by/4.0/)."
msgstr ""

#. type: Plain text
#: ../text/chapter1.md:167
#, markdown-text
msgid ""
"Finally, I would like to thank everyone who has given me feedback and "
"corrections on the contents of this book."
msgstr ""

#. type: Title #
#: ../text/chapter10.md:1
#, markdown-text, no-wrap
msgid "The Foreign Function Interface"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:3 ../text/chapter11.md:3 ../text/chapter12.md:3
#: ../text/chapter13.md:3 ../text/chapter14.md:3 ../text/chapter2.md:3
#: ../text/chapter3.md:3 ../text/chapter4.md:5 ../text/chapter5.md:5
#: ../text/chapter6.md:3 ../text/chapter7.md:3 ../text/chapter8.md:3
#: ../text/chapter9.md:3
#, markdown-text, no-wrap
msgid "Chapter Goals"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:6
#, markdown-text
msgid ""
"This chapter will introduce PureScript's _foreign function interface_ (or "
"_FFI_), which enables communication from PureScript code to JavaScript code "
"and vice versa. We will cover how to:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:10
#, markdown-text
msgid "Call pure, effectful, and asynchronous JavaScript functions from PureScript."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:10
#, markdown-text
msgid "Work with untyped data."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:10
#, markdown-text
msgid "Encode and parse JSON using the `argonaut` package."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:12
#, markdown-text
msgid ""
"Towards the end of this chapter, we will revisit our recurring address book "
"example. The goal of the chapter will be to add the following new "
"functionality to our application using the FFI:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:15
#, markdown-text
msgid "Alert the user with a popup notification."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:15
#, markdown-text
msgid ""
"Store the serialized form data in the browser's local storage, and reload it "
"when the application restarts."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:17
#, markdown-text
msgid ""
"There is also an addendum covering some additional topics that are not as "
"commonly sought-after. Feel free to read these sections, but don't let them "
"stand in the way of progressing through the remainder of the book if they're "
"less relevant to your learning objectives:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:20
#, markdown-text
msgid "Understand the representation of PureScript values at runtime."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:20
#, markdown-text
msgid "Call PureScript functions from JavaScript."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:21 ../text/chapter11.md:7 ../text/chapter12.md:7
#: ../text/chapter13.md:9 ../text/chapter14.md:16 ../text/chapter3.md:11
#: ../text/chapter4.md:15 ../text/chapter5.md:13 ../text/chapter6.md:13
#: ../text/chapter7.md:11 ../text/chapter8.md:9 ../text/chapter9.md:7
#, markdown-text, no-wrap
msgid "Project Setup"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:24
#, markdown-text
msgid ""
"The source code for this module is a continuation of the source code from "
"chapters 3, 7, and 8. As such, the source tree includes the appropriate "
"source files from those chapters."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:26
#, markdown-text
msgid ""
"This chapter introduces the `argonaut` library as a dependency. This library "
"is used for encoding and decoding JSON."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:28
#, markdown-text
msgid ""
"The exercises for this chapter should be written in `test/MySolutions.purs` "
"and can be checked against the unit tests in `test/Main.purs` by running "
"`spago test`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:30
#, markdown-text
msgid ""
"The Address Book app can be launched with `parcel src/index.html --open`. It "
"uses the same workflow from Chapter 8, so refer to that chapter for more "
"detailed instructions."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:31
#, markdown-text, no-wrap
msgid "A Disclaimer"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:34
#, markdown-text
msgid ""
"PureScript provides a straightforward foreign function interface to make "
"working with JavaScript as simple as possible. However, it should be noted "
"that the FFI is an _advanced_ feature of the language. To use it safely and "
"effectively, you should understand the runtime representation of the data "
"you plan to work with. This chapter aims to impart such an understanding as "
"pertains to code in PureScript's standard libraries."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:36
#, markdown-text
msgid ""
"PureScript's FFI is designed to be very flexible. In practice, this means "
"that developers have a choice between giving their foreign functions very "
"simple types or using the type system to protect against accidental misuses "
"of foreign code. Code in the standard libraries tends to favor the latter "
"approach."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:38
#, markdown-text
msgid ""
"As a simple example, a JavaScript function makes no guarantees that its "
"return value will not be `null`. Indeed, idiomatic JavaScript code returns "
"`null` quite frequently! However, PureScript's types are usually not "
"inhabited by a null value. Therefore, it is the responsibility of the "
"developer to handle these corner cases appropriately when designing their "
"interfaces to JavaScript code using the FFI."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:39
#, markdown-text, no-wrap
msgid "Calling JavaScript From PureScript"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:42
#, markdown-text
msgid ""
"The simplest way to use JavaScript code from PureScript is to give a type to "
"an existing JavaScript value using a _foreign import_ declaration. Foreign "
"import declarations must have a corresponding JavaScript declaration "
"_exported_ from a _foreign JavaScript module_."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:44
#, markdown-text
msgid ""
"For example, consider the `encodeURIComponent` function, which can be used "
"in JavaScript to encode a component of a URI by escaping special characters:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:45
#, no-wrap
msgid ""
"$ node\n"
"\n"
"node> encodeURIComponent('Hello World')\n"
"'Hello%20World'\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:53
#, markdown-text, no-wrap
msgid ""
"This function has the correct runtime representation for the function type "
"`String -> String`, since it takes non-null strings to non-null strings and "
"has no other side-effects.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:55
#, markdown-text
msgid ""
"We can assign this type to the function with the following foreign import "
"declaration:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:56
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.purs}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:62
#, markdown-text
msgid ""
"We also need to write a foreign JavaScript module to import it from. A "
"corresponding foreign JavaScript module is one of the same name but the "
"extension changed from `.purs` to `.js`. If the PureScript module above is "
"saved as `URI.purs`, then the foreign JavaScript module is saved as "
"`URI.js`.  Since `encodeURIComponent` is already defined, we have to export "
"it as `_encodeURIComponent`:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:63
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.js}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:68
#, markdown-text
msgid ""
"Since version 0.15, PureScript uses the ES module system when interoperating "
"with JavaScript. In ES modules, functions and values are exported from a "
"module by providing the `export` keyword on an object."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:70
#, markdown-text
msgid ""
"With these two pieces in place, we can now use the `_encodeURIComponent` "
"function from PureScript like any function written in PureScript. For "
"example, in PSCi, we can reproduce the calculation above:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:71
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.URI\n"
"> _encodeURIComponent \"Hello World\"\n"
"\"Hello%20World\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:80
#, markdown-text
msgid ""
"We can also define our own functions in foreign modules. Here's an example "
"of how to create and call a custom JavaScript function that squares a "
"`Number`:"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:82
#, markdown-text
msgid "`test/Examples.js`:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:83
#, no-wrap
msgid ""
"\"use strict\";\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.js:square}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:90
#, markdown-text
msgid "`test/Examples.purs`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:91
#, no-wrap
msgid ""
"module Test.Examples where\n"
"\n"
"foreign import square :: Number -> Number\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:97
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> square 5.0\n"
"25.0\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:105
#, markdown-text, no-wrap
msgid "Functions of Multiple Arguments"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:108
#, markdown-text
msgid ""
"Let's rewrite our `diagonal` function from Chapter 2 in a foreign "
"module. This function calculates the diagonal of a right-angled triangle."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:109
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:114
#, markdown-text
msgid ""
"Recall that functions in PureScript are _curried_. `diagonal` is a function "
"that takes a `Number` and returns a _function_ that takes a `Number` and "
"returns a `Number`."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:115
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:120
#, markdown-text
msgid "Or with ES6 arrow syntax (see ES6 note below)."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:121
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_arrow}}\n"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:125
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_arrow}}\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:129
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> diagonal 3.0 4.0\n"
"5.0\n"
"> diagonalArrow 3.0 4.0\n"
"5.0\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:139
#, markdown-text, no-wrap
msgid "Uncurried Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:142
#, markdown-text
msgid ""
"Writing curried functions in JavaScript isn't always feasible, despite being "
"scarcely idiomatic. A typical multi-argument JavaScript function would be of "
"the _uncurried_ form:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:143
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_uncurried}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:148
#, markdown-text
msgid ""
"The module `Data.Function.Uncurried` exports _wrapper_ types and utility "
"functions to work with uncurried functions."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:149
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_uncurried}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:154
#, markdown-text
msgid "Inspecting the type constructor `Fn2`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:155
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Function.Uncurried \n"
"> :kind Fn2\n"
"Type -> Type -> Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:164
#, markdown-text
msgid ""
"`Fn2` takes three type arguments. `Fn2 a b c` is a type representing an "
"uncurried function of two arguments of types `a` and `b`, that returns a "
"value of type `c`. We used it to import `diagonalUncurried` from the foreign "
"module."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:166
#, markdown-text
msgid ""
"We can then call it with `runFn2`, which takes the uncurried function and "
"then the arguments."
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:167
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Function.Uncurried\n"
"> runFn2 diagonalUncurried 3.0 4.0\n"
"5.0\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:177
#, markdown-text
msgid ""
"The `functions` package defines similar type constructors for function "
"arities from 0 to 10."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:178
#, markdown-text, no-wrap
msgid "A Note About Uncurried Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:181
#, markdown-text
msgid ""
"PureScript's curried functions have certain advantages. It allows us to "
"partially apply functions, and to give type class instances for function "
"types – but it comes with a performance penalty. For performance-critical "
"code, it is sometimes necessary to define uncurried JavaScript functions "
"which accept multiple arguments."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:183
#, markdown-text
msgid ""
"We can also create uncurried functions from PureScript. For a function of "
"two arguments, we can use the `mkFn2` function."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:184
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_add}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:189
#, markdown-text
msgid ""
"We can apply the uncurried function of two arguments by using `runFn2` as "
"before:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:190
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_sum}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:195
#, markdown-text
msgid ""
"The key here is that the compiler _inlines_ the `mkFn2` and `runFn2` "
"functions whenever they are fully applied. The result is that the generated "
"code is very compact:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:196
#, no-wrap
msgid ""
"var uncurriedAdd = function (n, m) {\n"
"  return m + n | 0;\n"
"};\n"
"\n"
"var uncurriedSum = uncurriedAdd(3, 10);\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:205
#, markdown-text
msgid "For contrast, here is a traditional curried function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:curried_add}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:211
#, markdown-text
msgid ""
"And the resulting generated code, which is less compact due to the nested "
"functions:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:212
#, no-wrap
msgid ""
"var curriedAdd = function (n) {\n"
"  return function (m) {\n"
"    return m + n | 0;\n"
"  };\n"
"};\n"
"\n"
"var curriedSum = curriedAdd(3)(10);\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:222
#, markdown-text, no-wrap
msgid "A Note About Modern JavaScript Syntax"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:225
#, markdown-text
msgid ""
"The arrow function syntax we saw earlier is an ES6 feature, which is "
"incompatible with some older browsers (namely IE11). As of writing, it is "
"[estimated that arrow functions are unavailable for the 6% of "
"users](https://caniuse.com/#feat=arrow-functions) who have not yet updated "
"their web browser."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:227
#, markdown-text
msgid ""
"To be compatible with the most users, the JavaScript code generated by the "
"PureScript compiler does not use arrow functions. It is also recommended to "
"**avoid arrow functions in public libraries** for the same reason."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:229
#, markdown-text
msgid ""
"You may still use arrow functions in your own FFI code, but then you should "
"include a tool such as [Babel](https://github.com/babel/babel#intro) in your "
"deployment workflow to convert these back to ES5 compatible functions."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:231
#, markdown-text
msgid ""
"If you find arrow functions in ES6 more readable, you may transform "
"JavaScript code in the compiler's `output` directory with a tool like "
"[Lebab](https://github.com/lebab/lebab):"
msgstr ""

#. type: Fenced code block (sh)
#: ../text/chapter10.md:232
#, no-wrap
msgid ""
"npm i -g lebab\n"
"lebab --replace output/ --transform arrow,arrow-return\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:238
#, markdown-text
msgid "This operation would convert the above `curriedAdd` function to:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:239
#, no-wrap
msgid ""
"var curriedAdd = n => m =>\n"
"  m + n | 0;\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:245
#, markdown-text
msgid ""
"The remaining examples in this book will use arrow functions instead of "
"nested functions."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:246 ../text/chapter10.md:321 ../text/chapter10.md:478
#: ../text/chapter10.md:716 ../text/chapter10.md:893 ../text/chapter10.md:1076
#: ../text/chapter10.md:1313 ../text/chapter11.md:141 ../text/chapter11.md:223
#: ../text/chapter11.md:342 ../text/chapter11.md:548 ../text/chapter11.md:715
#: ../text/chapter11.md:914 ../text/chapter11.md:959 ../text/chapter12.md:153
#: ../text/chapter12.md:361 ../text/chapter12.md:555 ../text/chapter13.md:90
#: ../text/chapter13.md:137 ../text/chapter13.md:244 ../text/chapter13.md:387
#: ../text/chapter14.md:249 ../text/chapter14.md:352 ../text/chapter14.md:569
#: ../text/chapter14.md:704 ../text/chapter2.md:123 ../text/chapter3.md:774
#: ../text/chapter4.md:101 ../text/chapter4.md:230 ../text/chapter4.md:394
#: ../text/chapter4.md:467 ../text/chapter4.md:526 ../text/chapter5.md:72
#: ../text/chapter5.md:183 ../text/chapter5.md:373 ../text/chapter5.md:531
#: ../text/chapter5.md:625 ../text/chapter6.md:168 ../text/chapter6.md:359
#: ../text/chapter6.md:449 ../text/chapter6.md:646 ../text/chapter6.md:780
#: ../text/chapter7.md:381 ../text/chapter7.md:540 ../text/chapter7.md:642
#: ../text/chapter8.md:308 ../text/chapter8.md:667 ../text/chapter8.md:974
#: ../text/chapter9.md:87 ../text/chapter9.md:134 ../text/chapter9.md:201
#, markdown-text, no-wrap
msgid "Exercises"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:250
#, markdown-text
msgid ""
"(Medium) Write a JavaScript function `volumeFn` in the `Test.MySolutions` "
"module that finds the volume of a box. Use an `Fn` wrapper from "
"`Data.Function.Uncurried`."
msgstr ""

#. type: Bullet: '2. '
#: ../text/chapter10.md:250
#, markdown-text
msgid "(Medium) Rewrite `volumeFn` with arrow functions as `volumeArrow`."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:251
#, markdown-text, no-wrap
msgid "Passing Simple Types"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:254
#, markdown-text
msgid ""
"The following data types may be passed between PureScript and JavaScript "
"as-is:"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:262
#, markdown-text
msgid ""
"PureScript | JavaScript --- | --- Boolean | Boolean String | String Int, "
"Number | Number Array | Array Record | Object"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:264
#, markdown-text
msgid ""
"We've already seen examples with the primitive types `String` and "
"`Number`. We'll now take a look at the structural types `Array` and `Record` "
"(`Object` in JavaScript)."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:266
#, markdown-text
msgid ""
"To demonstrate passing `Array`s, here's how to call a JavaScript function "
"that takes an `Array` of `Int` and returns the cumulative sum as another "
"array. Recall that since JavaScript does not have a separate type for `Int`, "
"both `Int` and `Number` in PureScript translate to `Number` in JavaScript."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:267
#, no-wrap
msgid "foreign import cumulativeSums :: Array Int -> Array Int\n"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:271
#, no-wrap
msgid ""
"export const cumulativeSums = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  return sums;\n"
"};\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:283
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> cumulativeSums [1, 2, 3]\n"
"[1,3,6]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:292
#, markdown-text
msgid ""
"To demonstrate passing `Records`, here's how to call a JavaScript function "
"that takes two `Complex` numbers as records and returns their sum as another "
"record. Note that a `Record` in PureScript is represented as an `Object` in "
"JavaScript:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:293
#, no-wrap
msgid ""
"type Complex = {\n"
"  real :: Number,\n"
"  imag :: Number\n"
"}\n"
"\n"
"foreign import addComplex :: Complex -> Complex -> Complex\n"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:302
#, no-wrap
msgid ""
"export const addComplex = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    imag: a.imag + b.imag\n"
"  }\n"
"};\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:311
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"{ imag: 6.0, real: 4.0 }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:320
#, markdown-text
msgid ""
"Note that the above techniques require trusting that JavaScript will return "
"the expected types, as PureScript cannot apply type checking to JavaScript "
"code. We will describe this type safety concern in more detail later on in "
"the JSON section, as well as cover techniques to protect against type "
"mismatches."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:324
#, markdown-text
msgid ""
"(Medium) Write a JavaScript function `cumulativeSumsComplex` (and "
"corresponding PureScript foreign import) that takes an `Array` of `Complex` "
"numbers and returns the cumulative sum as another array of complex numbers."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:325
#, markdown-text, no-wrap
msgid "Beyond Simple Types"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:328
#, markdown-text
msgid ""
"We have seen examples of how to send and receive types with a native "
"JavaScript representation, such as `String`, `Number`, `Array`, and "
"`Record`, over FFI. Now we'll cover how to use some of the other types "
"available in PureScript, like `Maybe`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:330
#, markdown-text
msgid ""
"Suppose we wanted to recreate the `head` function on arrays by using a "
"foreign declaration. In JavaScript, we might write the function as follows:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:331
#, no-wrap
msgid ""
"export const head = arr =>\n"
"  arr[0];\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:337
#, markdown-text, no-wrap
msgid ""
"How would we type this function? We might try to give it the type `forall "
"a. Array a -> a`, but for empty arrays, this function returns "
"`undefined`. Therefore, the type `forall a. Array a -> a` does not correctly "
"represent this implementation.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:339
#, markdown-text
msgid "We instead want to return a `Maybe` value to handle this corner case:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:340
#, no-wrap
msgid "foreign import maybeHead :: forall a. Array a -> Maybe a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:345
#, markdown-text
msgid "But how do we return a `Maybe`? It is tempting to write the following:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:346
#, no-wrap
msgid ""
"// Don't do this\n"
"import Data_Maybe from '../Data.Maybe'\n"
"\n"
"export const maybeHead = arr => {\n"
"  if (arr.length) {\n"
"    return Data_Maybe.Just.create(arr[0]);\n"
"  } else {\n"
"    return Data_Maybe.Nothing.value;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:360
#, markdown-text
msgid ""
"Importing and using the `Data.Maybe` module directly in the foreign module "
"isn't recommended as it makes our code brittle to changes in the code "
"generator &mdash; `create` and `value` are not public APIs. Additionally, "
"doing this can cause problems when using `purs bundle` for dead code "
"elimination."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:362
#, markdown-text
msgid ""
"The recommended approach is to add extra parameters to our FFI-defined "
"function to accept the functions we need."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:363
#, no-wrap
msgid ""
"export const maybeHeadImpl = just => nothing => arr => {\n"
"  if (arr.length) {\n"
"    return just(arr[0]);\n"
"  } else {\n"
"    return nothing;\n"
"  }\n"
"};\n"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:373
#, no-wrap
msgid ""
"foreign import maybeHeadImpl :: forall a. (forall x. x -> Maybe x) -> "
"(forall x. Maybe x) -> Array a -> Maybe a\n"
"\n"
"maybeHead :: forall a. Array a -> Maybe a\n"
"maybeHead arr = maybeHeadImpl Just Nothing arr\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:381
#, markdown-text
msgid "Note that we wrote:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:382
#, no-wrap
msgid ""
"forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> "
"Maybe a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:387
#, markdown-text
msgid "And not:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:388
#, no-wrap
msgid "forall a. (a -> Maybe a) -> Maybe a -> Array a -> Maybe a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:393
#, markdown-text
msgid ""
"While both forms work, the latter is more vulnerable to unwanted inputs in "
"place of `Just` and `Nothing`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:395
#, markdown-text
msgid "For example, in the more vulnerable case, we could call it as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:396
#, no-wrap
msgid "maybeHeadImpl (\\_ -> Just 1000) (Just 1000) [1,2,3]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:401
#, markdown-text
msgid "Which returns `Just 1000` for any array input."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:403
#, markdown-text, no-wrap
msgid ""
"This vulnerability is allowed because `(\\_ -> Just 1000)` and `Just 1000` "
"match the signatures of `(a -> Maybe a)` and `Maybe a`, respectively, when "
"`a` is `Int` (based on input array).\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:406
#, markdown-text, no-wrap
msgid ""
"In the more secure type signature, even when `a` is determined to be `Int` "
"based on the input array, we still need to provide valid functions matching "
"the signatures involving `forall x`.\n"
"The _only_ option for `(forall x. Maybe x)` is `Nothing`, since a `Just` "
"value would assume a type for `x` and will no longer be valid for all "
"`x`. The only options for `(forall x. x -> Maybe x)` are `Just` (our desired "
"argument) and `(\\_ -> Nothing)`, which is the only remaining "
"vulnerability.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:407
#, markdown-text, no-wrap
msgid "Defining Foreign Types"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:410
#, markdown-text
msgid ""
"Suppose instead of returning a `Maybe a`, we want to return `arr[0]`. We "
"want a type that represents a value either of type `a` or the `undefined` "
"value (but not `null`). We'll call this type `Undefined a`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:412
#, markdown-text
msgid ""
"We can define a _foreign type_ using a _foreign type declaration_. The "
"syntax is similar to defining a foreign function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:413
#, no-wrap
msgid "foreign import data Undefined :: Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:418
#, markdown-text, no-wrap
msgid ""
"The `data` keyword here indicates that we are defining a _type_, not a "
"value. Instead of a type signature, we give the _kind_ of the new type. In "
"this case, we declare the kind of `Undefined` to be `Type -> Type`. In other "
"words, `Undefined` is a type constructor.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:420
#, markdown-text
msgid "We can now reuse our original definition for `head`:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:421
#, no-wrap
msgid ""
"export const undefinedHead = arr =>\n"
"  arr[0];\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:427
#, markdown-text
msgid "And in the PureScript module:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:428
#, no-wrap
msgid "foreign import undefinedHead :: forall a. Array a -> Undefined a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:433
#, markdown-text
msgid ""
"The body of the `undefinedHead` function returns `arr[0]`, which may be "
"`undefined`, and the type signature correctly reflects that fact."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:435
#, markdown-text
msgid ""
"This function has the correct runtime representation for its type, but it's "
"quite useless since we have no way to use a value of type `Undefined "
"a`. Well, not exactly. We can use this type in another FFI!"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:437
#, markdown-text
msgid ""
"We can write a function that will tell us whether a value is undefined or "
"not:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:438
#, no-wrap
msgid "foreign import isUndefined :: forall a. Undefined a -> Boolean\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:443
#, markdown-text
msgid "This is defined in our foreign JavaScript module as follows:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:444
#, no-wrap
msgid ""
"export const isUndefined = value =>\n"
"  value === undefined;\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:450
#, markdown-text
msgid ""
"We can now use `isUndefined` and `undefinedHead` together from PureScript to "
"define a useful function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:451
#, no-wrap
msgid ""
"isEmpty :: forall a. Array a -> Boolean\n"
"isEmpty = isUndefined <<< undefinedHead\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:457
#, markdown-text
msgid ""
"Here, the foreign function we defined is very simple, which means we can "
"benefit from using PureScript's typechecker as much as possible. This is "
"good practice in general: foreign functions should be kept as small as "
"possible, and application logic moved into PureScript code wherever "
"possible."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:458 ../text/chapter8.md:365 ../text/chapter8.md:444
#, markdown-text, no-wrap
msgid "Exceptions"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:461
#, markdown-text
msgid ""
"Another option is to simply throw an exception in the case of an empty "
"array. Strictly speaking, pure functions should not throw exceptions, but we "
"have the flexibility to do so. We indicate the lack of safety in the "
"function name:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:462
#, no-wrap
msgid "foreign import unsafeHead :: forall a. Array a -> a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:467
#, markdown-text
msgid "In our foreign JavaScript module, we can define `unsafeHead` as follows:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:468
#, no-wrap
msgid ""
"export const unsafeHead = arr => {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:481
#, markdown-text
msgid ""
"(Medium) Given a record that represents a quadratic polynomial \\\\( a x ^ 2 "
"+ b x + c = 0 \\\\):"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:489
#, markdown-text, no-wrap
msgid ""
"    ```hs\n"
"    type Quadratic = {\n"
"      a :: Number,\n"
"      b :: Number,\n"
"      c :: Number\n"
"    }\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:491
#, markdown-text, no-wrap
msgid ""
"    Write a JavaScript function `quadraticRootsImpl` and a wrapper "
"`quadraticRoots :: Quadratic -> Pair Complex` that uses the quadratic "
"formula to find the roots of this polynomial. Return the two roots as a "
"`Pair` of `Complex` numbers. _Hint:_ Use the `quadraticRoots` wrapper to "
"pass a constructor for `Pair` to `quadraticRootsImpl`.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:493
#, markdown-text
msgid ""
"(Medium) Write the function `toMaybe :: forall a. Undefined a -> Maybe "
"a`. This function converts `undefined` to `Nothing` and `a` values to "
"`Just`s."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:495
#, markdown-text
msgid "(Difficult) With `toMaybe` in place, we can rewrite `maybeHead` as"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:500
#, markdown-text, no-wrap
msgid ""
"    ```hs\n"
"    maybeHead :: forall a. Array a -> Maybe a\n"
"    maybeHead = toMaybe <<< undefinedHead\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:502
#, markdown-text, no-wrap
msgid ""
"    Is this a better approach than our previous implementation? _Note:_ "
"There is no unit test for this exercise.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:503
#, markdown-text, no-wrap
msgid "Using Type Class Member Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:506
#, markdown-text
msgid ""
"Like our earlier guide on passing the `Maybe` constructor over FFI, this is "
"another case of writing PureScript that calls JavaScript, which calls "
"PureScript functions again. Here we will explore how to pass type class "
"member functions over the FFI."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:508
#, markdown-text
msgid ""
"We start with writing a foreign JavaScript function that expects the "
"appropriate instance of `show` to match the type of `x`."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:509
#, no-wrap
msgid ""
"export const boldImpl = show => x =>\n"
"  show(x).toUpperCase() + \"!!!\";\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:515
#, markdown-text
msgid "Then we write the matching signature:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:516
#, no-wrap
msgid "foreign import boldImpl :: forall a. (a -> String) -> a -> String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:521
#, markdown-text
msgid "And a wrapper function that passes the correct instance of `show`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:522
#, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold x = boldImpl show x\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:528
#, markdown-text
msgid "Alternatively, in point-free form:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:529
#, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold = boldImpl show\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:535
#, markdown-text
msgid "We can then call the wrapper:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:536
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> bold (Tuple 1 \"Hat\")\n"
"\"(TUPLE 1 \\\"HAT\\\")!!!\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:546
#, markdown-text
msgid ""
"Here's another example demonstrating passing multiple functions, including a "
"function of multiple arguments (`eq`):"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:547
#, no-wrap
msgid ""
"export const showEqualityImpl = eq => show => a => b => {\n"
"  if (eq(a)(b)) {\n"
"    return \"Equivalent\";\n"
"  } else {\n"
"    return show(a) + \" is not equal to \" + show(b);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:557
#, no-wrap
msgid ""
"foreign import showEqualityImpl :: forall a. (a -> a -> Boolean) -> (a -> "
"String) -> a -> a -> String\n"
"\n"
"showEquality :: forall a. Eq a => Show a => a -> a -> String\n"
"showEquality = showEqualityImpl eq show\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:564
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Maybe\n"
"> showEquality Nothing (Just 5)\n"
"\"Nothing is not equal to (Just 5)\"\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:573
#, markdown-text, no-wrap
msgid "Effectful Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:576
#, markdown-text
msgid ""
"Let's extend our `bold` function to log to the console. Logging is an "
"`Effect`, and `Effect`s are represented in JavaScript as a function of zero "
"arguments, `()` with arrow notation:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:577
#, no-wrap
msgid ""
"export const yellImpl = show => x => () =>\n"
"  console.log(show(x).toUpperCase() + \"!!!\");\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:583
#, markdown-text
msgid ""
"The new foreign import is the same as before, except that the return type "
"changed from `String` to `Effect Unit`."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:584
#, no-wrap
msgid ""
"foreign import yellImpl :: forall a. (a -> String) -> a -> Effect Unit\n"
"\n"
"yell :: forall a. Show a => a -> Effect Unit\n"
"yell = yellImpl show\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:592
#, markdown-text
msgid ""
"When testing this in the repl, notice that the string is printed directly to "
"the console (instead of being quoted), and a `unit` value is returned."
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:593
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> yell (Tuple 1 \"Hat\")\n"
"(TUPLE 1 \"HAT\")!!!\n"
"unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:604
#, markdown-text
msgid ""
"There are also `EffectFn` wrappers from `Effect.Uncurried`. These are "
"similar to the `Fn` wrappers from `Data.Function.Uncurried` that we've "
"already seen. These wrappers let you call uncurried effectful functions in "
"PureScript."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:606
#, markdown-text
msgid ""
"You'd generally only use these if you want to call existing JavaScript "
"library APIs directly rather than wrapping those APIs in curried "
"functions. So it doesn't make much sense to present an example of uncurried "
"`yell`, where the JavaScript relies on PureScript type class members since "
"you wouldn't find that in the existing JavaScript ecosystem."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:608
#, markdown-text
msgid ""
"Instead, we'll modify our previous `diagonal` example to include logging in "
"addition to returning the result:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:609
#, no-wrap
msgid ""
"export const diagonalLog = function(w, h) {\n"
"  let result = Math.sqrt(w * w + h * h);\n"
"  console.log(\"Diagonal is \" + result);\n"
"  return result;\n"
"};\n"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:617
#, no-wrap
msgid "foreign import diagonalLog :: EffectFn2 Number Number Number\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:621
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Effect.Uncurried\n"
"> runEffectFn2 diagonalLog 3.0 4.0\n"
"Diagonal is 5\n"
"5.0\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:631
#, markdown-text, no-wrap
msgid "Asynchronous Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:634
#, markdown-text
msgid ""
"Promises in JavaScript translate directly to asynchronous effects in "
"PureScript with the help of the `aff-promise` library. See that library's "
"[documentation](https://pursuit.purescript.org/packages/purescript-aff-promise) "
"for more information. We'll just go through a few examples."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:636
#, markdown-text
msgid ""
"Suppose we want to use this JavaScript `wait` promise (or asynchronous "
"function) in our PureScript project. It may be used to delay execution for "
"`ms` milliseconds."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:637
#, no-wrap
msgid "const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:642
#, markdown-text
msgid ""
"We just need to export it wrapped as an `Effect` (function of zero "
"arguments):"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:643
#, no-wrap
msgid ""
"export const sleepImpl = ms => () =>\n"
"  wait(ms);\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:649
#, markdown-text
msgid "Then import it as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:650
#, no-wrap
msgid ""
"foreign import sleepImpl :: Int -> Effect (Promise Unit)\n"
"\n"
"sleep :: Int -> Aff Unit\n"
"sleep = sleepImpl >>> toAffE\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:658
#, markdown-text
msgid "We can then run this `Promise` in an `Aff` block like so:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:659
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Test.Examples\n"
"> import Effect.Class.Console\n"
"> import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   log \"waiting\"\n"
"…   sleep 300\n"
"…   log \"done waiting\"\n"
"…\n"
"waiting\n"
"unit\n"
"done waiting\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:678
#, markdown-text
msgid ""
"Note that asynchronous logging in the repl waits to print until the entire "
"block has finished executing. This code behaves more predictably when run "
"with `spago test` where there is a slight delay _between_ prints."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:680
#, markdown-text
msgid ""
"Let's look at another example where we return a value from a promise. This "
"function is written with `async` and `await`, which is just syntactic sugar "
"for promises."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:681
#, no-wrap
msgid ""
"async function diagonalWait(delay, w, h) {\n"
"  await wait(delay);\n"
"  return Math.sqrt(w * w + h * h);\n"
"}\n"
"\n"
"export const diagonalAsyncImpl = delay => w => h => () =>\n"
"  diagonalWait(delay, w, h);\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:692
#, markdown-text
msgid ""
"Since we're returning a `Number`, we represent this type in the `Promise` "
"and `Aff` wrappers:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:693
#, no-wrap
msgid ""
"foreign import diagonalAsyncImpl :: Int -> Number -> Number -> Effect "
"(Promise Number)\n"
"\n"
"diagonalAsync :: Int -> Number -> Number -> Aff Number\n"
"diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:700
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"import Prelude\n"
"import Test.Examples\n"
"import Effect.Class.Console\n"
"import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   res <- diagonalAsync 300 3.0 4.0\n"
"…   logShow res\n"
"…\n"
"unit\n"
"5.0\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:719
#, markdown-text
msgid ""
"Exercises for the above sections are still on the ToDo list. If you have any "
"ideas for good exercises, please make a suggestion."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:720
#, markdown-text, no-wrap
msgid "JSON"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:723
#, markdown-text
msgid ""
"There are many reasons to use JSON in an application; for example, it's a "
"common means of communicating with web APIs. This section will discuss other "
"use-cases, too, beginning with a technique to improve type safety when "
"passing structural data over the FFI."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:725
#, markdown-text
msgid ""
"Let's revisit our earlier FFI functions `cumulativeSums` and `addComplex` "
"and introduce a bug to each:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:726
#, no-wrap
msgid ""
"export const cumulativeSumsBroken = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  sums.push(\"Broken\"); // Bug\n"
"  return sums;\n"
"};\n"
"\n"
"export const addComplexBroken = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    broken: a.imag + b.imag // Bug\n"
"  }\n"
"};\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:747
#, markdown-text
msgid ""
"We can use the original type signatures, and the code will still compile, "
"despite the incorrect return types."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:748
#, no-wrap
msgid ""
"foreign import cumulativeSumsBroken :: Array Int -> Array Int\n"
"\n"
"foreign import addComplexBroken :: Complex -> Complex -> Complex\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:755
#, markdown-text
msgid ""
"We can even execute the code, which might either produce unexpected results "
"or a runtime error:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:756
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Foldable (sum)\n"
"\n"
"> sums = cumulativeSumsBroken [1, 2, 3]\n"
"> sums\n"
"[1,3,6,Broken]\n"
"> sum sums\n"
"0\n"
"\n"
"> complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 "
"}\n"
"> complex.real\n"
"4.0\n"
"> complex.imag + 1.0\n"
"NaN\n"
"> complex.imag\n"
"  var str = n.toString();\n"
"              ^\n"
"TypeError: Cannot read property 'toString' of undefined\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:780
#, markdown-text
msgid ""
"For example, our resulting `sums` is no-longer a valid `Array Int`, now that "
"a `String` is included in the Array. And further operations produce "
"unexpected behavior, rather than an outright error, as the `sum` of these "
"`sums` is `0` rather than `10`. This could be a difficult bug to track down!"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:782
#, markdown-text
msgid ""
"Likewise, there are no errors when calling `addComplexBroken`; however, "
"accessing the `imag` field of our `Complex` result will either produce "
"unexpected behavior (returning `NaN` instead of `7.0`), or a non-obvious "
"runtime error."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:784
#, markdown-text
msgid ""
"Let's use JSON to make our PureScript code more impervious to bugs in "
"JavaScript code."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:786
#, markdown-text
msgid ""
"The `argonaut` library contains the JSON decoding and encoding capabilities "
"we need. That library has excellent "
"[documentation](https://github.com/purescript-contrib/purescript-argonaut#documentation), "
"so we will only cover basic usage in this book."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:788
#, markdown-text
msgid ""
"If we create an alternate foreign import that defines the return type as "
"`Json`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:789
#, no-wrap
msgid ""
"foreign import cumulativeSumsJson :: Array Int -> Json\n"
"foreign import addComplexJson :: Complex -> Complex -> Json\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:795
#, markdown-text
msgid "Note that we're simply pointing to our existing broken functions:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:796
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSumsBroken\n"
"export const addComplexJson = addComplexBroken\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:802
#, markdown-text
msgid "And then write a wrapper to decode the returned foreign `Json` value:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:803
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter10/test/Examples.purs:cumulativeSumsDecoded}}\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.purs:addComplexDecoded}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:810
#, markdown-text
msgid ""
"Then any values that can't be successfully decoded to our return type appear "
"as a `Left` error `String`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:811
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Left \"Couldn't decode Array (Failed at index 3): Value is not a "
"Number\")\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Left \"JSON was missing expected field: imag\")\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:824
#, markdown-text
msgid "If we call the working versions, a `Right` value is returned."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:826
#, markdown-text
msgid ""
"Try this yourself by modifying `test/Examples.js` with the following change "
"to point to the working versions before running the next repl block."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:827
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSums\n"
"export const addComplexJson = addComplex\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:832
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Right [1,3,6])\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Right { imag: 6.0, real: 4.0 })\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:845
#, markdown-text
msgid ""
"Using JSON is also the easiest way to pass other structural types, such as "
"`Map` and `Set`, through the FFI. Since JSON only consists of booleans, "
"numbers, strings, arrays, and objects of other JSON values, we can't write a "
"`Map` and `Set` directly in JSON. But we can represent these structures as "
"arrays (assuming the keys and values can also be represented in JSON) and "
"then decode them back to `Map` or `Set`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:847
#, markdown-text
msgid ""
"Here's an example of a foreign function signature that modifies a `Map` of "
"`String` keys and `Int` values, along with the wrapper function that handles "
"JSON encoding and decoding."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:848
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:mapSetFooJson}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:853
#, markdown-text
msgid ""
"Note that this is a prime use case for function composition. Both of these "
"alternatives are equivalent to the above:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:854
#, no-wrap
msgid ""
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = decodeJson <<< mapSetFooJson <<< encodeJson\n"
"\n"
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = encodeJson >>> mapSetFooJson >>> decodeJson\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:863
#, markdown-text
msgid ""
"Here is the JavaScript implementation. Note the `Array.from` step, which is "
"necessary to convert the JavaScript `Map` into a JSON-friendly format before "
"decoding converts it back to a PureScript `Map`."
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:864
#, no-wrap
msgid ""
"export const mapSetFooJson = j => {\n"
"  let m = new Map(j);\n"
"  m.set(\"Foo\", 42);\n"
"  return Array.from(m);\n"
"};\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:873
#, markdown-text
msgid "Now we can send and receive a `Map` over the FFI:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:874
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Map\n"
"> import Data.Tuple\n"
"\n"
"> myMap = fromFoldable [ Tuple \"hat\" 1, Tuple \"cat\" 2 ]\n"
"\n"
"> :type myMap\n"
"Map String Int\n"
"\n"
"> myMap\n"
"(fromFoldable [(Tuple \"cat\" 2),(Tuple \"hat\" 1)])\n"
"\n"
"> mapSetFoo myMap\n"
"(Right (fromFoldable [(Tuple \"Foo\" 42),(Tuple \"cat\" 2),(Tuple \"hat\" "
"1)]))\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:902
#, markdown-text
msgid ""
"(Medium) Write a JavaScript function and PureScript wrapper `valuesOfMap :: "
"Map String Int -> Either JsonDecodeError (Set Int)` that returns a `Set` of "
"all the values in a `Map`. _Hint_: The `.values()` instance method for Map "
"may be useful in your JavaScript code."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:902
#, markdown-text
msgid ""
"(Easy) Write a new wrapper for the previous JavaScript function with the "
"signature `valuesOfMapGeneric :: forall k v. Map k v -> Either "
"JsonDecodeError (Set v)` so it works with a wider variety of maps. Note that "
"you'll need to add some type class constraints for `k` and `v`. The compiler "
"will guide you."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter10.md:902
#, markdown-text
msgid ""
"(Medium) Rewrite the earlier `quadraticRoots` function as "
"`quadraticRootsSet` that returns the `Complex` roots as a `Set` via JSON "
"(instead of as a `Pair`)."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:902
#, markdown-text, no-wrap
msgid ""
"1. (Difficult) Rewrite the earlier `quadraticRoots` function as "
"`quadraticRootsSafe` that uses JSON to pass the `Pair` of `Complex` roots "
"over FFI. Don't use the `Pair` constructor in JavaScript, but instead, just "
"return the pair in a decoder-compatible format.\n"
"_Hint_: You'll need to write a `DecodeJson` instance for `Pair`. Consult the "
"[argonaut "
"docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances) "
"for instruction on writing your own decode instance. Their "
"[decodeJsonTuple](https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs) "
"instance may also be a helpful reference.  Note that you'll need a `newtype` "
"wrapper for `Pair` to avoid creating an \"orphan instance\".\n"
"1. (Medium) Write a `parseAndDecodeArray2D :: String -> Either String (Array "
"(Array Int))` function to parse and decode a JSON string containing a 2D "
"array, such as `\"[[1, 2, 3], [4, 5], [6]]\"`. _Hint_: You'll need to use "
"`jsonParser` to convert the `String` into `Json` before decoding.\n"
"1. (Medium) The following data type represents a binary tree with values at "
"the leaves:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:908
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a\n"
"       = Leaf a\n"
"       | Branch (Tree a) (Tree a)\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:913
#, markdown-text, no-wrap
msgid ""
"     Derive generic `EncodeJson` and `DecodeJson` instances for the `Tree` "
"type.\n"
"     Consult the [argonaut "
"docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics) "
"for instructions on how to do this.\n"
"     Note that you'll also need generic instances of `Show` and `Eq` to "
"enable unit testing for this exercise, but those should be straightforward "
"to implement after tackling the JSON instances.\n"
"1. (Difficult) The following `data` type should be represented directly in "
"JSON as either an integer or a string:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:919
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     data IntOrString\n"
"       = IntOrString_Int Int\n"
"       | IntOrString_String String\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:921
#, markdown-text, no-wrap
msgid ""
"     Write instances of `EncodeJson` and `DecodeJson` for the `IntOrString` "
"data type which implement this behavior. _Hint_: The `alt` operator from "
"`Control.Alt` may be helpful.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:922
#, markdown-text, no-wrap
msgid "Address book"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:925
#, markdown-text
msgid ""
"In this section, we will apply our newly-acquired FFI and JSON knowledge to "
"build on our address book example from Chapter 8. We will add the following "
"features:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:929
#, markdown-text
msgid ""
"A Save button at the bottom of the form that, when clicked, serializes the "
"state of the form to JSON and saves it in local storage."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:929
#, markdown-text
msgid ""
"Automatic retrieval of the JSON document from local storage upon page "
"reload. The form fields are populated with the contents of this document."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:929
#, markdown-text
msgid "A pop-up alert if there is an issue saving or loading the form state."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:931
#, markdown-text
msgid ""
"We'll start by creating FFI wrappers for the following Web Storage APIs in "
"our `Effect.Storage` module:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:934
#, markdown-text
msgid ""
"`setItem` takes a key and a value (both strings), and returns a computation "
"which stores (or updates) the value in local storage at the specified key."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:934
#, markdown-text
msgid ""
"`getItem` takes a key, and attempts to retrieve the associated value from "
"local storage. However, since the `getItem` method on `window.localStorage` "
"can return `null`, the return type is not `String`, but `Json`."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:935
#, no-wrap
msgid ""
"foreign import setItem :: String -> String -> Effect Unit\n"
"\n"
"foreign import getItem :: String -> Effect Json\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:942
#, markdown-text
msgid ""
"Here is the corresponding JavaScript implementation of these functions in "
"`Effect/Storage.js`:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:943
#, no-wrap
msgid ""
"export const setItem = key => value => () =>\n"
"  window.localStorage.setItem(key, value);\n"
"\n"
"export const getItem = key => () =>\n"
"  window.localStorage.getItem(key);\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:952
#, markdown-text
msgid "We'll create a save button like so:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:953
#, no-wrap
msgid ""
"saveButton :: R.JSX\n"
"saveButton =\n"
"  D.label\n"
"    { className: \"form-group row col-form-label\"\n"
"    , children:\n"
"        [ D.button\n"
"            { className: \"btn-primary btn\"\n"
"            , onClick: handler_ validateAndSave\n"
"            , children: [ D.text \"Save\" ]\n"
"            }\n"
"        ]\n"
"    }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:969
#, markdown-text
msgid ""
"And write our validated `person` as a JSON string with `setItem` in the "
"`validateAndSave` function:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:970
#, no-wrap
msgid ""
"validateAndSave :: Effect Unit\n"
"validateAndSave = do\n"
"  log \"Running validators\"\n"
"  case validatePerson' person of\n"
"    Left errs -> log $ \"There are \" <> show (length errs) <> \" validation "
"errors.\"\n"
"    Right validPerson -> do\n"
"      setItem \"person\" $ stringify $ encodeJson validPerson\n"
"      log \"Saved\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:982
#, markdown-text
msgid ""
"Note that if we attempt to compile at this stage, we'll encounter the "
"following error:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter10.md:983
#, no-wrap
msgid ""
"  No type class instance was found for\n"
"    Data.Argonaut.Encode.Class.EncodeJson PhoneType\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:989
#, markdown-text
msgid ""
"This is because `PhoneType` in the `Person` record needs an `EncodeJson` "
"instance. We'll also derive a generic encode instance and a decode instance "
"while we're at it. More information on how this works is available in the "
"argonaut docs:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:990
#, no-wrap
msgid ""
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:import}}\n"
"\n"
"{{#include "
"../exercises/chapter10/src/Data/AddressBook.purs:PhoneType_generic}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:997
#, markdown-text
msgid ""
"Now we can save our `person` to local storage, but this isn't very useful "
"unless we can retrieve the data. We'll tackle that next."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:999
#, markdown-text
msgid "We'll start with retrieving the \"person\" string from local storage:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1000
#, no-wrap
msgid "item <- getItem \"person\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1005
#, markdown-text
msgid ""
"Then we'll create a helper function to convert the string from local storage "
"to our `Person` record. Note that this string in storage may be `null`, so "
"we represent it as a foreign `Json` until it is successfully decoded as a "
"`String`. There are a number of other conversion steps along the way – each "
"of which returns an `Either` value, so it makes sense to organize these "
"together in a `do` block."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1006
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- decodeJson item\n"
"  j          <- jsonParser jsonString\n"
"  decodeJson j\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1015
#, markdown-text
msgid ""
"Then we inspect this result to see if it succeeded. If it fails, we'll log "
"the errors and use our default `examplePerson`, otherwise, we'll use the "
"person retrieved from local storage."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1016
#, no-wrap
msgid ""
"initialPerson <- case processItem item of\n"
"  Left  err -> do\n"
"    log $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
"    pure examplePerson\n"
"  Right p   -> pure p\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1025
#, markdown-text
msgid ""
"Finally, we'll pass this `initialPerson` to our component via the `props` "
"record:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1026
#, no-wrap
msgid ""
"-- Create JSX node from react component.\n"
"app = element addressBookApp { initialPerson }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1032
#, markdown-text
msgid "And pick it up on the other side to use in our state hook:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1033
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })\n"
"mkAddressBookApp =\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState props.initialPerson\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1041
#, markdown-text
msgid ""
"As a finishing touch, we'll improve the quality of our error messages by "
"appending to the `String` of each `Left` value with `lmap`."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1042
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- lmap (\"No string in local storage: \" <> _) $ decodeJson "
"item\n"
"  j          <- lmap (\"Cannot parse JSON string: \"   <> _) $ jsonParser "
"jsonString\n"
"  lmap               (\"Cannot decode Person: \"       <> _) $ decodeJson "
"j\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1051
#, markdown-text
msgid ""
"Only the first error should ever occur during the normal operation of this "
"app. You can trigger the other errors by opening your web browser's dev "
"tools, editing the saved \"person\" string in local storage, and refreshing "
"the page. How you modify the JSON string determines which error is "
"triggered. See if you can trigger each of them."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1053
#, markdown-text
msgid ""
"That covers local storage. Next, we'll implement the `alert` action, similar "
"to the `log` action from the `Effect.Console` module. The only difference is "
"that the `alert` action uses the `window.alert` method, whereas the `log` "
"action uses the `console.log` method. As such, `alert` can only be used in "
"environments where `window.alert` is defined, such as a web browser."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1054
#, no-wrap
msgid "foreign import alert :: String -> Effect Unit\n"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter10.md:1058
#, no-wrap
msgid ""
"export const alert = msg => () =>\n"
"  window.alert(msg);\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1064
#, markdown-text
msgid "We want this alert to appear when either:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:1067
#, markdown-text
msgid "A user attempts to save a form with validation errors."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:1067
#, markdown-text
msgid "The state cannot be retrieved from local storage."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1069
#, markdown-text
msgid "That is accomplished by simply replacing `log` with `alert` on these lines:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter10.md:1070
#, no-wrap
msgid ""
"Left errs -> alert $ \"There are \" <> show (length errs) <> \" validation "
"errors.\"\n"
"\n"
"alert $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter10.md:1082
#, markdown-text
msgid ""
"(Easy) Write a wrapper for the `removeItem` method on the `localStorage` "
"object, and add your foreign function to the `Effect.Storage` module."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter10.md:1082
#, markdown-text
msgid ""
"(Medium) Add a \"Reset\" button that, when clicked, calls the newly-created "
"`removeItem` function to delete the \"person\" entry from local storage."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter10.md:1082
#, markdown-text
msgid ""
"(Easy) Write a wrapper for the `confirm` method on the JavaScript `Window` "
"object, and add your foreign function to the `Effect.Alert` module."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter10.md:1082
#, markdown-text
msgid ""
"(Medium) Call this `confirm` function when a users clicks the \"Reset\" "
"button to ask if they're sure they want to reset their address book."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:1083 ../text/chapter11.md:963 ../text/chapter12.md:594
#: ../text/chapter13.md:401 ../text/chapter14.md:720 ../text/chapter2.md:128
#: ../text/chapter3.md:782 ../text/chapter4.md:531 ../text/chapter5.md:641
#: ../text/chapter6.md:795 ../text/chapter7.md:691 ../text/chapter8.md:1001
#: ../text/chapter9.md:238
#, markdown-text, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1086
#, markdown-text
msgid ""
"In this chapter, we've learned how to work with foreign JavaScript code from "
"PureScript, and we've seen the issues involved with writing trustworthy code "
"using the FFI:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:1090
#, markdown-text
msgid ""
"We've seen the importance of ensuring that foreign functions have correct "
"representations."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:1090
#, markdown-text
msgid ""
"We learned how to deal with corner cases like null values and other types of "
"JavaScript data by using foreign types or the `Json` data type."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter10.md:1090
#, markdown-text
msgid "We saw how to safely serialize and deserialize JSON data."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1092
#, markdown-text
msgid ""
"For more examples, the `purescript`, `purescript-contrib`, and "
"`purescript-node` GitHub organizations provide plenty of examples of "
"libraries that use the FFI. In the remaining chapters, we will see some of "
"these libraries put to use to solve real-world problems in a type-safe way."
msgstr ""

#. type: Title ##
#: ../text/chapter10.md:1093
#, markdown-text, no-wrap
msgid "Addendum"
msgstr ""

#. type: Title ###
#: ../text/chapter10.md:1095
#, markdown-text, no-wrap
msgid "Calling PureScript from JavaScript"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1098
#, markdown-text
msgid ""
"Calling a PureScript function from JavaScript is very simple, at least for "
"functions with simple types."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1100
#, markdown-text
msgid "Let's take the following simple module as an example:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1101
#, no-wrap
msgid ""
"module Test where\n"
"\n"
"gcd :: Int -> Int -> Int\n"
"gcd 0 m = m\n"
"gcd n 0 = n\n"
"gcd n m\n"
"  | n > m     = gcd (n - m) m\n"
"  | otherwise = gcd (m – n) n\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1113
#, markdown-text
msgid ""
"This function finds the greatest common divisor of two numbers by repeated "
"subtraction. It is a nice example of a case where you might like to use "
"PureScript to define the function, but have a requirement to call it from "
"JavaScript: it is simple to define this function in PureScript using pattern "
"matching and recursion, and the implementor can benefit from the use of the "
"type checker."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1115
#, markdown-text
msgid ""
"To understand how this function can be called from JavaScript, it is "
"important to realize that PureScript functions always get turned into "
"JavaScript functions of a single argument, so we need to apply its arguments "
"one-by-one:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1116
#, no-wrap
msgid ""
"import Test from 'Test.js';\n"
"Test.gcd(15)(20);\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1122
#, markdown-text
msgid ""
"Here, I assume the code was compiled with `spago build`, which compiles "
"PureScript modules to ES modules. For that reason, I could reference the "
"`gcd` function on the `Test` object, after importing the `Test` module using "
"`import`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1124
#, markdown-text
msgid ""
"You can also use the `spago bundle-app` and `spago bundle-module` commands "
"to bundle your generated JavaScript into a single file. Consult [the "
"documentation](https://github.com/purescript/spago#bundle-a-project-into-a-single-js-file) "
"for more information."
msgstr ""

#. type: Title ###
#: ../text/chapter10.md:1125
#, markdown-text, no-wrap
msgid "Understanding Name Generation"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1128
#, markdown-text
msgid ""
"PureScript aims to preserve names during code generation as much as "
"possible. In particular, most identifiers that are neither PureScript nor "
"JavaScript keywords can be expected to be preserved, at least for names of "
"top-level declarations."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1130
#, markdown-text
msgid ""
"If you decide to use a JavaScript keyword as an identifier, the name will be "
"escaped with a double dollar symbol. For example,"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1131
#, no-wrap
msgid "null = []\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1136 ../text/chapter10.md:1148
#, markdown-text
msgid "Generates the following JavaScript:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1137
#, no-wrap
msgid "var $$null = [];\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1142
#, markdown-text
msgid ""
"In addition, if you would like to use special characters in your identifier "
"names, they will be escaped using a single dollar symbol. For example,"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1143
#, no-wrap
msgid "example' = 100\n"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1149
#, no-wrap
msgid "var example$prime = 100;\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1154
#, markdown-text
msgid ""
"Where compiled PureScript code is intended to be called from JavaScript, it "
"is recommended that identifiers only use alphanumeric characters and avoid "
"JavaScript keywords. If user-defined operators are provided for use in "
"PureScript code, it is good practice to provide an alternative function with "
"an alphanumeric name for use in JavaScript."
msgstr ""

#. type: Title ###
#: ../text/chapter10.md:1155
#, markdown-text, no-wrap
msgid "Runtime Data Representation"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1158
#, markdown-text
msgid ""
"Types allow us to reason at compile-time that our programs are \"correct\" "
"in some sense – that is, they will not break at runtime. But what does that "
"mean? In PureScript, it means that the type of an expression should be "
"compatible with its representation at runtime."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1160
#, markdown-text
msgid ""
"For that reason, it is important to understand the representation of data at "
"runtime to be able to use PureScript and JavaScript code together "
"effectively. This means that for any given PureScript expression, we should "
"be able to understand the behavior of the value it will evaluate to at "
"runtime."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1162
#, markdown-text
msgid ""
"The good news is that PureScript expressions have particularly simple "
"representations at runtime. It should always be possible to understand the "
"runtime data representation of an expression by considering its type."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1164
#, markdown-text
msgid ""
"For simple types, the correspondence is almost trivial. For example, if an "
"expression has the type `Boolean`, then its value `v` at runtime should "
"satisfy `typeof v === 'boolean'`. That is, expressions of type `Boolean` "
"evaluate to one of the (JavaScript) values `true` or `false`. In particular, "
"there is no PureScript expression of type `Boolean` which evaluates to "
"`null` or `undefined`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1166
#, markdown-text
msgid ""
"A similar law holds for expressions of type `Int`, `Number`, and `String` – "
"expressions of type `Int` or `Number` evaluate to non-null JavaScript "
"numbers, and expressions of type `String` evaluate to non-null JavaScript "
"strings. Expressions of type `Int` will evaluate to integers at runtime, "
"even though they cannot be distinguished from values of type `Number` by "
"using `typeof`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1168
#, markdown-text
msgid ""
"What about `Unit`? Well, since `Unit` has only one inhabitant (`unit`) and "
"its value is not observable, it doesn't matter what it's represented with at "
"runtime. Old code tends to represent it using `{}`. Newer code, however, "
"tends to use `undefined`. So, although it doesn't matter what you use to "
"represent `Unit`, it is recommended to use `undefined` (not returning "
"anything from a function also returns `undefined`)."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1170
#, markdown-text
msgid "What about some more complex types?"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1172
#, markdown-text, no-wrap
msgid ""
"As we have already seen, PureScript functions correspond to JavaScript "
"functions of a single argument. More precisely, if an expression `f` has "
"type `a -> b` for some types `a` and `b`, and an expression `x` evaluates to "
"a value with the correct runtime representation for type `a`, then `f` "
"evaluates to a JavaScript function, which, when applied to the result of "
"evaluating `x`, has the correct runtime representation for type `b`. As a "
"simple example, an expression of type `String -> String` evaluates to a "
"function that takes non-null JavaScript strings to non-null JavaScript "
"strings.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1174
#, markdown-text
msgid ""
"As you might expect, PureScript's arrays correspond to JavaScript "
"arrays. But remember – PureScript arrays are homogeneous, so every element "
"has the same type. Concretely, if a PureScript expression `e` has type "
"`Array a` for some type `a`, then `e` evaluates to a (non-null) JavaScript "
"array, all of whose elements have the correct runtime representation for "
"type `a`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1176
#, markdown-text
msgid ""
"We've already seen that PureScript's records evaluate to JavaScript "
"objects. As for functions and arrays, we can reason about the runtime "
"representation of data in a record's fields by considering the types "
"associated with its labels. Of course, the fields of a record are not "
"required to be of the same type."
msgstr ""

#. type: Title ###
#: ../text/chapter10.md:1177
#, markdown-text, no-wrap
msgid "Representing ADTs"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1180
#, markdown-text
msgid ""
"For every constructor of an algebraic data type, the PureScript compiler "
"creates a new JavaScript object type by defining a function. Its "
"constructors correspond to functions that create new JavaScript objects "
"based on those prototypes."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1182
#, markdown-text
msgid "For example, consider the following simple ADT:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1183
#, no-wrap
msgid "data ZeroOrOne a = Zero | One a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1188
#, markdown-text
msgid "The PureScript compiler generates the following code:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1189
#, no-wrap
msgid ""
"function One(value0) {\n"
"    this.value0 = value0;\n"
"};\n"
"\n"
"One.create = function (value0) {\n"
"    return new One(value0);\n"
"};\n"
"\n"
"function Zero() {\n"
"};\n"
"\n"
"Zero.value = new Zero();\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1205
#, markdown-text
msgid ""
"Here, we see two JavaScript object types: `Zero` and `One`. It is possible "
"to create values of each type by using JavaScript's `new` keyword. For "
"constructors with arguments, the compiler stores the associated data in "
"fields called `value0`, `value1`, etc."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1207
#, markdown-text
msgid ""
"The PureScript compiler also generates helper functions. For constructors "
"with no arguments, the compiler generates a `value` property, which can be "
"reused instead of using the `new` operator repeatedly. For constructors with "
"one or more arguments, the compiler generates a `create` function, which "
"takes arguments with the appropriate representation and applies the "
"appropriate constructor."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1209
#, markdown-text
msgid ""
"What about constructors with more than one argument? In that case, the "
"PureScript compiler also creates a new object type, and a helper "
"function. This time, however, the helper function is a curried function of "
"two arguments. For example, this algebraic data type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1210
#, no-wrap
msgid "data Two a b = Two a b\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1215
#, markdown-text
msgid "Generates this JavaScript code:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1216
#, no-wrap
msgid ""
"function Two(value0, value1) {\n"
"    this.value0 = value0;\n"
"    this.value1 = value1;\n"
"};\n"
"\n"
"Two.create = function (value0) {\n"
"    return function (value1) {\n"
"        return new Two(value0, value1);\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1230
#, markdown-text
msgid ""
"Here, values of the object type `Two` can be created using the `new` keyword "
"or by using the `Two.create` function."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1232
#, markdown-text
msgid ""
"The case of newtypes is slightly different. Recall that a newtype is like an "
"algebraic data type, restricted to having a single constructor taking a "
"single argument. In this case, the runtime representation of the newtype is "
"the same as its argument type."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1234
#, markdown-text
msgid ""
"For example, this newtype represents telephone numbers is represented as a "
"JavaScript string at runtime:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1235
#, no-wrap
msgid "newtype PhoneNumber = PhoneNumber String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1240
#, markdown-text
msgid ""
"This is useful for designing libraries since newtypes provide an additional "
"layer of type safety without the runtime overhead of another function call."
msgstr ""

#. type: Title ###
#: ../text/chapter10.md:1241
#, markdown-text, no-wrap
msgid "Representing Quantified Types"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1244
#, markdown-text
msgid ""
"Expressions with quantified (polymorphic) types have restrictive "
"representations at runtime. In practice, there are relatively few "
"expressions with a given quantified type, but we can reason about them quite "
"effectively."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1246
#, markdown-text
msgid "Consider this polymorphic type, for example:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1247
#, no-wrap
msgid "forall a. a -> a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1252
#, markdown-text
msgid ""
"What sort of functions have this type? Well, there is certainly one function "
"with this type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1253
#, no-wrap
msgid ""
"identity :: forall a. a -> a\n"
"identity a = a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1259
#, markdown-text, no-wrap
msgid ""
"> Note that the actual "
"[`identity`](https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Category#v:identity) "
"function defined in `Prelude` has a slightly different type.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1261
#, markdown-text
msgid ""
"In fact, the `identity` function is the _only_ (total) function with this "
"type! This certainly seems to be the case (try writing an expression with "
"this type that is not observably equivalent to `identity`), but how can we "
"be sure? We can be sure by considering the runtime representation of the "
"type."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1263
#, markdown-text, no-wrap
msgid ""
"What is the runtime representation of a quantified type `forall a. t`? Well, "
"any expression with the runtime representation for this type must have the "
"correct runtime representation for the type `t` for any choice of type "
"`a`. In our example above, a function of type `forall a. a -> a` must have "
"the correct runtime representation for the types `String -> String`, `Number "
"-> Number`, `Array Boolean -> Array Boolean`, and so on. It must take "
"strings to strings, numbers to numbers, etc.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1265
#, markdown-text
msgid ""
"But that is not enough – the runtime representation of a quantified type is "
"more strict than this. We require any expression to be _parametrically "
"polymorphic_ – that is, it cannot use any information about the type of its "
"argument in its implementation. This additional condition prevents "
"problematic implementations such as the following JavaScript function from "
"inhabiting a polymorphic type:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1266
#, no-wrap
msgid ""
"function invalid(a) {\n"
"    if (typeof a === 'string') {\n"
"        return \"Argument was a string.\";\n"
"    } else {\n"
"        return a;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1277
#, markdown-text, no-wrap
msgid ""
"Certainly, this function takes strings to strings, numbers to numbers, "
"etc. But it does not meet the additional condition, since it inspects the "
"(runtime) type of its argument, so this function would not be a valid "
"inhabitant of the type `forall a. a -> a`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1279
#, markdown-text, no-wrap
msgid ""
"Without being able to inspect the runtime type of our function argument, our "
"only option is to return the argument unchanged. So `identity` is indeed the "
"only inhabitant of the type `forall a. a -> a`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1281
#, markdown-text
msgid ""
"A full discussion of _parametric polymorphism_ and _parametricity_ is beyond "
"the scope of this book. Note, however, that since PureScript's types are "
"_erased_ at runtime, a polymorphic function in PureScript _cannot_ inspect "
"the runtime representation of its arguments (without using the FFI), so this "
"representation of polymorphic data is appropriate."
msgstr ""

#. type: Title ###
#: ../text/chapter10.md:1282
#, markdown-text, no-wrap
msgid "Representing Constrained Types"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1285
#, markdown-text
msgid ""
"Functions with a type class constraint have an interesting representation at "
"runtime. Because the function's behavior might depend on the type class "
"instance chosen by the compiler, the function is given an additional "
"argument, called a _type class dictionary_, which contains the "
"implementation of the type class functions provided by the chosen instance."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1287
#, markdown-text
msgid ""
"For example, here is a simple PureScript function with a constrained type "
"that uses the `Show` type class:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1288
#, no-wrap
msgid ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1294
#, markdown-text
msgid "The generated JavaScript looks like this:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1295
#, no-wrap
msgid ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1304
#, markdown-text
msgid ""
"Notice that `shout` is compiled to a (curried) function of two arguments, "
"not one. The first argument `dict` is the type class dictionary for the "
"`Show` constraint. `dict` contains the implementation of the `show` function "
"for the type `a`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1306
#, markdown-text
msgid ""
"We can call this function from JavaScript by passing an explicit type class "
"dictionary from `Data.Show` as the first parameter:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1307
#, no-wrap
msgid ""
"import { showNumber } from 'Data.Show'\n"
"\n"
"shout(showNumber)(42);\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter10.md:1316
#, markdown-text
msgid "(Easy) What are the runtime representations of these types?"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1322
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     forall a. a\n"
"     forall a. a -> a -> a\n"
"     forall a. Ord a => Array a -> Boolean\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1325
#, markdown-text, no-wrap
msgid ""
"     What can you say about the expressions which have these types?\n"
" 1. (Medium) Try using the functions defined in the `arrays` package, "
"calling them from JavaScript, by compiling the library using `spago build` "
"and importing modules using the `import` function in NodeJS. _Hint_: you may "
"need to configure the output path so that the generated ES modules are "
"available on the NodeJS module path.\n"
msgstr ""

#. type: Title ###
#: ../text/chapter10.md:1326
#, markdown-text, no-wrap
msgid "Representing Side Effects"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1329
#, markdown-text
msgid ""
"The `Effect` monad is also defined as a foreign type. Its runtime "
"representation is quite simple – an expression of type `Effect a` should "
"evaluate to a JavaScript function of **no arguments**, which performs any "
"side-effects and returns a value with the correct runtime representation for "
"type `a`."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1331
#, markdown-text
msgid ""
"The definition of the `Effect` type constructor is given in the `Effect` "
"module as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1332
#, no-wrap
msgid "foreign import data Effect :: Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1337
#, markdown-text
msgid ""
"As a simple example, consider the `random` function defined in the `random` "
"package. Recall that its type was:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1338
#, no-wrap
msgid "foreign import random :: Effect Number\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1343
#, markdown-text
msgid "The definition of the `random` function is given here:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1344
#, no-wrap
msgid "export const random = Math.random;\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1349
#, markdown-text
msgid ""
"Notice that the `random` function is represented at runtime as a function of "
"no arguments. It performs the side effect of generating a random number, "
"returns it, and the return value matches the runtime representation of the "
"`Number` type: it is a non-null JavaScript number."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1351
#, markdown-text
msgid ""
"As a slightly more interesting example, consider the `log` function defined "
"by the `Effect.Console` module in the `console` package. The `log` function "
"has the following type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter10.md:1352
#, no-wrap
msgid "foreign import log :: String -> Effect Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1357
#, markdown-text
msgid "And here is its definition:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1358
#, no-wrap
msgid ""
"export const log = function (s) {\n"
"  return function () {\n"
"    console.log(s);\n"
"  };\n"
"};\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1367
#, markdown-text
msgid ""
"The representation of `log` at runtime is a JavaScript function of a single "
"argument, returning a function of no arguments. The inner function performs "
"the side-effect of writing a message to the console."
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1369
#, markdown-text
msgid ""
"Expressions of type `Effect a` can be invoked from JavaScript like regular "
"JavaScript methods. For example, since the `main` function is required to "
"have type `Effect a` for some type `a`, it can be invoked as follows:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter10.md:1370
#, no-wrap
msgid ""
"import { main } from 'Main'\n"
"\n"
"main();\n"
msgstr ""

#. type: Plain text
#: ../text/chapter10.md:1376
#, markdown-text
msgid ""
"When using `spago bundle-app --to` or `spago run`, this call to `main` is "
"generated automatically whenever the `Main` module is defined."
msgstr ""

#. type: Title #
#: ../text/chapter11.md:1
#, markdown-text, no-wrap
msgid "Monadic Adventures"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:6
#, markdown-text
msgid ""
"The goal of this chapter will be to learn about _monad transformers_, which "
"provide a way to combine side-effects provided by different monads. The "
"motivating example will be a text adventure game that can be played on the "
"console in NodeJS. The various side-effects of the game (logging, state, and "
"configuration) will all be provided by a monad transformer stack."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:10 ../text/chapter12.md:10
#, markdown-text
msgid "This module's project introduces the following new dependencies:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter11.md:15
#, markdown-text
msgid "`ordered-collections`, which provides data types for immutable maps and sets"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter11.md:15
#, markdown-text
msgid ""
"`transformers`, which provides implementations of standard monad "
"transformers"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter11.md:15
#, markdown-text
msgid ""
"`node-readline`, which provides FFI bindings to the "
"[`readline`](https://nodejs.org/api/readline.html) interface provided by "
"NodeJS"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter11.md:15
#, markdown-text
msgid ""
"`optparse`, which provides applicative parsers for processing command-line "
"arguments"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:16
#, markdown-text, no-wrap
msgid "How To Play The Game"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:19
#, markdown-text
msgid "To run the project, use `spago run`"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:21
#, markdown-text
msgid "By default, you will see a usage message:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:22
#, no-wrap
msgid ""
"Monadic Adventures! A game to learn monad transformers\n"
"\n"
"Usage: run.js (-p|--player <player name>) [-d|--debug]\n"
"  Play the game as <player name>\n"
"\n"
"Available options:\n"
"  -p,--player <player name>\n"
"                           The player's name <String>\n"
"  -d,--debug               Use debug mode\n"
"  -h,--help                Show this help text\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:36
#, markdown-text
msgid ""
"To provide command line arguments, you can either call `spago run` with the "
"`-a` option to pass additional arguments directly to your application or "
"call `spago bundle-app`, which will create an index.js file that can be run "
"directly with `node`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:38
#, markdown-text
msgid "For example, to provide the player name using the `-p` option:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:39
#, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
">\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:44
#, no-wrap
msgid ""
"$ spago bundle-app \n"
"$ node index.js -p Phil\n"
">\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:51
#, markdown-text
msgid ""
"From the prompt, you can enter commands like `look`, `inventory`, `take`, "
"`use`, `north`, `south`, `east`, and `west`. There is also a `debug` "
"command, which can print the game state when the `--debug` command line "
"option is provided."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:53
#, markdown-text
msgid ""
"The game is played on a two-dimensional grid, and the player moves by "
"issuing commands `north`, `south`, `east`, and `west`. The game contains a "
"collection of items that can either be in the player's possession (in the "
"user's _inventory_) or on the game grid at some location. Items can be "
"picked up by the player using the `take` command."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:55
#, markdown-text
msgid "For reference, here is a complete walkthrough of the game:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:56
#, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
"\n"
"> look\n"
"You are at (0, 0)\n"
"You are in a dark forest. You see a path to the north.\n"
"You can see the Matches.\n"
"\n"
"> take Matches\n"
"You now have the Matches\n"
"\n"
"> north\n"
"> look\n"
"You are at (0, 1)\n"
"You are in a clearing.\n"
"You can see the Candle.\n"
"\n"
"> take Candle\n"
"You now have the Candle\n"
"\n"
"> inventory\n"
"You have the Candle.\n"
"You have the Matches.\n"
"\n"
"> use Matches\n"
"You light the candle.\n"
"Congratulations, Phil!\n"
"You win!\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:87
#, markdown-text
msgid ""
"The game is very simple, but the aim of the chapter is to use the "
"`transformers` package to build a library that will enable rapid development "
"of this type of game."
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:88
#, markdown-text, no-wrap
msgid "The State Monad"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:91
#, markdown-text
msgid ""
"We will start by looking at some of the monads provided by the "
"`transformers` package."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:93
#, markdown-text
msgid ""
"The first example is the `State` monad, which provides a way to model "
"_mutable state_ in pure code. We have already seen an approach to a mutable "
"state provided by the `Effect` monad. `State` provides an alternative."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:95
#, markdown-text
msgid ""
"The `State` type constructor takes two type parameters: the type `s` of the "
"state and the return type `a`. Even though we speak of the \"`State` "
"monad\", the instance of the `Monad` type class is actually provided for the "
"`State s` type constructor for any type `s`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:97
#, markdown-text
msgid "The `Control.Monad.State` module provides the following API:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:98
#, no-wrap
msgid ""
"get     :: forall s.             State s s\n"
"gets    :: forall s. (s -> a) -> State s a\n"
"put     :: forall s. s        -> State s Unit\n"
"modify  :: forall s. (s -> s) -> State s s\n"
"modify_ :: forall s. (s -> s) -> State s Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:107
#, markdown-text
msgid ""
"Note that these API signatures are presented in a simplified form using the "
"`State` type constructor for now. The actual API involves `MonadState`, "
"which we'll cover in the later \"Type Classes\" section of this chapter, so "
"don't worry if you see different signatures in your IDE tooltips or on "
"Pursuit."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:109
#, markdown-text
msgid ""
"Let's see an example. One use of the `State` monad might be to add the "
"values in an array of integers to the current state. We could do that by "
"choosing `Int` as the state type `s` and using `traverse_` to traverse the "
"array, with a call to `modify` for each array element:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:110
#, no-wrap
msgid ""
"import Data.Foldable (traverse_)\n"
"import Control.Monad.State\n"
"import Control.Monad.State.Class\n"
"\n"
"sumArray :: Array Int -> State Int Unit\n"
"sumArray = traverse_ \\n -> modify \\sum -> sum + n\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:120
#, markdown-text
msgid ""
"The `Control.Monad.State` module provides three functions for running a "
"computation in the `State` monad:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:121
#, no-wrap
msgid ""
"evalState :: forall s a. State s a -> s -> a\n"
"execState :: forall s a. State s a -> s -> s\n"
"runState  :: forall s a. State s a -> s -> Tuple a s\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:128
#, markdown-text
msgid ""
"Each function takes an initial state of type `s` and a computation of type "
"`State s a`. `evalState` only returns the return value, `execState` only "
"returns the final state, and `runState` returns both, expressed as a value "
"of type `Tuple a s`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:130
#, markdown-text
msgid ""
"Given the `sumArray` function above, we could use `execState` in PSCi to sum "
"the numbers in several arrays as follows:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:131
#, no-wrap
msgid ""
"> :paste\n"
"… execState (do\n"
"…   sumArray [1, 2, 3]\n"
"…   sumArray [4, 5]\n"
"…   sumArray [6]) 0\n"
"… ^D\n"
"21\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:145
#, markdown-text
msgid ""
"(Easy) What is the result of replacing `execState` with `runState` or "
"`evalState` in our example above?"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:145
#, markdown-text
msgid ""
"(Medium) A string of parentheses is _balanced_ if it is obtained by either "
"concatenating zero-or-more shorter balanced strings or wrapping a shorter "
"balanced string in a pair of parentheses."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:147
#, markdown-text, no-wrap
msgid ""
"     Use the `State` monad and the `traverse_` function to write a "
"function\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:151
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     testParens :: String -> Boolean\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:153
#, markdown-text, no-wrap
msgid ""
"     which tests whether or not a `String` of parentheses is balanced by "
"keeping track of the number of opening parentheses that have not been "
"closed. Your function should work as follows:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:157
#, markdown-text, no-wrap
msgid ""
"     ```text\n"
"     > testParens \"\"\n"
"     true\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:160
#, markdown-text, no-wrap
msgid ""
"     > testParens \"(()(())())\"\n"
"     true\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:163
#, markdown-text, no-wrap
msgid ""
"     > testParens \")\"\n"
"     false\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:167
#, markdown-text, no-wrap
msgid ""
"     > testParens \"(()()\"\n"
"     false\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:169
#, markdown-text, no-wrap
msgid ""
"     _Hint_: you may like to use the `toCharArray` function from the "
"`Data.String.CodeUnits` module to turn the input string into an array of "
"characters.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:170
#, markdown-text, no-wrap
msgid "The Reader Monad"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:173
#, markdown-text
msgid ""
"Another monad provided by the `transformers` package is the `Reader` "
"monad. This monad provides the ability to read from a global "
"configuration. Whereas the `State` monad provides the ability to read and "
"write a single piece of mutable state, the `Reader` monad only provides the "
"ability to read a single piece of data."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:175
#, markdown-text
msgid ""
"The `Reader` type constructor takes two type arguments: a type `r` which "
"represents the configuration type, and the return type `a`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:177
#, markdown-text
msgid "The `Control.Monad.Reader` module provides the following API:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:178
#, no-wrap
msgid ""
"ask   :: forall r. Reader r r\n"
"local :: forall r a. (r -> r) -> Reader r a -> Reader r a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:184
#, markdown-text
msgid ""
"The `ask` action can be used to read the current configuration, and the "
"`local` action can be used to run a computation with a modified "
"configuration."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:186
#, markdown-text
msgid ""
"For example, suppose we were developing an application controlled by "
"permissions, and we wanted to use the `Reader` monad to hold the current "
"user's permissions object. We might choose the type `r` to be some type "
"`Permissions` with the following API:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:187
#, no-wrap
msgid ""
"hasPermission :: String -> Permissions -> Boolean\n"
"addPermission :: String -> Permissions -> Permissions\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:193
#, markdown-text
msgid ""
"Whenever we wanted to check if the user had a particular permission, we "
"could use `ask` to retrieve the current permissions object. For example, "
"only administrators might be allowed to create new users:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:194
#, no-wrap
msgid ""
"createUser :: Reader Permissions (Maybe User)\n"
"createUser = do\n"
"  permissions <- ask\n"
"  if hasPermission \"admin\" permissions\n"
"    then map Just newUser\n"
"    else pure Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:204
#, markdown-text
msgid ""
"To elevate the user's permissions, we might use the `local` action to modify "
"the `Permissions` object during the execution of some computation:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:205
#, no-wrap
msgid ""
"runAsAdmin :: forall a. Reader Permissions a -> Reader Permissions a\n"
"runAsAdmin = local (addPermission \"admin\")\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:211
#, markdown-text
msgid ""
"Then we could write a function to create a new user, even if the user did "
"not have the `admin` permission:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:212
#, no-wrap
msgid ""
"createUserAsAdmin :: Reader Permissions (Maybe User)\n"
"createUserAsAdmin = runAsAdmin createUser\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:218
#, markdown-text
msgid ""
"To run a computation in the `Reader` monad, the `runReader` function can be "
"used to provide the global configuration:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:219
#, no-wrap
msgid "runReader :: forall r a. Reader r a -> r -> a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:226
#, markdown-text, no-wrap
msgid ""
" In these exercises, we will use the `Reader` monad to build a small library "
"for rendering documents with indentation. The \"global configuration\" will "
"be a number indicating the current indentation level:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:227
#, no-wrap
msgid ""
"type Level = Int\n"
"\n"
"type Doc = Reader Level String\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:234
#, markdown-text
msgid ""
"(Easy) Write a function `line` that renders a function at the current "
"indentation level. Your function should have the following type:"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:238
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     line :: String -> Doc\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:241
#, markdown-text, no-wrap
msgid ""
"     _Hint_: use the `ask` function to read the current indentation "
"level. The `power` function from `Data.Monoid` may be helpful too.\n"
" 1. (Easy) Use the `local` function to write a function\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:245
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     indent :: Doc -> Doc\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:248
#, markdown-text, no-wrap
msgid ""
"     which increases the indentation level for a block of code.\n"
" 1. (Medium) Use the `sequence` function defined in `Data.Traversable` to "
"write a function\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:252
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     cat :: Array Doc -> Doc\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:255
#, markdown-text, no-wrap
msgid ""
"     which concatenates a collection of documents, separating them with new "
"lines.\n"
" 1. (Medium) Use the `runReader` function to write a function\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:259
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     render :: Doc -> String\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:261
#, markdown-text, no-wrap
msgid "     which renders a document as a String.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:263
#, markdown-text, no-wrap
msgid ""
" You should now be able to use your library to write simple documents as "
"follows:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:264
#, no-wrap
msgid ""
" render $ cat\n"
"   [ line \"Here is some indented text:\"\n"
"   , indent $ cat\n"
"       [ line \"I am indented\"\n"
"       , line \"So am I\"\n"
"       , indent $ line \"I am even more indented\"\n"
"       ]\n"
"   ]\n"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:275
#, markdown-text, no-wrap
msgid "The Writer Monad"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:278
#, markdown-text
msgid ""
"The `Writer` monad allows accumulating a secondary value in addition to the "
"return value of a computation."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:280
#, markdown-text
msgid ""
"A common use case is to accumulate a log of type `String` or `Array String`, "
"but the `Writer` monad is more general than this. It can accumulate a value "
"in any monoid, so it might be used to keep track of an integer total using "
"the `Additive Int` monoid or to track whether any of several intermediate "
"`Boolean` values were true using the `Disj Boolean` monoid."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:282
#, markdown-text
msgid ""
"The `Writer` type constructor takes two type arguments: a type `w` that "
"should be an instance of the `Monoid` type class, and the return type `a`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:284
#, markdown-text
msgid "The key element of the `Writer` API is the `tell` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:285
#, no-wrap
msgid "tell :: forall w a. Monoid w => w -> Writer w Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:290
#, markdown-text
msgid ""
"The `tell` action appends the provided value to the current accumulated "
"result."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:292
#, markdown-text
msgid ""
"As an example, let's add a log to an existing function using the `Array "
"String` monoid. Consider our previous implementation of the _greatest common "
"divisor_ function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:293
#, no-wrap
msgid ""
"gcd :: Int -> Int -> Int\n"
"gcd n 0 = n\n"
"gcd 0 m = m\n"
"gcd n m = if n > m\n"
"            then gcd (n - m) m\n"
"            else gcd n (m - n)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:303
#, markdown-text
msgid ""
"We could add a log to this function by changing the return type to `Writer "
"(Array String) Int`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:304
#, no-wrap
msgid ""
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"\n"
"gcdLog :: Int -> Int -> Writer (Array String) Int\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:312
#, markdown-text
msgid ""
"We only have to change our function slightly to log the two inputs at each "
"step:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:313
#, no-wrap
msgid ""
"    gcdLog n 0 = pure n\n"
"    gcdLog 0 m = pure m\n"
"    gcdLog n m = do\n"
"      tell [\"gcdLog \" <> show n <> \" \" <> show m]\n"
"      if n > m\n"
"        then gcdLog (n - m) m\n"
"        else gcdLog n (m - n)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:324
#, markdown-text
msgid ""
"We can run a computation in the `Writer` monad by using either of the "
"`execWriter` or `runWriter` functions:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:325
#, no-wrap
msgid ""
"execWriter :: forall w a. Writer w a -> w\n"
"runWriter  :: forall w a. Writer w a -> Tuple a w\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:331
#, markdown-text
msgid ""
"Just like in the case of the `State` monad, `execWriter` only returns the "
"accumulated log, whereas `runWriter` returns both the log and the result."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:333
#, markdown-text
msgid "We can test our modified function in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:334
#, no-wrap
msgid ""
"> import Control.Monad.Writer\n"
"> import Control.Monad.Writer.Class\n"
"\n"
"> runWriter (gcdLog 21 15)\n"
"Tuple 3 [\"gcdLog 21 15\",\"gcdLog 6 15\",\"gcdLog 6 9\",\"gcdLog 6 "
"3\",\"gcdLog 3 3\"]\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:346
#, markdown-text
msgid ""
"(Medium) Rewrite the `sumArray` function above using the `Writer` monad and "
"the `Additive Int` monoid from the `monoid` package."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:346
#, markdown-text
msgid ""
"(Medium) The _Collatz_ function is defined on natural numbers \\\\( n \\\\) "
"as \\\\( n / 2 \\\\) when \\\\( n \\\\) is even and \\\\( 3 n + 1 \\\\) when "
"\\\\( n \\\\) is odd. For example, the iterated Collatz sequence starting at "
"\\\\( 10 \\\\) is as follows:"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:350
#, markdown-text, no-wrap
msgid ""
"     ```text\n"
"     10, 5, 16, 8, 4, 2, 1, ...\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:352
#, markdown-text, no-wrap
msgid ""
"     It is conjectured that the iterated Collatz sequence always reaches "
"\\\\( 1 \\\\) after some finite number of applications of the Collatz "
"function.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:354
#, markdown-text, no-wrap
msgid ""
"     Write a function that uses recursion to calculate how many iterations "
"of the Collatz function are required before the sequence reaches \\\\( 1 "
"\\\\).\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:356
#, markdown-text, no-wrap
msgid ""
"     Modify your function to use the `Writer` monad to log each application "
"of the Collatz function.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:357
#, markdown-text, no-wrap
msgid "Monad Transformers"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:360
#, markdown-text
msgid ""
"Each of the three monads above: `State`, `Reader`, and `Writer`, are also "
"examples of so-called _monad transformers_. The equivalent monad "
"transformers are called `StateT`, `ReaderT`, and `WriterT`, respectively."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:362
#, markdown-text
msgid ""
"What is a monad transformer? Well, as we have seen, a monad augments "
"PureScript code with some type of side effect, which can be interpreted in "
"PureScript by using the appropriate handler (`runState`, `runReader`, "
"`runWriter`, etc.) This is fine if we only need to use _one_ "
"side-effect. However, it is often useful to use more than one side-effect at "
"once. For example, we might want to use `Reader` together with `Maybe` to "
"express _optional results_ in the context of some global configuration. Or "
"we might want the mutable state provided by the `State` monad together with "
"the pure error tracking capability of the `Either` monad. This is the "
"problem solved by _monad transformers_."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:364
#, markdown-text
msgid ""
"Note that we have already seen that the `Effect` monad partially solves this "
"problem. Monad transformers provide another solution, and each approach has "
"its own benefits and limitations."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:366
#, markdown-text
msgid ""
"A monad transformer is a type constructor parameterized by a type and "
"another type constructor. It takes one monad and turns it into another "
"monad, adding its own variety of side-effects."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:368
#, markdown-text
msgid ""
"Let's see an example. The monad transformer version of the `State` monad is "
"`StateT`, defined in the `Control.Monad.State.Trans` module. We can find the "
"kind of `StateT` using PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:369
#, no-wrap
msgid ""
"> import Control.Monad.State.Trans\n"
"> :kind StateT\n"
"Type -> (Type -> Type) -> Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:376
#, markdown-text
msgid ""
"This looks quite confusing, but we can apply `StateT` one argument at a time "
"to understand how to use it."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:378
#, markdown-text
msgid ""
"The first type argument is the type of the state we wish to use, as was the "
"case for `State`. Let's use a state of type `String`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:379
#, no-wrap
msgid ""
"> :kind StateT String\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:385
#, markdown-text, no-wrap
msgid ""
"The next argument is a type constructor of kind `Type -> Type`. It "
"represents the underlying monad, which we want to add the effects of "
"`StateT` to. For the sake of an example, let's choose the `Either String` "
"monad:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:386
#, no-wrap
msgid ""
"> :kind StateT String (Either String)\n"
"Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:392
#, markdown-text
msgid ""
"We are left with a type constructor. The final argument represents the "
"return type, and we might instantiate it to `Number` for example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:393
#, no-wrap
msgid ""
"> :kind StateT String (Either String) Number\n"
"Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:399
#, markdown-text
msgid ""
"Finally, we are left with something of kind `Type`, which means we can try "
"to find values of this type."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:401
#, markdown-text
msgid ""
"The monad we have constructed – `StateT String (Either String)` – represents "
"computations that can fail with an error and use mutable state."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:403
#, markdown-text
msgid ""
"We can use the actions of the outer `StateT String` monad (`get`, `put`, and "
"`modify`) directly, but to use the effects of the wrapped monad (`Either "
"String`), we need to \"lift\" them over the monad transformer. The "
"`Control.Monad.Trans` module defines the `MonadTrans` type class, which "
"captures those type constructors which are monad transformers, as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:404
#, no-wrap
msgid ""
"class MonadTrans t where\n"
"  lift :: forall m a. Monad m => m a -> t m a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:410
#, markdown-text
msgid ""
"This class contains a single member, `lift`, which takes computations in any "
"underlying monad `m` and lifts them into the wrapped monad `t m`. In our "
"case, the type constructor `t` is `StateT String`, `m` is the `Either "
"String` monad, so `lift` provides a way to lift computations of type `Either "
"String a` to computations of type `StateT String (Either String) a`. This "
"means that we can use the effects of `StateT String` and `Either String` "
"side-by-side, as long as we use `lift` every time we use a computation of "
"type `Either String a`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:412
#, markdown-text
msgid ""
"For example, the following computation reads the underlying state and then "
"throws an error if the state is the empty string:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:413
#, no-wrap
msgid ""
"import Data.String (drop, take)\n"
"\n"
"split :: StateT String (Either String) String\n"
"split = do\n"
"  s <- get\n"
"  case s of\n"
"    \"\" -> lift $ Left \"Empty string\"\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:427
#, markdown-text
msgid ""
"If the state is not empty, the computation uses `put` to update the state to "
"`drop 1 s` (that is, `s` with the first character removed) and returns `take "
"1 s` (that is, the first character of `s`)."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:429
#, markdown-text
msgid "Let's try this in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:430
#, no-wrap
msgid ""
"> runStateT split \"test\"\n"
"Right (Tuple \"t\" \"est\")\n"
"\n"
"> runStateT split \"\"\n"
"Left \"Empty string\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:439
#, markdown-text
msgid ""
"This is not very remarkable since we could have implemented this without "
"`StateT`. However, since we are working in a monad, we can use do notation "
"or applicative combinators to build larger computations from smaller "
"ones. For example, we can apply `split` twice to read the first two "
"characters from a string:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:440
#, no-wrap
msgid ""
"> runStateT ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple \"te\" \"st\"))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:446
#, markdown-text
msgid ""
"We can use the `split` function with a handful of other actions to build a "
"basic parsing library. In fact, this is the approach taken by the `parsing` "
"library. This is the power of monad transformers – we can create "
"custom-built monads for various problems, choose the side-effects we need, "
"and keep the expressiveness of do notation and applicative combinators."
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:447
#, markdown-text, no-wrap
msgid "The ExceptT Monad Transformer"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:450
#, markdown-text
msgid ""
"The `transformers` package also defines the `ExceptT e` monad transformer, "
"corresponding to the `Either e` monad. It provides the following API:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:451
#, no-wrap
msgid ""
"class MonadError e m where\n"
"  throwError :: forall a. e -> m a\n"
"  catchError :: forall a. m a -> (e -> m a) -> m a\n"
"\n"
"instance Monad m => MonadError e (ExceptT e m)\n"
"\n"
"runExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:462
#, markdown-text
msgid ""
"The `MonadError` class captures those monads that support throwing and "
"catching errors of some type `e`, and an instance is provided for the "
"`ExceptT e` monad transformer. The `throwError` action can indicate failure, "
"like `Left` in the `Either e` monad. The `catchError` action allows us to "
"continue after an error is thrown using `throwError`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:464
#, markdown-text
msgid ""
"The `runExceptT` handler is used to run a computation of type `ExceptT e m "
"a`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:466
#, markdown-text
msgid ""
"This API is similar to that provided by the `exceptions` package and the "
"`Exception` effect. However, there are some important differences:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter11.md:469
#, markdown-text
msgid ""
"`Exception` uses actual JavaScript exceptions, whereas `ExceptT` models "
"errors as a pure data structure."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter11.md:469
#, markdown-text
msgid ""
"The `Exception` effect only supports exceptions of one type, namely "
"JavaScript's `Error` type, whereas `ExceptT` supports errors of any type. In "
"particular, we are free to define new error types."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:471
#, markdown-text
msgid ""
"Let's try out `ExceptT` by using it to wrap the `Writer` monad. Again, we "
"are free to use actions from the monad transformer `ExceptT e` directly, but "
"computations in the `Writer` monad should be lifted using `lift`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:472
#, no-wrap
msgid ""
"import Control.Monad.Except\n"
"import Control.Monad.Writer\n"
"\n"
"writerAndExceptT :: ExceptT String (Writer (Array String)) String\n"
"writerAndExceptT = do\n"
"  lift $ tell [\"Before the error\"]\n"
"  _ <- throwError \"Error!\"\n"
"  lift $ tell [\"After the error\"]\n"
"  pure \"Return value\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:485
#, markdown-text
msgid ""
"If we test this function in PSCi, we can see how the two effects of "
"accumulating a log and throwing an error interact. First, we can run the "
"outer `ExceptT` computation of type by using `runExceptT`, leaving a result "
"of type `Writer (Array String) (Either String String)`. We can then use "
"`runWriter` to run the inner `Writer` computation:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:486
#, no-wrap
msgid ""
"> runWriter $ runExceptT writerAndExceptT\n"
"Tuple (Left \"Error!\") [\"Before the error\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:492
#, markdown-text
msgid ""
"Note that only those log messages that were written before the error was "
"thrown get appended to the log."
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:493
#, markdown-text, no-wrap
msgid "Monad Transformer Stacks"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:496
#, markdown-text
msgid ""
"As we have seen, monad transformers can be used to build new monads on top "
"of existing monads. For some monad transformer `t1` and some monad `m`, the "
"application `t1 m` is also a monad. That means we can apply a _second_ monad "
"transformer `t2` to the result `t1 m` to construct a third monad `t2 (t1 "
"m)`. In this way, we can construct a _stack_ of monad transformers, which "
"combine the side-effects provided by their constituent monads."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:498
#, markdown-text
msgid ""
"In practice, the underlying monad `m` is either the `Effect` monad, if "
"native side-effects are required, or the `Identity` monad, defined in the "
"`Data.Identity` module. The `Identity` monad adds no new side-effects, so "
"transforming the `Identity` monad only provides the effects of the monad "
"transformer. The `State`, `Reader`, and `Writer` monads are implemented by "
"transforming the `Identity` monad with `StateT`, `ReaderT`, and `WriterT`, "
"respectively."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:500
#, markdown-text
msgid ""
"Let's see an example in which three side effects are combined. We will use "
"the `StateT`, `WriterT`, and `ExceptT` effects, with the `Identity` monad on "
"the bottom of the stack. This monad transformer stack will provide the side "
"effects of mutable state, accumulating a log, and pure errors."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:502
#, markdown-text
msgid ""
"We can use this monad transformer stack to reproduce our `split` action with "
"the added feature of logging."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:503
#, no-wrap
msgid ""
"type Errors = Array String\n"
"\n"
"type Log = Array String\n"
"\n"
"type Parser = StateT String (WriterT Log (ExceptT Errors Identity))\n"
"\n"
"split :: Parser String\n"
"split = do\n"
"  s <- get\n"
"  lift $ tell [\"The state is \" <> s]\n"
"  case s of\n"
"    \"\" -> lift $ lift $ throwError [\"Empty string\"]\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:522
#, markdown-text
msgid ""
"If we test this computation in PSCi, we see that the state is appended to "
"the log for every invocation of `split`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:524
#, markdown-text
msgid ""
"Note that we have to remove the side-effects in the order in which they "
"appear in the monad transformer stack: first, we use `runStateT` to remove "
"the `StateT` type constructor, then `runWriterT`, then "
"`runExceptT`. Finally, we run the computation in the `Identity` monad by "
"using `unwrap`."
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:525
#, no-wrap
msgid ""
"> runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s\n"
"\n"
"> runParser split \"test\"\n"
"(Right (Tuple (Tuple \"t\" \"est\") [\"The state is test\"]))\n"
"\n"
"> runParser ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple (Tuple \"te\" \"st\") [\"The state is test\", \"The state is "
"est\"]))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:536
#, markdown-text
msgid ""
"However, if the parse is unsuccessful because the state is empty, then no "
"log is printed at all:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:537
#, no-wrap
msgid ""
"> runParser split \"\"\n"
"(Left [\"Empty string\"])\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:543
#, markdown-text
msgid ""
"This is because of how the side-effects provided by the `ExceptT` monad "
"transformer interact with the side-effects provided by the `WriterT` monad "
"transformer. We can address this by changing the order in which the monad "
"transformer stack is composed. If we move the `ExceptT` transformer to the "
"top of the stack, then the log will contain all messages written up until "
"the first error, as we saw earlier when we transformed `Writer` with "
"`ExceptT`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:545
#, markdown-text
msgid ""
"One problem with this code is that we have to use the `lift` function "
"multiple times to lift computations over multiple monad transformers; for "
"example, the call to `throwError` has to be lifted twice, once over "
"`WriterT` and a second time over `StateT`. This is fine for small monad "
"transformer stacks but quickly becomes inconvenient."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:547
#, markdown-text
msgid ""
"Fortunately, as we will see, we can use the automatic code generation "
"provided by type class inference to do most of this \"heavy lifting\" for "
"us."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:552
#, markdown-text
msgid ""
"(Easy) Use the `ExceptT` monad transformer over the `Identity` functor to "
"write a function `safeDivide` which divides two numbers, throwing an error "
"(as the String \"Divide by zero!\") if the denominator is zero."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:552
#, markdown-text
msgid "(Medium) Write a parser"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:556
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     string :: String -> Parser String\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:558
#, markdown-text, no-wrap
msgid ""
"     which matches a string as a prefix of the current state or fails with "
"an error message.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:560
#, markdown-text, no-wrap
msgid "     Your parser should work as follows:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:565
#, markdown-text, no-wrap
msgid ""
"     ```text\n"
"     > runParser (string \"abc\") \"abcdef\"\n"
"     (Right (Tuple (Tuple \"abc\" \"def\") [\"The state is abcdef\"]))\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:568
#, markdown-text, no-wrap
msgid ""
"     _Hint_: you can use the implementation of `split` as a starting "
"point. You might find the `stripPrefix` function useful.\n"
" 1. (Difficult) Use the `ReaderT` and `WriterT` monad transformers to "
"reimplement the document printing library, which we wrote earlier using the "
"`Reader` monad.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:570
#, markdown-text, no-wrap
msgid ""
"     Instead of using `line` to emit strings and `cat` to concatenate "
"strings, use the `Array String` monoid with the `WriterT` monad transformer, "
"and `tell` to append a line to the result. Use the same names as in the "
"original implementation but ending with an apostrophe (`'`).\n"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:571
#, markdown-text, no-wrap
msgid "Type Classes to the Rescue!"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:574
#, markdown-text
msgid ""
"When we looked at the `State` monad at the start of this chapter, I gave the "
"following types for the actions of the `State` monad:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:575
#, no-wrap
msgid ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:582
#, markdown-text
msgid ""
"In reality, the types given in the `Control.Monad.State.Class` module are "
"more general than this:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:583
#, no-wrap
msgid ""
"get    :: forall m s. MonadState s m =>             m s\n"
"put    :: forall m s. MonadState s m => s        -> m Unit\n"
"modify :: forall m s. MonadState s m => (s -> s) -> m Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:590
#, markdown-text
msgid ""
"The `Control.Monad.State.Class` module defines the `MonadState` "
"(multi-parameter) type class, which allows us to abstract over \"monads "
"which support pure mutable state\". As one would expect, the `State s` type "
"constructor is an instance of the `MonadState s` type class, but there are "
"many more interesting instances of this class."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:592
#, markdown-text
msgid ""
"In particular, there are instances of `MonadState` for the `WriterT`, "
"`ReaderT`, and `ExceptT` monad transformers provided in the `transformers` "
"package. Each has an instance for `MonadState` whenever the underlying "
"`Monad` does. In practice, this means that as long as `StateT` appears "
"_somewhere_ in the monad transformer stack, and everything above `StateT` is "
"an instance of `MonadState`, then we are free to use `get`, `put`, and "
"`modify` directly without the need to use `lift`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:594
#, markdown-text
msgid ""
"Indeed, the same is true of the actions we covered for the `ReaderT`, "
"`WriterT`, and `ExceptT` transformers. `transformers` defines a type class "
"for each of the major transformers, allowing us to abstract over monads that "
"support their operations."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:596
#, markdown-text
msgid ""
"In the case of the `split` function above, the monad stack we constructed is "
"an instance of each of the `MonadState`, `MonadWriter`, and `MonadError` "
"type classes. This means that we don't need to call `lift` at all! We can "
"just use the actions `get`, `put`, `tell`, and `throwError` as if they were "
"defined on the monad stack itself:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:597
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:split}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:602
#, markdown-text
msgid ""
"This computation looks like we have extended our programming language to "
"support the three new side-effects of mutable state, logging, and error "
"handling. However, everything is still implemented using pure functions and "
"immutable data under the hood."
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:603
#, markdown-text, no-wrap
msgid "Alternatives"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:606
#, markdown-text
msgid ""
"The `control` package defines a number of abstractions for working with "
"computations that can fail. One of these is the `Alternative` type class:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:607
#, no-wrap
msgid ""
"class Functor f <= Alt f where\n"
"  alt :: forall a. f a -> f a -> f a\n"
"\n"
"class Alt f <= Plus f where\n"
"  empty :: forall a. f a\n"
"\n"
"class (Applicative f, Plus f) <= Alternative f\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:618
#, markdown-text, no-wrap
msgid ""
"`Alternative` provides two new combinators: the `empty` value, which "
"provides a prototype for a failing computation, and the `alt` function (and "
"its alias, `<|>`), which provides the ability to fall back to an "
"_alternative_ computation in the case of an error.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:620
#, markdown-text
msgid ""
"The `Data.Array` module provides two useful functions for working with type "
"constructors in the `Alternative` type class:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:621
#, no-wrap
msgid ""
"many :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array "
"a)\n"
"some :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array "
"a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:627
#, markdown-text
msgid "There is also an equivalent `many` and `some` for `Data.List`"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:629
#, markdown-text
msgid ""
"The `many` combinator uses the `Alternative` type class to repeatedly run a "
"computation _zero-or-more_ times. The `some` combinator is similar but "
"requires at least the first computation to succeed."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:631
#, markdown-text
msgid ""
"In the case of our `Parser` monad transformer stack, there is an instance of "
"`Alternative` induced by the `ExceptT` component, which supports failure by "
"composing errors in different branches using a `Monoid` instance (this is "
"why we chose `Array String` for our `Errors` type). This means that we can "
"use the `many` and `some` functions to run a parser multiple times:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:632
#, no-wrap
msgid ""
"> import Data.Array (many)\n"
"\n"
"> runParser (many split) \"test\"\n"
"(Right (Tuple (Tuple [\"t\", \"e\", \"s\", \"t\"] \"\")\n"
"              [ \"The state is \\\"test\\\"\"\n"
"              , \"The state is \\\"est\\\"\"\n"
"              , \"The state is \\\"st\\\"\"\n"
"              , \"The state is \\\"t\\\"\"\n"
"              ]))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:645
#, markdown-text
msgid ""
"Here, the input string `\"test\"` has been repeatedly split to return an "
"array of four single-character strings, the leftover state is empty, and the "
"log shows that we applied the `split` combinator four times."
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:646
#, markdown-text, no-wrap
msgid "Monad Comprehensions"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:649
#, markdown-text
msgid ""
"The `Control.MonadPlus` module defines a subclass of the `Alternative` type "
"class, called `MonadPlus`. `MonadPlus` captures those type constructors "
"which are both monads and instances of `Alternative`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:650
#, no-wrap
msgid "class (Monad m, Alternative m) <= MonadPlus m\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:655
#, markdown-text
msgid "In particular, our `Parser` monad is an instance of `MonadPlus`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:657
#, markdown-text
msgid ""
"When we covered array comprehensions earlier in the book, we introduced the "
"`guard` function, which could be used to filter out unwanted results. In "
"fact, the `guard` function is more general and can be used for any monad, "
"which is an instance of `MonadPlus`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:658
#, no-wrap
msgid "guard :: forall m. Alternative m => Boolean -> m Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:663
#, markdown-text, no-wrap
msgid ""
"The `<|>` operator allows us to backtrack in case of failure. To see how "
"this is useful, let's define a variant of the `split` combinator which only "
"matches upper case characters:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:664
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:upper}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:669
#, markdown-text
msgid ""
"Here, we use a `guard` to fail if the string is not upper case. Note that "
"this code looks very similar to the array comprehensions we saw earlier – "
"using `MonadPlus` in this way, we sometimes refer to constructing _monad "
"comprehensions_."
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:670
#, markdown-text, no-wrap
msgid "Backtracking"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:673
#, markdown-text, no-wrap
msgid ""
"We can use the `<|>` operator to backtrack to another alternative in case of "
"failure. To demonstrate this, let's define one more parser, which matches "
"lower case characters:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:674
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:lower}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:679
#, markdown-text
msgid ""
"With this, we can define a parser which eagerly matches many upper case "
"characters if the first character is upper case, or many lower case "
"character if the first character is lower case:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:680
#, no-wrap
msgid "> upperOrLower = some upper <|> some lower\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:685
#, markdown-text
msgid "This parser will match characters until the case changes:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:686
#, no-wrap
msgid ""
"> runParser upperOrLower \"abcDEF\"\n"
"(Right (Tuple (Tuple [\"a\",\"b\",\"c\"] (\"DEF\"))\n"
"              [ \"The state is \\\"abcDEF\\\"\"\n"
"              , \"The state is \\\"bcDEF\\\"\"\n"
"              , \"The state is \\\"cDEF\\\"\"\n"
"              ]))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:696
#, markdown-text
msgid ""
"We can even use `many` to fully split a string into its lower and upper case "
"components:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter11.md:697
#, no-wrap
msgid ""
"> components = many upperOrLower\n"
"\n"
"> runParser components \"abCDeFgh\"\n"
"(Right (Tuple (Tuple "
"[[\"a\",\"b\"],[\"C\",\"D\"],[\"e\"],[\"F\"],[\"g\",\"h\"]] \"\")\n"
"              [ \"The state is \\\"abCDeFgh\\\"\"\n"
"              , \"The state is \\\"bCDeFgh\\\"\"\n"
"              , \"The state is \\\"CDeFgh\\\"\"\n"
"              , \"The state is \\\"DeFgh\\\"\"\n"
"              , \"The state is \\\"eFgh\\\"\"\n"
"              , \"The state is \\\"Fgh\\\"\"\n"
"              , \"The state is \\\"gh\\\"\"\n"
"              , \"The state is \\\"h\\\"\"\n"
"              ]))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:714
#, markdown-text
msgid ""
"Again, this illustrates the power of reusability that monad transformers "
"bring – we were able to write a backtracking parser in a declarative style "
"with only a few lines of code, by reusing standard abstractions!"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:721
#, markdown-text
msgid ""
"(Easy) Remove the calls to the `lift` function from your implementation of "
"the `string` parser. Verify that the new implementation type checks, and "
"convince yourself it should."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:721
#, markdown-text
msgid ""
"(Medium) Use your `string` parser with the `some` combinator to write a "
"parser `asFollowedByBs` that recognizes strings consisting of several copies "
"of the string `\"a\"` followed by several copies of the string `\"b\"`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:721
#, markdown-text
msgid ""
"(Medium) Use the `<|>` operator to write a parser `asOrBs` that recognizes "
"strings of the letters `a` or `b` in any order."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:721
#, markdown-text
msgid "(Difficult) The `Parser` monad might also be defined as follows:"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:725
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     type Parser = ExceptT Errors (StateT String (WriterT Log Identity))\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:727
#, markdown-text, no-wrap
msgid "     What effect does this change have on our parsing functions?\n"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:728
#, markdown-text, no-wrap
msgid "The RWS Monad"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:731
#, markdown-text
msgid ""
"One particular combination of monad transformers is so common that it is "
"provided as a single monad transformer in the `transformers` package. The "
"`Reader`, `Writer`, and `State` monads are combined into the "
"_reader-writer-state_ or simply `RWS` monad. This monad has a corresponding "
"monad transformer called the `RWST` monad transformer."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:733
#, markdown-text
msgid ""
"We will use the `RWS` monad to model the game logic for our text adventure "
"game."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:735
#, markdown-text
msgid ""
"The `RWS` monad is defined in terms of three type parameters (in addition to "
"its return type):"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:736
#, no-wrap
msgid "type RWS r w s = RWST r w s Identity\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:741
#, markdown-text
msgid ""
"Notice that the `RWS` monad is defined as its own monad transformer by "
"setting the base monad to `Identity`, which provides no side-effects."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:743
#, markdown-text
msgid ""
"The first type parameter, `r`, represents the global configuration type. The "
"second, `w`, represents the monoid, which we will use to accumulate a log, "
"and the third, `s`, is the type of our mutable state."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:745
#, markdown-text
msgid ""
"In the case of our game, our global configuration is defined in a type "
"called `GameEnvironment` in the `Data.GameEnvironment` module:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:746
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameEnvironment.purs:env}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:751
#, markdown-text
msgid ""
"It defines the player name and a flag that indicates whether or not the game "
"is running in debug mode. These options will be set from the command line "
"when we come to run our monad transformer."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:753
#, markdown-text
msgid ""
"The mutable state is defined in a type called `GameState` in the "
"`Data.GameState` module:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:754
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Data/GameState.purs:imports}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Data/GameState.purs:GameState}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:761
#, markdown-text
msgid ""
"The `Coords` data type represents points on a two-dimensional grid, and the "
"`GameItem` data type is an enumeration of the items in the game:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:762
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameItem.purs:GameItem}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:767
#, markdown-text
msgid ""
"The `GameState` type uses two new data structures: `Map` and `Set`, which "
"represent sorted maps and sorted sets, respectively. The `items` property is "
"a mapping from coordinates of the game grid to sets of game items at that "
"location. The `player` property stores the current coordinates of the "
"player, and the `inventory` property stores a set of game items currently "
"held by the player."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:769
#, markdown-text
msgid ""
"The `Map` and `Set` data structures are sorted by their keys, and can be "
"used with any key type in the `Ord` type class. This means that the keys in "
"our data structures should be totally ordered."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:771
#, markdown-text
msgid ""
"We will see how the `Map` and `Set` structures are used as we write the "
"actions for our game."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:773
#, markdown-text
msgid ""
"For our log, we will use the `List String` monoid. We can define a type "
"synonym for our `Game` monad, implemented using `RWS`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:774
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:Game}}\n"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:778
#, markdown-text, no-wrap
msgid "Implementing Game Logic"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:781
#, markdown-text
msgid ""
"Our game will be built from simple actions defined in the `Game` monad by "
"reusing the actions from the `Reader`, `Writer`, and `State` monads. At the "
"top level of our application, we will run the pure computations in the "
"`Game` monad and use the `Effect` monad to turn the results into observable "
"side-effects, such as printing text to the console."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:783
#, markdown-text
msgid ""
"One of the simplest actions in our game is the `has` action. This action "
"tests whether the player's inventory contains a particular game item. It is "
"defined as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:784
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:has}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:789
#, markdown-text
msgid ""
"This function uses the `get` action defined in the `MonadState` type class "
"to read the current game state and then uses the `member` function defined "
"in `Data.Set` to test whether the specified `GameItem` appears in the `Set` "
"of inventory items."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:791
#, markdown-text
msgid ""
"Another action is the `pickUp` action. It adds a game item to the player's "
"inventory if it appears in the current room. It uses actions from the "
"`MonadWriter` and `MonadState` type classes. First of all, it reads the "
"current game state:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:792
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_start}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:797
#, markdown-text
msgid ""
"Next, `pickUp` looks up the set of items in the current room. It does this "
"by using the `lookup` function defined in `Data.Map`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:798
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_case}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:803
#, markdown-text
msgid ""
"The `lookup` function returns an optional result indicated by the `Maybe` "
"type constructor. If the key does not appear in the map, the `lookup` "
"function returns `Nothing`; otherwise, it returns the corresponding value in "
"the `Just` constructor."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:805
#, markdown-text
msgid ""
"We are interested in the case where the corresponding item set contains the "
"specified game item. Again we can test this using the `member` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:806
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_Just}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:811
#, markdown-text
msgid ""
"In this case, we can use `put` to update the game state and `tell` to add a "
"message to the log:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:812
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_body}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:817
#, markdown-text
msgid ""
"Note that there is no need to `lift` either of the two computations here "
"because there are appropriate instances for both `MonadState` and "
"`MonadWriter` for our `Game` monad transformer stack."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:819
#, markdown-text
msgid ""
"The argument to `put` uses a record update to modify the game state's "
"`items` and `inventory` fields. We use the `update` function from "
"`Data.Map`, which modifies a value at a particular key. In this case, we "
"modify the set of items at the player's current location, using the `delete` "
"function to remove the specified item from the set. `inventory` is also "
"updated, using `insert` to add the new item to the player's inventory set."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:821
#, markdown-text
msgid ""
"Finally, the `pickUp` function handles the remaining cases by notifying the "
"user using `tell`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:822
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_err}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:827
#, markdown-text
msgid ""
"As an example of using the `Reader` monad, we can look at the code for the "
"`debug` command. This command allows the user to inspect the game state at "
"runtime if the game is running in debug mode:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:828
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:debug}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:833
#, markdown-text
msgid ""
"Here, we use the `ask` action to read the game configuration. Again, note "
"that we don't need to `lift` any computation, and we can use actions defined "
"in the `MonadState`, `MonadReader`, and `MonadWriter` type classes in the "
"same do notation block."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:835
#, markdown-text
msgid ""
"If the `debugMode` flag is set, the `tell` action is used to write the state "
"to the log. Otherwise, an error message is added."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:837
#, markdown-text
msgid ""
"The remainder of the `Game` module defines a set of similar actions, each "
"using only the actions defined by the `MonadState`, `MonadReader`, and "
"`MonadWriter` type classes."
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:838
#, markdown-text, no-wrap
msgid "Running the Computation"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:841
#, markdown-text
msgid ""
"Since our game logic runs in the `RWS` monad, it is necessary to run the "
"computation to respond to the user's commands."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:843
#, markdown-text
msgid ""
"The front-end of our game is built using two packages: `optparse`, which "
"provides applicative command line parsing, and `node-readline`, which wraps "
"NodeJS' `readline` module, allowing us to write interactive console-based "
"applications."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:845
#, markdown-text
msgid ""
"The interface to our game logic is provided by the function `game` in the "
"`Game` module:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:846
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:game_sig}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:851
#, markdown-text
msgid ""
"To run this computation, we pass a list of words entered by the user as an "
"array of strings and run the resulting `RWS` computation using `runRWS`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:852
#, no-wrap
msgid ""
"data RWSResult state result writer = RWSResult state result writer\n"
"\n"
"runRWS :: forall r w s a. RWS r w s a -> r -> s -> RWSResult s a w\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:859
#, markdown-text
msgid ""
"`runRWS` looks like a combination of `runReader`, `runWriter`, and "
"`runState`. It takes a global configuration and an initial state as an "
"argument and returns a data structure containing the log, the result, and "
"the final state."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:861
#, markdown-text
msgid ""
"The front-end of our application is defined by a function `runGame`, with "
"the following type signature:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:862
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_sig}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:867
#, markdown-text
msgid ""
"This function interacts with the user via the console (using the "
"`node-readline` and `console` packages). `runGame` takes the game "
"configuration as a function argument."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:869
#, markdown-text
msgid ""
"The `node-readline` package provides the `LineHandler` type, which "
"represents actions in the `Effect` monad, which handle user input from the "
"terminal. Here is the corresponding API:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:870
#, no-wrap
msgid ""
"type LineHandler a = String -> Effect a\n"
"\n"
"foreign import setLineHandler\n"
"  :: forall a\n"
"   . Interface\n"
"  -> LineHandler a\n"
"  -> Effect Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:881
#, markdown-text
msgid ""
"The `Interface` type represents a handle for the console and is passed as an "
"argument to the functions which interact with it. An `Interface` can be "
"created using the `createConsoleInterface` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:882
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:import_RL}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:runGame_interface}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:889
#, markdown-text
msgid ""
"The first step is to set the prompt at the console. We pass the `interface` "
"handle, and provide the prompt string and indentation level:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:890
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_prompt}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:895
#, markdown-text
msgid ""
"In our case, we are interested in implementing the line handler "
"function. Our line handler is defined using a helper function in a `let` "
"declaration, as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:896
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_lineHandler}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:901
#, markdown-text
msgid ""
"The `let` binding is closed over both the game configuration, named `env`, "
"and the console handle, named `interface`."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:903
#, markdown-text
msgid ""
"Our handler takes an additional first argument, the game state. This is "
"required since we need to pass the game state to `runRWS` to run the game's "
"logic."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:905
#, markdown-text
msgid ""
"The first thing this action does is to break the user input into words using "
"the `split` function from the `Data.String` module. It then uses `runRWS` to "
"run the `game` action (in the `RWS` monad), passing the game environment and "
"current game state."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:907
#, markdown-text
msgid ""
"Having run the game logic, which is a pure computation, we need to print any "
"log messages to the screen and show the user a prompt for the next "
"command. The `for_` action is used to traverse the log (of type `List "
"String`) and print its entries to the console. Finally, `setLineHandler` is "
"used to update the line handler function to use the updated game state, and "
"the prompt is displayed again using the `prompt` action."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:909
#, markdown-text
msgid ""
"The `runGame` function finally attaches the initial line handler to the "
"console interface and displays the initial prompt:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:910
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_attach_handler}}\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:918
#, markdown-text
msgid ""
"(Medium) Implement a new command `cheat`, which moves all game items from "
"the game grid into the user's inventory. Create a function `cheat :: Game "
"Unit` in the `Game` module, and use this function from `game`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:918
#, markdown-text
msgid ""
"(Difficult) The `Writer` component of the `RWS` monad is currently used for "
"two types of messages: error messages and informational messages. Because of "
"this, several parts of the code use case statements to handle error cases."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:920
#, markdown-text, no-wrap
msgid ""
"     Refactor the code to use the `ExceptT` monad transformer to handle the "
"error messages and `RWS` to handle informational messages. _Note:_ There are "
"no tests for this exercise.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter11.md:921
#, markdown-text, no-wrap
msgid "Handling Command Line Options"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:924
#, markdown-text
msgid ""
"The final piece of the application is responsible for parsing command line "
"options and creating the `GameEnvironment` configuration record. For this, "
"we use the `optparse` package."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:926
#, markdown-text
msgid ""
"`optparse` is an example of _applicative command line option "
"parsing_. Recall that an applicative functor allows us to lift functions of "
"arbitrary arity over a type constructor representing some type of "
"side-effect. In the case of the `optparse` package, the functor we are "
"interested in is the `Parser` functor (imported from the optparse module "
"`Options.Applicative`, not to be confused with our `Parser` that we defined "
"in the `Split` module), which adds the side-effect of reading from command "
"line options. It provides the following handler:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:927
#, no-wrap
msgid "customExecParser :: forall a. ParserPrefs -> ParserInfo a -> Effect a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:932
#, markdown-text
msgid ""
"This is best illustrated by example. The application's `main` function is "
"defined using `customExecParser` as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:933
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:main}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:938
#, markdown-text
msgid ""
"The first argument is used to configure the `optparse` library. In our case, "
"we simply configure it to show the help message when the application is run "
"without any arguments (instead of showing a \"missing argument\" error) by "
"using `OP.prefs OP.showHelpOnEmpty`, but the `Options.Applicative.Builder` "
"module provides several other options."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:940
#, markdown-text
msgid "The second argument is the complete description of our parser program:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:941
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:argParser}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:parserOptions}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:948
#, markdown-text, no-wrap
msgid ""
"Here `OP.info` combines a `Parser` with a set of options for how the help "
"message is formatted. `env <**> OP.helper` takes any command line argument "
"`Parser` named `env` and automatically adds a `--help` option. Options for "
"the help message are of type `InfoMod`, which is a monoid, so we can use the "
"`fold` function to add several options together.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:950
#, markdown-text
msgid "The interesting part of our parser is constructing the `GameEnvironment`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter11.md:951
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:env}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:956
#, markdown-text, no-wrap
msgid ""
"`player` and `debug` are both `Parser`s, so we can use our applicative "
"operators `<$>` and `<*>` to lift our `gameEnvironment` function, which has "
"the type `PlayerName -> Boolean -> GameEnvironment` over "
"`Parser`. `OP.strOption` constructs a command line option that expects a "
"string value and is configured via a collection of `Mod`s folded "
"together. `OP.flag` works similarly but doesn't expect an associated "
"value. `optparse` offers extensive "
"[documentation](https://pursuit.purescript.org/packages/purescript-optparse) "
"on different modifiers available to build various command line parsers.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:958
#, markdown-text, no-wrap
msgid ""
"Notice how we used the notation afforded by the applicative operators to "
"give a compact, declarative specification of our command line interface. In "
"addition, it is simple to add new command line arguments by adding a new "
"function argument to `runGame` and then using `<*>` to lift `runGame` over "
"an additional argument in the definition of `env`.\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter11.md:962
#, markdown-text
msgid ""
"(Medium) Add a new Boolean-valued property `cheatMode` to the "
"`GameEnvironment` record. Add a new command line flag `-c` to the `optparse` "
"configuration, enabling cheat mode. The `cheat` command from the previous "
"exercise should be disallowed if cheat mode is not enabled."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:966
#, markdown-text
msgid ""
"This chapter was a practical demonstration of the techniques we've learned "
"so far, using monad transformers to build a pure specification of our game "
"and the `Effect` monad to build a front-end using the console."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:968
#, markdown-text
msgid ""
"Because we separated our implementation from the user interface, it would be "
"possible to create other front-ends for our game. For example, we could use "
"the `Effect` monad to render the game in the browser using the Canvas API or "
"the DOM."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:970
#, markdown-text
msgid ""
"We have seen how monad transformers allow us to write safe code in an "
"imperative style, where the type system tracks effects. In addition, type "
"classes provide a powerful way to abstract over the actions provided by a "
"monad, enabling code reuse. We used standard abstractions like `Alternative` "
"and `MonadPlus` to build useful monads by combining standard monad "
"transformers."
msgstr ""

#. type: Plain text
#: ../text/chapter11.md:971
#, markdown-text
msgid ""
"Monad transformers are an excellent demonstration of expressive code that "
"can be written by relying on advanced type system features such as "
"higher-kinded polymorphism and multi-parameter type classes."
msgstr ""

#. type: Title #
#: ../text/chapter12.md:1
#, markdown-text, no-wrap
msgid "Canvas Graphics"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:6
#, markdown-text
msgid ""
"This chapter will be an extended example focussing on the `canvas` package, "
"which provides a way to generate 2D graphics from PureScript using the HTML5 "
"Canvas API."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:13
#, markdown-text
msgid "`canvas`, which gives types to methods from the HTML5 Canvas API"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:13
#, markdown-text
msgid "`refs`, which provides a side-effect for using _global mutable references_"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:15
#, markdown-text
msgid ""
"The source code for the chapter is broken up into a set of modules, each of "
"which defines a `main` method. Different sections of this chapter are "
"implemented in different files, and the `Main` module can be changed by "
"modifying the Spago build command to run the appropriate file's `main` "
"method at each point."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:17
#, markdown-text
msgid ""
"The HTML file `html/index.html` contains a single `canvas` element which "
"will be used in each example, and a `script` element to load the compiled "
"PureScript code. To test the code for each section, open the HTML file in "
"your browser. Because most exercises target the browser, this chapter has no "
"unit tests."
msgstr ""

#. type: Title ##
#: ../text/chapter12.md:18
#, markdown-text, no-wrap
msgid "Simple Shapes"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:21
#, markdown-text
msgid ""
"The `Example/Rectangle.purs` file contains a simple introductory example, "
"which draws a single blue rectangle at the center of the canvas. The module "
"imports the `Effect` type from the `Effect` module, and also the "
"`Graphics.Canvas` module, which contains actions in the `Effect` monad for "
"working with the Canvas API."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:23
#, markdown-text
msgid ""
"The `main` action starts, like in the other modules, by using the "
"`getCanvasElementById` action to get a reference to the canvas object and "
"the `getContext2D` action to access the 2D rendering context for the canvas:"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:25
#, markdown-text
msgid ""
"The `void` function takes a functor and replaces its value with `Unit`. In "
"the example, it is used to make `main` conform with its signature."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:26
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:main}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:31
#, markdown-text
msgid ""
"_Note_: the call to `unsafePartial` here is necessary since the pattern "
"match on the result of `getCanvasElementById` is partial, matching only the "
"`Just` constructor. For our purposes, this is fine, but in production code, "
"we would probably want to match the `Nothing` constructor and provide an "
"appropriate error message."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:33
#, markdown-text
msgid ""
"The types of these actions can be found using PSCi or by looking at the "
"documentation:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:34
#, no-wrap
msgid ""
"getCanvasElementById :: String -> Effect (Maybe CanvasElement)\n"
"\n"
"getContext2D :: CanvasElement -> Effect Context2D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:41
#, markdown-text
msgid ""
"`CanvasElement` and `Context2D` are types defined in the `Graphics.Canvas` "
"module. The same module also defines the `Canvas` effect, which is used by "
"all of the actions in the module."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:43
#, markdown-text
msgid ""
"The graphics context `ctx` manages the state of the canvas and provides "
"methods to render primitive shapes, set styles and colors, and apply "
"transformations."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:45
#, markdown-text
msgid ""
"We continue by setting the fill style to solid blue using the `setFillStyle` "
"action. The longer hex notation of `#0000FF` may also be used for blue, but "
"shorthand notation is easier for simple colors:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:46
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter12/src/Example/Rectangle.purs:setFillStyle}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:51
#, markdown-text
msgid ""
"Note that the `setFillStyle` action takes the graphics context as an "
"argument. This is a common pattern in the `Graphics.Canvas` module."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:53
#, markdown-text
msgid ""
"Finally, we use the `fillPath` action to fill the rectangle. `fillPath` has "
"the following type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:54
#, no-wrap
msgid "fillPath :: forall a. Context2D -> Effect a -> Effect a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:59
#, markdown-text
msgid ""
"`fillPath` takes a graphics context and another action that builds the path "
"to render. To build a path, we can use the `rect` action. `rect` takes a "
"graphics context and a record that provides the position and size of the "
"rectangle:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:60
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:fillPath}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:65
#, markdown-text
msgid ""
"Build the rectangle example, providing `Example.Rectangle` as the name of "
"the main module:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:66
#, no-wrap
msgid "$ spago bundle-app --main Example.Rectangle --to dist/Main.js\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:71
#, markdown-text
msgid ""
"Now, open the `html/index.html` file and verify that this code renders a "
"blue rectangle in the center of the canvas."
msgstr ""

#. type: Title ##
#: ../text/chapter12.md:72
#, markdown-text, no-wrap
msgid "Putting Row Polymorphism to Work"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:75
#, markdown-text
msgid ""
"There are other ways to render paths. The `arc` function renders an arc "
"segment, and the `moveTo`, `lineTo`, and `closePath` functions can render "
"piecewise-linear paths."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:77
#, markdown-text
msgid ""
"The `Shapes.purs` file renders three shapes: a rectangle, an arc segment, "
"and a triangle."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:79
#, markdown-text
msgid ""
"We have seen that the `rect` function takes a record as its argument. In "
"fact, the properties of the rectangle are defined in a type synonym:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:80
#, no-wrap
msgid ""
"type Rectangle =\n"
"  { x :: Number\n"
"  , y :: Number\n"
"  , width :: Number\n"
"  , height :: Number\n"
"  }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:90
#, markdown-text
msgid ""
"The `x` and `y` properties represent the location of the top-left corner, "
"while the `width` and `height` properties represent the lengths of the "
"rectangle, respectively."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:92
#, markdown-text
msgid ""
"To render an arc segment, we can use the `arc` function, passing a record "
"with the following type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:93
#, no-wrap
msgid ""
"type Arc =\n"
"  { x      :: Number\n"
"  , y      :: Number\n"
"  , radius :: Number\n"
"  , start  :: Number\n"
"  , end    :: Number\n"
"  }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:104
#, markdown-text
msgid ""
"Here, the `x` and `y` properties represent the center point, `radius` is the "
"radius, `start` and `end` represent the endpoints of the arc in radians."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:106
#, markdown-text
msgid ""
"For example, this code fills an arc segment centered at `(300, 300)` with "
"radius `50`. The arc completes 2/3rds of a rotation. Note that the unit "
"circle is flipped vertically since the y-axis increases towards the bottom "
"of the canvas:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:107
#, no-wrap
msgid ""
"  fillPath ctx $ arc ctx\n"
"    { x      : 300.0\n"
"    , y      : 300.0\n"
"    , radius : 50.0\n"
"    , start  : 0.0\n"
"    , end    : Math.tau * 2.0 / 3.0\n"
"    }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:118
#, markdown-text
msgid ""
"Notice that both the `Rectangle` and `Arc` record types contain `x` and `y` "
"properties of type `Number`. In both cases, this pair represents a "
"point. This means we can write row-polymorphic functions acting on either "
"type of record."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:120
#, markdown-text
msgid ""
"For example, the `Shapes` module defines a `translate` function that "
"translates a shape by modifying its `x` and `y` properties:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:121
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:translate}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:126
#, markdown-text
msgid ""
"Notice the row-polymorphic type. It says that `translate` accepts any record "
"with `x` and `y` properties _and any other properties_, and returns the same "
"type of record. The `x` and `y` fields are updated, but the rest of the "
"fields remain unchanged."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:128
#, markdown-text
msgid ""
"This is an example of _record update syntax_. The expression `shape { ... }` "
"creates a new record based on the `shape` record, with the fields inside the "
"braces updated to the specified values. Note that the expressions inside the "
"braces are separated from their labels by equals symbols, not colons like in "
"record literals."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:130
#, markdown-text
msgid ""
"The `translate` function can be used with both the `Rectangle` and `Arc` "
"records, as seen in the `Shapes` example."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:132
#, markdown-text
msgid ""
"The third type of path rendered in the `Shapes` example is a "
"piecewise-linear path. Here is the corresponding code:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:133
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:path}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:138
#, markdown-text
msgid "There are three functions in use here:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:142
#, markdown-text
msgid ""
"`moveTo` moves the current location of the path to the specified "
"coordinates,"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:142
#, markdown-text
msgid ""
"`lineTo` renders a line segment between the current location and the "
"specified coordinates, and updates the current location,"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:142
#, markdown-text
msgid ""
"`closePath` completes the path by rendering a line segment joining the "
"current location to the start position."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:144
#, markdown-text
msgid "The result of this code snippet is to fill an isosceles triangle."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:146
#, markdown-text
msgid "Build the example by specifying `Example.Shapes` as the main module:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:147
#, no-wrap
msgid "$ spago bundle-app --main Example.Shapes --to dist/Main.js\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:152
#, markdown-text
msgid ""
"and open `html/index.html` again to see the result. You should see the three "
"different types of shapes rendered to the canvas."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:158
#, markdown-text
msgid ""
"(Easy) Experiment with the `strokePath` and `setStrokeStyle` functions in "
"each example so far."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:158
#, markdown-text
msgid ""
"(Easy) The `fillPath` and `strokePath` functions can render complex paths "
"with a common style using a do notation block inside the function "
"argument. Try changing the `Rectangle` example to render two rectangles "
"side-by-side using the same call to `fillPath`. Try rendering a sector of a "
"circle by using a combination of a piecewise-linear path and an arc segment."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:158
#, markdown-text
msgid "(Medium) Given the following record type:"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:162
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     type Point = { x :: Number, y :: Number }\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:164
#, markdown-text, no-wrap
msgid ""
"     which represents a 2D point, write a function `renderPath` which "
"strokes a closed path constructed from a number of points:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:171
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     renderPath\n"
"       :: Context2D\n"
"       -> Array Point\n"
"       -> Effect Unit\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:173
#, markdown-text, no-wrap
msgid "     Given a function\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:177
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     f :: Number -> Point\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:179
#, markdown-text, no-wrap
msgid ""
"     which takes a `Number` between `0` and `1` as its argument and returns "
"a `Point`, write an action that plots `f` by using your `renderPath` "
"function. Your action should approximate the path by sampling `f` at a "
"finite set of points.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:181
#, markdown-text, no-wrap
msgid "     Experiment by rendering different paths by varying the function `f`.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter12.md:182
#, markdown-text, no-wrap
msgid "Drawing Random Circles"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:185
#, markdown-text
msgid ""
"The `Example/Random.purs` file contains an example that uses the `Effect` "
"monad to interleave two types of side-effect: random number generation and "
"canvas manipulation. The example renders one hundred randomly generated "
"circles onto the canvas."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:187
#, markdown-text
msgid ""
"The `main` action obtains a reference to the graphics context as before and "
"then sets the stroke and fill styles:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:188
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:style}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:193
#, markdown-text
msgid ""
"Next, the code uses the `for_` function to loop over the integers between "
"`0` and `100`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:194
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:for}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:199
#, markdown-text
msgid ""
"On each iteration, the do notation block starts by generating three random "
"numbers distributed between `0` and `1`. These numbers represent the `x` and "
"`y` coordinates and the radius of a circle:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:random}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:205
#, markdown-text
msgid ""
"Next, for each circle, the code creates an `Arc` based on these parameters "
"and finally fills and strokes the arc with the current styles:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:path}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:211
#, markdown-text
msgid ""
"Build this example by specifying the `Example.Random` module as the main "
"module:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:212
#, no-wrap
msgid "$ spago bundle-app --main Example.Random --to dist/Main.js\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:217
#, markdown-text
msgid "and view the result by opening `html/index.html`."
msgstr ""

#. type: Title ##
#: ../text/chapter12.md:218
#, markdown-text, no-wrap
msgid "Transformations"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:221
#, markdown-text
msgid ""
"There is more to the canvas than just rendering simple shapes. Every canvas "
"maintains a transformation that is used to transform shapes before "
"rendering. Shapes can be translated, rotated, scaled, and skewed."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:223
#, markdown-text
msgid ""
"The `canvas` library supports these transformations using the following "
"functions:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:224
#, no-wrap
msgid ""
"translate :: Context2D\n"
"          -> TranslateTransform\n"
"          -> Effect Context2D\n"
"\n"
"rotate    :: Context2D\n"
"          -> Number\n"
"          -> Effect Context2D\n"
"\n"
"scale     :: Context2D\n"
"          -> ScaleTransform\n"
"          -> Effect Context2D\n"
"\n"
"transform :: Context2D\n"
"          -> Transform\n"
"          -> Effect Context2D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:243
#, markdown-text
msgid ""
"The `translate` action performs a translation whose components are specified "
"by the properties of the `TranslateTransform` record."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:245
#, markdown-text
msgid ""
"The `rotate` action rotates around the origin through some number of radians "
"specified by the first argument."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:247
#, markdown-text
msgid ""
"The `scale` action performs a scaling, with the origin as the center. The "
"`ScaleTransform` record specifies the scale factors along the `x` and `y` "
"axes."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:249
#, markdown-text
msgid ""
"Finally, `transform` is the most general action of the four here. It "
"performs an affine transformation specified by a matrix."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:251
#, markdown-text
msgid ""
"Any shapes rendered after these actions have been invoked will automatically "
"have the appropriate transformation applied."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:253
#, markdown-text
msgid ""
"In fact, the effect of each of these functions is to _post-multiply_ the "
"transformation with the context's current transformation. The result is that "
"if multiple transformations applied after one another, then their effects "
"are actually applied in reverse:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:254
#, no-wrap
msgid ""
"transformations ctx = do\n"
"  translate ctx { translateX: 10.0, translateY: 10.0 }\n"
"  scale ctx { scaleX: 2.0, scaleY: 2.0 }\n"
"  rotate ctx (Math.tau / 4.0)\n"
"\n"
"  renderScene\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:264
#, markdown-text
msgid ""
"The effect of this sequence of actions is that the scene is rotated, then "
"scaled, and finally translated."
msgstr ""

#. type: Title ##
#: ../text/chapter12.md:265
#, markdown-text, no-wrap
msgid "Preserving the Context"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:268
#, markdown-text
msgid ""
"A common use case is to render some subset of the scene using a "
"transformation and then reset the transformation."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:270
#, markdown-text
msgid ""
"The Canvas API provides the `save` and `restore` methods, which manipulate a "
"_stack_ of states associated with the canvas. `canvas` wraps this "
"functionality into the following functions:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:271
#, no-wrap
msgid ""
"save\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
"\n"
"restore\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:282
#, markdown-text
msgid ""
"The `save` action pushes the current state of the context (including the "
"current transformation and any styles) onto the stack, and the `restore` "
"action pops the top state from the stack and restores it."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:284
#, markdown-text
msgid ""
"This allows us to save the current state, apply some styles and "
"transformations, render some primitives, and finally restore the original "
"transformation and state. For example, the following function performs some "
"canvas action but applies a rotation before doing so and restores the "
"transformation afterwards:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:285
#, no-wrap
msgid ""
"rotated ctx render = do\n"
"  save ctx\n"
"  rotate (Math.tau / 3.0) ctx\n"
"  render\n"
"  restore ctx\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:294
#, markdown-text
msgid ""
"In the interest of abstracting over common use cases using higher-order "
"functions, the `canvas` library provides the `withContext` function, which "
"performs some canvas action while preserving the original context state:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:295
#, no-wrap
msgid ""
"withContext\n"
"  :: Context2D\n"
"  -> Effect a\n"
"  -> Effect a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:303
#, markdown-text
msgid ""
"We could rewrite the `rotated` function above using `withContext` as "
"follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:304
#, no-wrap
msgid ""
"rotated ctx render =\n"
"  withContext ctx do\n"
"    rotate (Math.tau / 3.0) ctx\n"
"    render\n"
msgstr ""

#. type: Title ##
#: ../text/chapter12.md:311
#, markdown-text, no-wrap
msgid "Global Mutable State"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:314
#, markdown-text
msgid ""
"In this section, we'll use the `refs` package to demonstrate another effect "
"in the `Effect` monad."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:316
#, markdown-text
msgid ""
"The `Effect.Ref` module provides a type constructor for global mutable "
"references and an associated effect:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:317
#, no-wrap
msgid ""
"> import Effect.Ref\n"
"\n"
"> :kind Ref\n"
"Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:325
#, markdown-text
msgid ""
"A value of type `Ref a` is a mutable reference cell containing a value of "
"type `a`, used to track global mutation. As such, it should be used "
"sparingly."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:327
#, markdown-text
msgid ""
"The `Example/Refs.purs` file contains an example that uses a `Ref` to track "
"mouse clicks on the `canvas` element."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:329
#, markdown-text
msgid ""
"The code starts by creating a new reference containing the value `0` by "
"using the `new` action:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:330
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:clickCount}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:335
#, markdown-text
msgid ""
"Inside the click event handler, the `modify` action is used to update the "
"click count, and the updated value is returned."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:336
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:count}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:341
#, markdown-text
msgid ""
"In the `render` function, the click count is used to determine the "
"transformation applied to a rectangle:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:342
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:withContext}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:347
#, markdown-text
msgid ""
"This action uses `withContext` to preserve the original transformation and "
"then applies the following sequence of transformations (remember that "
"transformations are applied bottom-to-top):"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:352
#, markdown-text
msgid ""
"The rectangle is translated through `(-100, -100)`, so its center lies at "
"the origin."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:352
#, markdown-text
msgid "The rectangle is scaled around the origin."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:352
#, markdown-text
msgid ""
"The rectangle is rotated through some multiple of `10` degrees around the "
"origin."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter12.md:352
#, markdown-text
msgid ""
"The rectangle is translated through `(300, 300)`, so its center lies at the "
"center of the canvas."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:354
#, markdown-text
msgid "Build the example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:355
#, no-wrap
msgid "$ spago bundle-app --main Example.Refs --to dist/Main.js\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:360
#, markdown-text
msgid ""
"and open the `html/index.html` file. If you click the canvas repeatedly, you "
"should see a green rectangle rotating around the center of the canvas."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:366
#, markdown-text
msgid ""
"(Easy) Write a higher-order function that simultaneously strokes and fills a "
"path. Rewrite the `Random.purs` example using your function."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:366
#, markdown-text
msgid ""
"(Medium) Use `Random` and `Dom` to create an application that renders a "
"circle with random position, color, and radius to the canvas when the mouse "
"is clicked."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:366
#, markdown-text
msgid ""
"(Medium) Write a function that transforms the scene by rotating it around a "
"point with specified coordinates. _Hint_: use a translation to first "
"translate the scene to the origin."
msgstr ""

#. type: Title ##
#: ../text/chapter12.md:367
#, markdown-text, no-wrap
msgid "L-Systems"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:370
#, markdown-text
msgid ""
"In this final example, we will use the `canvas` package to write a function "
"for rendering _L-systems_ (or _Lindenmayer systems_)."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:372
#, markdown-text
msgid ""
"An L-system is defined by an _alphabet_, an initial sequence of letters from "
"the alphabet, and a set of _production rules_. Each production rule takes a "
"letter of the alphabet and returns a sequence of replacement letters. This "
"process is iterated some number of times, starting with the initial sequence "
"of letters."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:374
#, markdown-text
msgid ""
"If each letter of the alphabet is associated with some instruction to "
"perform on the canvas, the L-system can be rendered by following the "
"instructions in order."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:376
#, markdown-text
msgid ""
"For example, suppose the alphabet consists of the letters `L` (turn left), "
"`R` (turn right), and `F` (move forward). We might define the following "
"production rules:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:377
#, no-wrap
msgid ""
"L -> L\n"
"R -> R\n"
"F -> FLFRRFLF\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:384
#, markdown-text
msgid ""
"If we start with the initial sequence \"FRRFRRFRR\" and iterate, we obtain "
"the following sequence:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:385
#, no-wrap
msgid ""
"FRRFRRFRR\n"
"FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR\n"
"FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:392
#, markdown-text
msgid ""
"and so on. Plotting a piecewise-linear path corresponding to this set of "
"instructions approximates the _Koch curve_. Increasing the number of "
"iterations increases the resolution of the curve."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:394
#, markdown-text
msgid "Let's translate this into the language of types and functions."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:396
#, markdown-text
msgid "We can represent our alphabet of letters with the following ADT:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:397
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:letter}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:402
#, markdown-text
msgid "This data type defines one data constructor for each letter in our alphabet."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:404
#, markdown-text
msgid ""
"How can we represent the initial sequence of letters? Well, that's just an "
"array of letters from our alphabet, which we will call a `Sentence`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:405
#, no-wrap
msgid ""
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:sentence}}\n"
"\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:initial}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:412
#, markdown-text
msgid ""
"Our production rules can be represented as a function from `Letter` to "
"`Sentence` as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:413
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:productions}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:418
#, markdown-text
msgid "This is just copied straight from the specification above."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:420
#, markdown-text
msgid ""
"Now we can implement a function `lsystem` that will take a specification in "
"this form and render it to the canvas. What type should `lsystem` have? "
"Well, it needs to take values like `initial` and `productions` as arguments, "
"as well as a function that can render a letter of the alphabet to the "
"canvas."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:422
#, markdown-text
msgid "Here is a first approximation to the type of `lsystem`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:423
#, no-wrap
msgid ""
"Sentence\n"
"-> (Letter -> Sentence)\n"
"-> (Letter -> Effect Unit)\n"
"-> Int\n"
"-> Effect Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:432
#, markdown-text
msgid ""
"The first two argument types correspond to the values `initial` and "
"`productions`."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:434
#, markdown-text
msgid ""
"The third argument represents a function that takes a letter of the alphabet "
"and _interprets_ it by performing some actions on the canvas. In our "
"example, this would mean turning left in the case of the letter `L`, turning "
"right in the case of the letter `R`, and moving forward in the case of a "
"letter `F`."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:436
#, markdown-text
msgid ""
"The final argument is a number representing the number of iterations of the "
"production rules we would like to perform."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:438
#, markdown-text
msgid ""
"The first observation is that the `lsystem` function should work for only "
"one type of `Letter`, but for any type, so we should generalize our type "
"accordingly. Let's replace `Letter` and `Sentence` with `a` and `Array a` "
"for some quantified type variable `a`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:439
#, no-wrap
msgid ""
"forall a. Array a\n"
"          -> (a -> Array a)\n"
"          -> (a -> Effect Unit)\n"
"          -> Int\n"
"          -> Effect Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:448
#, markdown-text
msgid ""
"The second observation is that, to implement instructions like \"turn left\" "
"and \"turn right\", we will need to maintain some state, namely the "
"direction in which the path is moving at any time. We need to modify our "
"function to pass the state through the computation. Again, the `lsystem` "
"function should work for any type of state, so we will represent it using "
"the type variable `s`."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:450
#, markdown-text
msgid "We need to add the type `s` in three places:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:451
#, no-wrap
msgid ""
"forall a s. Array a\n"
"            -> (a -> Array a)\n"
"            -> (s -> a -> Effect s)\n"
"            -> Int\n"
"            -> s\n"
"            -> Effect s\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:461
#, markdown-text
msgid ""
"Firstly, the type `s` was added as the type of an additional argument to "
"`lsystem`. This argument will represent the initial state of the L-system."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:463
#, markdown-text
msgid ""
"The type `s` also appears as an argument to, and as the return type of the "
"interpretation function (the third argument to `lsystem`). The "
"interpretation function will now receive the current state of the L-system "
"as an argument, and will return a new, updated state as its return value."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:465
#, markdown-text
msgid ""
"In the case of our example, we can define use following type to represent "
"the state:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:466
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:state}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:471
#, markdown-text
msgid ""
"The properties `x` and `y` represent the current position of the path, and "
"the `theta` property represents the current direction of the path, specified "
"as the angle between the path direction and the horizontal axis, in radians."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:473
#, markdown-text
msgid "The initial state of the system might be specified as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:474
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:initialState}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:479
#, markdown-text
msgid ""
"Now let's try to implement the `lsystem` function. We will find that its "
"definition is remarkably simple."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:481
#, markdown-text
msgid ""
"It seems reasonable that `lsystem` should recurse on its fourth argument (of "
"type `Int`). On each step of the recursion, the current sentence will "
"change, having been updated by using the production rules. With that in "
"mind, let's begin by introducing names for the function arguments, and "
"delegating to a helper function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:482
#, no-wrap
msgid ""
"lsystem :: forall a s\n"
"         . Array a\n"
"        -> (a -> Array a)\n"
"        -> (s -> a -> Effect s)\n"
"        -> Int\n"
"        -> s\n"
"        -> Effect s\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_impl}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:494
#, markdown-text
msgid ""
"The `go` function works by recursion on its second argument. There are two "
"cases: when `n` is zero and `n` is non-zero."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:496
#, markdown-text, no-wrap
msgid ""
"In the first case, the recursion is complete, and we need to interpret the "
"current sentence according to the interpretation function. We have a "
"sentence of type `Array a`, a state of type `s`, and a function of type `s "
"-> a -> Effect s`. This sounds like a job for the `foldM` function which we "
"defined earlier, and which is available from the `control` package:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:497
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_0}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:502
#, markdown-text
msgid ""
"What about in the non-zero case? In that case, we can simply apply the "
"production rules to each letter of the current sentence, concatenate the "
"results, and repeat by calling `go` recursively:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:503
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_i}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:508
#, markdown-text
msgid ""
"That's it! Note how using higher-order functions like `foldM` and "
"`concatMap` allowed us to communicate our ideas concisely."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:510
#, markdown-text
msgid ""
"However, we're not quite done. The type we have given is actually still too "
"specific. Note that we don't use any canvas operations anywhere in our "
"implementation. Nor do we make use of the structure of the `Effect` monad at "
"all. In fact, our function works for _any_ monad `m`!"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:512
#, markdown-text
msgid ""
"Here is the more general type of `lsystem`, as specified in the accompanying "
"source code for this chapter:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:513
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_anno}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:518
#, markdown-text
msgid ""
"We can understand this type as saying that our interpretation function is "
"free to have any side-effects at all, captured by the monad `m`. It might "
"render to the canvas, print information to the console, or support failure "
"or multiple return values. The reader is encouraged to try writing L-systems "
"that use these various types of side-effect."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:520
#, markdown-text
msgid ""
"This function is a good example of the power of separating data from "
"implementation. The advantage of this approach is that we can interpret our "
"data in multiple ways. We might even factor `lsystem` into two smaller "
"functions: the first would build the sentence using repeated application of "
"`concatMap`, and the second would interpret the sentence using `foldM`. This "
"is also left as an exercise for the reader."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:522
#, markdown-text, no-wrap
msgid ""
"Let's complete our example by implementing its interpretation function. The "
"type of `lsystem` tells us that its type signature must be `s -> a -> m s` "
"for some types `a` and `s` and a type constructor `m`. We know that we want "
"`a` to be `Letter` and `s` to be `State`, and for the monad `m` we can "
"choose `Effect`. This gives us the following type:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:523
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter12/src/Example/LSystem.purs:interpret_anno}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:528
#, markdown-text
msgid ""
"To implement this function, we need to handle the three data constructors of "
"the `Letter` type. To interpret the letters `L` (move left) and `R` (move "
"right), we simply have to update the state to change the angle `theta` "
"appropriately:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:529
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretLR}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:534
#, markdown-text
msgid ""
"To interpret the letter `F` (move forward), we can calculate the new "
"position of the path, render a line segment, and update the state as "
"follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:535
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretF}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:540
#, markdown-text
msgid ""
"Note that in the source code for this chapter, the `interpret` function is "
"defined using a `let` binding inside the `main` function, so that the name "
"`ctx` is in scope. It would also be possible to move the context into the "
"`State` type, but this would be inappropriate because it is not a changing "
"part of the state of the system."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:542
#, markdown-text
msgid "To render this L-system, we can simply use the `strokePath` action:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:543
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:strokePath}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:548
#, markdown-text
msgid "Compile the L-system example using"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter12.md:549
#, no-wrap
msgid "$ spago bundle-app --main Example.LSystem --to dist/Main.js\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:554
#, markdown-text
msgid ""
"and open `html/index.html`. You should see the Koch curve rendered to the "
"canvas."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:562
#, markdown-text
msgid ""
"(Easy) Modify the L-system example above to use `fillPath` instead of "
"`strokePath`. _Hint_: you will need to include a call to `closePath`, and "
"move the call to `moveTo` outside of the `interpret` function."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:562
#, markdown-text
msgid ""
"(Easy) Try changing the various numerical constants in the code to "
"understand their effect on the rendered system."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:562
#, markdown-text
msgid ""
"(Medium) Break the `lsystem` function into two smaller functions. The first "
"should build the final sentence using repeated application of `concatMap`, "
"and the second should use `foldM` to interpret the result."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:562
#, markdown-text
msgid ""
"(Medium) Add a drop shadow to the filled shape using the `setShadowOffsetX`, "
"`setShadowOffsetY`, `setShadowBlur`, and `setShadowColor` actions. _Hint_: "
"use PSCi to find the types of these functions."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter12.md:562
#, markdown-text
msgid ""
"(Medium) The angle of the corners is currently a constant \\\\( \\\\tau / 6 "
"\\\\). Instead, it can be moved into the `Letter` data type, which allows it "
"to be changed by the production rules:"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:565
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     type Angle = Number\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:568
#, markdown-text, no-wrap
msgid ""
"     data Letter = L Angle | R Angle | F\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:571
#, markdown-text, no-wrap
msgid ""
"     How can this new information be used in the production rules to create "
"interesting shapes?\n"
" 1. (Difficult) An L-system is given by an alphabet with four letters: `L` "
"(turn left through 60 degrees), `R` (turn right through 60 degrees), `F` "
"(move forward), and `M` (also move forward).\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:573
#, markdown-text, no-wrap
msgid "     The initial sentence of the system is the single letter `M`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:575
#, markdown-text, no-wrap
msgid "     The production rules are specified as follows:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:582
#, markdown-text, no-wrap
msgid ""
"     ```text\n"
"     L -> L\n"
"     R -> R\n"
"     F -> FLMLFRMRFRMRFLMLF\n"
"     M -> MRFRMLFLMLFLMRFRM\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:584
#, markdown-text, no-wrap
msgid ""
"     Render this L-system. _Note_: you will need to decrease the number of "
"iterations of the production rules since the size of the final sentence "
"grows exponentially with the number of iterations.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:586
#, markdown-text, no-wrap
msgid ""
"     Now, notice the symmetry between `L` and `M` in the production "
"rules. The two \"move forward\" instructions can be differentiated using a "
"`Boolean` value using the following alphabet type:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:590
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     data Letter = L | R | F Boolean\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:593
#, markdown-text, no-wrap
msgid ""
"     Implement this L-system again using this representation of the "
"alphabet.\n"
" 1. (Difficult) Use a different monad `m` in the interpretation "
"function. You might try using `Effect.Console` to write the L-system onto "
"the console, or using `Effect.Random` to apply random \"mutations\" to the "
"state type.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:597
#, markdown-text
msgid ""
"In this chapter, we learned how to use the HTML5 Canvas API from PureScript "
"by using the `canvas` library. We also saw a practical demonstration of many "
"techniques we have learned already: maps and folds, records and row "
"polymorphism, and the `Effect` monad for handling side-effects."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:599
#, markdown-text
msgid ""
"The examples also demonstrated the power of higher-order functions and "
"_separating data from implementation_. It would be possible to extend these "
"ideas to completely separate the representation of a scene from its "
"rendering function, using an algebraic data type, for example:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter12.md:600
#, no-wrap
msgid ""
"data Scene\n"
"  = Rect Rectangle\n"
"  | Arc Arc\n"
"  | PiecewiseLinear (Array Point)\n"
"  | Transformed Transform Scene\n"
"  | Clipped Rectangle Scene\n"
"  | ...\n"
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:611
#, markdown-text
msgid ""
"This approach is taken in the `drawing` package, and it brings the "
"flexibility of manipulating the scene as data in various ways before "
"rendering."
msgstr ""

#. type: Plain text
#: ../text/chapter12.md:612
#, markdown-text
msgid ""
"For examples of games rendered to the canvas, see the \"Behavior\" and "
"\"Signal\" recipes in the "
"[cookbook](https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes)."
msgstr ""

#. type: Title #
#: ../text/chapter13.md:1
#, markdown-text, no-wrap
msgid "Generative Testing"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:6
#, markdown-text
msgid ""
"In this chapter, we will see a particularly elegant application of type "
"classes to the problem of testing. Instead of testing our code by telling "
"the compiler _how_ to test, we simply assert _what_ properties our code "
"should have. Test cases can be generated randomly from this specification, "
"using type classes to hide the boilerplate code of random data "
"generation. This is called _generative testing_ (or _property-based "
"testing_), a technique made popular by the "
"[QuickCheck](https://wiki.haskell.org/Introduction_to_QuickCheck1) library "
"in Haskell."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:8
#, markdown-text
msgid ""
"The `quickcheck` package is a port of Haskell's QuickCheck library to "
"PureScript, and for the most part, it preserves the types and syntax of the "
"original library. We will see how to use `quickcheck` to test a simple "
"library, using Spago to integrate our test suite into our development "
"process."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:12
#, markdown-text
msgid "This chapter's project adds `quickcheck` as a dependency."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:14
#, markdown-text
msgid ""
"In a Spago project, test sources should be placed in the `test` directory, "
"and the main module for the test suite should be named `Test.Main`. The test "
"suite can be run using the `spago test` command."
msgstr ""

#. type: Title ##
#: ../text/chapter13.md:15
#, markdown-text, no-wrap
msgid "Writing Properties"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:18
#, markdown-text
msgid ""
"The `Merge` module implements a simple function `merge`, which we will use "
"to demonstrate the features of the `quickcheck` library."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:19
#, no-wrap
msgid "merge :: Array Int -> Array Int -> Array Int\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:24
#, markdown-text
msgid ""
"`merge` takes two sorted arrays of integers and merges their elements so "
"that the result is also sorted. For example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter13.md:25
#, no-wrap
msgid ""
"> import Merge\n"
"> merge [1, 3, 5] [2, 4, 5]\n"
"\n"
"[1, 2, 3, 4, 5, 5]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:33
#, markdown-text
msgid ""
"In a typical test suite, we might test `merge` by generating a few small "
"test cases like this by hand and asserting that the results were equal to "
"the appropriate values. However, everything we need to know about the "
"`merge` function can be summarized by this property:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter13.md:35
#, markdown-text
msgid ""
"If `xs` and `ys` are sorted, then `merge xs ys` is the sorted result of both "
"arrays appended together."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:37
#, markdown-text
msgid ""
"`quickcheck` allows us to test this property directly by generating random "
"test cases. We state the properties we want our code to have as "
"functions. In this case, we have a single property:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:38
#, no-wrap
msgid ""
"main = do\n"
"  quickCheck \\xs ys ->\n"
"    eq (merge (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:45
#, markdown-text
msgid ""
"When we run this code, `quickcheck` will attempt to disprove the properties "
"we claimed by generating random inputs `xs` and `ys` and passing them to our "
"functions. If our function returns `false` for any inputs, the property will "
"be incorrect, and the library will raise an error. Fortunately, the library "
"is unable to disprove our properties after generating 100 random test cases:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter13.md:46
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Installation complete.\n"
"Build succeeded.\n"
"100/100 test(s) passed.\n"
"...\n"
"Tests succeeded.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:57
#, markdown-text
msgid ""
"If we deliberately introduce a bug into the `merge` function (for example, "
"by changing the less-than check for a greater-than check), then an exception "
"is thrown at runtime after the first failed test case:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter13.md:58
#, no-wrap
msgid ""
"Error: Test 1 failed:\n"
"Test returned false\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:64
#, markdown-text
msgid ""
"As we can see, this error message is not very helpful, but it can be "
"improved with a little work."
msgstr ""

#. type: Title ##
#: ../text/chapter13.md:65
#, markdown-text, no-wrap
msgid "Improving Error Messages"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:68
#, markdown-text, no-wrap
msgid ""
"To provide error messages along with our failed test cases, `quickcheck` "
"provides the `<?>` operator. Simply separate the property definition from "
"the error message using `<?>`, as follows:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:69
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  let\n"
"    result = merge (sort xs) (sort ys)\n"
"    expected = sort $ xs <> ys\n"
"  in\n"
"    eq result expected <?> \"Result:\\n\" <> show result <> \"\\nnot equal "
"to expected:\\n\" <> show expected\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:79
#, markdown-text
msgid ""
"This time, if we modify the code to introduce a bug, we see our improved "
"error message after the first failed test case:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter13.md:80
#, no-wrap
msgid ""
"Error: Test 1 (seed 534161891) failed:\n"
"Result:\n"
"[-822215,-196136,-116841,618343,887447,-888285]\n"
"not equal to expected:\n"
"[-888285,-822215,-196136,-116841,618343,887447]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:89
#, markdown-text
msgid ""
"Notice how the input `xs` and `ys` were generated as arrays of "
"randomly-selected integers."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:94
#, markdown-text
msgid ""
"(Easy) Write a property that asserts that merging an array with an empty one "
"does not modify the original array. _Note_: This new property is redundant "
"since this situation is already covered by our existing property. We're just "
"trying to give readers a simple way to practice using quickCheck."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:94
#, markdown-text
msgid ""
"(Easy) Add an appropriate error message to the remaining property for "
"`merge`."
msgstr ""

#. type: Title ##
#: ../text/chapter13.md:95
#, markdown-text, no-wrap
msgid "Testing Polymorphic Code"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:98
#, markdown-text
msgid ""
"The `Merge` module defines a generalization of the `merge` function, called "
"`mergePoly`, which works not only with arrays of numbers, but also arrays of "
"any type belonging to the `Ord` type class:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:99
#, no-wrap
msgid "mergePoly :: forall a. Ord a => Array a -> Array a -> Array a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:104
#, markdown-text
msgid ""
"If we modify our original test to use `mergePoly` in place of `merge`, we "
"see the following error message:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter13.md:105
#, no-wrap
msgid ""
"No type class instance was found for\n"
"\n"
"  Test.QuickCheck.Arbitrary.Arbitrary t0\n"
"\n"
"The instance head contains unknown type variables.\n"
"Consider adding a type annotation.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:115
#, markdown-text
msgid ""
"This error message indicates that the compiler could not generate random "
"test cases because it did not know what type of elements we wanted our "
"arrays to have. In these sorts of cases, we can use type annotations to "
"force the compiler to infer a particular type, such as `Array Int`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:116
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs <> ys)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:122
#, markdown-text
msgid ""
"We can alternatively use a helper function to specify the type, which may "
"result in cleaner code. For example, if we define a function `ints` as a "
"synonym for the identity function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:123
#, no-wrap
msgid ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:129
#, markdown-text
msgid ""
"then we can modify our test so that the compiler infers the type `Array Int` "
"for our two array arguments:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:130
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:136
#, markdown-text
msgid ""
"Here, `xs` and `ys` have type `Array Int` since the `ints` function has been "
"used to disambiguate the unknown type."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:141
#, markdown-text
msgid ""
"(Easy) Write a function `bools` that forces the types of `xs` and `ys` to be "
"`Array Boolean`, and add additional properties that test `mergePoly` at that "
"type."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:141
#, markdown-text
msgid ""
"(Medium) Choose a pure function from the core libraries (for example, from "
"the `arrays` package), and write a QuickCheck property for it, including an "
"appropriate error message. Your property should use a helper function to fix "
"any polymorphic type arguments to either `Int` or `Boolean`."
msgstr ""

#. type: Title ##
#: ../text/chapter13.md:142
#, markdown-text, no-wrap
msgid "Generating Arbitrary Data"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:145
#, markdown-text
msgid ""
"Now we will see how the `quickcheck` library can randomly generate test "
"cases for our properties."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:147
#, markdown-text
msgid ""
"Those types whose values can be randomly generated are captured by the "
"`Arbitrary` type class:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:148
#, no-wrap
msgid ""
"class Arbitrary t where\n"
"  arbitrary :: Gen t\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:154
#, markdown-text
msgid ""
"The `Gen` type constructor represents the side-effects of _deterministic "
"random data generation_. It uses a pseudo-random number generator to "
"generate deterministic random function arguments from a seed value. The "
"`Test.QuickCheck.Gen` module defines several useful combinators for building "
"generators."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:156
#, markdown-text
msgid ""
"`Gen` is also a monad and an applicative functor, so we have the usual "
"collection of combinators at our disposal for creating new instances of the "
"`Arbitrary` type class."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:158
#, markdown-text
msgid ""
"For example, we can use the `Arbitrary` instance for the `Int` type, "
"provided in the `quickcheck` library, to create a distribution on the "
"256-byte values, using the `Functor` instance for `Gen` to map a function "
"from integers to bytes over arbitrary integer values:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:159
#, no-wrap
msgid ""
"newtype Byte = Byte Int\n"
"\n"
"instance Arbitrary Byte where\n"
"  arbitrary = map intToByte arbitrary\n"
"    where\n"
"    intToByte n | n >= 0 = Byte (n `mod` 256)\n"
"                | otherwise = intToByte (-n)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:170
#, markdown-text
msgid ""
"Here, we define a type `Byte` of integral values between 0 and 255. The "
"`Arbitrary` instance uses the `map` function to lift the `intToByte` "
"function over the `arbitrary` action. The type of the inner `arbitrary` "
"action is inferred as `Gen Int`."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:172
#, markdown-text
msgid "We can also use this idea to improve our test for `merge`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:173
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:179
#, markdown-text
msgid ""
"In this test, we generated arbitrary arrays `xs` and `ys`, but had to sort "
"them, since `merge` expects sorted input. On the other hand, we could create "
"a newtype representing sorted arrays and write an `Arbitrary` instance that "
"generates sorted data:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:180
#, no-wrap
msgid ""
"newtype Sorted a = Sorted (Array a)\n"
"\n"
"sorted :: forall a. Sorted a -> Array a\n"
"sorted (Sorted xs) = xs\n"
"\n"
"instance (Arbitrary a, Ord a) => Arbitrary (Sorted a) where\n"
"  arbitrary = map (Sorted <<< sort) arbitrary\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:191
#, markdown-text
msgid "With this type constructor, we can modify our test as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:192
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs <> sorted "
"ys)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:198
#, markdown-text
msgid ""
"This may look like a small change, but the types of `xs` and `ys` have "
"changed to `Sorted Int` instead of just `Array Int`. This communicates our "
"_intent_ in a clearer way – the `mergePoly` function takes sorted "
"input. Ideally, the type of the `mergePoly` function itself would be updated "
"to use the `Sorted` type constructor."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:200
#, markdown-text
msgid ""
"As a more interesting example, the `Tree` module defines a type of sorted "
"binary trees with values at the branches:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:201
#, no-wrap
msgid ""
"data Tree a\n"
"  = Leaf\n"
"  | Branch (Tree a) a (Tree a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:208
#, markdown-text
msgid "The `Tree` module defines the following API:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:209
#, no-wrap
msgid ""
"insert    :: forall a. Ord a => a -> Tree a -> Tree a\n"
"member    :: forall a. Ord a => a -> Tree a -> Boolean\n"
"fromArray :: forall a. Ord a => Array a -> Tree a\n"
"toArray   :: forall a. Tree a -> Array a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:217
#, markdown-text
msgid ""
"The `insert` function inserts a new element into a sorted tree, and the "
"`member` function can query a tree for a particular value. For example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter13.md:218
#, no-wrap
msgid ""
"> import Tree\n"
"\n"
"> member 2 $ insert 1 $ insert 2 Leaf\n"
"true\n"
"\n"
"> member 1 Leaf\n"
"false\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:229
#, markdown-text
msgid ""
"The `toArray` and `fromArray` functions can convert sorted trees to and from "
"arrays. We can use `fromArray` to write an `Arbitrary` instance for trees:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:230
#, no-wrap
msgid ""
"instance (Arbitrary a, Ord a) => Arbitrary (Tree a) where\n"
"  arbitrary = map fromArray arbitrary\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:236
#, markdown-text
msgid ""
"We can now use `Tree a` as the type of an argument to our test properties "
"whenever there is an `Arbitrary` instance available for the type `a`. For "
"example, we can test that the `member` test always returns `true` after "
"inserting a value:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:237
#, no-wrap
msgid ""
"quickCheck \\t a ->\n"
"  member a $ insert a $ treeOfInt t\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:243
#, markdown-text
msgid ""
"Here, the argument `t` is a randomly-generated tree of type `Tree Int`, "
"where the type argument disambiguated by the identity function `treeOfInt`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:248
#, markdown-text
msgid ""
"(Medium) Create a newtype for `String` with an associated `Arbitrary` "
"instance which generates collections of randomly-selected characters in the "
"range `a-z`. _Hint_: use the `elements` and `arrayOf` functions from the "
"`Test.QuickCheck.Gen` module."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:248
#, markdown-text
msgid ""
"(Difficult) Write a property that asserts that a value inserted into a tree "
"is still a member of that tree after arbitrarily many more insertions."
msgstr ""

#. type: Title ##
#: ../text/chapter13.md:249
#, markdown-text, no-wrap
msgid "Testing Higher-Order Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:252
#, markdown-text
msgid ""
"The `Merge` module defines another generalization of the `merge` function – "
"the `mergeWith` function takes an additional function as an argument to "
"determine the order in which elements should be merged. That is, `mergeWith` "
"is a higher-order function."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:254
#, markdown-text
msgid ""
"For example, we can pass the `length` function as the first argument to "
"merge two arrays already in length-increasing order. The result should also "
"be in length-increasing order:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:255
#, no-wrap
msgid ""
"> import Data.String\n"
"\n"
"> mergeWith length\n"
"    [\"\", \"ab\", \"abcd\"]\n"
"    [\"x\", \"xyz\"]\n"
"\n"
"[\"\",\"x\",\"ab\",\"xyz\",\"abcd\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:266
#, markdown-text
msgid ""
"How might we test such a function? Ideally, we would like to generate values "
"for all three arguments, including the first argument, which is a function."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:268
#, markdown-text
msgid ""
"There is a second type class that allows us to create randomly-generated "
"functions. It is called `Coarbitrary`, and it is defined as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:269
#, no-wrap
msgid ""
"class Coarbitrary t where\n"
"  coarbitrary :: forall r. t -> Gen r -> Gen r\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:275
#, markdown-text
msgid ""
"The `coarbitrary` function takes a function argument of type `t` and a "
"random generator for a function result of type `r`. It uses the function "
"argument to _perturb_ the random generator. That is, it uses the function "
"argument to modify the random output of the random generator for the result."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:277
#, markdown-text
msgid ""
"In addition, there is a type class instance that gives us `Arbitrary` "
"functions if the function domain is `Coarbitrary` and the function codomain "
"is `Arbitrary`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:278
#, no-wrap
msgid "instance (Coarbitrary a, Arbitrary b) => Arbitrary (a -> b)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:283
#, markdown-text
msgid ""
"In practice, we can write properties that take functions as arguments. In "
"the case of the `mergeWith` function, we can generate the first argument "
"randomly, modifying our tests to take account of the new argument."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:285
#, markdown-text
msgid ""
"We cannot guarantee that the result will be sorted – we do not even "
"necessarily have an `Ord` instance – but we can expect that the result be "
"sorted with respect to the function `f` that we pass in as an argument. In "
"addition, we need the two input arrays to be sorted concerning `f`, so we "
"use the `sortBy` function to sort `xs` and `ys` based on comparison after "
"the function `f` has been applied:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:286
#, no-wrap
msgid ""
"quickCheck \\xs ys f ->\n"
"  let\n"
"    result =\n"
"      map f $\n"
"        mergeWith (intToBool f)\n"
"                  (sortBy (compare `on` f) xs)\n"
"                  (sortBy (compare `on` f) ys)\n"
"    expected =\n"
"      map f $\n"
"        sortBy (compare `on` f) $ xs <> ys\n"
"  in\n"
"    eq result expected\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:302
#, markdown-text
msgid ""
"Here, we use a function `intToBool` to disambiguate the type of the function "
"`f`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:303
#, no-wrap
msgid ""
"intToBool :: (Int -> Boolean) -> Int -> Boolean\n"
"intToBool = id\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:309
#, markdown-text
msgid "In addition to being `Arbitrary`, functions are also `Coarbitrary`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:310
#, no-wrap
msgid "instance (Arbitrary a, Coarbitrary b) => Coarbitrary (a -> b)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:315
#, markdown-text
msgid ""
"This means that we are not limited to just values and functions – we can "
"also randomly generate _higher-order functions_, or functions whose "
"arguments are higher-order functions, and so on."
msgstr ""

#. type: Title ##
#: ../text/chapter13.md:316
#, markdown-text, no-wrap
msgid "Writing Coarbitrary Instances"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:319
#, markdown-text
msgid ""
"Just as we can write `Arbitrary` instances for our data types by using the "
"`Monad` and `Applicative` instances of `Gen`, we can write our own "
"`Coarbitrary` instances as well. This allows us to use our own data types as "
"the domain of randomly-generated functions."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:321
#, markdown-text
msgid ""
"Let's write a `Coarbitrary` instance for our `Tree` type. We will need a "
"`Coarbitrary` instance for the type of the elements stored in the branches:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:322
#, no-wrap
msgid "instance Coarbitrary a => Coarbitrary (Tree a) where\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:327
#, markdown-text
msgid ""
"We have to write a function that perturbs a random generator given a value "
"of type `Tree a`. If the input value is a `Leaf`, then we will return the "
"generator unchanged:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:328
#, no-wrap
msgid "  coarbitrary Leaf = id\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:333
#, markdown-text
msgid ""
"If the tree is a `Branch`, then we will perturb the generator using the left "
"subtree, the value, and the right subtree. We use function composition to "
"create our perturbing function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:334
#, no-wrap
msgid ""
"  coarbitrary (Branch l a r) =\n"
"    coarbitrary l <<<\n"
"    coarbitrary a <<<\n"
"    coarbitrary r\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:342
#, markdown-text
msgid ""
"Now we can write properties whose arguments include functions taking trees "
"as arguments. For example, the `Tree` module defines a function `anywhere`, "
"which tests if a predicate holds on any subtree of its argument:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:343
#, no-wrap
msgid "anywhere :: forall a. (Tree a -> Boolean) -> Tree a -> Boolean\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:348
#, markdown-text
msgid ""
"Now we can generate the predicate function randomly. For example, we expect "
"the `anywhere` function to _respect disjunction_:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:349
#, no-wrap
msgid ""
"quickCheck \\f g t ->\n"
"  anywhere (\\s -> f s || g s) t ==\n"
"    anywhere f (treeOfInt t) || anywhere g t\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:356
#, markdown-text
msgid ""
"Here, the `treeOfInt` function is used to fix the type of values contained "
"in the tree to the type `Int`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter13.md:357
#, no-wrap
msgid ""
"treeOfInt :: Tree Int -> Tree Int\n"
"treeOfInt = id\n"
msgstr ""

#. type: Title ##
#: ../text/chapter13.md:362
#, markdown-text, no-wrap
msgid "Testing Without Side-Effects"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:365
#, markdown-text
msgid ""
"For the purposes of testing, we usually include calls to the `quickCheck` "
"function in the `main` action of our test suite. However, there is a variant "
"of the `quickCheck` function, called `quickCheckPure` which does not use "
"side-effects. Instead, it is a pure function that takes a random seed as an "
"input and returns an array of test results."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:367
#, markdown-text
msgid ""
"We can test `quickCheckPure` using PSCi. Here, we test that the `merge` "
"operation is associative:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter13.md:368
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Merge\n"
"> import Test.QuickCheck\n"
"> import Test.QuickCheck.LCG (mkSeed)\n"
"\n"
"> :paste\n"
"… quickCheckPure (mkSeed 12345) 10 \\xs ys zs ->\n"
"…   ((xs `merge` ys) `merge` zs) ==\n"
"…     (xs `merge` (ys `merge` zs))\n"
"… ^D\n"
"\n"
"Success : Success : ...\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:384
#, markdown-text
msgid ""
"`quickCheckPure` takes three arguments: the random seed, the number of test "
"cases to generate, and the property to test. If all tests pass, you should "
"see an array of `Success` data constructors printed to the console."
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:386
#, markdown-text
msgid ""
"`quickCheckPure` might be useful in other situations, such as generating "
"random input data for performance benchmarks or sample form data for web "
"applications."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:392
#, markdown-text
msgid ""
"(Easy) Write `Coarbitrary` instances for the `Byte` and `Sorted` type "
"constructors."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:392
#, markdown-text
msgid ""
"(Medium) Write a (higher-order) property which asserts associativity of the "
"`mergeWith f` function for any function `f`. Test your property in PSCi "
"using `quickCheckPure`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter13.md:392
#, markdown-text
msgid ""
"(Medium) Write `Arbitrary` and `Coarbitrary` instances for the following "
"data type:"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:396
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     data OneTwoThree a = One a | Two a a | Three a a a\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:400
#, markdown-text, no-wrap
msgid ""
"     _Hint_: Use the `oneOf` function defined in `Test.QuickCheck.Gen` to "
"define your `Arbitrary` instance.\n"
" 1. (Medium) Use `all` to simplify the result of the `quickCheckPure` "
"function – your new function should have the type `List Result -> Boolean` "
"and should return `true` if every test passes and `false` otherwise.\n"
" 1. (Medium) As another approach to simplifying the result of "
"`quickCheckPure`, try writing a function `squashResults :: List Result -> "
"Result`. Consider using the `First` monoid from `Data.Maybe.First` with the "
"`foldMap` function to preserve the first error in case of failure.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter13.md:404
#, markdown-text
msgid ""
"In this chapter, we met the `quickcheck` package, which can be used to write "
"tests in a declarative way using the paradigm of _generative testing_. In "
"particular:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter13.md:408
#, markdown-text
msgid "We saw how to automate QuickCheck tests using `spago test`."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter13.md:408
#, markdown-text
msgid ""
"We saw how to write properties as functions and how to use the `<?>` "
"operator to improve error messages."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter13.md:408
#, markdown-text
msgid ""
"We saw how the `Arbitrary` and `Coarbitrary` type classes enable generation "
"of boilerplate testing code and how they allow us to test higher-order "
"properties."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter13.md:408
#, markdown-text
msgid ""
"We saw how to implement custom `Arbitrary` and `Coarbitrary` instances for "
"our own data types."
msgstr ""

#. type: Title #
#: ../text/chapter14.md:1
#, markdown-text, no-wrap
msgid "Domain-Specific Languages"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:6
#, markdown-text
msgid ""
"In this chapter, we will explore the implementation of _domain-specific "
"languages_ (or _DSLs_) in PureScript, using a number of standard techniques."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:8
#, markdown-text
msgid ""
"A domain-specific language is a language that is well-suited to development "
"in a particular problem domain. Its syntax and functions are chosen to "
"maximize the readability of code used to express ideas in that domain. We "
"have already seen several examples of domain-specific languages in this "
"book:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:11
#, markdown-text
msgid ""
"The `Game` monad and its associated actions, developed in chapter 11, "
"constitute a domain-specific language for the domain of _text adventure game "
"development_."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:11
#, markdown-text
msgid ""
"The `quickcheck` package, covered in Chapter 13, is a domain-specific "
"language for the domain of _generative testing_. Its combinators enable a "
"particularly expressive notation for test properties."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:13
#, markdown-text
msgid ""
"This chapter will take a more structured approach to some standard "
"techniques in implementing domain-specific languages. It is by no means a "
"complete exposition of the subject, but should provide you with enough "
"knowledge to build some practical DSLs for your own tasks."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:15
#, markdown-text
msgid ""
"Our running example will be a domain-specific language for creating HTML "
"documents. We will aim to develop a type-safe language for describing "
"correct HTML documents, and we will work by improving a naive implementation "
"in small steps."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:19
#, markdown-text
msgid ""
"The project accompanying this chapter adds one new dependency – the `free` "
"library, which defines the _free monad_, one of the tools we will use."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:21
#, markdown-text
msgid "We will test this chapter's project in PSCi."
msgstr ""

#. type: Title ##
#: ../text/chapter14.md:22
#, markdown-text, no-wrap
msgid "An HTML Data Type"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:25
#, markdown-text
msgid ""
"The most basic version of our HTML library is defined in the "
"`Data.DOM.Simple` module. The module contains the following type "
"definitions:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:26
#, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Array Content)\n"
"  }\n"
"\n"
"data Content\n"
"  = TextContent String\n"
"  | ElementContent Element\n"
"\n"
"newtype Attribute = Attribute\n"
"  { key          :: String\n"
"  , value        :: String\n"
"  }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:44
#, markdown-text
msgid ""
"The `Element` type represents HTML elements. Each element consists of an "
"element name, an array of attribute pairs, and some content. The content "
"property uses the `Maybe` type to indicate that an element might be open "
"(containing other elements and text) or closed."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:46
#, markdown-text
msgid "The key function of our library is a function"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:47
#, no-wrap
msgid "render :: Element -> String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:52
#, markdown-text
msgid ""
"which renders HTML elements as HTML strings. We can try out this version of "
"the library by constructing values of the appropriate types explicitly in "
"PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter14.md:53
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Simple\n"
"> import Data.Maybe\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ Element\n"
"…   { name: \"p\"\n"
"…   , attribs: [\n"
"…       Attribute\n"
"…         { key: \"class\"\n"
"…         , value: \"main\"\n"
"…         }\n"
"…     ]\n"
"…   , content: Just [\n"
"…       TextContent \"Hello World!\"\n"
"…     ]\n"
"…   }\n"
"… ^D\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:81
#, markdown-text
msgid "As it stands, there are several problems with this library:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:87
#, markdown-text
msgid ""
"Creating HTML documents is difficult – every new element requires at least "
"one record and one data constructor."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:87
#, markdown-text
msgid "It is possible to represent invalid documents:"
msgstr ""

#. type: Bullet: '  - '
#: ../text/chapter14.md:87
#, markdown-text
msgid "The developer might mistype the element name"
msgstr ""

#. type: Bullet: '  - '
#: ../text/chapter14.md:87
#, markdown-text
msgid "The developer can associate an attribute with the wrong type of element"
msgstr ""

#. type: Bullet: '  - '
#: ../text/chapter14.md:87
#, markdown-text
msgid "The developer can use a closed element when an open element is correct"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:89
#, markdown-text
msgid ""
"In the remainder of the chapter, we will apply certain techniques to solve "
"these problems and turn our library into a usable domain-specific language "
"for creating HTML documents."
msgstr ""

#. type: Title ##
#: ../text/chapter14.md:90
#, markdown-text, no-wrap
msgid "Smart Constructors"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:93
#, markdown-text
msgid ""
"The first technique we will apply is simple but can be very "
"effective. Instead of exposing the representation of the data to the "
"module's users, we can use the module exports list to hide the `Element`, "
"`Content`, and `Attribute` data constructors, and only export so-called "
"_smart constructors_, which construct data known to be correct."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:95
#, markdown-text
msgid ""
"Here is an example. First, we provide a convenience function for creating "
"HTML elements:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:96
#, no-wrap
msgid ""
"element :: String -> Array Attribute -> Maybe (Array Content) -> Element\n"
"element name attribs content = Element\n"
"  { name:      name\n"
"  , attribs:   attribs\n"
"  , content:   content\n"
"  }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:106
#, markdown-text
msgid ""
"Next, we create smart constructors for those HTML elements we want our users "
"to be able to create by applying the `element` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:107
#, no-wrap
msgid ""
"a :: Array Attribute -> Array Content -> Element\n"
"a attribs content = element \"a\" attribs (Just content)\n"
"\n"
"p :: Array Attribute -> Array Content -> Element\n"
"p attribs content = element \"p\" attribs (Just content)\n"
"\n"
"img :: Array Attribute -> Element\n"
"img attribs = element \"img\" attribs Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:119
#, markdown-text
msgid ""
"Finally, we update the module exports list to only export those functions "
"which are known to construct correct data structures:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:120
#, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute(..)\n"
"  , Content(..)\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:135
#, markdown-text
msgid ""
"The module exports list is provided immediately after the module name inside "
"parentheses. Each module export can be one of three types:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:139
#, markdown-text
msgid "A value (or function), indicated by the name of the value,"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:139
#, markdown-text
msgid "A type class, indicated by the name of the class,"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:139
#, markdown-text
msgid ""
"A type constructor and any associated data constructors indicated by the "
"name of the type followed by a parenthesized list of exported data "
"constructors."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:141
#, markdown-text
msgid ""
"Here, we export the `Element` _type_, but we do not export its data "
"constructors. If we did, the user could construct invalid HTML elements."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:143
#, markdown-text
msgid ""
"In the case of the `Attribute` and `Content` types, we still export all of "
"the data constructors (indicated by the symbol `..` in the exports list). We "
"will apply the technique of smart constructors to these types shortly."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:145
#, markdown-text
msgid "Notice that we have already made some big improvements to our library:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:148
#, markdown-text
msgid ""
"It is impossible to represent HTML elements with invalid names (of course, "
"we are restricted to the set of element names provided by the library)."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:148
#, markdown-text
msgid "Closed elements cannot contain content by construction."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:150
#, markdown-text
msgid ""
"We can apply this technique to the `Content` type very easily. We simply "
"remove the data constructors for the `Content` type from the exports list "
"and provide the following smart constructors:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:151
#, no-wrap
msgid ""
"text :: String -> Content\n"
"text = TextContent\n"
"\n"
"elem :: Element -> Content\n"
"elem = ElementContent\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:160
#, markdown-text
msgid ""
"Let's apply the same technique to the `Attribute` type. First, we provide a "
"general-purpose smart constructor for attributes. Here is a first attempt:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:161
#, no-wrap
msgid ""
"attribute :: String -> String -> Attribute\n"
"attribute key value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
"\n"
"infix 4 attribute as :=\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:172
#, markdown-text
msgid ""
"This representation suffers from the same problem as the original `Element` "
"type – it is possible to represent attributes that do not exist or whose "
"names were entered incorrectly. To solve this problem, we can create a "
"newtype that represents attribute names:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:173
#, no-wrap
msgid "newtype AttributeKey = AttributeKey String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:178
#, markdown-text
msgid "With that, we can modify our operator as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:179
#, no-wrap
msgid ""
"attribute :: AttributeKey -> String -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:188
#, markdown-text
msgid ""
"If we do not export the `AttributeKey` data constructor, then the user has "
"no way to construct values of type `AttributeKey` other than by using "
"functions we explicitly export. Here are some examples:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:189
#, no-wrap
msgid ""
"href :: AttributeKey\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey\n"
"height = AttributeKey \"height\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:207
#, markdown-text
msgid ""
"Here is the final exports list for our new module. Note that we no longer "
"export any data constructors directly:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:208
#, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute\n"
"  , Content\n"
"  , AttributeKey\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , href\n"
"  , _class\n"
"  , src\n"
"  , width\n"
"  , height\n"
"\n"
"  , attribute, (:=)\n"
"  , text\n"
"  , elem\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:234
#, markdown-text
msgid ""
"If we try this new module in PSCi, we can already see massive improvements "
"in the conciseness of the user code:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter14.md:235
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Smart\n"
"> import Effect.Console\n"
"> log $ render $ p [ _class := \"main\" ] [ text \"Hello World!\" ]\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:248
#, markdown-text
msgid ""
"Note, however, that no changes had to be made to the `render` function, "
"because the underlying data representation never changed. This is one of the "
"benefits of the smart constructors approach – it allows us to separate the "
"internal data representation for a module from the representation perceived "
"by users of its external API."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:253
#, markdown-text
msgid ""
"(Easy) Use the `Data.DOM.Smart` module to experiment by creating new HTML "
"documents using `render`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:253
#, markdown-text
msgid ""
"(Medium) Some HTML attributes, such as `checked` and `disabled`, do not "
"require values and may be rendered as _empty attributes_:"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:257
#, markdown-text, no-wrap
msgid ""
"     ```html\n"
"     <input disabled>\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:259
#, markdown-text, no-wrap
msgid ""
"     Modify the representation of an `Attribute` to take empty attributes "
"into account. Write a function which can be used in place of `attribute` or "
"`:=` to add an empty attribute to an element.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter14.md:260
#, markdown-text, no-wrap
msgid "Phantom Types"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:263
#, markdown-text
msgid "To motivate the next technique, consider the following code:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter14.md:264
#, no-wrap
msgid ""
"> log $ render $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := \"foo\"\n"
"    , height := \"bar\"\n"
"    ]\n"
"\n"
"<img src=\"cat.jpg\" width=\"foo\" height=\"bar\" />\n"
"unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:276
#, markdown-text
msgid ""
"The problem here is that we have provided string values for the `width` and "
"`height` attributes, where we should only be allowed to provide numeric "
"values in units of pixels or percentage points."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:278
#, markdown-text
msgid ""
"To solve this problem, we can introduce a so-called _phantom type_ argument "
"to our `AttributeKey` type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:279
#, no-wrap
msgid "newtype AttributeKey a = AttributeKey String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:284
#, markdown-text
msgid ""
"The type variable `a` is called a _phantom type_ because there are no values "
"of type `a` involved in the right-hand side of the definition. The type `a` "
"only exists to provide more information at compile-time. Any value of type "
"`AttributeKey a` is simply a string at runtime, but at compile-time, the "
"type of the value tells us the desired type of the values associated with "
"this key."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:286
#, markdown-text
msgid ""
"We can modify the type of our `attribute` function to take the new form of "
"`AttributeKey` into account:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:287
#, no-wrap
msgid ""
"attribute :: forall a. IsValue a => AttributeKey a -> a -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: toValue value\n"
"  }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:296
#, markdown-text
msgid ""
"Here, the phantom type argument `a` is used to ensure that the attribute key "
"and attribute value have compatible types. Since the user cannot create "
"values of type `AttributeKey a` directly (only via the constants we provide "
"in the library), every attribute will be correct by construction."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:298
#, markdown-text
msgid ""
"Note that the `IsValue` constraint ensures that whatever value type we "
"associate to a key, its values can be converted to strings and displayed in "
"the generated HTML. The `IsValue` type class is defined as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:299
#, no-wrap
msgid ""
"class IsValue a where\n"
"  toValue :: a -> String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:305
#, markdown-text
msgid "We also provide type class instances for the `String` and `Int` types:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:306
#, no-wrap
msgid ""
"instance IsValue String where\n"
"  toValue = id\n"
"\n"
"instance IsValue Int where\n"
"  toValue = show\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:315
#, markdown-text
msgid ""
"We also have to update our `AttributeKey` constants so that their types "
"reflect the new type parameter:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:316
#, no-wrap
msgid ""
"href :: AttributeKey String\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey String\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey String\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey Int\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey Int\n"
"height = AttributeKey \"height\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:334
#, markdown-text
msgid ""
"Now we find it is impossible to represent these invalid HTML documents, and "
"we are forced to use numbers to represent the `width` and `height` "
"attributes instead:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter14.md:335
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Phantom\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ img\n"
"…   [ src    := \"cat.jpg\"\n"
"…   , width  := 100\n"
"…   , height := 200\n"
"…   ]\n"
"… ^D\n"
"\n"
"<img src=\"cat.jpg\" width=\"100\" height=\"200\" />\n"
"unit\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:356
#, markdown-text
msgid ""
"(Easy) Create a data type representing either pixel or percentage "
"lengths. Write an instance of `IsValue` for your type. Modify the `width` "
"and `height` attributes to use your new type."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:356
#, markdown-text
msgid ""
"(Difficult) By defining type-level representatives for the Boolean values "
"`true` and `false`, we can use a phantom type to encode whether an "
"`AttributeKey` represents an _empty attribute_, such as `disabled` or "
"`checked`."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:361
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     data True\n"
"     data False\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:363
#, markdown-text, no-wrap
msgid ""
"     Modify your solution to the previous exercise to use a phantom type to "
"prevent the user from using the `attribute` operator with an empty "
"attribute.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter14.md:364
#, markdown-text, no-wrap
msgid "The Free Monad"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:367
#, markdown-text
msgid ""
"In our final set of modifications to our API, we will use a construction "
"called the _free monad_ to turn our `Content` type into a monad, enabling do "
"notation. This will allow us to structure our HTML documents in a form in "
"which the nesting of elements becomes clearer – instead of this:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:368
#, no-wrap
msgid ""
"p [ _class := \"main\" ]\n"
"  [ elem $ img\n"
"      [ src    := \"cat.jpg\"\n"
"      , width  := 100\n"
"      , height := 200\n"
"      ]\n"
"  , text \"A cat\"\n"
"  ]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:380
#, markdown-text
msgid "we will be able to write this:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:381
#, no-wrap
msgid ""
"p [ _class := \"main\" ] $ do\n"
"  elem $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := 100\n"
"    , height := 200\n"
"    ]\n"
"  text \"A cat\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:392
#, markdown-text
msgid ""
"However, do notation is not the only benefit of a free monad. The free monad "
"allows us to separate the _representation_ of our monadic actions from their "
"_interpretation_ and even support _multiple interpretations_ of the same "
"actions."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:394
#, markdown-text
msgid ""
"The `Free` monad is defined in the `free` library in the "
"`Control.Monad.Free` module. We can find out some basic information about it "
"using PSCi, as follows:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter14.md:395
#, no-wrap
msgid ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:403
#, markdown-text
msgid ""
"The kind of `Free` indicates that it takes a type constructor as an argument "
"and returns another type constructor. In fact, the `Free` monad can be used "
"to turn any `Functor` into a `Monad`!"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:405
#, markdown-text
msgid ""
"We begin by defining the _representation_ of our monadic actions. To do "
"this, we need to create a `Functor` with one data constructor for each "
"monadic action we wish to support. In our case, our two monadic actions will "
"be `elem` and `text`. We can simply modify our `Content` type as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:406
#, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"\n"
"instance Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:417
#, markdown-text
msgid ""
"Here, the `ContentF` type constructor looks just like our old `Content` data "
"type – however, it now takes a type argument `a`, and each data constructor "
"has been modified to take a value of type `a` as an additional argument. The "
"`Functor` instance simply applies the function `f` to the value of type `a` "
"in each data constructor."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:419
#, markdown-text
msgid ""
"With that, we can define our new `Content` monad as a type synonym for the "
"`Free` monad, which we construct by using our `ContentF` type constructor as "
"the first type argument:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:420
#, no-wrap
msgid "type Content = Free ContentF\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:425
#, markdown-text
msgid ""
"Instead of a type synonym, we might use a `newtype` to avoid exposing the "
"internal representation of our library to our users – by hiding the "
"`Content` data constructor, we restrict our users to only using the monadic "
"actions we provide."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:427
#, markdown-text
msgid ""
"Because `ContentF` is a `Functor`, we automatically get a `Monad` instance "
"for `Free ContentF`."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:429
#, markdown-text
msgid ""
"We have to modify our `Element` data type slightly to take account of the "
"new type argument on `Content`. We will simply require that the return type "
"of our monadic computations be `Unit`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:430
#, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Content Unit)\n"
"  }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:439
#, markdown-text
msgid ""
"In addition, we have to modify our `elem` and `text` functions, which become "
"our new monadic actions for the `Content` monad. To do this, we can use the "
"`liftF` function provided by the `Control.Monad.Free` module. Here is its "
"type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:440
#, no-wrap
msgid "liftF :: forall f a. f a -> Free f a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:445
#, markdown-text
msgid ""
"`liftF` allows us to construct an action in our free monad from a value of "
"type `f a` for some type `a`. In our case, we can use the data constructors "
"of our `ContentF` type constructor directly:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:446
#, no-wrap
msgid ""
"text :: String -> Content Unit\n"
"text s = liftF $ TextContent s unit\n"
"\n"
"elem :: Element -> Content Unit\n"
"elem e = liftF $ ElementContent e unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:455
#, markdown-text
msgid ""
"Some other routine modifications have to be made, but the interesting "
"changes are in the `render` function, where we have to _interpret_ our free "
"monad."
msgstr ""

#. type: Title ##
#: ../text/chapter14.md:456
#, markdown-text, no-wrap
msgid "Interpreting the Monad"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:459
#, markdown-text
msgid ""
"The `Control.Monad.Free` module provides a number of functions for "
"interpreting a computation in a free monad:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:460
#, no-wrap
msgid ""
"runFree\n"
"  :: forall f a\n"
"   . Functor f\n"
"  => (f (Free f a) -> Free f a)\n"
"  -> Free f a\n"
"  -> a\n"
"\n"
"runFreeM\n"
"  :: forall f m a\n"
"   . (Functor f, MonadRec m)\n"
"  => (f (Free f a) -> m (Free f a))\n"
"  -> Free f a\n"
"  -> m a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:477
#, markdown-text
msgid ""
"The `runFree` function is used to compute a _pure_ result. The `runFreeM` "
"function allows us to use a monad to interpret the actions of our free "
"monad."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:479
#, markdown-text
msgid ""
"_Note_: Technically, we are restricted to monads `m` that satisfy the "
"stronger `MonadRec` constraint. In practice, we don't need to worry about "
"stack overflow since `m` supports safe _monadic tail recursion_."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:481
#, markdown-text
msgid ""
"First, we have to choose a monad in which we can interpret our actions. We "
"will use the `Writer String` monad to accumulate an HTML string as our "
"result."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:483
#, markdown-text
msgid ""
"Our new `render` method starts by delegating to a helper function, "
"`renderElement`, and using `execWriter` to run our computation in the "
"`Writer` monad:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:484
#, no-wrap
msgid ""
"render :: Element -> String\n"
"render = execWriter <<< renderElement\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:490
#, markdown-text
msgid "`renderElement` is defined in a where block:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:491
#, no-wrap
msgid ""
"  where\n"
"    renderElement :: Element -> Writer String Unit\n"
"    renderElement (Element e) = do\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:498
#, markdown-text
msgid ""
"The definition of `renderElement` is straightforward, using the `tell` "
"action from the `Writer` monad to accumulate several small strings:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:499
#, no-wrap
msgid ""
"      tell \"<\"\n"
"      tell e.name\n"
"      for_ e.attribs $ \\x -> do\n"
"        tell \" \"\n"
"        renderAttribute x\n"
"      renderContent e.content\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:509
#, markdown-text
msgid "Next, we define the `renderAttribute` function, which is equally simple:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:510
#, no-wrap
msgid ""
"    where\n"
"      renderAttribute :: Attribute -> Writer String Unit\n"
"      renderAttribute (Attribute x) = do\n"
"        tell x.key\n"
"        tell \"=\\\"\"\n"
"        tell x.value\n"
"        tell \"\\\"\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:521
#, markdown-text
msgid ""
"The `renderContent` function is more interesting. Here, we use the "
"`runFreeM` function to interpret the computation inside the free monad, "
"delegating to a helper function, `renderContentItem`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:522
#, no-wrap
msgid ""
"      renderContent :: Maybe (Content Unit) -> Writer String Unit\n"
"      renderContent Nothing = tell \" />\"\n"
"      renderContent (Just content) = do\n"
"        tell \">\"\n"
"        runFreeM renderContentItem content\n"
"        tell \"</\"\n"
"        tell e.name\n"
"        tell \">\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:534
#, markdown-text
msgid ""
"The type of `renderContentItem` can be deduced from the type signature of "
"`runFreeM`. The functor `f` is our type constructor `ContentF`, and the "
"monad `m` is the monad in which we are interpreting the computation, namely "
"`Writer String`. This gives the following type signature for "
"`renderContentItem`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:535
#, no-wrap
msgid ""
"      renderContentItem :: ContentF (Content Unit) -> Writer String (Content "
"Unit)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:540
#, markdown-text
msgid ""
"We can implement this function by pattern matching on the two data "
"constructors of `ContentF`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:541
#, no-wrap
msgid ""
"      renderContentItem (TextContent s rest) = do\n"
"        tell s\n"
"        pure rest\n"
"      renderContentItem (ElementContent e rest) = do\n"
"        renderElement e\n"
"        pure rest\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:551
#, markdown-text
msgid ""
"In each case, the expression `rest` has the type `Content Unit` and "
"represents the remainder of the interpreted computation. We can complete "
"each case by returning the `rest` action."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:553
#, markdown-text
msgid "That's it! We can test our new monadic API in PSCi, as follows:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter14.md:554
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Free\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ p [] $ do\n"
"…   elem $ img [ src := \"cat.jpg\" ]\n"
"…   text \"A cat\"\n"
"… ^D\n"
"\n"
"<p><img src=\"cat.jpg\" />A cat</p>\n"
"unit\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:572
#, markdown-text
msgid ""
"(Medium) Add a new data constructor to the `ContentF` type to support a new "
"action `comment`, which renders a comment in the generated HTML. Implement "
"the new action using `liftF`. Update the interpretation `renderContentItem` "
"to interpret your new constructor appropriately."
msgstr ""

#. type: Title ##
#: ../text/chapter14.md:573
#, markdown-text, no-wrap
msgid "Extending the Language"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:576
#, markdown-text
msgid ""
"A monad in which every action returns something of type `Unit` is not "
"particularly interesting. In fact, aside from an arguably nicer syntax, our "
"monad adds no extra functionality over a `Monoid`."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:578
#, markdown-text
msgid ""
"Let's illustrate the power of the free monad construction by extending our "
"language with a new monadic action that returns a non-trivial result."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:580
#, markdown-text
msgid ""
"Suppose we want to generate HTML documents that contain hyperlinks to "
"different sections of the document using _anchors_. We can accomplish this "
"by generating anchor names by hand and including them at least twice in the "
"document: once at the anchor's definition and once in each "
"hyperlink. However, this approach has some basic issues:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:583
#, markdown-text
msgid "The developer might fail to generate unique anchor names."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:583
#, markdown-text
msgid "The developer might mistype one or more instances of the anchor name."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:585
#, markdown-text
msgid ""
"To protect the developer from their mistakes, we can introduce a new type "
"that represents anchor names and provide a monadic action for generating new "
"unique names."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:587
#, markdown-text
msgid "The first step is to add a new type for names:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:588
#, no-wrap
msgid ""
"newtype Name = Name String\n"
"\n"
"runName :: Name -> String\n"
"runName (Name n) = n\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:596
#, markdown-text
msgid ""
"Again, we define this as a newtype around `String`, but we must be careful "
"not to export the data constructor in the module's export lists."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:598
#, markdown-text
msgid ""
"Next, we define an instance for the `IsValue` type class for our new type so "
"that we can use names in attribute values:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:599
#, no-wrap
msgid ""
"instance IsValue Name where\n"
"  toValue (Name n) = n\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:605
#, markdown-text
msgid ""
"We also define a new data type for hyperlinks which can appear in `a` "
"elements, as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:606
#, no-wrap
msgid ""
"data Href\n"
"  = URLHref String\n"
"  | AnchorHref Name\n"
"\n"
"instance IsValue Href where\n"
"  toValue (URLHref url) = url\n"
"  toValue (AnchorHref (Name nm)) = \"#\" <> nm\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:617
#, markdown-text
msgid ""
"With this new type, we can modify the value type of the `href` attribute, "
"forcing our users to use our new `Href` type. We can also create a new "
"`name` attribute, which can be used to turn an element into an anchor:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:618
#, no-wrap
msgid ""
"href :: AttributeKey Href\n"
"href = AttributeKey \"href\"\n"
"\n"
"name :: AttributeKey Name\n"
"name = AttributeKey \"name\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:627
#, markdown-text
msgid ""
"The remaining problem is that our users currently have no way to generate "
"new names. We can provide this functionality in our `Content` monad. First, "
"we need to add a new data constructor to our `ContentF` type constructor:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:628
#, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"  | NewName (Name -> a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:636
#, markdown-text, no-wrap
msgid ""
"The `NewName` data constructor corresponds to an action which returns a "
"value of type `Name`. Notice that instead of requiring a `Name` as a data "
"constructor argument, we require the user to provide a _function_ of type "
"`Name -> a`. Remembering that the type `a` represents the _rest of the "
"computation_, we can see that this function provides a way to continue "
"computation after a value of type `Name` has been returned.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:638
#, markdown-text
msgid ""
"We also need to update the `Functor` instance for `ContentF`, taking into "
"account the new data constructor, as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:639
#, no-wrap
msgid ""
"instance Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
"  map f (NewName k) = NewName (f <<< k)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:647
#, markdown-text
msgid "Now we can build our new action by using the `liftF` function, as before:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:648
#, no-wrap
msgid ""
"newName :: Content Name\n"
"newName = liftF $ NewName id\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:654
#, markdown-text
msgid ""
"Notice that we provide the `id` function as our continuation, meaning we "
"return the result of type `Name` unchanged."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:656
#, markdown-text
msgid ""
"Finally, we need to update our interpretation function to interpret the new "
"action. We previously used the `Writer String` monad to interpret our "
"computations, but that monad cannot generate new names, so we must switch to "
"something else. The `WriterT` monad transformer can be used with the `State` "
"monad to combine the effects we need. We can define our interpretation monad "
"as a type synonym to keep our type signatures short:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:657
#, no-wrap
msgid "type Interp = WriterT String (State Int)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:662
#, markdown-text
msgid ""
"Here, the state of type `Int` will act as an incrementing counter, used to "
"generate unique names."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:664
#, markdown-text
msgid ""
"Because the `Writer` and `WriterT` monads use the same type class members to "
"abstract their actions, we do not need to change any actions – we only need "
"to replace every reference to `Writer String` with `Interp`. However, we "
"need to modify the handler used to run our computation. Instead of just "
"`execWriter`, we now need to use `evalState` as well:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:665
#, no-wrap
msgid ""
"render :: Element -> String\n"
"render e = evalState (execWriterT (renderElement e)) 0\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:671
#, markdown-text
msgid ""
"We also need to add a new case to `renderContentItem`, to interpret the new "
"`NewName` data constructor:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter14.md:672
#, no-wrap
msgid ""
"renderContentItem (NewName k) = do\n"
"  n <- get\n"
"  let fresh = Name $ \"name\" <> show n\n"
"  put $ n + 1\n"
"  pure (k fresh)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:681
#, markdown-text, no-wrap
msgid ""
"Here, we are given a continuation `k` of type `Name -> Content a`, and we "
"need to construct an interpretation of type `Content a`. Our interpretation "
"is simple: we use `get` to read the state, use that state to generate a "
"unique name, then use `put` to increment the state. Finally, we pass our new "
"name to the continuation to complete the computation.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:683
#, markdown-text
msgid ""
"With that, we can try out our new functionality in PSCi, by generating a "
"unique name inside the `Content` monad and using it as both the name of an "
"element and the target of a hyperlink:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter14.md:684
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Name\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… render $ p [ ] $ do\n"
"…   top <- newName\n"
"…   elem $ a [ name := top ] $\n"
"…     text \"Top\"\n"
"…   elem $ a [ href := AnchorHref top ] $\n"
"…     text \"Back to top\"\n"
"… ^D\n"
"\n"
"<p><a name=\"name0\">Top</a><a href=\"#name0\">Back to top</a></p>\n"
"unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:703
#, markdown-text
msgid ""
"You can verify that multiple calls to `newName` do, in fact, result in "
"unique names."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:711
#, markdown-text
msgid ""
"(Medium) We can simplify the API further by hiding the `Element` type from "
"its users. Make these changes in the following steps:"
msgstr ""

#. type: Bullet: '     - '
#: ../text/chapter14.md:711
#, markdown-text
msgid ""
"Combine functions like `p` and `img` (with return type `Element`) with the "
"`elem` action to create new actions with return type `Content Unit`."
msgstr ""

#. type: Bullet: '     - '
#: ../text/chapter14.md:711
#, markdown-text
msgid ""
"Change the `render` function to accept an argument of type `Content Unit` "
"instead of `Element`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:711
#, markdown-text
msgid ""
"(Medium) Hide the implementation of the `Content` monad using a `newtype` "
"instead of a type synonym. You should not export the data constructor for "
"your `newtype`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter14.md:711
#, markdown-text
msgid "(Difficult) Modify the `ContentF` type to support a new action"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:715
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     isMobile :: Content Boolean\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:717
#, markdown-text, no-wrap
msgid ""
"     which returns a boolean value indicating whether or not the document is "
"being rendered for display on a mobile device.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:719
#, markdown-text, no-wrap
msgid ""
"     _Hint_: use the `ask` action and the `ReaderT` monad transformer to "
"interpret this action. Alternatively, you might prefer to use the `RWS` "
"monad.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:723
#, markdown-text
msgid ""
"In this chapter, we developed a domain-specific language for creating HTML "
"documents by incrementally improving a naive implementation using some "
"standard techniques:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:728
#, markdown-text
msgid ""
"We used _smart constructors_ to hide the details of our data representation, "
"only permitting the user to create documents that were "
"_correct-by-construction_."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:728
#, markdown-text
msgid ""
"We used a _user-defined infix binary operator_ to improve the syntax of the "
"language."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:728
#, markdown-text
msgid ""
"We used _phantom types_ to encode additional information in the types of our "
"data, preventing the user from providing attribute values of the wrong type."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter14.md:728
#, markdown-text
msgid ""
"We used the _free monad_ to turn our array representation of a collection of "
"content into a monadic representation supporting do notation. We then "
"extended this representation to support a new monadic action and interpreted "
"the monadic computations using standard monad transformers."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:730
#, markdown-text
msgid ""
"These techniques all leverage PureScript's module and type systems, either "
"to prevent the user from making mistakes or to improve the syntax of the "
"domain-specific language."
msgstr ""

#. type: Plain text
#: ../text/chapter14.md:731
#, markdown-text
msgid ""
"Implementing domain-specific languages in functional programming languages "
"is an area of active research. Still, hopefully, this provides a useful "
"introduction to some simple techniques and illustrates the power of working "
"in a language with expressive types."
msgstr ""

#. type: Title #
#: ../text/chapter2.md:1
#, markdown-text, no-wrap
msgid "Getting Started"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:6
#, markdown-text
msgid ""
"In this chapter, we'll set up a working PureScript development environment, "
"solve some exercises, and use the tests provided with this book to check our "
"answers. You may also find a [video walkthrough of this "
"chapter](https://www.youtube.com/watch?v=GPjPwb6d-70) helpful if that better "
"suits your learning style."
msgstr ""

#. type: Title ##
#: ../text/chapter2.md:7
#, markdown-text, no-wrap
msgid "Environment Setup"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:10
#, markdown-text
msgid ""
"First, work through this [Getting Started "
"Guide](https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md) "
"in the Documentation Repo to setup your environment and learn a few basics "
"about the language. Don't worry if the code in the example solution to the "
"[Project Euler](http://projecteuler.net/problem=1) problem is confusing or "
"contains unfamiliar syntax. We'll cover all of this in great detail in the "
"upcoming chapters."
msgstr ""

#. type: Title ###
#: ../text/chapter2.md:11
#, markdown-text, no-wrap
msgid "Editor support"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:14
#, markdown-text
msgid ""
"You can use your preferred editor to write PureScript (for example, to solve "
"the book exercises). See [Editor Support "
"Documentation](https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editor-support)."
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:18
#, markdown-text, no-wrap
msgid ""
"> Note that some editors expect a `spago.dhall` file in the root of the "
"opened project for full IDE support. For example, you should open the "
"`chapter2` directory to work on the exercises in this chapter.\n"
">\n"
"> If you use VS Code, you can use the provided workspace to open all the "
"chapters simultaneously.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter2.md:19
#, markdown-text, no-wrap
msgid "Solving Exercises"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:22
#, markdown-text
msgid ""
"Now that you've installed the necessary development tools, clone this book's "
"repo."
msgstr ""

#. type: Fenced code block (sh)
#: ../text/chapter2.md:23
#, no-wrap
msgid "git clone https://github.com/purescript-contrib/purescript-book.git\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:28
#, markdown-text
msgid ""
"The book repo contains PureScript example code and unit tests for the "
"exercises that accompany each chapter. There's some initial setup required "
"to reset the exercise solutions so they are ready to be solved by you. Use "
"the `prepareExercises.sh` script to simplify this process:"
msgstr ""

#. type: Fenced code block (sh)
#: ../text/chapter2.md:29
#, no-wrap
msgid ""
"cd purescript-book\n"
"./scripts/prepareExercises.sh\n"
"git add .\n"
"git commit --all --message \"Exercises ready to be solved\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:37
#, markdown-text
msgid "Now run the tests for this chapter:"
msgstr ""

#. type: Fenced code block (sh)
#: ../text/chapter2.md:38
#, no-wrap
msgid ""
"cd exercises/chapter2\n"
"spago test\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:44
#, markdown-text
msgid "You should see the following successful test output:"
msgstr ""

#. type: Fenced code block (sh)
#: ../text/chapter2.md:45
#, no-wrap
msgid ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"\n"
"All 2 tests passed! 🎉\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:54
#, markdown-text
msgid ""
"Note that the `answer` function (found in `src/Euler.purs`) has been "
"modified to find the multiples of 3 and 5 below any integer. The test suite "
"(located in `test/Main.purs`) for this `answer` function is more "
"comprehensive than the test in the earlier getting-started guide. Don't "
"worry about understanding how this test framework code works while reading "
"these early chapters."
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:56
#, markdown-text
msgid ""
"The remainder of the book contains lots of exercises. If you write your "
"solutions in the `Test.MySolutions` module (`test/MySolutions.purs`), you "
"can check your work against the provided test suite."
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:58
#, markdown-text
msgid ""
"Let's work through this next exercise together in a test-driven-development "
"style."
msgstr ""

#. type: Title ##
#: ../text/chapter2.md:59
#, markdown-text, no-wrap
msgid "Exercise"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter2.md:62
#, markdown-text
msgid ""
"(Medium) Write a `diagonal` function to compute the length of the diagonal "
"(or hypotenuse) of a right-angled triangle when given the lengths of the two "
"other sides."
msgstr ""

#. type: Title ##
#: ../text/chapter2.md:63
#, markdown-text, no-wrap
msgid "Solution"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:66
#, markdown-text
msgid ""
"We'll start by enabling the tests for this exercise. Move the start of the "
"block-comment down a few lines, as shown below. Block comments start with "
"`{-` and end with `-}`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter2.md:67
#, no-wrap
msgid ""
"{{#include ../exercises/chapter2/test/Main.purs:diagonalTests}}\n"
"    {-  Move this block comment starting point to enable more tests\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:73
#, markdown-text
msgid ""
"If we attempt to run the test now, we'll encounter a compilation error "
"because we have not yet implemented our `diagonal` function."
msgstr ""

#. type: Fenced code block (sh)
#: ../text/chapter2.md:74
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Error found:\n"
"in module Test.Main\n"
"at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)\n"
"\n"
"  Unknown value diagonal\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:85
#, markdown-text
msgid ""
"Let's first look at what happens with a faulty version of this function. Add "
"the following code to `test/MySolutions.purs`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter2.md:86
#, no-wrap
msgid ""
"import Data.Number (sqrt)\n"
"\n"
"diagonal w h = sqrt (w * w + h)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:93
#, markdown-text
msgid "And check our work by running `spago test`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter2.md:94
#, no-wrap
msgid ""
"→ Suite: diagonal\n"
"  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989\n"
"  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219\n"
"\n"
"2 tests failed:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:103
#, markdown-text
msgid ""
"Uh-oh, that's not quite right. Let's fix this with the correct application "
"of the Pythagorean formula by changing the function to:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter2.md:104
#, no-wrap
msgid "{{#include ../exercises/chapter2/test/no-peeking/Solutions.purs:diagonal}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:109
#, markdown-text
msgid "Trying `spago test` again now shows all tests are passing:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter2.md:110
#, no-wrap
msgid ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"→ Suite: diagonal\n"
"  ✓ Passed: 3 4 5\n"
"  ✓ Passed: 5 12 13\n"
"\n"
"All 4 tests passed! 🎉\n"
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:122
#, markdown-text
msgid "Success! Now you're ready to try these next exercises on your own."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter2.md:127
#, markdown-text
msgid ""
"(Easy) Write a function `circleArea` which computes the area of a circle "
"with a given radius. Use the `pi` constant, which is defined in the "
"`Numbers` module. _Hint_: don't forget to import `pi` by modifying the "
"`import Data.Number` statement."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter2.md:127
#, markdown-text
msgid ""
"(Medium) Write a function `leftoverCents` which takes an `Int` and returns "
"what's leftover after dividing by `100`. Use the `rem` function. Search "
"[Pursuit](https://pursuit.purescript.org/) for this function to learn about "
"usage and which module to import it from. _Note:_ Your IDE may support "
"auto-importing of this function if you accept the auto-completion "
"suggestion."
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:131
#, markdown-text
msgid ""
"In this chapter, we installed the PureScript compiler and the Spago tool. We "
"also learned how to write solutions to exercises and check these for "
"correctness."
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:133
#, markdown-text
msgid ""
"There will be many more exercises in the chapters ahead, and working through "
"those helps with learning the material. If any of the exercises stumps you, "
"please reach out to any of the community resources listed in the [Getting "
"Help](https://book.purescript.org/chapter1.html#getting-help) section of "
"this book, or even file an issue in this [book's "
"repo](https://github.com/purescript-contrib/purescript-book/issues). This "
"reader feedback on which exercises could be made more approachable helps us "
"improve the book."
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:135
#, markdown-text
msgid ""
"Once you solve all the exercises in a chapter, you may compare your answers "
"against those in the `no-peeking/Solutions.purs`. No peeking, please, "
"without putting in an honest effort to solve these yourself. And even if you "
"are stuck, try asking a community member for help first, as we would prefer "
"to give you a small hint rather than spoil the exercise. If you found a more "
"elegant solution (that only requires knowledge of the covered content), "
"please send us a PR."
msgstr ""

#. type: Plain text
#: ../text/chapter2.md:136
#, markdown-text
msgid ""
"The repo is continuously being revised, so be sure to check for updates "
"before starting each new chapter."
msgstr ""

#. type: Title #
#: ../text/chapter3.md:1
#, markdown-text, no-wrap
msgid "Functions and Records"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:6
#, markdown-text
msgid ""
"This chapter will introduce two building blocks of PureScript programs: "
"functions and records. In addition, we'll see how to structure PureScript "
"programs, and how to use types as an aid to program development."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:8
#, markdown-text
msgid ""
"We will build a simple address book application to manage a list of "
"contacts. This code will introduce some new ideas from the syntax of "
"PureScript."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:10
#, markdown-text
msgid ""
"The front-end of our application will be the interactive mode PSCi, but it "
"would be possible to build on this code to write a front-end in "
"JavaScript. In fact, we will do exactly that in later chapters, adding form "
"validation and save/restore functionality."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:14
#, markdown-text
msgid ""
"The source code for this chapter is contained in the file "
"`src/Data/AddressBook.purs`. This file starts with a module declaration and "
"its import list:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:15
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:imports}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:20
#, markdown-text
msgid "Here, we import several modules:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:25
#, markdown-text
msgid ""
"The `Prelude` module, which contains a small set of standard definitions and "
"functions. It re-exports many foundational modules from "
"the `purescript-prelude` library."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:25
#, markdown-text
msgid "The `Control.Plus` module, which defines the `empty` value."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:25
#, markdown-text
msgid ""
"The `Data.List` module, provided by the `lists` package, which can be "
"installed using Spago. It contains a few functions that we will need for "
"working with linked lists."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:25
#, markdown-text
msgid ""
"The `Data.Maybe` module, which defines data types and functions for working "
"with optional values."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:27
#, markdown-text
msgid ""
"Notice that the imports for these modules are listed explicitly in "
"parentheses (except for `Prelude`, which is typically imported as an open "
"import). This is generally a good practice, as it helps to avoid conflicting "
"imports."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:29
#, markdown-text
msgid ""
"Assuming you have cloned the book's source code repository, the project for "
"this chapter can be built using Spago, with the following commands:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:30
#, no-wrap
msgid ""
"$ cd chapter3\n"
"$ spago build\n"
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:35
#, markdown-text, no-wrap
msgid "Simple Types"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:38
#, markdown-text
msgid ""
"PureScript defines three built-in types corresponding to JavaScript's "
"primitive types: numbers, strings, and booleans. These are defined in the "
"`Prim` module, which is implicitly imported by every module. They are called "
"`Number`, `String`, and `Boolean`, respectively, and you can see them in "
"PSCi by using the `:type` command to print the types of some simple values:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:39
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :type 1.0\n"
"Number\n"
"\n"
"> :type \"test\"\n"
"String\n"
"\n"
"> :type true\n"
"Boolean\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:53
#, markdown-text
msgid ""
"PureScript defines other built-in types: integers, characters, arrays, "
"records, and functions."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:55
#, markdown-text
msgid ""
"Integers are differentiated from floating point values of type `Number` by "
"the lack of a decimal point:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:56
#, no-wrap
msgid ""
"> :type 1\n"
"Int\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:62
#, markdown-text
msgid ""
"Character literals are wrapped in single quotes, unlike string literals "
"which use double quotes:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:63
#, no-wrap
msgid ""
"> :type 'a'\n"
"Char\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:69
#, markdown-text
msgid ""
"Arrays correspond to JavaScript arrays, but unlike in JavaScript, all "
"elements of a PureScript array must have the same type:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:70
#, no-wrap
msgid ""
"> :type [1, 2, 3]\n"
"Array Int\n"
"\n"
"> :type [true, false]\n"
"Array Boolean\n"
"\n"
"> :type [1, false]\n"
"Could not match type Int with type Boolean.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:82
#, markdown-text
msgid ""
"The last example shows an error from the type checker, which failed to "
"_unify_ (i.e., make equal) the types of the two elements."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:84
#, markdown-text
msgid ""
"Records correspond to JavaScript's objects, and record literals have the "
"same syntax as JavaScript's object literals:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:85
#, no-wrap
msgid ""
"> author = { name: \"Phil\", interests: [\"Functional Programming\", "
"\"JavaScript\"] }\n"
"\n"
"> :type author\n"
"{ name :: String\n"
", interests :: Array String\n"
"}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:95
#, markdown-text
msgid ""
"This type indicates that the specified object has two _fields_: a `name` "
"field with the type `String` and an `interests` field with the type `Array "
"String`, i.e., an array of `String`s."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:97
#, markdown-text
msgid ""
"Fields of records can be accessed using a dot, followed by the label of the "
"field to access:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:98
#, no-wrap
msgid ""
"> author.name\n"
"\"Phil\"\n"
"\n"
"> author.interests\n"
"[\"Functional Programming\",\"JavaScript\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:107
#, markdown-text
msgid ""
"PureScript's functions correspond to JavaScript's functions. Functions can "
"be defined at the top-level of a file by specifying arguments before the "
"equals sign:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:108
#, no-wrap
msgid ""
"import Prelude -- bring the (+) operator into scope\n"
"\n"
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:116
#, markdown-text
msgid ""
"Alternatively, functions can be defined inline using a backslash character "
"followed by a space-delimited list of argument names. To enter a multi-line "
"declaration in PSCi, we can enter \"paste mode\" using the `:paste` "
"command. In this mode, declarations are terminated using the _Control-D_ key "
"sequence:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:117
#, no-wrap
msgid ""
"> import Prelude\n"
"> :paste\n"
"… add :: Int -> Int -> Int\n"
"… add = \\x y -> x + y\n"
"… ^D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:126
#, markdown-text
msgid ""
"Having defined this function in PSCi, we can _apply_ it to its arguments by "
"separating the two arguments from the function name by whitespace:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:127
#, no-wrap
msgid ""
"> add 10 20\n"
"30\n"
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:132
#, markdown-text, no-wrap
msgid "Notes On Indentation"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:135
#, markdown-text
msgid ""
"PureScript code is _indentation-sensitive_, just like Haskell, but unlike "
"JavaScript. This means that the whitespace in your code is not meaningless, "
"but rather is used to group regions of code, just like curly braces in "
"C-like languages."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:137
#, markdown-text
msgid ""
"If a declaration spans multiple lines, any lines except the first must be "
"indented past the indentation level of the first line."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:139
#, markdown-text
msgid "Therefore, the following is a valid PureScript code:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:140
#, no-wrap
msgid ""
"add x y z = x +\n"
"  y + z\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:146
#, markdown-text
msgid "But this is not a valid code:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:147
#, no-wrap
msgid ""
"add x y z = x +\n"
"y + z\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:153
#, markdown-text
msgid ""
"In the second case, the PureScript compiler will try to parse _two_ "
"declarations, one for each line."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:155
#, markdown-text
msgid ""
"Generally, any declarations defined in the same block should be indented at "
"the same level. For example, in PSCi, declarations in a let statement must "
"be indented equally. This is valid:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:156
#, no-wrap
msgid ""
"> :paste\n"
"… x = 1\n"
"… y = 2\n"
"… ^D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:164
#, markdown-text
msgid "But this is not:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:165
#, no-wrap
msgid ""
"> :paste\n"
"… x = 1\n"
"…  y = 2\n"
"… ^D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:173
#, markdown-text
msgid ""
"Certain PureScript keywords introduce a new block of code, in which "
"declarations must be further-indented:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:174
#, no-wrap
msgid ""
"example x y z =\n"
"  let\n"
"    foo = x * y\n"
"    bar = y * z\n"
"  in\n"
"    foo + bar\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:184
#, markdown-text
msgid "This doesn't compile:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:185
#, no-wrap
msgid ""
"example x y z =\n"
"  let\n"
"    foo = x * y\n"
"  bar = y * z\n"
"  in\n"
"    foo + bar\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:195
#, markdown-text
msgid ""
"If you want to learn more (or encounter any problems), see the "
"[Syntax](https://github.com/purescript/documentation/blob/master/language/Syntax.md#syntax) "
"documentation."
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:196
#, markdown-text, no-wrap
msgid "Defining Our Types"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:199
#, markdown-text
msgid ""
"A good first step when tackling a new problem in PureScript is to write out "
"type definitions for any values you will be working with. First, let's "
"define a type for records in our address book:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Entry}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:205
#, markdown-text
msgid ""
"This defines a _type synonym_ called `Entry` – the type `Entry` is "
"equivalent to the type on the right of the equals symbol: a record type with "
"three fields – `firstName`, `lastName`, and `address`. The two name fields "
"will have the type `String`, and the `address` field will have the type "
"`Address`, defined as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Address}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:211
#, markdown-text
msgid "Note that records can contain other records."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:213
#, markdown-text
msgid ""
"Now let's define a third type synonym for our address book data structure, "
"which will be represented simply as a linked list of entries:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:214
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:AddressBook}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:219
#, markdown-text
msgid ""
"Note that `List Entry` differs from `Array Entry`, which represents an "
"_array_ of entries."
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:220
#, markdown-text, no-wrap
msgid "Type Constructors and Kinds"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:223
#, markdown-text
msgid ""
"`List` is an example of a _type constructor_. Values do not have the type "
"`List` directly, but rather `List a` for some type `a`. That is, `List` "
"takes a _type argument_ `a` and _constructs_ a new type `List a`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:225
#, markdown-text
msgid ""
"Note that just like function application, type constructors are applied to "
"other types simply by juxtaposition: the type `List Entry` is, in fact, the "
"type constructor `List` _applied_ to the type `Entry` – it represents a list "
"of entries."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:227
#, markdown-text
msgid ""
"If we try to incorrectly define a value of type `List` (by using the type "
"annotation operator `::`), we will see a new type of error:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:228
#, no-wrap
msgid ""
"> import Data.List\n"
"> Nil :: List\n"
"In a type-annotated expression x :: t, the type t must have kind Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:235
#, markdown-text
msgid ""
"This is a _kind error_. Just like values are distinguished by their _types_, "
"types are distinguished by their _kinds_, and just like ill-typed values "
"result in _type errors_, _ill-kinded_ types result in _kind errors_."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:237
#, markdown-text
msgid ""
"There is a special kind called `Type` which represents the kind of all types "
"which have values, like `Number` and `String`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:239
#, markdown-text, no-wrap
msgid ""
"There are also kinds for type constructors. For example, the kind `Type -> "
"Type` represents a function from types to types, just like `List`. So the "
"error here occurred because values are expected to have types with kind "
"`Type`, but `List` has kind `Type -> Type`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:241
#, markdown-text
msgid ""
"To find out the kind of a type, use the `:kind` command in PSCi. For "
"example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:242
#, no-wrap
msgid ""
"> :kind Number\n"
"Type\n"
"\n"
"> import Data.List\n"
"> :kind List\n"
"Type -> Type\n"
"\n"
"> :kind List String\n"
"Type\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:255
#, markdown-text
msgid ""
"PureScript's _kind system_ supports other interesting kinds, which we will "
"see later in the book."
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:256
#, markdown-text, no-wrap
msgid "Quantified Types"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:259
#, markdown-text
msgid ""
"For illustration purposes, let's define a primitive function that takes any "
"two arguments and returns the first one:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:260
#, no-wrap
msgid ""
"> :paste\n"
"… constantlyFirst :: forall a b. a -> b -> a\n"
"… constantlyFirst = \\a b -> a\n"
"… ^D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:275
#, markdown-text, no-wrap
msgid ""
"> Note that if you use `:type` to ask about the type of `constantlyFirst`, "
"it will be more verbose:\n"
">\n"
"> ```text\n"
"> : type constantlyFirst\n"
"> forall (a :: Type) (b :: Type). a -> b -> a\n"
"> ```\n"
">\n"
"> The type signature contains additional kind information, which explicitly "
"notes that `a` and `b` should be concrete types.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:277
#, markdown-text
msgid ""
"The keyword `forall` indicates that `constantlyFirst` has a _universally "
"quantified type_. It means we can substitute any types for `a` and `b` – "
"`constantlyFirst` will work with these types."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:279
#, markdown-text
msgid ""
"For example, we might choose the type `a` to be `Int` and `b` to be "
"`String`. In that case, we can _specialize_ the type of `constantlyFirst` to"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:280
#, no-wrap
msgid "Int -> String -> Int\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:285
#, markdown-text
msgid ""
"We don't have to indicate in code that we want to specialize a quantified "
"type – it happens automatically. For example, we can use `constantlyFirst` "
"as if it had this type already:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:286
#, no-wrap
msgid ""
"> constantlyFirst 3 \"ignored\"\n"
"\n"
"3\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:293
#, markdown-text
msgid ""
"While we can choose any types for `a` and `b`, the return type of "
"`constantlyFirst` has to be the same as the type of the first argument "
"(because both of them are \"tied\" to the same `a`):"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:294
#, no-wrap
msgid ""
":type constantlyFirst true \"ignored\"\n"
"Boolean\n"
"\n"
":type constantlyFirst \"keep\" 3\n"
"String\n"
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:302
#, markdown-text, no-wrap
msgid "Displaying Address Book Entries"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:305
#, markdown-text
msgid ""
"Let's write our first function, which will render an address book entry as a "
"string. We start by giving the function a type. This is optional, but good "
"practice, since it acts as a form of documentation. In fact, the PureScript "
"compiler will give a warning if a top-level declaration does not contain a "
"type annotation. A type declaration separates the name of a function from "
"its type with the `::` symbol:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:306
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter3/src/Data/AddressBook.purs:showEntry_signature}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:311
#, markdown-text
msgid ""
"This type signature says that `showEntry` is a function that takes an "
"`Entry` as an argument and returns a `String`. Here is the code for "
"`showEntry`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:312
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter3/src/Data/AddressBook.purs:showEntry_implementation}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:317
#, markdown-text
msgid ""
"This function concatenates the three fields of the `Entry` record into a "
"single string, using the `showAddress` function to turn the record inside "
"the `address` field into a `String`. `showAddress` is defined similarly:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:318
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showAddress}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:323
#, markdown-text, no-wrap
msgid ""
"A function definition begins with the name of the function, followed by a "
"list of argument names. The result of the function is specified after the "
"equals sign. Fields are accessed with a dot, followed by the field name. In "
"PureScript, string concatenation uses the diamond operator (`<>`), instead "
"of the plus operator like in JavaScript.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:324
#, markdown-text, no-wrap
msgid "Test Early, Test Often"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:327
#, markdown-text
msgid ""
"The PSCi interactive mode allows for rapid prototyping with immediate "
"feedback, so let's use it to verify that our first few functions behave as "
"expected."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:329
#, markdown-text
msgid "First, build the code you've written:"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:335
#, markdown-text
msgid "Next, load PSCi, and use the `import` command to import your new module:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:336
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.AddressBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:343
#, markdown-text
msgid ""
"We can create an entry by using a record literal, which looks just like an "
"anonymous object in JavaScript."
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:344
#, no-wrap
msgid ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" "
"}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:349
#, markdown-text
msgid "Now, try applying our function to the example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:350
#, no-wrap
msgid ""
"> showAddress address\n"
"\n"
"\"123 Fake St., Faketown, CA\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:357
#, markdown-text
msgid ""
"Let's also test `showEntry` by creating an address book entry record "
"containing our example address:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:358
#, no-wrap
msgid ""
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> showEntry entry\n"
"\n"
"\"Smith, John: 123 Fake St., Faketown, CA\"\n"
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:365
#, markdown-text, no-wrap
msgid "Creating Address Books"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:368
#, markdown-text
msgid ""
"Now let's write some utility functions for working with address books. We "
"will need a value representing an empty address book: an empty list."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:369
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:emptyBook}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:374
#, markdown-text
msgid ""
"We will also need a function for inserting a value into an existing address "
"book. We will call this function `insertEntry`. Start by giving its type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:375 ../text/chapter3.md:459
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter3/src/Data/AddressBook.purs:insertEntry_signature}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:380
#, markdown-text
msgid ""
"This type signature says that `insertEntry` takes an `Entry` as its first "
"argument, an `AddressBook` as a second argument, and returns a new "
"`AddressBook`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:382
#, markdown-text
msgid ""
"We don't modify the existing `AddressBook` directly. Instead, we return a "
"new `AddressBook`, which contains the same data. As such, `AddressBook` is "
"an example of an _immutable data structure_. This is an important idea in "
"PureScript – mutation is a side-effect of code and inhibits our ability to "
"reason effectively about its behavior, so we prefer pure functions and "
"immutable data where possible."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:384
#, markdown-text
msgid ""
"To implement `insertEntry`, we can use the `Cons` function from "
"`Data.List`. To see its type, open PSCi and use the `:type` command:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:385
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type Cons\n"
"\n"
"forall (a :: Type). a -> List a -> List a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:395
#, markdown-text
msgid ""
"This type signature says that `Cons` takes a value of some type `a`, takes a "
"list of elements of type `a`, and returns a new list with entries of the "
"same type. Let's specialize this with `a` as our `Entry` type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:396
#, no-wrap
msgid "Entry -> List Entry -> List Entry\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:401
#, markdown-text
msgid "But `List Entry` is the same as `AddressBook`, so this is equivalent to"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:402
#, no-wrap
msgid "Entry -> AddressBook -> AddressBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:407
#, markdown-text
msgid ""
"In our case, we already have the appropriate inputs: an `Entry`, and an "
"`AddressBook`, so can apply `Cons` and get a new `AddressBook`, which is "
"exactly what we wanted!"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:409
#, markdown-text
msgid "Here is our implementation of `insertEntry`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:410
#, no-wrap
msgid "insertEntry entry book = Cons entry book\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:415
#, markdown-text
msgid ""
"This brings the two arguments `entry` and `book` into scope – on the "
"left-hand side of the equals symbol – and then applies the `Cons` function "
"to create the result."
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:416
#, markdown-text, no-wrap
msgid "Curried Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:419
#, markdown-text
msgid ""
"Functions in PureScript take exactly one argument. While it looks like the "
"`insertEntry` function takes two arguments, it is an example of a _curried "
"function_. In PureScript, all functions are considered curried."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:421
#, markdown-text
msgid ""
"Currying means converting a function that takes multiple arguments into a "
"function that takes them one at a time. When we call a function, we pass it "
"one argument, and it returns another function that also takes one argument "
"until all arguments are passed."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:423
#, markdown-text
msgid ""
"For example, when we pass `5` to `add`, we get another function, which takes "
"an int, adds 5 to it, and returns the sum as a result:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:424
#, no-wrap
msgid ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"
"\n"
"addFive :: Int -> Int\n"
"addFive = add 5\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:433
#, markdown-text
msgid ""
"`addFive` is the result of _partial application_, which means we pass less "
"than the total number of arguments to a function that takes multiple "
"arguments. Let's give it a try:"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:443
#, markdown-text, no-wrap
msgid ""
"> Note that you must define the `add` function if you haven't already:\n"
">\n"
"> ```text\n"
"> > import Prelude\n"
"> > :paste\n"
">… add :: Int -> Int -> Int\n"
">… add x y = x + y\n"
">… ^D\n"
"> ```\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:444
#, no-wrap
msgid ""
"> :paste\n"
"… addFive :: Int -> Int\n"
"… addFive = add 5\n"
"… ^D\n"
"\n"
"> addFive 1\n"
"6\n"
"\n"
"> add 5 1\n"
"6\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:458
#, markdown-text
msgid ""
"To better understand currying and partial application, try making a few "
"other functions, for example, out of `add`. And when you're done, let's "
"return to the `insertEntry`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:464
#, markdown-text, no-wrap
msgid ""
"The `->` operator (in the type signature) associates to the right, which "
"means that the compiler parses the type as\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:465
#, no-wrap
msgid "Entry -> (AddressBook -> AddressBook)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:470
#, markdown-text
msgid ""
"`insertEntry` takes a single argument, an `Entry`, and returns a new "
"function, which in turn takes a single `AddressBook` argument and returns a "
"new `AddressBook`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:472
#, markdown-text
msgid ""
"This means we can _partially apply_ `insertEntry` by specifying only its "
"first argument, for example. In PSCi, we can see the result type:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:473
#, no-wrap
msgid ""
"> :type insertEntry entry\n"
"\n"
"AddressBook -> AddressBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:480
#, markdown-text
msgid ""
"As expected, the return type was a function. We can apply the resulting "
"function to a second argument:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:481
#, no-wrap
msgid ""
"> :type (insertEntry entry) emptyBook\n"
"AddressBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:487
#, markdown-text
msgid ""
"Note though, that the parentheses here are unnecessary – the following is "
"equivalent:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:488
#, no-wrap
msgid ""
"> :type insertEntry entry emptyBook\n"
"AddressBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:494
#, markdown-text
msgid ""
"This is because function application associates to the left, which explains "
"why we can specify function arguments one after the other, separated by "
"whitespace."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:496
#, markdown-text, no-wrap
msgid ""
"The `->` operator in function types is a _type constructor_ for "
"functions. It takes two type arguments: the function's argument type and the "
"return type – the left and right operands, respectively.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:498
#, markdown-text
msgid ""
"Note that in the rest of the book, I will talk about things like \"functions "
"of two arguments\". However, it is to be understood that this means a "
"curried function, taking a first argument and returning a function that "
"takes the second."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:500
#, markdown-text
msgid "Now consider the definition of `insertEntry`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:501
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry book = Cons entry book\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:507
#, markdown-text
msgid ""
"If we explicitly parenthesize the right-hand side, we get `(Cons entry) "
"book`. That is, `insertEntry entry` is a function whose argument is just "
"passed along to the `(Cons entry)` function. But if two functions have the "
"same result for every input, then they are the same! So we can remove the "
"argument `book` from both sides:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:508
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry = Cons entry\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:514
#, markdown-text
msgid "But now, by the same argument, we can remove `entry` from both sides:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:515
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:520
#, markdown-text
msgid ""
"This process, called _eta conversion_, can be used (along with other "
"techniques) to rewrite functions in _point-free form_, which means functions "
"defined without reference to their arguments."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:522
#, markdown-text
msgid ""
"In the case of `insertEntry`, _eta conversion_ has resulted in a very clear "
"definition of our function – \"`insertEntry` is just cons on "
"lists\". However, it is arguable whether the point-free form is better in "
"general."
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:523
#, markdown-text, no-wrap
msgid "Property Accessors"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:526
#, markdown-text
msgid ""
"One common pattern is to use a function to access individual fields (or "
"\"properties\") of a record. An inline function to extract an `Address` from "
"an `Entry` could be written as:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:527
#, no-wrap
msgid "\\entry -> entry.address\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:532
#, markdown-text
msgid ""
"PureScript also allows [_property "
"accessor_](https://github.com/purescript/documentation/blob/master/language/Syntax.md#property-accessors) "
"shorthand, where an underscore acts as the anonymous function argument, so "
"the inline function above is equivalent to:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:533
#, no-wrap
msgid "_.address\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:538
#, markdown-text
msgid ""
"This works with any number of levels or properties, so a function to extract "
"the city associated with an `Entry` could be written as:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:539
#, no-wrap
msgid "_.address.city\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:544 ../text/chapter4.md:249
#, markdown-text
msgid "For example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:545
#, no-wrap
msgid ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" "
"}\n"
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> _.lastName entry\n"
"\"Smith\"\n"
"\n"
"> _.address.city entry\n"
"\"Faketown\"\n"
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:555
#, markdown-text, no-wrap
msgid "Querying the Address Book"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:558
#, markdown-text
msgid ""
"The last function we need to implement for our minimal address book "
"application will look up a person by name and return the correct "
"`Entry`. This will be a nice application of building programs by composing "
"small functions – a key idea from functional programming."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:560
#, markdown-text
msgid ""
"We can filter the address book, keeping only those entries with the correct "
"first and last names. Then we can return the head (i.e., first) element of "
"the resulting list."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:562
#, markdown-text
msgid ""
"With this high-level specification of our approach, we can calculate the "
"type of our function. First, open PSCi, and find the types of the `filter` "
"and `head` functions:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:563
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type filter\n"
"\n"
"forall (a :: Type). (a -> Boolean) -> List a -> List a\n"
"\n"
"> :type head\n"
"\n"
"forall (a :: Type). List a -> Maybe a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:577
#, markdown-text
msgid "Let's pick apart these two types to understand their meaning."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:579
#, markdown-text
msgid ""
"`filter` is a curried function of two arguments. Its first argument is a "
"function, which takes an element of the list and returns a `Boolean` "
"value. Its second argument is a list of elements, and the return value is "
"another list."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:581
#, markdown-text
msgid ""
"`head` takes a list as its argument and returns a type we haven't seen "
"before: `Maybe a`. `Maybe a` represents an optional value of type `a`, and "
"provides a type-safe alternative to using `null` to indicate a missing value "
"in languages like JavaScript. We will see it again in more detail in later "
"chapters."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:583
#, markdown-text
msgid ""
"The universally quantified types of `filter` and `head` can be _specialized_ "
"by the PureScript compiler, to the following types:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:584
#, no-wrap
msgid ""
"filter :: (Entry -> Boolean) -> AddressBook -> AddressBook\n"
"\n"
"head :: AddressBook -> Maybe Entry\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:591
#, markdown-text
msgid ""
"We know that we will need to pass the first and last names that we want to "
"search for as arguments to our function."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:593
#, markdown-text, no-wrap
msgid ""
"We also know that we will need a function to pass to `filter`. Let's call "
"this function `filterEntry`. `filterEntry` will have type `Entry -> "
"Boolean`. The application `filter filterEntry` will then have type "
"`AddressBook -> AddressBook`. If we pass the result of this function to the "
"`head` function, we get our result of type `Maybe Entry`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:595
#, markdown-text
msgid ""
"Putting these facts together, a reasonable type signature for our function, "
"which we will call `findEntry`, is:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:596
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter3/src/Data/AddressBook.purs:findEntry_signature}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:601
#, markdown-text
msgid ""
"This type signature says that `findEntry` takes two strings: the first and "
"last names, takes an `AddressBook`, and returns an optional `Entry`. The "
"optional result will contain a value only if the name is found in the "
"address book."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:603
#, markdown-text
msgid "And here is the definition of `findEntry`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:604
#, no-wrap
msgid ""
"findEntry firstName lastName book = head (filter filterEntry book)\n"
"  where\n"
"    filterEntry :: Entry -> Boolean\n"
"    filterEntry entry = entry.firstName == firstName && entry.lastName == "
"lastName\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:612
#, markdown-text
msgid "Let's go over this code step by step."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:614
#, markdown-text
msgid ""
"`findEntry` brings three names into scope: `firstName` and `lastName`, both "
"representing strings, and `book`, an `AddressBook`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:616
#, markdown-text
msgid ""
"The right-hand side of the definition combines the `filter` and `head` "
"functions: first, the list of entries is filtered, and the `head` function "
"is applied to the result."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:618
#, markdown-text
msgid ""
"The predicate function `filterEntry` is defined as an auxiliary declaration "
"inside a `where` clause. This way, the `filterEntry` function is available "
"inside the definition of our function, but not outside it. Also, it can "
"depend on the arguments to the enclosing function, which is essential here "
"because `filterEntry` uses the `firstName` and `lastName` arguments to "
"filter the specified `Entry`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:620
#, markdown-text
msgid ""
"Note that, just like for top-level declarations, it was unnecessary to "
"specify a type signature for `filterEntry`. However, doing so is recommended "
"as a form of documentation."
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:621
#, markdown-text, no-wrap
msgid "Infix Function Application"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:624
#, markdown-text
msgid ""
"Most functions discussed so far used _prefix_ function application, where "
"the function name was put _before_ the arguments. For example, when using "
"the `insertEntry` function to add an `Entry` (`john`) to an empty "
"`AddressBook`, we might write:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:625
#, no-wrap
msgid "> book1 = insertEntry john emptyBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:630
#, markdown-text
msgid ""
"However, this chapter has also included examples of _infix_ [binary "
"operators](https://github.com/purescript/documentation/blob/master/language/Syntax.md#binary-operators), "
"such as the `==` operator in the definition of `filterEntry`, where the "
"operator is put _between_ the two arguments. These infix operators are "
"defined in the PureScript source as infix aliases for their underlying "
"_prefix_ implementations. For example, `==` is defined as an infix alias for "
"the prefix `eq` function with the line:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:631
#, no-wrap
msgid "infix 4 eq as ==\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:636
#, markdown-text
msgid ""
"Therefore `entry.firstName == firstName` in `filterEntry` could be replaced "
"with the `eq entry.firstName firstName`. We'll cover a few more examples of "
"defining infix operators later in this section."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:638
#, markdown-text
msgid ""
"In some situations, putting a prefix function in an infix position as an "
"operator leads to more readable code. One example is the `mod` function:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:639
#, no-wrap
msgid ""
"> mod 8 3\n"
"2\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:645
#, markdown-text
msgid ""
"The above usage works fine but is awkward to read. A more familiar phrasing "
"is \"eight mod three\", which you can achieve by wrapping a prefix function "
"in backticks (\\`):"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:646
#, no-wrap
msgid ""
"> 8 `mod` 3\n"
"2\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:652
#, markdown-text
msgid ""
"In the same way, wrapping `insertEntry` in backticks turns it into an infix "
"operator, such that `book1` and `book2` below are equivalent:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:653
#, no-wrap
msgid ""
"book1 = insertEntry john emptyBook\n"
"book2 = john `insertEntry` emptyBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:659
#, markdown-text
msgid ""
"We can make an `AddressBook` with multiple entries by using multiple "
"applications of `insertEntry` as a prefix function (`book3`) or as an infix "
"operator (`book4`) as shown below:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:660
#, no-wrap
msgid ""
"book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))\n"
"book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` "
"emptyBook))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:666
#, markdown-text
msgid ""
"We can also define an infix operator alias (or synonym) for `insertEntry.` "
"We'll arbitrarily choose `++` for this operator, give it a "
"[precedence](https://github.com/purescript/documentation/blob/master/language/Syntax.md#precedence) "
"of `5`, and make it right "
"[associative](https://github.com/purescript/documentation/blob/master/language/Syntax.md#associativity) "
"using `infixr`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:667
#, no-wrap
msgid "infixr 5 insertEntry as ++\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:672
#, markdown-text
msgid "This new operator lets us rewrite the above `book4` example as:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:673
#, no-wrap
msgid "book5 = john ++ (peggy ++ (ned ++ emptyBook))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:678
#, markdown-text
msgid ""
"The right associativity of our new `++` operator lets us get rid of the "
"parentheses without changing the meaning:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:679
#, no-wrap
msgid "book6 = john ++ peggy ++ ned ++ emptyBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:684
#, markdown-text
msgid ""
"Another common technique for eliminating parens is to use `apply`'s infix "
"operator `$`, along with your standard prefix functions."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:686
#, markdown-text
msgid "For example, the earlier `book3` example could be rewritten as:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:687
#, no-wrap
msgid "book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:692
#, markdown-text
msgid ""
"Substituting `$` for parens is usually easier to type and (arguably) easier "
"to read. A mnemonic to remember the meaning of this symbol is to think of "
"the dollar sign as being drawn from two parens that are also being "
"crossed-out, suggesting the parens are now unnecessary."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:694
#, markdown-text
msgid ""
"Note that `$` isn't a special syntax hardcoded into the language. It's "
"simply the infix operator for a regular function called `apply`, which is "
"defined in `Data.Function` as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:695
#, no-wrap
msgid ""
"apply :: forall a b. (a -> b) -> a -> b\n"
"apply f x = f x\n"
"\n"
"infixr 0 apply as $\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:703
#, markdown-text, no-wrap
msgid ""
"The `apply` function takes another function (of type `(a -> b)`) as its "
"first argument and a value (of type `a`) as its second argument, then calls "
"that function with that value. If it seems like this function doesn't "
"contribute anything meaningful, you are absolutely correct! Your program is "
"logically identical without it (see [referential "
"transparency](https://en.wikipedia.org/wiki/Referential_transparency)). The "
"syntactic utility of this function comes from the special properties "
"assigned to its infix operator. `$` is a right-associative (`infixr`), low "
"precedence (`0`) operator, which lets us remove sets of parentheses for "
"deeply-nested applications.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:705
#, markdown-text
msgid ""
"Another parens-busting opportunity for the `$` operator is in our earlier "
"`findEntry` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:706
#, no-wrap
msgid "findEntry firstName lastName book = head $ filter filterEntry book\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:711
#, markdown-text
msgid ""
"We'll see an even more elegant way to rewrite this line with \"function "
"composition\" in the next section."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:713
#, markdown-text
msgid ""
"If you'd like to use a concise infix operator alias as a prefix function, "
"you can surround it in parentheses:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:714
#, no-wrap
msgid ""
"> 8 + 3\n"
"11\n"
"\n"
"> (+) 8 3\n"
"11\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:723
#, markdown-text
msgid ""
"Alternatively, operators can be partially applied by surrounding the "
"expression with parentheses and using `_` as an operand in an [operator "
"section](https://github.com/purescript/documentation/blob/master/language/Syntax.md#operator-sections). "
"You can think of this as a more convenient way to create simple anonymous "
"functions (although in the below example, we're then binding that anonymous "
"function to a name, so it's not so anonymous anymore):"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter3.md:724
#, no-wrap
msgid ""
"> add3 = (3 + _)\n"
"> add3 2\n"
"5\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:731
#, markdown-text
msgid ""
"To summarize, the following are equivalent definitions of a function that "
"adds `5` to its argument:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:732
#, no-wrap
msgid ""
"add5 x = 5 + x\n"
"add5 x = add 5 x\n"
"add5 x = (+) 5 x\n"
"add5 x = 5 `add` x\n"
"add5   = add 5\n"
"add5   = \\x -> 5 + x\n"
"add5   = (5 + _)\n"
"add5 x = 5 `(+)` x  -- Yo Dawg, I herd you like infix, so we put infix in "
"your infix!\n"
msgstr ""

#. type: Title ##
#: ../text/chapter3.md:743
#, markdown-text, no-wrap
msgid "Function Composition"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:746
#, markdown-text
msgid ""
"Just like we were able to simplify the `insertEntry` function by using eta "
"conversion, we can simplify the definition of `findEntry` by reasoning about "
"its arguments."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:748
#, markdown-text
msgid ""
"Note that the `book` argument is passed to the `filter filterEntry` "
"function, and the result of this application is passed to `head`. In other "
"words, `book` is passed to the _composition_ of the functions `filter "
"filterEntry` and `head`."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:750
#, markdown-text, no-wrap
msgid ""
"In PureScript, the function composition operators are `<<<` and `>>>`. The "
"first is \"backwards composition\", and the second is \"forwards "
"composition\".\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:752
#, markdown-text
msgid ""
"We can rewrite the right-hand side of `findEntry` using either "
"operator. Using backwards-composition, the right-hand side would be"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:753
#, no-wrap
msgid "(head <<< filter filterEntry) book\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:758
#, markdown-text
msgid ""
"In this form, we can apply the eta conversion trick from earlier, to arrive "
"at the final form of `findEntry`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:759
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter3/src/Data/AddressBook.purs:findEntry_implementation}}\n"
"    ...\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:765
#, markdown-text
msgid "An equally valid right-hand side would be:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter3.md:766
#, no-wrap
msgid "filter filterEntry >>> head\n"
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:771
#, markdown-text
msgid ""
"Either way, this gives a clear definition of the `findEntry` function: "
"\"`findEntry` is the composition of a filtering function and the `head` "
"function\"."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:773
#, markdown-text
msgid ""
"I will let you decide which definition is easier to understand, but it is "
"often useful to think of functions as building blocks in this way: each "
"function executes a single task, and solutions are assembled using function "
"composition."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter3.md:781
#, markdown-text
msgid ""
"(Easy) Test your understanding of the `findEntry` function by writing down "
"the types of each of its major subexpressions. For example, the type of the "
"`head` function as used is specialized to `AddressBook -> Maybe "
"Entry`. _Note_: There is no test for this exercise."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter3.md:781
#, markdown-text
msgid ""
"(Medium) Write a function `findEntryByStreet :: String -> AddressBook -> "
"Maybe Entry` which looks up an `Entry` given a street address. _Hint_ "
"reusing the existing code in `findEntry`. Test your function in PSCi and by "
"running `spago test`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter3.md:781
#, markdown-text
msgid ""
"(Medium) Rewrite `findEntryByStreet` to replace `filterEntry` with the "
"composition (using `<<<` or `>>>`) of: a property accessor (using the `_.` "
"notation); and a function that tests whether its given string argument is "
"equal to the given street address."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter3.md:781
#, markdown-text
msgid ""
"(Medium) Write a function `isInBook` that tests whether a name appears in a "
"`AddressBook`, returning a Boolean value. _Hint_: Use PSCi to find the type "
"of the `Data.List.null` function, which tests whether a list is empty or "
"not."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter3.md:781
#, markdown-text
msgid ""
"(Difficult) Write a function `removeDuplicates` which removes \"duplicate\" "
"address book entries. We'll consider entries duplicated if they share the "
"same first and last names, while ignoring `address` fields. _Hint_: Use PSCi "
"to find the type of the `Data.List.nubByEq` function, which removes "
"duplicate elements from a list based on an equality predicate. Note that the "
"first element in each set of duplicates (closest to the list head) is the "
"one that is kept."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:785
#, markdown-text
msgid ""
"In this chapter, we covered several new functional programming concepts and "
"learned how to:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:793
#, markdown-text
msgid "Use the interactive mode PSCi to experiment with functions and test ideas."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:793
#, markdown-text
msgid "Use types as both a correctness tool and an implementation tool."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:793
#, markdown-text
msgid "Use curried functions to represent functions of multiple arguments."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:793
#, markdown-text
msgid "Create programs from smaller components by composition."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:793
#, markdown-text
msgid "Structure code neatly using `where` expressions."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:793
#, markdown-text
msgid "Avoid null values by using the `Maybe` type."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter3.md:793
#, markdown-text
msgid ""
"Use techniques like eta conversion and function composition to refactor code "
"into a clear specification."
msgstr ""

#. type: Plain text
#: ../text/chapter3.md:794
#, markdown-text
msgid "In the following chapters, we'll build on these ideas."
msgstr ""

#. type: Title #
#: ../text/chapter4.md:1
#, markdown-text, no-wrap
msgid "Pattern Matching"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:4 ../text/chapter5.md:4
#, markdown-text, no-wrap
msgid ""
"> Temporary note: If you're working on this chapter, beware that chapters 4 "
"and 5 were swapped in November 2023.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:8
#, markdown-text
msgid ""
"This chapter will introduce two new concepts: algebraic data types and "
"pattern matching. We will also briefly cover an interesting feature of the "
"PureScript type system: row polymorphism."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:10
#, markdown-text
msgid ""
"Pattern matching is a common technique in functional programming and allows "
"the developer to write compact functions, which express potentially complex "
"ideas by breaking their implementation down into multiple cases."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:12
#, markdown-text
msgid ""
"Algebraic data types are a feature of the PureScript type system, which "
"enables a similar level of expressiveness in the language of types – they "
"are closely related to pattern matching."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:14
#, markdown-text
msgid ""
"The chapter's goal will be to write a library to describe and manipulate "
"simple vector graphics using algebraic types and pattern matching."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:18
#, markdown-text
msgid ""
"The source code for this chapter is defined in the file "
"`src/Data/Picture.purs`."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:20
#, markdown-text
msgid ""
"The `Data.Picture` module defines a data type `Shape` for simple shapes and "
"a type `Picture` for collections of shapes, along with functions for working "
"with those types."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:22
#, markdown-text
msgid ""
"The module imports the `Data.Foldable` module, which provides functions for "
"folding data structures:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:23
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/Data/Picture.purs:module_picture}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:28
#, markdown-text
msgid ""
"The `Data.Picture` module also imports the `Number` module, but this time "
"using the `as` keyword:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:29
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/Data/Picture.purs:picture_import_as}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:34
#, markdown-text
msgid ""
"This makes the types and functions in that module available for use, but "
"only by using the _qualified name_, like `Number.max`. This can be useful to "
"avoid overlapping imports or clarify which modules certain things are "
"imported from."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:36
#, markdown-text, no-wrap
msgid ""
"> _Note_: Using the same module name as the original module for a qualified "
"import is unnecessary  – shorter qualified names like `import Data.Number as "
"N` are possible and quite common.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:37
#, markdown-text, no-wrap
msgid "Simple Pattern Matching"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:40
#, markdown-text
msgid ""
"Let's begin by looking at an example. Here is a function that computes the "
"greatest common divisor of two integers using pattern matching:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:41
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:gcd}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:46
#, markdown-text
msgid ""
"This algorithm is called the Euclidean Algorithm. If you search for its "
"definition online, you will likely find a set of mathematical equations that "
"look like the code above. One benefit of pattern matching is that it allows "
"you to define code by cases, writing simple, declarative code that looks "
"like a mathematical function specification."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:48
#, markdown-text
msgid ""
"A function written using pattern matching works by pairing sets of "
"conditions with their results. Each line is called an _alternative_ or a "
"_case_. The expressions on the left of the equals sign are called "
"_patterns_, and each case consists of one or more patterns separated by "
"spaces. Cases describe which conditions the arguments must satisfy before "
"the expression on the right of the equals sign should be evaluated and "
"returned. Each case is tried in order, and the first case whose patterns "
"match their inputs determines the return value."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:50
#, markdown-text
msgid "For example, the `gcd` function is evaluated using the following steps:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter4.md:54
#, markdown-text
msgid ""
"The first case is tried: if the second argument is zero, the function "
"returns `n` (the first argument)."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter4.md:54
#, markdown-text
msgid ""
"If not, the second case is tried: if the first argument is zero, the "
"function returns `m` (the second argument)."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter4.md:54
#, markdown-text
msgid ""
"Otherwise, the function evaluates and returns the expression in the last "
"line."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:56
#, markdown-text
msgid ""
"Note that patterns can bind values to names – each line in the example binds "
"one or both of the names `n` and `m` to the input values. As we learn about "
"different patterns, we will see that different patterns correspond to "
"different ways to choose names from the input arguments."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:57
#, markdown-text, no-wrap
msgid "Simple Patterns"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:60
#, markdown-text
msgid "The example code above demonstrates two types of patterns:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter4.md:63
#, markdown-text
msgid ""
"Integer literals patterns, which match something of type `Int`, only if the "
"value matches exactly."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter4.md:63
#, markdown-text
msgid "Variable patterns, which bind their argument to a name"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:65
#, markdown-text
msgid "There are other types of simple patterns:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter4.md:68
#, markdown-text
msgid "`Number`, `String`, `Char`, and `Boolean` literals"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter4.md:68
#, markdown-text
msgid ""
"Wildcard patterns, indicated with an underscore (`_`), match any argument "
"and do not bind any names."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:70
#, markdown-text
msgid "Here are two more examples that demonstrate using these simple patterns:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:71
#, no-wrap
msgid ""
"{{#include ../exercises/chapter4/src/ChapterExamples.purs:fromString}}\n"
"\n"
"{{#include ../exercises/chapter4/src/ChapterExamples.purs:toString}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:78
#, markdown-text
msgid "Try these functions in PSCi."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:79 ../text/chapter5.md:324
#, markdown-text, no-wrap
msgid "Guards"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:82
#, markdown-text, no-wrap
msgid ""
"In the Euclidean algorithm example, we used an `if .. then .. else` "
"expression to switch between the two alternatives when `m > n` and `m <= "
"n`. Another option, in this case, would be to use a _guard_.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:84
#, markdown-text
msgid ""
"A guard is a boolean-valued expression that must be satisfied in addition to "
"the constraints imposed by the patterns. Here is the Euclidean algorithm "
"rewritten to use a guard:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:85
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:gcdV2}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:90
#, markdown-text
msgid ""
"In this case, the third line uses a guard to impose the extra condition that "
"the first argument is strictly larger than the second. The guard in the "
"final line uses the expression `otherwise`, which might seem like a keyword "
"but is, in fact, just a regular binding in `Prelude`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:91
#, no-wrap
msgid ""
"> :type otherwise\n"
"Boolean\n"
"\n"
"> otherwise\n"
"true\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:100
#, markdown-text
msgid ""
"This example demonstrates that guards appear on the left of the equals "
"symbol, separated from the list of patterns by a pipe character (`|`)."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:106
#, markdown-text
msgid ""
"(Easy) Write the `factorial` function using pattern matching. _Hint_: "
"Consider the two corner cases of zero and non-zero inputs. _Note_: This is a "
"repeat of an example from the previous chapter, but see if you can rewrite "
"it here on your own."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:106
#, markdown-text
msgid ""
"(Medium) Write a function `binomial` which finds the coefficient of the "
"\\\\( x ^ k \\\\)th term in the polynomial expansion of \\\\( ( 1 + x ) ^ n "
"\\\\). This is the same as the number of ways to choose a subset of \\\\( k "
"\\\\) elements from a set of \\\\( n \\\\) elements. Use the formula \\\\( "
"n! \\\\: / \\\\: k! \\\\, (n - k)! \\\\), where \\\\( ! \\\\) is the "
"factorial function written earlier. _Hint_: Use pattern matching to handle "
"corner cases. If it takes a long time to complete or crashes with an error "
"about the call stack, try adding more corner cases."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:106
#, markdown-text
msgid ""
"(Medium) Write a function `pascal` which uses [_Pascal`s "
"Rule_](https://en.wikipedia.org/wiki/Pascal%27s_rule) for computing the same "
"binomial coefficients as the previous exercise."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:107
#, markdown-text, no-wrap
msgid "Array Patterns"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:110
#, markdown-text
msgid ""
"_Array literal patterns_ provide a way to match arrays of a fixed "
"length. For example, suppose we want to write a function `isEmpty` which "
"identifies empty arrays. We could do this by using an empty array pattern "
"(`[]`) in the first alternative:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:111
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:isEmpty}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:116
#, markdown-text
msgid ""
"Here is another function that matches arrays of length five, binding each of "
"its five elements differently:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:117
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:takeFive}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:122
#, markdown-text
msgid ""
"The first pattern only matches arrays with five elements, whose first and "
"second elements are 0 and 1, respectively. In that case, the function "
"returns the product of the third and fourth elements. In every other case, "
"the function returns zero. For example, in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:123
#, no-wrap
msgid ""
"> :paste\n"
"… takeFive [0, 1, a, b, _] = a * b\n"
"… takeFive _ = 0\n"
"… ^D\n"
"\n"
"> takeFive [0, 1, 2, 3, 4]\n"
"6\n"
"\n"
"> takeFive [1, 2, 3, 4, 5]\n"
"0\n"
"\n"
"> takeFive []\n"
"0\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:140
#, markdown-text
msgid ""
"Array literal patterns allow us to match arrays of a fixed length. Still, "
"PureScript does _not_ provide any means of matching arrays of an unspecified "
"length since destructuring immutable arrays in these sorts of ways can lead "
"to poor performance. If you need a data structure that supports this sort of "
"matching, the recommended approach is to use `Data.List`. Other data "
"structures exist which provide improved asymptotic performance for different "
"operations."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:141
#, markdown-text, no-wrap
msgid "Record Patterns and Row Polymorphism"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:144
#, markdown-text
msgid "_Record patterns_ are used to match – you guessed it – records."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:146
#, markdown-text
msgid ""
"Record patterns look just like record literals, but instead of values on the "
"right of the colon, we specify a binder for each field."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:148
#, markdown-text
msgid ""
"For example, this pattern matches any record which contains fields called "
"`first` and `last`, and binds their values to the names `x` and `y`, "
"respectively:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:149
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:showPerson}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:154
#, markdown-text
msgid ""
"Record patterns provide a good example of an interesting feature of the "
"PureScript type system: _row polymorphism_. Suppose we had defined "
"`showPerson` without a type signature above. What would its inferred type "
"have been? Interestingly, it is not the same as the type we gave:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:155
#, no-wrap
msgid ""
"> showPerson { first: x, last: y } = y <> \", \" <> x\n"
"\n"
"> :type showPerson\n"
"forall (r :: Row Type). { first :: String, last :: String | r } -> String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:163
#, markdown-text
msgid ""
"What is the type variable `r` here? Well, if we try `showPerson` in PSCi, we "
"see something interesting:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:164
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\", last: \"Freeman\" }\n"
"\"Freeman, Phil\"\n"
"\n"
"> showPerson { first: \"Phil\", last: \"Freeman\", location: \"Los Angeles\" "
"}\n"
"\"Freeman, Phil\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:173
#, markdown-text
msgid ""
"We can append additional fields to the record, and the `showPerson` function "
"will still work. As long as the record contains the `first` and `last` "
"fields of type `String`, the function application is well-typed. However, it "
"is _not_ valid to call `showPerson` with too _few_ fields:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:174
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\" }\n"
"\n"
"Type of expression lacks required label \"last\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:181
#, markdown-text
msgid ""
"We can read the new type signature of `showPerson` as \"takes any record "
"with `first` and `last` fields which are `Strings` _and any other fields_, "
"and returns a `String`\". This function is polymorphic in the _row_ `r` of "
"record fields, hence the name _row polymorphism_.  Note that this behavior "
"is different than that of the original `showPerson`. Without the row "
"variable `r`, `showPerson` only accepts records with _exactly_ a `first` and "
"`last` field and no others."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:183
#, markdown-text
msgid "Note that we could have also written"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:184
#, no-wrap
msgid "> showPerson p = p.last <> \", \" <> p.first\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:189
#, markdown-text
msgid "And PSCi would have inferred the same type."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:190
#, markdown-text, no-wrap
msgid "Record Puns"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:193
#, markdown-text
msgid ""
"Recall that the `showPerson` function matches a record inside its argument, "
"binding the `first` and `last` fields to values named `x` and `y`. We could "
"alternatively reuse the field names themselves and simplify this sort of "
"pattern match as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:194
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:showPersonV2}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:199
#, markdown-text
msgid ""
"Here, we only specify the names of the fields, and we do not need to specify "
"the names of the values we want to introduce. This is called a _record pun_."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:201
#, markdown-text
msgid ""
"It is also possible to use record puns to _construct_ records. For example, "
"if we have values named `first` and `last` in scope, we can construct a "
"person record using `{ first, last }`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:202
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:unknownPerson}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:207
#, markdown-text
msgid "This may improve the readability of code in some circumstances."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:208
#, markdown-text, no-wrap
msgid "Nested Patterns"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:211
#, markdown-text
msgid ""
"Array patterns and record patterns both combine smaller patterns to build "
"larger patterns. For the most part, the examples above have only used simple "
"patterns inside array patterns and record patterns. Still, it is important "
"to note that patterns can be arbitrarily _nested_, which allows functions to "
"be defined using conditions on potentially complex data types."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:213
#, markdown-text
msgid "For example, this code combines two record patterns:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:214
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:livesInLA}}\n"
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:218
#, markdown-text, no-wrap
msgid "Named Patterns"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:221
#, markdown-text
msgid ""
"Patterns can be _named_ to bring additional names into scope when using "
"nested patterns. Any pattern can be named by using the `@` symbol."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:223
#, markdown-text
msgid ""
"For example, this function sorts two-element arrays, naming the two "
"elements, but also naming the array itself:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:224
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:sortPair}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:229
#, markdown-text
msgid ""
"This way, we save ourselves from allocating a new array if the pair is "
"already sorted. Note that if the input array does not contain _exactly_ two "
"elements, then this function returns it unchanged, even if it's unsorted."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:235
#, markdown-text
msgid ""
"(Easy) Write a function `sameCity` which uses record patterns to test "
"whether two `Person` records belong to the same city."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:235
#, markdown-text
msgid ""
"(Medium) What is the most general type of the `sameCity` function, "
"considering row polymorphism? What about the `livesInLA` function defined "
"above? _Note_: There is no test for this exercise."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:235
#, markdown-text
msgid ""
"(Medium) Write a function `fromSingleton` that uses an array literal pattern "
"to extract the sole member of a singleton array. If the array is not a "
"singleton, your function should return a provided default value. Your "
"function should have type `forall a. a -> Array a -> a`"
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:236
#, markdown-text, no-wrap
msgid "Case Expressions"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:239
#, markdown-text
msgid ""
"Patterns do not only appear in top-level function declarations. It is "
"possible to use patterns to match on an intermediate value in a computation "
"using a `case` expression. Case expressions provide a similar type of "
"utility to anonymous functions: it is not always desirable to give a name to "
"a function, and a `case` expression allows us to avoid naming a function "
"just because we want to use a pattern."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:241
#, markdown-text
msgid ""
"Here is an example. This function computes the \"longest zero suffix\" of an "
"array (the longest suffix which sums to zero):"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:242
#, no-wrap
msgid ""
"{{#include ../exercises/chapter4/src/ChapterExamples.purs:lzsImport}}\n"
"\n"
"{{#include ../exercises/chapter4/src/ChapterExamples.purs:lzs}}\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:250
#, no-wrap
msgid ""
"> lzs [1, 2, 3, 4]\n"
"[]\n"
"\n"
"> lzs [1, -1, -2, 3]\n"
"[-1, -2, 3]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:259
#, markdown-text
msgid ""
"This function works by case analysis. If the array is empty, our only option "
"is to return an empty array. If the array is non-empty, we first use a "
"`case` expression to split it into two cases. If the sum of the array is "
"zero, we return the whole array. If not, we recurse on the tail of the "
"array."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:260
#, markdown-text, no-wrap
msgid "Pattern Match Failures and Partial Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:263
#, markdown-text
msgid ""
"If patterns in a case expression are tried in order, what happens when none "
"of the patterns in a case alternatives match their inputs? In this case, the "
"case expression will fail at runtime with a _pattern match failure_."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:265
#, markdown-text
msgid "We can see this behavior with a simple example:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:266
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter4/src/ChapterExamples.purs:unsafePartialImport}}\n"
"\n"
"{{#include "
"../exercises/chapter4/src/ChapterExamples.purs:partialFunction}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:273
#, markdown-text
msgid ""
"This function contains only a single case, which only matches a single "
"input, `true`. If we compile this file and test in PSCi with any other "
"argument, we will see an error at runtime:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:274
#, no-wrap
msgid ""
"> partialFunction false\n"
"\n"
"Failed pattern match\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:281
#, markdown-text
msgid ""
"Functions that return a value for any combination of inputs are called "
"_total_ functions, and functions that do not are called _partial_."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:283
#, markdown-text
msgid ""
"It is generally considered better to define total functions where "
"possible. If it is known that a function does not return a result for some "
"valid set of inputs, it is usually better to return a value capable of "
"indicating failure, such as type `Maybe a` for some `a`, using `Nothing` "
"when it cannot return a valid result. This way, the presence or absence of a "
"value can be indicated in a type-safe way."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:285
#, markdown-text
msgid ""
"The PureScript compiler will generate an error if it can detect that your "
"function is not total due to an incomplete pattern match. The "
"`unsafePartial` function can be used to silence these errors (if you are "
"sure your partial function is safe!) If we removed the call to the "
"`unsafePartial` function above, then the compiler would generate the "
"following error:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:286
#, no-wrap
msgid ""
"A case expression could not be determined to cover all inputs.\n"
"The following additional cases are required to cover all inputs:\n"
"\n"
"  false\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:294
#, markdown-text
msgid ""
"This tells us that the value `false` is not matched by any pattern. In "
"general, these warnings might include multiple unmatched cases."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:296
#, markdown-text
msgid "If we also omit the type signature above:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:297
#, no-wrap
msgid "partialFunction true = true\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:302
#, markdown-text
msgid "then PSCi infers a curious type:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:303
#, no-wrap
msgid ""
"> :type partialFunction\n"
"\n"
"Partial => Boolean -> Boolean\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:310
#, markdown-text, no-wrap
msgid ""
"We will see more types that involve the `=>` symbol later on in the book "
"(they are related to _type classes_), but for now, it suffices to observe "
"that PureScript keeps track of partial functions using the type system and "
"that we must explicitly tell the type checker when they are safe.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:312
#, markdown-text
msgid ""
"The compiler will also generate a warning in certain cases when it can "
"detect that cases are _redundant_ (that is, a case only matches values which "
"a prior case would have matched):"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:313
#, no-wrap
msgid ""
"redundantCase :: Boolean -> Boolean\n"
"redundantCase true = true\n"
"redundantCase false = false\n"
"redundantCase false = false\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:321
#, markdown-text
msgid "In this case, the last case is correctly identified as redundant:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:322
#, no-wrap
msgid ""
"A case expression contains unreachable cases:\n"
"\n"
"  false\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:329
#, markdown-text, no-wrap
msgid ""
"> _Note_: PSCi does not show warnings, so to reproduce this example, you "
"will need to save this function as a file and compile it using `spago "
"build`.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:330
#, markdown-text, no-wrap
msgid "Algebraic Data Types"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:333
#, markdown-text
msgid ""
"This section will introduce a feature of the PureScript type system called "
"_Algebraic Data Types_ (or _ADTs_), which are fundamentally related to "
"pattern matching."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:335
#, markdown-text
msgid ""
"However, we'll first consider a motivating example, which will provide the "
"basis of a solution to this chapter's problem of implementing a simple "
"vector graphics library."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:337
#, markdown-text
msgid ""
"Suppose we wanted to define a type to represent some simple shapes: lines, "
"rectangles, circles, text, etc. In an object oriented language, we would "
"probably define an interface or abstract class `Shape`, and one concrete "
"subclass for each type of shape that we wanted to be able to work with."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:339
#, markdown-text
msgid ""
"However, this approach has one major drawback: to work with `Shape`s "
"abstractly, it is necessary to identify all of the operations one might wish "
"to perform and to define them on the `Shape` interface. It becomes difficult "
"to add new operations without breaking modularity."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:341
#, markdown-text
msgid ""
"Algebraic data types provide a type-safe way to solve this problem if the "
"set of shapes is known in advance. It is possible to define new operations "
"on `Shape` in a modular way and still maintain type-safety."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:343
#, markdown-text
msgid "Here is how `Shape` might be represented as an algebraic data type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:344
#, no-wrap
msgid ""
"{{#include ../exercises/chapter4/src/Data/Picture.purs:Shape}}\n"
"\n"
"{{#include ../exercises/chapter4/src/Data/Picture.purs:Point}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:351
#, markdown-text
msgid ""
"This declaration defines `Shape` as a sum of different constructors, and for "
"each constructor identifies the included data. A `Shape` is either a "
"`Circle` that contains a center `Point` and a radius (a number), or a "
"`Rectangle`, or a `Line`, or `Text`. There are no other ways to construct a "
"value of type `Shape`."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:353
#, markdown-text
msgid ""
"An algebraic data type is introduced using the `data` keyword, followed by "
"the name of the new type and any type arguments. The type's constructors "
"(i.e., its _data constructors_) are defined after the equals symbol and "
"separated by pipe characters (`|`). The data carried by an ADT's "
"constructors doesn't have to be restricted to primitive types: constructors "
"can include records, arrays, or even other ADTs."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:355
#, markdown-text
msgid ""
"Let's see another example from PureScript's standard libraries. We saw the "
"`Maybe` type, which is used to define optional values, earlier in the "
"book. Here is its definition from the `maybe` package:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:356
#, no-wrap
msgid "data Maybe a = Nothing | Just a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:361
#, markdown-text
msgid ""
"This example demonstrates the use of a type parameter `a`. Reading the pipe "
"character as the word \"or\", its definition almost reads like English: \"a "
"value of type `Maybe a` is either `Nothing`, or `Just` a value of type "
"`a`\"."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:363
#, markdown-text
msgid ""
"Note that we don't use the syntax `forall a.` anywhere in our data "
"definition. `forall` syntax is necessary for functions but is not used when "
"defining ADTs with `data` or type aliases with `type`."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:365
#, markdown-text
msgid ""
"Data constructors can also be used to define recursive data structures. Here "
"is one more example, defining a data type of singly-linked lists of elements "
"of type `a`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:366
#, no-wrap
msgid "data List a = Nil | Cons a (List a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:371
#, markdown-text
msgid ""
"This example is taken from the `lists` package. Here, the `Nil` constructor "
"represents an empty list, and `Cons` is used to create non-empty lists from "
"a head element and a tail. Notice how the tail is defined using the data "
"type `List a`, making this a recursive data type."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:372
#, markdown-text, no-wrap
msgid "Using ADTs"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:375
#, markdown-text
msgid ""
"It is simple enough to use the constructors of an algebraic data type to "
"construct a value: simply apply them like functions, providing arguments "
"corresponding to the data included with the appropriate constructor."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:377
#, markdown-text
msgid ""
"For example, the `Line` constructor defined above required two `Point`s, so "
"to construct a `Shape` using the `Line` constructor, we have to provide two "
"arguments of type `Point`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:378
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/Data/Picture.purs:exampleLine}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:383
#, markdown-text
msgid ""
"So, constructing values of algebraic data types is simple, but how do we use "
"them? This is where the important connection with pattern matching appears: "
"the only way to consume a value of an algebraic data type is to use a "
"pattern to match its constructor."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:385
#, markdown-text
msgid ""
"Let's see an example. Suppose we want to convert a `Shape` into a "
"`String`. We have to use pattern matching to discover which constructor was "
"used to construct the `Shape`. We can do this as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:386
#, no-wrap
msgid ""
"{{#include ../exercises/chapter4/src/Data/Picture.purs:showShape}}\n"
"\n"
"{{#include ../exercises/chapter4/src/Data/Picture.purs:showPoint}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:393
#, markdown-text
msgid ""
"Each constructor can be used as a pattern, and the arguments to the "
"constructor can themselves be bound using patterns of their own. Consider "
"the first case of `showShape`: if the `Shape` matches the `Circle` "
"constructor, then we bring the arguments of `Circle` (center and radius) "
"into scope using two variable patterns, `c` and `r`. The other cases are "
"similar."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:399
#, markdown-text
msgid ""
"(Easy) Write a function `circleAtOrigin` which constructs a `Circle` (of "
"type `Shape`) centered at the origin with a radius `10.0`."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:399
#, markdown-text
msgid ""
"(Medium) Write a function `doubleScaleAndCenter` that scales the size of a "
"`Shape` by a factor of `2.0` and centers it at the origin."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:399
#, markdown-text
msgid ""
"(Medium) Write a function `shapeText` which extracts the text from a "
"`Shape`. It should return `Maybe String`, and use the `Nothing` constructor "
"if the input is not constructed using `Text`."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:400
#, markdown-text, no-wrap
msgid "Newtypes"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:403
#, markdown-text
msgid ""
"There is a special case of algebraic data types, called _newtypes_. Newtypes "
"are introduced using the `newtype` keyword instead of the `data` keyword."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:405
#, markdown-text
msgid ""
"Newtypes must define _exactly one_ constructor, and that constructor must "
"take _exactly one_ argument. That is, a newtype gives a new name to an "
"existing type. In fact, the values of a newtype have the same runtime "
"representation as the underlying type, so there is no runtime performance "
"overhead. They are, however, distinct from the point of view of the type "
"system. This gives an extra layer of type safety."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:407
#, markdown-text
msgid ""
"As an example, we might want to define newtypes as type-level aliases for "
"`Number`, to ascribe units like volts, amps, and ohms:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:408
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter4/src/ChapterExamples.purs:electricalUnits}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:413
#, markdown-text
msgid "Then we define functions and values using these types:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:414
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter4/src/ChapterExamples.purs:calculateCurrent}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:419
#, markdown-text
msgid ""
"This prevents us from making silly mistakes, such as attempting to calculate "
"the current produced by _two_ lightbulbs _without_ a voltage source."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:420
#, no-wrap
msgid ""
"current :: Amp\n"
"current = calculateCurrent lightbulb lightbulb\n"
"{-\n"
"TypesDoNotUnify:\n"
"  current = calculateCurrent lightbulb lightbulb\n"
"                             ^^^^^^^^^\n"
"  Could not match type\n"
"    Ohm\n"
"  with type\n"
"    Volt\n"
"-}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:435
#, markdown-text
msgid ""
"If we instead just used `Number` without `newtype`, then the compiler can't "
"help us catch this mistake:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:436
#, no-wrap
msgid ""
"-- This also compiles, but is not as type safe.\n"
"calculateCurrent :: Number -> Number -> Number\n"
"calculateCurrent v r = v / r\n"
"\n"
"battery :: Number\n"
"battery = 1.5\n"
"\n"
"lightbulb :: Number\n"
"lightbulb = 500.0\n"
"\n"
"current :: Number\n"
"current = calculateCurrent lightbulb lightbulb -- uncaught mistake\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:452
#, markdown-text
msgid ""
"Note that while a newtype can only have a single constructor, and the "
"constructor must be of a single value, a newtype _can_ take any number of "
"type variables. For example, the following newtype would be a valid "
"definition (`err` and `a` are the type variables, and the `CouldError` "
"constructor expects a _single_ value of type `Either err a`):"
msgstr ""

#. type: Fenced code block (Haskell)
#: ../text/chapter4.md:453
#, no-wrap
msgid "newtype CouldError err a = CouldError (Either err a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:458
#, markdown-text
msgid ""
"Also, note that the constructor of a newtype often has the same name as the "
"newtype itself, but this is not a requirement. For example, unique names are "
"also valid:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:459
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/ChapterExamples.purs:Coulomb}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:464
#, markdown-text
msgid ""
"In this case, `Coulomb` is the _type constructor_ (of zero arguments), and "
"`MakeCoulomb` is the _data constructor_. These constructors live in "
"different namespaces, even when the names are identical, such as with the "
"`Volt` example. This is true for all ADTs. Note that although the type "
"constructor and data constructor can have different names, in practice, it "
"is idiomatic for them to share the same name. This is the case with `Amp` "
"and `Volt` types above."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:466
#, markdown-text
msgid ""
"Another application of newtypes is to attach different _behavior_ to an "
"existing type without changing its representation at runtime. We cover that "
"use case in the next chapter when we discuss _type classes_."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:470
#, markdown-text
msgid ""
"(Easy) Define `Watt` as a `newtype` of `Number`. Then define a "
"`calculateWattage` function using this new `Watt` type and the above "
"definitions `Amp` and `Volt`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:471
#, no-wrap
msgid "calculateWattage :: Amp -> Volt -> Watt\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:476
#, markdown-text
msgid ""
"A wattage in `Watt`s can be calculated as the product of a given current in "
"`Amp`s and a given voltage in `Volt`s."
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:477
#, markdown-text, no-wrap
msgid "A Library for Vector Graphics"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:480
#, markdown-text
msgid ""
"Let's use the data types we have defined above to create a simple library "
"for using vector graphics."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:482
#, markdown-text
msgid "Define a type synonym for a `Picture` – just an array of `Shape`s:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:483
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/Data/Picture.purs:Picture}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:488
#, markdown-text
msgid ""
"For debugging purposes, we'll want to be able to turn a `Picture` into "
"something readable. The `showPicture` function lets us do that:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:489
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/Data/Picture.purs:showPicture}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:494
#, markdown-text
msgid ""
"Let's try it out. Compile your module with `spago build` and open PSCi with "
"`spago repl`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter4.md:495
#, no-wrap
msgid ""
"$ spago build\n"
"$ spago repl\n"
"\n"
"> import Data.Picture\n"
"\n"
"> showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]\n"
"\n"
"[\"Line [start: (0.0, 0.0), end: (1.0, 1.0)]\"]\n"
msgstr ""

#. type: Title ##
#: ../text/chapter4.md:506
#, markdown-text, no-wrap
msgid "Computing Bounding Rectangles"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:509
#, markdown-text
msgid ""
"The example code for this module contains a function `bounds` which computes "
"the smallest bounding rectangle for a `Picture`."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:511
#, markdown-text
msgid "The `Bounds` type defines a bounding rectangle."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:512
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/Data/Picture.purs:Bounds}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:517
#, markdown-text
msgid ""
"`bounds` uses the `foldl` function from `Data.Foldable` to traverse the "
"array of `Shapes` in a `Picture`, and accumulate the smallest bounding "
"rectangle:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter4.md:518
#, no-wrap
msgid "{{#include ../exercises/chapter4/src/Data/Picture.purs:bounds}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:523
#, markdown-text
msgid ""
"In the base case, we need to find the smallest bounding rectangle of an "
"empty `Picture`, and the empty bounding rectangle defined by `emptyBounds` "
"suffices."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:525
#, markdown-text
msgid ""
"The accumulating function `combine` is defined in a `where` block. `combine` "
"takes a bounding rectangle computed from `foldl`'s recursive call, and the "
"next `Shape` in the array, and uses the `union` function to compute the "
"union of the two bounding rectangles. The `shapeBounds` function computes "
"the bounds of a single shape using pattern matching."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:530
#, markdown-text
msgid ""
"(Medium) Extend the vector graphics library with a new operation `area` that "
"computes the area of a `Shape`. For the purpose of this exercise, the area "
"of a line or a piece of text is assumed to be zero."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter4.md:530
#, markdown-text
msgid ""
"(Difficult) Extend the `Shape` type with a new data constructor `Clipped`, "
"which clips another `Picture` to a rectangle. Extend the `shapeBounds` "
"function to compute the bounds of a clipped picture. Note that this makes "
"`Shape` into a recursive data type. _Hint_: The compiler will walk you "
"through extending other functions as required."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:534
#, markdown-text
msgid ""
"In this chapter, we covered pattern matching, a basic but powerful technique "
"from functional programming. We saw how to use simple patterns as well as "
"array and record patterns to match parts of deep data structures."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:536
#, markdown-text
msgid ""
"This chapter also introduced algebraic data types, which are closely related "
"to pattern matching. We saw how algebraic data types allow concise "
"descriptions of data structures and provide a modular way to extend data "
"types with new operations."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:538
#, markdown-text
msgid ""
"Finally, we covered _row polymorphism_, a powerful type of abstraction that "
"allows many idiomatic JavaScript functions to be given a type."
msgstr ""

#. type: Plain text
#: ../text/chapter4.md:539
#, markdown-text
msgid ""
"In the rest of the book, we will use ADTs and pattern matching extensively, "
"so it will pay dividends to become familiar with them now. Try creating your "
"own algebraic data types and writing functions to consume them using pattern "
"matching."
msgstr ""

#. type: Title #
#: ../text/chapter5.md:1
#, markdown-text, no-wrap
msgid "Recursion, Maps, And Folds"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:8
#, markdown-text
msgid ""
"In this chapter, we will look at how recursive functions can be used to "
"structure algorithms. Recursion is a basic technique used in functional "
"programming, which we will use throughout this book."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:10
#, markdown-text
msgid ""
"We will also cover some standard functions from PureScript's standard "
"libraries. We will `map`, `fold`, and some useful special cases, like "
"`filter` and `concatMap`."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:12
#, markdown-text
msgid ""
"The motivating example for this chapter is a library of functions for "
"working with a virtual filesystem. We will apply the techniques learned in "
"this chapter to write functions that compute properties of the files "
"represented by a model of a filesystem."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:16
#, markdown-text
msgid ""
"The source code for this chapter is contained in `src/Data/Path.purs` and "
"`test/Examples.purs`. The `Data.Path` module contains a model of a virtual "
"filesystem. You do not need to modify the contents of this module. Implement "
"your solutions to the exercises in the `Test.MySolutions` module. Enable "
"accompanying tests in the `Test.Main` module as you complete each exercise "
"and check your work by running `spago test`."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:18 ../text/chapter6.md:18
#, markdown-text
msgid "The project has the following dependencies:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:24
#, markdown-text
msgid "`maybe`, which defines the `Maybe` type constructor"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:24
#, markdown-text
msgid "`arrays`, which defines functions for working with arrays"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:24
#, markdown-text
msgid "`strings`, which defines functions for working with JavaScript strings"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:24
#, markdown-text
msgid ""
"`foldable-traversable`, which defines functions for folding arrays and other "
"data structures"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:24
#, markdown-text
msgid "`console`, which defines functions for printing to the console"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:28
#, markdown-text
msgid ""
"Recursion is an important technique in programming in general, but "
"particularly common in pure functional programming, because, as we will see "
"in this chapter, recursion helps to reduce the mutable state in our "
"programs."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:30
#, markdown-text
msgid ""
"Recursion is closely linked to the _divide and conquer_ strategy: to solve a "
"problem on certain inputs, we can break down the inputs into smaller parts, "
"solve the problem on those parts, and then assemble a solution from the "
"partial solutions."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:32
#, markdown-text
msgid "Let's see some simple examples of recursion in PureScript."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:34
#, markdown-text
msgid "Here is the usual _factorial function_ example:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:35
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:factorial}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:40
#, markdown-text
msgid ""
"Here, we can see how the factorial function is computed by reducing the "
"problem to a subproblem – computing the factorial of a smaller integer. When "
"we reach zero, the answer is immediate."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:42
#, markdown-text
msgid "Here is another common example that computes the _Fibonacci function_:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:43
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:fib}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:48
#, markdown-text
msgid ""
"Again, this problem is solved by considering the solutions to "
"subproblems. In this case, there are two subproblems, corresponding to the "
"expressions `fib (n - 1)` and `fib (n - 2)`. When these two subproblems are "
"solved, we assemble the result by adding the partial results."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:50
#, markdown-text, no-wrap
msgid ""
"> Note that, while the above examples of `factorial` and `fib` work as "
"intended, a more idiomatic implementation would use pattern matching instead "
"of `if`/`then`/`else`. Pattern-matching techniques are discussed in a later "
"chapter.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:51
#, markdown-text, no-wrap
msgid "Recursion on Arrays"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:54
#, markdown-text
msgid ""
"We are not limited to defining recursive functions over the `Int` type! We "
"will see recursive functions defined over a wide array of data types when we "
"cover _pattern matching_ later in the book, but for now, we will restrict "
"ourselves to numbers and arrays."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:56
#, markdown-text
msgid ""
"Just as we branch based on whether the input is non-zero, in the array case, "
"we will branch based on whether the input is non-empty. Consider this "
"function, which computes the length of an array using recursion:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:57
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Data.Array (null, tail)\n"
"import Data.Maybe (fromMaybe)\n"
"\n"
"{{#include ../exercises/chapter5/test/Examples.purs:length}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:67
#, markdown-text
msgid ""
"In this function, we use an `if .. then .. else` expression to branch based "
"on the emptiness of the array. The `null` function returns `true` on an "
"empty array. Empty arrays have a length of zero, and a non-empty array has a "
"length that is one more than the length of its tail."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:69
#, markdown-text
msgid ""
"The `tail` function returns a `Maybe` wrapping the given array without its "
"first element. If the array is empty (i.e., it doesn't have a tail), "
"`Nothing` is returned. The `fromMaybe` function takes a default value and a "
"`Maybe` value. If the latter is `Nothing` it returns the default; in the "
"other case, it returns the value wrapped by `Just`."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:71
#, markdown-text
msgid ""
"This example is a very impractical way to find the length of an array in "
"JavaScript, but it should provide enough help to allow you to complete the "
"following exercises:"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:76
#, markdown-text
msgid ""
"(Easy) Write a recursive function `isEven` that returns `true` if and only "
"if its input is an even integer."
msgstr ""

#. type: Bullet: ' 2. '
#: ../text/chapter5.md:76
#, markdown-text
msgid ""
"(Medium) Write a recursive function `countEven` that counts the number of "
"even integers in an array. _Hint_: the function `head` (also available in "
"`Data.Array`) can be used to find the first element in a non-empty array."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:77
#, markdown-text, no-wrap
msgid "Maps"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:80
#, markdown-text
msgid ""
"The `map` function is an example of a recursive function on arrays. It is "
"used to transform the elements of an array by applying a function to each "
"element in turn. Therefore, it changes the _contents_ of the array but "
"preserves its _shape_ (i.e., its length)."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:82
#, markdown-text
msgid ""
"When we cover _type classes_ later in the book, we will see that the `map` "
"function is an example of a more general pattern of shape-preserving "
"functions which transform a class of type constructors called _functors_."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:84
#, markdown-text
msgid "Let's try out the `map` function in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:85
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> map (\\n -> n + 1) [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:94
#, markdown-text
msgid ""
"Notice how `map` is used – we provide a function that should be \"mapped "
"over\" the array in the first argument, and the array itself in its second."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:95
#, markdown-text, no-wrap
msgid "Infix Operators"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:98
#, markdown-text
msgid ""
"The `map` function can also be written between the mapping function and the "
"array, by wrapping the function name in backticks:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:99
#, no-wrap
msgid ""
"> (\\n -> n + 1) `map` [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:105
#, markdown-text
msgid ""
"This syntax is called _infix function application_, and any function can be "
"made infix in this way. It is usually most appropriate for functions with "
"two arguments."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:107
#, markdown-text, no-wrap
msgid ""
"There is an operator which is equivalent to the `map` function when used "
"with arrays, called `<$>`.\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:108
#, no-wrap
msgid ""
"> (\\n -> n + 1) <$> [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:114
#, markdown-text
msgid "Let's look at the type of `map`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:115
#, no-wrap
msgid ""
"> :type map\n"
"forall (f :: Type -> Type) (a :: Type) (b :: Type). Functor f => (a -> b) -> "
"f a -> f b\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:121
#, markdown-text
msgid ""
"The type of `map` is actually more general than we need in this chapter. For "
"our purposes, we can treat `map` as if it had the following less general "
"type:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:122
#, no-wrap
msgid "forall (a :: Type) (b :: Type). (a -> b) -> Array a -> Array b\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:127
#, markdown-text, no-wrap
msgid ""
"This type says that we can choose any two types, `a` and `b`, with which to "
"apply the `map` function. `a` is the type of elements in the source array, "
"and `b` is the type of elements in the target array. In particular, there is "
"no reason why `map` has to preserve the type of the array elements. We can "
"use `map` or `<$>` to transform integers to strings, for example:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:128
#, no-wrap
msgid ""
"> show <$> [1, 2, 3, 4, 5]\n"
"\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:135
#, markdown-text, no-wrap
msgid ""
"Even though the infix operator `<$>` looks like special syntax, it is in "
"fact just an alias for a regular PureScript function. The function is simply "
"_applied_ using infix syntax. In fact, the function can be used like a "
"regular function by enclosing its name in parentheses. This means that we "
"can use the parenthesized name `(<$>)` in place of `map` on arrays:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:136
#, no-wrap
msgid ""
"> (<$>) show [1, 2, 3, 4, 5]\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:142
#, markdown-text
msgid ""
"Infix function names are defined as _aliases_ for existing function "
"names. For example, the `Data.Array` module defines an infix operator `(..)` "
"as a synonym for the `range` function, as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:143
#, no-wrap
msgid "infix 8 range as ..\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:148
#, markdown-text
msgid "We can use this operator as follows:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:149
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> 1 .. 5\n"
"[1, 2, 3, 4, 5]\n"
"\n"
"> show <$> (1 .. 5)\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:160
#, markdown-text
msgid ""
"_Note_: Infix operators can be a great tool for defining domain-specific "
"languages with a natural syntax. However, used excessively, they can render "
"code unreadable to beginners, so it is wise to exercise caution when "
"defining any new operators."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:162
#, markdown-text, no-wrap
msgid ""
"In the example above, we parenthesized the expression `1 .. 5`, but this was "
"actually not necessary, because the `Data.Array` module assigns a higher "
"precedence level to the `..` operator than that assigned to the `<$>` "
"operator. In the example above, the precedence of the `..` operator was "
"defined as `8`, the number after the `infix` keyword. This is higher than "
"the precedence level of `<$>`, meaning that we do not need to add "
"parentheses:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:163
#, no-wrap
msgid ""
"> show <$> 1 .. 5\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:169
#, markdown-text
msgid ""
"If we wanted to assign an _associativity_ (left or right) to an infix "
"operator, we could do so with the `infixl` and `infixr` keywords instead.  "
"Using `infix` assigns no associativity, meaning that you must parenthesize "
"any expression using the same operator multiple times or using multiple "
"operators of the same precedence."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:170
#, markdown-text, no-wrap
msgid "Filtering Arrays"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:173
#, markdown-text
msgid ""
"The `Data.Array` module provides another function `filter`, which is "
"commonly used together with `map`. It provides the ability to create a new "
"array from an existing array, keeping only those elements which match a "
"predicate function."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:175
#, markdown-text
msgid ""
"For example, suppose we wanted to compute an array of all numbers between 1 "
"and 10 which were even. We could do so as follows:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:176
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> filter (\\n -> n `mod` 2 == 0) (1 .. 10)\n"
"[2,4,6,8,10]\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:191
#, markdown-text
msgid ""
"(Easy) Write a function `squared` which calculates the squares of an array "
"of numbers. _Hint_: Use the `map` or `<$>` function."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:191
#, markdown-text
msgid ""
"(Easy) Write a function `keepNonNegative` which removes the negative numbers "
"from an array of numbers. _Hint_: Use the `filter` function."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:191
#, markdown-text
msgid "(Medium)"
msgstr ""

#. type: Bullet: '    - '
#: ../text/chapter5.md:191
#, markdown-text
msgid ""
"Define an infix synonym `<$?>` for `filter`. _Note_: Infix synonyms may not "
"be defined in the REPL, but you can define it in a file."
msgstr ""

#. type: Bullet: '    - '
#: ../text/chapter5.md:191
#, markdown-text
msgid ""
"Write a `keepNonNegativeRewrite` function, which is the same as "
"`keepNonNegative`, but replaces `filter` with your new infix operator "
"`<$?>`."
msgstr ""

#. type: Bullet: '    - '
#: ../text/chapter5.md:191
#, markdown-text
msgid ""
"Experiment with the precedence level and associativity of your operator in "
"PSCi. _Note_: There are no unit tests for this step."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:192
#, markdown-text, no-wrap
msgid "Flattening Arrays"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:195
#, markdown-text
msgid ""
"Another standard function on arrays is the `concat` function, defined in "
"`Data.Array`. `concat` flattens an array of arrays into a single array:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:196
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> :type concat\n"
"forall (a :: Type). Array (Array a) -> Array a\n"
"\n"
"> concat [[1, 2, 3], [4, 5], [6]]\n"
"[1, 2, 3, 4, 5, 6]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:207
#, markdown-text
msgid ""
"There is a related function called `concatMap` which is a combination of the "
"`concat` and `map` functions. Where `map` takes a function from values to "
"values (possibly of a different type), `concatMap` takes a function from "
"values to arrays of values."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:209
#, markdown-text
msgid "Let's see it in action:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:210
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> :type concatMap\n"
"forall (a :: Type) (b :: Type). (a -> Array b) -> Array a -> Array b\n"
"\n"
"> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
"[1,1,2,4,3,9,4,16,5,25]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:221
#, markdown-text, no-wrap
msgid ""
"Here, we call `concatMap` with the function `\\n -> [n, n * n]` which sends "
"an integer to the array of two elements consisting of that integer and its "
"square. The result is an array of ten integers: the integers from 1 to 5 "
"along with their squares.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:223
#, markdown-text
msgid ""
"Note how `concatMap` concatenates its results. It calls the provided "
"function once for each element of the original array, generating an array "
"for each. Finally, it collapses all of those arrays into a single array, "
"which is its result."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:225
#, markdown-text
msgid ""
"`map`, `filter` and `concatMap` form the basis for a whole range of "
"functions over arrays called \"array comprehensions\"."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:226
#, markdown-text, no-wrap
msgid "Array Comprehensions"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:229
#, markdown-text
msgid ""
"Suppose we wanted to find the factors of a number `n`. One simple way to do "
"this would be by brute force: we could generate all pairs of numbers between "
"1 and `n`, and try multiplying them together. If the product was `n`, we "
"would have found a pair of factors of `n`."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:231
#, markdown-text
msgid ""
"We can perform this computation using array comprehension. We will do so in "
"steps, using PSCi as our interactive development environment."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:233
#, markdown-text
msgid ""
"The first step is to generate an array of pairs of numbers below `n`, which "
"we can do using `concatMap`."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:235
#, markdown-text
msgid "Let's start by mapping each number to the array `1 .. n`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:236
#, no-wrap
msgid "> pairs n = concatMap (\\i -> 1 .. n) (1 .. n)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:241
#, markdown-text
msgid "We can test our function"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:242
#, no-wrap
msgid ""
"> pairs 3\n"
"[1,2,3,1,2,3,1,2,3]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:248
#, markdown-text
msgid ""
"This is not quite what we want. Instead of just returning the second element "
"of each pair, we need to map a function over the inner copy of `1 .. n` "
"which will allow us to keep the entire pair:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:249
#, no-wrap
msgid ""
"> :paste\n"
"… pairs' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (1 .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"\n"
"> pairs' 3\n"
"[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:262
#, markdown-text
msgid ""
"This is looking better. However, we are generating too many pairs: we keep "
"both [1, 2] and [2, 1] for example. We can exclude the second case by making "
"sure that `j` only ranges from `i` to `n`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:263
#, no-wrap
msgid ""
"> :paste\n"
"… pairs'' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (i .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"> pairs'' 3\n"
"[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:275
#, markdown-text
msgid ""
"Great! Now that we have all of the pairs of potential factors, we can use "
"`filter` to choose the pairs which multiply to give `n`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:276
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> factors n = filter (\\pair -> product pair == n) (pairs'' n)\n"
"\n"
"> factors 10\n"
"[[1,10],[2,5]]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:286
#, markdown-text
msgid ""
"This code uses the `product` function from the `Data.Foldable` module in the "
"`foldable-traversable` library."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:288
#, markdown-text
msgid ""
"Excellent! We've managed to find the correct set of factor pairs without "
"duplicates."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:289
#, markdown-text, no-wrap
msgid "Do Notation"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:292
#, markdown-text
msgid ""
"However, we can improve the readability of our code considerably. `map` and "
"`concatMap` are so fundamental, that they (or rather, their generalizations "
"`map` and `bind`) form the basis of a special syntax called _do notation_."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:294
#, markdown-text, no-wrap
msgid ""
"> _Note_: Just like `map` and `concatMap` allowed us to write _array "
"comprehensions_, the more general operators `map` and `bind` allow us to "
"write so-called _monad comprehensions_. We'll see plenty more examples of "
"_monads_ later in the book, but in this chapter, we will only consider "
"arrays.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:296
#, markdown-text
msgid "We can rewrite our `factors` function using do notation as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:297
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:factors}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:302
#, markdown-text
msgid ""
"The keyword `do` introduces a block of code that uses do notation. The block "
"consists of expressions of a few types:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:306
#, markdown-text
msgid ""
"Expressions that bind elements of an array to a name. These are indicated "
"with the backwards-facing arrow `<-`, with a name on the left, and an "
"expression on the right whose type is an array."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:306
#, markdown-text
msgid ""
"Expressions that do not bind elements of the array to names. The `do` "
"_result_ is an example of this kind of expression and is illustrated in the "
"last line, `pure [i, j]`."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:306
#, markdown-text
msgid "Expressions that give names to expressions, using the `let` keyword."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:308
#, markdown-text, no-wrap
msgid ""
"This new notation hopefully makes the structure of the algorithm clearer. If "
"you mentally replace the arrow `<-` with the word \"choose\", you might read "
"it as follows: \"choose an element `i` between 1 and n, then choose an "
"element `j` between `i` and `n`, and return `[i, j]`\".\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:310
#, markdown-text
msgid ""
"In the last line, we use the `pure` function. This function can be evaluated "
"in PSCi, but we have to provide a type:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:311
#, no-wrap
msgid ""
"> pure [1, 2] :: Array (Array Int)\n"
"[[1, 2]]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:317
#, markdown-text
msgid ""
"In the case of arrays, `pure` simply constructs a singleton array. We can "
"modify our `factors` function to use this form, instead of using `pure`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:318
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:factorsV2}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:323
#, markdown-text
msgid "and the result would be the same."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:327
#, markdown-text
msgid ""
"One further change we can make to the `factors` function is to move the "
"filter inside the array comprehension. This is possible using the `guard` "
"function from the `Control.Alternative` module (from the `control` package):"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:328
#, no-wrap
msgid ""
"import Control.Alternative (guard)\n"
"\n"
"{{#include ../exercises/chapter5/test/Examples.purs:factorsV3}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:335
#, markdown-text
msgid ""
"Just like `pure`, we can apply the `guard` function in PSCi to understand "
"how it works. The type of the `guard` function is more general than we need "
"here:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:336
#, no-wrap
msgid ""
"> import Control.Alternative\n"
"\n"
"> :type guard\n"
"forall (m :: Type -> Type). Alternative m => Boolean -> m Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:350
#, markdown-text, no-wrap
msgid ""
"> The `Unit` type represents values with no computational content — the "
"absence of a concrete meaningful value.\n"
">\n"
"> We often use `Unit` \"wrapped\" in a type constructor as the return type "
"of a computation where we only care about the _effects_ of the computation "
"(or a \"shape\" of the result) and not some concrete value.\n"
">\n"
"> For example, the `main` function has the type `Effect Unit`. Main is an "
"entry point to the project — we don't call it directly.\n"
">\n"
"> We'll explain what `m` in the type signature means in Chapter 6.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:352
#, markdown-text
msgid "In our case, we can assume that PSCi reported the following type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:353
#, no-wrap
msgid "Boolean -> Array Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:358
#, markdown-text
msgid ""
"For our purposes, the following calculations tell us everything we need to "
"know about the `guard` function on arrays:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:359
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> length $ guard true\n"
"1\n"
"\n"
"> length $ guard false\n"
"0\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:370
#, markdown-text
msgid ""
"If we pass an expression to `guard` that evaluates to `true`, then it "
"returns an array with a single element. If the expression evaluates to "
"`false`, then its result is empty."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:372
#, markdown-text
msgid ""
"This means that if the guard fails, then the current branch of the array "
"comprehension will terminate early with no results. This means that a call "
"to `guard` is equivalent to using `filter` on the intermediate "
"array. Depending on the application, you might prefer to use `guard` instead "
"of a `filter`. Try the two definitions of `factors` to verify that they give "
"the same results."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:379
#, markdown-text
msgid ""
"(Easy) Write a function `isPrime`, which tests whether its integer argument "
"is prime. _Hint_: Use the `factors` function."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:379
#, markdown-text
msgid ""
"(Medium) Write a function `cartesianProduct` which uses do notation to find "
"the _cartesian product_ of two arrays, i.e., the set of all pairs of "
"elements `a`, `b`, where `a` is an element of the first array, and `b` is an "
"element of the second."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:379
#, markdown-text
msgid ""
"(Medium) Write a function `triples :: Int -> Array (Array Int)`, which takes "
"a number \\\\( n \\\\) and returns all Pythagorean triples whose components "
"(the \\\\( a \\\\), \\\\( b \\\\), and \\\\( c \\\\) values) are each less "
"than or equal to \\\\( n \\\\). A _Pythagorean triple_ is an array of "
"numbers \\\\( [ a, b, c ] \\\\) such that \\\\( a ^ 2 + b ^ 2 = c ^ 2 "
"\\\\). _Hint_: Use the `guard` function in an array comprehension."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:379
#, markdown-text
msgid ""
"(Difficult) Write a function `primeFactors` which produces the [prime "
"factorization](https://www.mathsisfun.com/prime-factorization.html) of `n`, "
"i.e., the array of prime integers whose product is `n`. _Hint_: for an "
"integer greater than 1, break the problem into two subproblems: finding the "
"first factor and the remaining factors."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:380
#, markdown-text, no-wrap
msgid "Folds"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:383
#, markdown-text
msgid ""
"Left and right folds over arrays provide another class of interesting "
"functions that can be implemented using recursion."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:385
#, markdown-text
msgid ""
"Start by importing the `Data.Foldable` module and inspecting the types of "
"the `foldl` and `foldr` functions using PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:386
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> :type foldl\n"
"forall (f :: Type -> Type) (a :: Type) (b :: Type). Foldable f => (b -> a -> "
"b) -> b -> f a -> b\n"
"\n"
"> :type foldr\n"
"forall (f :: Type -> Type) (a :: Type) (b :: Type). Foldable f => (a -> b -> "
"b) -> b -> f a -> b\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:397
#, markdown-text
msgid ""
"These types are more general than we are interested in right now. For this "
"chapter, we can simplify and assume the following (more specific) type "
"signatures:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:398
#, no-wrap
msgid ""
"-- foldl\n"
"forall a b. (b -> a -> b) -> b -> Array a -> b\n"
"\n"
"-- foldr\n"
"forall a b. (a -> b -> b) -> b -> Array a -> b\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:407
#, markdown-text
msgid ""
"In both cases, the type `a` corresponds to the type of elements of our "
"array. The type `b` can be thought of as the type of an \"accumulator\", "
"which will accumulate a result as we traverse the array."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:409
#, markdown-text
msgid ""
"The difference between the `foldl` and `foldr` functions is the direction of "
"the traversal. `foldl` folds the array \"from the left\", whereas `foldr` "
"folds the array \"from the right\"."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:411
#, markdown-text, no-wrap
msgid ""
"Let's see these functions in action. Let's use `foldl` to sum an array of "
"integers. The type `a` will be `Int`, and we can also choose the result type "
"`b` to be `Int`. We need to provide three arguments: a function `Int -> Int "
"-> Int`, which will add the next element to the accumulator, an initial "
"value for the accumulator of type `Int`, and an array of `Int`s to add. For "
"the first argument, we can use the addition operator, and the initial value "
"of the accumulator will be zero:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:412
#, no-wrap
msgid ""
"> foldl (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:418
#, markdown-text
msgid ""
"In this case, it didn't matter whether we used `foldl` or `foldr`, because "
"the result is the same, no matter what order the additions happen in:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:419
#, no-wrap
msgid ""
"> foldr (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:425
#, markdown-text
msgid ""
"Let's write an example where the choice of folding function matters to "
"illustrate the difference. Instead of the addition function, let's use "
"string concatenation to build a string:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:426
#, no-wrap
msgid ""
"> foldl (\\acc n -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"12345\"\n"
"\n"
"> foldr (\\n acc -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"54321\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:435
#, markdown-text
msgid ""
"This illustrates the difference between the two functions. The left fold "
"expression is equivalent to the following application:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:436
#, no-wrap
msgid "(((((\"\" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:441
#, markdown-text
msgid "Whereas the right fold is equivalent to this:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:442
#, no-wrap
msgid "(((((\"\" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)\n"
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:446
#, markdown-text, no-wrap
msgid "Tail Recursion"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:449
#, markdown-text
msgid ""
"Recursion is a powerful technique for specifying algorithms but comes with a "
"problem: evaluating recursive functions in JavaScript can lead to stack "
"overflow errors if our inputs are too large."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:451
#, markdown-text
msgid "It is easy to verify this problem with the following code in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:452
#, no-wrap
msgid ""
"> :paste\n"
"… f n =\n"
"…   if n == 0\n"
"…     then 0\n"
"…     else 1 + f (n - 1)\n"
"… ^D\n"
"\n"
"> f 10\n"
"10\n"
"\n"
"> f 100000\n"
"RangeError: Maximum call stack size exceeded\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:468
#, markdown-text
msgid ""
"This is a problem. If we adopt recursion as a standard technique from "
"functional programming, we need a way to deal with possibly unbounded "
"recursion."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:470
#, markdown-text
msgid ""
"PureScript provides a partial solution to this problem through _tail "
"recursion optimization_."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:472
#, markdown-text, no-wrap
msgid ""
"> _Note_: more complete solutions to the problem can be implemented in "
"libraries using so-called _trampolining_, but that is beyond the scope of "
"this chapter. The interested reader can consult the documentation for the "
"[`free`](https://pursuit.purescript.org/packages/purescript-free) and "
"[`tailrec`](https://pursuit.purescript.org/packages/purescript-tailrec) "
"packages.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:474
#, markdown-text
msgid ""
"The key observation that enables tail recursion optimization: a recursive "
"call in _tail position_ to a function can be replaced with a _jump_, which "
"does not allocate a stack frame. A call is in _tail position_ when it is the "
"last call made before a function returns. This is why we observed a stack "
"overflow in the example – the recursive call to `f` was _not_ in tail "
"position."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:476
#, markdown-text
msgid ""
"In practice, the PureScript compiler does not replace the recursive call "
"with a jump, but rather replaces the entire recursive function with a _while "
"loop_."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:478
#, markdown-text
msgid ""
"Here is an example of a recursive function with all recursive calls in tail "
"position:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:479
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:factorialTailRec}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:484
#, markdown-text
msgid ""
"Notice that the recursive call to `factorialTailRec` is the last thing in "
"this function – it is in tail position."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:485
#, markdown-text, no-wrap
msgid "Accumulators"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:488
#, markdown-text
msgid ""
"One common way to turn a not tail recursive function into a tail recursive "
"is to use an _accumulator parameter_. An accumulator parameter is an "
"additional parameter added to a function that _accumulates_ a return value, "
"as opposed to using the return value to accumulate the result."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:490
#, markdown-text
msgid ""
"For example, consider again the `length` function presented at the beginning "
"of the chapter:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:491
#, no-wrap
msgid ""
"length :: forall a. Array a -> Int\n"
"length arr =\n"
"  if null arr\n"
"    then 0\n"
"    else 1 + (length $ fromMaybe [] $ tail arr)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:500
#, markdown-text
msgid ""
"This implementation is not tail recursive, so the generated JavaScript will "
"cause a stack overflow when executed on a large input array. However, we can "
"make it tail recursive, by introducing a second function argument to "
"accumulate the result instead:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:501
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:lengthTailRec}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:506
#, markdown-text
msgid ""
"In this case, we delegate to the helper function `length'`, which is tail "
"recursive – its only recursive call is in the last case, in tail "
"position. This means that the generated code will be a _while loop_ and not "
"blow the stack for large inputs."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:508
#, markdown-text
msgid ""
"To understand the implementation of `lengthTailRec`, note that the helper "
"function `length'` essentially uses the accumulator parameter to maintain an "
"additional piece of state – the partial result. It starts at 0 and grows by "
"adding 1 for every element in the input array."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:510
#, markdown-text
msgid ""
"Note also that while we might think of the accumulator as a \"state\", there "
"is no direct mutation."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:511
#, markdown-text, no-wrap
msgid "Prefer Folds to Explicit Recursion"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:514
#, markdown-text
msgid ""
"If we can write our recursive functions using tail recursion, we can benefit "
"from tail recursion optimization, so it becomes tempting to try to write all "
"of our functions in this form. However, it is often easy to forget that many "
"functions can be written directly as a fold over an array or similar data "
"structure. Writing algorithms directly in terms of combinators such as `map` "
"and `fold` has the added advantage of code simplicity – these combinators "
"are well-understood, and as such, communicate the _intent_ of the algorithm "
"much better than explicit recursion."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:516
#, markdown-text
msgid "For example, we can reverse an array using `foldr`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:517
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> :paste\n"
"… reverse :: forall a. Array a -> Array a\n"
"… reverse = foldr (\\x xs -> xs <> [x]) []\n"
"… ^D\n"
"\n"
"> reverse [1, 2, 3]\n"
"[3,2,1]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:530
#, markdown-text
msgid ""
"Writing `reverse` in terms of `foldl` will be left as an exercise for the "
"reader."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:537
#, markdown-text
msgid ""
"(Easy) Write a function `allTrue` which uses `foldl` to test whether an "
"array of boolean values are all true."
msgstr ""

#. type: Bullet: ' 2. '
#: ../text/chapter5.md:537
#, markdown-text
msgid ""
"(Medium - No Test) Characterize those arrays `xs` for which the function "
"`foldl (==) false xs` returns `true`. In other words, complete the sentence: "
"\"The function returns `true` when `xs` contains ...\""
msgstr ""

#. type: Bullet: ' 3. '
#: ../text/chapter5.md:537
#, markdown-text
msgid ""
"(Medium) Write a function `fibTailRec` which is the same as `fib` but in "
"tail recursive form. _Hint_: Use an accumulator parameter."
msgstr ""

#. type: Bullet: ' 4. '
#: ../text/chapter5.md:537
#, markdown-text
msgid "(Medium) Write `reverse` in terms of `foldl`."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:538
#, markdown-text, no-wrap
msgid "A Virtual Filesystem"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:541
#, markdown-text
msgid ""
"In this section, we'll apply what we've learned, writing functions that will "
"work with a model of a filesystem. We will use maps, folds, and filters to "
"work with a predefined API."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:543
#, markdown-text
msgid "The `Data.Path` module defines an API for a virtual filesystem as follows:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:550
#, markdown-text
msgid "There is a type `Path` which represents a path in the filesystem."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:550
#, markdown-text
msgid "There is a path `root` which represents the root directory."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:550
#, markdown-text
msgid "The `ls` function enumerates the files in a directory."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:550
#, markdown-text
msgid "The `filename` function returns the file name for a `Path`."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:550
#, markdown-text
msgid "The `size` function returns the file size for a `Path` representing a file."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter5.md:550
#, markdown-text
msgid "The `isDirectory` function tests whether a `Path` is a file or a directory."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:552
#, markdown-text
msgid "In terms of types, we have the following type definitions:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:553
#, no-wrap
msgid ""
"root :: Path\n"
"\n"
"ls :: Path -> Array Path\n"
"\n"
"filename :: Path -> String\n"
"\n"
"size :: Path -> Maybe Int\n"
"\n"
"isDirectory :: Path -> Boolean\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:566
#, markdown-text
msgid "We can try out the API in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:567
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Path\n"
"\n"
"> root\n"
"/\n"
"\n"
"> isDirectory root\n"
"true\n"
"\n"
"> ls root\n"
"[/bin/,/etc/,/home/]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:583
#, markdown-text
msgid ""
"The `Test.Examples` module defines functions that use the `Data.Path` "
"API. You do not need to modify the `Data.Path` module, or understand its "
"implementation. We will work entirely in the `Test.Examples` module."
msgstr ""

#. type: Title ##
#: ../text/chapter5.md:584
#, markdown-text, no-wrap
msgid "Listing All Files"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:587
#, markdown-text
msgid ""
"Let's write a function that performs a deep enumeration of all files inside "
"a directory. This function will have the following type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:588
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:allFiles_signature}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:593
#, markdown-text
msgid ""
"We can define this function by recursion. First, we can use `ls` to "
"enumerate the immediate children of the directory. For each child, we can "
"recursively apply `allFiles`, which will return an array of "
"paths. `concatMap` will allow us to apply `allFiles` and flatten the results "
"simultaneously."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:595
#, markdown-text
msgid "Finally, we use the cons operator `:` to include the current file:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:596
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter5/test/Examples.purs:allFiles_implementation}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:601
#, markdown-text, no-wrap
msgid ""
"> _Note_: the cons operator `:` has poor performance on immutable arrays, so "
"it is not generally recommended. Performance can be improved by using other "
"data structures, such as linked lists and sequences.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:603
#, markdown-text
msgid "Let's try this function in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter5.md:604
#, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.Path\n"
"\n"
"> allFiles root\n"
"\n"
"[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:614
#, markdown-text
msgid ""
"Great! Now let's see if we can write this function using an array "
"comprehension using do notation."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:616
#, markdown-text
msgid ""
"Recall that a backwards arrow corresponds to choosing an element from an "
"array. The first step is to choose an element from the immediate children of "
"the argument. Then we call the function recursively for that file. Since we "
"use do notation, there is an implicit call to `concatMap`, which "
"concatenates all of the recursive results."
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:618
#, markdown-text
msgid "Here is the new version:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter5.md:619
#, no-wrap
msgid "{{#include ../exercises/chapter5/test/Examples.purs:allFiles_2}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:624
#, markdown-text
msgid ""
"Try out the new version in PSCi – you should get the same result. I'll let "
"you decide which version you find clearer."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter5.md:629
#, markdown-text
msgid ""
"(Easy) Write a function `onlyFiles` which returns all _files_ (not "
"directories) in all subdirectories of a directory."
msgstr ""

#. type: Bullet: ' 2. '
#: ../text/chapter5.md:629
#, markdown-text
msgid ""
"(Medium) Write a function `whereIs` to search for a file by name. The "
"function should return a value of type `Maybe Path`, indicating the "
"directory containing the file, if it exists. It should behave as follows:"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:633
#, markdown-text, no-wrap
msgid ""
"     ```text\n"
"     > whereIs root \"ls\"\n"
"     Just (/bin/)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:637
#, markdown-text, no-wrap
msgid ""
"     > whereIs root \"cat\"\n"
"     Nothing\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:640
#, markdown-text, no-wrap
msgid ""
"     _Hint_: Try to write this function as an array comprehension using do "
"notation.\n"
" 3. (Difficult) Write a function `largestSmallest` which takes a `Path` and "
"returns an array containing the single largest and single smallest files in "
"the `Path`. _Note_: consider the cases where there are zero or one files in "
"the `Path` by returning an empty or one-element array, respectively.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter5.md:643
#, markdown-text
msgid ""
"In this chapter, we covered the basics of recursion in PureScript to express "
"algorithms concisely. We also introduced user-defined infix operators, "
"standard functions on arrays such as maps, filters, and folds, and array "
"comprehensions that combine these ideas. Finally, we showed the importance "
"of using tail recursion to avoid stack overflow errors and how to use "
"accumulator parameters to convert functions to tail recursive form."
msgstr ""

#. type: Title #
#: ../text/chapter6.md:1
#, markdown-text, no-wrap
msgid "Type Classes"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:6
#, markdown-text
msgid ""
"This chapter will introduce a powerful form of abstraction enabled by "
"PureScript's type system – type classes."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:8
#, markdown-text
msgid ""
"This motivating example for this chapter will be a library for hashing data "
"structures. We will see how the machinery of type classes allows us to hash "
"complex data structures without having to think directly about the structure "
"of the data itself."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:10
#, markdown-text
msgid ""
"We will also see a collection of standard type classes from PureScript's "
"Prelude and standard libraries. PureScript code leans heavily on the power "
"of type classes to express ideas concisely, so it will be beneficial to "
"familiarize yourself with these classes."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:12
#, markdown-text
msgid ""
"If you come from an Object Oriented background, please note that the word "
"\"class\" means something _very_ different in this context than what you're "
"used to. A type class serves a purpose more similar to an OO interface."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:16
#, markdown-text
msgid ""
"The source code for this chapter is defined in the file "
"`src/Data/Hashable.purs`."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:24
#, markdown-text
msgid ""
"`maybe`, which defines the `Maybe` data type, which represents optional "
"values."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:24
#, markdown-text
msgid ""
"`tuples`, which defines the `Tuple` data type, which represents pairs of "
"values."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:24
#, markdown-text
msgid ""
"`either`, which defines the `Either` data type, which represents disjoint "
"unions."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:24
#, markdown-text
msgid "`strings`, which defines functions that operate on strings."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:24
#, markdown-text
msgid ""
"`functions`, which defines some helper functions for defining PureScript "
"functions."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:26
#, markdown-text
msgid ""
"The module `Data.Hashable` imports several modules provided by these "
"packages."
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:27
#, markdown-text, no-wrap
msgid "Show Me!"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:30
#, markdown-text
msgid ""
"Our first simple example of a type class is provided by a function we've "
"seen several times already: the `show` function, which takes a value and "
"displays it as a string."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:32
#, markdown-text
msgid ""
"`show` is defined by a type class in the `Prelude` module called `Show`, "
"which is defined as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:33
#, no-wrap
msgid ""
"class Show a where\n"
"  show :: a -> String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:39
#, markdown-text
msgid ""
"This code declares a new _type class_ called `Show`, which is parameterized "
"by the type variable `a`."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:41
#, markdown-text
msgid ""
"A type class _instance_ contains implementations of the functions defined in "
"a type class, specialized to a particular type."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:43
#, markdown-text
msgid ""
"For example, here is the definition of the `Show` type class instance for "
"`Boolean` values, taken from the Prelude:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:44
#, no-wrap
msgid ""
"instance Show Boolean where\n"
"  show true = \"true\"\n"
"  show false = \"false\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:51
#, markdown-text
msgid ""
"This code declares a type class instance; we say that the `Boolean` type "
"_belongs to the `Show` type class_."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:89
#, markdown-text, no-wrap
msgid ""
"> If you're wondering, the generated JS code looks like this:\n"
">\n"
"> ```javascript\n"
"> var showBoolean = {\n"
">     show: function (v) {\n"
">         if (v) {\n"
">             return \"true\";\n"
">         };\n"
">        if (!v) {\n"
">             return \"false\";\n"
">         };\n"
">         throw new Error(\"Failed pattern match at ...\");\n"
">     }\n"
"> };\n"
"> ```\n"
">\n"
"> If you're unhappy with the generated name, you can give names to type "
"class instances. For example:\n"
">\n"
"> ```haskell\n"
"> instance myShowBoolean :: Show Boolean where\n"
">   show true = \"true\"\n"
">   show false = \"false\"\n"
"> ```\n"
">\n"
"> ```javascript\n"
"> var myShowBoolean = {\n"
">     show: function (v) {\n"
">         if (v) {\n"
">             return \"true\";\n"
">         };\n"
">        if (!v) {\n"
">             return \"false\";\n"
">         };\n"
">         throw new Error(\"Failed pattern match at ...\");\n"
">     }\n"
"> };\n"
"> ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:91
#, markdown-text
msgid ""
"We can try out the `Show` type class in PSCi by showing a few values with "
"different types:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:92
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> show true\n"
"\"true\"\n"
"\n"
"> show 1.0\n"
"\"1.0\"\n"
"\n"
"> show \"Hello World\"\n"
"\"\\\"Hello World\\\"\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:106
#, markdown-text
msgid ""
"These examples demonstrate how to `show` values of various primitive types, "
"but we can also `show` values with more complicated types:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:107
#, no-wrap
msgid ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:120
#, markdown-text
msgid ""
"The output of `show` should be a string that you can paste back into the "
"repl (or `.purs` file) to recreate the item being shown. Here we'll use "
"`logShow`, which just calls `show` and then `log`, to render the string "
"without quotes. Ignore the `unit` print – that will be covered in Chapter 8 "
"when we examine `Effect`s, like `log`."
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:121
#, no-wrap
msgid ""
"> import Effect.Console\n"
"\n"
"> logShow (Tuple 1 true)\n"
"(Tuple 1 true)\n"
"unit\n"
"\n"
"> logShow (Just \"testing\")\n"
"(Just \"testing\")\n"
"unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:134
#, markdown-text
msgid ""
"If we try to show a value of type `Data.Either`, we get an interesting error "
"message:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:135
#, no-wrap
msgid ""
"> import Data.Either\n"
"> show (Left 10)\n"
"\n"
"The inferred type\n"
"\n"
"    forall a. Show a => String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider "
"adding a type annotation.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:147
#, markdown-text
msgid ""
"The problem here is not that there is no `Show` instance for the type we "
"intended to `show`, but rather that PSCi could not infer the type. This is "
"indicated by the _unknown type_ `a` in the inferred type."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:149
#, markdown-text
msgid ""
"We can annotate the expression with a type using the `::` operator, so that "
"PSCi can choose the correct type class instance:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:150
#, no-wrap
msgid ""
"> show (Left 10 :: Either Int String)\n"
"\"(Left 10)\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:156
#, markdown-text, no-wrap
msgid ""
"Some types do not have a `Show` instance defined at all. One example of this "
"is the function type `->`. If we try to `show` a function from `Int` to "
"`Int`, we get an appropriate error message from the type checker:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:157
#, no-wrap
msgid ""
"> import Prelude\n"
"> show $ \\n -> n + 1\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Data.Show.Show (Int -> Int)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:167
#, markdown-text
msgid ""
"Type class instances can be defined in one of two places: in the same module "
"that the type class is defined, or in the same module that the type "
"\"belonging to\" the type class is defined. An instance defined in any other "
"spot is called an [\"orphan "
"instance\"](https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#orphan-instances) "
"and is not allowed by the PureScript compiler. Some of the exercises in this "
"chapter will require you to copy the definition of a type into your "
"MySolutions module so that you can define type class instances for that "
"type."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:171
#, markdown-text
msgid ""
"(Easy) Define a `Show` instance for `Point`. Match the same output as the "
"`showPoint` function from the previous chapter. _Note:_ Point is now a "
"`newtype` (instead of a `type` synonym), which allows us to customize how to "
"`show` it. Otherwise, we'd be stuck with the default `Show` instance for "
"records."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:175
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:Point}}\n"
"    ```\n"
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:176
#, markdown-text, no-wrap
msgid "Common Type Classes"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:179
#, markdown-text
msgid ""
"In this section, we'll look at some standard type classes defined in the "
"Prelude and standard libraries. These type classes form the basis of many "
"common patterns of abstraction in idiomatic PureScript code, so a basic "
"understanding of their functions is highly recommended."
msgstr ""

#. type: Title ###
#: ../text/chapter6.md:180
#, markdown-text, no-wrap
msgid "Eq"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:183
#, markdown-text
msgid ""
"The `Eq` type class defines the `eq` function, which tests two values for "
"equality. The `==` operator is actually an alias for `eq`."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:184
#, no-wrap
msgid ""
"class Eq a where\n"
"  eq :: a -> a -> Boolean\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:190
#, markdown-text
msgid ""
"In either case, the two arguments must have the same type: it does not make "
"sense to compare two values of different types for equality."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:192
#, markdown-text
msgid "Try out the `Eq` type class in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:193
#, no-wrap
msgid ""
"> 1 == 2\n"
"false\n"
"\n"
"> \"Test\" == \"Test\"\n"
"true\n"
msgstr ""

#. type: Title ###
#: ../text/chapter6.md:201
#, markdown-text, no-wrap
msgid "Ord"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:204
#, markdown-text, no-wrap
msgid ""
"The `Ord` type class defines the `compare` function, which can be used to "
"compare two values, for types that support ordering. The comparison "
"operators `<` and `>` along with their non-strict companions `<=` and `>=`, "
"can be defined in terms of `compare`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:206
#, markdown-text, no-wrap
msgid ""
"_Note_: In the example below, the class signature contains `<=`. This usage "
"of `<=` in this context indicates that `Eq` is a superclass of `Ord` and is "
"not intended to represent the use of `<=` as a comparison operator. See the "
"section [Superclasses](#superclasses) below.\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:207
#, no-wrap
msgid ""
"data Ordering = LT | EQ | GT\n"
"\n"
"class Eq a <= Ord a where\n"
"  compare :: a -> a -> Ordering\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:215
#, markdown-text
msgid ""
"The `compare` function compares two values and returns an `Ordering`, which "
"has three alternatives:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:219
#, markdown-text
msgid "`LT` – if the first argument is less than the second."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:219
#, markdown-text
msgid "`EQ` – if the first argument is equal to the second."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:219
#, markdown-text
msgid "`GT` – if the first argument is greater than the second."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:221
#, markdown-text
msgid "Again, we can try out the `compare` function in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:222
#, no-wrap
msgid ""
"> compare 1 2\n"
"LT\n"
"\n"
"> compare \"A\" \"Z\"\n"
"LT\n"
msgstr ""

#. type: Title ###
#: ../text/chapter6.md:230
#, markdown-text, no-wrap
msgid "Field"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:233
#, markdown-text
msgid ""
"The `Field` type class identifies those types which support numeric "
"operators such as addition, subtraction, multiplication, and division. It is "
"provided to abstract over those operators, so that they can be reused where "
"appropriate."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:235
#, markdown-text, no-wrap
msgid ""
"> _Note_: Just like the `Eq` and `Ord` type classes, the `Field` type class "
"has special support in the PureScript compiler, so that simple expressions "
"such as `1 + 2 * 3` get translated into simple JavaScript, as opposed to "
"function calls which dispatch based on a type class implementation.\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:236
#, no-wrap
msgid "class EuclideanRing a <= Field a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:241
#, markdown-text
msgid ""
"The `Field` type class is composed from several more general "
"_superclasses_. This allows us to talk abstractly about types that support "
"some but not all of the `Field` operations. For example, a type of natural "
"numbers would be closed under addition and multiplication, but not "
"necessarily under subtraction, so that type might have an instance of the "
"`Semiring` class (which is a superclass of `Num`), but not an instance of "
"`Ring` or `Field`."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:243
#, markdown-text
msgid ""
"Superclasses will be explained later in this chapter, but the full [numeric "
"type class "
"hierarchy](https://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html) "
"([cheatsheet](https://harry.garrood.me/numeric-hierarchy-overview/)) is "
"beyond the scope of this chapter. The interested reader is encouraged to "
"read the documentation for the superclasses of `Field` in `prelude`."
msgstr ""

#. type: Title ###
#: ../text/chapter6.md:244
#, markdown-text, no-wrap
msgid "Semigroups and Monoids"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:247
#, markdown-text
msgid ""
"The `Semigroup` type class identifies those types which support an `append` "
"operation to combine two values:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:248
#, no-wrap
msgid ""
"class Semigroup a where\n"
"  append :: a -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:254
#, markdown-text
msgid ""
"Strings form a semigroup under regular string concatenation, and so do "
"arrays. The `prelude` package provides several other standard instances."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:256
#, markdown-text, no-wrap
msgid ""
"The `<>` concatenation operator, which we have already seen, is provided as "
"an alias for `append`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:258
#, markdown-text
msgid ""
"The `Monoid` type class (provided by the `prelude` package) extends the "
"`Semigroup` type class with the concept of an empty value, called `mempty`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:259
#, no-wrap
msgid ""
"class Semigroup m <= Monoid m where\n"
"  mempty :: m\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:265
#, markdown-text
msgid "Again, strings and arrays are simple examples of monoids."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:267
#, markdown-text
msgid ""
"A `Monoid` type class instance for a type describes how to _accumulate_ a "
"result with that type by starting with an \"empty\" value and combining new "
"results. For example, we can write a function that concatenates an array of "
"values in some monoid using a fold. In PSCi:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:268
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.Monoid\n"
"> import Data.Foldable\n"
"\n"
"> foldl append mempty [\"Hello\", \" \", \"World\"]\n"
"\"Hello World\"\n"
"\n"
"> foldl append mempty [[1, 2, 3], [4, 5], [6]]\n"
"[1,2,3,4,5,6]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:281
#, markdown-text
msgid ""
"The `prelude` package provides many examples of monoids and semigroups, "
"which we will use in the rest of the book."
msgstr ""

#. type: Title ###
#: ../text/chapter6.md:282
#, markdown-text, no-wrap
msgid "Foldable"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:285
#, markdown-text
msgid ""
"If the `Monoid` type class identifies those types which act as the result of "
"a fold, then the `Foldable` type class identifies those type constructors "
"which can be used as the source of a fold."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:287
#, markdown-text
msgid ""
"The `Foldable` type class is provided in the `foldable-traversable` package, "
"which also contains instances for some standard containers such as arrays "
"and `Maybe`."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:289
#, markdown-text
msgid ""
"The type signatures for the functions belonging to the `Foldable` class are "
"a little more complicated than the ones we've seen so far:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:290
#, no-wrap
msgid ""
"class Foldable f where\n"
"  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n"
"  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n"
"  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:298
#, markdown-text
msgid ""
"It is instructive to specialize to the case where `f` is the array type "
"constructor. In this case, we can replace `f a` with `Array a` for any a, "
"and we notice that the types of `foldl` and `foldr` become the types we saw "
"when we first encountered folds over arrays."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:300
#, markdown-text, no-wrap
msgid ""
"What about `foldMap`? Well, that becomes `forall a m. Monoid m => (a -> m) "
"-> Array a -> m`. This type signature says that we can choose any type `m` "
"for our result type, as long as that type is an instance of the `Monoid` "
"type class. If we can provide a function that turns our array elements into "
"values in that monoid, then we can accumulate over our array using the "
"structure of the monoid and return a single value.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:302
#, markdown-text
msgid "Let's try out `foldMap` in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:303
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> foldMap show [1, 2, 3, 4, 5]\n"
"\"12345\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:311
#, markdown-text
msgid ""
"Here, we choose the monoid for strings, which concatenates strings together, "
"and the `show` function, which renders an `Int` as a `String`. Then, passing "
"in an array of integers, we see that the results of `show`ing each integer "
"have been concatenated into a single `String`."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:313
#, markdown-text
msgid ""
"But arrays are not the only types that are foldable. `foldable-traversable` "
"also defines `Foldable` instances for types like `Maybe` and `Tuple`, and "
"other libraries like `lists` define `Foldable` instances for their own data "
"types. `Foldable` captures the notion of an _ordered container_."
msgstr ""

#. type: Title ###
#: ../text/chapter6.md:314
#, markdown-text, no-wrap
msgid "Functor and Type Class Laws"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:317
#, markdown-text
msgid ""
"The Prelude also defines a collection of type classes that enable a "
"functional style of programming with side-effects in PureScript: `Functor`, "
"`Applicative`, and `Monad`. We will cover these abstractions later in the "
"book, but for now, let's look at the definition of the `Functor` type class, "
"which we have seen already in the form of the `map` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:318
#, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:324
#, markdown-text, no-wrap
msgid ""
"The `map` function (and its alias `<$>`) allows a function to be \"lifted\" "
"over a data structure. The precise definition of the word \"lifted\" here "
"depends on the data structure in question, but we have already seen its "
"behavior for some simple types:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:325
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> map (\\n -> n < 3) [1, 2, 3, 4, 5]\n"
"[true, true, false, false, false]\n"
"\n"
"> import Data.Maybe\n"
"> import Data.String (length)\n"
"\n"
"> map length (Just \"testing\")\n"
"(Just 7)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:339
#, markdown-text
msgid ""
"How can we understand the meaning of the `map` function, when it acts on "
"many different structures, each in a different way?"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:341
#, markdown-text
msgid ""
"Well, we can build an intuition that the `map` function applies the function "
"it is given to each element of a container, and builds a new container from "
"the results, with the same shape as the original. But how do we make this "
"concept precise?"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:343
#, markdown-text
msgid ""
"Type class instances for `Functor` are expected to adhere to a set of "
"_laws_, called the _functor laws_:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:346
#, markdown-text
msgid "`map identity xs = xs`"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:346
#, markdown-text
msgid "`map g (map f xs) = map (g <<< f) xs`"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:348
#, markdown-text
msgid ""
"The first law is the _identity law_. It states that lifting the identity "
"function (the function which returns its argument unchanged) over a "
"structure just returns the original structure. This makes sense since the "
"identity function does not modify its input."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:350
#, markdown-text
msgid ""
"The second law is the _composition law_. It states that mapping one function "
"over a structure and then mapping a second is the same as mapping the "
"composition of the two functions over the structure."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:352
#, markdown-text
msgid ""
"Whatever \"lifting\" means in the general sense, it should be true that any "
"reasonable definition of lifting a function over a data structure should "
"obey these rules."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:354
#, markdown-text
msgid ""
"Many standard type classes come with their own set of similar laws. The laws "
"given to a type class give structure to the functions of that type class and "
"allow us to study its instances in generality. The interested reader can "
"research the laws ascribed to the standard type classes that we have seen "
"already."
msgstr ""

#. type: Title ###
#: ../text/chapter6.md:355
#, markdown-text, no-wrap
msgid "Deriving Instances"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:358
#, markdown-text
msgid ""
"Rather than writing instances manually, you can let the compiler do most of "
"the work for you. Take a look at this [Type Class Deriving "
"guide](https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md). "
"That information will help you solve the following exercises."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:362
#, markdown-text
msgid "The following newtype represents a complex number:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:363
#, no-wrap
msgid "{{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Complex}}\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:368
#, markdown-text
msgid ""
"(Easy) Define a `Show` instance for `Complex`. Match the output format "
"expected by the tests (e.g. `1.2+3.4i`, `5.6-7.8i`, etc.)."
msgstr ""

#. type: Bullet: '2. '
#: ../text/chapter6.md:370
#, markdown-text
msgid ""
"(Easy) Derive an `Eq` instance for `Complex`. _Note_: You may instead write "
"this instance manually, but why do more work if you don't have to?"
msgstr ""

#. type: Bullet: '3. '
#: ../text/chapter6.md:372
#, markdown-text
msgid ""
"(Medium) Define a `Semiring` instance for `Complex`. _Note_: You can use "
"`wrap` and `over2` from "
"[`Data.Newtype`](https://pursuit.purescript.org/packages/purescript-newtype/docs/Data.Newtype) "
"to create a more concise solution. If you do so, you will also need to "
"import `class Newtype` from `Data.Newtype` and derive a `Newtype` instance "
"for `Complex`."
msgstr ""

#. type: Bullet: '4. '
#: ../text/chapter6.md:374
#, markdown-text
msgid ""
"(Easy) Derive (via `newtype`) a `Ring` instance for `Complex`. _Note_: You "
"may instead write this instance manually, but that's not as convenient."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:376
#, markdown-text, no-wrap
msgid "    Here's the `Shape` ADT from the previous chapter:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:380
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:Shape}}\n"
"    ```\n"
msgstr ""

#. type: Bullet: '5. '
#: ../text/chapter6.md:382
#, markdown-text
msgid ""
"(Medium) Derive (via `Generic`) a `Show` instance for `Shape`. How does the "
"amount of code written and `String` output compare to `showShape` from the "
"previous chapter? _Hint_: See the [Deriving from "
"`Generic`](https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md#deriving-from-generic) "
"section of the [Type Class "
"Deriving](https://github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving.md) "
"guide."
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:383
#, markdown-text, no-wrap
msgid "Type Class Constraints"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:386
#, markdown-text
msgid ""
"Types of functions can be constrained by using type classes. Here is an "
"example: suppose we want to write a function that tests if three values are "
"equal, by using equality defined using an `Eq` type class instance."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:387
#, no-wrap
msgid ""
"threeAreEqual :: forall a. Eq a => a -> a -> a -> Boolean\n"
"threeAreEqual a1 a2 a3 = a1 == a2 && a2 == a3\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:393
#, markdown-text, no-wrap
msgid ""
"The type declaration looks like an ordinary polymorphic type defined using "
"`forall`. However, there is a type class constraint `Eq a`, separated from "
"the rest of the type by a double arrow `=>`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:395
#, markdown-text
msgid ""
"This type says that we can call `threeAreEqual` with any choice of type `a`, "
"as long as there is an `Eq` instance available for `a` in one of the "
"imported modules."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:397
#, markdown-text
msgid ""
"Constrained types can contain several type class instances, and the types of "
"the instances are not restricted to simple type variables. Here is another "
"example which uses `Ord` and `Show` instances to compare two values:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:398
#, no-wrap
msgid ""
"showCompare :: forall a. Ord a => Show a => a -> a -> String\n"
"showCompare a1 a2 | a1 < a2 =\n"
"  show a1 <> \" is less than \" <> show a2\n"
"showCompare a1 a2 | a1 > a2 =\n"
"  show a1 <> \" is greater than \" <> show a2\n"
"showCompare a1 a2 =\n"
"  show a1 <> \" is equal to \" <> show a2\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:410
#, markdown-text, no-wrap
msgid ""
"Note that multiple constraints can be specified by using the `=>` symbol "
"multiple times, just like we specify curried functions\n"
"of multiple arguments. But remember not to confuse the two symbols:\n"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:413
#, markdown-text
msgid ""
"`a -> b` denotes the type of functions from _type_ `a` to _type_ `b`, "
"whereas"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:413
#, markdown-text
msgid "`a => b` applies the _constraint_ `a` to the type `b`."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:415
#, markdown-text
msgid ""
"The PureScript compiler will try to infer constrained types when a type "
"annotation is not provided. This can be useful if we want to use the most "
"general type possible for a function."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:417
#, markdown-text
msgid ""
"To see this, try using one of the standard type classes like `Semiring` in "
"PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:418
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> :type \\x -> x + x\n"
"forall (a :: Type). Semiring a => a -> a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:426
#, markdown-text, no-wrap
msgid ""
"Here, we might have annotated this function as `Int -> Int` or `Number -> "
"Number`, but PSCi shows us that the most general type works for any "
"`Semiring`, allowing us to use our function with both `Int`s and `Number.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:427
#, markdown-text, no-wrap
msgid "Instance Dependencies"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:430
#, markdown-text
msgid ""
"Just as the implementation of functions can depend on type class instances "
"using constrained types, so can the implementation of type class instances "
"depend on other type class instances. This provides a powerful form of "
"program inference, in which the implementation of a program can be inferred "
"using its types."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:432
#, markdown-text
msgid ""
"For example, consider the `Show` type class. We can write a type class "
"instance to `show` arrays of elements, as long as we have a way to `show` "
"the elements themselves:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:433
#, no-wrap
msgid ""
"instance Show a => Show (Array a) where\n"
"  ...\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:439
#, markdown-text, no-wrap
msgid ""
"If a type class instance depends on multiple other instances, those "
"instances should be grouped in parentheses and separated by commas on the "
"left-hand side of the `=>` symbol:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:440
#, no-wrap
msgid ""
"instance (Show a, Show b) => Show (Either a b) where\n"
"  ...\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:446
#, markdown-text
msgid "These two type class instances are provided in the `prelude` library."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:448
#, markdown-text
msgid ""
"When the program is compiled, the correct type class instance for `Show` is "
"chosen based on the inferred type of the argument to `show`. The selected "
"instance might depend on many such instance relationships, but this "
"complexity is not exposed to the developer."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:452
#, markdown-text
msgid ""
"(Easy) The following declaration defines a type of non-empty arrays of "
"elements of type `a`:"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:456
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:NonEmpty}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:458
#, markdown-text, no-wrap
msgid ""
"    Write an `Eq` instance for the type `NonEmpty a` that reuses the "
"instances for `Eq a` and `Eq (Array a)`. _Note:_ you may instead derive the "
"`Eq` instance.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:460
#, markdown-text
msgid ""
"(Medium) Write a `Semigroup` instance for `NonEmpty a` by reusing the "
"`Semigroup` instance for `Array`."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:462
#, markdown-text
msgid "(Medium) Write a `Functor` instance for `NonEmpty`."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:464
#, markdown-text
msgid ""
"(Medium) Given any type `a` with an instance of `Ord`, we can add a new "
"\"infinite\" value that is greater than any other value:"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:468
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:Extended}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:470
#, markdown-text, no-wrap
msgid ""
"    Write an `Ord` instance for `Extended a` that reuses the `Ord` instance "
"for `a`.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:472
#, markdown-text
msgid ""
"(Difficult) Write a `Foldable` instance for `NonEmpty`. _Hint_: reuse the "
"`Foldable` instance for arrays."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:474
#, markdown-text
msgid ""
"(Difficult) Given a type constructor `f` which defines an ordered container "
"(and so has a `Foldable` instance), we can create a new container type that "
"includes an extra element at the front:"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:478
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:480
#, markdown-text, no-wrap
msgid ""
"    The container `OneMore f` also has an ordering, where the new element "
"comes before any element of `f`. Write a `Foldable` instance for `OneMore "
"f`:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:485
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore_Foldable}}\n"
"      ...\n"
"    ```\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:487
#, markdown-text
msgid ""
"(Medium) Write a `dedupShapes :: Array Shape -> Array Shape` function that "
"removes duplicate `Shape`s from an array using the `nubEq` function."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:489
#, markdown-text
msgid ""
"(Medium) Write a `dedupShapesFast` function which is the same as "
"`dedupShapes`, but uses the more efficient `nub` function."
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:490
#, markdown-text, no-wrap
msgid "Multi-Parameter Type Classes"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:493
#, markdown-text
msgid ""
"It's not the case that a type class can only take a single type as an "
"argument. This is the most common case, but a type class can be "
"parameterized by _zero or more_ type arguments."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:495
#, markdown-text
msgid "Let's see an example of a type class with two type arguments."
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:496
#, no-wrap
msgid ""
"module Stream where\n"
"\n"
"import Data.Array as Array\n"
"import Data.Maybe (Maybe)\n"
"import Data.String.CodeUnits as String\n"
"\n"
"class Stream stream element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
"\n"
"instance Stream (Array a) a where\n"
"  uncons = Array.uncons\n"
"\n"
"instance Stream String Char where\n"
"  uncons = String.uncons\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:514
#, markdown-text
msgid ""
"The `Stream` module defines a class `Stream` which identifies types that "
"look like streams of elements, where elements can be pulled from the front "
"of the stream using the `uncons` function."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:516
#, markdown-text
msgid ""
"Note that the `Stream` type class is parameterized not only by the type of "
"the stream itself, but also by its elements. This allows us to define type "
"class instances for the same stream type but different element types."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:518
#, markdown-text
msgid ""
"The module defines two type class instances: an instance for arrays, where "
"`uncons` removes the head element of the array using pattern matching, and "
"an instance for String, which removes the first character from a String."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:520
#, markdown-text
msgid ""
"We can write functions that work over arbitrary streams. For example, here "
"is a function that accumulates a result in some `Monoid` based on the "
"elements of a stream:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:521
#, no-wrap
msgid ""
"import Prelude\n"
"import Data.Monoid (class Monoid, mempty)\n"
"\n"
"foldStream :: forall l e m. Stream l e => Monoid m => (e -> m) -> l -> m\n"
"foldStream f list =\n"
"  case uncons list of\n"
"    Nothing -> mempty\n"
"    Just cons -> f cons.head <> foldStream f cons.tail\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:533
#, markdown-text
msgid ""
"Try using `foldStream` in PSCi for different types of `Stream` and different "
"types of `Monoid`."
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:534
#, markdown-text, no-wrap
msgid "Functional Dependencies"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:537
#, markdown-text
msgid ""
"Multi-parameter type classes can be very useful but can easily lead to "
"confusing types and even issues with type inference. As a simple example, "
"consider writing a generic `tail` function on streams using the `Stream` "
"class given above:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:538
#, no-wrap
msgid "genericTail xs = map _.tail (uncons xs)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:543
#, markdown-text
msgid "This gives a somewhat confusing error message:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:544
#, no-wrap
msgid ""
"The inferred type\n"
"\n"
"  forall stream a. Stream stream a => stream -> Maybe stream\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider "
"adding a type annotation.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:553
#, markdown-text
msgid ""
"The problem is that the `genericTail` function does not use the `element` "
"type mentioned in the definition of the `Stream` type class, so that type is "
"left unsolved."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:555
#, markdown-text
msgid ""
"Worse still, we cannot even use `genericTail` by applying it to a specific "
"type of stream:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:556
#, no-wrap
msgid ""
"> map _.tail (uncons \"testing\")\n"
"\n"
"The inferred type\n"
"\n"
"  forall a. Stream String a => Maybe String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider "
"adding a type annotation.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:567
#, markdown-text
msgid ""
"Here, we might expect the compiler to choose the `streamString` "
"instance. After all, a `String` is a stream of `Char`s, and cannot be a "
"stream of any other type of elements."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:569
#, markdown-text
msgid ""
"The compiler cannot make that deduction automatically or commit to the "
"`streamString` instance. However, we can help the compiler by adding a hint "
"to the type class definition:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:570
#, no-wrap
msgid ""
"class Stream stream element | stream -> element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:576
#, markdown-text, no-wrap
msgid ""
"Here, `stream -> element` is called a _functional dependency_. A functional "
"dependency asserts a functional relationship between the type arguments of a "
"multi-parameter type class. This functional dependency tells the compiler "
"that there is a function from stream types to (unique) element types, so if "
"the compiler knows the stream type, then it can commit to the element "
"type.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:578
#, markdown-text
msgid ""
"This hint is enough for the compiler to infer the correct type for our "
"generic tail function above:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:579
#, no-wrap
msgid ""
"> :type genericTail\n"
"forall (stream :: Type) (element :: Type). Stream stream element => stream "
"-> Maybe stream\n"
"\n"
"> genericTail \"testing\"\n"
"(Just \"esting\")\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:588
#, markdown-text
msgid ""
"Functional dependencies can be useful when designing certain APIs using "
"multi-parameter type classes."
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:589
#, markdown-text, no-wrap
msgid "Nullary Type Classes"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:592
#, markdown-text
msgid ""
"We can even define type classes with zero-type arguments! These correspond "
"to compile-time assertions about our functions, allowing us to track the "
"global properties of our code in the type system."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:594
#, markdown-text
msgid ""
"An important example is the `Partial` class we saw earlier when discussing "
"partial functions. Take, for example, the functions `head` and `tail` "
"defined in `Data.Array.Partial` that allow us to get the head or tail of an "
"array without wrapping them in a `Maybe`, so they can fail if the array is "
"empty:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:595
#, no-wrap
msgid ""
"head :: forall a. Partial => Array a -> a\n"
"\n"
"tail :: forall a. Partial => Array a -> Array a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:602
#, markdown-text
msgid ""
"Note that there is no instance defined for the `Partial` type class! Doing "
"so would defeat its purpose: attempting to use the `head` function directly "
"will result in a type error:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:603
#, no-wrap
msgid ""
"> head [1, 2, 3]\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Prim.Partial\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:612
#, markdown-text
msgid ""
"Instead, we can republish the `Partial` constraint for any functions making "
"use of partial functions:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:613
#, no-wrap
msgid ""
"secondElement :: forall a. Partial => Array a -> a\n"
"secondElement xs = head (tail xs)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:619
#, markdown-text
msgid ""
"We've already seen the `unsafePartial` function, which allows us to treat a "
"partial function as a regular function (unsafely). This function is defined "
"in the `Partial.Unsafe` module:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:620
#, no-wrap
msgid "unsafePartial :: forall a. (Partial => a) -> a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:625
#, markdown-text
msgid ""
"Note that the `Partial` constraint appears _inside the parentheses_ on the "
"left of the function arrow, but not in the outer `forall`. That is, "
"`unsafePartial` is a function from partial values to regular values:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter6.md:626
#, no-wrap
msgid ""
"> unsafePartial head [1, 2, 3]\n"
"1\n"
"\n"
"> unsafePartial secondElement [1, 2, 3]\n"
"2\n"
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:634
#, markdown-text, no-wrap
msgid "Superclasses"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:637
#, markdown-text
msgid ""
"Just as we can express relationships between type class instances by making "
"an instance dependent on another instance, we can express relationships "
"between type classes themselves using so-called _superclasses_."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:639
#, markdown-text, no-wrap
msgid ""
"We say that one type class is a superclass of another if every instance of "
"the second class is required to be an instance of the first, and we indicate "
"a superclass relationship in the class definition by using a backwards "
"facing double arrow ( `<=` ).\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:641
#, markdown-text
msgid ""
"We've [already seen an example of superclass relationships](#ord): the `Eq` "
"class is a superclass of `Ord`, and the `Semigroup` class is a superclass of "
"`Monoid`. For every type class instance of the `Ord` class, there must be a "
"corresponding `Eq` instance for the same type. This makes sense since, in "
"many cases, when the `compare` function reports that two values are "
"incomparable, we often want to use the `Eq` class to determine if they are "
"equal."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:643
#, markdown-text
msgid ""
"In general, it makes sense to define a superclass relationship when the laws "
"for the subclass mention the superclass members. For example, for any pair "
"of `Ord` and `Eq` instances, it is reasonable to assume that if two values "
"are equal under the `Eq` instance, then the `compare` function should return "
"`EQ`. In other words, `a == b` should be true exactly when `compare a b` "
"evaluates to `EQ`. This relationship on the level of laws justifies the "
"superclass relationship between `Eq` and `Ord`."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:645
#, markdown-text
msgid ""
"Another reason to define a superclass relationship is when there is a clear "
"\"is-a\" relationship between the two classes. That is, every member of the "
"subclass _is a_ member of the superclass as well."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:649
#, markdown-text
msgid ""
"(Medium) Define a partial function `unsafeMaximum :: Partial => Array Int -> "
"Int` that finds the maximum of a non-empty array of integers. Test out your "
"function in PSCi using `unsafePartial`. _Hint_: Use the `maximum` function "
"from `Data.Foldable`."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:651
#, markdown-text
msgid ""
"(Medium) The `Action` class is a multi-parameter type class that defines an "
"action of one type on another:"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:655
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:Action}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:657
#, markdown-text, no-wrap
msgid ""
"    An _action_ is a function that describes how monoidal values are used to "
"determine how to modify a value of another type. There are two laws for the "
"`Action` type class:\n"
msgstr ""

#. type: Bullet: '    - '
#: ../text/chapter6.md:660
#, markdown-text
msgid "`act mempty a = a`"
msgstr ""

#. type: Bullet: '    - '
#: ../text/chapter6.md:660
#, markdown-text
msgid "`act (m1 <> m2) a = act m1 (act m2 a)`"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:662
#, markdown-text, no-wrap
msgid ""
"    Applying an empty action is a no-op. And applying two actions in "
"sequence is the same as applying the actions combined. That is, actions "
"respect the operations defined by the `Monoid` class.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:664
#, markdown-text, no-wrap
msgid "    For example, the natural numbers form a monoid under multiplication:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:667
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:669
#, markdown-text, no-wrap
msgid ""
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:semigroupMultiply}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:672
#, markdown-text, no-wrap
msgid ""
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:monoidMultiply}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:674
#, markdown-text, no-wrap
msgid "    Write an instance that implements this action:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:679
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply_Action}}\n"
"      ...\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:681
#, markdown-text, no-wrap
msgid "    Remember, your instance must satisfy the laws listed above.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:683
#, markdown-text
msgid ""
"(Difficult) There are multiple ways to implement an instance of `Action "
"Multiply Int`. How many can you think of? PureScript does not allow multiple "
"implementations of the same instance, so you will have to replace your "
"original implementation. _Note_: the tests cover 4 implementations."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:685
#, markdown-text
msgid ""
"(Medium) Write an `Action` instance that repeats an input string some number "
"of times:"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:690
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:actionMultiplyString}}\n"
"      ...\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:692
#, markdown-text, no-wrap
msgid ""
"    _Hint_: Search Pursuit for a helper-function with the signature [`String "
"-> Int -> "
"String`](https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String). "
"Note that `String` might appear as a more generic type (such as `Monoid`).\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:694
#, markdown-text, no-wrap
msgid "    Does this instance satisfy the laws listed above?\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:696
#, markdown-text
msgid ""
"(Medium) Write an instance `Action m a => Action m (Array a)`, where the "
"action on arrays is defined by acting on each array element independently."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:698
#, markdown-text
msgid ""
"(Difficult) Given the following newtype, write an instance for `Action m "
"(Self m)`, where the monoid `m` acts on itself using `append`:"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:702
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Self}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:704
#, markdown-text, no-wrap
msgid ""
"    _Note_: The testing framework requires `Show` and `Eq` instances for the "
"`Self` and `Multiply` types. You may either write these instances manually, "
"or let the compiler handle this for you with [`derive newtype "
"instance`](https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype) "
"shorthand.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter6.md:706
#, markdown-text
msgid ""
"(Difficult) Should the arguments of the multi-parameter type class `Action` "
"be related by some functional dependency? Why or why not? _Note_: There is "
"no test for this exercise."
msgstr ""

#. type: Title ##
#: ../text/chapter6.md:707
#, markdown-text, no-wrap
msgid "A Type Class for Hashes"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:710
#, markdown-text
msgid ""
"In the last section of this chapter, we will use the lessons from the rest "
"of the chapter to create a library for hashing data structures."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:712
#, markdown-text, no-wrap
msgid ""
"> Note that this library is for demonstration purposes only and is not "
"intended to provide a robust hashing mechanism.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:714
#, markdown-text
msgid "What properties might we expect of a hash function?"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:717
#, markdown-text
msgid ""
"A hash function should be deterministic and map equal values to equal hash "
"codes."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter6.md:717
#, markdown-text
msgid ""
"A hash function should distribute its results approximately uniformly over "
"some set of hash codes."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:719
#, markdown-text
msgid ""
"The first property looks a lot like a law for a type class, whereas the "
"second property is more along the lines of an informal contract and "
"certainly would not be enforceable by PureScript's type system. However, "
"this should provide the intuition for the following type class:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:720
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:Hashable}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:725
#, markdown-text
msgid "with the associated law that `a == b` implies `hash a == hash b`."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:727
#, markdown-text
msgid ""
"We'll spend the rest of this section building a library of instances and "
"functions associated with the `Hashable` type class."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:729
#, markdown-text
msgid "We will need a way to combine hash codes in a deterministic way:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:730
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:combineHashes}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:735
#, markdown-text
msgid ""
"The `combineHashes` function will mix two hash codes and redistribute the "
"result over the interval 0-65535."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:737
#, markdown-text
msgid ""
"Let's write a function that uses the `Hashable` constraint to restrict the "
"types of its inputs. One common task which requires a hashing function is to "
"determine if two values hash to the same hash code. The `hashEqual` relation "
"provides such a capability:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:738
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashEqual}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:743
#, markdown-text
msgid ""
"This function uses the `on` function from `Data.Function` to define "
"hash-equality in terms of equality of hash codes, and should read like a "
"declarative definition of hash-equality: two values are \"hash-equal\" if "
"they are equal after each value passed through the `hash` function."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:745
#, markdown-text
msgid ""
"Let's write some `Hashable` instances for some primitive types. Let's start "
"with an instance for integers. Since a `HashCode` is really just a wrapped "
"integer, this is simple – we can use the `hashCode` helper function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:746
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashInt}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:751
#, markdown-text
msgid ""
"We can also define a simple instance for `Boolean` values using pattern "
"matching:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:752
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashBoolean}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:757
#, markdown-text
msgid ""
"With an instance for hashing integers, we can create an instance for hashing "
"`Char`s by using the `toCharCode` function from `Data.Char`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:758
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashChar}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:763
#, markdown-text
msgid ""
"To define an instance for arrays, we can `map` the `hash` function over the "
"elements of the array (if the element type is also an instance of "
"`Hashable`) and then perform a left fold over the resulting hashes using the "
"`combineHashes` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:764
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashArray}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:769
#, markdown-text
msgid ""
"Notice how we build up instances using the simpler instances we have already "
"written. Let's use our new `Array` instance to define an instance for "
"`String`s, by turning a `String` into an array of `Char`s:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter6.md:770
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashString}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:775
#, markdown-text
msgid ""
"How can we prove that these `Hashable` instances satisfy the type class law "
"that we stated above? We need to make sure that equal values have equal hash "
"codes. In cases like `Int`, `Char`, `String`, and `Boolean`, this is simple "
"because there are no values of those types that are equal in the sense of "
"`Eq` but not equal identically."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:777
#, markdown-text
msgid ""
"What about some more interesting types? To prove the type class law for the "
"`Array` instance, we can use induction on the length of the array. The only "
"array with a length zero is `[]`. Any two non-empty arrays are equal only if "
"they have equal head elements and equal tails, by the definition of `Eq` on "
"arrays. By the inductive hypothesis, the tails have equal hashes, and we "
"know that the head elements have equal hashes if the `Hashable a` instance "
"must satisfy the law. Therefore, the two arrays have equal hashes, and so "
"the `Hashable (Array a)` obeys the type class law as well."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:779
#, markdown-text
msgid ""
"The source code for this chapter includes several other examples of "
"`Hashable` instances, such as instances for the `Maybe` and `Tuple` type."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter6.md:785
#, markdown-text
msgid ""
"(Easy) Use PSCi to test the hash functions for each of the defined "
"instances. _Note_: There is no provided unit test for this exercise."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter6.md:785
#, markdown-text
msgid ""
"(Medium) Write a function `arrayHasDuplicates`, which tests if an array has "
"any duplicate elements based on both hash and value equality. First, check "
"for hash equality with the `hashEqual` function, then check for value "
"equality with `==` if a duplicate pair of hashes is found. _Hint_: the "
"`nubByEq` function in `Data.Array` should make this task much simpler."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter6.md:785
#, markdown-text
msgid ""
"(Medium) Write a `Hashable` instance for the following newtype which "
"satisfies the type class law:"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:788
#, markdown-text, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Hour}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:791
#, markdown-text, no-wrap
msgid ""
"    {{#include "
"../exercises/chapter6/test/no-peeking/Solutions.purs:eqHour}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:794
#, markdown-text, no-wrap
msgid ""
"    The newtype `Hour` and its `Eq` instance represent the type of integers "
"modulo 12, so that 1 and 13 are identified as equal, for example. Prove that "
"the type class law holds for your instance.\n"
" 1. (Difficult) Prove the type class laws for the `Hashable` instances for "
"`Maybe`, `Either` and `Tuple`. _Note_: There is no test for this exercise.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:798
#, markdown-text
msgid ""
"In this chapter, we've been introduced to _type classes_, a type-oriented "
"form of abstraction that enables powerful forms of code reuse. We've seen a "
"collection of standard type classes from the PureScript standard libraries "
"and defined our own library based on a type class for computing hash codes."
msgstr ""

#. type: Plain text
#: ../text/chapter6.md:799
#, markdown-text
msgid ""
"This chapter also introduced type class laws, a technique for proving "
"properties about code that uses type classes for abstraction. Type class "
"laws are part of a larger subject called _equational reasoning_, in which "
"the properties of a programming language and its type system are used to "
"enable logical reasoning about its programs. This is an important idea and a "
"theme that we will return to throughout the rest of the book."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:1 ../text/chapter7.md:387
#, markdown-text, no-wrap
msgid "Applicative Validation"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:6
#, markdown-text
msgid ""
"In this chapter, we will meet an important new abstraction – the "
"_applicative functor_, described by the `Applicative` type class. Don't "
"worry if the name sounds confusing – we will motivate the concept with a "
"practical example – validating form data. This technique allows us to "
"convert code which usually involves a lot of boilerplate checking into a "
"simple, declarative description of our form."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:8
#, markdown-text
msgid ""
"We will also meet another type class, `Traversable`, which describes "
"_traversable functors_, and see how this concept also arises very naturally "
"from solutions to real-world problems."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:10
#, markdown-text
msgid ""
"The example code for this chapter will be a continuation of the address book "
"example from Chapter 3. This time, we will extend our address book data "
"types and write functions to validate values for those types. The "
"understanding is that these functions could be used, for example, in a web "
"user interface, to display errors to the user as part of a data entry form."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:14
#, markdown-text
msgid ""
"The source code for this chapter is defined in the files "
"`src/Data/AddressBook.purs` and `src/Data/AddressBook/Validation.purs`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:16
#, markdown-text
msgid ""
"The project has a number of dependencies, many of which we have seen "
"before. There are two new dependencies:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter7.md:19
#, markdown-text
msgid ""
"`control`, which defines functions for abstracting control flow using type "
"classes like `Applicative`."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter7.md:19
#, markdown-text
msgid ""
"`validation`, which defines a functor for _applicative validation_, the "
"subject of this chapter."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:21
#, markdown-text
msgid ""
"The `Data.AddressBook` module defines data types and `Show` instances for "
"the types in our project and the `Data.AddressBook.Validation` module "
"contains validation rules for those types."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:22
#, markdown-text, no-wrap
msgid "Generalizing Function Application"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:25
#, markdown-text
msgid ""
"To explain the concept of an _applicative functor_, let's consider the type "
"constructor `Maybe` that we met earlier."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:27
#, markdown-text
msgid ""
"The source code for this module defines a function `address` that has the "
"following type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:28
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:33
#, markdown-text
msgid ""
"This function is used to construct a value of type `Address` from three "
"strings: a street name, a city, and a state."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:35
#, markdown-text
msgid "We can apply this function easily and see the result in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:36
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> address \"123 Fake St.\" \"Faketown\" \"CA\"\n"
"{ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:44
#, markdown-text
msgid ""
"However, suppose we did not necessarily have a street, city, or state, and "
"wanted to use the `Maybe` type to indicate a missing value in each of the "
"three cases."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:46
#, markdown-text
msgid ""
"In one case, we might have a missing city. If we try to apply our function "
"directly, we will receive an error from the type checker:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:47
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"> address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Could not match type\n"
"\n"
"  Maybe String\n"
"\n"
"with type\n"
"\n"
"  String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:61
#, markdown-text
msgid ""
"Of course, this is an expected type error – `address` takes strings as "
"arguments, not values of type `Maybe String`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:63
#, markdown-text
msgid ""
"However, it is reasonable to expect that we should be able to \"lift\" the "
"`address` function to work with optional values described by the `Maybe` "
"type. In fact, we can, and the `Control.Apply` provides the function `lift3` "
"function which does exactly what we need:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:64
#, no-wrap
msgid ""
"> import Control.Apply\n"
"> lift3 address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:72
#, markdown-text
msgid ""
"In this case, the result is `Nothing`, because one of the arguments (the "
"city) was missing. If we provide all three arguments using the `Just` "
"constructor, then the result will contain a value as well:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:73
#, no-wrap
msgid ""
"> lift3 address (Just \"123 Fake St.\") (Just \"Faketown\") (Just \"CA\")\n"
"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:80
#, markdown-text
msgid ""
"The name of the function `lift3` indicates that it can be used to lift "
"functions of 3 arguments. There are similar functions defined in "
"`Control.Apply` for functions of other numbers of arguments."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:81
#, markdown-text, no-wrap
msgid "Lifting Arbitrary Functions"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:84
#, markdown-text
msgid ""
"So, we can lift functions with small numbers of arguments by using `lift2`, "
"`lift3`, etc. But how can we generalize this to arbitrary functions?"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:86
#, markdown-text
msgid "It is instructive to look at the type of `lift3`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:87
#, no-wrap
msgid ""
"> :type lift3\n"
"forall (a :: Type) (b :: Type) (c :: Type) (d :: Type) (f :: Type -> "
"Type). Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:93
#, markdown-text
msgid ""
"In the `Maybe` example above, the type constructor `f` is `Maybe`, so that "
"`lift3` is specialized to the following type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:94
#, no-wrap
msgid ""
"forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe "
"d\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:99
#, markdown-text
msgid ""
"This type says that we can take any function with three arguments and lift "
"it to give a new function whose argument and result types are wrapped with "
"`Maybe`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:101
#, markdown-text
msgid ""
"Certainly, this is not possible for every type constructor `f`, so what is "
"it about the `Maybe` type which allowed us to do this? Well, in specializing "
"the type above, we removed a type class constraint on `f` from the `Apply` "
"type class. `Apply` is defined in the Prelude as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:102
#, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
"\n"
"class Functor f <= Apply f where\n"
"  apply :: forall a b. f (a -> b) -> f a -> f b\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:111
#, markdown-text, no-wrap
msgid ""
"The `Apply` type class is a subclass of `Functor`, and defines an additional "
"function `apply`. As `<$>` was defined as an alias for `map`, the `Prelude` "
"module defines `<*>` as an alias for `apply`. As we'll see, these two "
"operators are often used together.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:113
#, markdown-text
msgid ""
"Note that this "
"[`apply`](https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Apply#v:apply) "
"is different than the "
"[`apply`](https://pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:apply) "
"from `Data.Function` (infixed as `$`). Luckily, infix notation is almost "
"always used for the latter, so you don't need to worry about name "
"collisions."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:115
#, markdown-text
msgid ""
"The type of `apply` looks a lot like the type of `map`. The difference "
"between `map` and `apply` is that `map` takes a function as an argument, "
"whereas the first argument to `apply` is wrapped in the type constructor "
"`f`. We'll see how this is used soon, but first, let's see how to implement "
"the `Apply` type class for the `Maybe` type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:116
#, no-wrap
msgid ""
"instance Functor Maybe where\n"
"  map f (Just a) = Just (f a)\n"
"  map f Nothing  = Nothing\n"
"\n"
"instance Apply Maybe where\n"
"  apply (Just f) (Just x) = Just (f x)\n"
"  apply _        _        = Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:127
#, markdown-text
msgid ""
"This type class instance says that we can apply an optional function to an "
"optional value, and the result is defined only if both are defined."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:129
#, markdown-text
msgid ""
"Now we'll see how `map` and `apply` can be used together to lift functions "
"of an arbitrary number of arguments."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:131
#, markdown-text
msgid "For functions of one argument, we can use `map` directly."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:133
#, markdown-text, no-wrap
msgid ""
"For functions of two arguments, we have a curried function `g` with type `a "
"-> b -> c`, say. This is equivalent to the type `a -> (b -> c)`, so we can "
"apply `map` to `g` to get a new function of type `f a -> f (b -> c)` for any "
"type constructor `f` with a `Functor` instance. Partially applying this "
"function to the first lifted argument (of type `f a`), we get a new wrapped "
"function of type `f (b -> c)`. If we also have an `Apply` instance for `f`, "
"we can then use `apply` to apply the second lifted argument (of type `f b`) "
"to get our final value of type `f c`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:135
#, markdown-text, no-wrap
msgid ""
"Putting this all together, we see that if we have values `x :: f a` and `y "
":: f b`, then the expression `(g <$> x) <*> y` has type `f c` (remember, "
"this expression is equivalent to `apply (map g x) y`). The precedence rules "
"defined in the Prelude allow us to remove the parentheses: `g <$> x <*> "
"y`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:137
#, markdown-text, no-wrap
msgid ""
"In general, we can use `<$>` on the first argument, and `<*>` for the "
"remaining arguments, as illustrated here for `lift3`:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:138
#, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:150
#, markdown-text, no-wrap
msgid ""
"> It is left as an exercise for the reader to verify the types involved in "
"this expression.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:152
#, markdown-text, no-wrap
msgid ""
"As an example, we can try lifting the address function over `Maybe`, "
"directly using the `<$>` and `<*>` functions:\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:153
#, no-wrap
msgid ""
"> address <$> Just \"123 Fake St.\" <*> Just \"Faketown\" <*> Just \"CA\"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
"\n"
"> address <$> Just \"123 Fake St.\" <*> Nothing <*> Just \"CA\"\n"
"Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:162
#, markdown-text
msgid ""
"Try lifting some other functions of various numbers of arguments over "
"`Maybe` in this way."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:164
#, markdown-text
msgid ""
"Alternatively, _applicative do notation_ can be used for the same purpose in "
"a way that looks similar to the familiar _do notation_. Here is `lift3` "
"using _applicative do notation_. Note `ado` is used instead of `do`, and "
"`in` is used on the final line to denote the yielded value:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:165
#, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = ado\n"
"  a <- x\n"
"  b <- y\n"
"  c <- z\n"
"  in f a b c\n"
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:180
#, markdown-text, no-wrap
msgid "The Applicative Type Class"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:183
#, markdown-text
msgid "There is a related type class called `Applicative`, defined as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:184
#, no-wrap
msgid ""
"class Apply f <= Applicative f where\n"
"  pure :: forall a. a -> f a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:190
#, markdown-text
msgid ""
"`Applicative` is a subclass of `Apply` and defines the `pure` "
"function. `pure` takes a value and returns a value whose type has been "
"wrapped with the type constructor `f`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:192
#, markdown-text
msgid "Here is the `Applicative` instance for `Maybe`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:193
#, no-wrap
msgid ""
"instance Applicative Maybe where\n"
"  pure x = Just x\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:199
#, markdown-text
msgid ""
"If we think of applicative functors as functors that allow lifting of "
"functions, then `pure` can be thought of as lifting functions of zero "
"arguments."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:200
#, markdown-text, no-wrap
msgid "Intuition for Applicative"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:203
#, markdown-text
msgid ""
"Functions in PureScript are pure and do not support "
"side-effects. Applicative functors allow us to work in larger \"programming "
"languages\" which support some sort of side-effect encoded by the functor "
"`f`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:205
#, markdown-text, no-wrap
msgid ""
"As an example, the functor `Maybe` represents the side effect of "
"possibly-missing values. Some other examples include `Either err`, which "
"represents the side effect of possible errors of type `err`, and the arrow "
"functor `r ->`, which represents the side-effect of reading from a global "
"configuration. For now, we'll only consider the `Maybe` functor.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:207
#, markdown-text
msgid ""
"If the functor `f` represents this larger programming language with effects, "
"then the `Apply` and `Applicative` instances allow us to lift values and "
"function applications from our smaller programming language (PureScript) "
"into the new language."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:209
#, markdown-text
msgid ""
"`pure` lifts pure (side-effect free) values into the larger language; for "
"functions, we can use `map` and `apply` as described above."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:211
#, markdown-text
msgid ""
"This raises a question: if we can use `Applicative` to embed PureScript "
"functions and values into this new language, then how is the new language "
"any larger? The answer depends on the functor `f`. If we can find "
"expressions of type `f a` which cannot be expressed as `pure x` for some "
"`x`, then that expression represents a term which only exists in the larger "
"language."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:213
#, markdown-text
msgid ""
"When `f` is `Maybe`, an example is the expression `Nothing`: we cannot write "
"`Nothing` as `pure x` for any `x`. Therefore, we can think of PureScript as "
"having been enlarged to include the new term `Nothing`, which represents a "
"missing value."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:214
#, markdown-text, no-wrap
msgid "More Effects"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:217
#, markdown-text
msgid ""
"Let's see some more examples of lifting functions over different "
"`Applicative` functors."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:219
#, markdown-text
msgid ""
"Here is a simple example function defined in PSCi, which joins three names "
"to form a full name:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:220
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> fullName first middle last = last <> \", \" <> first <> \" \" <> middle\n"
"\n"
"> fullName \"Phillip\" \"A\" \"Freeman\"\n"
"Freeman, Phillip A\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:230
#, markdown-text
msgid ""
"Suppose that this function forms the implementation of a (very simple!) web "
"service with the three arguments provided as query parameters. We want to "
"ensure that the user provided each of the three parameters, so we might use "
"the Maybe type to indicate the presence or absence of a parameter. We can "
"lift `fullName` over `Maybe` to create an implementation of the web service "
"which checks for missing parameters:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:231
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:242 ../text/chapter7.md:292 ../text/chapter7.md:444
#: ../text/chapter7.md:479 ../text/chapter7.md:525
#, markdown-text
msgid "Or with _applicative do_:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:243
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> :paste…\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Just \"A\"\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"(Just \"Freeman, Phillip A\")\n"
"\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Nothing\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:265
#, markdown-text
msgid ""
"Note that the lifted function returns `Nothing` if any of the arguments was "
"`Nothing`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:267
#, markdown-text
msgid ""
"This is good because now we can send an error response back from our web "
"service if the parameters are invalid. However, it would be better if we "
"could indicate which field was incorrect in the response."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:269
#, markdown-text
msgid ""
"Instead of lifting over `Maybe`, we can lift over `Either String`, which "
"allows us to return an error message. First, let's write an operator to "
"convert optional inputs into computations which can signal an error using "
"`Either String`:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:270
#, no-wrap
msgid ""
"> import Data.Either\n"
"> :paste\n"
"… withError Nothing  err = Left err\n"
"… withError (Just a) _   = Right a\n"
"… ^D\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:279
#, markdown-text
msgid ""
"_Note_: In the `Either err` applicative functor, the `Left` constructor "
"indicates an error, and the `Right` constructor indicates success."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:281
#, markdown-text
msgid ""
"Now we can lift over `Either String`, providing an appropriate error message "
"for each parameter:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:282
#, no-wrap
msgid ""
"> :paste\n"
"… fullNameEither first middle last =\n"
"…   fullName <$> (first  `withError` \"First name was missing\")\n"
"…            <*> (middle `withError` \"Middle name was missing\")\n"
"…            <*> (last   `withError` \"Last name was missing\")\n"
"… ^D\n"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:293
#, no-wrap
msgid ""
"> :paste\n"
"… fullNameEither first middle last = ado\n"
"…  f <- first  `withError` \"First name was missing\"\n"
"…  m <- middle `withError` \"Middle name was missing\"\n"
"…  l <- last   `withError` \"Last name was missing\"\n"
"…  in fullName f m l\n"
"… ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:307
#, markdown-text
msgid ""
"Now our function takes three optional arguments using `Maybe`, and returns "
"either a `String` error message or a `String` result."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:309
#, markdown-text
msgid "We can try out the function with different inputs:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:310
#, no-wrap
msgid ""
"> fullNameEither (Just \"Phillip\") (Just \"A\") (Just \"Freeman\")\n"
"(Right \"Freeman, Phillip A\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") Nothing (Just \"Freeman\")\n"
"(Left \"Middle name was missing\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") (Just \"A\") Nothing\n"
"(Left \"Last name was missing\")\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:322
#, markdown-text
msgid ""
"In this case, we see the error message corresponding to the first missing "
"field or a successful result if every field was provided. However, if we are "
"missing multiple inputs, we still only see the first error:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:323
#, no-wrap
msgid ""
"> fullNameEither Nothing Nothing Nothing\n"
"(Left \"First name was missing\")\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:329
#, markdown-text
msgid ""
"This might be good enough, but if we want to see a list of _all_ missing "
"fields in the error, then we need something more powerful than `Either "
"String`. We will see a solution later in this chapter."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:330
#, markdown-text, no-wrap
msgid "Combining Effects"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:333
#, markdown-text
msgid ""
"As an example of working with applicative functors abstractly, this section "
"will show how to write a function that generically combines side-effects "
"encoded by an applicative functor `f`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:335
#, markdown-text
msgid ""
"What does this mean? Well, suppose we have a list of wrapped arguments of "
"type `f a` for some `a`. That is, suppose we have a list of type `List (f "
"a)`. Intuitively, this represents a list of computations with side-effects "
"tracked by `f`, each with return type `a`. If we could run all of these "
"computations in order, we would obtain a list of results of type `List "
"a`. However, we would still have side-effects tracked by `f`. That is, we "
"expect to be able to turn something of type `List (f a)` into something of "
"type `f (List a)` by \"combining\" the effects inside the original list."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:337
#, markdown-text, no-wrap
msgid ""
"For any fixed list size `n`, there is a function of `n` arguments that "
"builds a list of size `n` out of those arguments. For example, if `n` is "
"`3`, the function is `\\x y z -> x : y : z : Nil`. This function has type `a "
"-> a -> a -> List a`. We can use the `Applicative` instance for `List` to "
"lift this function over `f`, to get a function of type `f a -> f a -> f a -> "
"f (List a)`. But, since we can do this for any `n`, it makes sense that we "
"should be able to perform the same lifting for any _list_ of arguments.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:339
#, markdown-text
msgid "That means that we should be able to write a function"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:340 ../text/chapter7.md:602
#, no-wrap
msgid "combineList :: forall f a. Applicative f => List (f a) -> f (List a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:345
#, markdown-text
msgid ""
"This function will take a list of arguments, which possibly have "
"side-effects, and return a single wrapped list, applying the side-effects of "
"each."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:347
#, markdown-text
msgid ""
"To write this function, we'll consider the length of the list of "
"arguments. If the list is empty, then we do not need to perform any effects, "
"and we can use `pure` to simply return an empty list:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:348
#, no-wrap
msgid "combineList Nil = pure Nil\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:353
#, markdown-text
msgid "In fact, this is the only thing we can do!"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:355
#, markdown-text, no-wrap
msgid ""
"If the list is non-empty, then we have a head element, which is a wrapped "
"argument of type `f a`, and a tail of type `List (f a)`. We can recursively "
"combine the effects in the tail, giving a result of type `f (List a)`. We "
"can then use `<$>` and `<*>` to lift the `Cons` constructor over the head "
"and new tail:\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:356
#, no-wrap
msgid "combineList (Cons x xs) = Cons <$> x <*> combineList xs\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:361
#, markdown-text
msgid ""
"Again, this was the only sensible implementation, based on the types we were "
"given."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:363
#, markdown-text
msgid ""
"We can test this function in PSCi, using the `Maybe` type constructor as an "
"example:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:364
#, no-wrap
msgid ""
"> import Data.List\n"
"> import Data.Maybe\n"
"\n"
"> combineList (fromFoldable [Just 1, Just 2, Just 3])\n"
"(Just (Cons 1 (Cons 2 (Cons 3 Nil))))\n"
"\n"
"> combineList (fromFoldable [Just 1, Nothing, Just 2])\n"
"Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:376
#, markdown-text
msgid ""
"When specialized to `Maybe`, our function returns a `Just` only if every "
"list element is `Just`; otherwise, it returns `Nothing`. This is consistent "
"with our intuition of working in a larger language supporting optional "
"values – a list of computations that produce optional results only has a "
"result itself if every computation contained a result."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:378
#, markdown-text, no-wrap
msgid ""
"But the `combineList` function works for any `Applicative`! We can use it to "
"combine computations that possibly signal an error using `Either err`, or "
"which read from a global configuration using `r ->`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:380
#, markdown-text
msgid ""
"We will see the `combineList` function again later when we consider "
"`Traversable` functors."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:386
#, markdown-text
msgid ""
"(Medium) Write versions of the numeric operators `+`, `-`, `*`, and `/` "
"which work with optional arguments (i.e., arguments wrapped in `Maybe`) and "
"return a value wrapped in `Maybe`. Name these functions `addMaybe`, "
"`subMaybe`, `mulMaybe`, and `divMaybe`. _Hint_: Use `lift2`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:386
#, markdown-text
msgid ""
"(Medium) Extend the above exercise to work with all `Apply` types (not just "
"`Maybe`). Name these new functions `addApply`, `subApply`, `mulApply`, and "
"`divApply`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:386
#, markdown-text
msgid ""
"(Difficult) Write a function `combineMaybe` which has type `forall a "
"f. Applicative f => Maybe (f a) -> f (Maybe a)`. This function takes an "
"optional computation with side-effects and returns a side-effecting "
"computation with an optional result."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:390
#, markdown-text
msgid ""
"The source code for this chapter defines several data types which might be "
"used in an address book application. The details are omitted here, but the "
"key functions exported by the `Data.AddressBook` module have the following "
"types:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:391
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
"\n"
"{{#include "
"../exercises/chapter7/src/Data/AddressBook.purs:phoneNumber_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:person_anno}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:400
#, markdown-text
msgid "Where `PhoneType` is defined as an algebraic data type:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:401
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:PhoneType}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:406
#, markdown-text
msgid ""
"These functions can construct a `Person` representing an address book "
"entry. For example, the following value is defined in `Data.AddressBook`:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:407
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:examplePerson}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:412
#, markdown-text
msgid "Test this value in PSCi (this result has been formatted):"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:413
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> examplePerson\n"
"{ firstName: \"John\"\n"
", lastName: \"Smith\"\n"
", homeAddress:\n"
"    { street: \"123 Fake St.\"\n"
"    , city: \"FakeTown\"\n"
"    , state: \"CA\"\n"
"    }\n"
", phones:\n"
"    [ { type: HomePhone\n"
"      , number: \"555-555-5555\"\n"
"      }\n"
"    , { type: CellPhone\n"
"      , number: \"555-555-0000\"\n"
"      }\n"
"    ]\n"
"}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:436
#, markdown-text
msgid ""
"We saw in a previous section how we could use the `Either String` functor to "
"validate a data structure of type `Person`. For example, provided functions "
"to validate the two names in the structure, we might validate the entire "
"data structure as follows:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:437
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty1}}\n"
"\n"
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1}}\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:445
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1Ado}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:450
#, markdown-text
msgid ""
"In the first two lines, we use the `nonEmpty1` function to validate a "
"non-empty string. `nonEmpty1` returns an error indicated with the `Left` "
"constructor if its input is empty. Otherwise, it returns the value wrapped "
"with the `Right` constructor."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:452
#, markdown-text
msgid ""
"The final lines do not perform any validation but simply provide the "
"`address` and `phones` fields to the `person` function as the remaining "
"arguments."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:454
#, markdown-text
msgid ""
"This function can be seen to work in PSCi, but it has a limitation that we "
"have seen before:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:455
#, no-wrap
msgid ""
"> validatePerson $ person \"\" \"\" (address \"\" \"\" \"\") []\n"
"(Left \"Field cannot be empty\")\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:461
#, markdown-text
msgid ""
"The `Either String` applicative functor only provides the first error "
"encountered. Given the input here, we would prefer to see two errors – one "
"for the missing first name and a second for the missing last name."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:463
#, markdown-text
msgid ""
"There is another applicative functor that the `validation` library "
"provides. This functor is called `V`, and it can return errors in any "
"_semigroup_. For example, we can use `V (Array String)` to return an array "
"of `String`s as errors, concatenating new errors onto the end of the array."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:465
#, markdown-text
msgid ""
"The `Data.AddressBook.Validation` module uses the `V (Array String)` "
"applicative functor to validate the data structures in the "
"`Data.AddressBook` module."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:467
#, markdown-text
msgid ""
"Here is an example of a validator taken from the "
"`Data.AddressBook.Validation` module:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:468
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:Errors}}\n"
"\n"
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty}}\n"
"\n"
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:lengthIs}}\n"
"\n"
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddress}}\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:480
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddressAdo}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:485
#, markdown-text
msgid ""
"`validateAddress` validates an `Address` structure. It checks that the "
"`street` and `city` fields are non-empty and that the string in the `state` "
"field has length 2."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:487
#, markdown-text
msgid ""
"Notice how the `nonEmpty` and `lengthIs` validator functions both use the "
"`invalid` function provided by the `Data.Validation` module to indicate an "
"error. Since we are working in the `Array String` semigroup, `invalid` takes "
"an array of strings as its argument."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:489
#, markdown-text
msgid "We can try this function in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:490
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> validateAddress $ address \"\" \"\" \"\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         , \"Field 'State' must have length 2\"\n"
"         ])\n"
"\n"
"> validateAddress $ address \"\" \"\" \"CA\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         ])\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:507
#, markdown-text
msgid "This time, we receive an array of all validation errors."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:508
#, markdown-text, no-wrap
msgid "Regular Expression Validators"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:511
#, markdown-text
msgid ""
"The `validatePhoneNumber` function uses a regular expression to validate the "
"form of its argument. The key is a `matches` validation function, which uses "
"a `Regex` from the `Data.String.Regex` module to validate its input:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:512
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:matches}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:517
#, markdown-text
msgid ""
"Again, notice how `pure` is used to indicate successful validation, and "
"`invalid` is used to signal an array of errors."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:519
#, markdown-text
msgid ""
"`validatePhoneNumber` is built from the `matches` function in the same way "
"as before:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:520
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumber}}\n"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:526
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumberAdo}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:531
#, markdown-text
msgid ""
"Again, try running this validator against some valid and invalid inputs in "
"PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:532
#, no-wrap
msgid ""
"> validatePhoneNumber $ phoneNumber HomePhone \"555-555-5555\"\n"
"pure ({ type: HomePhone, number: \"555-555-5555\" })\n"
"\n"
"> validatePhoneNumber $ phoneNumber HomePhone \"555.555.5555\"\n"
"invalid ([\"Field 'Number' did not match the required format\"])\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:545
#, markdown-text
msgid ""
"(Easy) Write a regular expression `stateRegex :: Regex` to check that a "
"string only contains two alphabetic characters. _Hint_: see the source code "
"for `phoneNumberRegex`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:545
#, markdown-text
msgid ""
"(Medium) Write a regular expression `nonEmptyRegex :: Regex` to check that a "
"string is not entirely whitespace. _Hint_: If you need help developing this "
"regex expression, check out [RegExr](https://regexr.com), which has a great "
"cheatsheet and interactive test environment."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:545
#, markdown-text
msgid ""
"(Medium) Write a function `validateAddressImproved` that is similar to "
"`validateAddress`, but uses the above `stateRegex` to validate the `state` "
"field and `nonEmptyRegex` to validate the `street` and `city` "
"fields. _Hint_: see the source for `validatePhoneNumber` for an example of "
"how to use `matches`."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:546
#, markdown-text, no-wrap
msgid "Traversable Functors"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:549
#, markdown-text
msgid ""
"The remaining validator is `validatePerson`, which combines the validators "
"we have seen so far to validate an entire `Person` structure, including the "
"following new `validatePhoneNumbers` function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:550
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumbers}}\n"
"\n"
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:557
#, markdown-text
msgid "or with _applicative do_"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:558
#, no-wrap
msgid ""
"{{#include "
"../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePersonAdo}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:563
#, markdown-text
msgid ""
"`validatePhoneNumbers` uses a new function we haven't seen before – "
"`traverse`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:565
#, markdown-text
msgid ""
"`traverse` is defined in the `Data.Traversable` module, in the `Traversable` "
"type class:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:566
#, no-wrap
msgid ""
"class (Functor t, Foldable t) <= Traversable t where\n"
"  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n"
"  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:573
#, markdown-text
msgid ""
"`Traversable` defines the class of _traversable functors_. The types of its "
"functions might look a little intimidating, but `validatePerson` provides a "
"good motivating example."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:575
#, markdown-text
msgid ""
"Every traversable functor is both a `Functor` and `Foldable` (recall that a "
"_foldable functor_ was a type constructor that supported a fold operation, "
"reducing a structure to a single value). In addition, a traversable functor "
"can combine a collection of side-effects that depend on its structure."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:577
#, markdown-text
msgid ""
"This may sound complicated, but let's simplify things by specializing to the "
"case of arrays. The array type constructor is traversable, which means that "
"there is a function:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:578
#, no-wrap
msgid ""
"traverse :: forall a b m. Applicative m => (a -> m b) -> Array a -> m (Array "
"b)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:583
#, markdown-text
msgid ""
"Intuitively, given any applicative functor `m`, and a function which takes a "
"value of type `a` and returns a value of type `b` (with side-effects tracked "
"by `m`), we can apply the function to each element of an array of type "
"`Array a` to obtain a result of type `Array b` (with side-effects tracked by "
"`m`)."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:585
#, markdown-text
msgid ""
"Still not clear? Let's specialize further to the case where `m` is the `V "
"Errors` applicative functor above. Now, we have a function of type"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:586
#, no-wrap
msgid "traverse :: forall a b. (a -> V Errors b) -> Array a -> V Errors (Array b)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:591
#, markdown-text
msgid ""
"This type signature says that if we have a validation function `m` for a "
"type `a`, then `traverse m` is a validation function for arrays of type "
"`Array a`. But that's exactly what we need to be able to validate the "
"`phones` field of the `Person` data structure! We pass `validatePhoneNumber` "
"to `traverse` to create a validation function that validates each element "
"successively."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:593
#, markdown-text
msgid ""
"In general, `traverse` walks over the elements of a data structure, "
"performing computations with side-effects and accumulating a result."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:595
#, markdown-text
msgid ""
"The type signature for `Traversable`'s other function `sequence` might look "
"more familiar:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:596
#, no-wrap
msgid "sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:601
#, markdown-text
msgid ""
"In fact, the `combineList` function that we wrote earlier is just a special "
"case of the `sequence` function from the `Traversable` type class. Setting "
"`t` to be the type constructor `List`, we recover the type of the "
"`combineList` function:"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:607
#, markdown-text
msgid ""
"Traversable functors capture the idea of traversing a data structure, "
"collecting a set of effectful computations, and combining their effects. In "
"fact, `sequence` and `traverse` are equally important to the definition of "
"`Traversable` – each can be implemented in terms of the other. This is left "
"as an exercise for the interested reader."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:609
#, markdown-text
msgid "The `Traversable` instance for lists given in the `Data.List` module is:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:610
#, no-wrap
msgid ""
"instance Traversable List where\n"
"-- traverse :: forall a b m. Applicative m => (a -> m b) -> List a -> m "
"(List b)\n"
"traverse _ Nil         = pure Nil\n"
"traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:618
#, markdown-text
msgid ""
"(The actual definition was later modified to improve stack safety. You can "
"read more about that change "
"[here](https://github.com/purescript/purescript-lists/pull/87).)"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:620
#, markdown-text
msgid ""
"In the case of an empty list, we can return an empty list using `pure`. If "
"the list is non-empty, we can use the function `f` to create a computation "
"of type `f b` from the head element. We can also call `traverse` recursively "
"on the tail. Finally, we can lift the `Cons` constructor over the "
"applicative functor `m` to combine the two results."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:622
#, markdown-text
msgid ""
"But there are more examples of traversable functors than just arrays and "
"lists. The `Maybe` type constructor we saw earlier also has an instance for "
"`Traversable`. We can try it in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter7.md:623
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"> import Data.Traversable\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> traverse (nonEmpty \"Example\") Nothing\n"
"pure (Nothing)\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"\")\n"
"invalid ([\"Field 'Example' cannot be empty\"])\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"Testing\")\n"
"pure ((Just \"Testing\"))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:639
#, markdown-text
msgid ""
"These examples show that traversing the `Nothing` value returns `Nothing` "
"with no validation, and traversing `Just x` uses the validation function to "
"validate `x`. That is, `traverse` takes a validation function for type `a` "
"and returns a validation function for `Maybe a`, i.e., a validation function "
"for optional values of type `a`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:641
#, markdown-text
msgid ""
"Other traversable functors include `Array`, `Tuple a`, and `Either a` for "
"any type `a`. Generally, most \"container\" data type constructors have "
"`Traversable` instances. As an example, the exercises will include writing a "
"`Traversable` instance for a type of binary trees."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:645
#, markdown-text
msgid ""
"(Easy) Write `Eq` and `Show` instances for the following binary tree data "
"structure:"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:649
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:651
#, markdown-text, no-wrap
msgid ""
"     Recall from the previous chapter that you may either write these "
"instances manually or let the compiler derive them.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:653
#, markdown-text, no-wrap
msgid ""
"     There are many \"correct\" formatting options for `Show` output. The "
"test for this exercise expects the following whitespace style. This matches "
"the default formatting of the generic show, so you only need to note this if "
"you're planning on writing this instance manually.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:657
#, markdown-text, no-wrap
msgid ""
"     ```haskell\n"
"     (Branch (Branch Leaf 8 Leaf) 42 Leaf)\n"
"     ```\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:659
#, markdown-text
msgid ""
"(Medium) Write a `Traversable` instance for `Tree a`, which combines "
"side-effects left-to-right. _Hint_: There are some additional instance "
"dependencies that need to be defined for `Traversable`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:661
#, markdown-text
msgid ""
"(Medium) Write a function `traversePreOrder :: forall a m b. Applicative m "
"=> (a -> m b) -> Tree a -> m (Tree b)` that performs a pre-order traversal "
"of the tree. This means the order of effect execution is root-left-right, "
"instead of left-root-right as was done for the previous in-order traverse "
"exercise. _Hint_: No additional instances need to be defined, and you don't "
"need to call any of the functions defined earlier. Applicative do notation "
"(`ado`) is the easiest way to write this function."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:663
#, markdown-text
msgid ""
"(Medium) Write a function `traversePostOrder` that performs a post-order "
"traversal of the tree where effects are executed left-right-root."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:665
#, markdown-text
msgid ""
"(Medium) Create a new version of the `Person` type where the `homeAddress` "
"field is optional (using `Maybe`). Then write a new version of "
"`validatePerson` (renamed as `validatePersonOptionalAddress`) to validate "
"this new `Person`. _Hint_: Use `traverse` to validate a field of type `Maybe "
"a`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:667
#, markdown-text
msgid ""
"(Difficult) Write a function `sequenceUsingTraverse` which behaves like "
"`sequence`, but is written in terms of `traverse`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter7.md:669
#, markdown-text
msgid ""
"(Difficult) Write a function `traverseUsingSequence` which behaves like "
"`traverse`, but is written in terms of `sequence`."
msgstr ""

#. type: Title ##
#: ../text/chapter7.md:670
#, markdown-text, no-wrap
msgid "Applicative Functors for Parallelism"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:673
#, markdown-text
msgid ""
"In the discussion above, I chose the word \"combine\" to describe how "
"applicative functors \"combine side-effects\". However, in all the examples "
"given, it would be equally valid to say that applicative functors allow us "
"to \"sequence\" effects. This would be consistent with the intuition that "
"traversable functors provide a `sequence` function to combine effects in "
"sequence based on a data structure."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:675
#, markdown-text
msgid ""
"However, in general, applicative functors are more general than this. The "
"applicative functor laws do not impose any ordering on the side-effects that "
"their computations perform. It would be valid for an applicative functor to "
"perform its side-effects in parallel."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:677
#, markdown-text
msgid ""
"For example, the `V` validation functor returned an _array_ of errors, but "
"it would work just as well if we picked the `Set` semigroup, in which case "
"it would not matter what order we ran the various validators. We could even "
"run them in parallel over the data structure!"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:679
#, markdown-text
msgid ""
"As a second example, the `parallel` package provides a type class `Parallel` "
"which supports _parallel computations_. `Parallel` provides a function "
"`parallel` that uses some `Applicative` functor to compute the result of its "
"input computation _in parallel_:"
msgstr ""

#. type: Fenced code block (haskell)
#: ../text/chapter7.md:680
#, no-wrap
msgid ""
"f <$> parallel computation1\n"
"  <*> parallel computation2\n"
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:686
#, markdown-text
msgid ""
"This computation would start computing values asynchronously using "
"`computation1` and `computation2`. When both results have been computed, "
"they would be combined into a single result using the function `f`."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:688
#, markdown-text
msgid ""
"We will see this idea in more detail when we apply applicative functors to "
"the problem of _callback hell_ later in the book."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:690
#, markdown-text
msgid ""
"Applicative functors are a natural way to capture side-effects that can be "
"combined in parallel."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:694
#, markdown-text
msgid "In this chapter, we covered a lot of new ideas:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter7.md:698
#, markdown-text
msgid ""
"We introduced the concept of an _applicative functor_ which generalizes the "
"idea of function application to type constructors that captures some notion "
"of side-effect."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter7.md:698
#, markdown-text
msgid ""
"We saw how applicative functors solved the problem of validating data "
"structures and how by switching the applicative functor, we could change "
"from reporting a single error to reporting all errors across a data "
"structure."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter7.md:698
#, markdown-text
msgid ""
"We met the `Traversable` type class, which encapsulates the idea of a "
"_traversable functor_, or a container whose elements can be used to combine "
"values with side-effects."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:700
#, markdown-text
msgid ""
"Applicative functors are an interesting abstraction that provides neat "
"solutions to a number of problems. We will see them a few more times "
"throughout the book. In this case, the validation applicative functor "
"provided a way to write validators in a declarative style, allowing us to "
"define _what_ our validators should validate and not _how_ they should "
"perform that validation. In general, we will see that applicative functors "
"are a useful tool for the design of _domain specific languages_."
msgstr ""

#. type: Plain text
#: ../text/chapter7.md:701
#, markdown-text
msgid ""
"In the next chapter, we will see a related idea, the class of _monads_, and "
"extend our address book example to run in the browser!"
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:1 ../text/chapter8.md:393
#, markdown-text, no-wrap
msgid "The Effect Monad"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:6
#, markdown-text
msgid ""
"In the last chapter, we introduced applicative functors, an abstraction we "
"used to deal with _side-effects_: optional values, error messages, and "
"validation. This chapter will introduce another abstraction for dealing with "
"side-effects more expressively: _monads_."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:8
#, markdown-text
msgid ""
"The goal of this chapter is to explain why monads are a useful abstraction "
"and their connection with _do notation_."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:12
#, markdown-text
msgid "The project adds the following dependencies:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:15
#, markdown-text
msgid ""
"`effect` – defines the `Effect` monad, the subject of the second half of the "
"chapter. This dependency is often listed in every starter project (it's been "
"a dependency of every chapter so far), so you'll rarely have to install it "
"explicitly."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:15
#, markdown-text
msgid "`react-basic-hooks` – a web framework we will use for our Address Book app."
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:16
#, markdown-text, no-wrap
msgid "Monads and Do Notation"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:19
#, markdown-text
msgid ""
"Do notation was first introduced when we covered _array "
"comprehensions_. Array comprehensions provide syntactic sugar for the "
"`concatMap` function from the `Data.Array` module."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:21
#, markdown-text
msgid ""
"Consider the following example. Suppose we throw two dice and want to count "
"the number of ways in which we can score a total of `n`. We could do this "
"using the following non-deterministic algorithm:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:25
#, markdown-text
msgid "_Choose_ the value `x` of the first throw."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:25
#, markdown-text
msgid "_Choose_ the value `y` of the second throw."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:25
#, markdown-text
msgid "If the sum of `x` and `y` is `n`, return the pair `[x, y]`, else fail."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:27
#, markdown-text
msgid ""
"Array comprehensions allow us to write this non-deterministic algorithm "
"naturally:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:28
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Plus (empty)\n"
"import Data.Array ((..))\n"
"\n"
"{{#include ../exercises/chapter8/test/Examples.purs:countThrows}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:38
#, markdown-text
msgid "We can see that this function works in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter8.md:39
#, no-wrap
msgid ""
"> import Test.Examples\n"
"\n"
"> countThrows 10\n"
"[[4,6],[5,5],[6,4]]\n"
"\n"
"> countThrows 12\n"
"[[6,6]]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:50
#, markdown-text
msgid ""
"In the last chapter, we formed an intuition for the `Maybe` applicative "
"functor, embedding PureScript functions into a larger programming language "
"supporting _optional values_. In the same way, we can form an intuition for "
"the _array monad_, embedding PureScript functions into a larger programming "
"language supporting _non-deterministic choice_."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:52
#, markdown-text
msgid ""
"Generally, a _monad_ for some type constructor `m` provides a way to use do "
"notation with values of type `m a`. Note that in the array comprehension "
"above, every line contains a computation of type `Array a` for some type "
"`a`. In general, every line of a do notation block will contain a "
"computation of type `m a` for some type `a` and our monad `m`. The monad `m` "
"must be the same on every line (i.e., we fix the side-effect), but the types "
"`a` can differ (i.e., individual computations can have different result "
"types)."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:54
#, markdown-text
msgid ""
"Here is another example of do notation, this time applied to the type "
"constructor `Maybe`. Suppose we have some type `XML` representing XML nodes, "
"and a function"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:55
#, no-wrap
msgid "child :: XML -> String -> Maybe XML\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:60
#, markdown-text
msgid ""
"Which looks for a child element of a node and returns `Nothing` if no such "
"element exists."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:62
#, markdown-text
msgid ""
"In this case, we can look for a deeply-nested element using do "
"notation. Suppose we wanted to read a user's city from a user profile that "
"had been encoded as an XML document:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:63 ../text/chapter8.md:293
#, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root = do\n"
"  prof <- child root \"profile\"\n"
"  addr <- child prof \"address\"\n"
"  city <- child addr \"city\"\n"
"  pure city\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:73
#, markdown-text
msgid ""
"The `userCity` function looks for a child element `profile`, an element "
"`address` inside the `profile` element, and finally, an element `city` "
"inside the `address` element. If any of these elements are missing, the "
"return value will be `Nothing`. Otherwise, the return value is constructed "
"using `Just` from the `city` node."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:75
#, markdown-text
msgid ""
"Remember, the `pure` function in the last line is defined for every "
"`Applicative` functor. Since `pure` is defined as `Just` for the `Maybe` "
"applicative functor, it would be equally valid to change the last line to "
"`Just city`."
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:76
#, markdown-text, no-wrap
msgid "The Monad Type Class"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:79
#, markdown-text
msgid "The `Monad` type class is defined as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:80
#, no-wrap
msgid ""
"class Apply m <= Bind m where\n"
"  bind :: forall a b. m a -> (a -> m b) -> m b\n"
"\n"
"class (Applicative m, Bind m) <= Monad m\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:88
#, markdown-text, no-wrap
msgid ""
"The key function here is `bind`, defined in the `Bind` type class. Just like "
"for the `<$>` and `<*>` operators in the `Functor` and `Apply` type classes, "
"the Prelude defines an infix alias `>>=` for the `bind` function.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:90
#, markdown-text
msgid ""
"The `Monad` type class extends `Bind` with the operations of the "
"`Applicative` type class we've already seen."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:92
#, markdown-text
msgid ""
"It will be useful to see some examples of the `Bind` type class. A sensible "
"definition for `Bind` on arrays can be given as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:93
#, no-wrap
msgid ""
"instance Bind Array where\n"
"  bind xs f = concatMap f xs\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:99
#, markdown-text
msgid ""
"This explains the connection between array comprehensions and the "
"`concatMap` function that has been alluded to before."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:101
#, markdown-text
msgid "Here is an implementation of `Bind` for the `Maybe` type constructor:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:102
#, no-wrap
msgid ""
"instance Bind Maybe where\n"
"  bind Nothing  _ = Nothing\n"
"  bind (Just a) f = f a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:109
#, markdown-text
msgid ""
"This definition confirms the intuition that missing values are propagated "
"through a do notation block."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:111
#, markdown-text
msgid ""
"Let's see how the `Bind` type class is related to do notation. Consider a "
"simple do notation block that starts by binding a value from the result of "
"some computation:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:112
#, no-wrap
msgid ""
"do value <- someComputation\n"
"   whatToDoNext\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:118
#, markdown-text
msgid ""
"Every time the PureScript compiler sees this pattern, it replaces the code "
"with this:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:119
#, no-wrap
msgid "bind someComputation \\value -> whatToDoNext\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:124
#, markdown-text
msgid "or, written infix:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:125
#, no-wrap
msgid "someComputation >>= \\value -> whatToDoNext\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:130
#, markdown-text
msgid "The computation `whatToDoNext` is allowed to depend on `value`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:132
#, markdown-text
msgid ""
"If there are multiple binds involved, this rule is applied multiple times, "
"starting from the top. For example, the `userCity` example that we saw "
"earlier gets desugared as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:133
#, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root =\n"
"  child root \"profile\" >>= \\prof ->\n"
"    child prof \"address\" >>= \\addr ->\n"
"      child addr \"city\" >>= \\city ->\n"
"        pure city\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:143
#, markdown-text, no-wrap
msgid ""
"Notably, code expressed using do notation is often much clearer than the "
"equivalent code using the `>>=` operator. However, writing binds explicitly "
"using `>>=` can often lead to opportunities to write code in _point-free_ "
"form – but the usual warnings about readability apply.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:144
#, markdown-text, no-wrap
msgid "Monad Laws"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:147
#, markdown-text
msgid ""
"The `Monad` type class comes equipped with three laws, called the _monad "
"laws_. These tell us what we can expect from sensible implementations of the "
"`Monad` type class."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:149
#, markdown-text
msgid "It is simplest to explain these laws using do notation."
msgstr ""

#. type: Title ###
#: ../text/chapter8.md:150
#, markdown-text, no-wrap
msgid "Identity Laws"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:153
#, markdown-text
msgid ""
"The _right-identity_ law is the simplest of the three laws. It tells us that "
"we can eliminate a call to `pure` if it is the last expression in a do "
"notation block:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:154
#, no-wrap
msgid ""
"do\n"
"  x <- expr\n"
"  pure x\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:161
#, markdown-text
msgid "The right-identity law says that this is equivalent to just `expr`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:163
#, markdown-text
msgid ""
"The _left-identity_ law states that we can eliminate a call to `pure` if it "
"is the first expression in a do notation block:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:164
#, no-wrap
msgid ""
"do\n"
"  x <- pure y\n"
"  next\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:171
#, markdown-text
msgid ""
"This code is equivalent to `next`, after the name `x` has been replaced with "
"the expression `y`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:173
#, markdown-text
msgid ""
"The last law is the _associativity law_. It tells us how to deal with nested "
"do notation blocks. It states that the following piece of code:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:174
#, no-wrap
msgid ""
"c1 = do\n"
"  y <- do\n"
"    x <- m1\n"
"    m2\n"
"  m3\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:183
#, markdown-text
msgid "is equivalent to this code:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:184
#, no-wrap
msgid ""
"c2 = do\n"
"  x <- m1\n"
"  y <- m2\n"
"  m3\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:192
#, markdown-text
msgid ""
"Each of these computations involves three monadic expressions `m1`, `m2`, "
"and `m3`. In each case, the result of `m1` is eventually bound to the name "
"`x`, and the result of `m2` is bound to the name `y`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:194
#, markdown-text
msgid ""
"In `c1`, the two expressions `m1` and `m2` are grouped into their own do "
"notation block."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:196
#, markdown-text
msgid ""
"In `c2`, all three expressions `m1`, `m2`, and `m3` appear in the same do "
"notation block."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:198
#, markdown-text
msgid ""
"The associativity law tells us that it is safe to simplify nested do "
"notation blocks in this way."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:200
#, markdown-text
msgid ""
"_Note_ that by the definition of how do notation gets desugared into calls "
"to `bind`, both of `c1` and `c2` are also equivalent to this code:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:201
#, no-wrap
msgid ""
"c3 = do\n"
"  x <- m1\n"
"  do\n"
"    y <- m2\n"
"    m3\n"
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:209
#, markdown-text, no-wrap
msgid "Folding With Monads"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:212
#, markdown-text
msgid ""
"As an example of working with monads abstractly, this section will present a "
"function that works with any type constructor in the `Monad` type "
"class. This should solidify the intuition that monadic code corresponds to "
"programming \"in a larger language\" with side-effects, and also illustrate "
"the generality which programming with monads brings."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:214
#, markdown-text
msgid ""
"The function we will write is called `foldM`. It generalizes the `foldl` "
"function we met earlier to a monadic context. Here is its type signature:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:215
#, no-wrap
msgid ""
"foldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> List b -> m a\n"
"foldl :: forall   a b.            (a -> b ->   a) -> a -> List b ->   a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:221
#, markdown-text
msgid ""
"Notice that this is the same as the type of `foldl`, except for the "
"appearance of the monad `m`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:223
#, markdown-text
msgid ""
"Intuitively, `foldM` performs a fold over a list in some context supporting "
"some set of side-effects."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:225
#, markdown-text
msgid ""
"For example, if we picked `m` to be `Maybe`, then our fold would be allowed "
"to fail by returning `Nothing` at any stage – every step returns an optional "
"result, and the result of the fold is therefore also optional."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:227
#, markdown-text
msgid ""
"If we picked `m` to be the `Array` type constructor, then every step of the "
"fold would be allowed to return zero or more results, and the fold would "
"proceed to the next step independently for each result. In the end, the set "
"of results would consist of all folds over all possible paths. This "
"corresponds to a traversal of a graph!"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:229
#, markdown-text
msgid "To write `foldM`, we can simply break the input list into cases."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:231
#, markdown-text
msgid ""
"If the list is empty, then to produce the result of type `a`, we only have "
"one option: we have to return the second argument:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:232
#, no-wrap
msgid "foldM _ a Nil = pure a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:237
#, markdown-text
msgid "Note that we have to use `pure` to lift `a` into the monad `m`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:239
#, markdown-text, no-wrap
msgid ""
"What if the list is non-empty? In that case, we have a value of type `a`, a "
"value of type `b`, and a function of type `a -> b -> m a`. If we apply the "
"function, we obtain a monadic result of type `m a`. We can bind the result "
"of this computation with a backwards arrow `<-`.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:241
#, markdown-text
msgid ""
"It only remains to recurse on the tail of the list. The implementation is "
"simple:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:242
#, no-wrap
msgid ""
"foldM f a (b : bs) = do\n"
"  a' <- f a b\n"
"  foldM f a' bs\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:249
#, markdown-text
msgid ""
"Note that this implementation is almost identical to that of `foldl` on "
"lists, except for do notation."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:251
#, markdown-text
msgid ""
"We can define and test this function in PSCi. Here is an example – suppose "
"we defined a \"safe division\" function on integers, which tested for "
"division by zero and used the `Maybe` type constructor to indicate failure:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:252
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Examples.purs:safeDivide}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:257
#, markdown-text
msgid "Then we can use `foldM` to express iterated safe division:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter8.md:258
#, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.List (fromFoldable)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [5, 2, 2])\n"
"(Just 5)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [2, 0, 4])\n"
"Nothing\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:270
#, markdown-text
msgid ""
"The `foldM safeDivide` function returns `Nothing` if a division by zero was "
"attempted at any point. Otherwise, it returns the result of repeatedly "
"dividing the accumulator, wrapped in the `Just` constructor."
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:271
#, markdown-text, no-wrap
msgid "Monads and Applicatives"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:274
#, markdown-text
msgid ""
"Every instance of the `Monad` type class is also an instance of the `Apply` "
"type class, by virtue of the superclass relationship between the two "
"classes."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:276
#, markdown-text
msgid ""
"However, there is also an implementation of the `Apply` type class which "
"comes \"for free\" for any instance of `Monad`, given by the `ap` function:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:277
#, no-wrap
msgid ""
"ap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\n"
"ap mf ma = do\n"
"  f <- mf\n"
"  a <- ma\n"
"  pure (f a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:286
#, markdown-text
msgid ""
"If `m` is a law-abiding member of the `Monad` type class, then there is a "
"valid `Apply` instance for `m` given by `ap`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:288
#, markdown-text
msgid ""
"The interested reader can check that `ap` agrees with `apply` for the monads "
"we have already encountered: `Array`, `Maybe`, and `Either e`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:290
#, markdown-text
msgid ""
"If every monad is also an applicative functor, then we should be able to "
"apply our intuition for applicative functors to every monad. In particular, "
"we can reasonably expect a monad to correspond, in some sense, to "
"programming \"in a larger language\" augmented with some set of additional "
"side-effects. We should be able to lift functions of arbitrary arities, "
"using `map` and `apply`, into this new language."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:292
#, markdown-text
msgid ""
"But monads allow us to do more than we could do with just applicative "
"functors, and the key difference is highlighted by the syntax of do "
"notation. Consider the `userCity` example again, in which we looked for a "
"user's city in an XML document that encoded their user profile:"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:303
#, markdown-text
msgid ""
"Do notation allows the second computation to depend on the result `prof` of "
"the first, and the third computation to depend on the result `addr` of the "
"second, and so on. This dependence on previous values is not possible using "
"only the interface of the `Applicative` type class."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:305
#, markdown-text
msgid ""
"Try writing `userCity` using only `pure` and `apply`: you will see that it "
"is impossible. Applicative functors only allow us to lift function arguments "
"which are independent of each other, but monads allow us to write "
"computations which involve more interesting data dependencies."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:307
#, markdown-text
msgid ""
"In the last chapter, we saw that the `Applicative` type class can be used to "
"express parallelism. This was precisely because the function arguments being "
"lifted were independent of one another. Since the `Monad` type class allows "
"computations to depend on the results of previous computations, the same "
"does not apply – a monad has to combine its side-effects in sequence."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter8.md:312
#, markdown-text
msgid ""
"(Easy) Write a function `third` that returns the third element of an array "
"with three or more elements. Your function should return an appropriate "
"`Maybe` type. _Hint:_ Look up the types of the `head` and `tail` functions "
"from the `Data.Array` module in the `arrays` package. Use do notation with "
"the `Maybe` monad to combine these functions."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter8.md:312
#, markdown-text
msgid ""
"(Medium) Write a function `possibleSums` which uses `foldM` to determine all "
"possible totals that could be made using a set of coins. The coins will be "
"specified as an array which contains the value of each coin. Your function "
"should have the following result:"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:316
#, markdown-text, no-wrap
msgid ""
"     ```text\n"
"     > possibleSums []\n"
"     [0]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:320
#, markdown-text, no-wrap
msgid ""
"     > possibleSums [1, 2, 10]\n"
"     [0,1,2,3,10,11,12,13]\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:325
#, markdown-text, no-wrap
msgid ""
"     _Hint_: This function can be written as a one-liner using `foldM`. You "
"might want to use the `nub` and `sort` functions to remove duplicates and "
"sort the result.\n"
" 1. (Medium) Confirm that the `ap` function and the `apply` operator agree "
"for the `Maybe` monad. _Note:_ There are no tests for this exercise.\n"
" 1. (Medium) Verify that the monad laws hold for the `Monad` instance for "
"the `Maybe` type, as defined in the `maybe` package. _Note:_ There are no "
"tests for this exercise.\n"
" 1. (Medium) Write a function `filterM` which generalizes the `filter` "
"function on lists. Your function should have the following type signature:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:329
#, markdown-text, no-wrap
msgid ""
"     ```hs\n"
"     filterM :: forall m a. Monad m => (a -> m Boolean) -> List a -> m (List "
"a)\n"
"     ```\n"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter8.md:331
#, markdown-text
msgid "(Difficult) Every monad has a default `Functor` instance given by:"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:337
#, markdown-text, no-wrap
msgid ""
"     ```hs\n"
"     map f a = do\n"
"       x <- a\n"
"       pure (f x)\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:339
#, markdown-text, no-wrap
msgid "     Use the monad laws to prove that for any monad, the following holds:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:343
#, markdown-text, no-wrap
msgid ""
"     ```hs\n"
"     lift2 f (pure a) (pure b) = pure (f a b)\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:345
#, markdown-text, no-wrap
msgid ""
"     Where the `Apply` instance uses the `ap` function defined above. Recall "
"that `lift2` was defined as follows:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:350
#, markdown-text, no-wrap
msgid ""
"     ```hs\n"
"     lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f "
"c\n"
"     lift2 f a b = f <$> a <*> b\n"
"     ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:352
#, markdown-text, no-wrap
msgid "    _Note:_ There are no tests for this exercise.\n"
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:353
#, markdown-text, no-wrap
msgid "Native Effects"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:356
#, markdown-text
msgid ""
"We will now look at one particular monad of central importance in PureScript "
"– the `Effect` monad."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:358
#, markdown-text
msgid ""
"The `Effect` monad is defined in the `Effect` module. It is used to manage "
"so-called _native_ side-effects. If you are familiar with Haskell, it is the "
"equivalent of the `IO` monad."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:360
#, markdown-text
msgid ""
"What are native side-effects? They are the side-effects that distinguish "
"JavaScript expressions from idiomatic PureScript expressions, which "
"typically are free from side-effects. Some examples of native effects are:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:365
#, markdown-text
msgid "Console IO"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:365
#, markdown-text
msgid "Random number generation"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:365
#, markdown-text
msgid "Reading/writing mutable state"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:367
#, markdown-text
msgid "And in the browser:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:372
#, markdown-text
msgid "DOM manipulation"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:372
#, markdown-text
msgid "XMLHttpRequest / AJAX calls"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:372
#, markdown-text
msgid "Interacting with a websocket"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:372
#, markdown-text
msgid "Writing/reading to/from local storage"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:374
#, markdown-text
msgid "We have already seen plenty of examples of \"non-native\" side-effects:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:378
#, markdown-text
msgid "Optional values, as represented by the `Maybe` data type"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:378
#, markdown-text
msgid "Errors, as represented by the `Either` data type"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:378
#, markdown-text
msgid "Multi-functions, as represented by arrays or lists"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:380
#, markdown-text
msgid ""
"Note that the distinction is subtle. It is true, for example, that an error "
"message is a possible side-effect of a JavaScript expression in the form of "
"an exception. In that sense, exceptions do represent native side-effects, "
"and it is possible to represent them using `Effect`. However, error messages "
"implemented using `Either` are not a side-effect of the JavaScript runtime, "
"and so it is not appropriate to implement error messages in that style using "
"`Effect`. So it is not the effect itself, which is native, but rather how it "
"is implemented at runtime."
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:381
#, markdown-text, no-wrap
msgid "Side-Effects and Purity"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:384
#, markdown-text
msgid ""
"In a pure language like PureScript, one question presents itself: without "
"side-effects, how can one write useful real-world code?"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:386
#, markdown-text
msgid ""
"The answer is that PureScript does not aim to eliminate side-effects but to "
"represent them in such a way that pure computations can be distinguished "
"from computations with side-effects in the type system. In this sense, the "
"language is still pure."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:388
#, markdown-text
msgid ""
"Values with side-effects have different types from pure values. As such, it "
"is impossible to pass a side-effecting argument to a function, for example, "
"and have side-effects performed unexpectedly."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:390
#, markdown-text
msgid ""
"The only way side-effects managed by the `Effect` monad will be presented is "
"to run a computation of type `Effect a` from JavaScript."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:392
#, markdown-text
msgid ""
"The Spago build tool (and other tools) provide a shortcut by generating "
"additional JavaScript to invoke the `main` computation when the application "
"starts. `main` is required to be a computation in the `Effect` monad."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:396
#, markdown-text
msgid ""
"The `Effect` monad provides a well-typed API for computations with "
"side-effects, while at the same time generating efficient JavaScript."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:398
#, markdown-text
msgid ""
"Let's look at the return type of the familiar `log` function. `Effect` "
"indicates that this function produces a native effect, console IO in this "
"case."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:400
#, markdown-text
msgid ""
"`Unit` indicates that no _meaningful_ data is returned. You can think of "
"`Unit` as analogous to the `void` keyword in other languages, such as C, "
"Java, etc."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:401
#, no-wrap
msgid "log :: String -> Effect Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:410
#, markdown-text, no-wrap
msgid ""
"> _Aside:_ You may encounter IDE suggestions for the more general (and more "
"elaborately typed) `log` function from `Effect.Class.Console`. This is "
"interchangeable with the one from `Effect.Console` when dealing with the "
"basic `Effect` monad. Reasons for the more general version will become "
"clearer after reading about \"Monad Transformers\" in the \"Monadic "
"Adventures\" chapter. For the curious (and impatient), this works because "
"there's a `MonadEffect` instance for `Effect`.\n"
">\n"
"> ```hs\n"
"> log :: forall m. MonadEffect m => String -> m Unit\n"
"> ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:412
#, markdown-text
msgid ""
"Now let's consider an `Effect` that returns meaningful data. The `random` "
"function from `Effect.Random` produces a random `Number`."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:413
#, no-wrap
msgid "random :: Effect Number\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:418
#, markdown-text
msgid ""
"Here's a full example program (found in `test/Random.purs` of this chapter's "
"exercises folder)."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:419
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Random.purs}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:424
#, markdown-text
msgid ""
"Because `Effect` is a monad, we use do notation to _unwrap_ the data it "
"contains before passing this data on to the effectful `logShow` function. As "
"a refresher, here's the equivalent code written using the `bind` operator:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:425
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = random >>= logShow\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:431
#, markdown-text
msgid "Try running this yourself with:"
msgstr ""

#. type: Fenced code block (shell)
#: ../text/chapter8.md:432
#, no-wrap
msgid "spago run --main Test.Random\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:437
#, markdown-text
msgid ""
"You should see a randomly chosen number between `0.0` and `1.0` printed to "
"the console."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:439
#, markdown-text, no-wrap
msgid ""
"> _Aside:_ `spago run` defaults to searching in the `Main` module for a "
"`main` function. You may also specify an alternate module as an entry point "
"with the `--main` flag, as in the above example. Just be sure that this "
"alternate module also contains a `main` function.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:441
#, markdown-text
msgid ""
"Note that it's also possible to generate \"random\" (technically "
"pseudorandom) data without resorting to impure effectful code. We'll cover "
"these techniques in the \"Generative Testing\" chapter."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:443
#, markdown-text
msgid ""
"As mentioned previously, the `Effect` monad is of central importance to "
"PureScript. The reason why it's central is that it is the conventional way "
"to interoperate with PureScript's `Foreign Function Interface`, which "
"provides the mechanism to execute a program and perform side effects. While "
"it's desirable to avoid using the `Foreign Function Interface`, it's fairly "
"critical to understand how it works and how to use it, so I recommend "
"reading that chapter before doing any serious PureScript work. That said, "
"the `Effect` monad is fairly simple. It has a few helper functions but "
"doesn't do much except encapsulate side effects."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:447
#, markdown-text
msgid ""
"Let's examine a function from the `node-fs` package that involves two "
"_native_ side effects: reading mutable state and exceptions:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:448
#, no-wrap
msgid "readTextFile :: Encoding -> String -> Effect String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:453
#, markdown-text
msgid "If we attempt to read a file that does not exist:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:454
#, no-wrap
msgid ""
"import Node.Encoding (Encoding(..))\n"
"import Node.FS.Sync (readTextFile)\n"
"\n"
"main :: Effect Unit\n"
"main = do\n"
"  lines <- readTextFile UTF8 \"iDoNotExist.md\"\n"
"  log lines\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:465
#, markdown-text
msgid "We encounter the following exception:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter8.md:466
#, no-wrap
msgid ""
"    throw err;\n"
"    ^\n"
"Error: ENOENT: no such file or directory, open 'iDoNotExist.md'\n"
"...\n"
"  errno: -2,\n"
"  syscall: 'open',\n"
"  code: 'ENOENT',\n"
"  path: 'iDoNotExist.md'\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:478
#, markdown-text
msgid ""
"To manage this exception gracefully, we can wrap the potentially problematic "
"code in `try` to handle either outcome:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:479
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = do\n"
"  result <- try $ readTextFile UTF8 \"iDoNotExist.md\"\n"
"  case result of\n"
"    Right lines -> log $ \"Contents: \\n\" <> lines\n"
"    Left  error -> log $ \"Couldn't open file. Error was: \" <> message "
"error\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:489
#, markdown-text
msgid ""
"`try` runs an `Effect` and returns eventual exceptions as a `Left` value. If "
"the computation succeeds, the result gets wrapped in a `Right`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:490
#, no-wrap
msgid "try :: forall a. Effect a -> Effect (Either Error a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:495
#, markdown-text
msgid ""
"We can also generate our own exceptions. Here is an alternative "
"implementation of `Data.List.head` that throws an exception if the list is "
"empty rather than returning a `Maybe` value of `Nothing`."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:496
#, no-wrap
msgid ""
"exceptionHead :: List Int -> Effect Int\n"
"exceptionHead l = case l of\n"
"  x : _ -> pure x\n"
"  Nil -> throwException $ error \"empty list\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:504
#, markdown-text
msgid ""
"Note that the `exceptionHead` function is a somewhat impractical example, as "
"it is best to avoid generating exceptions in PureScript code and instead use "
"non-native effects such as `Either` and `Maybe` to manage errors and missing "
"values."
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:505
#, markdown-text, no-wrap
msgid "Mutable State"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:508
#, markdown-text
msgid "There is another effect defined in the core libraries: the `ST` effect."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:510
#, markdown-text
msgid ""
"The `ST` effect is used to manipulate mutable state. As pure functional "
"programmers, we know that shared mutable state can be problematic. However, "
"the `ST` effect uses the type system to restrict sharing in such a way that "
"only safe _local_ mutation is allowed."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:512
#, markdown-text
msgid ""
"The `ST` effect is defined in the `Control.Monad.ST` module. To see how it "
"works, we need to look at the types of its actions:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:513
#, no-wrap
msgid ""
"new :: forall a r. a -> ST r (STRef r a)\n"
"\n"
"read :: forall a r. STRef r a -> ST r a\n"
"\n"
"write :: forall a r. a -> STRef r a -> ST r a\n"
"\n"
"modify :: forall r a. (a -> a) -> STRef r a -> ST r a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:524
#, markdown-text
msgid ""
"`new` is used to create a new mutable reference cell of type `STRef r a`, "
"which can be read using the `read` action and modified using the `write` and "
"`modify` actions. The type `a` is the type of the value stored in the cell, "
"and the type `r` is used to indicate a _memory region_ (or _heap_) in the "
"type system."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:526
#, markdown-text
msgid ""
"Here is an example. Suppose we want to simulate the movement of a particle "
"falling under gravity by iterating a simple update function over many small "
"time steps."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:528
#, markdown-text
msgid ""
"We can do this by creating a mutable reference cell to hold the position and "
"velocity of the particle, and then using a `for` loop to update the value "
"stored in that cell:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:529
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Monad.ST.Ref (modify, new, read)\n"
"import Control.Monad.ST (ST, for, run)\n"
"\n"
"simulate :: forall r. Number -> Number -> Int -> ST r Number\n"
"simulate x0 v0 time = do\n"
"  ref <- new { x: x0, v: v0 }\n"
"  for 0 (time * 1000) \\_ ->\n"
"    modify\n"
"      ( \\o ->\n"
"          { v: o.v - 9.81 * 0.001\n"
"          , x: o.x + o.v * 0.001\n"
"          }\n"
"      )\n"
"      ref\n"
"  final <- read ref\n"
"  pure final.x\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:551
#, markdown-text
msgid ""
"At the end of the computation, we read the final value of the reference cell "
"and return the position of the particle."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:553
#, markdown-text
msgid ""
"Note that even though this function uses a mutable state, it is still a pure "
"function, so long as the reference cell `ref` is not allowed to be used by "
"other program parts. We will see that this is exactly what the `ST` effect "
"disallows."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:555
#, markdown-text
msgid ""
"To run a computation with the `ST` effect, we have to use the `run` "
"function:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:556
#, no-wrap
msgid "run :: forall a. (forall r. ST r a) -> a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:561
#, markdown-text
msgid ""
"The thing to notice here is that the region type `r` is quantified _inside "
"the parentheses_ on the left of the function arrow. That means that whatever "
"action we pass to `run` has to work with _any region_ `r` whatsoever."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:563
#, markdown-text
msgid ""
"However, once a reference cell has been created by `new`, its region type is "
"already fixed, so it would be a type error to try to use the reference cell "
"outside the code delimited by `run`.  This allows `run` to safely remove the "
"`ST` effect and turn `simulate` into a pure function!"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:564
#, no-wrap
msgid ""
"simulate' :: Number -> Number -> Int -> Number\n"
"simulate' x0 v0 time = run (simulate x0 v0 time)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:570
#, markdown-text
msgid "You can even try running this function in PSCi:"
msgstr ""

#. type: Fenced code block (text)
#: ../text/chapter8.md:571
#, no-wrap
msgid ""
"> import Main\n"
"\n"
"> simulate' 100.0 0.0 0\n"
"100.00\n"
"\n"
"> simulate' 100.0 0.0 1\n"
"95.10\n"
"\n"
"> simulate' 100.0 0.0 2\n"
"80.39\n"
"\n"
"> simulate' 100.0 0.0 3\n"
"55.87\n"
"\n"
"> simulate' 100.0 0.0 4\n"
"21.54\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:591
#, markdown-text
msgid ""
"In fact, if we inline the definition of `simulate` at the call to `run`, as "
"follows:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:592
#, no-wrap
msgid ""
"simulate :: Number -> Number -> Int -> Number\n"
"simulate x0 v0 time =\n"
"  run do\n"
"    ref <- new { x: x0, v: v0 }\n"
"    for 0 (time * 1000) \\_ ->\n"
"      modify\n"
"        ( \\o ->\n"
"            { v: o.v - 9.81 * 0.001\n"
"            , x: o.x + o.v * 0.001\n"
"            }\n"
"        )\n"
"        ref\n"
"    final <- read ref\n"
"    pure final.x\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:610
#, markdown-text
msgid ""
"Then the compiler will notice that the reference cell cannot escape its "
"scope and can safely turn `ref` into a `var`. Here is the generated "
"JavaScript for `simulate` inlined with `run`:"
msgstr ""

#. type: Fenced code block (javascript)
#: ../text/chapter8.md:611
#, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return (function __do() {\n"
"\n"
"        var ref = { value: { x: x0, v: v0 } };\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) "
"{\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        return ref.value.x;\n"
"\n"
"      })();\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:637
#, markdown-text, no-wrap
msgid ""
"> Note that this resulting JavaScript is not as optimal as it could be. See "
"[this "
"issue](https://github.com/purescript-contrib/purescript-book/issues/121) for "
"more details. The above snippet should be updated once that issue is "
"resolved.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:639
#, markdown-text
msgid "For comparison, this is the generated JavaScript of the non-inlined form:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter8.md:640
#, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return function __do() {\n"
"\n"
"        var ref = Control_Monad_ST_Internal[\"new\"]({ x: x0, v: v0 })();\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) "
"{\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        var $$final = Control_Monad_ST_Internal.read(ref)();\n"
"        return $$final.x;\n"
"      };\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:666
#, markdown-text
msgid ""
"The `ST` effect is a good way to generate short JavaScript when working with "
"locally-scoped mutable state, especially when used together with actions "
"like `for`, `foreach`, and `while`, which generate efficient loops."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter8.md:672
#, markdown-text
msgid ""
"(Medium) Rewrite the `safeDivide` function as `exceptionDivide` and throw an "
"exception using `throwException` with the message `\"div zero\"` if the "
"denominator is zero."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter8.md:672
#, markdown-text
msgid ""
"(Medium) Write a function `estimatePi :: Int -> Number` that uses `n` terms "
"of the [Gregory Series](https://mathworld.wolfram.com/GregorySeries.html) to "
"calculate an approximation of `pi`. _Hints:_ You can pattern your answer "
"like the definition of `simulate` above. You might need to convert an `Int` "
"into a `Number` using `toNumber :: Int -> Number` from `Data.Int`."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter8.md:672
#, markdown-text
msgid ""
"(Medium) Write a function `fibonacci :: Int -> Int` to compute the `n`th "
"Fibonacci number, using `ST` to track the values of the previous two "
"Fibonacci numbers. Using PSCi, compare the speed of your new `ST`-based "
"implementation against the recursive implementation (`fib`) from Chapter 5."
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:673
#, markdown-text, no-wrap
msgid "DOM Effects"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:676
#, markdown-text
msgid ""
"In the final sections of this chapter, we will apply what we have learned "
"about effects in the `Effect` monad to the problem of working with the DOM."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:678
#, markdown-text
msgid ""
"There are several PureScript packages for working directly with the DOM or "
"open-source DOM libraries. For example:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:682
#, markdown-text
msgid ""
"[`web-dom`](https://github.com/purescript-web/purescript-web-dom) provides "
"type definitions and low-level interface implementations for the W3C DOM "
"spec."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:682
#, markdown-text
msgid ""
"[`web-html`](https://github.com/purescript-web/purescript-web-html) provides "
"type definitions and low-level interface implementations for the W3C HTML5 "
"spec."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:682
#, markdown-text
msgid ""
"[`jquery`](https://github.com/paf31/purescript-jquery) is a set of bindings "
"to the [jQuery](http://jquery.org) library."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:684
#, markdown-text
msgid ""
"There are also PureScript libraries that build abstractions on top of these "
"libraries, such as"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:688
#, markdown-text
msgid ""
"[`thermite`](https://github.com/paf31/purescript-thermite) builds on "
"[`react`](https://github.com/purescript-contrib/purescript-react)"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:688
#, markdown-text
msgid ""
"[`react-basic-hooks`](https://github.com/megamaddu/purescript-react-basic-hooks) "
"builds on [`react-basic`](https://github.com/lumihq/purescript-react-basic)"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:688
#, markdown-text
msgid ""
"[`halogen`](https://github.com/purescript-halogen/purescript-halogen) "
"provides a type-safe set of abstractions on top of a custom virtual DOM "
"library."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:690
#, markdown-text
msgid ""
"In this chapter, we will use the `react-basic-hooks` library to add a user "
"interface to our address book application, but the interested reader is "
"encouraged to explore alternative approaches."
msgstr ""

#. type: Title ##
#: ../text/chapter8.md:691
#, markdown-text, no-wrap
msgid "An Address Book User Interface"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:694
#, markdown-text
msgid ""
"Using the `react-basic-hooks` library, we will define our application as a "
"React _component_. React components describe HTML elements in code as pure "
"data structures, which are then efficiently rendered to the DOM. In "
"addition, components can respond to events like button clicks. The "
"`react-basic-hooks` library uses the `Effect` monad to describe how to "
"handle these events."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:696
#, markdown-text
msgid ""
"A full tutorial for the React library is well beyond the scope of this "
"chapter, but the reader is encouraged to consult its documentation where "
"needed. For our purposes, React will provide a practical example of the "
"`Effect` monad."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:698
#, markdown-text
msgid ""
"We are going to build a form that will allow a user to add a new entry into "
"our address book. The form will contain text boxes for the various fields "
"(first name, last name, city, state, etc.) and an area where validation "
"errors will be displayed. As the user types text into the text boxes, the "
"validation errors will be updated."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:700
#, markdown-text
msgid ""
"To keep things simple, the form will have a fixed shape: the different phone "
"number types (home, cell, work, other) will be expanded into separate text "
"boxes."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:702
#, markdown-text
msgid ""
"You can launch the web app from the `exercises/chapter8` directory with the "
"following commands:"
msgstr ""

#. type: Fenced code block (shell)
#: ../text/chapter8.md:703
#, no-wrap
msgid ""
"$ npm install\n"
"$ npx spago build\n"
"$ npx parcel src/index.html --open\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:710
#, markdown-text
msgid ""
"If development tools such as `spago` and `parcel` are installed globally, "
"then the `npx` prefix may be omitted. You have likely already installed "
"`spago` globally with `npm i -g spago`, and the same can be done for "
"`parcel`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:712
#, markdown-text
msgid ""
"`parcel` should launch a browser window with our \"Address Book\" app. If "
"you keep the `parcel` terminal open and rebuild with `spago` in another "
"terminal, the page should automatically refresh with your latest edits. You "
"can also configure automatic rebuilds (and therefore automatic page refresh) "
"on file-save if you're using an "
"[editor](https://github.com/purescript/documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors) "
"that supports [`purs "
"ide`](https://github.com/purescript/purescript/tree/master/psc-ide) or are "
"running [`pscid`](https://github.com/kRITZCREEK/pscid)."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:714
#, markdown-text
msgid ""
"In this Address Book app, you can enter some values into the form fields and "
"see the validation errors printed onto the page."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:716
#, markdown-text
msgid "Let's explore how it works."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:718
#, markdown-text
msgid "The `src/index.html` file is minimal:"
msgstr ""

#. type: Fenced code block (html)
#: ../text/chapter8.md:719
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.html}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:724
#, markdown-text, no-wrap
msgid ""
"The `<script` line includes the JavaScript entry point, `index.js`, which "
"contains this single line:\n"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter8.md:725
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.js}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:730
#, markdown-text
msgid ""
"It calls our generated JavaScript equivalent of the `main` function of "
"`module Main` (`src/main.purs`). Recall that `spago build` puts all "
"generated JavaScript in the `output` directory."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:732
#, markdown-text
msgid ""
"The `main` function uses the DOM and HTML APIs to render our address book "
"component within the `container` element we defined in `index.html`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:733
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:main}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:738
#, markdown-text
msgid "Note that these three lines:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:739
#, no-wrap
msgid ""
"w <- window\n"
"doc <- document w\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:746
#, markdown-text
msgid "Can be consolidated to:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:747
#, no-wrap
msgid ""
"doc <- document =<< window\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:753
#, markdown-text
msgid "Or consolidated even further to:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:754
#, no-wrap
msgid ""
"ctr <- getElementById \"container\" <<< toNonElementParentNode =<< document "
"=<< window\n"
"-- or, equivalently:\n"
"ctr <- window >>= document >>= toNonElementParentNode >>> getElementById "
"\"container\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:761
#, markdown-text
msgid ""
"It is a matter of personal preference whether the intermediate `w` and `doc` "
"variables aid in readability."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:763
#, markdown-text
msgid ""
"Let's dig into our AddressBook `reactComponent`. We'll start with a "
"simplified component and then build up to the actual code in `Main.purs`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:765
#, markdown-text
msgid ""
"Take a look at this minimal component. Feel free to substitute the full "
"component with this one to see it run:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:766
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp =\n"
"  reactComponent\n"
"    \"AddressBookApp\"\n"
"    (\\props -> pure $ D.text \"Hi! I'm an address book\")\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:775
#, markdown-text
msgid "`reactComponent` has this intimidating signature:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:776
#, no-wrap
msgid ""
"reactComponent ::\n"
"  forall hooks props.\n"
"  Lacks \"children\" props =>\n"
"  Lacks \"key\" props =>\n"
"  Lacks \"ref\" props =>\n"
"  String ->\n"
"  ({ | props } -> Render Unit hooks JSX) ->\n"
"  Effect (ReactComponent { | props })\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:788
#, markdown-text
msgid ""
"The important points to note are the arguments after all the type class "
"constraints. It takes a `String` (an arbitrary component name), a function "
"that describes how to convert `props` into rendered `JSX`, and returns our "
"`ReactComponent` wrapped in an `Effect`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:790
#, markdown-text
msgid "The props-to-JSX function is simply:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:791
#, no-wrap
msgid "\\props -> pure $ D.text \"Hi! I'm an address book\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:796
#, markdown-text
msgid ""
"`props` are ignored, `D.text` returns `JSX`, and `pure` lifts to rendered "
"JSX. Now `component` has everything it needs to produce the "
"`ReactComponent`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:798
#, markdown-text
msgid ""
"Next, we'll examine some of the additional complexities of the full Address "
"Book component."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:800
#, markdown-text
msgid "These are the first few lines of our full component:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:801
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp = do\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState examplePerson\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:809
#, markdown-text
msgid "We track `person` as a piece of state with the `useState` hook."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:810
#, no-wrap
msgid "Tuple person setPerson <- useState examplePerson\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:815
#, markdown-text
msgid ""
"Note that you are free to break-up component state into multiple pieces of "
"state with multiple calls to `useState`. For example, we could rewrite this "
"app to use a separate piece of state for each record field of `Person`, but "
"that results in a slightly less convenient architecture in this case."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:817
#, markdown-text
msgid ""
"In other examples, you may encounter the `/\\` infix operator for "
"`Tuple`. This is equivalent to the above line:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:818
#, no-wrap
msgid "firstName /\\ setFirstName <- useState p.firstName\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:823
#, markdown-text
msgid ""
"`useState` takes a default initial value and returns the current value and a "
"way to update the value. We can check the type of `useState` to gain more "
"insight of the types `person` and `setPerson`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:824
#, no-wrap
msgid ""
"useState ::\n"
"  forall state.\n"
"  state ->\n"
"  Hook (UseState state) (Tuple state ((state -> state) -> Effect Unit))\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:832
#, markdown-text
msgid ""
"We can strip the `Hook (UseState state)` wrapper off of the return value "
"because `useState` is called within an `R.do` block. We'll elaborate on "
"`R.do` later."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:834
#, markdown-text
msgid "So now we can observe the following signatures:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:835
#, no-wrap
msgid ""
"person :: state\n"
"setPerson :: (state -> state) -> Effect Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:841
#, markdown-text
msgid ""
"The specific type of `state` is determined by our initial default "
"value. `Person` `Record` in this case because that is the type of "
"`examplePerson`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:843
#, markdown-text
msgid "`person` is how we access the current state at each rerender."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:845
#, markdown-text
msgid ""
"`setPerson` is how we update the state. We provide a function describing how "
"to transform the current state into the new one. The record update syntax is "
"perfect for this when the type of `state` happens to be a `Record`, for "
"example:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:846
#, no-wrap
msgid ""
"setPerson (\\currentPerson -> currentPerson {firstName = \"NewName\"})\n"
"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:852
#, markdown-text
msgid "Or as shorthand:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:853
#, no-wrap
msgid "setPerson _ {firstName = \"NewName\"}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:858
#, markdown-text
msgid ""
"Non-`Record` states can also follow this update pattern. See [this "
"guide](https://github.com/megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541) "
"for more details on best practices."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:860
#, markdown-text
msgid ""
"Recall that `useState` is used within an `R.do` block. `R.do` is a special "
"react hooks variant of `do`. The `R.` prefix \"qualifies\" this as coming "
"from `React.Basic.Hooks`, and means we use their hooks-compatible version of "
"`bind` in the `R.do` block. This is known as a \"qualified do\". It lets us "
"ignore the `Hook (UseState state)` wrapping and bind the inner `Tuple` of "
"values to variables."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:862
#, markdown-text
msgid ""
"Another possible state management strategy is with `useReducer`, but that is "
"outside the scope of this chapter."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:864
#, markdown-text
msgid "Rendering `JSX` occurs here:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:865
#, no-wrap
msgid ""
"pure\n"
"  $ D.div\n"
"      { className: \"container\"\n"
"      , children:\n"
"          renderValidationErrors errors\n"
"            <> [ D.div\n"
"                  { className: \"row\"\n"
"                  , children:\n"
"                      [ D.form_\n"
"                          $ [ D.h3_ [ D.text \"Basic Information\" ]\n"
"                            , formField \"First Name\" \"First Name\" "
"person.firstName \\s ->\n"
"                                setPerson _ { firstName = s }\n"
"                            , formField \"Last Name\" \"Last Name\" "
"person.lastName \\s ->\n"
"                                setPerson _ { lastName = s }\n"
"                            , D.h3_ [ D.text \"Address\" ]\n"
"                            , formField \"Street\" \"Street\" "
"person.homeAddress.street \\s ->\n"
"                                setPerson _ { homeAddress { street = s } }\n"
"                            , formField \"City\" \"City\" "
"person.homeAddress.city \\s ->\n"
"                                setPerson _ { homeAddress { city = s } }\n"
"                            , formField \"State\" \"State\" "
"person.homeAddress.state \\s ->\n"
"                                setPerson _ { homeAddress { state = s } }\n"
"                            , D.h3_ [ D.text \"Contact Information\" ]\n"
"                            ]\n"
"                          <> renderPhoneNumbers\n"
"                      ]\n"
"                  }\n"
"              ]\n"
"      }\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:897
#, markdown-text
msgid ""
"Here we produce `JSX`, which represents the intended state of the DOM. This "
"JSX is typically created by applying functions corresponding to HTML tags "
"(e.g., `div`, `form`, `h3`, `li`, `ul`, `label`, `input`) which create "
"single HTML elements. These HTML elements are React components themselves, "
"converted to JSX. There are usually three variants of each of these "
"functions:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:901
#, markdown-text
msgid "`div_`: Accepts an array of child elements. Uses default attributes."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:901
#, markdown-text
msgid ""
"`div`: Accepts a `Record` of attributes. An array of child elements may be "
"passed to the `children` field of this record."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:901
#, markdown-text
msgid ""
"`div'`: Same as `div`, but returns the `ReactComponent` before conversion to "
"`JSX`."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:903
#, markdown-text
msgid ""
"To display validation errors (if any) at the top of our form, we create a "
"`renderValidationErrors` helper function that turns the `Errors` structure "
"into an array of JSX. This array is prepended to the rest of our form."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:904
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:renderValidationErrors}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:909
#, markdown-text
msgid ""
"Note that since we are simply manipulating regular data structures here, we "
"can use functions like `map` to build up more interesting elements:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:910
#, no-wrap
msgid "children: [ D.ul_ (map renderError xs)]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:915
#, markdown-text
msgid ""
"We use the `className` property to define classes for CSS styling. We're "
"using the [Bootstrap](https://getbootstrap.com/) `stylesheet` for this "
"project, which is imported in `index.html`. For example, we want items in "
"our form arranged as `row`s, and validation errors to be emphasized with "
"`alert-danger` styling:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:916
#, no-wrap
msgid "className: \"alert alert-danger row\"\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:921
#, markdown-text
msgid ""
"A second helper function is `formField`, which creates a text input for a "
"single form field:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:922
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:formField}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:927
#, markdown-text
msgid ""
"Putting the `input` and display `text` in a `label` aids in accessibility "
"for screen readers."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:929
#, markdown-text
msgid ""
"The `onChange` attribute allows us to describe how to respond to user "
"input. We use the `handler` function, which has the following type:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:930
#, no-wrap
msgid ""
"handler :: forall a. EventFn SyntheticEvent a -> (a -> Effect Unit) -> "
"EventHandler\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:935
#, markdown-text
msgid ""
"For the first argument to `handler` we use `targetValue`, which provides the "
"value of the text within the HTML `input` element. It matches the signature "
"expected by `handler` where the type variable `a` in this case is `Maybe "
"String`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:936
#, no-wrap
msgid "targetValue :: EventFn SyntheticEvent (Maybe String)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:941
#, markdown-text
msgid ""
"In JavaScript, the `input` element's `onChange` event is accompanied by a "
"`String` value, but since strings in JavaScript can be null, `Maybe` is used "
"for safety."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:943
#, markdown-text, no-wrap
msgid ""
"The second argument to `handler`, `(a -> Effect Unit)`, must therefore have "
"this signature:\n"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:944
#, no-wrap
msgid "Maybe String -> Effect Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:949
#, markdown-text
msgid ""
"It is a function that describes how to convert this `Maybe String` value "
"into our desired effect. We define a custom `handleValue` function for this "
"purpose and pass it to `handler` as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:950
#, no-wrap
msgid ""
"onChange:\n"
"  let\n"
"    handleValue :: Maybe String -> Effect Unit\n"
"    handleValue (Just v) = setValue v\n"
"    handleValue Nothing  = pure unit\n"
"  in\n"
"    handler targetValue handleValue\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:961
#, markdown-text
msgid ""
"`setValue` is the function we provided to each `formField` call that takes a "
"string and makes the appropriate record-update call to the `setPerson` hook."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:963
#, markdown-text
msgid "Note that `handleValue` can be substituted as:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter8.md:964
#, no-wrap
msgid "onChange: handler targetValue $ traverse_ setValue\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:969
#, markdown-text
msgid ""
"Feel free to investigate the definition of `traverse_` to see how both forms "
"are indeed equivalent."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:971
#, markdown-text
msgid ""
"That covers the basics of our component implementation. However, you should "
"read the source accompanying this chapter to get a full understanding of the "
"way the component works."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:973
#, markdown-text
msgid ""
"Obviously, this user interface can be improved in a number of ways. The "
"exercises will explore some ways in which we can make the application more "
"usable."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:977
#, markdown-text
msgid ""
"Modify `src/Main.purs` in the following exercises. There are no unit tests "
"for these exercises."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter8.md:980
#, markdown-text
msgid "(Easy) Modify the application to include a work phone number text box."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter8.md:980
#, markdown-text
msgid ""
"(Medium) Right now, the application shows validation errors collected in a "
"single \"pink-alert\" background.  Modify to give each validation error its "
"own pink-alert background by separating them with blank lines."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:983
#, markdown-text, no-wrap
msgid ""
"    _Hint_: Instead of using a `ul` element to show the validation errors in "
"a list, modify the code to create one `div` with the `alert` and "
"`alert-danger` styles for each error.\n"
"1. (Difficult, Extended) One problem with this user interface is that the "
"validation errors are not displayed next to the form fields they originated "
"from. Modify the code to fix this problem.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:985
#, markdown-text, no-wrap
msgid ""
"    _Hint_: The error type returned by the validator should be extended to "
"indicate which field caused the error. You might want to use the following "
"modified `Errors` type:\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:993
#, markdown-text, no-wrap
msgid ""
"    ```hs\n"
"    data Field = FirstNameField\n"
"               | LastNameField\n"
"               | StreetField\n"
"               | CityField\n"
"               | StateField\n"
"               | PhoneField PhoneType\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:995
#, markdown-text, no-wrap
msgid "    data ValidationError = ValidationError String Field\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:998
#, markdown-text, no-wrap
msgid ""
"    type Errors = Array ValidationError\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:1000
#, markdown-text, no-wrap
msgid ""
"    You will need to write a function that extracts the validation error for "
"a particular `Field` from the `Errors` structure.\n"
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:1004
#, markdown-text
msgid ""
"This chapter has covered a lot of ideas about handling side-effects in "
"PureScript:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:1011
#, markdown-text
msgid "We met the `Monad` type class and its connection to do notation."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:1011
#, markdown-text
msgid ""
"We introduced the monad laws and saw how they allow us to transform code "
"written using do notation."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:1011
#, markdown-text
msgid ""
"We saw how monads can be used abstractly to write code that works with "
"different side-effects."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:1011
#, markdown-text
msgid ""
"We saw how monads are examples of applicative functors, how both allow us to "
"compute with side-effects, and the differences between the two approaches."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:1011
#, markdown-text
msgid ""
"The concept of native effects was defined, and we met the `Effect` monad, "
"which handles native side-effects."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter8.md:1011
#, markdown-text
msgid ""
"We used the `Effect` monad to handle a variety of effects: random number "
"generation, exceptions, console IO, mutable state, and DOM manipulation "
"using React."
msgstr ""

#. type: Plain text
#: ../text/chapter8.md:1012
#, markdown-text
msgid ""
"The `Effect` monad is a fundamental tool in real-world PureScript code. It "
"will be used in the rest of the book to handle side-effects in a number of "
"other use-cases."
msgstr ""

#. type: Title #
#: ../text/chapter9.md:1
#, markdown-text, no-wrap
msgid "Asynchronous Effects"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:6
#, markdown-text
msgid ""
"This chapter focuses on the `Aff` monad, which is similar to the `Effect` "
"monad, but represents _asynchronous_ side-effects. We'll demonstrate "
"examples of asynchronously interacting with the filesystem and making HTTP "
"requests. We'll also cover managing sequential and parallel execution of "
"asynchronous effects."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:10
#, markdown-text
msgid "New PureScript libraries introduced in this chapter are:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:15
#, markdown-text
msgid "`aff` - defines the `Aff` monad."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:15
#, markdown-text
msgid "`node-fs-aff` - asynchronous filesystem operations with `Aff`."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:15
#, markdown-text
msgid "`affjax` - HTTP requests with AJAX and `Aff`."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:15
#, markdown-text
msgid "`parallel` - parallel execution of `Aff`."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:17
#, markdown-text
msgid ""
"When running outside of the browser (such as in our Node.js environment), "
"the `affjax` library requires the `xhr2` NPM module, which is listed as a "
"dependency in the `package.json` of this chapter. Install that by running:"
msgstr ""

#. type: Fenced code block (shell)
#: ../text/chapter9.md:18
#, no-wrap
msgid "$ npm install\n"
msgstr ""

#. type: Title ##
#: ../text/chapter9.md:22
#, markdown-text, no-wrap
msgid "Asynchronous JavaScript"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:25
#, markdown-text
msgid ""
"A convenient way to work with asynchronous code in JavaScript is with "
"[`async` and "
"`await`](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await). "
"See [this article on asynchronous "
"JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing) "
"for more background information."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:27
#, markdown-text
msgid ""
"Here is an example of using this technique to copy the contents of one file "
"to another file:"
msgstr ""

#. type: Fenced code block (js)
#: ../text/chapter9.md:28
#, no-wrap
msgid ""
"import { promises as fsPromises } from 'fs'\n"
"\n"
"async function copyFile(file1, file2) {\n"
"  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });\n"
"  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });\n"
"}\n"
"\n"
"copyFile('file1.txt', 'file2.txt')\n"
".catch(e => {\n"
"  console.log('There was a problem with copyFile: ' + e.message);\n"
"});\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:43
#, markdown-text
msgid ""
"It is also possible to use callbacks or synchronous functions, but those are "
"less desirable because:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:46
#, markdown-text
msgid ""
"Callbacks lead to excessive nesting, known as \"Callback Hell\" or the "
"\"Pyramid of Doom\"."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:46
#, markdown-text
msgid "Synchronous functions block execution of the other code in your app."
msgstr ""

#. type: Title ##
#: ../text/chapter9.md:47
#, markdown-text, no-wrap
msgid "Asynchronous PureScript"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:50
#, markdown-text
msgid ""
"The `Aff` monad in PureScript offers similar ergonomics of JavaScript's "
"`async`/`await` syntax. Here is the same `copyFile` example from before, but "
"rewritten in PureScript using `Aff`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:51
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/Copy.purs:copyFile}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:56
#, markdown-text
msgid ""
"Note that we have to use `launchAff_` to convert the `Aff` to `Effect` "
"because `main` must be `Effect Unit`."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:58
#, markdown-text
msgid ""
"It is also possible to re-write the above snippet using callbacks or "
"synchronous functions (for example, with `Node.FS.Async` and `Node.FS.Sync`, "
"respectively), but those share the same downsides as discussed earlier with "
"JavaScript, so that coding style is not recommended."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:60
#, markdown-text
msgid ""
"The syntax for working with `Aff` is very similar to working with "
"`Effect`. They are both monads and can therefore be written with do "
"notation."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:62
#, markdown-text
msgid ""
"For example, if we look at the signature of `readTextFile`, we see that it "
"returns the file contents as a `String` wrapped in `Aff`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:63
#, no-wrap
msgid "readTextFile :: Encoding -> FilePath -> Aff String\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:68
#, markdown-text, no-wrap
msgid ""
"We can \"unwrap\" the returned string with a bind arrow (`<-`) in do "
"notation:\n"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:69
#, no-wrap
msgid "my_data <- readTextFile UTF8 file1\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:74
#, markdown-text
msgid "Then pass it as the string argument to `writeTextFile`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:75
#, no-wrap
msgid "writeTextFile :: Encoding -> FilePath -> String -> Aff Unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:80
#, markdown-text
msgid ""
"The only other notable feature unique to `Aff` in the above example is "
"`attempt`, which captures errors or exceptions encountered while running "
"`Aff` code and stores them in an `Either`:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:81
#, no-wrap
msgid "attempt :: forall a. Aff a -> Aff (Either Error a)\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:86
#, markdown-text
msgid ""
"You should hopefully be able to draw on your knowledge of concepts from "
"previous chapters and combine this with the new `Aff` patterns learned in "
"the above `copyFile` example to tackle the following exercises:"
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter9.md:90
#, markdown-text
msgid "(Easy) Write a `concatenateFiles` function that concatenates two text files."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter9.md:92
#, markdown-text
msgid ""
"(Medium) Write a function `concatenateMany` to concatenate multiple text "
"files, given an array of input and output file names. _Hint_: use "
"`traverse`."
msgstr ""

#. type: Bullet: ' 1. '
#: ../text/chapter9.md:94
#, markdown-text
msgid ""
"(Medium) Write a function `countCharacters :: FilePath -> Aff (Either Error "
"Int)` that returns the number of characters in a file, or an error if one is "
"encountered."
msgstr ""

#. type: Title ##
#: ../text/chapter9.md:95
#, markdown-text, no-wrap
msgid "Additional Aff Resources"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:98
#, markdown-text
msgid ""
"If you haven't already looked at the [official Aff "
"guide](https://pursuit.purescript.org/packages/purescript-aff/), skim "
"through that now. It's not a direct prerequisite for completing the "
"remaining exercises in this chapter, but you may find it helpful to lookup "
"some functions on Pursuit."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:100
#, markdown-text
msgid ""
"You're also welcome to consult these supplemental resources too, but again, "
"the exercises in this chapter don't depend on them:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:103
#, markdown-text
msgid "[Drew's Aff Post](https://blog.drewolson.org/asynchronous-purescript)"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:103
#, markdown-text
msgid ""
"[Additional Aff Explanation and "
"Examples](https://github.com/JordanMartinez/purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff)"
msgstr ""

#. type: Title ##
#: ../text/chapter9.md:104
#, markdown-text, no-wrap
msgid "A HTTP Client"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:107
#, markdown-text
msgid ""
"The `affjax` library offers a convenient way to make asynchronous AJAX HTTP "
"requests with `Aff`. Depending on what environment you are targeting, you "
"need to use either the "
"[purescript-affjax-web](https://github.com/purescript-contrib/purescript-affjax-web) "
"or the "
"[purescript-affjax-node](https://github.com/purescript-contrib/purescript-affjax-node) "
"library."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:110
#, markdown-text
msgid ""
"In the rest of this chapter, we will be targeting node and thus using "
"`purescript-affjax-node`.  Consult the [Affjax "
"docs](https://pursuit.purescript.org/packages/purescript-affjax) for more "
"usage information. Here is an example that makes HTTP GET requests at a "
"provided URL and returns the response body or an error message:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:111
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/HTTP.purs:getUrl}}\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:116
#, markdown-text
msgid ""
"When calling this in the repl, `launchAff_` is required to convert the `Aff` "
"to a repl-compatible `Effect`:"
msgstr ""

#. type: Fenced code block (shell)
#: ../text/chapter9.md:117
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :pa\n"
"… import Prelude\n"
"… import Effect.Aff (launchAff_)\n"
"… import Effect.Class.Console (log)\n"
"… import Test.HTTP (getUrl)\n"
"…\n"
"… launchAff_ do\n"
"…   str <- getUrl \"https://reqres.in/api/users/1\"\n"
"…   log str\n"
"…\n"
"unit\n"
"{\"data\":{\"id\":1,\"email\":\"george.bluth@reqres.in\",\"first_name\":\"George\",\"last_name\":\"Bluth\", "
"...}}\n"
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter9.md:137
#, markdown-text
msgid ""
"(Easy) Write a function `writeGet` which makes an HTTP `GET` request to a "
"provided url, and writes the response body to a file."
msgstr ""

#. type: Title ##
#: ../text/chapter9.md:138
#, markdown-text, no-wrap
msgid "Parallel Computations"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:141
#, markdown-text
msgid ""
"We've seen how to use the `Aff` monad and do notation to compose "
"asynchronous computations in sequence. It would also be useful to be able to "
"compose asynchronous computations _in parallel_. With `Aff`, we can compute "
"in parallel simply by initiating our two computations one after the other."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:143
#, markdown-text
msgid ""
"The `parallel` package defines a type class `Parallel` for monads like "
"`Aff`, which support parallel execution. When we met applicative functors "
"earlier in the book, we observed how applicative functors can be useful for "
"combining parallel computations. In fact, an instance for `Parallel` defines "
"a correspondence between a monad `m` (such as `Aff`) and an applicative "
"functor `f` that can be used to combine computations in parallel:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:144
#, no-wrap
msgid ""
"class (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n"
"  sequential :: forall a. f a -> m a\n"
"  parallel :: forall a. m a -> f a\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:151
#, markdown-text
msgid "The class defines two functions:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:154
#, markdown-text
msgid ""
"`parallel`, which takes computations in the monad `m` and turns them into "
"computations in the applicative functor `f`, and"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:154
#, markdown-text
msgid "`sequential`, which performs a conversion in the opposite direction."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:156
#, markdown-text
msgid ""
"The `aff` library provides a `Parallel` instance for the `Aff` monad. It "
"uses mutable references to combine `Aff` actions in parallel by keeping "
"track of which of the two continuations has been called. When both results "
"have been returned, we can compute the final result and pass it to the main "
"continuation."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:158
#, markdown-text
msgid ""
"Because applicative functors support lifting of functions of arbitrary "
"arity, we can perform more computations in parallel by using the applicative "
"combinators. We can also benefit from all of the standard library functions "
"which work with applicative functors, such as `traverse` and `sequence`!"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:160
#, markdown-text
msgid ""
"We can also combine parallel computations with sequential portions of code "
"by using applicative combinators in a do notation block, or vice versa, "
"using `parallel` and `sequential` to change type constructors where "
"appropriate."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:164
#, markdown-text
msgid ""
"To demonstrate the difference between sequential and parallel execution, "
"we'll create an array of 100 10-millisecond delays, then execute those "
"delays with both techniques.  You'll notice in the repl that `seqDelay` is "
"much slower than `parDelay`.  Note that parallel execution is enabled by "
"simply replacing `sequence_` with `parSequence_`."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:165
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelDelay.purs:delays}}\n"
msgstr ""

#. type: Fenced code block (shell)
#: ../text/chapter9.md:169
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelDelay\n"
"\n"
"> seqDelay -- This is slow\n"
"unit\n"
"\n"
"> parDelay -- This is fast\n"
"unit\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:182
#, markdown-text
msgid ""
"Here's a more real-world example of making multiple HTTP requests in "
"parallel. We're reusing our `getUrl` function to fetch information from two "
"users in parallel. Note that `parTraverse` (the parallel version of "
"`traverse`) is used in this case. This example would also work fine with "
"`traverse` instead, but it will be slower."
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:183
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelFetch.purs:fetchPar}}\n"
msgstr ""

#. type: Fenced code block (shell)
#: ../text/chapter9.md:187
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelFetch\n"
"\n"
"> fetchPar\n"
"unit\n"
"[\"{\\\"data\\\":{\\\"id\\\":1,\\\"email\\\":\\\"george.bluth@reqres.in\\\", "
"... }\"\n"
",\"{\\\"data\\\":{\\\"id\\\":2,\\\"email\\\":\\\"janet.weaver@reqres.in\\\", "
"... }\"\n"
"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:200
#, markdown-text
msgid ""
"A full listing of available parallel functions can be found in the "
"[`parallel` docs on "
"Pursuit](https://pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel). "
"The [aff docs section on "
"parallel](https://github.com/purescript-contrib/purescript-aff#parallel-execution) "
"also contains more examples."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter9.md:204
#, markdown-text
msgid ""
"(Easy) Write a `concatenateManyParallel` function with the same signature as "
"the earlier `concatenateMany` function but reads all input files in "
"parallel."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter9.md:208
#, markdown-text
msgid ""
"(Medium) Write a `getWithTimeout :: Number -> String -> Aff (Maybe String)` "
"function which makes an HTTP `GET` request at the provided URL and returns "
"either:"
msgstr ""

#. type: Bullet: '    - '
#: ../text/chapter9.md:208
#, markdown-text
msgid ""
"`Nothing`: if the request takes longer than the provided timeout (in "
"milliseconds)."
msgstr ""

#. type: Bullet: '    - '
#: ../text/chapter9.md:208
#, markdown-text
msgid "The string response: if the request succeeds before the timeout elapses."
msgstr ""

#. type: Bullet: '1. '
#: ../text/chapter9.md:210
#, markdown-text
msgid ""
"(Difficult) Write a `recurseFiles` function that takes a \"root\" file and "
"returns an array of all paths listed in that file (and listed in the listed "
"files too). Read listed files in parallel. Paths are relative to the "
"directory of the file they appear in. _Hint:_ The `node-path` module has "
"some helpful functions for negotiating directories."
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:212
#, markdown-text
msgid "For example, if starting from the following `root.txt` file:"
msgstr ""

#. type: Fenced code block (shell)
#: ../text/chapter9.md:213
#, no-wrap
msgid ""
"$ cat root.txt\n"
"a.txt\n"
"b/a.txt\n"
"c/a/a.txt\n"
"\n"
"$ cat a.txt\n"
"b/b.txt\n"
"\n"
"$ cat b/b.txt\n"
"c/a.txt\n"
"\n"
"$ cat b/c/a.txt\n"
"\n"
"$ cat b/a.txt\n"
"\n"
"$ cat c/a/a.txt\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:233
#, markdown-text
msgid "The expected output is:"
msgstr ""

#. type: Fenced code block (hs)
#: ../text/chapter9.md:234
#, no-wrap
msgid "[\"root.txt\",\"a.txt\",\"b/a.txt\",\"b/b.txt\",\"b/c/a.txt\",\"c/a/a.txt\"]\n"
msgstr ""

#. type: Plain text
#: ../text/chapter9.md:241
#, markdown-text
msgid "In this chapter, we covered asynchronous effects and learned how to:"
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:244
#, markdown-text
msgid "Run asynchronous code in the `Aff` monad with the `aff` library."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:244
#, markdown-text
msgid "Make HTTP requests asynchronously with the `affjax` library."
msgstr ""

#. type: Bullet: '- '
#: ../text/chapter9.md:244
#, markdown-text
msgid "Run asynchronous code in parallel with the `parallel` library."
msgstr ""

#. type: Title #
#: ../CONTRIBUTING.md:1
#, markdown-text, no-wrap
msgid "Contributing"
msgstr ""

#. type: Plain text
#: ../CONTRIBUTING.md:4
#, markdown-text
msgid "Please open PRs or Issues if you find anything to improve in the book."
msgstr ""

#. type: Plain text
#: ../CONTRIBUTING.md:6
#, markdown-text
msgid "We appreciate your feedback."
msgstr ""

#. type: Title ##
#: ../CONTRIBUTING.md:7
#, markdown-text, no-wrap
msgid "Editing chapter text"
msgstr ""

#. type: Plain text
#: ../CONTRIBUTING.md:10
#, markdown-text
msgid ""
"To test changes to the text locally, install "
"[mdbook](https://github.com/rust-lang/mdBook), then run this command from "
"repo root:"
msgstr ""

#. type: Fenced code block (sh)
#: ../CONTRIBUTING.md:11
#, no-wrap
msgid "mdbook serve -o\n"
msgstr ""

#. type: Plain text
#: ../CONTRIBUTING.md:15
#, markdown-text
msgid ""
"The rendered webpage will automatically refresh with any changes to readme "
"files."
msgstr ""

# 実例によるPureScript
# Copyright (c) 2014-2017 Phil Freeman.
# Copyright (C) 2015-2018 aratama.
# Copyright (C) 2022 gemmaro.
# This file is distributed under the same license as the original document.
#
# 改行は行毎に入れるようにします。
# つまり、文字数で区切ったり全く入れないようにしたりはしません。
# ただしGettextの折り返しのせいでマークアップが崩れる場合はその限りではありません。
#
# 強調は*で囲みます。
# 全角文字と_は相性が悪いからです。
# なお、原訳では強い強調**を使っていましたが、意味が異なってくるので弱い強調に直しました。
#
msgid ""
msgstr ""
"Project-Id-Version: com.github.gemmaro.purescript-book.v0.1.0\n"
"POT-Creation-Date: 2023-08-25 20:42+0900\n"
"PO-Revision-Date: 2023-08-25 08:51+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

# mdBookのSUMMARY.mdの文言なので訳す必要がありません。
#. type: Title #
#: text/SUMMARY.md:1
#, no-wrap
msgid "Summary"
msgstr "Summary"

#. type: Plain text
#: text/SUMMARY.md:4
msgid "[Foreword](../README.md)"
msgstr "[序文](index.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Introduction](chapter1.md)"
msgstr "[導入](chapter1.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Getting Started](chapter2.md)"
msgstr "[はじめよう](chapter2.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Functions and Records](chapter3.md)"
msgstr "[関数とレコード](chapter3.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Recursion, Maps And Folds](chapter4.md)"
msgstr "[再帰、マップ、畳み込み](chapter4.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Pattern Matching](chapter5.md)"
msgstr "[パターン照合](chapter5.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Type Classes](chapter6.md)"
msgstr "[型クラス](chapter6.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Applicative Validation](chapter7.md)"
msgstr "[アプリカティブによる検証](chapter7.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[The Effect Monad](chapter8.md)"
msgstr "[作用モナド](chapter8.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Asynchronous Effects](chapter9.md)"
msgstr "[非同期作用](chapter9.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[The Foreign Function Interface](chapter10.md)"
msgstr "[外部関数インターフェース](chapter10.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Monadic Adventures](chapter11.md)"
msgstr "[モナドな冒険](chapter11.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Canvas Graphics](chapter12.md)"
msgstr "[Canvasグラフィックス](chapter12.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Generative Testing](chapter13.md)"
msgstr "[テストの自動生成](chapter13.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Domain-Specific Languages](chapter14.md)"
msgstr "[領域特化言語](chapter14.md)"

#. type: Title #
#: README.md:1
#, no-wrap
msgid "PureScript by Example"
msgstr "実例によるPureScript"

#. type: Plain text
#: README.md:4
msgid ""
"This repository contains a [community fork](https://github.com/purescript-"
"contrib/purescript-book/) of _PureScript by Example_ by Phil Freeman, also "
"known as \"the PureScript book\". This version differs from the original in "
"that it has been updated so that the code and exercises work with up-to-date "
"versions of the compiler, libraries, and tools. Some chapters have also been "
"rewritten to showcase the latest features of the PureScript ecosystem."
msgstr ""
"このリポジトリには、Phil Freemanによる*PureScript by Example*の[コミュニティ"
"フォーク](https://github.com/purescript-contrib/purescript-book/)が含まれま"
"す。\n"
"同書は \"The PureScript book\" としても知られています。\n"
"このバージョンはコードと演習が最近のバージョンのコンパイラ、ライブラリ、ツー"
"ルで動くように更新されています。\n"
"PureScriptのエコシステムの最新の機能を紹介すべく書き直された章もあります。"

#. type: Plain text
#: README.md:6
msgid ""
"If you enjoyed the book or found it useful, please consider buying a copy of "
"[the original on Leanpub](https://leanpub.com/purescript)."
msgstr ""
"本書をお楽しみいただき、お役立ちいただけましたら、[Leanpubの原書](https://"
"leanpub.com/purescript)の購入をご検討ください。"

#. type: Title ##
#: README.md:7
#, no-wrap
msgid "Status"
msgstr "現状"

#. type: Plain text
#: README.md:10
msgid ""
"This book is being continuously updated as the language evolves, so please "
"report any [issues](https://github.com/purescript-contrib/purescript-book/"
"issues) you discover with the material. We appreciate any feedback you have "
"to share, even if it's as simple as pointing out a confusing section that we "
"could make more beginner-friendly."
msgstr ""
"本書は言語の進化に伴って継続的に更新されているため、内容に関して発見したどん"
"な[問題](https://github.com/purescript-contrib/purescript-book/issues)でもご"
"報告ください。\n"
"より初心者にやさしくできそうな分かりづらい節を指摘するような単純なものであ"
"れ、共有いただいたどんなフィードバックにも感謝します。"

#. type: Plain text
#: README.md:12
msgid ""
"Unit tests are also being added to each chapter so you can check if your "
"answers to the exercises are correct. See [#79](https://github.com/"
"purescript-contrib/purescript-book/issues/79) for the latest status on tests."
msgstr ""
"各章には単体テストも加えられているので、演習への自分の回答が正しいかどうか確"
"かめることができます。\n"
"テストの最新の状態については[#79](https://github.com/purescript-contrib/"
"purescript-book/issues/79)を見てください。"

#. type: Title ##
#: README.md:13
#, no-wrap
msgid "About the Book"
msgstr "本書について"

#. type: Plain text
#: README.md:16
msgid ""
"PureScript is a small, strongly, statically typed programming language with "
"expressive types, written in and inspired by Haskell, and compiling to "
"Javascript."
msgstr ""
"PureScriptは、表現力のある型を持つ、小さくて強力で静的に型付けされたプログラ"
"ミング言語です。\n"
"Haskellで書かれ、またこの言語から着想を得ています。\n"
"そしてJavaScriptにコンパイルされます。"

#. type: Plain text
#: README.md:18
msgid ""
"Functional programming in JavaScript has seen quite a lot of popularity "
"recently, but large-scale application development is hindered by the lack of "
"a disciplined environment in which to write code. PureScript aims to solve "
"that problem by bringing the power of strongly-typed functional programming "
"to the world of JavaScript development."
msgstr ""
"JavaScriptでの関数型プログラミングは最近かなりの人気を誇るようになりました"
"が、コードを書く上で統制された環境が欠けていることが大規模なアプリケーション"
"開発の妨げとなっています。\n"
"PureScriptは、強力に型付けされた関数型プログラミングの力をJavaScriptでの開発"
"の世界に持ち込むことにより、この問題の解決を目指しています。"

#. type: Plain text
#: README.md:20
msgid ""
"This book will show you how to get started with the PureScript programming "
"language, from the basics (setting up a development environment) to the "
"advanced."
msgstr ""
"本書は、基礎（開発環境の立ち上げ）から応用に至るまでの、PureScriptプログラミ"
"ング言語の始め方を示します。"

#. type: Plain text
#: README.md:22
msgid ""
"Each chapter will be motivated by a particular problem, and in the course of "
"solving that problem, new functional programming tools and techniques will "
"be introduced. Here are some examples of problems that will be solved in "
"this book:"
msgstr ""
"各章は特定の課題により動機付けられており、その問題を解いていく過程において、"
"新しい関数型プログラミングの道具と技法が導入されていきます。\n"
"以下は本書で解いていく課題の幾つかの例です。"

#. type: Bullet: '- '
#: README.md:31
msgid "Transforming data structures with maps and folds"
msgstr "マップと畳み込みを使ったデータ構造の変換"

#. type: Bullet: '- '
#: README.md:31
msgid "Form field validation using applicative functors"
msgstr "アプリカティブ関手を使ったフォームフィールドの検証"

#. type: Bullet: '- '
#: README.md:31
msgid "Testing code with QuickCheck"
msgstr "QuickCheckによるコードの検査"

#. type: Bullet: '- '
#: README.md:31
msgid "Using the canvas"
msgstr "Canvasの使用"

#. type: Bullet: '- '
#: README.md:31
msgid "Domain specific language implementation"
msgstr "領域特化言語の実装"

#. type: Bullet: '- '
#: README.md:31
msgid "Working with the DOM"
msgstr "DOMの取り回し"

#. type: Bullet: '- '
#: README.md:31
msgid "JavaScript interoperability"
msgstr "JavaScriptの相互運用性"

#. type: Bullet: '- '
#: README.md:31
msgid "Parallel asynchronous execution"
msgstr "並列非同期実行"

#. type: Title ##
#: README.md:32
#, no-wrap
msgid "License"
msgstr "使用許諾"

#. type: Plain text
#: README.md:35
msgid "Copyright (c) 2014-2017 Phil Freeman."
msgstr "Copyright (c) 2014-2017 Phil Freeman."

#. type: Plain text
#: README.md:37
msgid ""
"The text of this book is licensed under the Creative Commons Attribution-"
"NonCommercial-ShareAlike 3.0 Unported License: <https://creativecommons.org/"
"licenses/by-nc-sa/3.0/deed.en_US>."
msgstr ""
"The text of this book is licensed under the Creative Commons Attribution-"
"NonCommercial-ShareAlike 3.0 Unported License: <https://creativecommons.org/"
"licenses/by-nc-sa/3.0/deed.en_US>.\n"
"\n"
"<small>※以降の原文の使用許諾に関する和訳は法的効力を持ちません。<br>\n"
"本書のテキストは<a href=\"https://creativecommons.org/licenses/by-nc-sa/3.0/"
"deed.ja\">表示 - 非営利 - 継承3.0非移植 (CC BY-NC-SA 3.0)</a>のもとに使用が許"
"諾される。</small>"

#. type: Plain text
#: README.md:39
msgid ""
"Some text is derived from the [PureScript Documentation Repo](https://github."
"com/purescript/documentation), which uses the same license, and is copyright "
"[various contributors](https://github.com/purescript/documentation/blob/"
"master/CONTRIBUTORS.md)."
msgstr ""
"Some text is derived from the [PureScript Documentation Repo](https://github."
"com/purescript/documentation), which uses the same license, and is copyright "
"[various contributors](https://github.com/purescript/documentation/blob/"
"master/CONTRIBUTORS.md).\n"
"\n"
"<small>幾つかのテキストは[PureScriptのドキュメントリポジトリ](https://github."
"com/purescript/documentation)から派生している。\n"
"派生元も同じ使用許諾であり、[様々な形で貢献された方々](https://github.com/"
"purescript/documentation/blob/master/CONTRIBUTORS.md)の著作権が含まれる。</"
"small>"

#. type: Plain text
#: README.md:40
msgid "The exercises are licensed under the MIT license."
msgstr ""
"The exercises are licensed under the MIT license.\n"
"\n"
"<small>演習はMITライセンスの下に使用が許諾される。</small>"

#. type: Title ##
#: text/chapter1.md:1 text/chapter4.md:23
#, no-wrap
msgid "Introduction"
msgstr "導入"

#. type: Title ##
#: text/chapter1.md:3
#, no-wrap
msgid "Functional JavaScript"
msgstr "関数型JavaScript"

#. type: Plain text
#: text/chapter1.md:6
msgid ""
"Functional programming techniques have been making appearances in JavaScript "
"for some time now:"
msgstr ""
"関数型プログラミングの手法がJavaScriptに姿を現しはじめてからしばらく経ちま"
"す。"

#. type: Bullet: '- '
#: text/chapter1.md:8
msgid ""
"Libraries such as [UnderscoreJS](https://underscorejs.org) allow the "
"developer to leverage tried-and-trusted functions such as `map`, `filter`, "
"and `reduce` to create larger programs from smaller programs by composition:"
msgstr ""
"[UnderscoreJS](https://underscorejs.org)などのライブラリがあれば、開発者は"
"`map`や `filter`、`reduce`といった実績のある関数を活用して、小さいプログラム"
"を組み合わせることで大きなプログラムを作ることができます。"

#. type: Plain text
#: text/chapter1.md:18
#, no-wrap
msgid ""
"    ```javascript\n"
"    var sumOfPrimes =\n"
"        _.chain(_.range(1000))\n"
"         .filter(isPrime)\n"
"         .reduce(function(x, y) {\n"
"             return x + y;\n"
"         })\n"
"         .value();\n"
"    ```\n"
msgstr ""
"    ```javascript\n"
"    var sumOfPrimes =\n"
"        _.chain(_.range(1000))\n"
"         .filter(isPrime)\n"
"         .reduce(function(x, y) {\n"
"             return x + y;\n"
"         })\n"
"         .value();\n"
"    ```\n"

#. type: Bullet: '- '
#: text/chapter1.md:20
msgid ""
"Asynchronous programming in NodeJS leans heavily on functions as first-class "
"values to define callbacks."
msgstr ""
"NodeJSにおける非同期プログラミングでは、第一級の値としての関数をコールバック"
"を定義するために多用しています。"

#. type: Plain text
#: text/chapter1.md:23
#, no-wrap
msgid ""
"    ```javascript\n"
"    import { readFile, writeFile } from 'fs'\n"
msgstr ""
"    ```javascript\n"
"    import { readFile, writeFile } from 'fs'\n"

#. type: Plain text
#: text/chapter1.md:34
#, no-wrap
msgid ""
"    readFile(sourceFile, function (error, data) {\n"
"      if (!error) {\n"
"        writeFile(destFile, data, function (error) {\n"
"          if (!error) {\n"
"            console.log(\"File copied\");\n"
"          }\n"
"        });\n"
"      }\n"
"    });\n"
"    ```\n"
msgstr ""
"    readFile(sourceFile, function (error, data) {\n"
"      if (!error) {\n"
"        writeFile(destFile, data, function (error) {\n"
"          if (!error) {\n"
"            console.log(\"File copied\");\n"
"          }\n"
"        });\n"
"      }\n"
"    });\n"
"    ```\n"

#. type: Bullet: '- '
#: text/chapter1.md:36
msgid ""
"Libraries such as [React](https://reactjs.org) and [virtual-dom](https://"
"github.com/Matt-Esch/virtual-dom) model views as pure functions of "
"application state."
msgstr ""
"[React](https://reactjs.org)や[virtual-dom](https://github.com/Matt-Esch/"
"virtual-dom)などのライブラリは、アプリケーションの状態についての純粋な関数と"
"してその外観をモデル化しています"

#. type: Plain text
#: text/chapter1.md:38
msgid ""
"Functions enable a simple form of abstraction that can yield great "
"productivity gains. However, functional programming in JavaScript has "
"disadvantages: JavaScript is verbose, untyped, and lacks powerful forms of "
"abstraction. Unrestricted JavaScript code also makes equational reasoning "
"very difficult."
msgstr ""
"関数は大幅な生産性の向上を<ruby>齎<rp>（</rp><rt>もたら</rt><rp>）</rp></"
"ruby>しうる単純な抽象化を可能にします。\n"
"しかし、JavaScriptでの関数型プログラミングには欠点があります。\n"
"JavaScriptは冗長で、型付けされず、強力な抽象化の形式を欠いているのです。\n"
"また、野放図なJavaScriptコードは等式推論がとても困難です。"

#. type: Plain text
#: text/chapter1.md:40
msgid ""
"PureScript is a programming language that aims to address these issues. It "
"features lightweight syntax, which allows us to write very expressive code "
"which is still clear and readable. It uses a rich type system to support "
"powerful abstractions. It also generates fast, understandable code, which is "
"important when interoperating with JavaScript or other languages that "
"compile to JavaScript. All in all, I hope to convince you that PureScript "
"strikes a very practical balance between the theoretical power of purely "
"functional programming and the fast-and-loose programming style of "
"JavaScript."
msgstr ""
"PureScriptはこうした課題への対処を目指すプログラミング言語です。\n"
"PureScriptは軽量な構文を備えていますが、この構文によりとても表現力豊かであり"
"ながら分かりやすく読みやすいコードが書けるのです。\n"
"強力な抽象化を支援する豊かな型システムも採用しています。\n"
"また、JavaScriptやJavaScriptへとコンパイルされる他の言語と相互運用するときに"
"重要な、高速で理解しやすいコードを生成します。\n"
"概してPureScriptとは、純粋関数型プログラミングの理論的な強力さと、JavaScript"
"のお手軽で緩いプログラミングスタイルとの、とても現実的なバランスを狙った言語"
"だということを理解して頂けたらと思います。"

#. type: Plain text
#: text/chapter1.md:42
#, no-wrap
msgid "> Note that PureScript can target other backends, not only JavaScript, but this book focuses on targeting web browser and node environments.\n"
msgstr ""

#. type: Title ##
#: text/chapter1.md:43
#, no-wrap
msgid "Types and Type Inference"
msgstr "型と型推論"

#. type: Plain text
#: text/chapter1.md:46
msgid ""
"The debate over statically typed languages versus dynamically typed "
"languages is well-documented. PureScript is a _statically typed_ language, "
"meaning that a correct program can be given a _type_ by the compiler, which "
"indicates its behavior. Conversely, programs that cannot be given a type are "
"_incorrect programs_, and will be rejected by the compiler. In PureScript, "
"unlike in dynamically typed languages, types exist only at _compile-time_ "
"and have no representation at runtime."
msgstr ""
"動的型付けの言語と静的型付けの言語をめぐる議論については充分に文書化されてい"
"ます。\n"
"PureScriptは*静的型付け*の言語、つまり正しいプログラムはコンパイラによって*型"
"*を与えられる言語です。\n"
"またこの型は、その動作を示すものです。\n"
"逆に言えば、型を与えることができないプログラムは*誤ったプログラム*であり、コ"
"ンパイラによって拒否されます。\n"
"動的型付けの言語とは異なり、PureScriptでは型は*コンパイル時*にのみ存在し、実"
"行時には一切その表現がありません。"

#. type: Plain text
#: text/chapter1.md:48
msgid ""
"It is important to note that, in many ways, the types in PureScript are "
"unlike the types that you might have seen in other languages like Java or "
"C#. While they serve the same purpose at a high level, the types in "
"PureScript are inspired by languages like ML and Haskell. PureScript's types "
"are expressive, allowing the developer to assert strong claims about their "
"programs. Most importantly, PureScript's type system supports _type "
"inference_ – it requires far fewer explicit type annotations than other "
"languages, making the type system a _tool_ rather than a hindrance. As a "
"simple example, the following code defines a _number_, but there is no "
"mention of the `Number` type anywhere in the code:"
msgstr ""
"多くの点で、PureScriptの型とこれまでJavaやC#のような他の言語で見てきたであろ"
"う型が異なっていることにも、注意することが大切です。\n"
"大まかに言えばPureScriptの型はJavaやC#と同じ目的を持っているものの、"
"PureScriptの型はMLやHaskellのような言語に影響を受けています。\n"
"PureScriptの型は表現力豊かであり、開発者はプログラムについての強い主張を表明"
"できます。\n"
"最も重要なのはPureScriptの型システムが*型推論*に対応していることです。\n"
"型推論があれば他の言語より明示的な型注釈が遥かに少なく済み、型システムを厄介"
"者ではなく*道具*にしてくれます。\n"
"単純な一例として、次のコードは*数*を定義していますが、`Number`型への言及は"
"コードのどこにもありません。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:49
#, no-wrap
msgid ""
"iAmANumber =\n"
"  let square x = x * x\n"
"  in square 42.0\n"
msgstr ""
"iAmANumber =\n"
"  let square x = x * x\n"
"  in square 42.0\n"

#. type: Plain text
#: text/chapter1.md:56
msgid ""
"A more involved example shows that type-correctness can be confirmed without "
"type annotations, even when there exist types that are _unknown to the "
"compiler_:"
msgstr ""
"より込み入った次の例では、*コンパイラにとって未知*の型が存在します。\n"
"それでも、型注釈なく型の正しさを確かめられていることを示しています。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:57
#, no-wrap
msgid ""
"iterate f 0 x = x\n"
"iterate f n x = iterate f (n - 1) (f x)\n"
msgstr ""
"iterate f 0 x = x\n"
"iterate f n x = iterate f (n - 1) (f x)\n"

#. type: Plain text
#: text/chapter1.md:63
msgid ""
"Here, the type of `x` is unknown, but the compiler can still verify that "
"`iterate` obeys the rules of the type system, no matter what type `x` might "
"have."
msgstr ""
"ここで `x`の型は不明ですが、`x`がどんな型を持っているかにかかわらず、"
"`iterate`が型システムの規則に従っていることをコンパイラは検証できます。"

#. type: Plain text
#: text/chapter1.md:65
msgid ""
"In this book, I will try to convince you (or reaffirm your belief) that "
"static types are not only a means of gaining confidence in the correctness "
"of your programs, but also an aid to development in their own right. "
"Refactoring a large body of code in JavaScript can be difficult when using "
"any but the simplest of abstractions, but an expressive type system together "
"with a type checker can even make refactoring into an enjoyable, interactive "
"experience."
msgstr ""
"本書で納得していただきたい（または既にお持ちの信条に寄り添って改めて断言した"
"い）ことは、静的型が単にプログラムの正しさに自信を持つためだけのものではな"
"く、それ自体の正しさによって開発の手助けになるものでもあるということです。"
"JavaScriptではごく単純な抽象化を施すのでも大規模なコードのリファクタリングを"
"することは難しいですが、型検証器のある表現力豊かな型システムは、リファクタリ"
"ングさえ楽しく対話的な体験にしてくれます。"

#. type: Plain text
#: text/chapter1.md:67
msgid ""
"In addition, the safety net provided by a type system enables more advanced "
"forms of abstraction. In fact, PureScript provides a powerful form of "
"abstraction that is fundamentally type-driven: type classes, made popular in "
"the functional programming language Haskell."
msgstr ""
"加えて、型システムによって提供されるこの安全網は、より高度な抽象化を可能にし"
"ます。\n"
"実際に、根本的に型駆動な抽象化の強力な形式である型クラスをPureScriptは提供し"
"ています。\n"
"この型クラスとは、関数型プログラミング言語Haskellによって有名になりました。"

#. type: Title ##
#: text/chapter1.md:68
#, no-wrap
msgid "Polyglot Web Programming"
msgstr "多言語webプログラミング"

#. type: Plain text
#: text/chapter1.md:71
msgid ""
"Functional programming has its success stories – applications where it has "
"been particularly successful: data analysis, parsing, compiler "
"implementation, generic programming, parallelism, to name a few."
msgstr ""
"関数型プログラミングは成功を収めてきました。\n"
"特に成功している応用例を挙げると、データ解析、構文解析、コンパイラの実装、"
"ジェネリックプログラミング、並列処理といった具合に、枚挙に暇がありません。"

#. type: Plain text
#: text/chapter1.md:73
msgid ""
"It would be possible to practice end-to-end application development in a "
"functional language like PureScript. PureScript provides the ability to "
"import existing JavaScript code, by providing types for its values and "
"functions, and then to use those functions in regular PureScript code. We'll "
"see this approach later in the book."
msgstr ""
"PureScriptのような関数型言語でアプリケーション開発の最初から最後までを実施で"
"きるでしょう。\n"
"値や関数の型を提供することで既存のJavaScriptコードをインポートし、通常の"
"PureScriptコードからこれらの関数を使用する機能をPureScriptは提供していま"
"す。\n"
"この手法については本書の後半で見ていくことになります。"

#. type: Plain text
#: text/chapter1.md:75
msgid ""
"However, one of PureScript's strengths is its interoperability with other "
"languages which target JavaScript. Another approach would be to use "
"PureScript for a subset of your application's development and to use one or "
"more other languages to write the rest of the JavaScript."
msgstr ""
"しかし、PureScriptの強みの1つは、JavaScriptを対象とする他の言語との相互運用性"
"にあります。\n"
"アプリケーションの開発の一部にだけPureScriptを使用し、JavaScriptの残りの部分"
"を記述するのに1つ以上の他の言語を使用するという方法もあります。"

#. type: Plain text
#: text/chapter1.md:77
msgid "Here are some examples:"
msgstr "幾つかの例を示します。"

#. type: Bullet: '- '
#: text/chapter1.md:81
msgid ""
"Core logic written in PureScript, with the user interface written in "
"JavaScript."
msgstr ""
"中核となる処理はPureScriptで記述し、ユーザーインターフェイスはJavaScriptで記"
"述する"

#. type: Bullet: '- '
#: text/chapter1.md:81
msgid ""
"Application written in JavaScript or another compile-to-JS language, with "
"tests written in PureScript."
msgstr ""
"JavaScriptや、他のJavaScriptにコンパイルする言語でアプリケーションを書き、"
"PureScriptでそのテストを書く"

#. type: Bullet: '- '
#: text/chapter1.md:81
msgid ""
"PureScript used to automate user interface tests for an existing application."
msgstr ""
"既存のアプリケーションのユーザインターフェースのテストを自動化するために"
"PureScriptを使用する"

#. type: Plain text
#: text/chapter1.md:83
msgid ""
"In this book, we'll focus on solving small problems with PureScript. The "
"solutions could be integrated into a larger application, but we will also "
"look at how to call PureScript code from JavaScript, and vice versa."
msgstr ""
"本書では小規模な課題をPureScriptで解決することに焦点を当てます。\n"
"ここで学ぶ手法は大規模なアプリケーションに組み込むこともできますが、"
"JavaScriptからPureScriptコードを呼び出す方法、及びその逆についても見ていきま"
"す。"

#. type: Title ##
#: text/chapter1.md:84
#, no-wrap
msgid "Prerequisites"
msgstr "ソフトウェア要件"

#. type: Plain text
#: text/chapter1.md:87
msgid ""
"The software requirements for this book are minimal: the first chapter will "
"guide you through setting up a development environment from scratch, and the "
"tools we will use are available in the standard repositories of most modern "
"operating systems."
msgstr ""
"本書のソフトウェア要件は最小限です。\n"
"第1章では開発環境の構築を一から案内します。\n"
"これから使用するツールは、ほとんどの現代のオペレーティングシステムの標準リポ"
"ジトリで使用できるものです。"

#. type: Plain text
#: text/chapter1.md:89
msgid ""
"The PureScript compiler itself can be downloaded as a binary distribution or "
"built from source on any system running an up-to-date installation of the "
"GHC Haskell compiler, and we will walk through this process in the next "
"chapter."
msgstr ""
"PureScriptコンパイラ自体はバイナリの配布物としてもダウンロードできますし、最"
"新のGHC Haskellコンパイラが動く任意のシステム上でソースからのビルドもできま"
"す。\n"
"次の章ではこの手順を進めていきます。"

#. type: Plain text
#: text/chapter1.md:92
msgid ""
"The code in this version of the book is compatible with versions `0.15.*` of "
"the PureScript compiler."
msgstr ""
"本書のこのバージョンのコードは`0.15.*`バージョンのPureScriptコンパイラと互換"
"性があります。"

#. type: Title ##
#: text/chapter1.md:93
#, no-wrap
msgid "About You"
msgstr "読者について"

#. type: Plain text
#: text/chapter1.md:96
msgid ""
"I will assume that you are familiar with the basics of JavaScript. Any prior "
"familiarity with common tools from the JavaScript ecosystem, such as NPM and "
"Gulp, will be beneficial if you wish to customize the standard setup to your "
"own needs, but such knowledge is not necessary."
msgstr ""
"読者はJavaScriptの基本を既に理解しているものと仮定します。\n"
"既にNPMやBowerのようなJavaScriptのエコシステムでの経験があれば、自身の好みに"
"応じて標準設定をカスタマイズしたい場合などに役に立ちます。\n"
"ですがそのような知識は必要ありません。"

#. type: Plain text
#: text/chapter1.md:98
msgid ""
"No prior knowledge of functional programming is required, but it certainly "
"won't hurt. New ideas will be accompanied by practical examples, so you "
"should be able to form an intuition for the concepts from the functional "
"programming that we will use."
msgstr ""
"関数型プログラミングの事前知識は必要ありませんが、あっても決して害にはならな"
"いでしょう。\n"
"新しい考えかたは実例と共に登場するため、これから使っていく関数型プログラミン"
"グからこうした概念に対する直感が形成されることでしょう。"

#. type: Plain text
#: text/chapter1.md:100
msgid ""
"Readers who are familiar with the Haskell programming language will "
"recognize a lot of the ideas and syntax presented in this book because "
"PureScript is heavily influenced by Haskell. However, those readers should "
"understand that there are a number of important differences between "
"PureScript and Haskell. It is not necessarily always appropriate to try to "
"apply ideas from one language in the other, although many of the concepts "
"presented here will have some interpretation in Haskell."
msgstr ""
"PureScriptはプログラミング言語Haskellに強く影響を受けているため、Haskellに通"
"じている読者は本書で提示された概念や構文の多くに見覚えがあるでしょう。\n"
"しかし、PureScriptとHaskellの間には数多くの重要な違いがあることも理解しておく"
"と良いでしょう。\n"
"ここで紹介する概念の多くはHaskellでも同じように解釈できるとはいえ、どちらかの"
"言語での考え方を他方の言語でそのまま応用しようとすることは、必ずしも適切では"
"ありません。"

#. type: Title ##
#: text/chapter1.md:101
#, no-wrap
msgid "How to Read This Book"
msgstr "本書の読み進めかた"

#. type: Plain text
#: text/chapter1.md:104
msgid ""
"The chapters in this book are largely self-contained. A beginner with little "
"functional programming experience would be well-advised, however, to work "
"through the chapters in order. The first few chapters lay the groundwork "
"required to understand the material later on in the book. A reader who is "
"comfortable with the ideas of functional programming (especially one with "
"experience in a strongly-typed language like ML or Haskell) will probably be "
"able to gain a general understanding of the code in the later chapters of "
"the book without reading the preceding chapters."
msgstr ""
"本書のほとんどの章が各章毎に完結しています。\n"
"しかし、関数型プログラミングの経験がほとんどない初心者の方は、各章を順番に進"
"めていくのが賢明です。\n"
"最初の数章は本書の後半の内容を理解するのに必要な下地作りです。\n"
"関数型プログラミングの考え方に充分通じた読者（特にMLやHaskellのような強く型付"
"けされた言語での経験を持つ読者）なら、本書の前半の章を読まなくても、後半の章"
"のコードの大まかな理解を得ることが恐らく可能でしょう。"

#. type: Plain text
#: text/chapter1.md:106
msgid ""
"Each chapter will focus on a single practical example, providing the "
"motivation for any new ideas introduced. Code for each chapter is available "
"from the book's [GitHub repository](https://github.com/purescript-contrib/"
"purescript-book). Some chapters will include code snippets taken from the "
"chapter's source code, but for a full understanding, you should read the "
"source code from the repository alongside the material from the book. Longer "
"sections will contain shorter snippets which you can execute in the "
"interactive mode PSCi to test your understanding."
msgstr ""
"各章では1つの実用的な例に焦点を当て、新しい考え方を導入するための動機を与えま"
"す。\n"
"各章のコードは本書の[GitHubのリポジトリ](https://github.com/purescript-"
"contrib/purescript-book)から入手できます。\n"
"該当の章のソースコードから抜粋したコード片が含まれる章もありますが、本書の内"
"容に沿ってリポジトリのソースコードを読まれると良いでしょう。\n"
"長めの節には、理解を確かめられるように対話式モードのPSCiで実行できる短めの"
"コード片が含まれます。"

#. type: Plain text
#: text/chapter1.md:108
msgid "Code samples will appear in a monospaced font as follows:"
msgstr "コード例は次のように等幅フォントで示されます。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:109
#, no-wrap
msgid ""
"module Example where\n"
"\n"
"import Effect.Console (log)\n"
"\n"
"main = log \"Hello, World!\"\n"
msgstr ""
"module Example where\n"
"\n"
"import Effect.Console (log)\n"
"\n"
"main = log \"Hello, World!\"\n"

#. type: Plain text
#: text/chapter1.md:118
msgid ""
"Commands which should be typed at the command line will be preceded by a "
"dollar symbol:"
msgstr "先頭にドル記号がついた行は、コマンドラインに入力されたコマンドです。"

#. type: Fenced code block (text)
#: text/chapter1.md:119 text/chapter3.md:330
#, no-wrap
msgid "$ spago build\n"
msgstr "$ spago build\n"

#. type: Plain text
#: text/chapter1.md:124
msgid ""
"Usually, these commands will be tailored to Linux/Mac OS users, so Windows "
"users may need to make small changes, such as modifying the file separator "
"or replacing shell built-ins with their Windows equivalents."
msgstr ""
"通常、これらのコマンドはLinuxやMac OSの利用者に合わせたものになっています。\n"
"そのためWindowsの利用者は小さな変更を加える必要があるかもしれません。\n"
"ファイル区切り文字を変更したり、シェルの組み込み機能をWindowsの相当するものに"
"置き換えるなどです。"

#. type: Plain text
#: text/chapter1.md:126
msgid ""
"Commands which should be typed at the PSCi interactive mode prompt will be "
"preceded by an angle bracket:"
msgstr ""
"PSCi対話式モードプロンプトに入力するコマンドは、行の先頭に山括弧が付けられて"
"います。"

#. type: Fenced code block (text)
#: text/chapter1.md:127
#, no-wrap
msgid ""
"> 1 + 2\n"
"3\n"
msgstr ""
"> 1 + 2\n"
"3\n"

#. type: Plain text
#: text/chapter1.md:133
msgid ""
"Each chapter will contain exercises labelled with their difficulty level. It "
"is strongly recommended that you attempt the exercises in each chapter to "
"fully understand the material."
msgstr ""
"各章には演習が含まれており、難易度も示されています。\n"
"内容を完全に理解するために、各章の演習に取り組むことを強くお勧めします。"

#. type: Plain text
#: text/chapter1.md:135
msgid ""
"This book aims to provide an introduction to the PureScript language for "
"beginners, but it is not the sort of book that provides a list of template "
"solutions to problems. For beginners, this book should be a fun challenge, "
"and you will get the most benefit if you read the material, attempt the "
"exercises, and, most importantly of all, try to write some code of your own."
msgstr ""
"本書は初心者にPureScriptへの導入を提供することを目的としており、課題に対する"
"お決まりの解決策の一覧を提供するような類の本ではありません。\n"
"初心者にとっては楽しい挑戦になるはずです。\n"
"内容を読んで演習に挑戦すれば得るものがあることでしょう。\n"
"そして何よりも大切なのは、自分自身でコードを書いてみることです。"

#. type: Title ##
#: text/chapter1.md:136
#, no-wrap
msgid "Getting Help"
msgstr "困ったときには"

#. type: Plain text
#: text/chapter1.md:139
msgid ""
"If you get stuck at any point, there are a number of resources available "
"online for learning PureScript:"
msgstr ""
"もしどこかでつまずいたときには、PureScriptを学べるオンラインで利用可能な資料"
"が沢山あります。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"The [PureScript Discord server](https://discord.gg/vKn9up84bp) is a great "
"place to chat about issues you may be having. The server is dedicated to "
"chatting about PureScript"
msgstr ""
"[PureScriptのDiscordサーバ](https://discord.gg/vKn9up84bp)は抱えている問題に"
"ついてチャットするのに良い場所です。\n"
"こちらのサーバはPureScriptについてのチャット専用です。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"The [Purescript Discourse Forum](https://discourse.purescript.org/) is "
"another good place to search for solutions to common problems."
msgstr ""
"[PurescriptのDiscourseフォーラム](https://discourse.purescript.org/)もよくあ"
"る問題への解決策を探すのに良い場所です。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"[PureScript: Jordan's Reference](https://github.com/jordanmartinez/"
"purescript-jordans-reference)  is an alternative learning resource that goes "
"into great depth. If a concept in this book is difficult to understand, "
"consider reading the corresponding section in that reference."
msgstr ""
"[PureScript: Jordan's Reference](https://github.com/jordanmartinez/"
"purescript-jordans-reference)は別のかなり深く踏み込んだ学習資料です。\n"
"本書中の概念で理解しにくいものがあったら、そちらの参考書の対応する節を読むと"
"よいでしょう。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"[Pursuit](https://pursuit.purescript.org) is a searchable database of "
"PureScript types and functions. Read Pursuit's help page to [learn what "
"kinds of searches you can do](https://pursuit.purescript.org/help/users)."
msgstr ""
"[Pursuit](https://pursuit.purescript.org)はPureScriptの型と関数を検索できる"
"データベースです。\n"
"Pursuitのヘルプページを読むと[どのような種類の検索ができるのかがわかります]"
"(https://pursuit.purescript.org/help/users)。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"The unofficial [PureScript Cookbook](https://github.com/JordanMartinez/"
"purescript-cookbook) provides answers via code to \"How do I do X?\"-type "
"questions."
msgstr ""
"非公式の[PureScript Cookbook](https://github.com/JordanMartinez/purescript-"
"cookbook)は「Xするにはどうするの」といった類の質問にコードを混じえて答えを提"
"供します。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"The [PureScript documentation repository](https://github.com/purescript/"
"documentation) collects articles and examples on a wide variety of topics "
"written by PureScript developers and users."
msgstr ""
"[PureScriptドキュメントリポジトリ](https://github.com/purescript/"
"documentation)には、PureScriptの開発者や利用者が書いた幅広い話題の記事と例が"
"集まっています。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"The [PureScript website](https://www.purescript.org) contains links to "
"several learning resources, including code samples, videos, and other "
"resources for beginners."
msgstr ""
"[PureScriptのwebサイト](https://www.purescript.org)には幾つかの学習資料へのリ"
"ンクがあります。\n"
"コード例、映像、他の初心者向け資料などです。"

#. type: Bullet: '- '
#: text/chapter1.md:148
msgid ""
"[Try PureScript!](https://try.purescript.org) is a website that allows users "
"to compile PureScript code in the web browser and contains several simple "
"examples of code."
msgstr ""
"[Try PureScript!](https://try.purescript.org)は利用者がwebブラウザで"
"PureScriptのコードをコンパイルできるwebサイトです。\n"
"幾つかの簡単なコードの例もあります。"

#. type: Plain text
#: text/chapter1.md:150
#, fuzzy
#| msgid ""
#| "If you prefer to learn by reading examples, the `purescript`, `purescript-"
#| "node`, and `purescript-contrib` GitHub organizations contain plenty of "
#| "examples of PureScript code."
msgid ""
"If you prefer to learn by reading examples, the [purescript](https://github."
"com/purescript), [purescript-node](https://github.com/purescript-node), and "
"[purescript-contrib](https://github.com/purescript-contrib) GitHub "
"organizations contain plenty of examples of PureScript code."
msgstr ""
"もし例を読んで学ぶ方が好きでしたら、GitHubの`purescript`組織、`purescript-"
"node`組織及び`purescript-contrib`組織にはPureScriptコードの例が沢山あります。"

#. type: Title ##
#: text/chapter1.md:151
#, no-wrap
msgid "About the Author"
msgstr "著者について"

#. type: Plain text
#: text/chapter1.md:154
msgid ""
"I am the original developer of the PureScript compiler. I'm based in Los "
"Angeles, California, and started programming at an early age in BASIC on an "
"8-bit personal computer, the Amstrad CPC. Since then, I have worked "
"professionally in a variety of programming languages (including Java, Scala, "
"C#, F#, Haskell and PureScript)."
msgstr ""
"私はPureScriptコンパイラの最初の開発者です。\n"
"カリフォルニア州ロサンゼルスを拠点にしており、8ビットパーソナルコンピュータで"
"あるAmstrad CPC上のBASICでまだ幼い時にプログラミングを始めました。\n"
"それ以来、私は幾つものプログラミング言語（JavaやScala、C#、F#、Haskell、そし"
"てPureScript）で専門的に業務に携わってきました。"

#. type: Plain text
#: text/chapter1.md:156
msgid ""
"Not long into my professional career, I began to appreciate functional "
"programming and its connections with mathematics, and enjoyed learning "
"functional concepts using the Haskell programming language."
msgstr ""
"プロとしての経歴が始まって間もなく、私は関数型プログラミングと数学の関係を理"
"解するようになり、そしてプログラミング言語Haskellを使って関数型の概念の学習を"
"楽しみました。"

#. type: Plain text
#: text/chapter1.md:158
msgid ""
"I started working on the PureScript compiler in response to my experience "
"with JavaScript. I found myself using functional programming techniques that "
"I had picked up in languages like Haskell, but wanted a more principled "
"environment in which to apply them. Solutions at the time included various "
"attempts to compile Haskell to JavaScript while preserving its semantics "
"(Fay, Haste, GHCJS), but I was interested to see how successful I could be "
"by approaching the problem from the other side – attempting to keep the "
"semantics of JavaScript, while enjoying the syntax and type system of a "
"language like Haskell."
msgstr ""
"JavaScriptでの経験をもとに、私はPureScriptコンパイラの開発を始めることにしま"
"した。\n"
"気が付くとHaskellのような言語から取り上げた関数型プログラミングの手法を使って"
"いましたが、それを応用するためのもっと理に適った環境を求めていました。\n"
"そのとき検討した案のなかには、Haskellからその意味論を維持しながらJavaScriptへ"
"とコンパイルするいろいろな試み（Fay、Haste、GHCJS）もありました。\n"
"しかし私が興味を持っていたのは、この問題へ別の切り口からアプローチすると、ど"
"の程度うまくいくのかということでした。\n"
"そのアプローチとは、JavaScriptの意味論を維持しつつ、Haskellのような言語の構文"
"と型システムを楽しむことなのです。"

#. type: Plain text
#: text/chapter1.md:160
msgid ""
"I maintain [a blog](https://blog.functorial.com), and can be [reached on "
"Twitter](https://twitter.com/paf31)."
msgstr ""
"私は[ブログ](http://blog.functorial.com)を運営しており、[Twitterで連絡をとる]"
"(http://twitter.com/paf31)こともできます。"

#. type: Title ##
#: text/chapter1.md:161
#, no-wrap
msgid "Acknowledgements"
msgstr "謝辞"

#. type: Plain text
#: text/chapter1.md:164
msgid ""
"I would like to thank the many contributors who helped PureScript to reach "
"its current state. Without the huge collective effort which has been made on "
"the compiler, tools, libraries, documentation, and tests, the project would "
"certainly have failed."
msgstr ""
"現在に至るまでPureScriptに手を貸してくださった多くの協力者に感謝したいと思い"
"ます。\n"
"コンパイラ、ツール、ライブラリ、ドキュメント、テストでの、巨大で組織的な尽力"
"なくしては、プロジェクトは間違いなく失敗していたことでしょう。"

#. type: Plain text
#: text/chapter1.md:166
msgid ""
"The PureScript logo which appears on the cover of this book was created by "
"Gareth Hughes and is gratefully reused here under the terms of the [Creative "
"Commons Attribution 4.0 license](https://creativecommons.org/licenses/"
"by/4.0/)."
msgstr ""
"本書の表紙に示されたPureScriptのロゴはGareth Hughesによって作成されたもので、"
"[Creative Commons Attribution 4.0 license](https://creativecommons.org/"
"licenses/by/4.0/)の条件の下で再利用させて頂いています 。"

#. type: Plain text
#: text/chapter1.md:167
msgid ""
"Finally, I would like to thank everyone who has given me feedback and "
"corrections on the contents of this book."
msgstr ""
"最後に、本書の内容に関する反応や訂正をくださった全ての方に、心より感謝したい"
"と思います。"

#. type: Title #
#: text/chapter10.md:1
#, no-wrap
msgid "The Foreign Function Interface"
msgstr "外部関数インターフェース"

#. type: Title ##
#: text/chapter10.md:3 text/chapter11.md:3 text/chapter12.md:3
#: text/chapter13.md:3 text/chapter14.md:3 text/chapter2.md:3
#: text/chapter3.md:3 text/chapter4.md:3 text/chapter5.md:3 text/chapter6.md:3
#: text/chapter7.md:3 text/chapter8.md:3 text/chapter9.md:3
#, no-wrap
msgid "Chapter Goals"
msgstr "この章の目標"

#. type: Plain text
#: text/chapter10.md:6
msgid ""
"This chapter will introduce PureScript's _foreign function interface_ (or "
"_FFI_), which enables communication from PureScript code to JavaScript code "
"and vice versa. We will cover how to:"
msgstr ""
"本章ではPureScriptの*外部関数インターフェース* (foreign function interface; "
"*FFI*) を紹介します。\n"
"これによりPureScriptコードからJavaScriptコードへの呼び出し、及びその逆が可能"
"になります。\n"
"以下の方法を押さえていきます。"

#. type: Bullet: '- '
#: text/chapter10.md:10
msgid ""
"Call pure, effectful, and asynchronous JavaScript functions from PureScript."
msgstr "純粋で、作用のある、非同期なJavaScript関数をPureScriptから呼び出す。"

#. type: Bullet: '- '
#: text/chapter10.md:10
msgid "Work with untyped data."
msgstr "型付けされていないデータを扱う。"

#. type: Bullet: '- '
#: text/chapter10.md:10
msgid "Encode and parse JSON using the `argonaut` package."
msgstr ""
"`argonaut`パッケージを使ってJSONにエンコードしたりJSONを構文解析したりする。"

#. type: Plain text
#: text/chapter10.md:12
msgid ""
"Towards the end of this chapter, we will revisit our recurring address book "
"example. The goal of the chapter will be to add the following new "
"functionality to our application using the FFI:"
msgstr ""
"この章の終わりにかけて、住所録の例に立ち返ります。\n"
"この章の目的は、FFIを使ってアプリケーションに次の新しい機能を追加することで"
"す。"

#. type: Bullet: '- '
#: text/chapter10.md:15
msgid "Alert the user with a popup notification."
msgstr "利用者にポップアップ通知で警告する。"

#. type: Bullet: '- '
#: text/chapter10.md:15
msgid ""
"Store the serialized form data in the browser's local storage, and reload it "
"when the application restarts."
msgstr ""
"フォームのデータを直列化してブラウザのローカルストレージに保存し、アプリケー"
"ションが再起動したときにそれを再読み込みする"

# From WordNet (r) 3.0 (2006) [wn]:
#
# sought-after
#     adj 1: being searched for; "the most sought-after item was the
#            silver candelabrum" [syn: sought, sought-after(a)]
#. type: Plain text
#: text/chapter10.md:17
msgid ""
"There is also an addendum covering some additional topics that are not as "
"commonly sought-after. Feel free to read these sections, but don't let them "
"stand in the way of progressing through the remainder of the book if they're "
"less relevant to your learning objectives:"
msgstr ""
"さらに一般にはそこまで重用されない幾つかの追加の話題を押さえた補遺もありま"
"す。\n"
"ご自由にこれらの節を読んで構いませんが、学習目標にあまり関係しなければ、本書"
"の残りを読み進める妨げにならないようにしてください。"

#. type: Bullet: '- '
#: text/chapter10.md:20
msgid "Understand the representation of PureScript values at runtime."
msgstr "実行時のPureScriptの値の表現を理解する。"

#. type: Bullet: '- '
#: text/chapter10.md:20
msgid "Call PureScript functions from JavaScript."
msgstr "JavaScriptからPureScriptを呼び出す。"

#. type: Title ##
#: text/chapter10.md:21 text/chapter11.md:7 text/chapter12.md:7
#: text/chapter13.md:9 text/chapter14.md:16 text/chapter3.md:11
#: text/chapter4.md:11 text/chapter5.md:13 text/chapter6.md:13
#: text/chapter7.md:11 text/chapter8.md:9 text/chapter9.md:7
#, no-wrap
msgid "Project Setup"
msgstr "プロジェクトの準備"

#. type: Plain text
#: text/chapter10.md:24
msgid ""
"The source code for this module is a continuation of the source code from "
"chapters 3, 7, and 8. As such, the source tree includes the appropriate "
"source files from those chapters."
msgstr ""
"このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。\n"
"そうしたわけでソースツリーにはこれらの章からの適切なソースファイルが含まれて"
"います。"

#. type: Plain text
#: text/chapter10.md:26
msgid ""
"This chapter introduces the `argonaut` library as a dependency. This library "
"is used for encoding and decoding JSON."
msgstr ""
"この章は`argonaut`ライブラリを依存関係として導入しています。\n"
"このライブラリはJSONにエンコードしたりJSONをデコードしたりするために使いま"
"す。"

#. type: Plain text
#: text/chapter10.md:28
msgid ""
"The exercises for this chapter should be written in `test/MySolutions.purs` "
"and can be checked against the unit tests in `test/Main.purs` by running "
"`spago test`."
msgstr ""
"この章の演習は`test/MySolutions.purs`に書き、`spago test`を走らせることによっ"
"て`test/Main.purs`中の単体試験について確認できます。"

#. type: Plain text
#: text/chapter10.md:30
msgid ""
"The Address Book app can be launched with `parcel src/index.html --open`. It "
"uses the same workflow from Chapter 8, so refer to that chapter for more "
"detailed instructions."
msgstr ""
"住所録アプリは`parcel src/index.html --open`で立ち上げることができます。8章と"
"同じ作業の流れになっているので、より詳しい説明についてはそちらの章を参照して"
"ください。"

#. type: Title ##
#: text/chapter10.md:31
#, no-wrap
msgid "A Disclaimer"
msgstr "免責事項"

#. type: Plain text
#: text/chapter10.md:34
msgid ""
"PureScript provides a straightforward foreign function interface to make "
"working with JavaScript as simple as possible. However, it should be noted "
"that the FFI is an _advanced_ feature of the language. To use it safely and "
"effectively, you should understand the runtime representation of the data "
"you plan to work with. This chapter aims to impart such an understanding as "
"pertains to code in PureScript's standard libraries."
msgstr ""
"JavaScriptの扱いをできる限り単純にするため、PureScriptは直感的な外部関数イン"
"ターフェースを提供しています。\n"
"しかし、FFIはこの言語の*応用的な*機能であることには心に留めておかれると良いで"
"しょう。\n"
"安全かつ効率的に使用するには、扱うつもりであるデータの実行時の表現について理"
"解していなければなりません。\n"
"この章では、PureScriptの標準ライブラリのコードに付いて回るそのような理解を伝"
"授することを目指します。"

#. type: Plain text
#: text/chapter10.md:36
msgid ""
"PureScript's FFI is designed to be very flexible. In practice, this means "
"that developers have a choice between giving their foreign functions very "
"simple types or using the type system to protect against accidental misuses "
"of foreign code. Code in the standard libraries tends to favor the latter "
"approach."
msgstr ""
"PureScriptのFFIはとても柔軟に設計されています。\n"
"実際には、外部関数にとても単純な型を与えるか、型システムを利用して外部のコー"
"ドの誤った使い方を防ぐようにするか、開発者が選べるようになっています。\n"
"標準ライブラリのコードは、後者の手法を採る傾向にあります。"

#. type: Plain text
#: text/chapter10.md:38
msgid ""
"As a simple example, a JavaScript function makes no guarantees that its "
"return value will not be `null`. Indeed, idiomatic JavaScript code returns "
"`null` quite frequently! However, PureScript's types are usually not "
"inhabited by a null value. Therefore, it is the responsibility of the "
"developer to handle these corner cases appropriately when designing their "
"interfaces to JavaScript code using the FFI."
msgstr ""
"簡単な例としては、JavaScriptの関数で戻り値が `null`にならないことは保証できま"
"せん。\n"
"実のところ、JavaScriptらしさのあるコードはかなり頻繁に `null`を返します。\n"
"しかし、大抵PureScriptの型にnull値が巣喰うことはありません。\n"
"そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するとき、これら"
"の特殊な場合を適切に処理するのは開発者の責任です。"

#. type: Title ##
#: text/chapter10.md:39
#, no-wrap
msgid "Calling JavaScript From PureScript"
msgstr "PureScriptからJavaScriptを呼び出す"

#. type: Plain text
#: text/chapter10.md:42
msgid ""
"The simplest way to use JavaScript code from PureScript is to give a type to "
"an existing JavaScript value using a _foreign import_ declaration. Foreign "
"import declarations must have a corresponding JavaScript declaration "
"_exported_ from a _foreign JavaScript module_."
msgstr ""
"PureScriptからJavaScriptコードを使用する最も簡単な方法は、 _外部インポート宣"
"言_ (foreign import declaration) を使用し、既存のJavaScriptの値に型を与えるこ"
"とです。\n"
"外部インポート宣言には _外部JavaScriptモジュール_ (foreign JavaScript "
"module) から _エクスポートされた_ 対応するJavaScriptでの宣言がなくてはなりま"
"せん。"

#. type: Plain text
#: text/chapter10.md:44
msgid ""
"For example, consider the `encodeURIComponent` function, which can be used "
"in JavaScript to encode a component of a URI by escaping special characters:"
msgstr ""
"例えば特殊文字をエスケープすることによりURIのコンポーネントをエンコードする"
"JavaScriptの `encodeURIComponent`関数について考えてみます。"

#. type: Fenced code block (text)
#: text/chapter10.md:45
#, no-wrap
msgid ""
"$ node\n"
"\n"
"node> encodeURIComponent('Hello World')\n"
"'Hello%20World'\n"
msgstr ""
"$ node\n"
"\n"
"node> encodeURIComponent('Hello World')\n"
"'Hello%20World'\n"

#. type: Plain text
#: text/chapter10.md:53
#, no-wrap
msgid "This function has the correct runtime representation for the function type `String -> String`, since it takes non-null strings to non-null strings and has no other side-effects.\n"
msgstr ""
"この関数は関数の型`String -> String`について適切な実行時表現を持っています。\n"
"`null`でない文字列を取って`null`でない文字列にするもので、副作用を持たないからです。\n"

#. type: Plain text
#: text/chapter10.md:55
msgid ""
"We can assign this type to the function with the following foreign import "
"declaration:"
msgstr ""
"次のような外部インポート宣言を使うと、この関数に型を割り当てることができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:56
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.purs}}\n"
msgstr "{{#include ../exercises/chapter10/test/URI.purs}}\n"

#. type: Plain text
#: text/chapter10.md:62
msgid ""
"We also need to write a foreign JavaScript module to import it from. A "
"corresponding foreign JavaScript module is one of the same name but the "
"extension changed from `.purs` to `.js`. If the Purescript module above is "
"saved as `URI.purs`, then the foreign JavaScript module is saved as `URI."
"js`.  Since `encodeURIComponent` is already defined, we have to export it as "
"`_encodeURIComponent`:"
msgstr ""
"インポートしてくるための外部JavaScriptモジュールを書く必要もあります。\n"
"対応する外部JavaScriptモジュールは、同名で拡張子が`.purs`から`.js`に変わった"
"ものです。\n"
"上のPureScriptモジュールが`URI.purs`として保存されているなら、外部JavaScript"
"モジュールを`URI.js`として保存します。\n"
"`encodeURIComponent`は既に定義されているので、`_encodeURIComponent`としてエク"
"スポートせねばなりません。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:63
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.js}}\n"
msgstr "{{#include ../exercises/chapter10/test/URI.js}}\n"

#. type: Plain text
#: text/chapter10.md:68
msgid ""
"Since version 0.15, Purescript uses the ES module system when interoperating "
"with JavaScript. In ES modules, functions and values are exported from a "
"module by providing the `export` keyword on an object."
msgstr ""
"バージョン0.15からPureScriptはJavaScriptと通訳する際にESモジュールシステムを"
"使います。\n"
"ESモジュールではオブジェクトに`export`キーワードを与えることで関数と値がモ"
"ジュールからエクスポートされます。"

#. type: Plain text
#: text/chapter10.md:70
msgid ""
"With these two pieces in place, we can now use the `_encodeURIComponent` "
"function from PureScript like any function written in PureScript. For "
"example, in PSCi, we can reproduce the calculation above:"
msgstr ""
"これら2つの部品を使うことで、PureScriptで書かれた関数のように、PureScriptから"
"`encodeURIComponent`関数を使うことができます。\n"
"例えばPSCiで上記の計算を再現できます。"

#. type: Fenced code block (text)
#: text/chapter10.md:71
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.URI\n"
"> _encodeURIComponent \"Hello World\"\n"
"\"Hello%20World\"\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.URI\n"
"> _encodeURIComponent \"Hello World\"\n"
"\"Hello%20World\"\n"

#. type: Plain text
#: text/chapter10.md:80
msgid ""
"We can also define our own functions in foreign modules. Here's an example "
"of how to create and call a custom JavaScript function that squares a "
"`Number`:"
msgstr ""
"外部モジュールには独自の関数も定義できます。\n"
"以下は`Number`を平方する独自のJavaScript関数を作って呼び出す方法の一例です。"

#. type: Plain text
#: text/chapter10.md:82
msgid "`test/Examples.js`:"
msgstr "`test/Examples.js`:"

#. type: Fenced code block (js)
#: text/chapter10.md:83
#, no-wrap
msgid ""
"\"use strict\";\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.js:square}}\n"
msgstr ""
"\"use strict\";\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.js:square}}\n"

#. type: Plain text
#: text/chapter10.md:90
msgid "`test/Examples.purs`:"
msgstr "`test/Examples.purs`:"

#. type: Fenced code block (hs)
#: text/chapter10.md:91
#, no-wrap
msgid ""
"module Test.Examples where\n"
"\n"
"foreign import square :: Number -> Number\n"
msgstr ""
"module Test.Examples where\n"
"\n"
"foreign import square :: Number -> Number\n"

#. type: Fenced code block (text)
#: text/chapter10.md:97
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> square 5.0\n"
"25.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> square 5.0\n"
"25.0\n"

#. type: Title ##
#: text/chapter10.md:105
#, no-wrap
msgid "Functions of Multiple Arguments"
msgstr "多変数関数"

#. type: Plain text
#: text/chapter10.md:108
msgid ""
"Let's rewrite our `diagonal` function from Chapter 2 in a foreign module. "
"This function calculates the diagonal of a right-angled triangle."
msgstr ""
"第2章の`diagonal`関数を外部モジュールで書き直してみましょう。\n"
"この関数は直角三角形の対角線を計算します。"

#. type: Fenced code block (hs)
#: text/chapter10.md:109
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:diagonal}}\n"

#. type: Plain text
#: text/chapter10.md:114
msgid ""
"Recall that functions in PureScript are _curried_. `diagonal` is a function "
"that takes a `Number` and returns a _function_ that takes a `Number` and "
"returns a `Number`."
msgstr ""
"PureScriptの関数は*カリー化*されていることを思い出してください。\n"
"`diagonal`は`Number`を取って*関数*を返す関数です。\n"
"そして返された関数は`Number`を取って`Number`を返します。"

#. type: Fenced code block (js)
#: text/chapter10.md:115
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.js:diagonal}}\n"

#. type: Plain text
#: text/chapter10.md:120
msgid "Or with ES6 arrow syntax (see ES6 note below)."
msgstr ""
"もしくはES6の矢印構文ではこうです（後述するES6についての補足を参照してくださ"
"い）。"

#. type: Fenced code block (js)
#: text/chapter10.md:121
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_arrow}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.js:diagonal_arrow}}\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:125
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_arrow}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_arrow}}\n"

#. type: Fenced code block (text)
#: text/chapter10.md:129
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> diagonal 3.0 4.0\n"
"5.0\n"
"> diagonalArrow 3.0 4.0\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> diagonal 3.0 4.0\n"
"5.0\n"
"> diagonalArrow 3.0 4.0\n"
"5.0\n"

#. type: Title ##
#: text/chapter10.md:139
#, no-wrap
msgid "Uncurried Functions"
msgstr "カリー化されていない関数"

#. type: Plain text
#: text/chapter10.md:142
msgid ""
"Writing curried functions in JavaScript isn't always feasible, despite being "
"scarcely idiomatic. A typical multi-argument JavaScript function would be of "
"the _uncurried_ form:"
msgstr ""
"JavaScriptでカリー化された関数を書くことは、ただでさえJavaScriptらしいもので"
"はない上に、常に可能というわけでもありません。\n"
"よくある多変数なJavaScriptの関数は _カリー化されていない_ 形式を取るでしょ"
"う。"

#. type: Fenced code block (js)
#: text/chapter10.md:143
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_uncurried}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.js:diagonal_uncurried}}\n"

#. type: Plain text
#: text/chapter10.md:148
msgid ""
"The module `Data.Function.Uncurried` exports _wrapper_ types and utility "
"functions to work with uncurried functions."
msgstr ""
"モジュール`Data.Function.Uncurried`は*梱包*型とカリー化されていない関数を取り"
"扱う関数をエクスポートします。"

#. type: Fenced code block (hs)
#: text/chapter10.md:149
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_uncurried}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_uncurried}}\n"

#. type: Plain text
#: text/chapter10.md:154
msgid "Inspecting the type constructor `Fn2`:"
msgstr "型構築子`Fn2`を調べると以下です。"

#. type: Fenced code block (text)
#: text/chapter10.md:155
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Function.Uncurried \n"
"> :kind Fn2\n"
"Type -> Type -> Type -> Type\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.Function.Uncurried \n"
"> :kind Fn2\n"
"Type -> Type -> Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:164
msgid ""
"`Fn2` takes three type arguments. `Fn2 a b c` is a type representing an "
"uncurried function of two arguments of types `a` and `b`, that returns a "
"value of type `c`. We used it to import `diagonalUncurried` from the foreign "
"module."
msgstr ""
"`Fn2`は3つの型引数を取ります。\n"
"`Fn2 a b c`は、型`a`と`b`の2つの引数、返り値の型`c`を持つカリー化されていない"
"関数の型を表現しています。\n"
"これを使って外部モジュールから`diagonalUncurried`をインポートしました。"

#. type: Plain text
#: text/chapter10.md:166
msgid ""
"We can then call it with `runFn2`, which takes the uncurried function and "
"then the arguments."
msgstr ""
"そうして`runFn2`を使って呼び出せます。\n"
"これはカリー化されていない関数と引数を取るものです。"

#. type: Fenced code block (text)
#: text/chapter10.md:167
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Function.Uncurried\n"
"> runFn2 diagonalUncurried 3.0 4.0\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Function.Uncurried\n"
"> runFn2 diagonalUncurried 3.0 4.0\n"
"5.0\n"

#. type: Plain text
#: text/chapter10.md:177
msgid ""
"The `functions` package defines similar type constructors for function "
"arities from 0 to 10."
msgstr ""
"`functions`パッケージでは0引数から10引数までの関数について同様の型構築子が定"
"義されています。"

#. type: Title ##
#: text/chapter10.md:178
#, no-wrap
msgid "A Note About Uncurried Functions"
msgstr "カリー化されていない関数についての補足"

#. type: Plain text
#: text/chapter10.md:181
msgid ""
"PureScript's curried functions have certain advantages. It allows us to "
"partially apply functions, and to give type class instances for function "
"types – but it comes with a performance penalty. For performance-critical "
"code, it is sometimes necessary to define uncurried JavaScript functions "
"which accept multiple arguments."
msgstr ""
"PureScriptのカリー化された関数には勿論利点があります。\n"
"部分的に関数を適用でき、関数型に型クラスインスタンスを与えられるのです。\n"
"しかし効率上の代償も付いてきます。\n"
"効率性が決定的に重要なコードでは時々、多変数を受け付けるカリー化されていない"
"JavaScript関数を定義する必要があります。"

#. type: Plain text
#: text/chapter10.md:183
msgid ""
"We can also create uncurried functions from PureScript. For a function of "
"two arguments, we can use the `mkFn2` function."
msgstr ""
"PureScriptでカリー化されていない関数を作ることもできます。\n"
"2引数の関数については`mkFn2`関数が使えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:184
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_add}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_add}}\n"

#. type: Plain text
#: text/chapter10.md:189
msgid ""
"We can apply the uncurried function of two arguments by using `runFn2` as "
"before:"
msgstr ""
"前と同様に`runFn2`関数を使うと、カリー化されていない2引数の関数を適用できま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:190
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_sum}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_sum}}\n"

#. type: Plain text
#: text/chapter10.md:195
msgid ""
"The key here is that the compiler _inlines_ the `mkFn2` and `runFn2` "
"functions whenever they are fully applied. The result is that the generated "
"code is very compact:"
msgstr ""
"ここで重要なのは、引数が全て適用されるなら、コンパイラは `mkFn2`関数や "
"`runFn2`関数を*インライン化*するということです。\n"
"そのため、生成されるコードはとても簡潔になります。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:196
#, no-wrap
msgid ""
"var uncurriedAdd = function (n, m) {\n"
"  return m + n | 0;\n"
"};\n"
"\n"
"var uncurriedSum = uncurriedAdd(3, 10);\n"
msgstr ""
"var uncurriedAdd = function (n, m) {\n"
"  return m + n | 0;\n"
"};\n"
"\n"
"var uncurriedSum = uncurriedAdd(3, 10);\n"

#. type: Plain text
#: text/chapter10.md:205
msgid "For contrast, here is a traditional curried function:"
msgstr "対照的に、こちらがこれまでのカリー化された関数です。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:curried_add}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:curried_add}}\n"

#. type: Plain text
#: text/chapter10.md:211
msgid ""
"And the resulting generated code, which is less compact due to the nested "
"functions:"
msgstr ""
"そして生成結果のコードが以下です。\n"
"入れ子の関数のため比較的簡潔ではありません。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:212
#, no-wrap
msgid ""
"var curriedAdd = function (n) {\n"
"  return function (m) {\n"
"    return m + n | 0;\n"
"  };\n"
"};\n"
"\n"
"var curriedSum = curriedAdd(3)(10);\n"
msgstr ""
"var curriedAdd = function (n) {\n"
"  return function (m) {\n"
"    return m + n | 0;\n"
"  };\n"
"};\n"
"\n"
"var curriedSum = curriedAdd(3)(10);\n"

#. type: Title ##
#: text/chapter10.md:222
#, no-wrap
msgid "A Note About Modern JavaScript Syntax"
msgstr "現代的なJavaScriptの構文についての補足"

#. type: Plain text
#: text/chapter10.md:225
msgid ""
"The arrow function syntax we saw earlier is an ES6 feature, which is "
"incompatible with some older browsers (namely IE11). As of writing, it is "
"[estimated that arrow functions are unavailable for the 6% of users](https://"
"caniuse.com/#feat=arrow-functions) who have not yet updated their web "
"browser."
msgstr ""
"前に見た矢印関数構文はES6の機能であり、そのため幾つかの古いブラウザ（名指しす"
"ればIE11）と互換性がありません。\n"
"執筆時点でwebブラウザをまだ更新していない[6%の利用者が矢印関数を使うことがで"
"きないと推計](https://caniuse.com/#feat=arrow-functions)されています。"

#. type: Plain text
#: text/chapter10.md:227
msgid ""
"To be compatible with the most users, the JavaScript code generated by the "
"PureScript compiler does not use arrow functions. It is also recommended to "
"**avoid arrow functions in public libraries** for the same reason."
msgstr ""
"ほとんどの利用者にとって互換性があるようにするため、PureScriptコンパイラに"
"よって生成されるJavaScriptコードは矢印関数を使っていません。\n"
"また、同じ理由で**公開するライブラリでも矢印関数を避ける**ことが推奨されま"
"す。"

#. type: Plain text
#: text/chapter10.md:229
msgid ""
"You may still use arrow functions in your own FFI code, but then you should "
"include a tool such as [Babel](https://github.com/babel/babel#intro) in your "
"deployment workflow to convert these back to ES5 compatible functions."
msgstr ""
"それでも自分のFFIコードで矢印関数を使うこともできますが、デプロイの作業工程で"
"ES5に互換性のある関数へ変換するために[Babel](https://github.com/babel/"
"babel#intro)などのツールを含めると良いでしょう。"

#. type: Plain text
#: text/chapter10.md:231
msgid ""
"If you find arrow functions in ES6 more readable, you may transform "
"JavaScript code in the compiler's `output` directory with a tool like [Lebab]"
"(https://github.com/lebab/lebab):"
msgstr ""
"ES6の矢印関数がより読みやすく感じたら[Lebab](https://github.com/lebab/lebab)"
"のようなツールを使ってコンパイラの`output`ディレクトリにJavaScriptのコードを"
"変換できます。"

#. type: Fenced code block (sh)
#: text/chapter10.md:232
#, no-wrap
msgid ""
"npm i -g lebab\n"
"lebab --replace output/ --transform arrow,arrow-return\n"
msgstr ""
"npm i -g lebab\n"
"lebab --replace output/ --transform arrow,arrow-return\n"

#. type: Plain text
#: text/chapter10.md:238
msgid "This operation would convert the above `curriedAdd` function to:"
msgstr "この操作により上の`curriedAdd`関数は以下に変換されます。"

#. type: Fenced code block (js)
#: text/chapter10.md:239
#, no-wrap
msgid ""
"var curriedAdd = n => m =>\n"
"  m + n | 0;\n"
msgstr ""
"var curriedAdd = n => m =>\n"
"  m + n | 0;\n"

#. type: Plain text
#: text/chapter10.md:245
msgid ""
"The remaining examples in this book will use arrow functions instead of "
"nested functions."
msgstr "本書の残りの例では入れ子の関数の代わりに矢印関数を使います。"

#. type: Title ##
#: text/chapter10.md:246 text/chapter10.md:321 text/chapter10.md:478
#: text/chapter10.md:716 text/chapter10.md:893 text/chapter10.md:1076
#: text/chapter10.md:1313 text/chapter11.md:141 text/chapter11.md:223
#: text/chapter11.md:342 text/chapter11.md:548 text/chapter11.md:715
#: text/chapter11.md:914 text/chapter11.md:959 text/chapter12.md:153
#: text/chapter12.md:361 text/chapter12.md:555 text/chapter13.md:90
#: text/chapter13.md:137 text/chapter13.md:244 text/chapter13.md:387
#: text/chapter14.md:249 text/chapter14.md:352 text/chapter14.md:569
#: text/chapter14.md:704 text/chapter2.md:124 text/chapter3.md:774
#: text/chapter4.md:70 text/chapter4.md:181 text/chapter4.md:363
#: text/chapter4.md:521 text/chapter4.md:615 text/chapter5.md:99
#: text/chapter5.md:228 text/chapter5.md:392 text/chapter5.md:465
#: text/chapter5.md:524 text/chapter6.md:130 text/chapter6.md:321
#: text/chapter6.md:411 text/chapter6.md:608 text/chapter6.md:742
#: text/chapter7.md:381 text/chapter7.md:540 text/chapter7.md:642
#: text/chapter8.md:308 text/chapter8.md:667 text/chapter8.md:974
#: text/chapter9.md:87 text/chapter9.md:134 text/chapter9.md:201
#, no-wrap
msgid "Exercises"
msgstr "演習"

#. type: Bullet: '1. '
#: text/chapter10.md:250
msgid ""
"(Medium) Write a JavaScript function `volumeFn` in the `Test.MySolutions` "
"module that finds the volume of a box. Use an `Fn` wrapper from `Data."
"Function.Uncurried`."
msgstr ""
"（普通）`Test.MySolutions`モジュールの中に箱の体積を求めるJavaScriptの関数"
"`volumeFn`を書いてください。\n"
"`Data.Function.Uncurried`の梱包`Fn`を使ってください。"

#. type: Bullet: '2. '
#: text/chapter10.md:250
msgid "(Medium) Rewrite `volumeFn` with arrow functions as `volumeArrow`."
msgstr ""
"（普通）`volumeFn`を矢印関数を使って書き直し、`volumeArrow`としてください。"

#. type: Title ##
#: text/chapter10.md:251
#, no-wrap
msgid "Passing Simple Types"
msgstr "単純な型を渡す"

#. type: Plain text
#: text/chapter10.md:254
msgid ""
"The following data types may be passed between PureScript and JavaScript as-"
"is:"
msgstr ""
"以下のデータ型はPureScriptとJavaScriptの間でそのまま渡し合うことができます。"

#. type: Plain text
#: text/chapter10.md:262
msgid ""
"PureScript | JavaScript --- | --- Boolean | Boolean String | String Int, "
"Number | Number Array | Array Record | Object"
msgstr ""
"PureScript  | JavaScript\n"
"---         | ---\n"
"Boolean     | Boolean\n"
"String      | String\n"
"Int, Number | Number\n"
"Array       | Array\n"
"Record      | Object"

#. type: Plain text
#: text/chapter10.md:264
msgid ""
"We've already seen examples with the primitive types `String` and `Number`. "
"We'll now take a look at the structural types `Array` and `Record` (`Object` "
"in JavaScript)."
msgstr ""
"`String`と`Number`という原始型の例は既に見てきました。\n"
"ここから`Array`や`Record`（JavaScriptでは`Object`）といった構造的な型を眺めて"
"いきます。"

#. type: Plain text
#: text/chapter10.md:266
msgid ""
"To demonstrate passing `Array`s, here's how to call a JavaScript function "
"that takes an `Array` of `Int` and returns the cumulative sum as another "
"array. Recall that since JavaScript does not have a separate type for `Int`, "
"both `Int` and `Number` in PureScript translate to `Number` in JavaScript."
msgstr ""
"`Array`を渡すところを実演するために、以下に`Int`の`Array`を取って別の配列とし"
"て累計の和を返すJavaScriptの関数の呼び出し方を示します。\n"
"前にありましたが、JavaScriptは`Int`のための分離した型を持たないため、"
"PureScriptでの`Int`と`Number`は両方共JavaScriptでの`Number`に翻訳されます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:267
#, no-wrap
msgid "foreign import cumulativeSums :: Array Int -> Array Int\n"
msgstr "foreign import cumulativeSums :: Array Int -> Array Int\n"

#. type: Fenced code block (js)
#: text/chapter10.md:271
#, no-wrap
msgid ""
"export const cumulativeSums = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  return sums;\n"
"};\n"
msgstr ""
"export const cumulativeSums = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  return sums;\n"
"};\n"

#. type: Fenced code block (text)
#: text/chapter10.md:283
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> cumulativeSums [1, 2, 3]\n"
"[1,3,6]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> cumulativeSums [1, 2, 3]\n"
"[1,3,6]\n"

#. type: Plain text
#: text/chapter10.md:292
msgid ""
"To demonstrate passing `Records`, here's how to call a JavaScript function "
"that takes two `Complex` numbers as records and returns their sum as another "
"record. Note that a `Record` in PureScript is represented as an `Object` in "
"JavaScript:"
msgstr ""
"`Record`を渡すところを実演するために、以下に2つの`Complex`な数をレコードとし"
"て取り、和を別のレコードとして返すJavaScriptの呼び出し方を示します。\n"
"PureScriptでの`Record`がJavaScriptでは`Object`として表現されることに注意して"
"ください。"

#. type: Fenced code block (hs)
#: text/chapter10.md:293
#, no-wrap
msgid ""
"type Complex = {\n"
"  real :: Number,\n"
"  imag :: Number\n"
"}\n"
"\n"
"foreign import addComplex :: Complex -> Complex -> Complex\n"
msgstr ""
"type Complex = {\n"
"  real :: Number,\n"
"  imag :: Number\n"
"}\n"
"\n"
"foreign import addComplex :: Complex -> Complex -> Complex\n"

#. type: Fenced code block (js)
#: text/chapter10.md:302
#, no-wrap
msgid ""
"export const addComplex = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    imag: a.imag + b.imag\n"
"  }\n"
"};\n"
msgstr ""
"export const addComplex = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    imag: a.imag + b.imag\n"
"  }\n"
"};\n"

#. type: Fenced code block (text)
#: text/chapter10.md:311
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"{ imag: 6.0, real: 4.0 }\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"{ imag: 6.0, real: 4.0 }\n"

#. type: Plain text
#: text/chapter10.md:320
msgid ""
"Note that the above techniques require trusting that JavaScript will return "
"the expected types, as PureScript cannot apply type checking to JavaScript "
"code. We will describe this type safety concern in more detail later on in "
"the JSON section, as well as cover techniques to protect against type "
"mismatches."
msgstr ""
"なお、上の手法にはJavaScriptが期待通りの型を返すことを信用する必要がありま"
"す。\n"
"PureScriptはJavaScriptのコードに型検査を適用できないからです。\n"
"この型安全性の配慮について後のJSONの節でより詳しく解説していきます。\n"
"型の不整合から身を守る手法についても押さえます。"

#. type: Bullet: '1. '
#: text/chapter10.md:324
msgid ""
"(Medium) Write a JavaScript function `cumulativeSumsComplex` (and "
"corresponding PureScript foreign import) that takes an `Array` of `Complex` "
"numbers and returns the cumulative sum as another array of complex numbers."
msgstr ""
"（普通）`Complex`な数の配列を取って別の複素数の配列として累計の和を返す"
"JavaScriptの関数`cumulativeSumsComplex`（と対応するPureScriptの外部インポー"
"ト）を書いてください。"

#. type: Title ##
#: text/chapter10.md:325
#, no-wrap
msgid "Beyond Simple Types"
msgstr "単純な型を越えて"

#. type: Plain text
#: text/chapter10.md:328
msgid ""
"We have seen examples of how to send and receive types with a native "
"JavaScript representation, such as `String`, `Number`, `Array`, and "
"`Record`, over FFI. Now we'll cover how to use some of the other types "
"available in PureScript, like `Maybe`."
msgstr ""
"`String`、`Number`、`Array`、そして`Record`といった、JavaScript固有の表現を持"
"つ型をFFI越しに送ったり受け取ったりする方法を数例見てきました。\n"
"ここから`Maybe`のようなPureScriptで使える幾つかの他の型の使い方を押さえていき"
"ます。"

#. type: Plain text
#: text/chapter10.md:330
msgid ""
"Suppose we wanted to recreate the `head` function on arrays by using a "
"foreign declaration. In JavaScript, we might write the function as follows:"
msgstr ""
"外部宣言を使用して、配列についての `head`関数を改めて作成したいとしましょ"
"う。\n"
"JavaScriptでは次のような関数を書くことになるでしょう。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:331
#, no-wrap
msgid ""
"export const head = arr =>\n"
"  arr[0];\n"
msgstr ""
"export const head = arr =>\n"
"  arr[0];\n"

#. type: Plain text
#: text/chapter10.md:337
#, no-wrap
msgid "How would we type this function? We might try to give it the type `forall a. Array a -> a`, but for empty arrays, this function returns `undefined`. Therefore, the type `forall a. Array a -> a` does not correctly represent this implementation.\n"
msgstr ""
"この関数をどう型付けましょうか。\n"
"型 `forall a. Array a -> a`を与えようとしても、空の配列に対してこの関数は `undefined`を返します。\n"
"したがって型`forall a. Array a -> a`は正しくこの実装を表現していないのです。\n"

#. type: Plain text
#: text/chapter10.md:339
msgid "We instead want to return a `Maybe` value to handle this corner case:"
msgstr "代わりにこの特殊な場合を扱うために`Maybe`値を返したいところです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:340
#, no-wrap
msgid "foreign import maybeHead :: forall a. Array a -> Maybe a\n"
msgstr "foreign import maybeHead :: forall a. Array a -> Maybe a\n"

#. type: Plain text
#: text/chapter10.md:345
msgid "But how do we return a `Maybe`? It is tempting to write the following:"
msgstr ""
"しかしどうやって`Maybe`を返しましょうか。\n"
"つい以下のように書きたくなります。"

#. type: Fenced code block (js)
#: text/chapter10.md:346
#, no-wrap
msgid ""
"// Don't do this\n"
"import Data_Maybe from '../Data.Maybe'\n"
"\n"
"export const maybeHead = arr => {\n"
"  if (arr.length) {\n"
"    return Data_Maybe.Just.create(arr[0]);\n"
"  } else {\n"
"    return Data_Maybe.Nothing.value;\n"
"  }\n"
"}\n"
msgstr ""
"// こうしないでください\n"
"import Data_Maybe from '../Data.Maybe'\n"
"\n"
"export const maybeHead = arr => {\n"
"  if (arr.length) {\n"
"    return Data_Maybe.Just.create(arr[0]);\n"
"  } else {\n"
"    return Data_Maybe.Nothing.value;\n"
"  }\n"
"}\n"

#. type: Plain text
#: text/chapter10.md:360
msgid ""
"Importing and using the `Data.Maybe` module directly in the foreign module "
"isn't recommended as it makes our code brittle to changes in the code "
"generator &mdash; `create` and `value` are not public APIs. Additionally, "
"doing this can cause problems when using `purs bundle` for dead code "
"elimination."
msgstr ""
"外部モジュールで直接`Data.Maybe`モジュールをインポートして使うことはお勧めし"
"ません。というのもコードがコード生成器の変化に対して脆くなるからです。"
"`create`や`value`は公開のAPIではありません。加えて、このようにすると、不要な"
"コードを消去する`purs bundle`を使う際に問題を引き起こす可能性があります。"

#. type: Plain text
#: text/chapter10.md:362
msgid ""
"The recommended approach is to add extra parameters to our FFI-defined "
"function to accept the functions we need."
msgstr ""
"推奨されるやり方はFFIで定義された関数に余剰の引数を加えて必要な関数を受け付け"
"ることです。"

#. type: Fenced code block (js)
#: text/chapter10.md:363
#, no-wrap
msgid ""
"export const maybeHeadImpl = just => nothing => arr => {\n"
"  if (arr.length) {\n"
"    return just(arr[0]);\n"
"  } else {\n"
"    return nothing;\n"
"  }\n"
"};\n"
msgstr ""
"export const maybeHeadImpl = just => nothing => arr => {\n"
"  if (arr.length) {\n"
"    return just(arr[0]);\n"
"  } else {\n"
"    return nothing;\n"
"  }\n"
"};\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:373
#, no-wrap
msgid ""
"foreign import maybeHeadImpl :: forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
"\n"
"maybeHead :: forall a. Array a -> Maybe a\n"
"maybeHead arr = maybeHeadImpl Just Nothing arr\n"
msgstr ""
"foreign import maybeHeadImpl :: forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
"\n"
"maybeHead :: forall a. Array a -> Maybe a\n"
"maybeHead arr = maybeHeadImpl Just Nothing arr\n"

#. type: Plain text
#: text/chapter10.md:381
msgid "Note that we wrote:"
msgstr "ただし、次のように書きますが、"

#. type: Fenced code block (hs)
#: text/chapter10.md:382
#, no-wrap
msgid "forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
msgstr "forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"

#. type: Plain text
#: text/chapter10.md:387
msgid "And not:"
msgstr "以下ではないことに注意です。"

#. type: Fenced code block (hs)
#: text/chapter10.md:388
#, no-wrap
msgid "forall a. (a -> Maybe a) -> Maybe a -> Array a -> Maybe a\n"
msgstr "forall a. (a -> Maybe a) -> Maybe a -> Array a -> Maybe a\n"

#. type: Plain text
#: text/chapter10.md:393
msgid ""
"While both forms work, the latter is more vulnerable to unwanted inputs in "
"place of `Just` and `Nothing`."
msgstr ""
"どちらの形式でも動きますが、後者は`Just`と`Nothing`の場所での招かれざる入力に"
"対してより脆弱です。"

#. type: Plain text
#: text/chapter10.md:395
msgid "For example, in the more vulnerable case, we could call it as follows:"
msgstr "例えば、比較的脆い方では、以下のように呼び出せるでしょう。"

#. type: Fenced code block (hs)
#: text/chapter10.md:396
#, no-wrap
msgid "maybeHeadImpl (\\_ -> Just 1000) (Just 1000) [1,2,3]\n"
msgstr "maybeHeadImpl (\\_ -> Just 1000) (Just 1000) [1,2,3]\n"

#. type: Plain text
#: text/chapter10.md:401
msgid "Which returns `Just 1000` for any array input."
msgstr "これは如何なる配列の入力に対しても`Just 1000`を返します。"

#. type: Plain text
#: text/chapter10.md:403
#, no-wrap
msgid "This vulnerability is allowed because `(\\_ -> Just 1000)` and `Just 1000` match the signatures of `(a -> Maybe a)` and `Maybe a`, respectively, when `a` is `Int` (based on input array).\n"
msgstr "この脆弱性では、`a`が`Int`のときに（これは入力の配列に基づきます）`(\\_ -> Just 1000)`と`Just 1000`がシグネチャ`(a -> Maybe a)`と`Maybe a`にそれぞれ照合するために許容されてしまっています。\n"

#. type: Plain text
#: text/chapter10.md:406
#, no-wrap
msgid ""
"In the more secure type signature, even when `a` is determined to be `Int` based on the input array, we still need to provide valid functions matching the signatures involving `forall x`.\n"
"The _only_ option for `(forall x. Maybe x)` is `Nothing`, since a `Just` value would assume a type for `x` and will no longer be valid for all `x`. The only options for `(forall x. x -> Maybe x)` are `Just` (our desired argument) and `(\\_ -> Nothing)`, which is the only remaining vulnerability.\n"
msgstr "より安全な型シグネチャでは、入力の配列に基づいて`a`が`Int`に決定されたとしても、`forall x`に絡むシグネチャに合致する妥当な関数を提供する必要があります。`(forall x. Maybe x)`の *唯一* の選択肢は`Nothing`ですが、それは`Just`値が`x`の型を前提にしてしまうと、もはや全ての`x`については妥当でなくなってしまうからです。`(forall x. x -> Maybe x)`の唯一の選択肢は`Just`（望まれている引数）と`(\\_ -> Nothing)`であり、後者は唯一残っている脆弱性になるのです。\n"

#. type: Title ##
#: text/chapter10.md:407
#, no-wrap
msgid "Defining Foreign Types"
msgstr "外部型の定義"

#. type: Plain text
#: text/chapter10.md:410
msgid ""
"Suppose instead of returning a `Maybe a`, we want to return `arr[0]`. We "
"want a type that represents a value either of type `a` or the `undefined` "
"value (but not `null`). We'll call this type `Undefined a`."
msgstr ""
"`Maybe a`を返す代わりに`arr[0]`を返したいのだとしましょう。\n"
"型`a`ないし`undefined`値（ただし`null`ではありません）の何れかの値を表現する"
"型がほしいです。\n"
"この型を`Undefined a`と呼びましょう。"

#. type: Plain text
#: text/chapter10.md:412
msgid ""
"We can define a _foreign type_ using a _foreign type declaration_. The "
"syntax is similar to defining a foreign function:"
msgstr ""
"_外部インポート宣言_ を使うと、*外部型* (foreign type) を定義できます。構文は"
"外部関数を定義するのと似ています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:413
#, no-wrap
msgid "foreign import data Undefined :: Type -> Type\n"
msgstr "foreign import data Undefined :: Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:418
#, no-wrap
msgid "The `data` keyword here indicates that we are defining a _type_, not a value. Instead of a type signature, we give the _kind_ of the new type. In this case, we declare the kind of `Undefined` to be `Type -> Type`. In other words, `Undefined` is a type constructor.\n"
msgstr ""
"このキーワード`data`は*型*を定義していることを表しています。\n"
"値ではありせん。\n"
"型シグネチャの代わりに、新しい型の*種*を与えます。\n"
"この場合は`Undefined`の種が `Type -> Type`であると宣言しています。\n"
"言い換えれば`Undefined`は型構築子です。\n"

#. type: Plain text
#: text/chapter10.md:420
msgid "We can now reuse our original definition for `head`:"
msgstr "これで元の`head`の定義を再利用できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:421
#, no-wrap
msgid ""
"export const undefinedHead = arr =>\n"
"  arr[0];\n"
msgstr ""
"export const undefinedHead = arr =>\n"
"  arr[0];\n"

#. type: Plain text
#: text/chapter10.md:427
msgid "And in the PureScript module:"
msgstr "PureScriptモジュールには以下を追加します。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:428
#, no-wrap
msgid "foreign import undefinedHead :: forall a. Array a -> Undefined a\n"
msgstr "foreign import undefinedHead :: forall a. Array a -> Undefined a\n"

#. type: Plain text
#: text/chapter10.md:433
msgid ""
"The body of the `undefinedHead` function returns `arr[0]`, which may be "
"`undefined`, and the type signature correctly reflects that fact."
msgstr ""
"`undefinedHead`関数の本体は`undefined`かもしれない`arr[0]`を返します。\n"
"そしてこの型シグネチャはその事実を正しく反映しています。"

#. type: Plain text
#: text/chapter10.md:435
msgid ""
"This function has the correct runtime representation for its type, but it's "
"quite useless since we have no way to use a value of type `Undefined a`. "
"Well, not exactly. We can use this type in another FFI!"
msgstr ""
"この関数はその型の適切な実行時表現を持っていますが、型`Undefined a`の値を使用"
"する方法がないので、全く役に立ちません。\n"
"いや、言い過ぎました。\n"
"別のFFIでこの型を使えますからね。"

#. type: Plain text
#: text/chapter10.md:437
msgid ""
"We can write a function that will tell us whether a value is undefined or "
"not:"
msgstr "値が未定義かどうかを教えてくれる関数を書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:438
#, no-wrap
msgid "foreign import isUndefined :: forall a. Undefined a -> Boolean\n"
msgstr "foreign import isUndefined :: forall a. Undefined a -> Boolean\n"

#. type: Plain text
#: text/chapter10.md:443
msgid "This is defined in our foreign JavaScript module as follows:"
msgstr "外部JavaScriptモジュールで次のように定義できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:444
#, no-wrap
msgid ""
"export const isUndefined = value =>\n"
"  value === undefined;\n"
msgstr ""
"export const isUndefined = value =>\n"
"  value === undefined;\n"

#. type: Plain text
#: text/chapter10.md:450
msgid ""
"We can now use `isUndefined` and `undefinedHead` together from PureScript to "
"define a useful function:"
msgstr ""
"これでPureScriptで `isUndefined`と `undefinedHead`を一緒に使用すると、便利な"
"関数を定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:451
#, no-wrap
msgid ""
"isEmpty :: forall a. Array a -> Boolean\n"
"isEmpty = isUndefined <<< undefinedHead\n"
msgstr ""
"isEmpty :: forall a. Array a -> Boolean\n"
"isEmpty = isUndefined <<< undefinedHead\n"

#. type: Plain text
#: text/chapter10.md:457
msgid ""
"Here, the foreign function we defined is very simple, which means we can "
"benefit from using PureScript's typechecker as much as possible. This is "
"good practice in general: foreign functions should be kept as small as "
"possible, and application logic moved into PureScript code wherever possible."
msgstr ""
"このように、定義したこの外部関数はとても単純です。\n"
"つまりPureScriptの型検査器を使うことによる利益が最大限得られるのです。\n"
"一般に、外部関数は可能な限り小さく保ち、できるだけアプリケーションの処理は"
"PureScriptコードへ移動しておくことをお勧めします。"

#. type: Title ##
#: text/chapter10.md:458 text/chapter8.md:365 text/chapter8.md:444
#, no-wrap
msgid "Exceptions"
msgstr "例外"

#. type: Plain text
#: text/chapter10.md:461
msgid ""
"Another option is to simply throw an exception in the case of an empty "
"array. Strictly speaking, pure functions should not throw exceptions, but we "
"have the flexibility to do so. We indicate the lack of safety in the "
"function name:"
msgstr ""
"他の選択肢としては、空の配列の場合に例外を投げる方法があります。\n"
"厳密に言えば、純粋な関数は例外を投げるべきではありませんが、そうする柔軟さは"
"あります。\n"
"安全性に欠けていることを関数名で示します。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:462
#, no-wrap
msgid "foreign import unsafeHead :: forall a. Array a -> a\n"
msgstr "foreign import unsafeHead :: forall a. Array a -> a\n"

#. type: Plain text
#: text/chapter10.md:467
msgid ""
"In our foreign JavaScript module, we can define `unsafeHead` as follows:"
msgstr "JavaScriptモジュールでは、`unsafeHead`を以下のように定義できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:468
#, no-wrap
msgid ""
"export const unsafeHead = arr => {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"
msgstr ""
"export const unsafeHead = arr => {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"

#. type: Bullet: '1. '
#: text/chapter10.md:481
msgid ""
"(Medium) Given a record that represents a quadratic polynomial `a*x^2 + b*x "
"+ c = 0`:"
msgstr ""
"（普通）二次多項式`a*x^2 + b*x + c = 0`を表現するレコードが与えられているとし"
"ます。"

#. type: Plain text
#: text/chapter10.md:489
#, no-wrap
msgid ""
"    ```hs\n"
"    type Quadratic = {\n"
"      a :: Number,\n"
"      b :: Number,\n"
"      c :: Number\n"
"    }\n"
"    ```\n"
msgstr ""
"    ```hs\n"
"    type Quadratic = {\n"
"      a :: Number,\n"
"      b :: Number,\n"
"      c :: Number\n"
"    }\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:491
#, no-wrap
msgid "    Write a JavaScript function `quadraticRootsImpl` and a wrapper `quadraticRoots :: Quadratic -> Pair Complex` that uses the quadratic formula to find the roots of this polynomial. Return the two roots as a `Pair` of `Complex` numbers. _Hint:_ Use the `quadraticRoots` wrapper to pass a constructor for `Pair` to `quadraticRootsImpl`.\n"
msgstr ""
"    二次多項式を使ってこの多項式の根を求めるJavaScriptの関数`quadraticRootsImpl`とその梱包の`quadraticRoots :: Quadratic -> Pair Complex`を書いてください。\n"
"    2つの根を`Complex`の数の`Pair`として返してください。\n"
"    *手掛かり*：梱包`quadraticRoots`を使って`Pair`の構築子を`quadraticRootsImpl`に渡してください。\n"

#. type: Bullet: '1. '
#: text/chapter10.md:493
msgid ""
"(Medium) Write the function `toMaybe :: forall a. Undefined a -> Maybe a`. "
"This function converts `undefined` to `Nothing` and `a` values to `Just`s."
msgstr ""
"（普通）関数`toMaybe :: forall a. Undefined a -> Maybe a`を書いてください。\n"
"この関数は`undefined`を`Nothing`に、`a`の値を`Just a`に変換します。"

#. type: Bullet: '1. '
#: text/chapter10.md:495
msgid "(Difficult) With `toMaybe` in place, we can rewrite `maybeHead` as"
msgstr ""
"（難しい）`toMaybe`が準備できたら、`maybeHead`を以下に書き換えられます。"

#. type: Plain text
#: text/chapter10.md:500
#, no-wrap
msgid ""
"    ```hs\n"
"    maybeHead :: forall a. Array a -> Maybe a\n"
"    maybeHead = toMaybe <<< undefinedHead\n"
"    ```\n"
msgstr ""
"    ```hs\n"
"    maybeHead :: forall a. Array a -> Maybe a\n"
"    maybeHead = toMaybe <<< undefinedHead\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:502
#, no-wrap
msgid "    Is this a better approach than our previous implementation? _Note:_ There is no unit test for this exercise.\n"
msgstr ""
"    これは前の実装よりも良いやり方なのでしょうか。\n"
"    *補足*：この演習のための単体試験はありません。\n"

#. type: Title ##
#: text/chapter10.md:503
#, no-wrap
msgid "Using Type Class Member Functions"
msgstr "型クラスメンバー関数を使う"

#. type: Plain text
#: text/chapter10.md:506
msgid ""
"Like our earlier guide on passing the `Maybe` constructor over FFI, this is "
"another case of writing PureScript that calls JavaScript, which calls "
"PureScript functions again. Here we will explore how to pass type class "
"member functions over the FFI."
msgstr ""
"つい先程までFFI越しに`Maybe`の構築子を渡す手引きをしましたが、今回は"
"JavaScriptを呼び出すPureScriptを書く別の場合です。\n"
"JavaScriptの呼び出しでも続けざまにPureScriptの関数を呼び出します。\n"
"ここでは型クラスのメンバー関数をFFI越しに渡す方法を探ります。"

#. type: Plain text
#: text/chapter10.md:508
msgid ""
"We start with writing a foreign JavaScript function that expects the "
"appropriate instance of `show` to match the type of `x`."
msgstr ""
"型`x`に合う適切な`show`のインスタンスを期待する外部JavaScript関数を書くことか"
"ら始めます。"

#. type: Fenced code block (js)
#: text/chapter10.md:509
#, no-wrap
msgid ""
"export const boldImpl = show => x =>\n"
"  show(x).toUpperCase() + \"!!!\";\n"
msgstr ""
"export const boldImpl = show => x =>\n"
"  show(x).toUpperCase() + \"!!!\";\n"

#. type: Plain text
#: text/chapter10.md:515
msgid "Then we write the matching signature:"
msgstr "それから対応するシグネチャを書きます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:516
#, no-wrap
msgid "foreign import boldImpl :: forall a. (a -> String) -> a -> String\n"
msgstr "foreign import boldImpl :: forall a. (a -> String) -> a -> String\n"

#. type: Plain text
#: text/chapter10.md:521
msgid "And a wrapper function that passes the correct instance of `show`:"
msgstr "そして`show`の正しいインスタンスを渡す梱包関数も書きます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:522
#, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold x = boldImpl show x\n"
msgstr ""
"bold :: forall a. Show a => a -> String\n"
"bold x = boldImpl show x\n"

#. type: Plain text
#: text/chapter10.md:528
msgid "Alternatively, in point-free form:"
msgstr "代えてポイントフリー形式だとこうです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:529
#, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold = boldImpl show\n"
msgstr ""
"bold :: forall a. Show a => a -> String\n"
"bold = boldImpl show\n"

#. type: Plain text
#: text/chapter10.md:535
msgid "We can then call the wrapper:"
msgstr "そうして梱包を呼び出すことができます。"

#. type: Fenced code block (text)
#: text/chapter10.md:536
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> bold (Tuple 1 \"Hat\")\n"
"\"(TUPLE 1 \\\"HAT\\\")!!!\"\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> bold (Tuple 1 \"Hat\")\n"
"\"(TUPLE 1 \\\"HAT\\\")!!!\"\n"

#. type: Plain text
#: text/chapter10.md:546
msgid ""
"Here's another example demonstrating passing multiple functions, including a "
"function of multiple arguments (`eq`):"
msgstr ""
"以下は複数の関数を渡す別の実演例です。\n"
"これらの関数には複数引数の関数 (`eq`) が含まれます。"

#. type: Fenced code block (js)
#: text/chapter10.md:547
#, no-wrap
msgid ""
"export const showEqualityImpl = eq => show => a => b => {\n"
"  if (eq(a)(b)) {\n"
"    return \"Equivalent\";\n"
"  } else {\n"
"    return show(a) + \" is not equal to \" + show(b);\n"
"  }\n"
"}\n"
msgstr ""
"export const showEqualityImpl = eq => show => a => b => {\n"
"  if (eq(a)(b)) {\n"
"    return \"Equivalent\";\n"
"  } else {\n"
"    return show(a) + \" is not equal to \" + show(b);\n"
"  }\n"
"}\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:557
#, no-wrap
msgid ""
"foreign import showEqualityImpl :: forall a. (a -> a -> Boolean) -> (a -> String) -> a -> a -> String\n"
"\n"
"showEquality :: forall a. Eq a => Show a => a -> a -> String\n"
"showEquality = showEqualityImpl eq show\n"
msgstr ""
"foreign import showEqualityImpl :: forall a. (a -> a -> Boolean) -> (a -> String) -> a -> a -> String\n"
"\n"
"showEquality :: forall a. Eq a => Show a => a -> a -> String\n"
"showEquality = showEqualityImpl eq show\n"

#. type: Fenced code block (text)
#: text/chapter10.md:564
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Maybe\n"
"> showEquality Nothing (Just 5)\n"
"\"Nothing is not equal to (Just 5)\"\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Maybe\n"
"> showEquality Nothing (Just 5)\n"
"\"Nothing is not equal to (Just 5)\"\n"

#. type: Title ##
#: text/chapter10.md:573
#, no-wrap
msgid "Effectful Functions"
msgstr "作用のある関数"

#. type: Plain text
#: text/chapter10.md:576
msgid ""
"Let's extend our `bold` function to log to the console. Logging is an "
"`Effect`, and `Effect`s are represented in JavaScript as a function of zero "
"arguments, `()` with arrow notation:"
msgstr ""
"`bold`関数を拡張してコンソールにログ出力するようにしましょう。\n"
"ログ出力は`Effect`であり、`Effect`はJavaScriptにおいて無引数関数として表現さ"
"れます。\n"
"つまり`()`と矢印記法だとこうです。"

#. type: Fenced code block (js)
#: text/chapter10.md:577
#, no-wrap
msgid ""
"export const yellImpl = show => x => () =>\n"
"  console.log(show(x).toUpperCase() + \"!!!\");\n"
msgstr ""
"export const yellImpl = show => x => () =>\n"
"  console.log(show(x).toUpperCase() + \"!!!\");\n"

#. type: Plain text
#: text/chapter10.md:583
msgid ""
"The new foreign import is the same as before, except that the return type "
"changed from `String` to `Effect Unit`."
msgstr ""
"新しくなった外部インポートは、返る型が`String`から`Effect Unit`に変わった点以"
"外は以前と同じです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:584
#, no-wrap
msgid ""
"foreign import yellImpl :: forall a. (a -> String) -> a -> Effect Unit\n"
"\n"
"yell :: forall a. Show a => a -> Effect Unit\n"
"yell = yellImpl show\n"
msgstr ""
"foreign import yellImpl :: forall a. (a -> String) -> a -> Effect Unit\n"
"\n"
"yell :: forall a. Show a => a -> Effect Unit\n"
"yell = yellImpl show\n"

#. type: Plain text
#: text/chapter10.md:592
msgid ""
"When testing this in the repl, notice that the string is printed directly to "
"the console (instead of being quoted), and a `unit` value is returned."
msgstr ""
"REPLで試すと文字列が（引用符で囲まれず）直接コンソールに印字され`unit`値が返"
"ることがわかります。"

#. type: Fenced code block (text)
#: text/chapter10.md:593
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> yell (Tuple 1 \"Hat\")\n"
"(TUPLE 1 \"HAT\")!!!\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> yell (Tuple 1 \"Hat\")\n"
"(TUPLE 1 \"HAT\")!!!\n"
"unit\n"

#. type: Plain text
#: text/chapter10.md:604
msgid ""
"There are also `EffectFn` wrappers from `Effect.Uncurried`. These are "
"similar to the `Fn` wrappers from `Data.Function.Uncurried` that we've "
"already seen. These wrappers let you call uncurried effectful functions in "
"PureScript."
msgstr ""
"`Effect.Uncurried`に梱包`EffectFn`というものもあります。\n"
"これらは既に見た`Data.Function.Uncurried`の梱包`Fn`に似ています。\n"
"これらの梱包があればカリー化されていない作用のある関数をPureScriptで呼び出す"
"ことができます。"

#. type: Plain text
#: text/chapter10.md:606
msgid ""
"You'd generally only use these if you want to call existing JavaScript "
"library APIs directly rather than wrapping those APIs in curried functions. "
"So it doesn't make much sense to present an example of uncurried `yell`, "
"where the JavaScript relies on PureScript type class members since you "
"wouldn't find that in the existing JavaScript ecosystem."
msgstr ""
"一般的にこれらを使うのは、こうしたAPIをカリー化された関数に包むのではなく、既"
"存のJavaScriptライブラリのAPIを直接呼び出したいときぐらいです。\n"
"したがってカリー化していない`yell`の例を見せてもあまり意味がありません。\n"
"というのもJavaScriptがPureScriptの型クラスのメンバーに依っているからで、更に"
"それは既存のJavaScriptの生態系にそのメンバーが見付からないためです。"

#. type: Plain text
#: text/chapter10.md:608
msgid ""
"Instead, we'll modify our previous `diagonal` example to include logging in "
"addition to returning the result:"
msgstr ""
"翻って以前の`diagonal`の例を変更し、結果を返すことに加えてログ出力を含めると"
"こうなります。"

#. type: Fenced code block (js)
#: text/chapter10.md:609
#, no-wrap
msgid ""
"export const diagonalLog = function(w, h) {\n"
"  let result = Math.sqrt(w * w + h * h);\n"
"  console.log(\"Diagonal is \" + result);\n"
"  return result;\n"
"};\n"
msgstr ""
"export const diagonalLog = function(w, h) {\n"
"  let result = Math.sqrt(w * w + h * h);\n"
"  console.log(\"Diagonal is \" + result);\n"
"  return result;\n"
"};\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:617
#, no-wrap
msgid "foreign import diagonalLog :: EffectFn2 Number Number Number\n"
msgstr "foreign import diagonalLog :: EffectFn2 Number Number Number\n"

#. type: Fenced code block (text)
#: text/chapter10.md:621
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Effect.Uncurried\n"
"> runEffectFn2 diagonalLog 3.0 4.0\n"
"Diagonal is 5\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Effect.Uncurried\n"
"> runEffectFn2 diagonalLog 3.0 4.0\n"
"Diagonal is 5\n"
"5.0\n"

#. type: Title ##
#: text/chapter10.md:631
#, no-wrap
msgid "Asynchronous Functions"
msgstr "非同期関数"

#. type: Plain text
#: text/chapter10.md:634
msgid ""
"Promises in JavaScript translate directly to asynchronous effects in "
"PureScript with the help of the `aff-promise` library. See that library's "
"[documentation](https://pursuit.purescript.org/packages/purescript-aff-"
"promise) for more information. We'll just go through a few examples."
msgstr ""
"`aff-promise`ライブラリの助けを借りるとJavaScriptのプロミスは直接PureScriptの"
"非同期作用に翻訳されます。\n"
"詳細についてはライブラリの[ドキュメント](https://pursuit.purescript.org/"
"packages/purescript-aff-promise)をあたってください。\n"
"ここでは幾つかの例に触れるだけとします。"

#. type: Plain text
#: text/chapter10.md:636
msgid ""
"Suppose we want to use this JavaScript `wait` promise (or asynchronous "
"function) in our PureScript project. It may be used to delay execution for "
"`ms` milliseconds."
msgstr ""
"JavaScriptの`wait`プロミス（または非同期関数）をPureScriptのプロジェクトで使"
"いたいとします。\n"
"`ms`ミリ秒分だけ送らせて実行させるのに使うことができます。"

#. type: Fenced code block (js)
#: text/chapter10.md:637
#, no-wrap
msgid "const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n"
msgstr "const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n"

#. type: Plain text
#: text/chapter10.md:642
msgid ""
"We just need to export it wrapped as an `Effect` (function of zero "
"arguments):"
msgstr "単に`Effect`（無引数関数）に包んで公開するだけで大丈夫です。"

#. type: Fenced code block (js)
#: text/chapter10.md:643
#, no-wrap
msgid ""
"export const sleepImpl = ms => () =>\n"
"  wait(ms);\n"
msgstr ""
"export const sleepImpl = ms => () =>\n"
"  wait(ms);\n"

#. type: Plain text
#: text/chapter10.md:649
msgid "Then import it as follows:"
msgstr "そして以下のようにインポートします。"

#. type: Fenced code block (hs)
#: text/chapter10.md:650
#, no-wrap
msgid ""
"foreign import sleepImpl :: Int -> Effect (Promise Unit)\n"
"\n"
"sleep :: Int -> Aff Unit\n"
"sleep = sleepImpl >>> toAffE\n"
msgstr ""
"foreign import sleepImpl :: Int -> Effect (Promise Unit)\n"
"\n"
"sleep :: Int -> Aff Unit\n"
"sleep = sleepImpl >>> toAffE\n"

#. type: Plain text
#: text/chapter10.md:658
msgid "We can then run this `Promise` in an `Aff` block like so:"
msgstr ""
"そうして`Aff`ブロック中でこの`Promise`を以下のように走らせることができます。"

#. type: Fenced code block (text)
#: text/chapter10.md:659
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Test.Examples\n"
"> import Effect.Class.Console\n"
"> import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   log \"waiting\"\n"
"…   sleep 300\n"
"…   log \"done waiting\"\n"
"…\n"
"waiting\n"
"unit\n"
"done waiting\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Test.Examples\n"
"> import Effect.Class.Console\n"
"> import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   log \"waiting\"\n"
"…   sleep 300\n"
"…   log \"done waiting\"\n"
"…\n"
"waiting\n"
"unit\n"
"done waiting\n"

#. type: Plain text
#: text/chapter10.md:678
msgid ""
"Note that asynchronous logging in the repl waits to print until the entire "
"block has finished executing. This code behaves more predictably when run "
"with `spago test` where there is a slight delay _between_ prints."
msgstr ""
"REPLでの非同期ログ出力はブロック全体が実行を終了するまで印字を待機する点に注"
"意しましょう。\n"
"このコードを`spago test`で走らせた場合、印字の*合間に*僅かな遅延があり、より"
"予測に近い挙動をします。"

#. type: Plain text
#: text/chapter10.md:680
msgid ""
"Let's look at another example where we return a value from a promise. This "
"function is written with `async` and `await`, which is just syntactic sugar "
"for promises."
msgstr ""
"他にプロミスから値を返す例を見てみましょう。\n"
"この関数は`async`と`await`を使って書かれていますが、これはプロミスの糖衣構文"
"に過ぎません。"

#. type: Fenced code block (js)
#: text/chapter10.md:681
#, no-wrap
msgid ""
"async function diagonalWait(delay, w, h) {\n"
"  await wait(delay);\n"
"  return Math.sqrt(w * w + h * h);\n"
"}\n"
"\n"
"export const diagonalAsyncImpl = delay => w => h => () =>\n"
"  diagonalWait(delay, w, h);\n"
msgstr ""
"async function diagonalWait(delay, w, h) {\n"
"  await wait(delay);\n"
"  return Math.sqrt(w * w + h * h);\n"
"}\n"
"\n"
"export const diagonalAsyncImpl = delay => w => h => () =>\n"
"  diagonalWait(delay, w, h);\n"

#. type: Plain text
#: text/chapter10.md:692
msgid ""
"Since we're returning a `Number`, we represent this type in the `Promise` "
"and `Aff` wrappers:"
msgstr "`Number`を返すため、この型を`Promise`と`Aff`の梱包の中で表現します。"

#. type: Fenced code block (hs)
#: text/chapter10.md:693
#, no-wrap
msgid ""
"foreign import diagonalAsyncImpl :: Int -> Number -> Number -> Effect (Promise Number)\n"
"\n"
"diagonalAsync :: Int -> Number -> Number -> Aff Number\n"
"diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y\n"
msgstr ""
"foreign import diagonalAsyncImpl :: Int -> Number -> Number -> Effect (Promise Number)\n"
"\n"
"diagonalAsync :: Int -> Number -> Number -> Aff Number\n"
"diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y\n"

#. type: Fenced code block (text)
#: text/chapter10.md:700
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"import Prelude\n"
"import Test.Examples\n"
"import Effect.Class.Console\n"
"import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   res <- diagonalAsync 300 3.0 4.0\n"
"…   logShow res\n"
"…\n"
"unit\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"import Prelude\n"
"import Test.Examples\n"
"import Effect.Class.Console\n"
"import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   res <- diagonalAsync 300 3.0 4.0\n"
"…   logShow res\n"
"…\n"
"unit\n"
"5.0\n"

#. type: Plain text
#: text/chapter10.md:719
msgid ""
"Exercises for the above sections are still on the ToDo list. If you have any "
"ideas for good exercises, please make a suggestion."
msgstr ""
"上の節の演習はまだやるべきことの一覧にあります。\n"
"もし何か良い演習の考えがあればご提案ください。"

#. type: Title ##
#: text/chapter10.md:720
#, no-wrap
msgid "JSON"
msgstr "JSON"

#. type: Plain text
#: text/chapter10.md:723
msgid ""
"There are many reasons to use JSON in an application; for example, it's a "
"common means of communicating with web APIs. This section will discuss other "
"use-cases, too, beginning with a technique to improve type safety when "
"passing structural data over the FFI."
msgstr ""
"アプリケーションでJSONを使うことには多くの理由があります。\n"
"例えばwebのAPIと疎通するよくある手段であるためです。\n"
"この節では他の用例についてもお話ししましょう。\n"
"構造的なデータをFFI越しに渡す場合に型安全性を向上させる手法から始めます。"

#. type: Plain text
#: text/chapter10.md:725
msgid ""
"Let's revisit our earlier FFI functions `cumulativeSums` and `addComplex` "
"and introduce a bug to each:"
msgstr ""
"少し前のFFI関数`cumulativeSums`と`addComplex`を再訪し、それぞれに1つバグを混"
"入させてみましょう。"

#. type: Fenced code block (js)
#: text/chapter10.md:726
#, no-wrap
msgid ""
"export const cumulativeSumsBroken = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  sums.push(\"Broken\"); // Bug\n"
"  return sums;\n"
"};\n"
"\n"
"export const addComplexBroken = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    broken: a.imag + b.imag // Bug\n"
"  }\n"
"};\n"
msgstr ""
"export const cumulativeSumsBroken = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  sums.push(\"Broken\"); // Bug\n"
"  return sums;\n"
"};\n"
"\n"
"export const addComplexBroken = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    broken: a.imag + b.imag // Bug\n"
"  }\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:747
msgid ""
"We can use the original type signatures, and the code will still compile, "
"despite the incorrect return types."
msgstr ""
"実際は返る型が正しくないのですが、元々の型シグネチャを使うことができ、依然と"
"してコードはコンパイルされます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:748
#, no-wrap
msgid ""
"foreign import cumulativeSumsBroken :: Array Int -> Array Int\n"
"\n"
"foreign import addComplexBroken :: Complex -> Complex -> Complex\n"
msgstr ""
"foreign import cumulativeSumsBroken :: Array Int -> Array Int\n"
"\n"
"foreign import addComplexBroken :: Complex -> Complex -> Complex\n"

#. type: Plain text
#: text/chapter10.md:755
msgid ""
"We can even execute the code, which might either produce unexpected results "
"or a runtime error:"
msgstr ""
"コードの実行さえ可能で、そうすると予期しない結果を生み出すか実行時エラーにな"
"ります。"

#. type: Fenced code block (text)
#: text/chapter10.md:756
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Foldable (sum)\n"
"\n"
"> sums = cumulativeSumsBroken [1, 2, 3]\n"
"> sums\n"
"[1,3,6,Broken]\n"
"> sum sums\n"
"0\n"
"\n"
"> complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"> complex.real\n"
"4.0\n"
"> complex.imag + 1.0\n"
"NaN\n"
"> complex.imag\n"
"  var str = n.toString();\n"
"              ^\n"
"TypeError: Cannot read property 'toString' of undefined\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Foldable (sum)\n"
"\n"
"> sums = cumulativeSumsBroken [1, 2, 3]\n"
"> sums\n"
"[1,3,6,Broken]\n"
"> sum sums\n"
"0\n"
"\n"
"> complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"> complex.real\n"
"4.0\n"
"> complex.imag + 1.0\n"
"NaN\n"
"> complex.imag\n"
"  var str = n.toString();\n"
"              ^\n"
"TypeError: Cannot read property 'toString' of undefined\n"

#. type: Plain text
#: text/chapter10.md:780
msgid ""
"For example, our resulting `sums` is no-longer a valid `Array Int`, now that "
"a `String` is included in the Array. And further operations produce "
"unexpected behavior, rather than an outright error, as the `sum` of these "
"`sums` is `0` rather than `10`. This could be a difficult bug to track down!"
msgstr ""
"例えば結果の`sums`はもはや正しい`Array Int`ではありませんが、それは`String`が"
"配列に含まれているからです。\n"
"そして更なる操作は即時のエラーではなく予期しない挙動を生み出します。\n"
"というのもこれらの`sums`の`sum`は`10`ではなく`0`だからです。\n"
"これでは捜索の難しいバグになりかねませんね。"

#. type: Plain text
#: text/chapter10.md:782
msgid ""
"Likewise, there are no errors when calling `addComplexBroken`; however, "
"accessing the `imag` field of our `Complex` result will either produce "
"unexpected behavior (returning `NaN` instead of `7.0`), or a non-obvious "
"runtime error."
msgstr ""
"同様に`addComplexBroken`を呼び出すときは1つもエラーが出ません。\n"
"しかし、`Complex`の結果の`imag`フィールドにアクセスすると予期しない挙動"
"（`7.0`ではなく`Nan`を返すため）やはっきりしない実行時エラーを生じることで"
"しょう。"

#. type: Plain text
#: text/chapter10.md:784
msgid ""
"Let's use JSON to make our PureScript code more impervious to bugs in "
"JavaScript code."
msgstr ""
"PureScriptのコードにバグ一匹通さないようにするため、JavaScriptのコードでJSON"
"を使いましょう。"

#. type: Plain text
#: text/chapter10.md:786
msgid ""
"The `argonaut` library contains the JSON decoding and encoding capabilities "
"we need. That library has excellent [documentation](https://github.com/"
"purescript-contrib/purescript-argonaut#documentation), so we will only cover "
"basic usage in this book."
msgstr ""
"`argonaut`ライブラリにはこのために必要なJSONのデコードとエンコードの機能が備"
"わっています。\n"
"このライブラリには素晴らしい[ドキュメント](https://github.com/purescript-"
"contrib/purescript-argonaut#documentation)があるので、本書では基本的な用法だ"
"けを押さえます。"

#. type: Plain text
#: text/chapter10.md:788
msgid ""
"If we create an alternate foreign import that defines the return type as "
"`Json`:"
msgstr ""
"返る型を`Json`として定義するようにして、代わりとなる外部インポートを作るとこ"
"うなります。"

#. type: Fenced code block (hs)
#: text/chapter10.md:789
#, no-wrap
msgid ""
"foreign import cumulativeSumsJson :: Array Int -> Json\n"
"foreign import addComplexJson :: Complex -> Complex -> Json\n"
msgstr ""
"foreign import cumulativeSumsJson :: Array Int -> Json\n"
"foreign import addComplexJson :: Complex -> Complex -> Json\n"

#. type: Plain text
#: text/chapter10.md:795
msgid "Note that we're simply pointing to our existing broken functions:"
msgstr "単純に既存の壊れた関数を指している点に注意します。"

#. type: Fenced code block (js)
#: text/chapter10.md:796
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSumsBroken\n"
"export const addComplexJson = addComplexBroken\n"
msgstr ""
"export const cumulativeSumsJson = cumulativeSumsBroken\n"
"export const addComplexJson = addComplexBroken\n"

#. type: Plain text
#: text/chapter10.md:802
msgid "And then write a wrapper to decode the returned foreign `Json` value:"
msgstr "そして返された`Json`の値をデコードする梱包を書きます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:803
#, no-wrap
msgid ""
"{{#include ../exercises/chapter10/test/Examples.purs:cumulativeSumsDecoded}}\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.purs:addComplexDecoded}}\n"
msgstr ""
"{{#include ../exercises/chapter10/test/Examples.purs:cumulativeSumsDecoded}}\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.purs:addComplexDecoded}}\n"

#. type: Plain text
#: text/chapter10.md:810
msgid ""
"Then any values that can't be successfully decoded to our return type appear "
"as a `Left` error `String`:"
msgstr ""
"そうすると返る型へのデコードが成功しなかったどんな値も`Left`の`String`なエ"
"ラーとして表れます。"

#. type: Fenced code block (text)
#: text/chapter10.md:811
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Left \"Couldn't decode Array (Failed at index 3): Value is not a Number\")\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Left \"JSON was missing expected field: imag\")\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Left \"Couldn't decode Array (Failed at index 3): Value is not a Number\")\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Left \"JSON was missing expected field: imag\")\n"

#. type: Plain text
#: text/chapter10.md:824
msgid "If we call the working versions, a `Right` value is returned."
msgstr "正常に動作するバージョンで呼び出すと`Right`の値が返ります。"

#. type: Plain text
#: text/chapter10.md:826
msgid ""
"Try this yourself by modifying `test/Examples.js` with the following change "
"to point to the working versions before running the next repl block."
msgstr ""
"次のREPLブロックを走らせる前に、正常に動作するバージョンを指すように、`test/"
"Examples.js`へ以下の変更を加えて、手元で試してみましょう。"

#. type: Fenced code block (js)
#: text/chapter10.md:827
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSums\n"
"export const addComplexJson = addComplex\n"
msgstr ""
"export const cumulativeSumsJson = cumulativeSums\n"
"export const addComplexJson = addComplex\n"

#. type: Fenced code block (text)
#: text/chapter10.md:832
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Right [1,3,6])\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Right { imag: 6.0, real: 4.0 })\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Right [1,3,6])\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Right { imag: 6.0, real: 4.0 })\n"

#. type: Plain text
#: text/chapter10.md:845
msgid ""
"Using JSON is also the easiest way to pass other structural types, such as "
"`Map` and `Set`, through the FFI. Since JSON only consists of booleans, "
"numbers, strings, arrays, and objects of other JSON values, we can't write a "
"`Map` and `Set` directly in JSON. But we can represent these structures as "
"arrays (assuming the keys and values can also be represented in JSON) and "
"then decode them back to `Map` or `Set`."
msgstr ""
"JSONを使うのは、`Map`や`Set`のようなその他の構造的な型をFFI越しに渡す、最も簡"
"単な方法でもあります。\n"
"JSONは真偽値、数値、文字列、配列、そして他のJSONの値からなるオブジェクトのみ"
"から構成されるため、JSONでは直接`Map`や`Set`を書けません。\n"
"しかしこれらの構造を配列としては表現でき（キーとバリューもまたJSONで表現され"
"ているとします）、それから`Map`や`Set`に復元できるのです。"

#. type: Plain text
#: text/chapter10.md:847
msgid ""
"Here's an example of a foreign function signature that modifies a `Map` of "
"`String` keys and `Int` values, along with the wrapper function that handles "
"JSON encoding and decoding."
msgstr ""
"以下は`String`のキーと`Int`のバリューからなる`Map`を変更する外部関数シグネ"
"チャと、それに伴うJSONのエンコードとデコードを扱う梱包関数の例です。"

#. type: Fenced code block (hs)
#: text/chapter10.md:848
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:mapSetFooJson}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:mapSetFooJson}}\n"

#. type: Plain text
#: text/chapter10.md:853
msgid ""
"Note that this is a prime use case for function composition. Both of these "
"alternatives are equivalent to the above:"
msgstr ""
"関数合成の絶好の用例になっていますね。\n"
"以下の代案は両方とも上のものと等価です。"

#. type: Fenced code block (hs)
#: text/chapter10.md:854
#, no-wrap
msgid ""
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = decodeJson <<< mapSetFooJson <<< encodeJson\n"
"\n"
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = encodeJson >>> mapSetFooJson >>> decodeJson\n"
msgstr ""
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = decodeJson <<< mapSetFooJson <<< encodeJson\n"
"\n"
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = encodeJson >>> mapSetFooJson >>> decodeJson\n"

#. type: Plain text
#: text/chapter10.md:863
msgid ""
"Here is the JavaScript implementation. Note the `Array.from` step, which is "
"necessary to convert the JavaScript `Map` into a JSON-friendly format before "
"decoding converts it back to a PureScript `Map`."
msgstr ""
"以下はJavaScriptでの実装です。\n"
"なお、`Array.from`の工程は、JavaScriptの`Map`をJSONに親和性のある形式に変換"
"し、デコードでPureScriptの`Map`に変換し直すために必須です。"

#. type: Fenced code block (js)
#: text/chapter10.md:864
#, no-wrap
msgid ""
"export const mapSetFooJson = j => {\n"
"  let m = new Map(j);\n"
"  m.set(\"Foo\", 42);\n"
"  return Array.from(m);\n"
"};\n"
msgstr ""
"export const mapSetFooJson = j => {\n"
"  let m = new Map(j);\n"
"  m.set(\"Foo\", 42);\n"
"  return Array.from(m);\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:873
msgid "Now we can send and receive a `Map` over the FFI:"
msgstr "これで`Map`をFFI越しに送ったり受け取ったりできます。"

#. type: Fenced code block (text)
#: text/chapter10.md:874
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Map\n"
"> import Data.Tuple\n"
"\n"
"> myMap = fromFoldable [ Tuple \"hat\" 1, Tuple \"cat\" 2 ]\n"
"\n"
"> :type myMap\n"
"Map String Int\n"
"\n"
"> myMap\n"
"(fromFoldable [(Tuple \"cat\" 2),(Tuple \"hat\" 1)])\n"
"\n"
"> mapSetFoo myMap\n"
"(Right (fromFoldable [(Tuple \"Foo\" 42),(Tuple \"cat\" 2),(Tuple \"hat\" 1)]))\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Map\n"
"> import Data.Tuple\n"
"\n"
"> myMap = fromFoldable [ Tuple \"hat\" 1, Tuple \"cat\" 2 ]\n"
"\n"
"> :type myMap\n"
"Map String Int\n"
"\n"
"> myMap\n"
"(fromFoldable [(Tuple \"cat\" 2),(Tuple \"hat\" 1)])\n"
"\n"
"> mapSetFoo myMap\n"
"(Right (fromFoldable [(Tuple \"Foo\" 42),(Tuple \"cat\" 2),(Tuple \"hat\" 1)]))\n"

#. type: Bullet: '1. '
#: text/chapter10.md:902
msgid ""
"(Medium) Write a JavaScript function and PureScript wrapper `valuesOfMap :: "
"Map String Int -> Either JsonDecodeError (Set Int)` that returns a `Set` of "
"all the values in a `Map`. _Hint_: The `.values()` instance method for Map "
"may be useful in your JavaScript code."
msgstr ""
"（普通）`Map`中の全てのバリューの`Set`を返すJavaScriptの関数とPureScriptの梱"
"包`valuesOfMap :: Map String Int -> Either JsonDecodeError (Set Int)`を書いて"
"ください。"

#. type: Bullet: '1. '
#: text/chapter10.md:902
msgid ""
"(Easy) Write a new wrapper for the previous JavaScript function with the "
"signature `valuesOfMapGeneric :: forall k v. Map k v -> Either "
"JsonDecodeError (Set v)` so it works with a wider variety of maps. Note that "
"you'll need to add some type class constraints for `k` and `v`. The compiler "
"will guide you."
msgstr ""
"（簡単）より広い種類のマップに関して動作するよう、前のJavaScriptの関数の新し"
"い梱包を書いてください。\n"
"シグネチャは`valuesOfMapGeneric :: forall k v. Map k v -> Either "
"JsonDecodeError (Set v)`です。\n"
"なお、`k`と`v`に幾つかの型クラス制約を加える必要があるでしょう。\n"
"コンパイラが導いてくれます。"

#. type: Bullet: '1. '
#: text/chapter10.md:902
msgid ""
"(Medium) Rewrite the earlier `quadraticRoots` function as "
"`quadraticRootsSet` that returns the `Complex` roots as a `Set` via JSON "
"(instead of as a `Pair`)."
msgstr ""
"（普通）少し前の`quadraticRoots`関数を書き換えて`quadraticRootSet`としてくだ"
"さい。\n"
"この関数は`Complex`の根をJSONを介して（`Pair`の代わりに）`Set`として返しま"
"す。"

#. type: Plain text
#: text/chapter10.md:902
#, no-wrap
msgid ""
"1. (Difficult) Rewrite the earlier `quadraticRoots` function as `quadraticRootsSafe` that uses JSON to pass the `Pair` of `Complex` roots over FFI. Don't use the `Pair` constructor in JavaScript, but instead, just return the pair in a decoder-compatible format.\n"
"_Hint_: You'll need to write a `DecodeJson` instance for `Pair`. Consult the [argonaut docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances) for instruction on writing your own decode instance. Their [decodeJsonTuple](https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs) instance may also be a helpful reference.  Note that you'll need a `newtype` wrapper for `Pair` to avoid creating an \"orphan instance\".\n"
"1. (Medium) Write a `parseAndDecodeArray2D :: String -> Either String (Array (Array Int))` function to parse and decode a JSON string containing a 2D array, such as `\"[[1, 2, 3], [4, 5], [6]]\"`. _Hint_: You'll need to use `jsonParser` to convert the `String` into `Json` before decoding.\n"
"1. (Medium) The following data type represents a binary tree with values at the leaves:\n"
msgstr ""
"1. （難しい）少し前の`quadraticRoots`関数を書き換えて`quadraticRootsSafe`としてください。\n"
"   この関数はJSONを使って`Complex`の根の`Pair`をFFI越しに渡します。\n"
"   JavaScriptでは`Pair`構築子を使わないでください。\n"
"   その代わり、デコーダーに互換性のある形式で対を返すだけにしてください。\n"
"   *手掛かり*：`DecodeJson`インタンスを`Pair`用に書く必要があるでしょう。\n"
"   独自のデコードインスタンスを書く上での説明については[argonautのドキュメント](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances)をあたってください。\n"
"   [decodeJsonTuple](https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs)インスタンスも参考になるかもしれません。\n"
"  「孤立インスタンス」を作ることを避けるために、`Pair`に`newtype`の梱包が必要になる点に注意してください。\n"
"1. （普通）2次元配列を含むJSON文字列を構文解析してデコードする`parseAndDecodeArray2D :: String -> Either String (Array (Array Int))`関数を書いてください。\n"
"   例えば`\"[[1, 2, 3], [4, 5], [6]]\"`です。\n"
"   *手掛かり*：デコードの前に`jsonParser`を使って`String`を`Json`に変換する必要があるでしょう。\n"
"1. （普通）以下のデータ型は値が葉にある二分木を表現します。\n"

#. type: Plain text
#: text/chapter10.md:908
#, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a\n"
"       = Leaf a\n"
"       | Branch (Tree a) (Tree a)\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data Tree a\n"
"       = Leaf a\n"
"       | Branch (Tree a) (Tree a)\n"
"     ```\n"

#. type: Plain text
#: text/chapter10.md:913
#, no-wrap
msgid ""
"     Derive generic `EncodeJson` and `DecodeJson` instances for the `Tree` type.\n"
"     Consult the [argonaut docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics) for instructions on how to do this.\n"
"     Note that you'll also need generic instances of `Show` and `Eq` to enable unit testing for this exercise, but those should be straightforward to implement after tackling the JSON instances.\n"
"1. (Difficult) The following `data` type should be represented directly in JSON as either an integer or a string:\n"
msgstr ""
"     汎化された`EncodeJson`及び`DecodeJson`インスタンスを`Tree`型用に導出してください。\n"
"     このやり方についての説明は[argonautのドキュメント](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics)をあたってください。\n"
"     なお、この演習の単体試験を有効にするには、汎化された`Show`及び`Eq`インスタンスも必要になります。\n"
"     しかしJSONのインスタンスと格闘したあとでは、これらの実装は直感的に進むことでしょう。\n"
"1. （難しい）以下の`data`型は整数か文字列かによってJSONで異なって表現されます。\n"

#. type: Plain text
#: text/chapter10.md:919
#, no-wrap
msgid ""
"     ```haskell\n"
"     data IntOrString\n"
"       = IntOrString_Int Int\n"
"       | IntOrString_String String\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data IntOrString\n"
"       = IntOrString_Int Int\n"
"       | IntOrString_String String\n"
"     ```\n"

#. type: Plain text
#: text/chapter10.md:921
#, no-wrap
msgid "     Write instances of `EncodeJson` and `DecodeJson` for the `IntOrString` data type which implement this behavior. _Hint_: The `alt` operator from `Control.Alt` may be helpful.\n"
msgstr ""
"     この挙動を実装する`IntOrString`データ型に、`EncodeJson`及び`DecodeJson`インスタンスを書いてください。\n"
"     *手掛かり*：`Control.Alt`の`alt`演算子が役立つかもしれません。\n"

#. type: Title ##
#: text/chapter10.md:922
#, no-wrap
msgid "Address book"
msgstr "住所録"

#. type: Plain text
#: text/chapter10.md:925
msgid ""
"In this section, we will apply our newly-acquired FFI and JSON knowledge to "
"build on our address book example from Chapter 8. We will add the following "
"features:"
msgstr ""
"この節では新しく獲得したFFIとJSONの知識を応用して、第8章の住所録の例を構築し"
"ていきたいと思います。\n"
"以下の機能を加えていきます。"

#. type: Bullet: '- '
#: text/chapter10.md:929
msgid ""
"A Save button at the bottom of the form that, when clicked, serializes the "
"state of the form to JSON and saves it in local storage."
msgstr ""
"保存ボタンをフォームの一番下に配置し、クリックしたときにフォームの状態をJSON"
"に直列化してローカルストレージに保存します。"

#. type: Bullet: '- '
#: text/chapter10.md:929
msgid ""
"Automatic retrieval of the JSON document from local storage upon page "
"reload. The form fields are populated with the contents of this document."
msgstr ""
"ページの再読み込み時にローカルストレージからJSON文書を自動的に取得します。\n"
"フォームのフィールドにはこの文書の内容を入れます。"

#. type: Bullet: '- '
#: text/chapter10.md:929
msgid "A pop-up alert if there is an issue saving or loading the form state."
msgstr ""
"フォームの状態を保存したり読み込んだりするのに問題があればポップアップの警告"
"を出します。"

#. type: Plain text
#: text/chapter10.md:931
msgid ""
"We'll start by creating FFI wrappers for the following Web Storage APIs in "
"our `Effect.Storage` module:"
msgstr ""
"`Effect.Storage`モジュールに以下のwebストレージAPIのためのFFIの梱包を作ること"
"から始めていきます。"

#. type: Bullet: '- '
#: text/chapter10.md:934
msgid ""
"`setItem` takes a key and a value (both strings), and returns a computation "
"which stores (or updates) the value in local storage at the specified key."
msgstr ""
"`setItem`はキーと値（両方とも文字列）を受け取り、指定されたキーでローカルスト"
"レージに値を格納する計算を返します。"

#. type: Bullet: '- '
#: text/chapter10.md:934
msgid ""
"`getItem` takes a key, and attempts to retrieve the associated value from "
"local storage. However, since the `getItem` method on `window.localStorage` "
"can return `null`, the return type is not `String`, but `Json`."
msgstr ""
"`getItem`はキーを取り、ローカルストレージから関連付けられたバリューの取得を試"
"みます。\n"
"しかし`window.localStorage`の`getItem`メソッドは`null`を返しうるので、返る型"
"は`String`ではなく`Json`です。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:935
#, no-wrap
msgid ""
"foreign import setItem :: String -> String -> Effect Unit\n"
"\n"
"foreign import getItem :: String -> Effect Json\n"
msgstr ""
"foreign import setItem :: String -> String -> Effect Unit\n"
"\n"
"foreign import getItem :: String -> Effect Json\n"

#. type: Plain text
#: text/chapter10.md:942
msgid ""
"Here is the corresponding JavaScript implementation of these functions in "
"`Effect/Storage.js`:"
msgstr ""
"以下はこれらの関数に対応するJavaScriptの実装で、`Effect/Storage.js`にありま"
"す。"

#. type: Fenced code block (js)
#: text/chapter10.md:943
#, no-wrap
msgid ""
"export const setItem = key => value => () =>\n"
"  window.localStorage.setItem(key, value);\n"
"\n"
"export const getItem = key => () =>\n"
"  window.localStorage.getItem(key);\n"
msgstr ""
"export const setItem = key => value => () =>\n"
"  window.localStorage.setItem(key, value);\n"
"\n"
"export const getItem = key => () =>\n"
"  window.localStorage.getItem(key);\n"

#. type: Plain text
#: text/chapter10.md:952
msgid "We'll create a save button like so:"
msgstr "以下のように保存ボタンを作ります。"

#. type: Fenced code block (hs)
#: text/chapter10.md:953
#, no-wrap
msgid ""
"saveButton :: R.JSX\n"
"saveButton =\n"
"  D.label\n"
"    { className: \"form-group row col-form-label\"\n"
"    , children:\n"
"        [ D.button\n"
"            { className: \"btn-primary btn\"\n"
"            , onClick: handler_ validateAndSave\n"
"            , children: [ D.text \"Save\" ]\n"
"            }\n"
"        ]\n"
"    }\n"
msgstr ""
"saveButton :: R.JSX\n"
"saveButton =\n"
"  D.label\n"
"    { className: \"form-group row col-form-label\"\n"
"    , children:\n"
"        [ D.button\n"
"            { className: \"btn-primary btn\"\n"
"            , onClick: handler_ validateAndSave\n"
"            , children: [ D.text \"Save\" ]\n"
"            }\n"
"        ]\n"
"    }\n"

#. type: Plain text
#: text/chapter10.md:969
msgid ""
"And write our validated `person` as a JSON string with `setItem` in the "
"`validateAndSave` function:"
msgstr ""
"そして`validateAndSave`関数中では、検証された`person`をJSON文字列とし、"
"`setItem`を使って書き込みます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:970
#, no-wrap
msgid ""
"validateAndSave :: Effect Unit\n"
"validateAndSave = do\n"
"  log \"Running validators\"\n"
"  case validatePerson' person of\n"
"    Left errs -> log $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"    Right validPerson -> do\n"
"      setItem \"person\" $ stringify $ encodeJson validPerson\n"
"      log \"Saved\"\n"
msgstr ""
"validateAndSave :: Effect Unit\n"
"validateAndSave = do\n"
"  log \"Running validators\"\n"
"  case validatePerson' person of\n"
"    Left errs -> log $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"    Right validPerson -> do\n"
"      setItem \"person\" $ stringify $ encodeJson validPerson\n"
"      log \"Saved\"\n"

#. type: Plain text
#: text/chapter10.md:982
msgid ""
"Note that if we attempt to compile at this stage, we'll encounter the "
"following error:"
msgstr "なお、この段階でコンパイルしようとすると以下のエラーに遭遇します。"

#. type: Fenced code block (text)
#: text/chapter10.md:983
#, no-wrap
msgid ""
"  No type class instance was found for\n"
"    Data.Argonaut.Encode.Class.EncodeJson PhoneType\n"
msgstr ""
"  No type class instance was found for\n"
"    Data.Argonaut.Encode.Class.EncodeJson PhoneType\n"

#. type: Plain text
#: text/chapter10.md:989
msgid ""
"This is because `PhoneType` in the `Person` record needs an `EncodeJson` "
"instance. We'll also derive a generic encode instance and a decode instance "
"while we're at it. More information on how this works is available in the "
"argonaut docs:"
msgstr ""
"これはなぜかというと`Person`レコード中の`PhoneType`が`EncodeJson`インスタンス"
"を必要としているからです。\n"
"また、ついでに汎用のエンコードインスタンスとデコードインスタンスを導出してい"
"きます。\n"
"この仕組みについての詳細情報はargonautのドキュメントにあります。"

#. type: Fenced code block (hs)
#: text/chapter10.md:990
#, no-wrap
msgid ""
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:import}}\n"
"\n"
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:PhoneType_generic}}\n"
msgstr ""
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:import}}\n"
"\n"
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:PhoneType_generic}}\n"

#. type: Plain text
#: text/chapter10.md:997
msgid ""
"Now we can save our `person` to local storage, but this isn't very useful "
"unless we can retrieve the data. We'll tackle that next."
msgstr ""
"これで`person`をローカルストレージに保存できます。\n"
"しかしデータを取得できない限りあまり便利ではありません。\n"
"次はそれに取り掛かりましょう。"

#. type: Plain text
#: text/chapter10.md:999
msgid "We'll start with retrieving the \"person\" string from local storage:"
msgstr "ローカルストレージから「person」文字列で取得することから始めましょう。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1000
#, no-wrap
msgid "item <- getItem \"person\"\n"
msgstr "item <- getItem \"person\"\n"

#. type: Plain text
#: text/chapter10.md:1005
msgid ""
"Then we'll create a helper function to convert the string from local storage "
"to our `Person` record. Note that this string in storage may be `null`, so "
"we represent it as a foreign `Json` until it is successfully decoded as a "
"`String`. There are a number of other conversion steps along the way – each "
"of which returns an `Either` value, so it makes sense to organize these "
"together in a `do` block."
msgstr ""
"そうしてローカルストレージ由来の文字列から`Person`レコードへ変換する補助関数"
"を作ります。\n"
"なお、このストレージ中の文字列は`null`かもしれないので、正常に`String`として"
"デコードされるまでは外部の`Json`として表現します。\n"
"道中には他にも多くの変換工程があり、それぞれで`Either`の値を返します。\n"
"そのためこれらをまとめて`do`ブロックの中に纏めるのは理に適っています。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1006
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- decodeJson item\n"
"  j          <- jsonParser jsonString\n"
"  decodeJson j\n"
msgstr ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- decodeJson item\n"
"  j          <- jsonParser jsonString\n"
"  decodeJson j\n"

#. type: Plain text
#: text/chapter10.md:1015
msgid ""
"Then we inspect this result to see if it succeeded. If it fails, we'll log "
"the errors and use our default `examplePerson`, otherwise, we'll use the "
"person retrieved from local storage."
msgstr ""
"そうしてこの結果が成功しているかどうか調べます。\n"
"もし失敗していればエラーをログ出力し、既定の`examplePerson`を使います。\n"
"そうでなければローカルストレージから取得した人物を使います。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1016
#, no-wrap
msgid ""
"initialPerson <- case processItem item of\n"
"  Left  err -> do\n"
"    log $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
"    pure examplePerson\n"
"  Right p   -> pure p\n"
msgstr ""
"initialPerson <- case processItem item of\n"
"  Left  err -> do\n"
"    log $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
"    pure examplePerson\n"
"  Right p   -> pure p\n"

#. type: Plain text
#: text/chapter10.md:1025
msgid ""
"Finally, we'll pass this `initialPerson` to our component via the `props` "
"record:"
msgstr ""
"最後にこの`initialPerson`を`props`レコードを介してコンポーネントに渡します。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1026
#, no-wrap
msgid ""
"-- Create JSX node from react component.\n"
"app = element addressBookApp { initialPerson }\n"
msgstr ""
"-- Create JSX node from react component.\n"
"app = element addressBookApp { initialPerson }\n"

#. type: Plain text
#: text/chapter10.md:1032
msgid "And pick it up on the other side to use in our state hook:"
msgstr "そして状態フックで使うために別の箇所で拾い上げます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1033
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })\n"
"mkAddressBookApp =\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState props.initialPerson\n"
msgstr ""
"mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })\n"
"mkAddressBookApp =\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState props.initialPerson\n"

#. type: Plain text
#: text/chapter10.md:1041
msgid ""
"As a finishing touch, we'll improve the quality of our error messages by "
"appending to the `String` of each `Left` value with `lmap`."
msgstr ""
"仕上げとして、各`Left`値の`String`に`lmap`を使って前置し、エラー文言の質を向"
"上させます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1042
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- lmap (\"No string in local storage: \" <> _) $ decodeJson item\n"
"  j          <- lmap (\"Cannot parse JSON string: \"   <> _) $ jsonParser jsonString\n"
"  lmap               (\"Cannot decode Person: \"       <> _) $ decodeJson j\n"
msgstr ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- lmap (\"No string in local storage: \" <> _) $ decodeJson item\n"
"  j          <- lmap (\"Cannot parse JSON string: \"   <> _) $ jsonParser jsonString\n"
"  lmap               (\"Cannot decode Person: \"       <> _) $ decodeJson j\n"

#. type: Plain text
#: text/chapter10.md:1051
msgid ""
"Only the first error should ever occur during the normal operation of this "
"app. You can trigger the other errors by opening your web browser's dev "
"tools, editing the saved \"person\" string in local storage, and refreshing "
"the page. How you modify the JSON string determines which error is "
"triggered. See if you can trigger each of them."
msgstr ""
"最初のエラーのみがこのアプリの通常の操作内で起こります。\n"
"他のエラーはwebブラウザの開発ツールを開いてローカルストレージ中に保存された"
"「person」文字列を編集し、そのページを参照することで引き起こせます。\n"
"どのようにJSON文字列を変更したかが、どのエラーを引き起こすかを決定します。\n"
"各エラーを引き起こせるかご確認ください。"

#. type: Plain text
#: text/chapter10.md:1053
msgid ""
"That covers local storage. Next, we'll implement the `alert` action, similar "
"to the `log` action from the `Effect.Console` module. The only difference is "
"that the `alert` action uses the `window.alert` method, whereas the `log` "
"action uses the `console.log` method. As such, `alert` can only be used in "
"environments where `window.alert` is defined, such as a web browser."
msgstr ""
"これでローカルストレージについては押さえました。\n"
"次に`alert`動作を実装していきます。\n"
"この動作は`Effect.Console`モジュールの`log`動作に似ています。\n"
"唯一の相違点は`alert`動作が`window.alert`メソッドを使うことで、対して`log`動"
"作は`console.log`メソッドを使っています。\n"
"そういうわけで`alert`は`window.alert`が定義された環境でのみ使うことができま"
"す。\n"
"webブラウザなどです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1054
#, no-wrap
msgid "foreign import alert :: String -> Effect Unit\n"
msgstr "foreign import alert :: String -> Effect Unit\n"

#. type: Fenced code block (js)
#: text/chapter10.md:1058
#, no-wrap
msgid ""
"export const alert = msg => () =>\n"
"  window.alert(msg);\n"
msgstr ""
"export const alert = msg => () =>\n"
"  window.alert(msg);\n"

#. type: Plain text
#: text/chapter10.md:1064
msgid "We want this alert to appear when either:"
msgstr "この警告が次の何れかの場合に現れるようにしたいです。"

#. type: Bullet: '- '
#: text/chapter10.md:1067
msgid "A user attempts to save a form with validation errors."
msgstr "利用者が検証エラーを含むフォームを保存しようと試みている。"

#. type: Bullet: '- '
#: text/chapter10.md:1067
msgid "The state cannot be retrieved from local storage."
msgstr "状態がローカルストレージから取得できない。"

#. type: Plain text
#: text/chapter10.md:1069
msgid ""
"That is accomplished by simply replacing `log` with `alert` on these lines:"
msgstr "以上は単に以下の行で`log`を`alert`に置き換えるだけで達成できます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1070
#, no-wrap
msgid ""
"Left errs -> alert $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"\n"
"alert $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
msgstr ""
"Left errs -> alert $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"\n"
"alert $ \"Error: \" <> err <> \". Loading examplePerson\"\n"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
msgid ""
"(Easy) Write a wrapper for the `removeItem` method on the `localStorage` "
"object, and add your foreign function to the `Effect.Storage` module."
msgstr ""
"（普通）`localStorage`オブジェクトの `removeItem`メソッドの梱包を書き、 "
"`Effect.Storage`モジュールに外部関数を追加してください"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
msgid ""
"(Medium) Add a \"Reset\" button that, when clicked, calls the newly-created "
"`removeItem` function to delete the \"person\" entry from local storage."
msgstr ""
"（普通）「リセット」ボタンを追加してください。\n"
"このボタンをクリックすると新しく作った`removeItem`関数を呼び出してローカルス"
"トレージから「人物」の項目を削除します。"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
msgid ""
"(Easy) Write a wrapper for the `confirm` method on the JavaScript `Window` "
"object, and add your foreign function to the `Effect.Alert` module."
msgstr ""
"（簡単）JavaScriptの `Window`オブジェクトの `confirm`メソッドの梱包を書き、 "
"`Effect.Alert`モジュールにその外部関数を追加してください。"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
msgid ""
"(Medium) Call this `confirm` function when a users clicks the \"Reset\" "
"button to ask if they're sure they want to reset their address book."
msgstr ""
"（普通）利用者が「リセット」ボタンをクリックしたときにこの`confirm`関数を呼び"
"出し、本当にアドレス帳を白紙にしたいか尋ねるようにしてください。"

#. type: Title ##
#: text/chapter10.md:1083 text/chapter11.md:963 text/chapter12.md:594
#: text/chapter13.md:401 text/chapter14.md:720 text/chapter2.md:129
#: text/chapter3.md:782 text/chapter4.md:631 text/chapter5.md:529
#: text/chapter6.md:757 text/chapter7.md:691 text/chapter8.md:1001
#: text/chapter9.md:238
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: text/chapter10.md:1086
msgid ""
"In this chapter, we've learned how to work with foreign JavaScript code from "
"PureScript, and we've seen the issues involved with writing trustworthy code "
"using the FFI:"
msgstr ""
"この章では、PureScriptから外部のJavaScriptコードを扱う方法を学びました。\n"
"また、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。"

#. type: Bullet: '- '
#: text/chapter10.md:1090
msgid ""
"We've seen the importance of ensuring that foreign functions have correct "
"representations."
msgstr "外部関数が正しい表現を持っていることを確かめる重要性を見てきました。"

#. type: Bullet: '- '
#: text/chapter10.md:1090
msgid ""
"We learned how to deal with corner cases like null values and other types of "
"JavaScript data by using foreign types or the `Json` data type."
msgstr ""
"外部型や`Json`データ型を使用することによって、null値やJavaScriptの他の型の"
"データのような特殊な場合に対処する方法を学びました。"

#. type: Bullet: '- '
#: text/chapter10.md:1090
msgid "We saw how to safely serialize and deserialize JSON data."
msgstr "安全にJSONデータを直列化・直列化復元する方法を見ました。"

#. type: Plain text
#: text/chapter10.md:1092
msgid ""
"For more examples, the `purescript`, `purescript-contrib`, and `purescript-"
"node` GitHub organizations provide plenty of examples of libraries that use "
"the FFI. In the remaining chapters, we will see some of these libraries put "
"to use to solve real-world problems in a type-safe way."
msgstr ""
"より多くの例については、GitHubの`purescript`組織、`purescript-contrib`組織、"
"及び`purescript-node`組織が、FFIを使用するライブラリの例を多数提供していま"
"す。\n"
"残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾"
"つか見ていきます。"

#. type: Title ##
#: text/chapter10.md:1093
#, no-wrap
msgid "Addendum"
msgstr "補遺"

#. type: Title ###
#: text/chapter10.md:1095
#, no-wrap
msgid "Calling PureScript from JavaScript"
msgstr "JavaScriptからPureScriptを呼び出す"

#. type: Plain text
#: text/chapter10.md:1098
msgid ""
"Calling a PureScript function from JavaScript is very simple, at least for "
"functions with simple types."
msgstr ""
"少なくとも単純な型を持つ関数については、JavaScriptからPureScript関数を呼び出"
"すのはとても簡単です。"

#. type: Plain text
#: text/chapter10.md:1100
msgid "Let's take the following simple module as an example:"
msgstr "例として以下のような簡単なモジュールを見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1101
#, no-wrap
msgid ""
"module Test where\n"
"\n"
"gcd :: Int -> Int -> Int\n"
"gcd 0 m = m\n"
"gcd n 0 = n\n"
"gcd n m\n"
"  | n > m     = gcd (n - m) m\n"
"  | otherwise = gcd (m – n) n\n"
msgstr ""
"module Test where\n"
"\n"
"gcd :: Int -> Int -> Int\n"
"gcd 0 m = m\n"
"gcd n 0 = n\n"
"gcd n m\n"
"  | n > m     = gcd (n - m) m\n"
"  | otherwise = gcd (m – n) n\n"

#. type: Plain text
#: text/chapter10.md:1113
msgid ""
"This function finds the greatest common divisor of two numbers by repeated "
"subtraction. It is a nice example of a case where you might like to use "
"PureScript to define the function, but have a requirement to call it from "
"JavaScript: it is simple to define this function in PureScript using pattern "
"matching and recursion, and the implementor can benefit from the use of the "
"type checker."
msgstr ""
"この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。\n"
"PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装す"
"る開発者は型検証器の恩恵を受けることができます。\n"
"そういうわけで関数を定義するのにPureScriptを使いたくなるかもしれない良い例と"
"なっていますが、JavaScriptからそれを呼び出すためには条件があります。"

#. type: Plain text
#: text/chapter10.md:1115
msgid ""
"To understand how this function can be called from JavaScript, it is "
"important to realize that PureScript functions always get turned into "
"JavaScript functions of a single argument, so we need to apply its arguments "
"one-by-one:"
msgstr ""
"この関数をJavaScriptから呼び出す方法を理解する上で重要なのは、PureScriptの関"
"数は常に引数が1つのJavaScript関数へと変換され、引数へは次のように1つずつ適用"
"していかなければならないということです。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1116
#, no-wrap
msgid ""
"import Test from 'Test.js';\n"
"Test.gcd(15)(20);\n"
msgstr ""
"import Test from 'Test.js';\n"
"Test.gcd(15)(20);\n"

#. type: Plain text
#: text/chapter10.md:1122
msgid ""
"Here, I assume the code was compiled with `spago build`, which compiles "
"PureScript modules to ES modules. For that reason, I could reference the "
"`gcd` function on the `Test` object, after importing the `Test` module using "
"`import`."
msgstr ""
"ここでは`spago build`でコンパイルされていることを前提としています。\n"
"SpagoはPureScriptモジュールをESモジュールにコンパイルするものです。\n"
"そのため、`import`を使って`Test`モジュールをインポートした後、`Test`オブジェ"
"クトの`gcd`関数を参照できました。"

#. type: Plain text
#: text/chapter10.md:1124
msgid ""
"You can also use the `spago bundle-app` and `spago bundle-module` commands "
"to bundle your generated JavaScript into a single file. Consult [the "
"documentation](https://github.com/purescript/spago#bundle-a-project-into-a-"
"single-js-file) for more information."
msgstr ""
"`spago bundle-app`や`spago bundle-module`コマンドを使って生成されたJavaScript"
"を単一のファイルにまとめることもできます。\n"
"詳細な情報については[ドキュメント](https://github.com/purescript/"
"spago#bundle-a-project-into-a-single-js-file)をあたってください。"

#. type: Title ###
#: text/chapter10.md:1125
#, no-wrap
msgid "Understanding Name Generation"
msgstr "名前の生成を理解する"

#. type: Plain text
#: text/chapter10.md:1128
msgid ""
"PureScript aims to preserve names during code generation as much as "
"possible. In particular, most identifiers that are neither PureScript nor "
"JavaScript keywords can be expected to be preserved, at least for names of "
"top-level declarations."
msgstr ""
"PureScriptはコード生成時にできるだけ名前を保持することを目指します。\n"
"とりわけ、PureScriptやJavaScriptのキーワードでなければほとんどの識別子が保存"
"されることが期待できます。\n"
"少なくとも最上位で宣言される名前についてはそうです。"

#. type: Plain text
#: text/chapter10.md:1130
msgid ""
"If you decide to use a JavaScript keyword as an identifier, the name will be "
"escaped with a double dollar symbol. For example,"
msgstr ""
"識別子としてJavaScriptのキーワードを使う場合は、名前は2重のドル記号でエスケー"
"プされます。\n"
"例えば次のPureScriptコードを考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1131
#, no-wrap
msgid "null = []\n"
msgstr "null = []\n"

#. type: Plain text
#: text/chapter10.md:1136 text/chapter10.md:1148
msgid "Generates the following JavaScript:"
msgstr "これは以下のJavaScriptを生成します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1137
#, no-wrap
msgid "var $$null = [];\n"
msgstr "var $$null = [];\n"

#. type: Plain text
#: text/chapter10.md:1142
msgid ""
"In addition, if you would like to use special characters in your identifier "
"names, they will be escaped using a single dollar symbol. For example,"
msgstr ""
"また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープ"
"されます。\n"
"例えばこのPureScriptコードを考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1143
#, no-wrap
msgid "example' = 100\n"
msgstr "example' = 100\n"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1149
#, no-wrap
msgid "var example$prime = 100;\n"
msgstr "var example$prime = 100;\n"

#. type: Plain text
#: text/chapter10.md:1154
msgid ""
"Where compiled PureScript code is intended to be called from JavaScript, it "
"is recommended that identifiers only use alphanumeric characters and avoid "
"JavaScript keywords. If user-defined operators are provided for use in "
"PureScript code, it is good practice to provide an alternative function with "
"an alphanumeric name for use in JavaScript."
msgstr ""
"コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図してい"
"る場合、識別子は英数字のみを使用し、JavaScriptの予約語を避けることをお勧めし"
"ます。\n"
"ユーザ定義演算子がPureScriptコードでの使用のために提供される場合、JavaScript"
"から使うための英数字の名前を持つ代替関数を提供しておくことをお勧めします。"

#. type: Title ###
#: text/chapter10.md:1155
#, no-wrap
msgid "Runtime Data Representation"
msgstr "実行時のデータ表現"

#. type: Plain text
#: text/chapter10.md:1158
msgid ""
"Types allow us to reason at compile-time that our programs are \"correct\" "
"in some sense – that is, they will not break at runtime. But what does that "
"mean? In PureScript, it means that the type of an expression should be "
"compatible with its representation at runtime."
msgstr ""
"型はプログラムがある意味で「正しい」ことをコンパイル時に論証できるようにしま"
"す。\n"
"つまり、その点については壊れることがありません。\n"
"しかし、これは何を意味するのでしょうか。\n"
"PureScriptでは、式の型は実行時の表現と互換性があることを意味します。"

#. type: Plain text
#: text/chapter10.md:1160
msgid ""
"For that reason, it is important to understand the representation of data at "
"runtime to be able to use PureScript and JavaScript code together "
"effectively. This means that for any given PureScript expression, we should "
"be able to understand the behavior of the value it will evaluate to at "
"runtime."
msgstr ""
"そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行"
"時のデータ表現について理解することが重要です。\n"
"これはつまり、与えられた任意のPureScriptの式について、その値が実行時にどのよ"
"うに評価されるかという挙動を理解できるべきだということです。"

#. type: Plain text
#: text/chapter10.md:1162
msgid ""
"The good news is that PureScript expressions have particularly simple "
"representations at runtime. It should always be possible to understand the "
"runtime data representation of an expression by considering its type."
msgstr ""
"幸いにもPureScriptの式はとりわけ実行時に単純な表現を持っています。\n"
"型を考慮すれば式の実行時のデータ表現を把握することが常に可能です。"

#. type: Plain text
#: text/chapter10.md:1164
msgid ""
"For simple types, the correspondence is almost trivial. For example, if an "
"expression has the type `Boolean`, then its value `v` at runtime should "
"satisfy `typeof v === 'boolean'`. That is, expressions of type `Boolean` "
"evaluate to one of the (JavaScript) values `true` or `false`. In particular, "
"there is no PureScript expression of type `Boolean` which evaluates to "
"`null` or `undefined`."
msgstr ""
"単純な型については、対応関係はほとんど自明です。\n"
"例えば式が型 `Boolean`を持っていれば、実行時のその値 `v`は `typeof v === "
"'boolean'`を満たします。\n"
"つまり、型 `Boolean`の式は `true`もしくは `false`のどちらか一方の（JavaScript"
"の）値へと評価されます。\n"
"特に`null`や `undefined`に評価される型`Boolean`なPureScriptの式はありません。"

#. type: Plain text
#: text/chapter10.md:1166
msgid ""
"A similar law holds for expressions of type `Int`, `Number`, and `String` – "
"expressions of type `Int` or `Number` evaluate to non-null JavaScript "
"numbers, and expressions of type `String` evaluate to non-null JavaScript "
"strings. Expressions of type `Int` will evaluate to integers at runtime, "
"even though they cannot be distinguished from values of type `Number` by "
"using `typeof`."
msgstr ""
"`Int`や`Number`や`String`の型の式についても似た法則が成り立ちます。\n"
"`Int`や`Number`型の式はnullでないJavaScriptの数へと評価されますし、`String`型"
"の式はnullでないJavaScriptの文字列へと評価されます。\n"
"`typeof`を使った場合に型`Number`の値と見分けがつかなくなるにせよ、型`Int`の式"
"は実行時に整数に評価されます。"

#. type: Plain text
#: text/chapter10.md:1168
msgid ""
"What about `Unit`? Well, since `Unit` has only one inhabitant (`unit`) and "
"its value is not observable, it doesn't matter what it's represented with at "
"runtime. Old code tends to represent it using `{}`. Newer code, however, "
"tends to use `undefined`. So, although it doesn't matter what you use to "
"represent `Unit`, it is recommended to use `undefined` (not returning "
"anything from a function also returns `undefined`)."
msgstr ""
"`Unit`についてはどうでしょうか。\n"
"`Unit`には現住 (`unit`) が1つのみで値が観測できないため、実のところ実行時に何"
"で表現されるかは重要ではありません。\n"
"古いコードは`{}`を使って表現する傾向がありました。\n"
"しかし比較的新しいコードでは`undefined`を使う傾向にあります。\n"
"なので、`Unit`を表現するのに使うものは何であれ差し支えありませんが、"
"`undefined`を使うことが推奨されます（関数から何も返さないときも`undefined`を"
"返します）。"

#. type: Plain text
#: text/chapter10.md:1170
msgid "What about some more complex types?"
msgstr "もっと複雑な型についてはどうでしょうか。"

#. type: Plain text
#: text/chapter10.md:1172
#, no-wrap
msgid "As we have already seen, PureScript functions correspond to JavaScript functions of a single argument. More precisely, if an expression `f` has type `a -> b` for some types `a` and `b`, and an expression `x` evaluates to a value with the correct runtime representation for type `a`, then `f` evaluates to a JavaScript function, which, when applied to the result of evaluating `x`, has the correct runtime representation for type `b`. As a simple example, an expression of type `String -> String` evaluates to a function that takes non-null JavaScript strings to non-null JavaScript strings.\n"
msgstr ""
"既に見てきたように、PureScriptの関数は引数が1つのJavaScriptの関数に対応しています。\n"
"厳密に言えばこうなります。\n"
"ある型`a`と`b`について、式`f`の型が`a -> b`で、式`x`が型`a`についての適切な実行時表現の値へと評価されるとします。\n"
"このとき`f`はJavaScriptの関数へと評価されますが、この関数は`x`を評価した結果に`f`を適用すると型`b`の適切な実行時表現を持ちます。\n"
"単純な例としては、`String -> String`型の式は、nullでないJavaScript文字列からnullでないJavaScript文字列への関数へと評価されます。\n"

#. type: Plain text
#: text/chapter10.md:1174
msgid ""
"As you might expect, PureScript's arrays correspond to JavaScript arrays. "
"But remember – PureScript arrays are homogeneous, so every element has the "
"same type. Concretely, if a PureScript expression `e` has type `Array a` for "
"some type `a`, then `e` evaluates to a (non-null) JavaScript array, all of "
"whose elements have the correct runtime representation for type `a`."
msgstr ""
"ご想像の通り、PureScriptの配列はJavaScriptの配列に対応しています。\n"
"しかし、PureScriptの配列は均質である、つまり全ての要素が同じ型を持っているこ"
"とは覚えておいてください。\n"
"具体的には、もしPureScriptの式`e`が何らかの型`a`について型`Array a`を持つな"
"ら、`e`は（nullでない）JavaScript配列へと評価されます。\n"
"この配列の全ての要素は型`a`の適切な実行時表現を持ちます。"

#. type: Plain text
#: text/chapter10.md:1176
msgid ""
"We've already seen that PureScript's records evaluate to JavaScript objects. "
"As for functions and arrays, we can reason about the runtime representation "
"of data in a record's fields by considering the types associated with its "
"labels. Of course, the fields of a record are not required to be of the same "
"type."
msgstr ""
"PureScriptのレコードがJavaScriptのオブジェクトへと評価されることは既に見てき"
"ました。\n"
"関数や配列の場合のように、そのラベルに関連付けられている型を考慮すれば、レ"
"コードのフィールド中のデータの実行時の表現について論証できます。\n"
"勿論、レコードのフィールドは、同じ型である必要はありません。"

#. type: Title ###
#: text/chapter10.md:1177
#, no-wrap
msgid "Representing ADTs"
msgstr "ADTの表現"

#. type: Plain text
#: text/chapter10.md:1180
msgid ""
"For every constructor of an algebraic data type, the PureScript compiler "
"creates a new JavaScript object type by defining a function. Its "
"constructors correspond to functions that create new JavaScript objects "
"based on those prototypes."
msgstr ""
"代数的データ型の全ての構築子について、PureScriptコンパイラは関数を定義するこ"
"とで新たなJavaScriptオブジェクト型を作成します。\n"
"これらの構築子はプロトタイプに基づいて新しいJavaScriptオブジェクトを作成する"
"関数に対応しています。"

#. type: Plain text
#: text/chapter10.md:1182
msgid "For example, consider the following simple ADT:"
msgstr "例えば次のような単純なADTを考えてみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1183
#, no-wrap
msgid "data ZeroOrOne a = Zero | One a\n"
msgstr "data ZeroOrOne a = Zero | One a\n"

#. type: Plain text
#: text/chapter10.md:1188
msgid "The PureScript compiler generates the following code:"
msgstr "PureScriptコンパイラは、次のようなコードを生成します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1189
#, no-wrap
msgid ""
"function One(value0) {\n"
"    this.value0 = value0;\n"
"};\n"
"\n"
"One.create = function (value0) {\n"
"    return new One(value0);\n"
"};\n"
"\n"
"function Zero() {\n"
"};\n"
"\n"
"Zero.value = new Zero();\n"
msgstr ""
"function One(value0) {\n"
"    this.value0 = value0;\n"
"};\n"
"\n"
"One.create = function (value0) {\n"
"    return new One(value0);\n"
"};\n"
"\n"
"function Zero() {\n"
"};\n"
"\n"
"Zero.value = new Zero();\n"

#. type: Plain text
#: text/chapter10.md:1205
msgid ""
"Here, we see two JavaScript object types: `Zero` and `One`. It is possible "
"to create values of each type by using JavaScript's `new` keyword. For "
"constructors with arguments, the compiler stores the associated data in "
"fields called `value0`, `value1`, etc."
msgstr ""
"ここで2つのJavaScriptオブジェクト型`Zero`と`One`を見てください。\n"
"JavaScriptのキーワード`new`を使用すると、各型の値を作成できます。\n"
"引数を持つ構築子については、コンパイラは`value0`、`value1`などという名前の"
"フィールドに、対応するデータを格納します。"

#. type: Plain text
#: text/chapter10.md:1207
msgid ""
"The PureScript compiler also generates helper functions. For constructors "
"with no arguments, the compiler generates a `value` property, which can be "
"reused instead of using the `new` operator repeatedly. For constructors with "
"one or more arguments, the compiler generates a `create` function, which "
"takes arguments with the appropriate representation and applies the "
"appropriate constructor."
msgstr ""
"PureScriptコンパイラは補助関数も生成します。\n"
"引数のない構築子については、コンパイラは構築子が使われるたびに `new`演算子を"
"使うのではなく、データを再利用できるように `value`プロパティを生成します。\n"
"1つ以上の引数を持つ構築子では、コンパイラは適切な表現を持つ引数を取り適切な構"
"築子を適用する `create`関数を生成します。"

#. type: Plain text
#: text/chapter10.md:1209
msgid ""
"What about constructors with more than one argument? In that case, the "
"PureScript compiler also creates a new object type, and a helper function. "
"This time, however, the helper function is a curried function of two "
"arguments. For example, this algebraic data type:"
msgstr ""
"1引数より多く取る構築子についてはどうでしょうか。\n"
"その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成しま"
"す。\n"
"ただしこの場合、補助関数は2引数のカリー化された関数です。\n"
"例えば次のような代数的データ型を考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1210
#, no-wrap
msgid "data Two a b = Two a b\n"
msgstr "data Two a b = Two a b\n"

#. type: Plain text
#: text/chapter10.md:1215
msgid "Generates this JavaScript code:"
msgstr "このコードからは、次のようなJavaScriptコードが生成されます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1216
#, no-wrap
msgid ""
"function Two(value0, value1) {\n"
"    this.value0 = value0;\n"
"    this.value1 = value1;\n"
"};\n"
"\n"
"Two.create = function (value0) {\n"
"    return function (value1) {\n"
"        return new Two(value0, value1);\n"
"    };\n"
"};\n"
msgstr ""
"function Two(value0, value1) {\n"
"    this.value0 = value0;\n"
"    this.value1 = value1;\n"
"};\n"
"\n"
"Two.create = function (value0) {\n"
"    return function (value1) {\n"
"        return new Two(value0, value1);\n"
"    };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1230
msgid ""
"Here, values of the object type `Two` can be created using the `new` keyword "
"or by using the `Two.create` function."
msgstr ""
"ここで、オブジェクト型`Two`の値はキーワード`new`または`Two.create`関数を使用"
"すると作成できます。"

#. type: Plain text
#: text/chapter10.md:1232
msgid ""
"The case of newtypes is slightly different. Recall that a newtype is like an "
"algebraic data type, restricted to having a single constructor taking a "
"single argument. In this case, the runtime representation of the newtype is "
"the same as its argument type."
msgstr ""
"newtypeの場合はまた少し異なります。\n"
"newtypeは代数的データ型のようなもので、単一の引数を取る単一の構築子を持つよう"
"制限されていたことを思い出してください。\n"
"この場合、newtypeの実行時表現は、その引数の型と同じになります。"

#. type: Plain text
#: text/chapter10.md:1234
msgid ""
"For example, this newtype represents telephone numbers is represented as a "
"JavaScript string at runtime:"
msgstr ""
"例えば、以下の電話番号を表すnewtypeは実行時にJavaScriptの文字列として表現され"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1235
#, no-wrap
msgid "newtype PhoneNumber = PhoneNumber String\n"
msgstr "newtype PhoneNumber = PhoneNumber String\n"

#. type: Plain text
#: text/chapter10.md:1240
msgid ""
"This is useful for designing libraries since newtypes provide an additional "
"layer of type safety without the runtime overhead of another function call."
msgstr ""
"newtypeは、関数呼び出しによる実行時のオーバーヘッドなく更なる型安全性のための"
"層を提供するため、ライブラリを設計するのに便利です。"

#. type: Title ###
#: text/chapter10.md:1241
#, no-wrap
msgid "Representing Quantified Types"
msgstr "量化された型の表現"

#. type: Plain text
#: text/chapter10.md:1244
msgid ""
"Expressions with quantified (polymorphic) types have restrictive "
"representations at runtime. In practice, there are relatively few "
"expressions with a given quantified type, but we can reason about them quite "
"effectively."
msgstr ""
"量化された型（多相型）の式は、実行時は制限された表現になっています。\n"
"実際、所与の量化された型を持つ式がより少なくなりますが、それによりかなり効率"
"的に推論できるのです。"

#. type: Plain text
#: text/chapter10.md:1246
msgid "Consider this polymorphic type, for example:"
msgstr "例えば、次の多相型を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1247
#, no-wrap
msgid "forall a. a -> a\n"
msgstr "forall a. a -> a\n"

#. type: Plain text
#: text/chapter10.md:1252
msgid ""
"What sort of functions have this type? Well, there is certainly one function "
"with this type:"
msgstr ""
"この型を持っている関数にはどんなものがあるでしょうか。\n"
"実は少なくとも1つ、この型を持つ関数が存在します。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1253
#, no-wrap
msgid ""
"identity :: forall a. a -> a\n"
"identity a = a\n"
msgstr ""
"identity :: forall a. a -> a\n"
"identity a = a\n"

#. type: Plain text
#: text/chapter10.md:1259
#, no-wrap
msgid "> Note that the actual [`identity`](https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Category#v:identity) function defined in `Prelude` has a slightly different type.\n"
msgstr "> なお、`Prelude`に定義された実際の[`identity`](https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Category#v:identity)関数は僅かに違った型を持ちます。\n"

#. type: Plain text
#: text/chapter10.md:1261
msgid ""
"In fact, the `identity` function is the _only_ (total) function with this "
"type! This certainly seems to be the case (try writing an expression with "
"this type that is not observably equivalent to `identity`), but how can we "
"be sure? We can be sure by considering the runtime representation of the "
"type."
msgstr ""
"実のところ、`identity`関数はこの型の*唯一の*（全）関数です。\n"
"これは確かに間違いなさそうに思えますが（この型を持った `id`とは明らかに異なる"
"式を書こうとしてみてください）、確かめるにはどうしたらいいでしょうか。\n"
"型の実行時表現を考えることによって確かめられます。"

#. type: Plain text
#: text/chapter10.md:1263
#, no-wrap
msgid "What is the runtime representation of a quantified type `forall a. t`? Well, any expression with the runtime representation for this type must have the correct runtime representation for the type `t` for any choice of type `a`. In our example above, a function of type `forall a. a -> a` must have the correct runtime representation for the types `String -> String`, `Number -> Number`, `Array Boolean -> Array Boolean`, and so on. It must take strings to strings, numbers to numbers, etc.\n"
msgstr "量化された型 `forall a. t`の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 `a`をどのように選んでも型 `t`の適切な実行時表現を持っていなければなりません。上の例では、型 `forall a. a -> a`の関数は、 `String -> String`、 `Number -> Number`、 `Array Boolean -> Array Boolean`などといった型について、適切な実行時表現を持っていなければなりません。 これらは、文字列から文字列、数から数の関数でなくてはなりません。\n"

#. type: Plain text
#: text/chapter10.md:1265
msgid ""
"But that is not enough – the runtime representation of a quantified type is "
"more strict than this. We require any expression to be _parametrically "
"polymorphic_ – that is, it cannot use any information about the type of its "
"argument in its implementation. This additional condition prevents "
"problematic implementations such as the following JavaScript function from "
"inhabiting a polymorphic type:"
msgstr ""
"しかし、それだけでは充分ではありません。\n"
"量化された型の実行時表現は、これよりも更に厳しいものです。\n"
"任意の式が*パラメトリック多相的*であることを要求しています。\n"
"つまり、その実装において、引数の型についてのどんな情報も使うことができないの"
"です。\n"
"この追加の条件は、以下のJavaScriptの関数のような問題のある実装が多相型に現住"
"することを防止します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1266
#, no-wrap
msgid ""
"function invalid(a) {\n"
"    if (typeof a === 'string') {\n"
"        return \"Argument was a string.\";\n"
"    } else {\n"
"        return a;\n"
"    }\n"
"}\n"
msgstr ""
"function invalid(a) {\n"
"    if (typeof a === 'string') {\n"
"        return \"Argument was a string.\";\n"
"    } else {\n"
"        return a;\n"
"    }\n"
"}\n"

#. type: Plain text
#: text/chapter10.md:1277
#, no-wrap
msgid "Certainly, this function takes strings to strings, numbers to numbers, etc. But it does not meet the additional condition, since it inspects the (runtime) type of its argument, so this function would not be a valid inhabitant of the type `forall a. a -> a`.\n"
msgstr ""
"確かにこの関数は文字列を取って文字列を返し、数を取って数を返す、といったものです。\n"
"しかしこの関数は追加条件を満たしていません。\n"
"引数の実行時の型を調べており、型`forall a. a -> a`の正しい現住にはならないからです。\n"

#. type: Plain text
#: text/chapter10.md:1279
#, no-wrap
msgid "Without being able to inspect the runtime type of our function argument, our only option is to return the argument unchanged. So `identity` is indeed the only inhabitant of the type `forall a. a -> a`.\n"
msgstr ""
"関数の引数の実行時の型を検査できなければ、唯一の選択肢は引数をそのまま返すことだけです。\n"
"したがって`id`は確かに`forall a. a -> a`の唯一の現住なのです。\n"

#. type: Plain text
#: text/chapter10.md:1281
msgid ""
"A full discussion of _parametric polymorphism_ and _parametricity_ is beyond "
"the scope of this book. Note, however, that since PureScript's types are "
"_erased_ at runtime, a polymorphic function in PureScript _cannot_ inspect "
"the runtime representation of its arguments (without using the FFI), so this "
"representation of polymorphic data is appropriate."
msgstr ""
"*パラメトリック多相*と*パラメトリック性*についての詳しい議論は本書の範囲を超"
"えています。\n"
"ただ、PureScriptの型は実行時に*消去*されており、PureScriptの多相関数は（FFIを"
"使わない限り）引数の実行時表現を検査*できない*ため、この多相的なデータの表現"
"が適切になっているという点にはご留意ください。"

#. type: Title ###
#: text/chapter10.md:1282
#, no-wrap
msgid "Representing Constrained Types"
msgstr "制約のある型の表現"

#. type: Plain text
#: text/chapter10.md:1285
msgid ""
"Functions with a type class constraint have an interesting representation at "
"runtime. Because the function's behavior might depend on the type class "
"instance chosen by the compiler, the function is given an additional "
"argument, called a _type class dictionary_, which contains the "
"implementation of the type class functions provided by the chosen instance."
msgstr ""
"型クラス制約を持つ関数は、実行時に面白い表現を持っています。\n"
"関数の挙動はコンパイラによって選ばれた型クラスのインスタンスに依存する可能性"
"があるため、関数には*型クラス辞書*と呼ばれる追加の引数が与えられます。\n"
"この辞書には選ばれたインスタンスから提供される型クラスの関数の実装が含まれま"
"す。"

#. type: Plain text
#: text/chapter10.md:1287
msgid ""
"For example, here is a simple PureScript function with a constrained type "
"that uses the `Show` type class:"
msgstr ""
"例えば以下は、`Show`型クラスを使う制約付きの型を持つ、単純なPureScript関数で"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1288
#, no-wrap
msgid ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"
msgstr ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"

#. type: Plain text
#: text/chapter10.md:1294
msgid "The generated JavaScript looks like this:"
msgstr "生成されるJavaScriptは次のようになります。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1295
#, no-wrap
msgid ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"
msgstr ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1304
msgid ""
"Notice that `shout` is compiled to a (curried) function of two arguments, "
"not one. The first argument `dict` is the type class dictionary for the "
"`Show` constraint. `dict` contains the implementation of the `show` function "
"for the type `a`."
msgstr ""
"`shout`は1引数ではなく、2引数の（カリー化された）関数にコンパイルされているこ"
"とに注意してください。最初の引数 `dict`は `Show`制約の型クラス辞書です。 "
"`dict`には型 `a`の `show`関数の実装が含まれています。"

#. type: Plain text
#: text/chapter10.md:1306
msgid ""
"We can call this function from JavaScript by passing an explicit type class "
"dictionary from `Data.Show` as the first parameter:"
msgstr ""
"最初の引数として明示的に`Data.Show`の型クラス辞書を渡すと、JavaScriptからこの"
"関数を呼び出すことができます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1307
#, no-wrap
msgid ""
"import { showNumber } from 'Data.Show'\n"
"\n"
"shout(showNumber)(42);\n"
msgstr ""
"import { showNumber } from 'Data.Show'\n"
"\n"
"shout(showNumber)(42);\n"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1316
msgid "(Easy) What are the runtime representations of these types?"
msgstr "（簡単）これらの型の実行時の表現は何でしょうか。"

#. type: Plain text
#: text/chapter10.md:1322
#, no-wrap
msgid ""
"     ```haskell\n"
"     forall a. a\n"
"     forall a. a -> a -> a\n"
"     forall a. Ord a => Array a -> Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     forall a. a\n"
"     forall a. a -> a -> a\n"
"     forall a. Ord a => Array a -> Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter10.md:1325
#, no-wrap
msgid ""
"     What can you say about the expressions which have these types?\n"
" 1. (Medium) Try using the functions defined in the `arrays` package, calling them from JavaScript, by compiling the library using `spago build` and importing modules using the `import` function in NodeJS. _Hint_: you may need to configure the output path so that the generated ES modules are available on the NodeJS module path.\n"
msgstr ""
"     これらの型を持つ式についてわかることは何でしょうか。\n"
"1. （普通）`spago build`を使ってコンパイルし、NodeJSの `import`機能を使ってモジュールをインポートすることで、JavaScriptから `arrays`ライブラリの関数を使ってみてください。\n"
"   *手掛かり*：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。\n"

#. type: Title ###
#: text/chapter10.md:1326
#, no-wrap
msgid "Representing Side Effects"
msgstr "副作用の表現"

#. type: Plain text
#: text/chapter10.md:1329
msgid ""
"The `Effect` monad is also defined as a foreign type. Its runtime "
"representation is quite simple – an expression of type `Effect a` should "
"evaluate to a JavaScript function of **no arguments**, which performs any "
"side-effects and returns a value with the correct runtime representation for "
"type `a`."
msgstr ""
"`Effect`モナドも外部型として定義されています。\n"
"その実行時表現はとても単純です。\n"
"型`Effect a`の式は**引数なしの**JavaScript関数へと評価されます。\n"
"この関数はあらゆる副作用を実行し、型`a`の適切な実行時表現を持つ値を返します。"

#. type: Plain text
#: text/chapter10.md:1331
msgid ""
"The definition of the `Effect` type constructor is given in the `Effect` "
"module as follows:"
msgstr ""
"`Effect`型構築子の定義は、 `Effect`モジュールで次のように与えられています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1332
#, no-wrap
msgid "foreign import data Effect :: Type -> Type\n"
msgstr "foreign import data Effect :: Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:1337
msgid ""
"As a simple example, consider the `random` function defined in the `random` "
"package. Recall that its type was:"
msgstr ""
"簡単な例として、 `random`パッケージで定義される `random`関数を考えてみてくだ"
"さい。その型は次のようなものでした。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1338
#, no-wrap
msgid "foreign import random :: Effect Number\n"
msgstr "foreign import random :: Effect Number\n"

#. type: Plain text
#: text/chapter10.md:1343
msgid "The definition of the `random` function is given here:"
msgstr "`random`関数の定義は次のように与えられます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1344
#, no-wrap
msgid "export const random = Math.random;\n"
msgstr "export const random = Math.random;\n"

#. type: Plain text
#: text/chapter10.md:1349
msgid ""
"Notice that the `random` function is represented at runtime as a function of "
"no arguments. It performs the side effect of generating a random number, "
"returns it, and the return value matches the runtime representation of the "
"`Number` type: it is a non-null JavaScript number."
msgstr ""
"`random`関数は実行時には引数なしの関数として表現されていることに注目してくだ"
"さい。\n"
"この関数は乱数生成という副作用を実行して返しますが、返り値は`Number`型の実行"
"時表現と一致します。\n"
"`Number`型はnullでないJavaScriptの数です。"

#. type: Plain text
#: text/chapter10.md:1351
msgid ""
"As a slightly more interesting example, consider the `log` function defined "
"by the `Effect.Console` module in the `console` package. The `log` function "
"has the following type:"
msgstr ""
"もう少し興味深い例として、`console`パッケージ中の`Effect.Console`モジュールで"
"定義された `log`関数を考えてみましょう。 `log`関数は次の型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1352
#, no-wrap
msgid "foreign import log :: String -> Effect Unit\n"
msgstr "foreign import log :: String -> Effect Unit\n"

#. type: Plain text
#: text/chapter10.md:1357
msgid "And here is its definition:"
msgstr "この定義は次のようになっています。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1358
#, no-wrap
msgid ""
"export const log = function (s) {\n"
"  return function () {\n"
"    console.log(s);\n"
"  };\n"
"};\n"
msgstr ""
"export const log = function (s) {\n"
"  return function () {\n"
"    console.log(s);\n"
"  };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1367
msgid ""
"The representation of `log` at runtime is a JavaScript function of a single "
"argument, returning a function of no arguments. The inner function performs "
"the side-effect of writing a message to the console."
msgstr ""
"実行時の `log`の表現は、単一の引数のJavaScript関数で、引数なしの関数を返しま"
"す。\n"
"内側の関数はコンソールに文言を書き込むという副作用を実行します。"

#. type: Plain text
#: text/chapter10.md:1369
msgid ""
"Expressions of type `Effect a` can be invoked from JavaScript like regular "
"JavaScript methods. For example, since the `main` function is required to "
"have type `Effect a` for some type `a`, it can be invoked as follows:"
msgstr ""
"`Effect a`型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出す"
"ことができます。例えば、この `main`関数は何らかの型`a`について`Effect a`とい"
"う型でなければならないので、次のように実行できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1370
#, no-wrap
msgid ""
"import { main } from 'Main'\n"
"\n"
"main();\n"
msgstr ""
"import { main } from 'Main'\n"
"\n"
"main();\n"

#. type: Plain text
#: text/chapter10.md:1376
msgid ""
"When using `spago bundle-app --to` or `spago run`, this call to `main` is "
"generated automatically whenever the `Main` module is defined."
msgstr ""
"`spago bundle-app --to`または`spago run`を使用する場合、`Main`モジュールが定"
"義されている場合は常に、この`main`の呼び出しを自動的に生成できます。"

#. type: Title #
#: text/chapter11.md:1
#, no-wrap
msgid "Monadic Adventures"
msgstr "モナドな冒険"

#. type: Plain text
#: text/chapter11.md:6
msgid ""
"The goal of this chapter will be to learn about _monad transformers_, which "
"provide a way to combine side-effects provided by different monads. The "
"motivating example will be a text adventure game that can be played on the "
"console in NodeJS. The various side-effects of the game (logging, state, and "
"configuration) will all be provided by a monad transformer stack."
msgstr ""
"この章の目標は*モナド変換子*について学ぶことです。\n"
"モナド変換子は異なるモナドから提供された副作用を合成する方法を提供します。\n"
"動機付けとする例は、NodeJSのコンソール上で遊ぶことができるテキストアドベン"
"チャーゲームです。\n"
"ゲームの様々な副作用（ロギング、状態、及び構成）が全てモナド変換子スタックに"
"よって提供されます。"

#. type: Plain text
#: text/chapter11.md:10 text/chapter12.md:10
msgid "This module's project introduces the following new dependencies:"
msgstr "このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`ordered-collections`, which provides data types for immutable maps and sets"
msgstr "`ordered-collections` は不変のマップと集合のためのデータ型を提供します"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`transformers`, which provides implementations of standard monad transformers"
msgstr "`transformers` は標準的なモナド変換子の実装を提供します"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`node-readline`, which provides FFI bindings to the [`readline`](https://"
"nodejs.org/api/readline.html) interface provided by NodeJS"
msgstr ""
"`node-readline`はNodeJSが提供する[`readline`](http://nodejs.org/api/readline."
"html)インターフェイスへのFFIバインディングを提供します"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`optparse`, which provides applicative parsers for processing command-line "
"arguments"
msgstr ""
"`optparse`はコマンドライン引数を処理するアプリカティブ構文解析器を提供します"

#. type: Title ##
#: text/chapter11.md:16
#, no-wrap
msgid "How To Play The Game"
msgstr "ゲームの遊びかた"

#. type: Plain text
#: text/chapter11.md:19
msgid "To run the project, use `spago run`"
msgstr "プロジェクトを走らせるには`spago run`を使います。"

#. type: Plain text
#: text/chapter11.md:21
msgid "By default, you will see a usage message:"
msgstr "既定では使い方の文言が表示されます。"

#. type: Fenced code block (text)
#: text/chapter11.md:22
#, no-wrap
msgid ""
"Monadic Adventures! A game to learn monad transformers\n"
"\n"
"Usage: run.js (-p|--player <player name>) [-d|--debug]\n"
"  Play the game as <player name>\n"
"\n"
"Available options:\n"
"  -p,--player <player name>\n"
"                           The player's name <String>\n"
"  -d,--debug               Use debug mode\n"
"  -h,--help                Show this help text\n"
msgstr ""
"Monadic Adventures! A game to learn monad transformers\n"
"\n"
"Usage: run.js (-p|--player <player name>) [-d|--debug]\n"
"  Play the game as <player name>\n"
"\n"
"Available options:\n"
"  -p,--player <player name>\n"
"                           The player's name <String>\n"
"  -d,--debug               Use debug mode\n"
"  -h,--help                Show this help text\n"

#. type: Plain text
#: text/chapter11.md:36
msgid ""
"To provide command line arguments, you can either call `spago run` with the "
"`-a` option to pass additional arguments directly to your application or "
"call `spago bundle-app`, which will create an index.js file that can be run "
"directly with `node`."
msgstr ""
"コマンドライン引数を与えるためには、追加の引数を直接アプリケーションに渡す`-"
"a`オプション付きで`spago run`を呼び出すか、`spago bundle-app`とすればよいで"
"す。\n"
"2つ目の方法では`node`で直接走らせられるindex.jsファイルが作られます。"

#. type: Plain text
#: text/chapter11.md:38
msgid "For example, to provide the player name using the `-p` option:"
msgstr "例えば`-p`オプションを使ってプレイヤー名を与えるには次のようにします。"

#. type: Fenced code block (text)
#: text/chapter11.md:39
#, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
">\n"
msgstr ""
"$ spago run -a \"-p Phil\"\n"
">\n"

#. type: Fenced code block (text)
#: text/chapter11.md:44
#, no-wrap
msgid ""
"$ spago bundle-app \n"
"$ node index.js -p Phil\n"
">\n"
msgstr ""
"$ spago bundle-app \n"
"$ node index.js -p Phil\n"
">\n"

#. type: Plain text
#: text/chapter11.md:51
msgid ""
"From the prompt, you can enter commands like `look`, `inventory`, `take`, "
"`use`, `north`, `south`, `east`, and `west`. There is also a `debug` "
"command, which can print the game state when the `--debug` command line "
"option is provided."
msgstr ""
"プロンプトからは、`look`、`inventory`、`take`、`use`、`north`、`south`、"
"`east`、`west`などのコマンドを入力できます。\n"
"`debug`コマンドもあり、`--debug`コマンドラインオプションを与えられていた場合"
"に、ゲームの状態を出力できます。"

#. type: Plain text
#: text/chapter11.md:53
msgid ""
"The game is played on a two-dimensional grid, and the player moves by "
"issuing commands `north`, `south`, `east`, and `west`. The game contains a "
"collection of items that can either be in the player's possession (in the "
"user's _inventory_) or on the game grid at some location. Items can be "
"picked up by the player using the `take` command."
msgstr ""
"ゲームは2次元の碁盤の目の上が舞台で、コマンド`north`、`south`、`east`、`west`"
"を発行することによってプレイヤーが移動します。\n"
"ゲームにはアイテムの集まりがあり、プレイヤーの所有物であったり、ゲームの盤上"
"の特定の位置にあったりします。\n"
"`take`コマンドを使うと、プレイヤーはアイテムを拾い上げられます。"

#. type: Plain text
#: text/chapter11.md:55
msgid "For reference, here is a complete walkthrough of the game:"
msgstr "参考までに、このゲームのひと通りの流れは次のようになります。"

#. type: Fenced code block (text)
#: text/chapter11.md:56
#, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
"\n"
"> look\n"
"You are at (0, 0)\n"
"You are in a dark forest. You see a path to the north.\n"
"You can see the Matches.\n"
"\n"
"> take Matches\n"
"You now have the Matches\n"
"\n"
"> north\n"
"> look\n"
"You are at (0, 1)\n"
"You are in a clearing.\n"
"You can see the Candle.\n"
"\n"
"> take Candle\n"
"You now have the Candle\n"
"\n"
"> inventory\n"
"You have the Candle.\n"
"You have the Matches.\n"
"\n"
"> use Matches\n"
"You light the candle.\n"
"Congratulations, Phil!\n"
"You win!\n"
msgstr ""
"$ spago run -a \"-p Phil\"\n"
"\n"
"> look\n"
"You are at (0, 0)\n"
"You are in a dark forest. You see a path to the north.\n"
"You can see the Matches.\n"
"\n"
"> take Matches\n"
"You now have the Matches\n"
"\n"
"> north\n"
"> look\n"
"You are at (0, 1)\n"
"You are in a clearing.\n"
"You can see the Candle.\n"
"\n"
"> take Candle\n"
"You now have the Candle\n"
"\n"
"> inventory\n"
"You have the Candle.\n"
"You have the Matches.\n"
"\n"
"> use Matches\n"
"You light the candle.\n"
"Congratulations, Phil!\n"
"You win!\n"

#. type: Plain text
#: text/chapter11.md:87
msgid ""
"The game is very simple, but the aim of the chapter is to use the "
"`transformers` package to build a library that will enable rapid development "
"of this type of game."
msgstr ""
"このゲームはとても単純ですが、この章の目的は`transformers`パッケージを使用し"
"てこのような種類のゲームを素早く開発できるようにするライブラリを構築すること"
"です。"

#. type: Title ##
#: text/chapter11.md:88
#, no-wrap
msgid "The State Monad"
msgstr "Stateモナド"

#. type: Plain text
#: text/chapter11.md:91
msgid ""
"We will start by looking at some of the monads provided by the "
"`transformers` package."
msgstr ""
"`transformers`パッケージで提供されている幾つかのモナドを眺めることから始めま"
"しょう。"

#. type: Plain text
#: text/chapter11.md:93
msgid ""
"The first example is the `State` monad, which provides a way to model "
"_mutable state_ in pure code. We have already seen an approach to a mutable "
"state provided by the `Effect` monad. `State` provides an alternative."
msgstr ""
"最初の例は`State`モナドです。\n"
"これは純粋なコードで*変更可能状態*をモデル化する手段を提供します。\n"
"既に`Effect`モナドによって提供される変更可能状態の手法について見てきまし"
"た。\n"
"`State`はその代替を提供します。"

#. type: Plain text
#: text/chapter11.md:95
msgid ""
"The `State` type constructor takes two type parameters: the type `s` of the "
"state and the return type `a`. Even though we speak of the \"`State` "
"monad\", the instance of the `Monad` type class is actually provided for the "
"`State s` type constructor for any type `s`."
msgstr ""
"`State`型構築子は、状態の型`s`、及び返り値の型`a`という2種類の引数を取りま"
"す。\n"
"「`State`モナド」というように説明はしていますが、実際には`Monad`型クラスのイ"
"ンスタンスが任意の型`s`についての`State s`型構築子に対して提供されています。"

#. type: Plain text
#: text/chapter11.md:97
msgid "The `Control.Monad.State` module provides the following API:"
msgstr "`Control.Monad.State`モジュールは以下のAPIを提供しています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:98
#, no-wrap
msgid ""
"get     :: forall s.             State s s\n"
"gets    :: forall s. (s -> a) -> State s a\n"
"put     :: forall s. s        -> State s Unit\n"
"modify  :: forall s. (s -> s) -> State s s\n"
"modify_ :: forall s. (s -> s) -> State s Unit\n"
msgstr ""
"get     :: forall s.             State s s\n"
"gets    :: forall s. (s -> a) -> State s a\n"
"put     :: forall s. s        -> State s Unit\n"
"modify  :: forall s. (s -> s) -> State s s\n"
"modify_ :: forall s. (s -> s) -> State s Unit\n"

#. type: Plain text
#: text/chapter11.md:107
msgid ""
"Note that these API signatures are presented in a simplified form using the "
"`State` type constructor for now. The actual API involves `MonadState`, "
"which we'll cover in the later \"Type Classes\" section of this chapter, so "
"don't worry if you see different signatures in your IDE tooltips or on "
"Pursuit."
msgstr ""
"なお、ここではこれらのAPIシグネチャは`State`型構築子を使った、単純化された形"
"式で表されています。\n"
"実際のAPIは本章の後にある「型クラス」節で押さえる`MonadState`が関わってきま"
"す。\n"
"ですからIDEのツールチップやPursuitで違うシグネチャを見たとしても心配しないで"
"ください。"

#. type: Plain text
#: text/chapter11.md:109
msgid ""
"Let's see an example. One use of the `State` monad might be to add the "
"values in an array of integers to the current state. We could do that by "
"choosing `Int` as the state type `s` and using `traverse_` to traverse the "
"array, with a call to `modify` for each array element:"
msgstr ""
"例を見てみましょう。\n"
"`State`モナドの使い方の1つとしては、整数の配列中の値を現在の状態に加えるもの"
"が考えられます。\n"
"状態の型`s`として`Int`を選択し、配列の走査に`traverse_`を使い、配列の各要素に"
"ついて`modify`を呼び出すと、これを実現できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:110
#, no-wrap
msgid ""
"import Data.Foldable (traverse_)\n"
"import Control.Monad.State\n"
"import Control.Monad.State.Class\n"
"\n"
"sumArray :: Array Int -> State Int Unit\n"
"sumArray = traverse_ \\n -> modify \\sum -> sum + n\n"
msgstr ""
"import Data.Foldable (traverse_)\n"
"import Control.Monad.State\n"
"import Control.Monad.State.Class\n"
"\n"
"sumArray :: Array Int -> State Int Unit\n"
"sumArray = traverse_ \\n -> modify \\sum -> sum + n\n"

#. type: Plain text
#: text/chapter11.md:120
msgid ""
"The `Control.Monad.State` module provides three functions for running a "
"computation in the `State` monad:"
msgstr ""
"`Control.Monad.State`モジュールは、`State`モナドで計算するための次の3つの関数"
"を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:121
#, no-wrap
msgid ""
"evalState :: forall s a. State s a -> s -> a\n"
"execState :: forall s a. State s a -> s -> s\n"
"runState  :: forall s a. State s a -> s -> Tuple a s\n"
msgstr ""
"evalState :: forall s a. State s a -> s -> a\n"
"execState :: forall s a. State s a -> s -> s\n"
"runState  :: forall s a. State s a -> s -> Tuple a s\n"

#. type: Plain text
#: text/chapter11.md:128
msgid ""
"Each function takes an initial state of type `s` and a computation of type "
"`State s a`. `evalState` only returns the return value, `execState` only "
"returns the final state, and `runState` returns both, expressed as a value "
"of type `Tuple a s`."
msgstr ""
"3つの各関数は型`s`の初期状態と型`State s a`の計算を引数に取ります。\n"
"`evalState`は返り値だけを返し、`execState`は最終的な状態だけを返し、"
"`runState`は`Tuple a s`型の値として表現された両方を返します。"

#. type: Plain text
#: text/chapter11.md:130
msgid ""
"Given the `sumArray` function above, we could use `execState` in PSCi to sum "
"the numbers in several arrays as follows:"
msgstr ""
"先ほどの `sumArray`関数が与えられているとき、PSCiで `execState`を使うと次のよ"
"うに複数の配列内の数字を合計できます。"

#. type: Fenced code block (text)
#: text/chapter11.md:131
#, no-wrap
msgid ""
"> :paste\n"
"… execState (do\n"
"…   sumArray [1, 2, 3]\n"
"…   sumArray [4, 5]\n"
"…   sumArray [6]) 0\n"
"… ^D\n"
"21\n"
msgstr ""
"> :paste\n"
"… execState (do\n"
"…   sumArray [1, 2, 3]\n"
"…   sumArray [4, 5]\n"
"…   sumArray [6]) 0\n"
"… ^D\n"
"21\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:145
msgid ""
"(Easy) What is the result of replacing `execState` with `runState` or "
"`evalState` in our example above?"
msgstr ""
"（簡単）上の例で、`execState`を`runState`や`evalState`で置き換えると結果はど"
"うなるでしょうか。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:145
msgid ""
"(Medium) A string of parentheses is _balanced_ if it is obtained by either "
"concatenating zero-or-more shorter balanced strings or wrapping a shorter "
"balanced string in a pair of parentheses."
msgstr ""
"（普通）括弧からなる文字列が*平衡している*のは、0個以上のより短い平衡した文字"
"列を連結したものか、より短い平衡した文字列を一対の括弧で囲んだものかの何れか"
"です。"

#. type: Plain text
#: text/chapter11.md:147
#, no-wrap
msgid "     Use the `State` monad and the `traverse_` function to write a function\n"
msgstr "    `State`モナドと `traverse_`関数を使用して、次のような関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:151
#, no-wrap
msgid ""
"     ```haskell\n"
"     testParens :: String -> Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     testParens :: String -> Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:153
#, no-wrap
msgid "     which tests whether or not a `String` of parentheses is balanced by keeping track of the number of opening parentheses that have not been closed. Your function should work as follows:\n"
msgstr ""
"     これは、まだ閉じられていない開括弧の数を把握することで、括弧の`String`が平衡しているかどうかを調べる関数です。\n"
"     この関数は次のように動作します。\n"

#. type: Plain text
#: text/chapter11.md:157
#, no-wrap
msgid ""
"     ```text\n"
"     > testParens \"\"\n"
"     true\n"
msgstr ""
"     ```text\n"
"     > testParens \"\"\n"
"     true\n"

#. type: Plain text
#: text/chapter11.md:160
#, no-wrap
msgid ""
"     > testParens \"(()(())())\"\n"
"     true\n"
msgstr ""
"     > testParens \"(()(())())\"\n"
"     true\n"

#. type: Plain text
#: text/chapter11.md:163
#, no-wrap
msgid ""
"     > testParens \")\"\n"
"     false\n"
msgstr ""
"     > testParens \")\"\n"
"     false\n"

#. type: Plain text
#: text/chapter11.md:167
#, no-wrap
msgid ""
"     > testParens \"(()()\"\n"
"     false\n"
"     ```\n"
msgstr ""
"     > testParens \"(()()\"\n"
"     false\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:169
#, no-wrap
msgid "     _Hint_: you may like to use the `toCharArray` function from the `Data.String.CodeUnits` module to turn the input string into an array of characters.\n"
msgstr "     *手掛かり*：入力の文字列を文字の配列に変換するのに、`Data.String.CodeUnits`モジュールの `toCharArray`関数を使うと良いでしょう。\n"

#. type: Title ##
#: text/chapter11.md:170
#, no-wrap
msgid "The Reader Monad"
msgstr "Readerモナド"

#. type: Plain text
#: text/chapter11.md:173
msgid ""
"Another monad provided by the `transformers` package is the `Reader` monad. "
"This monad provides the ability to read from a global configuration. Whereas "
"the `State` monad provides the ability to read and write a single piece of "
"mutable state, the `Reader` monad only provides the ability to read a single "
"piece of data."
msgstr ""
"`transformers`パッケージでは `Reader`というモナドも提供されています。\n"
"このモナドは大域的な設定を読み取る機能を提供します。\n"
"`State`モナドが1つの可変状態を読み書きする機能を提供するのに対し、 `Reader`モ"
"ナドは1つのデータの読み取り機能だけを提供します。"

#. type: Plain text
#: text/chapter11.md:175
msgid ""
"The `Reader` type constructor takes two type arguments: a type `r` which "
"represents the configuration type, and the return type `a`."
msgstr ""
"`Reader`型構築子は、設定の型を表す型 `r`、及び戻り値の型 `a`の2つの型引数を取"
"ります。"

#. type: Plain text
#: text/chapter11.md:177
msgid "The `Control.Monad.Reader` module provides the following API:"
msgstr "`Control.Monad.Reader`モジュールは以下のAPIを提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:178
#, no-wrap
msgid ""
"ask   :: forall r. Reader r r\n"
"local :: forall r a. (r -> r) -> Reader r a -> Reader r a\n"
msgstr ""
"ask   :: forall r. Reader r r\n"
"local :: forall r a. (r -> r) -> Reader r a -> Reader r a\n"

#. type: Plain text
#: text/chapter11.md:184
msgid ""
"The `ask` action can be used to read the current configuration, and the "
"`local` action can be used to run a computation with a modified "
"configuration."
msgstr ""
"`ask`動作は現在の設定を読み取るために使い、`local`動作は変更された設定で計算"
"するために使います。"

#. type: Plain text
#: text/chapter11.md:186
msgid ""
"For example, suppose we were developing an application controlled by "
"permissions, and we wanted to use the `Reader` monad to hold the current "
"user's permissions object. We might choose the type `r` to be some type "
"`Permissions` with the following API:"
msgstr ""
"例えば、権限で制御するアプリケーションを開発しており、現在の利用者の権限オブ"
"ジェクトを保持するのに `Reader`モナドを使いたいとしましょう。\n"
"型 `r`を次のようなAPIを備えた型 `Permission`として選択できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:187
#, no-wrap
msgid ""
"hasPermission :: String -> Permissions -> Boolean\n"
"addPermission :: String -> Permissions -> Permissions\n"
msgstr ""
"hasPermission :: String -> Permissions -> Boolean\n"
"addPermission :: String -> Permissions -> Permissions\n"

#. type: Plain text
#: text/chapter11.md:193
msgid ""
"Whenever we wanted to check if the user had a particular permission, we "
"could use `ask` to retrieve the current permissions object. For example, "
"only administrators might be allowed to create new users:"
msgstr ""
"利用者が特定の権限を持っているかどうかを確認したいときは、 `ask`を使って現在"
"の権限オブジェクトを取得すればいつでも調べることができます。\n"
"例えば管理者だけが新しい利用者の作成を許可されているとしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:194
#, no-wrap
msgid ""
"createUser :: Reader Permissions (Maybe User)\n"
"createUser = do\n"
"  permissions <- ask\n"
"  if hasPermission \"admin\" permissions\n"
"    then map Just newUser\n"
"    else pure Nothing\n"
msgstr ""
"createUser :: Reader Permissions (Maybe User)\n"
"createUser = do\n"
"  permissions <- ask\n"
"  if hasPermission \"admin\" permissions\n"
"    then map Just newUser\n"
"    else pure Nothing\n"

#. type: Plain text
#: text/chapter11.md:204
msgid ""
"To elevate the user's permissions, we might use the `local` action to modify "
"the `Permissions` object during the execution of some computation:"
msgstr ""
"`local`動作を使うと、計算の実行中に `Permissions`オブジェクトを変更し、ユー"
"ザーの権限を昇格させることもできます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:205
#, no-wrap
msgid ""
"runAsAdmin :: forall a. Reader Permissions a -> Reader Permissions a\n"
"runAsAdmin = local (addPermission \"admin\")\n"
msgstr ""
"runAsAdmin :: forall a. Reader Permissions a -> Reader Permissions a\n"
"runAsAdmin = local (addPermission \"admin\")\n"

#. type: Plain text
#: text/chapter11.md:211
msgid ""
"Then we could write a function to create a new user, even if the user did "
"not have the `admin` permission:"
msgstr ""
"こうすると、利用者が `admin`権限を持っていなかった場合であっても新しい利用者"
"を作成できるような関数を書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:212
#, no-wrap
msgid ""
"createUserAsAdmin :: Reader Permissions (Maybe User)\n"
"createUserAsAdmin = runAsAdmin createUser\n"
msgstr ""
"createUserAsAdmin :: Reader Permissions (Maybe User)\n"
"createUserAsAdmin = runAsAdmin createUser\n"

#. type: Plain text
#: text/chapter11.md:218
msgid ""
"To run a computation in the `Reader` monad, the `runReader` function can be "
"used to provide the global configuration:"
msgstr ""
"`Reader`モナドを計算するには、大域的な設定を与える`runReader`関数を使います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:219
#, no-wrap
msgid "runReader :: forall r a. Reader r a -> r -> a\n"
msgstr "runReader :: forall r a. Reader r a -> r -> a\n"

#. type: Plain text
#: text/chapter11.md:226
#, no-wrap
msgid " In these exercises, we will use the `Reader` monad to build a small library for rendering documents with indentation. The \"global configuration\" will be a number indicating the current indentation level:\n"
msgstr ""
"以下の演習では、 `Reader`モナドを使って、字下げのついた文書を出力するための小さなライブラリを作っていきます。\n"
"「大域的な設定」は、現在の字下げの深さを示す数になります。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:227
#, no-wrap
msgid ""
"type Level = Int\n"
"\n"
"type Doc = Reader Level String\n"
msgstr ""
"type Level = Int\n"
"\n"
"type Doc = Reader Level String\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:234
msgid ""
"(Easy) Write a function `line` that renders a function at the current "
"indentation level. Your function should have the following type:"
msgstr ""
"（簡単）現在の字下げの深さで関数を書き出す関数`line`を書いてください。\n"
"関数は以下の型を持ちます。"

#. type: Plain text
#: text/chapter11.md:238
#, no-wrap
msgid ""
"     ```haskell\n"
"     line :: String -> Doc\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     line :: String -> Doc\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:241
#, no-wrap
msgid ""
"     _Hint_: use the `ask` function to read the current indentation level. The `power` function from `Data.Monoid` may be helpful too.\n"
" 1. (Easy) Use the `local` function to write a function\n"
msgstr ""
"     *手掛かり*：現在の字下げの深さを読み取るためには `ask`関数を使用します。\n"
"     `Data.Monoid`の`power`関数も役に立つかもしれません。\n"
"1. （普通）`local`関数を使用して次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:245
#, no-wrap
msgid ""
"     ```haskell\n"
"     indent :: Doc -> Doc\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     indent :: Doc -> Doc\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:248
#, no-wrap
msgid ""
"     which increases the indentation level for a block of code.\n"
" 1. (Medium) Use the `sequence` function defined in `Data.Traversable` to write a function\n"
msgstr ""
"     この関数はコードブロックの字下げを深くします。\n"
"1. （普通）`Data.Traversable`で定義された `sequence`関数を使用して、次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:252
#, no-wrap
msgid ""
"     ```haskell\n"
"     cat :: Array Doc -> Doc\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     cat :: Array Doc -> Doc\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:255
#, no-wrap
msgid ""
"     which concatenates a collection of documents, separating them with new lines.\n"
" 1. (Medium) Use the `runReader` function to write a function\n"
msgstr ""
"     この関数は文書の集まりを改行で区切って連結します。\n"
"1. （普通）`runReader`関数を使用して次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:259
#, no-wrap
msgid ""
"     ```haskell\n"
"     render :: Doc -> String\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     render :: Doc -> String\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:261
#, no-wrap
msgid "     which renders a document as a String.\n"
msgstr "     この関数は文書を文字列として出力します。\n"

#. type: Plain text
#: text/chapter11.md:263
#, no-wrap
msgid " You should now be able to use your library to write simple documents as follows:\n"
msgstr " これでライブラリを使って以下のような単純な文書を書けるようになりました。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:264
#, no-wrap
msgid ""
" render $ cat\n"
"   [ line \"Here is some indented text:\"\n"
"   , indent $ cat\n"
"       [ line \"I am indented\"\n"
"       , line \"So am I\"\n"
"       , indent $ line \"I am even more indented\"\n"
"       ]\n"
"   ]\n"
msgstr ""
" render $ cat\n"
"   [ line \"Here is some indented text:\"\n"
"   , indent $ cat\n"
"       [ line \"I am indented\"\n"
"       , line \"So am I\"\n"
"       , indent $ line \"I am even more indented\"\n"
"       ]\n"
"   ]\n"

#. type: Title ##
#: text/chapter11.md:275
#, no-wrap
msgid "The Writer Monad"
msgstr "Writerモナド"

#. type: Plain text
#: text/chapter11.md:278
msgid ""
"The `Writer` monad allows accumulating a secondary value in addition to the "
"return value of a computation."
msgstr "`Writer`モナドでは、計算の返り値に加えてもう1つの値を累算できます。"

#. type: Plain text
#: text/chapter11.md:280
msgid ""
"A common use case is to accumulate a log of type `String` or `Array String`, "
"but the `Writer` monad is more general than this. It can accumulate a value "
"in any monoid, so it might be used to keep track of an integer total using "
"the `Additive Int` monoid or to track whether any of several intermediate "
"`Boolean` values were true using the `Disj Boolean` monoid."
msgstr ""
"よくある使い方としては型`String`もしくは`Array String`でログを累算していくと"
"いうものなどがありますが、`Writer`モナドはこれよりもっと一般的なものです。\n"
"累算するのに任意のモノイドの値を使うことができるので、`Additive Int`モノイド"
"を使って整数の合計を追跡するのに使ったり、`Disj Boolean`モノイドを使って途中"
"の`Boolean`値の何れかが真であるかどうかを追跡するのに使えます。"

#. type: Plain text
#: text/chapter11.md:282
msgid ""
"The `Writer` type constructor takes two type arguments: a type `w` that "
"should be an instance of the `Monoid` type class, and the return type `a`."
msgstr ""
"`Writer`型構築子は2つの型引数を取ります。\n"
"`Monoid`型クラスのインスタンスである型`w`と返り値の型`a`です。"

#. type: Plain text
#: text/chapter11.md:284
msgid "The key element of the `Writer` API is the `tell` function:"
msgstr "`Writer`のAPIで重要なのは `tell`関数です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:285
#, no-wrap
msgid "tell :: forall w a. Monoid w => w -> Writer w Unit\n"
msgstr "tell :: forall w a. Monoid w => w -> Writer w Unit\n"

#. type: Plain text
#: text/chapter11.md:290
msgid ""
"The `tell` action appends the provided value to the current accumulated "
"result."
msgstr "`tell`動作は与えられた値を現在の累算結果に付け加えます。"

#. type: Plain text
#: text/chapter11.md:292
msgid ""
"As an example, let's add a log to an existing function using the `Array "
"String` monoid. Consider our previous implementation of the _greatest common "
"divisor_ function:"
msgstr ""
"例として、`Array String`モノイドを使用して、既存の関数にログを追加してみま"
"しょう。\n"
"*最大公約数*関数の以前の実装を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:293
#, no-wrap
msgid ""
"gcd :: Int -> Int -> Int\n"
"gcd n 0 = n\n"
"gcd 0 m = m\n"
"gcd n m = if n > m\n"
"            then gcd (n - m) m\n"
"            else gcd n (m - n)\n"
msgstr ""
"gcd :: Int -> Int -> Int\n"
"gcd n 0 = n\n"
"gcd 0 m = m\n"
"gcd n m = if n > m\n"
"            then gcd (n - m) m\n"
"            else gcd n (m - n)\n"

#. type: Plain text
#: text/chapter11.md:303
msgid ""
"We could add a log to this function by changing the return type to `Writer "
"(Array String) Int`:"
msgstr ""
"`Writer (Array String) Int`へと返り値の型を変更することで、この関数にログ機能"
"を追加できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:304
#, no-wrap
msgid ""
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"\n"
"gcdLog :: Int -> Int -> Writer (Array String) Int\n"
msgstr ""
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"\n"
"gcdLog :: Int -> Int -> Writer (Array String) Int\n"

#. type: Plain text
#: text/chapter11.md:312
msgid ""
"We only have to change our function slightly to log the two inputs at each "
"step:"
msgstr ""
"各手順での2つの入力を記録するためには、少し関数を変更する必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:313
#, no-wrap
msgid ""
"    gcdLog n 0 = pure n\n"
"    gcdLog 0 m = pure m\n"
"    gcdLog n m = do\n"
"      tell [\"gcdLog \" <> show n <> \" \" <> show m]\n"
"      if n > m\n"
"        then gcdLog (n - m) m\n"
"        else gcdLog n (m - n)\n"
msgstr ""
"    gcdLog n 0 = pure n\n"
"    gcdLog 0 m = pure m\n"
"    gcdLog n m = do\n"
"      tell [\"gcdLog \" <> show n <> \" \" <> show m]\n"
"      if n > m\n"
"        then gcdLog (n - m) m\n"
"        else gcdLog n (m - n)\n"

#. type: Plain text
#: text/chapter11.md:324
msgid ""
"We can run a computation in the `Writer` monad by using either of the "
"`execWriter` or `runWriter` functions:"
msgstr ""
"`Writer`モナドを計算するには、`execWriter`関数または`runWriter`関数の何れかを"
"使います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:325
#, no-wrap
msgid ""
"execWriter :: forall w a. Writer w a -> w\n"
"runWriter  :: forall w a. Writer w a -> Tuple a w\n"
msgstr ""
"execWriter :: forall w a. Writer w a -> w\n"
"runWriter  :: forall w a. Writer w a -> Tuple a w\n"

#. type: Plain text
#: text/chapter11.md:331
msgid ""
"Just like in the case of the `State` monad, `execWriter` only returns the "
"accumulated log, whereas `runWriter` returns both the log and the result."
msgstr ""
"ちょうど `State`モナドの場合と同じように、 `execWriter`が累算されたログだけを"
"返すのに対して、 `runWriter`は累算されたログと結果の両方を返します。"

#. type: Plain text
#: text/chapter11.md:333
msgid "We can test our modified function in PSCi:"
msgstr "PSCiで改変した関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:334
#, no-wrap
msgid ""
"> import Control.Monad.Writer\n"
"> import Control.Monad.Writer.Class\n"
"\n"
"> runWriter (gcdLog 21 15)\n"
"Tuple 3 [\"gcdLog 21 15\",\"gcdLog 6 15\",\"gcdLog 6 9\",\"gcdLog 6 3\",\"gcdLog 3 3\"]\n"
msgstr ""
"> import Control.Monad.Writer\n"
"> import Control.Monad.Writer.Class\n"
"\n"
"> runWriter (gcdLog 21 15)\n"
"Tuple 3 [\"gcdLog 21 15\",\"gcdLog 6 15\",\"gcdLog 6 9\",\"gcdLog 6 3\",\"gcdLog 3 3\"]\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:346
msgid ""
"(Medium) Rewrite the `sumArray` function above using the `Writer` monad and "
"the `Additive Int` monoid from the `monoid` package."
msgstr ""
"（普通）`Writer`モナドと `monoid`パッケージの `Additive Int`モノイドを使うよ"
"うに、上の `sumArray`関数を書き換えてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:346
msgid ""
"(Medium) The _Collatz_ function is defined on natural numbers `n` as `n / 2` "
"when `n` is even and `3 * n + 1` when `n` is odd. For example, the iterated "
"Collatz sequence starting at `10` is as follows:"
msgstr ""
"（普通）*コラッツ*関数は自然数`n`上で定義され、`n`が偶数なら`n / 2`、`n`が奇"
"数なら`3 * n + 1`です。\n"
"例えば`10`で始まるコラッツ数列は以下です。"

#. type: Plain text
#: text/chapter11.md:350
#, no-wrap
msgid ""
"     ```text\n"
"     10, 5, 16, 8, 4, 2, 1, ...\n"
"     ```\n"
msgstr ""
"     ```text\n"
"     10, 5, 16, 8, 4, 2, 1, ...\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:352
#, no-wrap
msgid "     It is conjectured that the iterated Collatz sequence always reaches `1` after some finite number of applications of the Collatz function.\n"
msgstr "     コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的に `1`になるということが予想されています。\n"

#. type: Plain text
#: text/chapter11.md:354
#, no-wrap
msgid "     Write a function that uses recursion to calculate how many iterations of the Collatz function are required before the sequence reaches `1`.\n"
msgstr "     再帰を使い、数列が`1`に到達するまでに何回のコラッツ関数の適用が必要かを計算する関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:356
#, no-wrap
msgid "     Modify your function to use the `Writer` monad to log each application of the Collatz function.\n"
msgstr "     `Writer`モナドを使用してコラッツ関数の各適用の経過を記録するように、関数を変更してください。\n"

#. type: Title ##
#: text/chapter11.md:357
#, no-wrap
msgid "Monad Transformers"
msgstr "モナド変換子"

#. type: Plain text
#: text/chapter11.md:360
msgid ""
"Each of the three monads above: `State`, `Reader`, and `Writer`, are also "
"examples of so-called _monad transformers_. The equivalent monad "
"transformers are called `StateT`, `ReaderT`, and `WriterT`, respectively."
msgstr ""
"上の3つのモナド、`State`、`Reader`、`Writer`は、何れもいわゆる*モナド変換子*"
"の例となっています。\n"
"対応する各モナド変換子はそれぞれ`StateT`、`ReaderT`、`WriterT`という名前で"
"す。"

#. type: Plain text
#: text/chapter11.md:362
msgid ""
"What is a monad transformer? Well, as we have seen, a monad augments "
"PureScript code with some type of side effect, which can be interpreted in "
"PureScript by using the appropriate handler (`runState`, `runReader`, "
"`runWriter`, etc.) This is fine if we only need to use _one_ side-effect. "
"However, it is often useful to use more than one side-effect at once. For "
"example, we might want to use `Reader` together with `Maybe` to express "
"_optional results_ in the context of some global configuration. Or we might "
"want the mutable state provided by the `State` monad together with the pure "
"error tracking capability of the `Either` monad. This is the problem solved "
"by _monad transformers_."
msgstr ""
"モナド変換子とは何でしょうか。\n"
"さて、これまで見てきたように、モナドはPureScriptのコードを何らかの種類の副作"
"用で拡張するものでした。\n"
"このモナドはPureScriptで適切な制御子（`runState`、 `runReader`、`runWriter`な"
"ど）を使って解釈できます。\n"
"使用する必要がある副作用が*1つだけ*なら、これで問題ありません。\n"
"しかし、同時に複数の副作用を使用できると便利なことがよくあります。\n"
"例えば、 `Maybe`と`Reader`を一緒に使用すると、ある大域的な設定の文脈で*省略可"
"能な結果*を表現できます。\n"
"もしくは、 `Either`モナドの純粋なエラー追跡機能と、 `State`モナドが提供する変"
"更可能な状態が同時に欲しくなるかもしれません。\n"
"この問題を解決するのが*モナド変換子*です。"

#. type: Plain text
#: text/chapter11.md:364
msgid ""
"Note that we have already seen that the `Effect` monad partially solves this "
"problem. Monad transformers provide another solution, and each approach has "
"its own benefits and limitations."
msgstr ""
"ただし`Effect`モナドがこの問題を部分的に解決することは既に見ました。\n"
"モナド変換子はまた違った解決策を提供しますが、これらの各手法には利点と制約が"
"あります。"

#. type: Plain text
#: text/chapter11.md:366
msgid ""
"A monad transformer is a type constructor parameterized by a type and "
"another type constructor. It takes one monad and turns it into another "
"monad, adding its own variety of side-effects."
msgstr ""
"モナド変換子は型と別の型構築子を引数に取る型構築子です。\n"
"モナドを1つ取り、独自の様々な副作用を追加した別のモナドへと変換します。"

#. type: Plain text
#: text/chapter11.md:368
msgid ""
"Let's see an example. The monad transformer version of the `State` monad is "
"`StateT`, defined in the `Control.Monad.State.Trans` module. We can find the "
"kind of `StateT` using PSCi:"
msgstr ""
"例を見てみましょう。`State`のモナド変換子版は`Control.Monad.State.Trans`モ"
"ジュールで定義されている`StateT`です。\n"
"PSCiを使って `StateT`の種を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:369
#, no-wrap
msgid ""
"> import Control.Monad.State.Trans\n"
"> :kind StateT\n"
"Type -> (Type -> Type) -> Type -> Type\n"
msgstr ""
"> import Control.Monad.State.Trans\n"
"> :kind StateT\n"
"Type -> (Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:376
msgid ""
"This looks quite confusing, but we can apply `StateT` one argument at a time "
"to understand how to use it."
msgstr ""
"とても読みにくそうに見えるかもしれませんが、使い方を理解するために、`StateT`"
"に1つ引数を与えてみましょう。"

#. type: Plain text
#: text/chapter11.md:378
msgid ""
"The first type argument is the type of the state we wish to use, as was the "
"case for `State`. Let's use a state of type `String`:"
msgstr ""
"`State`の場合、最初の型引数は使いたい状態の型です。\n"
"それでは型`String`を与えてみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:379
#, no-wrap
msgid ""
"> :kind StateT String\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""
"> :kind StateT String\n"
"(Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:385
#, no-wrap
msgid "The next argument is a type constructor of kind `Type -> Type`. It represents the underlying monad, which we want to add the effects of `StateT` to. For the sake of an example, let's choose the `Either String` monad:\n"
msgstr ""
"次の引数は種 `Type -> Type`の型構築子です。\n"
"これは `StateT`の機能を追加したい元のモナドを表します。\n"
"例として、 `Either String`モナドを選んでみます。\n"

#. type: Fenced code block (text)
#: text/chapter11.md:386
#, no-wrap
msgid ""
"> :kind StateT String (Either String)\n"
"Type -> Type\n"
msgstr ""
"> :kind StateT String (Either String)\n"
"Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:392
msgid ""
"We are left with a type constructor. The final argument represents the "
"return type, and we might instantiate it to `Number` for example:"
msgstr ""
"型構築子が残りました。\n"
"最後の引数は戻り値の型を表しており、例えばそれを`Number`にできます。"

#. type: Fenced code block (text)
#: text/chapter11.md:393
#, no-wrap
msgid ""
"> :kind StateT String (Either String) Number\n"
"Type\n"
msgstr ""
"> :kind StateT String (Either String) Number\n"
"Type\n"

#. type: Plain text
#: text/chapter11.md:399
msgid ""
"Finally, we are left with something of kind `Type`, which means we can try "
"to find values of this type."
msgstr ""
"最後に種`Type`の何かが残りました。\n"
"つまりこの型の値を探してみることができます。"

#. type: Plain text
#: text/chapter11.md:401
msgid ""
"The monad we have constructed – `StateT String (Either String)` – represents "
"computations that can fail with an error and use mutable state."
msgstr ""
"構築したモナド`StateT String (Either String)`は、エラーで失敗する可能性があ"
"り、変更可能な状態を使える計算を表しています。"

#. type: Plain text
#: text/chapter11.md:403
msgid ""
"We can use the actions of the outer `StateT String` monad (`get`, `put`, and "
"`modify`) directly, but to use the effects of the wrapped monad (`Either "
"String`), we need to \"lift\" them over the monad transformer. The `Control."
"Monad.Trans` module defines the `MonadTrans` type class, which captures "
"those type constructors which are monad transformers, as follows:"
msgstr ""
"外側の`StateT String`モナドの動作（`get`、`put`、`modify`）は直接使えますが、"
"梱包されているモナド (`Either String`) の作用を使うためには、これらの関数をモ"
"ナド変換子まで「持ち上げ」る必要があります。\n"
"`Control.Monad.Trans`モジュールは`MonadTrans`型クラスを定義しています。\n"
"これはモナド変換子であるそうした型構築子を捕捉します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:404
#, no-wrap
msgid ""
"class MonadTrans t where\n"
"  lift :: forall m a. Monad m => m a -> t m a\n"
msgstr ""
"class MonadTrans t where\n"
"  lift :: forall m a. Monad m => m a -> t m a\n"

#. type: Plain text
#: text/chapter11.md:410
msgid ""
"This class contains a single member, `lift`, which takes computations in any "
"underlying monad `m` and lifts them into the wrapped monad `t m`. In our "
"case, the type constructor `t` is `StateT String`, `m` is the `Either "
"String` monad, so `lift` provides a way to lift computations of type `Either "
"String a` to computations of type `StateT String (Either String) a`. This "
"means that we can use the effects of `StateT String` and `Either String` "
"side-by-side, as long as we use `lift` every time we use a computation of "
"type `Either String a`."
msgstr ""
"このクラスは単一のメンバー`lift`を含みます。\n"
"これは通底する任意のモナド`m`の計算を取り、梱包されたモナド`t m`へと持ち上げ"
"るものです。\n"
"今回の場合、型構築子`t`は`StateT String`で、`m`は`Either String`モナドとなる"
"ので、`lift`は型`Either String a`の計算を、型`StateT String (Either String) "
"a`の計算へと持ち上げる方法を提供することになります。\n"
"つまり、型`Either String a`の計算を使う場合に毎回`lift`を使うのであれば、"
"`StateT String`と`Either String`の作用を使えます。"

#. type: Plain text
#: text/chapter11.md:412
msgid ""
"For example, the following computation reads the underlying state and then "
"throws an error if the state is the empty string:"
msgstr ""
"例えば、次の計算は通底する状態を読み、状態が空文字列であればエラーを投げま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:413
#, no-wrap
msgid ""
"import Data.String (drop, take)\n"
"\n"
"split :: StateT String (Either String) String\n"
"split = do\n"
"  s <- get\n"
"  case s of\n"
"    \"\" -> lift $ Left \"Empty string\"\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""
"import Data.String (drop, take)\n"
"\n"
"split :: StateT String (Either String) String\n"
"split = do\n"
"  s <- get\n"
"  case s of\n"
"    \"\" -> lift $ Left \"Empty string\"\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"

#. type: Plain text
#: text/chapter11.md:427
msgid ""
"If the state is not empty, the computation uses `put` to update the state to "
"`drop 1 s` (that is, `s` with the first character removed) and returns `take "
"1 s` (that is, the first character of `s`)."
msgstr ""
"状態が空でなければ、この計算は`put`を使って状態を`drop 1 s`（つまり`s`から最"
"初の文字を取り除いたもの）へと更新し、`take 1 s`（`s`の最初の文字）を返しま"
"す。"

#. type: Plain text
#: text/chapter11.md:429
msgid "Let's try this in PSCi:"
msgstr "それではPSCiでこれを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:430
#, no-wrap
msgid ""
"> runStateT split \"test\"\n"
"Right (Tuple \"t\" \"est\")\n"
"\n"
"> runStateT split \"\"\n"
"Left \"Empty string\"\n"
msgstr ""
"> runStateT split \"test\"\n"
"Right (Tuple \"t\" \"est\")\n"
"\n"
"> runStateT split \"\"\n"
"Left \"Empty string\"\n"

#. type: Plain text
#: text/chapter11.md:439
msgid ""
"This is not very remarkable since we could have implemented this without "
"`StateT`. However, since we are working in a monad, we can use do notation "
"or applicative combinators to build larger computations from smaller ones. "
"For example, we can apply `split` twice to read the first two characters "
"from a string:"
msgstr ""
"これは`StateT`を使わなくても実装できるので、さほど驚くようなことはありませ"
"ん。\n"
"しかし、モナドの中で扱っているので、do記法やアプリカティブコンビネータを使っ"
"て、小さな計算から大きな計算を構築できます。\n"
"例えば、2回`split`を適用すると、文字列から最初の2文字を読めます。"

#. type: Fenced code block (text)
#: text/chapter11.md:440
#, no-wrap
msgid ""
"> runStateT ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple \"te\" \"st\"))\n"
msgstr ""
"> runStateT ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple \"te\" \"st\"))\n"

#. type: Plain text
#: text/chapter11.md:446
msgid ""
"We can use the `split` function with a handful of other actions to build a "
"basic parsing library. In fact, this is the approach taken by the `parsing` "
"library. This is the power of monad transformers – we can create custom-"
"built monads for various problems, choose the side-effects we need, and keep "
"the expressiveness of do notation and applicative combinators."
msgstr ""
"`split`関数とその他沢山の動作を使えば基本的な構文解析ライブラリを構築できま"
"す。\n"
"実際、これは`parsing`ライブラリで採用されている手法です。\n"
"これがモナド変換子の力なのです。\n"
"必要な副作用を選択し、do記法とアプリカティブコンビネータで表現力を維持しなが"
"ら、様々な問題のための特注のモナドを作成できるのです。"

#. type: Title ##
#: text/chapter11.md:447
#, no-wrap
msgid "The ExceptT Monad Transformer"
msgstr "ExceptTモナド変換子"

#. type: Plain text
#: text/chapter11.md:450
msgid ""
"The `transformers` package also defines the `ExceptT e` monad transformer, "
"corresponding to the `Either e` monad. It provides the following API:"
msgstr ""
"`transformers`パッケージでは`ExceptT e`モナド変換子も定義されています。\n"
"これは`Either e`モナドに対応するもので、以下のAPIを提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:451
#, no-wrap
msgid ""
"class MonadError e m where\n"
"  throwError :: forall a. e -> m a\n"
"  catchError :: forall a. m a -> (e -> m a) -> m a\n"
"\n"
"instance Monad m => MonadError e (ExceptT e m)\n"
"\n"
"runExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\n"
msgstr ""
"class MonadError e m where\n"
"  throwError :: forall a. e -> m a\n"
"  catchError :: forall a. m a -> (e -> m a) -> m a\n"
"\n"
"instance Monad m => MonadError e (ExceptT e m)\n"
"\n"
"runExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\n"

#. type: Plain text
#: text/chapter11.md:462
msgid ""
"The `MonadError` class captures those monads that support throwing and "
"catching errors of some type `e`, and an instance is provided for the "
"`ExceptT e` monad transformer. The `throwError` action can indicate failure, "
"like `Left` in the `Either e` monad. The `catchError` action allows us to "
"continue after an error is thrown using `throwError`."
msgstr ""
"`MonadError`クラスは`e`型のエラーを投げたり捕えたりに対応するモナドを捕捉し、"
"`ExceptT e`モナド変換子のインスタンスが提供されます。\n"
"`Either e`モナドの`Left`と同じように、`throwError`動作では失敗を示せます。\n"
"`catchError`動作では`throwError`を使ってエラーが投げられた後に処理を継続でき"
"ます。"

#. type: Plain text
#: text/chapter11.md:464
msgid ""
"The `runExceptT` handler is used to run a computation of type `ExceptT e m "
"a`."
msgstr "`runExceptT`制御子を使うと、型 `ExceptT e m a`を計算できます。"

#. type: Plain text
#: text/chapter11.md:466
msgid ""
"This API is similar to that provided by the `exceptions` package and the "
"`Exception` effect. However, there are some important differences:"
msgstr ""
"このAPIは `exceptions`パッケージの `Exception`作用によって提供されているもの"
"と似ています。\n"
"しかし、幾つかの重要な違いがあります。"

#. type: Bullet: '- '
#: text/chapter11.md:469
msgid ""
"`Exception` uses actual JavaScript exceptions, whereas `ExceptT` models "
"errors as a pure data structure."
msgstr ""
"`Exception`が実際のJavaScriptの例外を使っているのに対して`ExceptT`モデルは代"
"数的データ型を使っています。"

#. type: Bullet: '- '
#: text/chapter11.md:469
msgid ""
"The `Exception` effect only supports exceptions of one type, namely "
"JavaScript's `Error` type, whereas `ExceptT` supports errors of any type. In "
"particular, we are free to define new error types."
msgstr ""
"`Exception`作用がJavaScriptの`Error`型という1つの例外の型だけを扱うのに対し"
"て、`ExceptT`は`Error`型クラスのどんな型のエラーでも扱います。つまり、 "
"`ExceptT`では新たなエラー型を自由に定義できます。"

#. type: Plain text
#: text/chapter11.md:471
msgid ""
"Let's try out `ExceptT` by using it to wrap the `Writer` monad. Again, we "
"are free to use actions from the monad transformer `ExceptT e` directly, but "
"computations in the `Writer` monad should be lifted using `lift`:"
msgstr ""
"試しに`ExceptT`を使って`Writer`モナドを包んでみましょう。\n"
"ここでもモナド変換子`ExceptT e`の動作を直接使うことも自由にできますが、"
"`Writer`モナドの計算は`lift`を使って持ち上げるべきです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:472
#, no-wrap
msgid ""
"import Control.Monad.Except\n"
"import Control.Monad.Writer\n"
"\n"
"writerAndExceptT :: ExceptT String (Writer (Array String)) String\n"
"writerAndExceptT = do\n"
"  lift $ tell [\"Before the error\"]\n"
"  _ <- throwError \"Error!\"\n"
"  lift $ tell [\"After the error\"]\n"
"  pure \"Return value\"\n"
msgstr ""
"import Control.Monad.Except\n"
"import Control.Monad.Writer\n"
"\n"
"writerAndExceptT :: ExceptT String (Writer (Array String)) String\n"
"writerAndExceptT = do\n"
"  lift $ tell [\"Before the error\"]\n"
"  _ <- throwError \"Error!\"\n"
"  lift $ tell [\"After the error\"]\n"
"  pure \"Return value\"\n"

#. type: Plain text
#: text/chapter11.md:485
msgid ""
"If we test this function in PSCi, we can see how the two effects of "
"accumulating a log and throwing an error interact. First, we can run the "
"outer `ExceptT` computation of type by using `runExceptT`, leaving a result "
"of type `Writer (Array String) (Either String String)`. We can then use "
"`runWriter` to run the inner `Writer` computation:"
msgstr ""
"PSCiでこの関数を試すと、ログの蓄積とエラーの送出という2つの作用がどのように相"
"互作用しているのかを見ることができます。\n"
"まず、 `runExceptT`を使って外側の`ExceptT`を計算し、型 `Writer (Array "
"String) (Either String String)`の結果を残します。\n"
"それから、 `runWriter`で内側の`Writer`を計算します。"

#. type: Fenced code block (text)
#: text/chapter11.md:486
#, no-wrap
msgid ""
"> runWriter $ runExceptT writerAndExceptT\n"
"Tuple (Left \"Error!\") [\"Before the error\"]\n"
msgstr ""
"> runWriter $ runExceptT writerAndExceptT\n"
"Tuple (Left \"Error!\") [\"Before the error\"]\n"

#. type: Plain text
#: text/chapter11.md:492
msgid ""
"Note that only those log messages that were written before the error was "
"thrown get appended to the log."
msgstr ""
"なお、エラーが投げられる前に書き出されるログ文言だけがログに追記されます。"

#. type: Title ##
#: text/chapter11.md:493
#, no-wrap
msgid "Monad Transformer Stacks"
msgstr "モナド変換子スタック"

#. type: Plain text
#: text/chapter11.md:496
msgid ""
"As we have seen, monad transformers can be used to build new monads on top "
"of existing monads. For some monad transformer `t1` and some monad `m`, the "
"application `t1 m` is also a monad. That means we can apply a _second_ monad "
"transformer `t2` to the result `t1 m` to construct a third monad `t2 (t1 "
"m)`. In this way, we can construct a _stack_ of monad transformers, which "
"combine the side-effects provided by their constituent monads."
msgstr ""
"これまで見てきたように、モナド変換子を使って既存のモナドを土台に新しいモナド"
"を構築できます。\n"
"何かのモナド変換子`t1`とモナド`m`について、その適用`t1 m`もまたモナドになりま"
"す。\n"
"つまり、*2つめの*モナド変換子`t2`を結果`t1 m`に適用すると、3つ目のモナド`t2 "
"(t1 m)`を作れます。\n"
"このようにしてモナド変換子の*スタック*を構築できます。\n"
"これは構成されるモナドによって提供される副作用を組み合わせるものです。"

#. type: Plain text
#: text/chapter11.md:498
msgid ""
"In practice, the underlying monad `m` is either the `Effect` monad, if "
"native side-effects are required, or the `Identity` monad, defined in the "
"`Data.Identity` module. The `Identity` monad adds no new side-effects, so "
"transforming the `Identity` monad only provides the effects of the monad "
"transformer. The `State`, `Reader`, and `Writer` monads are implemented by "
"transforming the `Identity` monad with `StateT`, `ReaderT`, and `WriterT`, "
"respectively."
msgstr ""
"実際には、通底するモナド`m`は、ネイティブの副作用が必要なら`Effect`モナド、さ"
"もなくば`Data.Identity`モジュールで定義されている`Identity`モナドになりま"
"す。\n"
"`Identity`モナドは何の新しい副作用も追加しませんから、`Identity`モナドの変換"
"はモナド変換子の作用だけを提供します。\n"
"`State`、`Reader`、`Writer`モナドは、`Identity`モナドをそれぞれ`StateT`、"
"`ReaderT`、`WriterT`で変換することによって実装されています。"

#. type: Plain text
#: text/chapter11.md:500
msgid ""
"Let's see an example in which three side effects are combined. We will use "
"the `StateT`, `WriterT`, and `ExceptT` effects, with the `Identity` monad on "
"the bottom of the stack. This monad transformer stack will provide the side "
"effects of mutable state, accumulating a log, and pure errors."
msgstr ""
"3つの副作用が組み合わっている例を見てみましょう。\n"
"`Identity`モナドをスタックの底にして、`StateT`、`WriterT`、`ExceptT`作用を使"
"います。\n"
"このモナド変換子スタックは、可変状態、ログの蓄積、そして純粋なエラーの副作用"
"を提供します。"

#. type: Plain text
#: text/chapter11.md:502
msgid ""
"We can use this monad transformer stack to reproduce our `split` action with "
"the added feature of logging."
msgstr ""
"このモナド変換子スタックを使うと、ロギングの機能が追加された `split`アクショ"
"ンに作り変えられます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:503
#, no-wrap
msgid ""
"type Errors = Array String\n"
"\n"
"type Log = Array String\n"
"\n"
"type Parser = StateT String (WriterT Log (ExceptT Errors Identity))\n"
"\n"
"split :: Parser String\n"
"split = do\n"
"  s <- get\n"
"  lift $ tell [\"The state is \" <> s]\n"
"  case s of\n"
"    \"\" -> lift $ lift $ throwError [\"Empty string\"]\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""
"type Errors = Array String\n"
"\n"
"type Log = Array String\n"
"\n"
"type Parser = StateT String (WriterT Log (ExceptT Errors Identity))\n"
"\n"
"split :: Parser String\n"
"split = do\n"
"  s <- get\n"
"  lift $ tell [\"The state is \" <> s]\n"
"  case s of\n"
"    \"\" -> lift $ lift $ throwError [\"Empty string\"]\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"

#. type: Plain text
#: text/chapter11.md:522
msgid ""
"If we test this computation in PSCi, we see that the state is appended to "
"the log for every invocation of `split`."
msgstr ""
"この計算をPSCiで試してみると、 `split`が実行されるたびに状態がログに追加され"
"ることがわかります。"

#. type: Plain text
#: text/chapter11.md:524
msgid ""
"Note that we have to remove the side-effects in the order in which they "
"appear in the monad transformer stack: first, we use `runStateT` to remove "
"the `StateT` type constructor, then `runWriterT`, then `runExceptT`. "
"Finally, we run the computation in the `Identity` monad by using `unwrap`."
msgstr ""
"なお、モナド変換子スタックに現れる順序で副作用を取り除いていかなければなりま"
"せん。\n"
"最初に`StateT`型構築子を取り除くために`runStateT`を、それから`runtWriteT`、"
"`runExceptT`を使います。\n"
"最後に`unwrap`を使用して`Identity`モナド中で計算します。"

#. type: Fenced code block (text)
#: text/chapter11.md:525
#, no-wrap
msgid ""
"> runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s\n"
"\n"
"> runParser split \"test\"\n"
"(Right (Tuple (Tuple \"t\" \"est\") [\"The state is test\"]))\n"
"\n"
"> runParser ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple (Tuple \"te\" \"st\") [\"The state is test\", \"The state is est\"]))\n"
msgstr ""
"> runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s\n"
"\n"
"> runParser split \"test\"\n"
"(Right (Tuple (Tuple \"t\" \"est\") [\"The state is test\"]))\n"
"\n"
"> runParser ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple (Tuple \"te\" \"st\") [\"The state is test\", \"The state is est\"]))\n"

#. type: Plain text
#: text/chapter11.md:536
msgid ""
"However, if the parse is unsuccessful because the state is empty, then no "
"log is printed at all:"
msgstr ""
"しかし、状態が空であることが理由で解析が失敗した場合、ログは全く出力されませ"
"ん。"

#. type: Fenced code block (text)
#: text/chapter11.md:537
#, no-wrap
msgid ""
"> runParser split \"\"\n"
"(Left [\"Empty string\"])\n"
msgstr ""
"> runParser split \"\"\n"
"(Left [\"Empty string\"])\n"

#. type: Plain text
#: text/chapter11.md:543
msgid ""
"This is because of how the side-effects provided by the `ExceptT` monad "
"transformer interact with the side-effects provided by the `WriterT` monad "
"transformer. We can address this by changing the order in which the monad "
"transformer stack is composed. If we move the `ExceptT` transformer to the "
"top of the stack, then the log will contain all messages written up until "
"the first error, as we saw earlier when we transformed `Writer` with "
"`ExceptT`."
msgstr ""
"これは、`ExceptT`モナド変換子が提供する副作用と`WriterT`モナド変換子が提供す"
"る副作用との関係によるものです。\n"
"これはモナド変換子スタックが構成されている順序を変更することで対処できま"
"す。\n"
"スタックの最上部に`ExceptT`変換子を移動すると、先ほど`Writer`を`ExceptT`に変"
"換したときに見たように、最初のエラーまでに書かれた全ての文言がログに含まれる"
"ようになります。"

#. type: Plain text
#: text/chapter11.md:545
msgid ""
"One problem with this code is that we have to use the `lift` function "
"multiple times to lift computations over multiple monad transformers; for "
"example, the call to `throwError` has to be lifted twice, once over "
"`WriterT` and a second time over `StateT`. This is fine for small monad "
"transformer stacks but quickly becomes inconvenient."
msgstr ""
"このコードの問題の1つは、複数のモナド変換子の上まで計算を持ち上げるために、"
"`lift`関数を複数回使わなければならないということです。\n"
"例えば`throwError`の呼び出しは、1回目は`WriteT`へ、2回目は`StateT`へ、と2回持"
"ちあげなければなりません。\n"
"小さなモナド変換子スタックならなんとかなりますが、そのうちすぐに不便になるで"
"しょう。"

#. type: Plain text
#: text/chapter11.md:547
msgid ""
"Fortunately, as we will see, we can use the automatic code generation "
"provided by type class inference to do most of this \"heavy lifting\" for us."
msgstr ""
"幸いなことに、これから見るような型クラス推論によって提供されるコードの自動生"
"成を使うと、ほとんどの「重労働」を任せられます。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:552
msgid ""
"(Easy) Use the `ExceptT` monad transformer over the `Identity` functor to "
"write a function `safeDivide` which divides two numbers, throwing an error "
"(as the String \"Divide by zero!\") if the denominator is zero."
msgstr ""
"（簡単）`Identity`関手を土台とする`ExceptT`モナド変換子を使って、2つの数の商"
"を求める関数 `safeDivide`を書いてください。\n"
"この関数は分母がゼロの場合に（文字列「Divide by zero!」の）エラーを投げます。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:552
msgid "(Medium) Write a parser"
msgstr "（普通）次のような構文解析関数を書いてください。"

#. type: Plain text
#: text/chapter11.md:556
#, no-wrap
msgid ""
"     ```haskell\n"
"     string :: String -> Parser String\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     string :: String -> Parser String\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:558
#, no-wrap
msgid "     which matches a string as a prefix of the current state or fails with an error message.\n"
msgstr "     これは現在の状態が接頭辞に照合するか、もしくはエラー文言とともに失敗します。\n"

#. type: Plain text
#: text/chapter11.md:560
#, no-wrap
msgid "     Your parser should work as follows:\n"
msgstr "     この構文解析器は次のように動作します。\n"

#. type: Plain text
#: text/chapter11.md:565
#, no-wrap
msgid ""
"     ```text\n"
"     > runParser (string \"abc\") \"abcdef\"\n"
"     (Right (Tuple (Tuple \"abc\" \"def\") [\"The state is abcdef\"]))\n"
"     ```\n"
msgstr ""
"     ```text\n"
"     > runParser (string \"abc\") \"abcdef\"\n"
"     (Right (Tuple (Tuple \"abc\" \"def\") [\"The state is abcdef\"]))\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:568
#, no-wrap
msgid ""
"     _Hint_: you can use the implementation of `split` as a starting point. You might find the `stripPrefix` function useful.\n"
" 1. (Difficult) Use the `ReaderT` and `WriterT` monad transformers to reimplement the document printing library, which we wrote earlier using the `Reader` monad.\n"
msgstr ""
"     *手掛かり*：出発点として`split`の実装が使えます。\n"
"     `stripPrefix`関数も役に立つかもしれません。\n"
"1. （難しい）文書表示ライブラリを、`ReaderT`と`WriterT`モナド変換子を使用して再実装してください。\n"
"   以前`Reader`モナドを使用して書いたものです。\n"

#. type: Plain text
#: text/chapter11.md:570
#, no-wrap
msgid "     Instead of using `line` to emit strings and `cat` to concatenate strings, use the `Array String` monoid with the `WriterT` monad transformer, and `tell` to append a line to the result. Use the same names as in the original implementation but ending with an apostrophe (`'`).\n"
msgstr ""
"     文字列を出力する `line`や文字列を連結する `cat`を使うのではなく、`WriteT`モナド変換子と一緒に `Array String`モノイドを使い、結果へ行を追加するのに `tell`を使ってください。\n"
"     アポストロフィ (`'`) を付ける以外は元の実装と同じ名前を使ってください。\n"

# もしかして：アカリがやってきたぞっ
#. type: Title ##
#: text/chapter11.md:571
#, no-wrap
msgid "Type Classes to the Rescue!"
msgstr "型クラスが助けに来たぞっ"

#. type: Plain text
#: text/chapter11.md:574
msgid ""
"When we looked at the `State` monad at the start of this chapter, I gave the "
"following types for the actions of the `State` monad:"
msgstr ""
"本章の最初で扱った `State`モナドを見てみると、 `State`モナドの動作には次のよ"
"うな型が与えられていました。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:575
#, no-wrap
msgid ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"
msgstr ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"

#. type: Plain text
#: text/chapter11.md:582
msgid ""
"In reality, the types given in the `Control.Monad.State.Class` module are "
"more general than this:"
msgstr ""
"`Control.Monad.State.Class`モジュールで与えられている型は、実際にはこれより"
"もっと一般的です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:583
#, no-wrap
msgid ""
"get    :: forall m s. MonadState s m =>             m s\n"
"put    :: forall m s. MonadState s m => s        -> m Unit\n"
"modify :: forall m s. MonadState s m => (s -> s) -> m Unit\n"
msgstr ""
"get    :: forall m s. MonadState s m =>             m s\n"
"put    :: forall m s. MonadState s m => s        -> m Unit\n"
"modify :: forall m s. MonadState s m => (s -> s) -> m Unit\n"

#. type: Plain text
#: text/chapter11.md:590
msgid ""
"The `Control.Monad.State.Class` module defines the `MonadState` (multi-"
"parameter) type class, which allows us to abstract over \"monads which "
"support pure mutable state\". As one would expect, the `State s` type "
"constructor is an instance of the `MonadState s` type class, but there are "
"many more interesting instances of this class."
msgstr ""
"`Control.Monad.State.Class`モジュールには`MonadState`（多変数）型クラスが定義"
"されています。\n"
"この型クラスは「変更可能な状態を提供する純粋なモナド」への抽象化を可能にしま"
"す。\n"
"予想できると思いますが、 `State s`型構築子は `MonadState s`型クラスのインスタ"
"ンスになっており、このクラスには他にも興味深いインスタンスが数多くあります。"

#. type: Plain text
#: text/chapter11.md:592
msgid ""
"In particular, there are instances of `MonadState` for the `WriterT`, "
"`ReaderT`, and `ExceptT` monad transformers provided in the `transformers` "
"package. Each has an instance for `MonadState` whenever the underlying "
"`Monad` does. In practice, this means that as long as `StateT` appears "
"_somewhere_ in the monad transformer stack, and everything above `StateT` is "
"an instance of `MonadState`, then we are free to use `get`, `put`, and "
"`modify` directly without the need to use `lift`."
msgstr ""
"特に、`transformers`パッケージではモナド変換子`WriterT`、`ReaderT`、`ExceptT`"
"についての`MonadState`のインスタンスがあります。\n"
"通底する`Monad`が`MonadState`インスタンスを持つなら常に、これらもインスタンス"
"を持ちます。\n"
"つまり実際には、`StateT`がモナド変換子スタックの*どこか*に現れ、`StateT`より"
"上の全てが`MonadState`のインスタンスであれば、`lift`を使う必要なく`get`や"
"`put`や`modify`を直接自由に使用できます。"

#. type: Plain text
#: text/chapter11.md:594
msgid ""
"Indeed, the same is true of the actions we covered for the `ReaderT`, "
"`WriterT`, and `ExceptT` transformers. `transformers` defines a type class "
"for each of the major transformers, allowing us to abstract over monads that "
"support their operations."
msgstr ""
"当然ですが、これまで扱ってきた`ReaderT`、`WriterT`、`ExceptT`変換子について"
"も、同じことが言えます。\n"
"`transformers`では主な各変換子について型クラスが定義されています。\n"
"これによりそれらの操作に対応するモナドの上に抽象化できるのです。"

#. type: Plain text
#: text/chapter11.md:596
msgid ""
"In the case of the `split` function above, the monad stack we constructed is "
"an instance of each of the `MonadState`, `MonadWriter`, and `MonadError` "
"type classes. This means that we don't need to call `lift` at all! We can "
"just use the actions `get`, `put`, `tell`, and `throwError` as if they were "
"defined on the monad stack itself:"
msgstr ""
"上の`split`関数の場合、構築したモナドスタックは各型クラス`MonadState`、"
"`MonadWriter`、`MonadError`のインスタンスです。\n"
"つまり`lift`は全く呼び出す必要がないのです。\n"
"まるでモナドスタック自体に定義されていたかのように、動作`get`、`put`、"
"`tell`、`throwError`をそのまま使用できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:597
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:split}}\n"
msgstr "{{#include ../exercises/chapter11/src/Split.purs:split}}\n"

#. type: Plain text
#: text/chapter11.md:602
msgid ""
"This computation looks like we have extended our programming language to "
"support the three new side-effects of mutable state, logging, and error "
"handling. However, everything is still implemented using pure functions and "
"immutable data under the hood."
msgstr ""
"この計算は、独自のプログラミング言語を拡張し、可変状態、ロギング、エラー処理"
"という3つの新しい副作用に対応したように見えます。\n"
"しかし、内部的には全てはあくまで純粋な関数と不変のデータを使って実装されてい"
"るのです。"

#. type: Title ##
#: text/chapter11.md:603
#, no-wrap
msgid "Alternatives"
msgstr "代替"

#. type: Plain text
#: text/chapter11.md:606
msgid ""
"The `control` package defines a number of abstractions for working with "
"computations that can fail. One of these is the `Alternative` type class:"
msgstr ""
"`control`パッケージでは失敗しうる計算を扱う抽象化が数多く定義されています。\n"
"その1つは`Alternative`型クラスです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:607
#, no-wrap
msgid ""
"class Functor f <= Alt f where\n"
"  alt :: forall a. f a -> f a -> f a\n"
"\n"
"class Alt f <= Plus f where\n"
"  empty :: forall a. f a\n"
"\n"
"class (Applicative f, Plus f) <= Alternative f\n"
msgstr ""
"class Functor f <= Alt f where\n"
"  alt :: forall a. f a -> f a -> f a\n"
"\n"
"class Alt f <= Plus f where\n"
"  empty :: forall a. f a\n"
"\n"
"class (Applicative f, Plus f) <= Alternative f\n"

#. type: Plain text
#: text/chapter11.md:618
#, no-wrap
msgid "`Alternative` provides two new combinators: the `empty` value, which provides a prototype for a failing computation, and the `alt` function (and its alias, `<|>`), which provides the ability to fall back to an _alternative_ computation in the case of an error.\n"
msgstr ""
"`Alternative`は2つの新しいコンビネータを提供しています。\n"
"1つは失敗しうる計算の雛形を提供する`empty`値で、もう1つはエラーが起きたときに*代替の*計算へ戻ってやり直す機能を提供する`alt`関数（そしてその別名`<|>`）です。\n"

#. type: Plain text
#: text/chapter11.md:620
msgid ""
"The `Data.Array` module provides two useful functions for working with type "
"constructors in the `Alternative` type class:"
msgstr ""
"`Data.Array`モジュールでは `Alternative`型クラスで型構築子を操作する2\n"
"つの便利な関数を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:621
#, no-wrap
msgid ""
"many :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
"some :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
msgstr ""
"many :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
"some :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"

#. type: Plain text
#: text/chapter11.md:627
msgid "There is also an equivalent `many` and `some` for `Data.List`"
msgstr "`Data.List`にも等価な`many`と`some`があります。"

#. type: Plain text
#: text/chapter11.md:629
msgid ""
"The `many` combinator uses the `Alternative` type class to repeatedly run a "
"computation _zero-or-more_ times. The `some` combinator is similar but "
"requires at least the first computation to succeed."
msgstr ""
"`many`コンビネータは計算を*ゼロ回以上*繰り返し実行するために`Alternative`型ク"
"ラスを使います。\n"
"`some`コンビネータも似ていますが、最低1回は計算が成功する必要があります。"

#. type: Plain text
#: text/chapter11.md:631
msgid ""
"In the case of our `Parser` monad transformer stack, there is an instance of "
"`Alternative` induced by the `ExceptT` component, which supports failure by "
"composing errors in different branches using a `Monoid` instance (this is "
"why we chose `Array String` for our `Errors` type). This means that we can "
"use the `many` and `some` functions to run a parser multiple times:"
msgstr ""
"`Parser`モナド変換子スタックの場合は、`ExceptT`コンポーネントによる"
"`Alternative`のインスタンスがあります。\n"
"このコンポーネントでは異なる分枝のエラーに`Monoid`インスタンスを使って組み合"
"わせることによって対応しています（だから`Errors`型に`Array String`を選ぶ必要"
"があったんですね）。\n"
"これは、構文解析器を複数回実行するのに`many`関数と`some`関数を使うことができ"
"ることを意味します。"

#. type: Fenced code block (text)
#: text/chapter11.md:632
#, no-wrap
msgid ""
"> import Data.Array (many)\n"
"\n"
"> runParser (many split) \"test\"\n"
"(Right (Tuple (Tuple [\"t\", \"e\", \"s\", \"t\"] \"\")\n"
"              [ \"The state is \\\"test\\\"\"\n"
"              , \"The state is \\\"est\\\"\"\n"
"              , \"The state is \\\"st\\\"\"\n"
"              , \"The state is \\\"t\\\"\"\n"
"              ]))\n"
msgstr ""
"> import Data.Array (many)\n"
"\n"
"> runParser (many split) \"test\"\n"
"(Right (Tuple (Tuple [\"t\", \"e\", \"s\", \"t\"] \"\")\n"
"              [ \"The state is \\\"test\\\"\"\n"
"              , \"The state is \\\"est\\\"\"\n"
"              , \"The state is \\\"st\\\"\"\n"
"              , \"The state is \\\"t\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:645
msgid ""
"Here, the input string `\"test\"` has been repeatedly split to return an "
"array of four single-character strings, the leftover state is empty, and the "
"log shows that we applied the `split` combinator four times."
msgstr ""
"ここでは入力文字列 `\"test\"`は、1文字からなる文字列4つの配列を返すように繰り"
"返し分割されています。\n"
"残った状態は空で、ログは `split`コンビネータが4回適用されたことを示していま"
"す。"

#. type: Title ##
#: text/chapter11.md:646
#, no-wrap
msgid "Monad Comprehensions"
msgstr "モナド内包表記"

#. type: Plain text
#: text/chapter11.md:649
msgid ""
"The `Control.MonadPlus` module defines a subclass of the `Alternative` type "
"class, called `MonadPlus`. `MonadPlus` captures those type constructors "
"which are both monads and instances of `Alternative`:"
msgstr ""
"`Control.MonadPlus`モジュールには `MonadPlus`と呼ばれる`Alternative`型クラス"
"の副クラスが定義されています。\n"
"`MonadPlus`はモナドと`Alternative`両方のインスタンスである型構築子を取りま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:650
#, no-wrap
msgid "class (Monad m, Alternative m) <= MonadPlus m\n"
msgstr "class (Monad m, Alternative m) <= MonadPlus m\n"

#. type: Plain text
#: text/chapter11.md:655
msgid "In particular, our `Parser` monad is an instance of `MonadPlus`."
msgstr "実際、`Parser`モナドは `MonadPlus`のインスタンスです。"

#. type: Plain text
#: text/chapter11.md:657
msgid ""
"When we covered array comprehensions earlier in the book, we introduced the "
"`guard` function, which could be used to filter out unwanted results. In "
"fact, the `guard` function is more general and can be used for any monad, "
"which is an instance of `MonadPlus`:"
msgstr ""
"以前本書中で配列内包表記を押さえたとき、`guard`関数を導入しました。\n"
"これは欲しくない結果を取り除けるのに使えました。\n"
"実際には`guard`関数はもっと一般的で、`MonadPlus`のインスタンスである任意のモ"
"ナドに対して使えます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:658
#, no-wrap
msgid "guard :: forall m. Alternative m => Boolean -> m Unit\n"
msgstr "guard :: forall m. Alternative m => Boolean -> m Unit\n"

#. type: Plain text
#: text/chapter11.md:663
#, no-wrap
msgid "The `<|>` operator allows us to backtrack in case of failure. To see how this is useful, let's define a variant of the `split` combinator which only matches upper case characters:\n"
msgstr ""
"`<|>`演算子は失敗時にバックトラッキングできるようにします。\n"
"これがどのように役立つかを見るために、大文字だけに照合する`split`コンビネータの亜種を定義してみましょう。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:664
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:upper}}\n"
msgstr "{{#include ../exercises/chapter11/src/Split.purs:upper}}\n"

#. type: Plain text
#: text/chapter11.md:669
msgid ""
"Here, we use a `guard` to fail if the string is not upper case. Note that "
"this code looks very similar to the array comprehensions we saw earlier – "
"using `MonadPlus` in this way, we sometimes refer to constructing _monad "
"comprehensions_."
msgstr ""
"ここで、文字列が大文字でない場合に失敗するよう、`guard`を使用しています。\n"
"なお、このコードは前に見た配列内包表記とよく似ています。\n"
"このように`MonadPlus`を使うことは、*モナド内包表記*の構築と呼ばれることがあり"
"ます。"

#. type: Title ##
#: text/chapter11.md:670
#, no-wrap
msgid "Backtracking"
msgstr "バックトラッキング"

#. type: Plain text
#: text/chapter11.md:673
#, no-wrap
msgid "We can use the `<|>` operator to backtrack to another alternative in case of failure. To demonstrate this, let's define one more parser, which matches lower case characters:\n"
msgstr ""
"`<|>`演算子を使うと、失敗したときに別の代替計算へとバックトラックできます。\n"
"これを確かめるために、小文字に一致するもう1つの構文解析器を定義してみましょう。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:674
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:lower}}\n"
msgstr "{{#include ../exercises/chapter11/src/Split.purs:lower}}\n"

#. type: Plain text
#: text/chapter11.md:679
msgid ""
"With this, we can define a parser which eagerly matches many upper case "
"characters if the first character is upper case, or many lower case "
"character if the first character is lower case:"
msgstr ""
"これにより、まずもし最初の文字が大文字なら複数の大文字に照合し、さもなくばも"
"し最初の文字が小文字なら複数の小文字に照合する、という構文解析器を定義できま"
"す。"

#. type: Fenced code block (text)
#: text/chapter11.md:680
#, no-wrap
msgid "> upperOrLower = some upper <|> some lower\n"
msgstr "> upperOrLower = some upper <|> some lower\n"

#. type: Plain text
#: text/chapter11.md:685
msgid "This parser will match characters until the case changes:"
msgstr ""
"この構文解析器は、大文字と小文字が切り替わるまで、文字に照合し続けます。"

#. type: Fenced code block (text)
#: text/chapter11.md:686
#, no-wrap
msgid ""
"> runParser upperOrLower \"abcDEF\"\n"
"(Right (Tuple (Tuple [\"a\",\"b\",\"c\"] (\"DEF\"))\n"
"              [ \"The state is \\\"abcDEF\\\"\"\n"
"              , \"The state is \\\"bcDEF\\\"\"\n"
"              , \"The state is \\\"cDEF\\\"\"\n"
"              ]))\n"
msgstr ""
"> runParser upperOrLower \"abcDEF\"\n"
"(Right (Tuple (Tuple [\"a\",\"b\",\"c\"] (\"DEF\"))\n"
"              [ \"The state is \\\"abcDEF\\\"\"\n"
"              , \"The state is \\\"bcDEF\\\"\"\n"
"              , \"The state is \\\"cDEF\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:696
msgid ""
"We can even use `many` to fully split a string into its lower and upper case "
"components:"
msgstr "また、`many`を使うと文字列を小文字と大文字の要素に完全に分割できます。"

#. type: Fenced code block (text)
#: text/chapter11.md:697
#, no-wrap
msgid ""
"> components = many upperOrLower\n"
"\n"
"> runParser components \"abCDeFgh\"\n"
"(Right (Tuple (Tuple [[\"a\",\"b\"],[\"C\",\"D\"],[\"e\"],[\"F\"],[\"g\",\"h\"]] \"\")\n"
"              [ \"The state is \\\"abCDeFgh\\\"\"\n"
"              , \"The state is \\\"bCDeFgh\\\"\"\n"
"              , \"The state is \\\"CDeFgh\\\"\"\n"
"              , \"The state is \\\"DeFgh\\\"\"\n"
"              , \"The state is \\\"eFgh\\\"\"\n"
"              , \"The state is \\\"Fgh\\\"\"\n"
"              , \"The state is \\\"gh\\\"\"\n"
"              , \"The state is \\\"h\\\"\"\n"
"              ]))\n"
msgstr ""
"> components = many upperOrLower\n"
"\n"
"> runParser components \"abCDeFgh\"\n"
"(Right (Tuple (Tuple [[\"a\",\"b\"],[\"C\",\"D\"],[\"e\"],[\"F\"],[\"g\",\"h\"]] \"\")\n"
"              [ \"The state is \\\"abCDeFgh\\\"\"\n"
"              , \"The state is \\\"bCDeFgh\\\"\"\n"
"              , \"The state is \\\"CDeFgh\\\"\"\n"
"              , \"The state is \\\"DeFgh\\\"\"\n"
"              , \"The state is \\\"eFgh\\\"\"\n"
"              , \"The state is \\\"Fgh\\\"\"\n"
"              , \"The state is \\\"gh\\\"\"\n"
"              , \"The state is \\\"h\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:714
msgid ""
"Again, this illustrates the power of reusability that monad transformers "
"bring – we were able to write a backtracking parser in a declarative style "
"with only a few lines of code, by reusing standard abstractions!"
msgstr ""
"繰り返しになりますが、これはモナド変換子が齎す再利用性の威力を示していま"
"す。\n"
"標準的な抽象化を再利用することで、宣言型スタイルのバックトラック構文解析器"
"を、ほんの数行のコードで書くことができました。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
msgid ""
"(Easy) Remove the calls to the `lift` function from your implementation of "
"the `string` parser. Verify that the new implementation type checks, and "
"convince yourself it should."
msgstr ""
"（簡単）`string`構文解析器の実装から`lift`関数の呼び出しを取り除いてくださ"
"い。\n"
"新しい実装の型検査が通ることを確認し、そうなることを納得するまで確かめましょ"
"う。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
msgid ""
"(Medium) Use your `string` parser with the `some` combinator to write a "
"parser `asFollowedByBs` that recognizes strings consisting of several copies "
"of the string `\"a\"` followed by several copies of the string `\"b\"`."
msgstr ""
"（普通）`string`構文解析器と`some`コンビネータを使って構文解析器"
"`asFollowedByBs`を書いてください。\n"
"これは文字列`\"a\"`の連続と、それに続く文字列`\"b\"`の連続からなる文字列を認"
"識するものです。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
msgid ""
"(Medium) Use the `<|>` operator to write a parser `asOrBs` that recognizes "
"strings of the letters `a` or `b` in any order."
msgstr ""
"（普通）`<|>`演算子を使って構文解析器`asOrBs`を書いてください。\n"
"これは文字`a`と文字`b`が任意の順序で現れる文字列を認識します。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
msgid "(Difficult) The `Parser` monad might also be defined as follows:"
msgstr "（難しい）`Parser`モナドを次のようにも定義できます。"

#. type: Plain text
#: text/chapter11.md:725
#, no-wrap
msgid ""
"     ```haskell\n"
"     type Parser = ExceptT Errors (StateT String (WriterT Log Identity))\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     type Parser = ExceptT Errors (StateT String (WriterT Log Identity))\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:727
#, no-wrap
msgid "     What effect does this change have on our parsing functions?\n"
msgstr "     このように変更すると、構文解析関数にどのような影響を与えるでしょうか。\n"

#. type: Title ##
#: text/chapter11.md:728
#, no-wrap
msgid "The RWS Monad"
msgstr "RWSモナド"

#. type: Plain text
#: text/chapter11.md:731
msgid ""
"One particular combination of monad transformers is so common that it is "
"provided as a single monad transformer in the `transformers` package. The "
"`Reader`, `Writer`, and `State` monads are combined into the _reader-writer-"
"state_ or simply `RWS` monad. This monad has a corresponding monad "
"transformer called the `RWST` monad transformer."
msgstr ""
"モナド変換子のとある特定の組み合わせは頻出なので、`transformers`パッケージ内"
"の単一のモナド変換子として提供されています。\n"
"`Reader`、`Writer`、`State`のモナドは、*Reader-Writer-State*モナドに組み合わ"
"さり、より単純に`RWS`モナドともされます。\n"
"このモナドは`RWST`モナド変換子という名前の、対応するモナド変換子を持ちます。"

#. type: Plain text
#: text/chapter11.md:733
msgid ""
"We will use the `RWS` monad to model the game logic for our text adventure "
"game."
msgstr ""
"ここでは `RWS`モナドを使ってテキストアドベンチャーゲームの処理を設計していき"
"ます。"

#. type: Plain text
#: text/chapter11.md:735
msgid ""
"The `RWS` monad is defined in terms of three type parameters (in addition to "
"its return type):"
msgstr ""
"`RWS`モナドは（戻り値の型に加えて）3つの型変数を使って定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:736
#, no-wrap
msgid "type RWS r w s = RWST r w s Identity\n"
msgstr "type RWS r w s = RWST r w s Identity\n"

#. type: Plain text
#: text/chapter11.md:741
msgid ""
"Notice that the `RWS` monad is defined as its own monad transformer by "
"setting the base monad to `Identity`, which provides no side-effects."
msgstr ""
"なお、`RWS`モナドは基底のモナドを`Identity`に設定することで独自のモナド変換子"
"として定義されています。\n"
"`Identity`は副作用を提供しないのでした。"

#. type: Plain text
#: text/chapter11.md:743
msgid ""
"The first type parameter, `r`, represents the global configuration type. The "
"second, `w`, represents the monoid, which we will use to accumulate a log, "
"and the third, `s`, is the type of our mutable state."
msgstr ""
"最初の型引数`r`は大域的な構成の型を表します。\n"
"2つ目の`w`はログを蓄積するために使用するモノイドを表します。\n"
"3つ目の`s`は可変状態の型です。"

#. type: Plain text
#: text/chapter11.md:745
msgid ""
"In the case of our game, our global configuration is defined in a type "
"called `GameEnvironment` in the `Data.GameEnvironment` module:"
msgstr ""
"このゲームの場合には、大域的な設定は `Data.GameEnvironment`モジュールの"
"`GameEnvironment`という名前の型で定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:746
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameEnvironment.purs:env}}\n"
msgstr "{{#include ../exercises/chapter11/src/Data/GameEnvironment.purs:env}}\n"

#. type: Plain text
#: text/chapter11.md:751
msgid ""
"It defines the player name and a flag that indicates whether or not the game "
"is running in debug mode. These options will be set from the command line "
"when we come to run our monad transformer."
msgstr ""
"プレイヤー名と、ゲームがデバッグモードで動作しているか否かを示すフラグが定義"
"されています。\n"
"モナド変換子を実行するとなると、これらのオプションがコマンドラインから設定さ"
"れます。"

#. type: Plain text
#: text/chapter11.md:753
msgid ""
"The mutable state is defined in a type called `GameState` in the `Data."
"GameState` module:"
msgstr ""
"可変状態は `Data.GameState`モジュールの `GameState`と呼ばれる型で定義されてい"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:754
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Data/GameState.purs:imports}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Data/GameState.purs:GameState}}\n"
msgstr ""
"{{#include ../exercises/chapter11/src/Data/GameState.purs:imports}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Data/GameState.purs:GameState}}\n"

#. type: Plain text
#: text/chapter11.md:761
msgid ""
"The `Coords` data type represents points on a two-dimensional grid, and the "
"`GameItem` data type is an enumeration of the items in the game:"
msgstr ""
"`Coords`データ型は2次元平面の点を表し、 `GameItem`データ型はゲーム内のアイテ"
"ムの列挙です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:762
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameItem.purs:GameItem}}\n"
msgstr "{{#include ../exercises/chapter11/src/Data/GameItem.purs:GameItem}}\n"

#. type: Plain text
#: text/chapter11.md:767
msgid ""
"The `GameState` type uses two new data structures: `Map` and `Set`, which "
"represent sorted maps and sorted sets, respectively. The `items` property is "
"a mapping from coordinates of the game grid to sets of game items at that "
"location. The `player` property stores the current coordinates of the "
"player, and the `inventory` property stores a set of game items currently "
"held by the player."
msgstr ""
"`GameState`型は2つの新しいデータ構造を使っています。\n"
"`Map`と`Set`はそれぞれ整列されたマップと整列された集合を表します。\n"
"`items`属性は、ゲーム平面上の座標からその位置にあるゲームアイテムの集合への対"
"応付けです。\n"
"`player`属性はプレイヤーの現在の座標を格納し、`inventory`属性は現在プレイヤー"
"が保有するゲームアイテムの集合を格納します。"

#. type: Plain text
#: text/chapter11.md:769
msgid ""
"The `Map` and `Set` data structures are sorted by their keys, and can be "
"used with any key type in the `Ord` type class. This means that the keys in "
"our data structures should be totally ordered."
msgstr ""
"`Map`と`Set`のデータ構造はキーによって整列され、このキーには`Ord`型クラスの任"
"意の型を使えます。\n"
"つまりデータ構造中のキーは完全に順序付けされます。"

#. type: Plain text
#: text/chapter11.md:771
msgid ""
"We will see how the `Map` and `Set` structures are used as we write the "
"actions for our game."
msgstr ""
"ゲームの動作を書く上で`Map`と`Set`構造をどのように使っていくのかを見ていきま"
"す。"

#. type: Plain text
#: text/chapter11.md:773
msgid ""
"For our log, we will use the `List String` monoid. We can define a type "
"synonym for our `Game` monad, implemented using `RWS`:"
msgstr ""
"ログとしては `List String`モノイドを使います。\n"
"`Game`モナド用の型同義語を定義し、`RWS`を使って実装できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:774
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:Game}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:Game}}\n"

#. type: Title ##
#: text/chapter11.md:778
#, no-wrap
msgid "Implementing Game Logic"
msgstr "ゲームロジックの実装"

#. type: Plain text
#: text/chapter11.md:781
msgid ""
"Our game will be built from simple actions defined in the `Game` monad by "
"reusing the actions from the `Reader`, `Writer`, and `State` monads. At the "
"top level of our application, we will run the pure computations in the "
"`Game` monad and use the `Effect` monad to turn the results into observable "
"side-effects, such as printing text to the console."
msgstr ""
"`Reader`、`Writer`、`State`モナドの動作を再利用することで、`Game`モナドで定義"
"されている単純な動作を組み合わせてゲームを構築していきます。\n"
"このアプリケーションの最上位では`Game`モナドで純粋に計算しており、`Effect`モ"
"ナドは結果からコンソールにテキストを出力するような観測可能な副作用へと変換す"
"るために使っています。"

#. type: Plain text
#: text/chapter11.md:783
msgid ""
"One of the simplest actions in our game is the `has` action. This action "
"tests whether the player's inventory contains a particular game item. It is "
"defined as follows:"
msgstr ""
"このゲームで最も簡単な動作の1つは `has`動作です。\n"
"この動作はプレイヤーの持ち物に特定のゲームアイテムが含まれているかどうかを調"
"べます。\n"
"これは次のように定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:784
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:has}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:has}}\n"

#. type: Plain text
#: text/chapter11.md:789
msgid ""
"This function uses the `get` action defined in the `MonadState` type class "
"to read the current game state and then uses the `member` function defined "
"in `Data.Set` to test whether the specified `GameItem` appears in the `Set` "
"of inventory items."
msgstr ""
"この関数は、現在のゲームの状態を読み取るために`MonadState`型クラスで定義され"
"ている`get`動作を使っています。\n"
"それから指定した`GameItem`が持ち物のアイテムの`Set`に出現するかどうかを調べる"
"ために`Data.Set`で定義されている`member`関数を使っています。"

#. type: Plain text
#: text/chapter11.md:791
msgid ""
"Another action is the `pickUp` action. It adds a game item to the player's "
"inventory if it appears in the current room. It uses actions from the "
"`MonadWriter` and `MonadState` type classes. First of all, it reads the "
"current game state:"
msgstr ""
"他にも`pickUp`動作があります。\n"
"現在の位置にゲームアイテムがある場合、プレイヤーの持ち物にそのアイテムを追加"
"します。\n"
"これには`MonadWriter`と`MonadState`型クラスの動作を使っています。\n"
"一番最初に現在のゲームの状態を読み取ります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:792
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_start}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_start}}\n"

#. type: Plain text
#: text/chapter11.md:797
msgid ""
"Next, `pickUp` looks up the set of items in the current room. It does this "
"by using the `lookup` function defined in `Data.Map`:"
msgstr ""
"次に `pickUp`は現在の位置にあるアイテムの集合を検索します。\n"
"これは`Data.Map`で定義された `lookup`関数を使って行います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:798
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_case}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_case}}\n"

#. type: Plain text
#: text/chapter11.md:803
msgid ""
"The `lookup` function returns an optional result indicated by the `Maybe` "
"type constructor. If the key does not appear in the map, the `lookup` "
"function returns `Nothing`; otherwise, it returns the corresponding value in "
"the `Just` constructor."
msgstr ""
"`lookup`関数は`Maybe`型構築子で示される省略可能な結果を返します。\n"
"`lookup`関数は、キーがマップにない場合は`Nothing`を返します。\n"
"それ以外の場合は`Just`構築子で対応する値を返します。"

#. type: Plain text
#: text/chapter11.md:805
msgid ""
"We are interested in the case where the corresponding item set contains the "
"specified game item. Again we can test this using the `member` function:"
msgstr ""
"関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含まれてい"
"る場合です。\n"
"ここでも`member`関数を使うとこれを調べることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:806
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_Just}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_Just}}\n"

#. type: Plain text
#: text/chapter11.md:811
msgid ""
"In this case, we can use `put` to update the game state and `tell` to add a "
"message to the log:"
msgstr ""
"この場合、`put`を使ってゲームの状態を更新し、`tell`を使ってログに文言を追加で"
"きます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:812
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_body}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_body}}\n"

#. type: Plain text
#: text/chapter11.md:817
msgid ""
"Note that there is no need to `lift` either of the two computations here "
"because there are appropriate instances for both `MonadState` and "
"`MonadWriter` for our `Game` monad transformer stack."
msgstr ""
"ここで2つの計算のどちらも`lift`が必要ないことに注意してください。\n"
"なぜなら`MonadState`と`MonadWriter`の両方について`Game`モナド変換子スタック用"
"の適切なインスタンスが存在するからです。"

#. type: Plain text
#: text/chapter11.md:819
msgid ""
"The argument to `put` uses a record update to modify the game state's "
"`items` and `inventory` fields. We use the `update` function from `Data."
"Map`, which modifies a value at a particular key. In this case, we modify "
"the set of items at the player's current location, using the `delete` "
"function to remove the specified item from the set. `inventory` is also "
"updated, using `insert` to add the new item to the player's inventory set."
msgstr ""
"`put`への引数では、レコード更新を使ってゲームの状態の`items`及び`inventory`"
"フィールドを変更しています。\n"
"また、特定のキーの値を変更する`Data.Map`の`update`関数を使っています。\n"
"今回の場合、プレイヤーの現在の位置にあるアイテムの集合を変更するのに、"
"`delete`関数を使って指定したアイテムを集合から取り除いています。\n"
"`insert`を使って新しいアイテムをプレイヤーの持ち物の集合に加えるときにも、"
"`inventory`は更新されます。"

#. type: Plain text
#: text/chapter11.md:821
msgid ""
"Finally, the `pickUp` function handles the remaining cases by notifying the "
"user using `tell`:"
msgstr ""
"最後に、`pickUp`関数は`tell`を使ってユーザに通知することにより、残りの場合を"
"処理します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:822
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_err}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_err}}\n"

#. type: Plain text
#: text/chapter11.md:827
msgid ""
"As an example of using the `Reader` monad, we can look at the code for the "
"`debug` command. This command allows the user to inspect the game state at "
"runtime if the game is running in debug mode:"
msgstr ""
"`Reader`モナドを使う例として、 `debug`コマンドのコードを見てみましょう。\n"
"ゲームがデバッグモードで実行されている場合、このコマンドを使うとユーザは実行"
"時にゲームの状態を調べることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:828
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:debug}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:debug}}\n"

#. type: Plain text
#: text/chapter11.md:833
msgid ""
"Here, we use the `ask` action to read the game configuration. Again, note "
"that we don't need to `lift` any computation, and we can use actions defined "
"in the `MonadState`, `MonadReader`, and `MonadWriter` type classes in the "
"same do notation block."
msgstr ""
"ここでは、ゲームの構成を読み込むために`ask`動作を使用しています。\n"
"繰り返しますが、どの計算でも`lift`する必要がなく、同じdo記法ブロック内で"
"`MonadState`、`MonadReader`、`MonadWriter`型クラスで定義されている動作を使え"
"る点に注意してください。"

#. type: Plain text
#: text/chapter11.md:835
msgid ""
"If the `debugMode` flag is set, the `tell` action is used to write the state "
"to the log. Otherwise, an error message is added."
msgstr ""
"`debugMode`フラグが設定されている場合、`tell`動作を使うとログに状態が書き込ま"
"れます。\n"
"そうでなければ、エラー文言が追加されます。"

#. type: Plain text
#: text/chapter11.md:837
msgid ""
"The remainder of the `Game` module defines a set of similar actions, each "
"using only the actions defined by the `MonadState`, `MonadReader`, and "
"`MonadWriter` type classes."
msgstr ""
"`Game`モジュールの残りの部分では同様の動作の集合が定義されています。\n"
"各動作は`MonadState`、`MonadReader`、`MonadWriter`型クラスにより定義された動"
"作のみを使っています。"

#. type: Title ##
#: text/chapter11.md:838
#, no-wrap
msgid "Running the Computation"
msgstr "計算の実行"

#. type: Plain text
#: text/chapter11.md:841
msgid ""
"Since our game logic runs in the `RWS` monad, it is necessary to run the "
"computation to respond to the user's commands."
msgstr ""
"このゲームロジックは`RWS`モナドで動くため、ユーザのコマンドに応答するために計"
"算する必要があります。"

#. type: Plain text
#: text/chapter11.md:843
msgid ""
"The front-end of our game is built using two packages: `optparse`, which "
"provides applicative command line parsing, and `node-readline`, which wraps "
"NodeJS' `readline` module, allowing us to write interactive console-based "
"applications."
msgstr ""
"このゲームのフロントエンドは2つのパッケージで構成されています。\n"
"アプリカティブなコマンドライン構文解析を提供する`optparse`と、対話的なコン"
"ソールベースのアプリケーションを書くことを可能にする、NodeJSの `readline`モ"
"ジュールを梱包する `node-readline`パッケージです。"

#. type: Plain text
#: text/chapter11.md:845
msgid ""
"The interface to our game logic is provided by the function `game` in the "
"`Game` module:"
msgstr ""
"このゲームロジックへのインターフェースは `Game`モジュール内の関数`game`によっ"
"て提供されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:846
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:game_sig}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:game_sig}}\n"

#. type: Plain text
#: text/chapter11.md:851
msgid ""
"To run this computation, we pass a list of words entered by the user as an "
"array of strings and run the resulting `RWS` computation using `runRWS`:"
msgstr ""
"これを計算するには、ユーザが入力した単語のリストを文字列の配列として渡してか"
"ら、`runRWS`を使って結果の`RWS`を計算します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:852
#, no-wrap
msgid ""
"data RWSResult state result writer = RWSResult state result writer\n"
"\n"
"runRWS :: forall r w s a. RWS r w s a -> r -> s -> RWSResult s a w\n"
msgstr ""
"data RWSResult state result writer = RWSResult state result writer\n"
"\n"
"runRWS :: forall r w s a. RWS r w s a -> r -> s -> RWSResult s a w\n"

#. type: Plain text
#: text/chapter11.md:859
msgid ""
"`runRWS` looks like a combination of `runReader`, `runWriter`, and "
"`runState`. It takes a global configuration and an initial state as an "
"argument and returns a data structure containing the log, the result, and "
"the final state."
msgstr ""
"`runRWS`は`runReader`、`runWriter`、`runState`を組み合わせたように見えま"
"す。\n"
"引数として大域的な構成及び初期状態を取り、ログ、結果、最終的な状態を含むデー"
"タ構造を返します。"

#. type: Plain text
#: text/chapter11.md:861
msgid ""
"The front-end of our application is defined by a function `runGame`, with "
"the following type signature:"
msgstr ""
"このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数`runGame`に"
"よって定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:862
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_sig}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_sig}}\n"

#. type: Plain text
#: text/chapter11.md:867
msgid ""
"This function interacts with the user via the console (using the `node-"
"readline` and `console` packages). `runGame` takes the game configuration as "
"a function argument."
msgstr ""
"この関数は（`node-readline`と`console`パッケージを使って）コンソールを介して"
"ユーザとやり取りします。\n"
"`runGame`は関数の引数としてのゲームの設定を取ります。"

#. type: Plain text
#: text/chapter11.md:869
msgid ""
"The `node-readline` package provides the `LineHandler` type, which "
"represents actions in the `Effect` monad, which handle user input from the "
"terminal. Here is the corresponding API:"
msgstr ""
"`node-readline`パッケージでは`LineHandler`型が提供されています。\n"
"これは端末からのユーザ入力を扱う`Effect`モナドの動作を表します。\n"
"対応するAPIは次の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:870
#, no-wrap
msgid ""
"type LineHandler a = String -> Effect a\n"
"\n"
"foreign import setLineHandler\n"
"  :: forall a\n"
"   . Interface\n"
"  -> LineHandler a\n"
"  -> Effect Unit\n"
msgstr ""
"type LineHandler a = String -> Effect a\n"
"\n"
"foreign import setLineHandler\n"
"  :: forall a\n"
"   . Interface\n"
"  -> LineHandler a\n"
"  -> Effect Unit\n"

#. type: Plain text
#: text/chapter11.md:881
msgid ""
"The `Interface` type represents a handle for the console and is passed as an "
"argument to the functions which interact with it. An `Interface` can be "
"created using the `createConsoleInterface` function:"
msgstr ""
"`Interface`型はコンソールの制御子を表しており、コンソールとやり取りする関数へ"
"の引数として渡されます。\n"
"`createConsoleInterface`関数を使用すると`Interface`を作成できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:882
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:import_RL}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:runGame_interface}}\n"
msgstr ""
"{{#include ../exercises/chapter11/src/Main.purs:import_RL}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:runGame_interface}}\n"

#. type: Plain text
#: text/chapter11.md:889
msgid ""
"The first step is to set the prompt at the console. We pass the `interface` "
"handle, and provide the prompt string and indentation level:"
msgstr ""
"最初の工程はコンソールにプロンプトを設定することです。\n"
"`interface`制御対象を渡し、プロンプト文字列と字下げレベルを与えます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:890
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_prompt}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_prompt}}\n"

#. type: Plain text
#: text/chapter11.md:895
msgid ""
"In our case, we are interested in implementing the line handler function. "
"Our line handler is defined using a helper function in a `let` declaration, "
"as follows:"
msgstr ""
"今回は行制御関数を実装することに関心があります。\n"
"ここでの行制御は`let`宣言内の補助関数を使って次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:896
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_lineHandler}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_lineHandler}}\n"

#. type: Plain text
#: text/chapter11.md:901
msgid ""
"The `let` binding is closed over both the game configuration, named `env`, "
"and the console handle, named `interface`."
msgstr ""
"`let`束縛が`env`という名前のゲーム構成や`interface`という名前のコンソール制御"
"対象を包み込んでいます。"

#. type: Plain text
#: text/chapter11.md:903
msgid ""
"Our handler takes an additional first argument, the game state. This is "
"required since we need to pass the game state to `runRWS` to run the game's "
"logic."
msgstr ""
"この制御子は追加の最初の引数としてゲームの状態を取ります。\n"
"ゲームのロジックを実行するために`runRWS`にゲームの状態を渡さなければならない"
"ので、これは必要となっています。"

#. type: Plain text
#: text/chapter11.md:905
msgid ""
"The first thing this action does is to break the user input into words using "
"the `split` function from the `Data.String` module. It then uses `runRWS` to "
"run the `game` action (in the `RWS` monad), passing the game environment and "
"current game state."
msgstr ""
"この動作が最初に行うことは、`Data.String`モジュールの `split`関数を使用して、"
"ユーザーの入力を単語に分割することです。\n"
"それから、ゲームの環境と現在のゲームの状態を渡し、 `runRWS`を使用して（`RWS`"
"モナドで）`game`動作を実行しています。"

#. type: Plain text
#: text/chapter11.md:907
msgid ""
"Having run the game logic, which is a pure computation, we need to print any "
"log messages to the screen and show the user a prompt for the next command. "
"The `for_` action is used to traverse the log (of type `List String`) and "
"print its entries to the console. Finally, `setLineHandler` is used to "
"update the line handler function to use the updated game state, and the "
"prompt is displayed again using the `prompt` action."
msgstr ""
"純粋な計算であるゲームロジックを実行するには、画面に全てのログ文言を出力し"
"て、ユーザに次のコマンドのためのプロンプトを表示する必要があります。\n"
"`for_`動作が（`List String`型の）ログを走査し、コンソールにその内容を出力する"
"ために使われています。\n"
"最後に`setLineHandler`を使って行制御関数を更新することでゲームの状態を更新"
"し、`prompt`動作を使ってプロンプトを再び表示しています。"

#. type: Plain text
#: text/chapter11.md:909
msgid ""
"The `runGame` function finally attaches the initial line handler to the "
"console interface and displays the initial prompt:"
msgstr ""
"`runGame`関数は最終的にコンソールインターフェイスに最初の行制御子を取り付け"
"て、初期プロンプトを表示します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:910
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_attach_handler}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_attach_handler}}\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:918
msgid ""
"(Medium) Implement a new command `cheat`, which moves all game items from "
"the game grid into the user's inventory. Create a function `cheat :: Game "
"Unit` in the `Game` module, and use this function from `game`."
msgstr ""
"（普通）ゲームの格子上にある全てのゲームアイテムをユーザの持ちものに移動する"
"新しいコマンド `cheat`を実装してください。\n"
"関数`cheat :: Game Unit`を`Game`モジュールに作り、この関数を`game`から使って"
"ください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:918
msgid ""
"(Difficult) The `Writer` component of the `RWS` monad is currently used for "
"two types of messages: error messages and informational messages. Because of "
"this, several parts of the code use case statements to handle error cases."
msgstr ""
"（難しい）`RWS`モナドの ` Writer`コンポーネントは、エラー文言とお知らせ文言の"
"2つの種類の文言のために使われています。\n"
"このため、コードの幾つかの箇所では、エラーの場合を扱うためにcase式を使用して"
"います。"

#. type: Plain text
#: text/chapter11.md:920
#, no-wrap
msgid "     Refactor the code to use the `ExceptT` monad transformer to handle the error messages and `RWS` to handle informational messages. _Note:_ There are no tests for this exercise.\n"
msgstr ""
"     コードをリファクタリングしてください。\n"
"     エラー文言を扱うのに`ExceptT`モナド変換子を使い、お知らせ文言を扱うのに`RWS`を使います。\n"
"     *補足*：この演習にはテストがありません。\n"

#. type: Title ##
#: text/chapter11.md:921
#, no-wrap
msgid "Handling Command Line Options"
msgstr "コマンドラインオプションの扱い"

#. type: Plain text
#: text/chapter11.md:924
msgid ""
"The final piece of the application is responsible for parsing command line "
"options and creating the `GameEnvironment` configuration record. For this, "
"we use the `optparse` package."
msgstr ""
"このアプリケーションの最後の部品には、コマンドラインオプションの解析と"
"`GameEnvironment`設定レコードを作成する役目があります。\n"
"このためには`optparse`パッケージを使用します。"

#. type: Plain text
#: text/chapter11.md:926
msgid ""
"`optparse` is an example of _applicative command line option parsing_. "
"Recall that an applicative functor allows us to lift functions of arbitrary "
"arity over a type constructor representing some type of side-effect. In the "
"case of the `optparse` package, the functor we are interested in is the "
"`Parser` functor (imported from the optparse module `Options.Applicative`, "
"not to be confused with our `Parser` that we defined in the `Split` module), "
"which adds the side-effect of reading from command line options. It provides "
"the following handler:"
msgstr ""
"`optparse`は*アプリカティブなコマンドラインオプション構文解析器*の一例で"
"す。\n"
"アプリカティブ関手を使うと、いろいろな副作用の型を表す型構築子まで任意個数の"
"引数の関数を持ち上げられることを思い出してください。\n"
"`optparse`パッケージの場合には、コマンドラインオプションからの読み取りの副作"
"用を追加する`Parser`関手（optparseのモジュール`Options.Applicative`からイン"
"ポートされたもの。`Split`モジュールで定義した`Parser`と混同しないように）が興"
"味深い関手になっています。\n"
"これは次のような制御子を提供しています。"

# TODO: 原文でもUnicodeの矢印になっています。
#. type: Fenced code block (haskell)
#: text/chapter11.md:927
#, no-wrap
msgid "customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a\n"
msgstr "customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a\n"

#. type: Plain text
#: text/chapter11.md:932
msgid ""
"This is best illustrated by example. The application's `main` function is "
"defined using `customExecParser` as follows:"
msgstr ""
"実例を見るのが一番です。\n"
"このアプリケーションの `main`関数は`customExecParser`を使って次のように定義さ"
"れています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:933
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:main}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:main}}\n"

#. type: Plain text
#: text/chapter11.md:938
msgid ""
"The first argument is used to configure the `optparse` library. In our case, "
"we simply configure it to show the help message when the application is run "
"without any arguments (instead of showing a \"missing argument\" error) by "
"using `OP.prefs OP.showHelpOnEmpty`, but the `Options.Applicative.Builder` "
"module provides several other options."
msgstr ""
"最初の引数は`optparse`ライブラリを設定するために使用されます。\n"
"今回の場合、アプリケーションが引数なしで走らされたときは、（「missing "
"argument」エラーを表示する代わりに）`OP.prefs OP.showHelpOnEmpty`を使って使用"
"方法の文言を表示するように設定していますが、`Options.Applicative.Builder`モ"
"ジュールには他にも幾つかの選択肢を提供しています。"

#. type: Plain text
#: text/chapter11.md:940
msgid "The second argument is the complete description of our parser program:"
msgstr "2つ目の引数は解析プログラムの完全な説明です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:941
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:argParser}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:parserOptions}}\n"
msgstr ""
"{{#include ../exercises/chapter11/src/Main.purs:argParser}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:parserOptions}}\n"

#. type: Plain text
#: text/chapter11.md:948
#, no-wrap
msgid "Here `OP.info` combines a `Parser` with a set of options for how the help message is formatted. `env <**> OP.helper` takes any command line argument `Parser` named `env` and automatically adds a `--help` option. Options for the help message are of type `InfoMod`, which is a monoid, so we can use the `fold` function to add several options together.\n"
msgstr ""
"ここで`OP.info`は、`Parser`をヘルプ文言の書式方法のためのオプションの集合と組み合わせます。\n"
"`env <**> OP.helper`は`env`と名付けられた任意のコマンドライン引数`Parser`を取り、自動的に`--help`オプションを加えます。\n"
"ヘルプ文言用のオプションは型が`InfoMod`であり、これはモノイドなので、`fold`関数を使って複数のオプションを一緒に追加できます。\n"

#. type: Plain text
#: text/chapter11.md:950
msgid ""
"The interesting part of our parser is constructing the `GameEnvironment`:"
msgstr "解析器の面白い部分は`GameEnvironment`の構築にあります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:951
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:env}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:env}}\n"

#. type: Plain text
#: text/chapter11.md:956
#, no-wrap
msgid "`player` and `debug` are both `Parser`s, so we can use our applicative operators `<$>` and `<*>` to lift our `gameEnvironment` function, which has the type `PlayerName -> Boolean -> GameEnvironment` over `Parser`. `OP.strOption` constructs a command line option that expects a string value and is configured via a collection of `Mod`s folded together. `OP.flag` works similarly but doesn't expect an associated value. `optparse` offers extensive [documentation](https://pursuit.purescript.org/packages/purescript-optparse) on different modifiers available to build various command line parsers.\n"
msgstr ""
"`player`と`debug`は両方とも`Parser`なので、アプリカティブ演算子`<$>`と`<*>`を使って`gameEnvironment`関数を持ち上げられます。\n"
"この関数は`Parser`上で型`PlayerName -> Boolean -> GameEnvironment`を持ちます。\n"
"`OP.strOption`は文字列値を期待するコマンドラインオプションを構築し、一緒に畳み込まれた`Mod`の集まりを介して構成されています。\n"
"`OP.flag`は似たような動作をしますが、関連付けられた値は期待しません。\n"
"`optparse`は多様なコマンドライン解析器を構築するために使える様々な修飾子について、大部の[ドキュメント](https://pursuit.purescript.org/packages/purescript-optparse)を提供しています。\n"

#. type: Plain text
#: text/chapter11.md:958
#, no-wrap
msgid "Notice how we used the notation afforded by the applicative operators to give a compact, declarative specification of our command line interface. In addition, it is simple to add new command line arguments by adding a new function argument to `runGame` and then using `<*>` to lift `runGame` over an additional argument in the definition of `env`.\n"
msgstr ""
"アプリカティブ演算子により齎される記法を使うことで、コマンドラインインターフェイスの簡潔で宣言的な仕様を与えられた点に注目です。\n"
"加えて、新しいコマンドライン引数を追加するのは単純で、`runGame`に新しい関数引数を追加し、`env`の定義中で`<*>`を使って追加の引数まで`runGame`を持ち上げるだけでできます。\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:962
msgid ""
"(Medium) Add a new Boolean-valued property `cheatMode` to the "
"`GameEnvironment` record. Add a new command line flag `-c` to the `optparse` "
"configuration, enabling cheat mode. The `cheat` command from the previous "
"exercise should be disallowed if cheat mode is not enabled."
msgstr ""
"（普通）`GameEnvironment`レコードに新しい真偽値のプロパティ`cheatMode`を追加"
"してください。\n"
"また、`optparse`の構成に、チートモードを有効にする新しいコマンドラインフラグ"
"`-c`を追加してください。\n"
"チートモードが有効になっていない場合、前の演習の`cheat`コマンドは禁止されま"
"す。"

#. type: Plain text
#: text/chapter11.md:966
msgid ""
"This chapter was a practical demonstration of the techniques we've learned "
"so far, using monad transformers to build a pure specification of our game "
"and the `Effect` monad to build a front-end using the console."
msgstr ""
"この章ではこれまで学んできた技術を実践的に実演しました。\n"
"モナド変換子を使用したゲームの純粋な仕様の構築、コンソールを使用したフロント"
"エンドを構築するための`Effect`モナドがそれです。"

#. type: Plain text
#: text/chapter11.md:968
msgid ""
"Because we separated our implementation from the user interface, it would be "
"possible to create other front-ends for our game. For example, we could use "
"the `Effect` monad to render the game in the browser using the Canvas API or "
"the DOM."
msgstr ""
"ユーザインターフェイスからの実装を分離したので、ゲームの別のフロントエンドも"
"作成できるでしょう。\n"
"例えば、`Effect`モナドでCanvas APIやDOMを使用して、ブラウザでゲームを描画する"
"ようなことができるでしょう。"

#. type: Plain text
#: text/chapter11.md:970
msgid ""
"We have seen how monad transformers allow us to write safe code in an "
"imperative style, where the type system tracks effects. In addition, type "
"classes provide a powerful way to abstract over the actions provided by a "
"monad, enabling code reuse. We used standard abstractions like `Alternative` "
"and `MonadPlus` to build useful monads by combining standard monad "
"transformers."
msgstr ""
"モナド変換子によって命令型のスタイルで安全なコードを書けることが分かりまし"
"た。\n"
"このスタイルでは型システムによって作用が追跡されています。\n"
"加えて、型クラスはモナドが提供する動作へと抽象化する強力な方法を提供し、これ"
"によりコードの再利用が可能になりました。\n"
"標準的なモナド変換子を組み合わせることにより、`Alternative`や`MonadPlus`のよ"
"うな標準的な抽象化を使用して、役に立つモナドを構築できました。"

#. type: Plain text
#: text/chapter11.md:971
msgid ""
"Monad transformers are an excellent demonstration of expressive code that "
"can be written by relying on advanced type system features such as higher-"
"kinded polymorphism and multi-parameter type classes."
msgstr ""
"モナド変換子は表現力の高いコードの優れた実演となっています。\n"
"これは高階多相や多変数型クラスなどの高度な型システムの機能を利用することに"
"よって記述できるものです。"

#. type: Title #
#: text/chapter12.md:1
#, no-wrap
msgid "Canvas Graphics"
msgstr "Canvasグラフィックス"

#. type: Plain text
#: text/chapter12.md:6
msgid ""
"This chapter will be an extended example focussing on the `canvas` package, "
"which provides a way to generate 2D graphics from PureScript using the HTML5 "
"Canvas API."
msgstr ""
"この章は`canvas`パッケージに焦点を当てる発展的な例となります。\n"
"このパッケージはPureScriptでHTML5のCanvas APIを使用して2Dグラフィックスを生成"
"する手段を提供します。"

#. type: Bullet: '- '
#: text/chapter12.md:13
msgid "`canvas`, which gives types to methods from the HTML5 Canvas API"
msgstr "`canvas`はHTML5のCanvas APIメソッドの型を与えます。"

#. type: Bullet: '- '
#: text/chapter12.md:13
msgid ""
"`refs`, which provides a side-effect for using _global mutable references_"
msgstr ""
"`refs`は _大域的な変更可能領域への参照_ を使うための副作用を提供します。"

#. type: Plain text
#: text/chapter12.md:15
msgid ""
"The source code for the chapter is broken up into a set of modules, each of "
"which defines a `main` method. Different sections of this chapter are "
"implemented in different files, and the `Main` module can be changed by "
"modifying the Spago build command to run the appropriate file's `main` "
"method at each point."
msgstr ""
"この章の各ソースコードは、`main`メソッドが定義されているモジュールの集合へと"
"分割されています。\n"
"この章の各節の内容は個別のファイルで実装されており、各時点での適切なファイル"
"の`main`メソッドを実行できるように、Spagoビルドコマンドを変更することで、"
"`Main`モジュールを合わせられるようになっています。"

#. type: Plain text
#: text/chapter12.md:17
msgid ""
"The HTML file `html/index.html` contains a single `canvas` element which "
"will be used in each example, and a `script` element to load the compiled "
"PureScript code. To test the code for each section, open the HTML file in "
"your browser. Because most exercises target the browser, this chapter has no "
"unit tests."
msgstr ""
"HTMLファイル`html/index.html`には、各例で使用される単一の`canvas`要素、及びコ"
"ンパイルされたPureScriptコードを読み込む`script`要素が含まれています。\n"
"各節のコードを試すにはブラウザでHTMLファイルを開きます。\n"
"ほとんどの演習はブラウザを対象にしているので、この章には単体試験はありませ"
"ん。"

#. type: Title ##
#: text/chapter12.md:18
#, no-wrap
msgid "Simple Shapes"
msgstr "単純な図形"

#. type: Plain text
#: text/chapter12.md:21
msgid ""
"The `Example/Rectangle.purs` file contains a simple introductory example, "
"which draws a single blue rectangle at the center of the canvas. The module "
"imports the `Effect` type from the `Effect` module, and also the `Graphics."
"Canvas` module, which contains actions in the `Effect` monad for working "
"with the Canvas API."
msgstr ""
"`Example/Rectangle.purs`ファイルには簡単な導入例が含まれています。\n"
"この例ではキャンバスの中心に青い四角形を1つ描画します。\n"
"このモジュールへは、`Effect`モジュールからの`Effect`型と、Canvas APIを扱うた"
"めの`Effect`モナドの動作を含む`Graphics.Canvas`モジュールをインポートします。"

#. type: Plain text
#: text/chapter12.md:23
msgid ""
"The `main` action starts, like in the other modules, by using the "
"`getCanvasElementById` action to get a reference to the canvas object and "
"the `getContext2D` action to access the 2D rendering context for the canvas:"
msgstr ""
"他のモジュールでも同様ですが、`main`動作は最初に`getCanvasElementById`動作を"
"使ってキャンバスオブジェクトへの参照を取得し、`getContext2D`動作を使ってキャ"
"ンバスの2D描画文脈にアクセスします。"

#. type: Plain text
#: text/chapter12.md:25
msgid ""
"The `void` function takes a functor and replaces its value with `Unit`. In "
"the example, it is used to make `main` conform with its signature."
msgstr ""
"`void`関数は関手を取り値を`Unit`で置き換えます。\n"
"例では`main`がシグネチャに沿うようにするために使われています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:26
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:main}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:main}}\n"

#. type: Plain text
#: text/chapter12.md:31
msgid ""
"_Note_: the call to `unsafePartial` here is necessary since the pattern "
"match on the result of `getCanvasElementById` is partial, matching only the "
"`Just` constructor. For our purposes, this is fine, but in production code, "
"we would probably want to match the `Nothing` constructor and provide an "
"appropriate error message."
msgstr ""
"*補足*：この`unsafePartial`の呼び出しは必須です。\n"
"これは`getCanvasElementById`の結果のパターン照合部分で、`Just`値構築子のみと"
"照合するためです。\n"
"ここではこれで問題ありませんが、恐らく実際の製品のコードでは`Nothing`値構築子"
"と照合させ、適切なエラー文言を提供したほうがよいでしょう。"

#. type: Plain text
#: text/chapter12.md:33
msgid ""
"The types of these actions can be found using PSCi or by looking at the "
"documentation:"
msgstr "これらの動作の型はPSCiを使うかドキュメントを見ると確認できます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:34
#, no-wrap
msgid ""
"getCanvasElementById :: String -> Effect (Maybe CanvasElement)\n"
"\n"
"getContext2D :: CanvasElement -> Effect Context2D\n"
msgstr ""
"getCanvasElementById :: String -> Effect (Maybe CanvasElement)\n"
"\n"
"getContext2D :: CanvasElement -> Effect Context2D\n"

#. type: Plain text
#: text/chapter12.md:41
msgid ""
"`CanvasElement` and `Context2D` are types defined in the `Graphics.Canvas` "
"module. The same module also defines the `Canvas` effect, which is used by "
"all of the actions in the module."
msgstr ""
"`CanvasElement`と `Context2D`は `Graphics.Canvas`モジュールで定義されている型"
"です。\n"
"このモジュールでは`Canvas`作用も定義されており、モジュール内の全てのアクショ"
"ンで使用されています。"

#. type: Plain text
#: text/chapter12.md:43
msgid ""
"The graphics context `ctx` manages the state of the canvas and provides "
"methods to render primitive shapes, set styles and colors, and apply "
"transformations."
msgstr ""
"グラフィックス文脈`ctx`はキャンバスの状態を管理し、原始的な図形を描画したり、"
"スタイルや色を設定したり、座標変換を適用したりするための手段を提供します。"

#. type: Plain text
#: text/chapter12.md:45
msgid ""
"We continue by setting the fill style to solid blue using the `setFillStyle` "
"action. The longer hex notation of `#0000FF` may also be used for blue, but "
"shorthand notation is easier for simple colors:"
msgstr ""
"話を進めると、`setFillStyle`動作を使うことで塗り潰しスタイルを濃い青に設定で"
"きます。\n"
"より長い16進数記法の`#0000FF`も青には使えますが、単純な色については略記法がよ"
"り簡単です。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:46
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:setFillStyle}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:setFillStyle}}\n"

#. type: Plain text
#: text/chapter12.md:51
msgid ""
"Note that the `setFillStyle` action takes the graphics context as an "
"argument. This is a common pattern in the `Graphics.Canvas` module."
msgstr ""
"`setFillStyle`動作がグラフィックス文脈を引数として取っていることに注意してく"
"ださい。\n"
"これは`Graphics.Canvas`ではよくあるパターンです。"

#. type: Plain text
#: text/chapter12.md:53
msgid ""
"Finally, we use the `fillPath` action to fill the rectangle. `fillPath` has "
"the following type:"
msgstr ""
"最後に、`fillPath`動作を使用して矩形を塗り潰しています。\n"
"`fillPath`は次のような型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:54
#, no-wrap
msgid "fillPath :: forall a. Context2D -> Effect a -> Effect a\n"
msgstr "fillPath :: forall a. Context2D -> Effect a -> Effect a\n"

#. type: Plain text
#: text/chapter12.md:59
msgid ""
"`fillPath` takes a graphics context and another action that builds the path "
"to render. To build a path, we can use the `rect` action. `rect` takes a "
"graphics context and a record that provides the position and size of the "
"rectangle:"
msgstr ""
"`fillPath`はグラフィックスの文脈と描画するパスを構築する他の動作を引数に取り"
"ます。\n"
"`rect`動作を使うとパスを構築できます。\n"
"`rect`はグラフィックスの文脈と矩形の位置及びサイズを格納するレコードを取りま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:60
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:fillPath}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:fillPath}}\n"

#. type: Plain text
#: text/chapter12.md:65
msgid ""
"Build the rectangle example, providing `Example.Rectangle` as the name of "
"the main module:"
msgstr ""
"mainモジュールの名前として`Example.Rectangle`を与えてこの長方形のコード例をビ"
"ルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:66
#, no-wrap
msgid "$ spago bundle-app --main Example.Rectangle --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Rectangle --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:71
msgid ""
"Now, open the `html/index.html` file and verify that this code renders a "
"blue rectangle in the center of the canvas."
msgstr ""
"それでは `html/index.html`ファイルを開き、このコードによってキャンバスの中央"
"に青い四角形が描画されていることを確認してみましょう。"

#. type: Title ##
#: text/chapter12.md:72
#, no-wrap
msgid "Putting Row Polymorphism to Work"
msgstr "行多相を利用する"

#. type: Plain text
#: text/chapter12.md:75
msgid ""
"There are other ways to render paths. The `arc` function renders an arc "
"segment, and the `moveTo`, `lineTo`, and `closePath` functions can render "
"piecewise-linear paths."
msgstr ""
"パスを描画する方法は他にもあります。\n"
"`arc`関数は円弧を描画します。\n"
"`moveTo`関数、`lineTo`関数、`closePath`関数は断片的な線分のパスを描画できま"
"す。"

#. type: Plain text
#: text/chapter12.md:77
msgid ""
"The `Shapes.purs` file renders three shapes: a rectangle, an arc segment, "
"and a triangle."
msgstr ""
"`Shapes.purs`ファイルでは長方形と円弧と三角形の、3つの図形を描画しています。"

#. type: Plain text
#: text/chapter12.md:79
msgid ""
"We have seen that the `rect` function takes a record as its argument. In "
"fact, the properties of the rectangle are defined in a type synonym:"
msgstr ""
"`rect`関数は引数としてレコードをとることを見てきました。\n"
"実際には、長方形のプロパティは型同義語で定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:80
#, no-wrap
msgid ""
"type Rectangle =\n"
"  { x :: Number\n"
"  , y :: Number\n"
"  , width :: Number\n"
"  , height :: Number\n"
"  }\n"
msgstr ""
"type Rectangle =\n"
"  { x :: Number\n"
"  , y :: Number\n"
"  , width :: Number\n"
"  , height :: Number\n"
"  }\n"

# FIXME: w, hとなっていますが、上のコードではwidthとheightになっています。
#. type: Plain text
#: text/chapter12.md:90
msgid ""
"The `x` and `y` properties represent the location of the top-left corner, "
"while the `w` and `h` properties represent the width and height, "
"respectively."
msgstr ""
"`x`と`y`プロパティは左上隅の位置を表しており、`w`と`h`のプロパティはそれぞれ"
"幅と高さを表しています。"

#. type: Plain text
#: text/chapter12.md:92
msgid ""
"To render an arc segment, we can use the `arc` function, passing a record "
"with the following type:"
msgstr ""
"`arc`関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画できま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:93
#, no-wrap
msgid ""
"type Arc =\n"
"  { x      :: Number\n"
"  , y      :: Number\n"
"  , radius :: Number\n"
"  , start  :: Number\n"
"  , end    :: Number\n"
"  }\n"
msgstr ""
"type Arc =\n"
"  { x      :: Number\n"
"  , y      :: Number\n"
"  , radius :: Number\n"
"  , start  :: Number\n"
"  , end    :: Number\n"
"  }\n"

# FIXME: これも半径がrとradiusで違います。
#. type: Plain text
#: text/chapter12.md:104
msgid ""
"Here, the `x` and `y` properties represent the center point, `r` is the "
"radius, `start` and `end` represent the endpoints of the arc in radians."
msgstr ""
"ここで、`x`と`y`プロパティは弧の中心、`r`は半径、`start`と`end`は弧の両端の角"
"度を弧度法で表しています。"

#. type: Plain text
#: text/chapter12.md:106
msgid ""
"For example, this code fills an arc segment centered at `(300, 300)` with "
"radius `50`. The arc completes 2/3rds of a rotation. Note that the unit "
"circle is flipped vertically since the y-axis increases towards the bottom "
"of the canvas:"
msgstr ""
"例えばこのコードは中心が`(300, 300)`に中心があり半径`50`の円弧を塗り潰しま"
"す。\n"
"弧は1回転のうち2/3ラジアン分あります。\n"
"単位円が上下逆様になっている点に注意してください。\n"
"これはy軸がキャンバスの下向きに伸びるためです。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:107
#, no-wrap
msgid ""
"  fillPath ctx $ arc ctx\n"
"    { x      : 300.0\n"
"    , y      : 300.0\n"
"    , radius : 50.0\n"
"    , start  : 0.0\n"
"    , end    : Math.tau * 2.0 / 3.0\n"
"    }\n"
msgstr ""
"  fillPath ctx $ arc ctx\n"
"    { x      : 300.0\n"
"    , y      : 300.0\n"
"    , radius : 50.0\n"
"    , start  : 0.0\n"
"    , end    : Math.tau * 2.0 / 3.0\n"
"    }\n"

#. type: Plain text
#: text/chapter12.md:118
msgid ""
"Notice that both the `Rectangle` and `Arc` record types contain `x` and `y` "
"properties of type `Number`. In both cases, this pair represents a point. "
"This means we can write row-polymorphic functions acting on either type of "
"record."
msgstr ""
"`Rectangle`レコード型と`Arc`レコード型の両方共、`Number`型の`x`と`y`というプ"
"ロパティを含んでいますね。\n"
"どちらの場合でもこの組は点を表しています。\n"
"つまり、何れのレコード型にも作用する行多相な関数を書けます。"

#. type: Plain text
#: text/chapter12.md:120
msgid ""
"For example, the `Shapes` module defines a `translate` function that "
"translates a shape by modifying its `x` and `y` properties:"
msgstr ""
"例えば`Shapes`モジュールでは`x`と`y`のプロパティを変更し図形を並行移動する"
"`translate`関数が定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:121
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:translate}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Shapes.purs:translate}}\n"

#. type: Plain text
#: text/chapter12.md:126
msgid ""
"Notice the row-polymorphic type. It says that `translate` accepts any record "
"with `x` and `y` properties _and any other properties_, and returns the same "
"type of record. The `x` and `y` fields are updated, but the rest of the "
"fields remain unchanged."
msgstr ""
"この行多相型に注目してください。\n"
"`translate`が `x`と `y`というプロパティと、*それに加えて他の任意のプロパティ*"
"を持つどんなレコードでも受け入れ、同じ型のレコードを返すと書かれています。\n"
"`x`フィールドと `y`フィールドは更新されますが、残りのフィールドは変更されませ"
"ん。"

#. type: Plain text
#: text/chapter12.md:128
msgid ""
"This is an example of _record update syntax_. The expression `shape { ... }` "
"creates a new record based on the `shape` record, with the fields inside the "
"braces updated to the specified values. Note that the expressions inside the "
"braces are separated from their labels by equals symbols, not colons like in "
"record literals."
msgstr ""
"これは*レコード更新構文*の例です。\n"
"`shape { ... }`という式は、`shape`を元にして、括弧の中で指定された値で更新さ"
"れたフィールドを持つ新たなレコードを作ります。\n"
"なお、波括弧の中の式はレコード直値のようなコロンではなく、等号でラベルと式を"
"区切って書きます。"

#. type: Plain text
#: text/chapter12.md:130
msgid ""
"The `translate` function can be used with both the `Rectangle` and `Arc` "
"records, as seen in the `Shapes` example."
msgstr ""
"`Shapes`の例からわかるように、`translate`関数は`Rectangle`レコードと`Arc`レ"
"コード双方に対して使えます。"

#. type: Plain text
#: text/chapter12.md:132
msgid ""
"The third type of path rendered in the `Shapes` example is a piecewise-"
"linear path. Here is the corresponding code:"
msgstr ""
"`Shape`の例で描画される3つ目の型は線分の断片からなるパスです。\n"
"対応するコードは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:133
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:path}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Shapes.purs:path}}\n"

#. type: Plain text
#: text/chapter12.md:138
msgid "There are three functions in use here:"
msgstr "ここでは3つの関数が使われています。"

#. type: Bullet: '- '
#: text/chapter12.md:142
msgid ""
"`moveTo` moves the current location of the path to the specified coordinates,"
msgstr "`moveTo`はパスの現在地を指定された座標に移動します。"

#. type: Bullet: '- '
#: text/chapter12.md:142
msgid ""
"`lineTo` renders a line segment between the current location and the "
"specified coordinates, and updates the current location,"
msgstr ""
"`lineTo`は現在地と指定された座標の間の線分を描画し、現在地を更新します。"

#. type: Bullet: '- '
#: text/chapter12.md:142
msgid ""
"`closePath` completes the path by rendering a line segment joining the "
"current location to the start position."
msgstr "`closePath`は現在地と開始地点とを結ぶ線分を描画してパスを完結します。"

#. type: Plain text
#: text/chapter12.md:144
msgid "The result of this code snippet is to fill an isosceles triangle."
msgstr "このコード片の結果は二等辺三角形の塗り潰しになります。"

#. type: Plain text
#: text/chapter12.md:146
msgid "Build the example by specifying `Example.Shapes` as the main module:"
msgstr ""
"mainモジュールとして`Example.Shapes`を指定して、この例をビルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:147
#, no-wrap
msgid "$ spago bundle-app --main Example.Shapes --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Shapes --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:152
msgid ""
"and open `html/index.html` again to see the result. You should see the three "
"different types of shapes rendered to the canvas."
msgstr ""
"そしてもう一度`html/index.html`を開き、結果を確認してください。\n"
"キャンバスに3つの異なる図形が描画されるはずです。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
msgid ""
"(Easy) Experiment with the `strokePath` and `setStrokeStyle` functions in "
"each example so far."
msgstr ""
"（簡単）これまでの各例について、`strokePath`関数や`setStrokeStyle`関数を使っ"
"てみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
msgid ""
"(Easy) The `fillPath` and `strokePath` functions can render complex paths "
"with a common style using a do notation block inside the function argument. "
"Try changing the `Rectangle` example to render two rectangles side-by-side "
"using the same call to `fillPath`. Try rendering a sector of a circle by "
"using a combination of a piecewise-linear path and an arc segment."
msgstr ""
"（簡単）関数の引数の内部でdo記法ブロックを使うと、`fillPath`関数と"
"`strokePath`関数は共通のスタイルを持つ複雑なパスを描画できます。\n"
"同じ`fillPath`呼び出しを使って隣り合う2つの矩形を描画するように、`Rectangle`"
"の例を変更してみてください。\n"
"線分と円弧の組み合わせを使って、扇形を描画してみてください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
msgid "(Medium) Given the following record type:"
msgstr "（普通）次のような2次元の点を表すレコードが与えられたとします。"

#. type: Plain text
#: text/chapter12.md:162
#, no-wrap
msgid ""
"     ```haskell\n"
"     type Point = { x :: Number, y :: Number }\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     type Point = { x :: Number, y :: Number }\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:164
#, no-wrap
msgid "     which represents a 2D point, write a function `renderPath` which strokes a closed path constructed from a number of points:\n"
msgstr ""
"     これは2次元の点を表現しています。\n"
"     多数の点からなる閉じたパスを線描きする関数 `renderPath`を書いてください。\n"

#. type: Plain text
#: text/chapter12.md:171
#, no-wrap
msgid ""
"     ```haskell\n"
"     renderPath\n"
"       :: Context2D\n"
"       -> Array Point\n"
"       -> Effect Unit\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     renderPath\n"
"       :: Context2D\n"
"       -> Array Point\n"
"       -> Effect Unit\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:173
#, no-wrap
msgid "     Given a function\n"
msgstr "     次のような関数を考えます。\n"

#. type: Plain text
#: text/chapter12.md:177
#, no-wrap
msgid ""
"     ```haskell\n"
"     f :: Number -> Point\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     f :: Number -> Point\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:179
#, no-wrap
msgid "     which takes a `Number` between `0` and `1` as its argument and returns a `Point`, write an action that plots `f` by using your `renderPath` function. Your action should approximate the path by sampling `f` at a finite set of points.\n"
msgstr ""
"    この関数は引数として`1`から`0`の間の`Number`を取り、`Point`を返します。\n"
"    `renderPath`関数を使い、関数`f`のグラフを描く動作を書いてください。\n"
"    その動作では有限個の点で`f`を標本化することによって近似しなければなりません。\n"

#. type: Plain text
#: text/chapter12.md:181
#, no-wrap
msgid "     Experiment by rendering different paths by varying the function `f`.\n"
msgstr "     関数 `f`を変更し、様々なパスが描画されることを確かめてください。\n"

#. type: Title ##
#: text/chapter12.md:182
#, no-wrap
msgid "Drawing Random Circles"
msgstr "無作為に円を描く"

#. type: Plain text
#: text/chapter12.md:185
msgid ""
"The `Example/Random.purs` file contains an example that uses the `Effect` "
"monad to interleave two types of side-effect: random number generation and "
"canvas manipulation. The example renders one hundred randomly generated "
"circles onto the canvas."
msgstr ""
"`Example/Random.purs`ファイルには、`Effect`モナドを使って2種類の副作用を綴じ"
"合わせる例が含まれています。\n"
"1つの副作用は乱数生成で、もう1つはキャンバスの操作です。\n"
"この例では無作為に生成された円をキャンバスに100個描画します。"

#. type: Plain text
#: text/chapter12.md:187
msgid ""
"The `main` action obtains a reference to the graphics context as before and "
"then sets the stroke and fill styles:"
msgstr ""
"`main`動作ではこれまでのようにグラフィックス文脈への参照を取得し、線描きと塗"
"り潰しのスタイルを設定します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:188
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:style}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:style}}\n"

#. type: Plain text
#: text/chapter12.md:193
msgid ""
"Next, the code uses the `for_` function to loop over the integers between "
"`0` and `100`:"
msgstr ""
"次のコードでは`for_`動作を使って`0`から`100`までの整数について反復していま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:194
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:for}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:for}}\n"

#. type: Plain text
#: text/chapter12.md:199
msgid ""
"On each iteration, the do notation block starts by generating three random "
"numbers distributed between `0` and `1`. These numbers represent the `x` and "
"`y` coordinates and the radius of a circle:"
msgstr ""
"各繰り返しで、do記法ブロックは`0`と`1`の間に分布する3つの乱数を生成することか"
"ら始まります。\n"
"これらの数はそれぞれ`x`座標、`y`座標、半径`r`を表しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:random}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:random}}\n"

#. type: Plain text
#: text/chapter12.md:205
msgid ""
"Next, for each circle, the code creates an `Arc` based on these parameters "
"and finally fills and strokes the arc with the current styles:"
msgstr ""
"次のコードでは各円について、これらの変数に基づいて`Arc`を作成し、最後に現在の"
"スタイルに従って円弧を塗り潰し線描きします。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:path}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:path}}\n"

#. type: Plain text
#: text/chapter12.md:211
msgid ""
"Build this example by specifying the `Example.Random` module as the main "
"module:"
msgstr ""
"mainモジュールとして`Example.Random`を指定して、この例をビルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:212
#, no-wrap
msgid "$ spago bundle-app --main Example.Random --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Random --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:217
msgid "and view the result by opening `html/index.html`."
msgstr "`html/index.html`を開いて、結果を確認してみましょう。"

#. type: Title ##
#: text/chapter12.md:218
#, no-wrap
msgid "Transformations"
msgstr "座標変換"

#. type: Plain text
#: text/chapter12.md:221
msgid ""
"There is more to the canvas than just rendering simple shapes. Every canvas "
"maintains a transformation that is used to transform shapes before "
"rendering. Shapes can be translated, rotated, scaled, and skewed."
msgstr ""
"キャンバスは簡単な図形を描画するだけのものではありません。\n"
"キャンバスは座標変換を管理しており、描画の前に図形を変形するのに使えます。\n"
"図形は平行移動、回転、拡大縮小、及び斜めに変形できます。"

#. type: Plain text
#: text/chapter12.md:223
msgid ""
"The `canvas` library supports these transformations using the following "
"functions:"
msgstr "`canvas`ライブラリではこれらの変換を以下の関数で提供しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:224
#, no-wrap
msgid ""
"translate :: Context2D\n"
"          -> TranslateTransform\n"
"          -> Effect Context2D\n"
"\n"
"rotate    :: Context2D\n"
"          -> Number\n"
"          -> Effect Context2D\n"
"\n"
"scale     :: Context2D\n"
"          -> ScaleTransform\n"
"          -> Effect Context2D\n"
"\n"
"transform :: Context2D\n"
"          -> Transform\n"
"          -> Effect Context2D\n"
msgstr ""
"translate :: Context2D\n"
"          -> TranslateTransform\n"
"          -> Effect Context2D\n"
"\n"
"rotate    :: Context2D\n"
"          -> Number\n"
"          -> Effect Context2D\n"
"\n"
"scale     :: Context2D\n"
"          -> ScaleTransform\n"
"          -> Effect Context2D\n"
"\n"
"transform :: Context2D\n"
"          -> Transform\n"
"          -> Effect Context2D\n"

#. type: Plain text
#: text/chapter12.md:243
msgid ""
"The `translate` action performs a translation whose components are specified "
"by the properties of the `TranslateTransform` record."
msgstr ""
"`translate`動作は`TranslateTransform`レコードのプロパティで指定した大きさだけ"
"平行移動します。"

#. type: Plain text
#: text/chapter12.md:245
msgid ""
"The `rotate` action rotates around the origin through some number of radians "
"specified by the first argument."
msgstr ""
"`rotate`動作は最初の引数で指定されたラジアンの数値に応じて、原点を中心として"
"回転します。"

#. type: Plain text
#: text/chapter12.md:247
msgid ""
"The `scale` action performs a scaling, with the origin as the center. The "
"`ScaleTransform` record specifies the scale factors along the `x` and `y` "
"axes."
msgstr ""
"`scale`動作は原点を中心として拡大縮小します。\n"
"`ScaleTransform`レコードは`x`軸と`y`軸に沿った拡大率を指定するのに使います。"

#. type: Plain text
#: text/chapter12.md:249
msgid ""
"Finally, `transform` is the most general action of the four here. It "
"performs an affine transformation specified by a matrix."
msgstr ""
"最後の `transform`はこの4つのうちで最も一般化された動作です。\n"
"この動作では行列に従ってアフィン変換します。"

#. type: Plain text
#: text/chapter12.md:251
msgid ""
"Any shapes rendered after these actions have been invoked will automatically "
"have the appropriate transformation applied."
msgstr ""
"これらの動作が呼び出された後に描画される図形は、自動的に適切な座標変換が適用"
"されます。"

#. type: Plain text
#: text/chapter12.md:253
msgid ""
"In fact, the effect of each of these functions is to _post-multiply_ the "
"transformation with the context's current transformation. The result is that "
"if multiple transformations applied after one another, then their effects "
"are actually applied in reverse:"
msgstr ""
"実際には、これらの関数の各作用は、文脈の現在の変換行列に対して変換行列を*右か"
"ら乗算*していきます。\n"
"つまり、もしある作用の変換をしていくと、その作用は実際には逆順に適用されてい"
"きます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:254
#, no-wrap
msgid ""
"transformations ctx = do\n"
"  translate ctx { translateX: 10.0, translateY: 10.0 }\n"
"  scale ctx { scaleX: 2.0, scaleY: 2.0 }\n"
"  rotate ctx (Math.tau / 4.0)\n"
"\n"
"  renderScene\n"
msgstr ""
"transformations ctx = do\n"
"  translate ctx { translateX: 10.0, translateY: 10.0 }\n"
"  scale ctx { scaleX: 2.0, scaleY: 2.0 }\n"
"  rotate ctx (Math.tau / 4.0)\n"
"\n"
"  renderScene\n"

#. type: Plain text
#: text/chapter12.md:264
msgid ""
"The effect of this sequence of actions is that the scene is rotated, then "
"scaled, and finally translated."
msgstr ""
"この一連の動作の作用では、まずシーンが回転され、それから拡大縮小され、最後に"
"平行移動されます。"

#. type: Title ##
#: text/chapter12.md:265
#, no-wrap
msgid "Preserving the Context"
msgstr "文脈の保存"

#. type: Plain text
#: text/chapter12.md:268
msgid ""
"A common use case is to render some subset of the scene using a "
"transformation and then reset the transformation."
msgstr ""
"座標変換を使ってシーンの一部を描画し、それからその変換を元に戻す、という使い"
"方はよくあります。"

#. type: Plain text
#: text/chapter12.md:270
msgid ""
"The Canvas API provides the `save` and `restore` methods, which manipulate a "
"_stack_ of states associated with the canvas. `canvas` wraps this "
"functionality into the following functions:"
msgstr ""
"Canvas APIにはキャンバスの状態の*スタック*を操作する`save`と`restore`メソッド"
"が備わっています。\n"
"`canvas`ではこの機能を次のような関数で梱包しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:271
#, no-wrap
msgid ""
"save\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
"\n"
"restore\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
msgstr ""
"save\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
"\n"
"restore\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"

#. type: Plain text
#: text/chapter12.md:282
msgid ""
"The `save` action pushes the current state of the context (including the "
"current transformation and any styles) onto the stack, and the `restore` "
"action pops the top state from the stack and restores it."
msgstr ""
"`save`動作は現在の文脈の状態（現在の変換行列や描画スタイル）をスタックにプッ"
"シュし、`restore`動作はスタックの一番上の状態をポップし、文脈の状態を復元しま"
"す。"

#. type: Plain text
#: text/chapter12.md:284
msgid ""
"This allows us to save the current state, apply some styles and "
"transformations, render some primitives, and finally restore the original "
"transformation and state. For example, the following function performs some "
"canvas action but applies a rotation before doing so and restores the "
"transformation afterwards:"
msgstr ""
"これらの動作により、現在の状態を保存し、いろいろなスタイルや変換を適用してか"
"ら原始的な図形を描画し、最後に元の変換と状態を復元できます。\n"
"例えば次の関数は幾つかのキャンバス動作を実行しますが、その前に回転を適用し、"
"その後に変換を復元します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:285
#, no-wrap
msgid ""
"rotated ctx render = do\n"
"  save ctx\n"
"  rotate (Math.tau / 3.0) ctx\n"
"  render\n"
"  restore ctx\n"
msgstr ""
"rotated ctx render = do\n"
"  save ctx\n"
"  rotate (Math.tau / 3.0) ctx\n"
"  render\n"
"  restore ctx\n"

#. type: Plain text
#: text/chapter12.md:294
msgid ""
"In the interest of abstracting over common use cases using higher-order "
"functions, the `canvas` library provides the `withContext` function, which "
"performs some canvas action while preserving the original context state:"
msgstr ""
"こういったよくある高階関数の使われ方の抽象化として、`canvas`ライブラリでは元"
"の文脈状態を保存しつつ幾つかのキャンバス動作を実行する`withContext`関数が提供"
"されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:295
#, no-wrap
msgid ""
"withContext\n"
"  :: Context2D\n"
"  -> Effect a\n"
"  -> Effect a\n"
msgstr ""
"withContext\n"
"  :: Context2D\n"
"  -> Effect a\n"
"  -> Effect a\n"

#. type: Plain text
#: text/chapter12.md:303
msgid ""
"We could rewrite the `rotated` function above using `withContext` as follows:"
msgstr ""
"`withContext`を使うと、先ほどの `rotated`関数を次のように書き換えることができ"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:304
#, no-wrap
msgid ""
"rotated ctx render =\n"
"  withContext ctx do\n"
"    rotate (Math.tau / 3.0) ctx\n"
"    render\n"
msgstr ""
"rotated ctx render =\n"
"  withContext ctx do\n"
"    rotate (Math.tau / 3.0) ctx\n"
"    render\n"

#. type: Title ##
#: text/chapter12.md:311
#, no-wrap
msgid "Global Mutable State"
msgstr "大域的な変更可能状態"

#. type: Plain text
#: text/chapter12.md:314
msgid ""
"In this section, we'll use the `refs` package to demonstrate another effect "
"in the `Effect` monad."
msgstr ""
"この節では `refs`パッケージを使って `Effect`モナドの別の作用について実演して"
"みます。"

#. type: Plain text
#: text/chapter12.md:316
msgid ""
"The `Effect.Ref` module provides a type constructor for global mutable "
"references and an associated effect:"
msgstr ""
"`Effect.Ref`モジュールでは、大域的に変更可能な参照のための型構築子、及びそれ"
"に紐付く作用を提供します。"

#. type: Fenced code block (text)
#: text/chapter12.md:317
#, no-wrap
msgid ""
"> import Effect.Ref\n"
"\n"
"> :kind Ref\n"
"Type -> Type\n"
msgstr ""
"> import Effect.Ref\n"
"\n"
"> :kind Ref\n"
"Type -> Type\n"

#. type: Plain text
#: text/chapter12.md:325
msgid ""
"A value of type `Ref a` is a mutable reference cell containing a value of "
"type `a`, used to track global mutation. As such, it should be used "
"sparingly."
msgstr ""
"型`Ref a`の値は型`a`の値を含む可変参照セルであり、大域的な変更を追跡するのに"
"使われます。\n"
"そういったわけでこれは少しだけ使う分に留めておくべきです。"

#. type: Plain text
#: text/chapter12.md:327
msgid ""
"The `Example/Refs.purs` file contains an example that uses a `Ref` to track "
"mouse clicks on the `canvas` element."
msgstr ""
"`Example/Refs.purs`ファイルには `canvas`要素上のマウスクリックを追跡するのに "
"`Ref`を使う例が含まれます。"

#. type: Plain text
#: text/chapter12.md:329
msgid ""
"The code starts by creating a new reference containing the value `0` by "
"using the `new` action:"
msgstr ""
"このコードでは最初に`new`動作を使って値`0`を含む新しい参照を作成しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:330
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:clickCount}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Refs.purs:clickCount}}\n"

#. type: Plain text
#: text/chapter12.md:335
msgid ""
"Inside the click event handler, the `modify` action is used to update the "
"click count, and the updated value is returned."
msgstr ""
"クリックイベント制御子の内部では、`modify`動作を使用してクリック数を更新し、"
"更新された値が返されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:336
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:count}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Refs.purs:count}}\n"

#. type: Plain text
#: text/chapter12.md:341
msgid ""
"In the `render` function, the click count is used to determine the "
"transformation applied to a rectangle:"
msgstr "`render`関数ではクリック数に応じた変換を矩形に適用しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:342
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:withContext}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Refs.purs:withContext}}\n"

#. type: Plain text
#: text/chapter12.md:347
msgid ""
"This action uses `withContext` to preserve the original transformation and "
"then applies the following sequence of transformations (remember that "
"transformations are applied bottom-to-top):"
msgstr ""
"この動作では元の変換を保存するために`withContext`を使用しており、それから一連"
"の変換を適用しています（変換が下から上に適用されることを思い出してくださ"
"い）。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid ""
"The rectangle is translated through `(-100, -100)`, so its center lies at "
"the origin."
msgstr "矩形が`(-100, -100)`だけ平行移動し、中心が原点に来ます。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid "The rectangle is scaled around the origin."
msgstr "矩形が原点を中心に拡大されます。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid ""
"The rectangle is rotated through some multiple of `10` degrees around the "
"origin."
msgstr "矩形が原点を中心に`10`の倍数分の角度で回転します。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid ""
"The rectangle is translated through `(300, 300)`, so its center lies at the "
"center of the canvas."
msgstr "矩形が`(300, 300)`だけ平行移動し、中心がキャンバスの中心に来ます。"

#. type: Plain text
#: text/chapter12.md:354
msgid "Build the example:"
msgstr "このコード例をビルドしてみましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:355
#, no-wrap
msgid "$ spago bundle-app --main Example.Refs --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Refs --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:360
msgid ""
"and open the `html/index.html` file. If you click the canvas repeatedly, you "
"should see a green rectangle rotating around the center of the canvas."
msgstr ""
"`html/index.html`ファイルを開いてみましょう。\n"
"緑の四角形が表示され、何度かキャンバスをクリックするとキャンバスの中心の周り"
"で回転するはずです。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
msgid ""
"(Easy) Write a higher-order function that simultaneously strokes and fills a "
"path. Rewrite the `Random.purs` example using your function."
msgstr ""
"（簡単）パスの線描と塗り潰しを同時に行う高階関数を書いてください。\n"
"その関数を使用して`Random.purs`の例を書き直してください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
msgid ""
"(Medium) Use `Random` and `Dom` to create an application that renders a "
"circle with random position, color, and radius to the canvas when the mouse "
"is clicked."
msgstr ""
"（普通）`Random`作用と`Dom`作用を使用して、マウスがクリックされたときに、キャ"
"ンバスに無作為な位置、色、半径の円を描画するアプリケーションを作成してくださ"
"い。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
msgid ""
"(Medium) Write a function that transforms the scene by rotating it around a "
"point with specified coordinates. _Hint_: use a translation to first "
"translate the scene to the origin."
msgstr ""
"（普通）指定された座標の点を中心として回転させることでシーンを変換する関数を"
"書いてください。\n"
"*手掛かり*：変換を使い、最初にシーンを原点まで平行移動しましょう。"

#. type: Title ##
#: text/chapter12.md:367
#, no-wrap
msgid "L-Systems"
msgstr "L-System"

#. type: Plain text
#: text/chapter12.md:370
msgid ""
"In this final example, we will use the `canvas` package to write a function "
"for rendering _L-systems_ (or _Lindenmayer systems_)."
msgstr ""
"この章の最後の例として、 `canvas`パッケージを使用して*L-system*（またの名を"
"*Lindenmayer system*）を描画する関数を記述します。"

#. type: Plain text
#: text/chapter12.md:372
msgid ""
"An L-system is defined by an _alphabet_, an initial sequence of letters from "
"the alphabet, and a set of _production rules_. Each production rule takes a "
"letter of the alphabet and returns a sequence of replacement letters. This "
"process is iterated some number of times, starting with the initial sequence "
"of letters."
msgstr ""
"1つのL-Systemは*アルファベット*、つまりアルファベット由来の文字の初期の並び"
"と、*生成規則*の集合で定義されます。\n"
"各生成規則は、アルファベットの文字を取り、それを置き換える文字の並びを返しま"
"す。\n"
"この処理は文字の初期の並びから始まり、複数回繰り返されます。"

#. type: Plain text
#: text/chapter12.md:374
msgid ""
"If each letter of the alphabet is associated with some instruction to "
"perform on the canvas, the L-system can be rendered by following the "
"instructions in order."
msgstr ""
"もしアルファベットの各文字がキャンバス上で実行される命令と対応付けられていれ"
"ば、その指示に順番に従うことでL-Systemを描画できます。"

#. type: Plain text
#: text/chapter12.md:376
msgid ""
"For example, suppose the alphabet consists of the letters `L` (turn left), "
"`R` (turn right), and `F` (move forward). We might define the following "
"production rules:"
msgstr ""
"例えばアルファベットが文字`L`（左回転）、`R`（右回転）、`F`（前進）で構成され"
"ているとします。\n"
"次のような生成規則を定義できます。"

#. type: Fenced code block (text)
#: text/chapter12.md:377
#, no-wrap
msgid ""
"L -> L\n"
"R -> R\n"
"F -> FLFRRFLF\n"
msgstr ""
"L -> L\n"
"R -> R\n"
"F -> FLFRRFLF\n"

#. type: Plain text
#: text/chapter12.md:384
msgid ""
"If we start with the initial sequence \"FRRFRRFRR\" and iterate, we obtain "
"the following sequence:"
msgstr ""
"配列 \"FRRFRRFRR\" から始めて処理を繰り返すと、次のような経過を辿ります。"

#. type: Fenced code block (text)
#: text/chapter12.md:385
#, no-wrap
msgid ""
"FRRFRRFRR\n"
"FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR\n"
"FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...\n"
msgstr ""
"FRRFRRFRR\n"
"FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR\n"
"FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...\n"

#. type: Plain text
#: text/chapter12.md:392
msgid ""
"and so on. Plotting a piecewise-linear path corresponding to this set of "
"instructions approximates the _Koch curve_. Increasing the number of "
"iterations increases the resolution of the curve."
msgstr ""
"というように続きます。\n"
"この命令群に対応する線分パスをプロットすると、*コッホ曲線*に近似されます。\n"
"反復回数を増やすと、曲線の解像度が増していきます。"

#. type: Plain text
#: text/chapter12.md:394
msgid "Let's translate this into the language of types and functions."
msgstr "それでは型と関数のある言語へとこれを翻訳してみましょう。"

#. type: Plain text
#: text/chapter12.md:396
msgid "We can represent our alphabet of letters with the following ADT:"
msgstr "アルファベットの文字は以下のADTで表現できます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:397
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:letter}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:letter}}\n"

#. type: Plain text
#: text/chapter12.md:402
msgid ""
"This data type defines one data constructor for each letter in our alphabet."
msgstr ""
"このデータ型では、アルファベットの文字ごとに1つずつデータ構築子が定義されてい"
"ます。"

#. type: Plain text
#: text/chapter12.md:404
msgid ""
"How can we represent the initial sequence of letters? Well, that's just an "
"array of letters from our alphabet, which we will call a `Sentence`:"
msgstr ""
"文字の初期配列はどのように表したらいいでしょうか。\n"
"単なるアルファベットの配列でいいでしょう。\n"
"これを `Sentence`と呼ぶことにします。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:405
#, no-wrap
msgid ""
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:sentence}}\n"
"\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:initial}}\n"
msgstr ""
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:sentence}}\n"
"\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:initial}}\n"

#. type: Plain text
#: text/chapter12.md:412
msgid ""
"Our production rules can be represented as a function from `Letter` to "
"`Sentence` as follows:"
msgstr ""
"生成規則は以下のように`Letter`から `Sentence`への関数として表すことができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:413
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:productions}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:productions}}\n"

#. type: Plain text
#: text/chapter12.md:418
msgid "This is just copied straight from the specification above."
msgstr "これはまさに上記の仕様をそのまま書き写したものです。"

#. type: Plain text
#: text/chapter12.md:420
msgid ""
"Now we can implement a function `lsystem` that will take a specification in "
"this form and render it to the canvas. What type should `lsystem` have? "
"Well, it needs to take values like `initial` and `productions` as arguments, "
"as well as a function that can render a letter of the alphabet to the canvas."
msgstr ""
"これで、この形式の仕様を受け取ってキャンバスに描画する関数`lsystem`を実装でき"
"ます。\n"
"`lsystem`はどのような型を持っているべきでしょうか。\n"
"`initial`や`productions`のような値だけでなく、アルファベットの文字をキャンバ"
"スに描画できる関数を引数に取る必要があります。"

#. type: Plain text
#: text/chapter12.md:422
msgid "Here is a first approximation to the type of `lsystem`:"
msgstr "`lsystem`の型の最初の大まかな設計は以下です。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:423
#, no-wrap
msgid ""
"Sentence\n"
"-> (Letter -> Sentence)\n"
"-> (Letter -> Effect Unit)\n"
"-> Int\n"
"-> Effect Unit\n"
msgstr ""
"Sentence\n"
"-> (Letter -> Sentence)\n"
"-> (Letter -> Effect Unit)\n"
"-> Int\n"
"-> Effect Unit\n"

#. type: Plain text
#: text/chapter12.md:432
msgid ""
"The first two argument types correspond to the values `initial` and "
"`productions`."
msgstr "最初の2つの引数の型は、値 `initial`と `productions`に対応しています。"

#. type: Plain text
#: text/chapter12.md:434
msgid ""
"The third argument represents a function that takes a letter of the alphabet "
"and _interprets_ it by performing some actions on the canvas. In our "
"example, this would mean turning left in the case of the letter `L`, turning "
"right in the case of the letter `R`, and moving forward in the case of a "
"letter `F`."
msgstr ""
"3番目の引数は、アルファベットの文字を取り、キャンバス上の幾つかの動作を実行す"
"ることによって*解釈*する関数を表します。\n"
"この例では、文字`L`は左回転、文字`R`で右回転、文字`F`は前進を意味します。"

#. type: Plain text
#: text/chapter12.md:436
msgid ""
"The final argument is a number representing the number of iterations of the "
"production rules we would like to perform."
msgstr "最後の引数は、実行したい生成規則の繰り返し回数を表す数です。"

#. type: Plain text
#: text/chapter12.md:438
msgid ""
"The first observation is that the `lsystem` function should work for only "
"one type of `Letter`, but for any type, so we should generalize our type "
"accordingly. Let's replace `Letter` and `Sentence` with `a` and `Array a` "
"for some quantified type variable `a`:"
msgstr ""
"最初に気付くことは、この`lsystem`関数は1つの型`Letter`に対してのみ動作するの"
"ですが、どんなアルファベットについても機能すべきですから、この型はもっと一般"
"化されるべきです。\n"
"それでは、量子化された型変数 `a`について、`Letter`と `Sentence`を `a`と "
"`Array a`で置き換えましょう。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:439
#, no-wrap
msgid ""
"forall a. Array a\n"
"          -> (a -> Array a)\n"
"          -> (a -> Effect Unit)\n"
"          -> Int\n"
"          -> Effect Unit\n"
msgstr ""
"forall a. Array a\n"
"          -> (a -> Array a)\n"
"          -> (a -> Effect Unit)\n"
"          -> Int\n"
"          -> Effect Unit\n"

#. type: Plain text
#: text/chapter12.md:448
msgid ""
"The second observation is that, to implement instructions like \"turn left\" "
"and \"turn right\", we will need to maintain some state, namely the "
"direction in which the path is moving at any time. We need to modify our "
"function to pass the state through the computation. Again, the `lsystem` "
"function should work for any type of state, so we will represent it using "
"the type variable `s`."
msgstr ""
"次に気付くこととしては、「左回転」と「右回転」のような命令を実装するために"
"は、幾つかの状態を管理する必要があります。\n"
"具体的に言えば、その時点でパスが動いている方向を状態として持たなければなりま"
"せん。\n"
"計算を通じて状態を渡すように関数を変更する必要があります。\n"
"ここでも`lsystem`関数は状態がどんな型でも動作したほうがよいので、型変数`s`を"
"使用してそれを表しています。"

#. type: Plain text
#: text/chapter12.md:450
msgid "We need to add the type `s` in three places:"
msgstr "型 `s`を追加する必要があるのは3箇所で、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:451
#, no-wrap
msgid ""
"forall a s. Array a\n"
"            -> (a -> Array a)\n"
"            -> (s -> a -> Effect s)\n"
"            -> Int\n"
"            -> s\n"
"            -> Effect s\n"
msgstr ""
"forall a s. Array a\n"
"            -> (a -> Array a)\n"
"            -> (s -> a -> Effect s)\n"
"            -> Int\n"
"            -> s\n"
"            -> Effect s\n"

#. type: Plain text
#: text/chapter12.md:461
msgid ""
"Firstly, the type `s` was added as the type of an additional argument to "
"`lsystem`. This argument will represent the initial state of the L-system."
msgstr ""
"まず追加の引数の型として `lsystem`に型 `s`が追加されています。\n"
"この引数はL-Systemの初期状態を表しています。"

#. type: Plain text
#: text/chapter12.md:463
msgid ""
"The type `s` also appears as an argument to, and as the return type of the "
"interpretation function (the third argument to `lsystem`). The "
"interpretation function will now receive the current state of the L-system "
"as an argument, and will return a new, updated state as its return value."
msgstr ""
"型 `s`は引数にも現れますが、解釈関数（`lsystem`の第3引数）の返り値の型として"
"も現れます。解釈関数は今のところ、引数としてL-Systemの現在の状態を受け取り、"
"返り値として更新された新しい状態を返します。"

#. type: Plain text
#: text/chapter12.md:465
msgid ""
"In the case of our example, we can define use following type to represent "
"the state:"
msgstr "この例の場合では、次のような型を使って状態を表す型を定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:466
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:state}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:state}}\n"

#. type: Plain text
#: text/chapter12.md:471
msgid ""
"The properties `x` and `y` represent the current position of the path, and "
"the `theta` property represents the current direction of the path, specified "
"as the angle between the path direction and the horizontal axis, in radians."
msgstr ""
"プロパティ `x`と `y`はパスの現在の位置を表しています。\n"
"プロパティ`theta`はパスの現在の向きを表しており、ラジアンで表された水平線に対"
"するパスの角度として指定されています。"

#. type: Plain text
#: text/chapter12.md:473
msgid "The initial state of the system might be specified as follows:"
msgstr "システムの初期状態は次のように指定されます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:474
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:initialState}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:initialState}}\n"

#. type: Plain text
#: text/chapter12.md:479
msgid ""
"Now let's try to implement the `lsystem` function. We will find that its "
"definition is remarkably simple."
msgstr ""
"それでは、 `lsystem`関数を実装してみます。定義はとても単純であることがわかる"
"でしょう。"

#. type: Plain text
#: text/chapter12.md:481
msgid ""
"It seems reasonable that `lsystem` should recurse on its fourth argument (of "
"type `Int`). On each step of the recursion, the current sentence will "
"change, having been updated by using the production rules. With that in "
"mind, let's begin by introducing names for the function arguments, and "
"delegating to a helper function:"
msgstr ""
"`lsystem`は第4引数の値（型は`Int`）に応じて再帰するのが良さそうです。\n"
"再帰の各ステップでは、生成規則に従って状態が更新され、現在の文が変化していき"
"ます。\n"
"このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を"
"移譲することから始めましょう。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:482
#, no-wrap
msgid ""
"lsystem :: forall a s\n"
"         . Array a\n"
"        -> (a -> Array a)\n"
"        -> (s -> a -> Effect s)\n"
"        -> Int\n"
"        -> s\n"
"        -> Effect s\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_impl}}\n"
msgstr ""
"lsystem :: forall a s\n"
"         . Array a\n"
"        -> (a -> Array a)\n"
"        -> (s -> a -> Effect s)\n"
"        -> Int\n"
"        -> s\n"
"        -> Effect s\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_impl}}\n"

#. type: Plain text
#: text/chapter12.md:494
msgid ""
"The `go` function works by recursion on its second argument. There are two "
"cases: when `n` is zero and `n` is non-zero."
msgstr ""
"`go`関数は第2引数について再帰することで動作します。\n"
"場合分けは2つであり、`n`がゼロであるときと`n`がゼロでないときです。"

#. type: Plain text
#: text/chapter12.md:496
#, no-wrap
msgid "In the first case, the recursion is complete, and we need to interpret the current sentence according to the interpretation function. We have a sentence of type `Array a`, a state of type `s`, and a function of type `s -> a -> Effect s`. This sounds like a job for the `foldM` function which we defined earlier, and which is available from the `control` package:\n"
msgstr ""
"1つ目の場合は再帰は完了し、解釈関数に応じて現在の文を解釈します。\n"
"型`Array a`の文、型`s`の状態、型`s -> a -> Effect s`の関数があります。\n"
"以前定義した`foldM`の出番のようです。\n"
"この関数は`control`パッケージで手に入ります。\n"

#. type: Fenced code block (haskell)
#: text/chapter12.md:497
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_0}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_0}}\n"

#. type: Plain text
#: text/chapter12.md:502
msgid ""
"What about in the non-zero case? In that case, we can simply apply the "
"production rules to each letter of the current sentence, concatenate the "
"results, and repeat by calling `go` recursively:"
msgstr ""
"ゼロでない場合ではどうでしょうか。\n"
"その場合は、単に生成規則を現在の文のそれぞれの文字に適用して、その結果を連結"
"し、そして再帰的に`go`を呼び出すことによって繰り返します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:503
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_i}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_i}}\n"

#. type: Plain text
#: text/chapter12.md:508
msgid ""
"That's it! Note how using higher-order functions like `foldM` and "
"`concatMap` allowed us to communicate our ideas concisely."
msgstr ""
"これだけです。\n"
"`foldM`や`concatMap`のような高階関数を使うと、アイデアを簡潔に表現できるので"
"す。"

#. type: Plain text
#: text/chapter12.md:510
msgid ""
"However, we're not quite done. The type we have given is actually still too "
"specific. Note that we don't use any canvas operations anywhere in our "
"implementation. Nor do we make use of the structure of the `Effect` monad at "
"all. In fact, our function works for _any_ monad `m`!"
msgstr ""
"しかし、話はこれで終わりではありません。\n"
"ここで与えた型は、実際はまだ特殊化されすぎています。\n"
"この定義ではキャンバスの操作が実装のどこにも使われていないことに注目してくだ"
"さい。\n"
"それに、全く`Effecta`モナドの構造を利用していません。\n"
"実際には、この関数は*どんな*モナド`m`についても動作します。"

#. type: Plain text
#: text/chapter12.md:512
msgid ""
"Here is the more general type of `lsystem`, as specified in the accompanying "
"source code for this chapter:"
msgstr ""
"この章に添付されたソースコードで指定されている`lsystem`の型はもっと一般的に"
"なっています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:513
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_anno}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_anno}}\n"

#. type: Plain text
#: text/chapter12.md:518
msgid ""
"We can understand this type as saying that our interpretation function is "
"free to have any side-effects at all, captured by the monad `m`. It might "
"render to the canvas, print information to the console, or support failure "
"or multiple return values. The reader is encouraged to try writing L-systems "
"that use these various types of side-effect."
msgstr ""
"この型で書かれていることは、この解釈関数はモナド`m`が持つ任意の副作用を完全に"
"自由に持つことができる、ということだと理解できます。\n"
"キャンバスに描画したり、またはコンソールに情報を出力したりするかもしれません"
"し、失敗や複数の戻り値に対応しているかもしれません。\n"
"こういった様々な型の副作用を使ったL-Systemを記述してみることを読者にお勧めし"
"ます。"

#. type: Plain text
#: text/chapter12.md:520
msgid ""
"This function is a good example of the power of separating data from "
"implementation. The advantage of this approach is that we can interpret our "
"data in multiple ways. We might even factor `lsystem` into two smaller "
"functions: the first would build the sentence using repeated application of "
"`concatMap`, and the second would interpret the sentence using `foldM`. This "
"is also left as an exercise for the reader."
msgstr ""
"この関数は実装からデータを分離することの威力を示す良い例となっています。\n"
"この手法の利点は、複数の異なる方法でデータを解釈できることです。\n"
"さらに`lsystem`を2つの小さな関数へと分解できます。\n"
"1つ目は`concatMap`の適用の繰り返しを使って文を構築するもの、2つ目は`foldM`を"
"使って文を解釈するものです。\n"
"これは読者の演習として残しておきます。"

#. type: Plain text
#: text/chapter12.md:522
#, no-wrap
msgid "Let's complete our example by implementing its interpretation function. The type of `lsystem` tells us that its type signature must be `s -> a -> m s` for some types `a` and `s` and a type constructor `m`. We know that we want `a` to be `Letter` and `s` to be `State`, and for the monad `m` we can choose `Effect`. This gives us the following type:\n"
msgstr ""
"それでは解釈関数を実装して、この章の例を完成させましょう。\n"
"`lsystem`の型が教えてくれているのは、型シグネチャが、何らかの型 `a`と `s`、型構築子 `m`について、 `s -> a -> m s`でなければならないということです。\n"
"`a`を `Letter`、 `s`を `State`、モナド `m`を `Effect`というように選びたいということがわかっています。\n"
"これにより次のような型になります。\n"

#. type: Fenced code block (haskell)
#: text/chapter12.md:523
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpret_anno}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpret_anno}}\n"

#. type: Plain text
#: text/chapter12.md:528
msgid ""
"To implement this function, we need to handle the three data constructors of "
"the `Letter` type. To interpret the letters `L` (move left) and `R` (move "
"right), we simply have to update the state to change the angle `theta` "
"appropriately:"
msgstr ""
"この関数を実装するには、 `Letter`型の3つのデータ構築子それぞれについて処理す"
"る必要があります。文字 `L`（左回転）と `R`（右回転）の解釈では、`theta`を適切"
"な角度へ変更するように状態を更新するだけです。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:529
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretLR}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretLR}}\n"

#. type: Plain text
#: text/chapter12.md:534
msgid ""
"To interpret the letter `F` (move forward), we can calculate the new "
"position of the path, render a line segment, and update the state as follows:"
msgstr ""
"文字`F`（前進）を解釈するには、次のようにパスの新しい位置を計算し、線分を描画"
"し、状態を更新します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:535
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretF}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretF}}\n"

#. type: Plain text
#: text/chapter12.md:540
msgid ""
"Note that in the source code for this chapter, the `interpret` function is "
"defined using a `let` binding inside the `main` function, so that the name "
"`ctx` is in scope. It would also be possible to move the context into the "
"`State` type, but this would be inappropriate because it is not a changing "
"part of the state of the system."
msgstr ""
"なお、この章のソースコードでは、名前 `ctx`がスコープに入るように、`interpret`"
"関数は `main`関数内で `let`束縛を使用して定義されています。\n"
"`State`型が文脈を持つように変更できるでしょうが、それはこのシステムの状態の変"
"化する部分ではないので不適切でしょう。"

#. type: Plain text
#: text/chapter12.md:542
msgid "To render this L-system, we can simply use the `strokePath` action:"
msgstr ""
"このL-Systemを描画するには、次のような`strokePath`動作を使用するだけです。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:543
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:strokePath}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:strokePath}}\n"

#. type: Plain text
#: text/chapter12.md:548
msgid "Compile the L-system example using"
msgstr "次のコマンドを使ってL-Systemをコンパイルします。"

#. type: Fenced code block (text)
#: text/chapter12.md:549
#, no-wrap
msgid "$ spago bundle-app --main Example.LSystem --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.LSystem --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:554
msgid ""
"and open `html/index.html`. You should see the Koch curve rendered to the "
"canvas."
msgstr ""
"`html/index.html`を開いてみましょう。\n"
"キャンバスにコッホ曲線が描画されるのがわかると思います。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Easy) Modify the L-system example above to use `fillPath` instead of "
"`strokePath`. _Hint_: you will need to include a call to `closePath`, and "
"move the call to `moveTo` outside of the `interpret` function."
msgstr ""
"（簡単）`strokePath`の代わりに `fillPath`を使用するように、上のL-Systemの例を"
"変更してください。\n"
"*手掛かり*：`closePath`の呼び出しを含め、 `moveTo`の呼び出しを `interpret`関"
"数の外側に移動する必要があります。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Easy) Try changing the various numerical constants in the code to "
"understand their effect on the rendered system."
msgstr ""
"（簡単）描画システムへの影響を理解するために、コード中の様々な数値の定数を変"
"更してみてください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Medium) Break the `lsystem` function into two smaller functions. The first "
"should build the final sentence using repeated application of `concatMap`, "
"and the second should use `foldM` to interpret the result."
msgstr ""
"（普通）`lsystem`関数を2つの小さな関数に分割してください。\n"
"1つ目は`concatMap`の適用の繰り返しを使用して最終的な文を構築するもので、2つ目"
"は `foldM`を使用して結果を解釈するものでなくてはなりません。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Medium) Add a drop shadow to the filled shape using the `setShadowOffsetX`, "
"`setShadowOffsetY`, `setShadowBlur`, and `setShadowColor` actions. _Hint_: "
"use PSCi to find the types of these functions."
msgstr ""
"（普通）`setShadowOffsetX`、`setShadowOffsetY`、`setShadowBlur`、"
"`setShadowColor`動作を使い、塗りつぶされた図形にドロップシャドウを追加してく"
"ださい。\n"
"*手掛かり*：PSCiを使って、これらの関数の型を調べてみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Medium) The angle of the corners is currently a constant (`tau/6`). "
"Instead, it can be moved into the `Letter` data type, which allows it to be "
"changed by the production rules:"
msgstr ""
"（普通）向きを変えるときの角度の大きさは今のところ一定 (`tau/6`) です。\n"
"これに代えて、`Letter`データ型の中に角度を移動させ、生成規則によって変更でき"
"るようにしてください。"

#. type: Plain text
#: text/chapter12.md:565
#, no-wrap
msgid ""
"     ```haskell\n"
"     type Angle = Number\n"
msgstr ""
"     ```haskell\n"
"     type Angle = Number\n"

#. type: Plain text
#: text/chapter12.md:568
#, no-wrap
msgid ""
"     data Letter = L Angle | R Angle | F\n"
"     ```\n"
msgstr ""
"     data Letter = L Angle | R Angle | F\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:571
#, no-wrap
msgid ""
"     How can this new information be used in the production rules to create interesting shapes?\n"
" 1. (Difficult) An L-system is given by an alphabet with four letters: `L` (turn left through 60 degrees), `R` (turn right through 60 degrees), `F` (move forward), and `M` (also move forward).\n"
msgstr ""
"     この新しい情報を生成規則でどう使うと、面白い図形を作ることができるでしょうか。\n"
"1. （難しい）4つの文字からなるアルファベットでL-Systemが与えられたとします。\n"
"   それぞれ`L`（60度左回転）、`R`（60度右回転）、`F`（前進）、`M`（これも前進）です。\n"

#. type: Plain text
#: text/chapter12.md:573
#, no-wrap
msgid "     The initial sentence of the system is the single letter `M`.\n"
msgstr "     このシステムの文の初期状態は、単一の文字 `M`です。\n"

#. type: Plain text
#: text/chapter12.md:575
#, no-wrap
msgid "     The production rules are specified as follows:\n"
msgstr "     このシステムの生成規則は次のように指定されています。\n"

#. type: Plain text
#: text/chapter12.md:582
#, no-wrap
msgid ""
"     ```text\n"
"     L -> L\n"
"     R -> R\n"
"     F -> FLMLFRMRFRMRFLMLF\n"
"     M -> MRFRMLFLMLFLMRFRM\n"
"     ```\n"
msgstr ""
"     ```text\n"
"     L -> L\n"
"     R -> R\n"
"     F -> FLMLFRMRFRMRFLMLF\n"
"     M -> MRFRMLFLMLFLMRFRM\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:584
#, no-wrap
msgid "     Render this L-system. _Note_: you will need to decrease the number of iterations of the production rules since the size of the final sentence grows exponentially with the number of iterations.\n"
msgstr ""
"     このL-Systemを描画してください。\n"
"     *補足*：最後の文のサイズは反復回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を削減する必要があります。\n"

#. type: Plain text
#: text/chapter12.md:586
#, no-wrap
msgid "     Now, notice the symmetry between `L` and `M` in the production rules. The two \"move forward\" instructions can be differentiated using a `Boolean` value using the following alphabet type:\n"
msgstr "     ここで、生成規則における `L`と `M`の間の対称性に注目してください。2つの「前進」命令は、次のようなアルファベット型を使用すると、`Boolean`値を使って区別できます。\n"

#. type: Plain text
#: text/chapter12.md:590
#, no-wrap
msgid ""
"     ```haskell\n"
"     data Letter = L | R | F Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data Letter = L | R | F Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:593
#, no-wrap
msgid ""
"     Implement this L-system again using this representation of the alphabet.\n"
" 1. (Difficult) Use a different monad `m` in the interpretation function. You might try using `Effect.Console` to write the L-system onto the console, or using `Effect.Random` to apply random \"mutations\" to the state type.\n"
msgstr ""
"    このアルファベットの表現を使用して、もう一度このL-Systemを実装してください。\n"
"1. （難しい）解釈関数で別のモナド `m`を使ってみましょう。`Effect.Console`作用を利用してコンソール上にL-Systemを出力したり、`Random`作用を利用して状態の型に無作為の「突然変異」を適用したりしてみてください。\n"

#. type: Plain text
#: text/chapter12.md:597
msgid ""
"In this chapter, we learned how to use the HTML5 Canvas API from PureScript "
"by using the `canvas` library. We also saw a practical demonstration of many "
"techniques we have learned already: maps and folds, records and row "
"polymorphism, and the `Effect` monad for handling side-effects."
msgstr ""
"この章では、`canvas`ライブラリを使用することにより、PureScriptからHTML5 "
"Canvas APIを使う方法について学びました。\n"
"また、これまで学んできた多くの手法からなる実用的な実演を見ました。\n"
"マップや畳み込み、レコードと行多相、副作用を扱うための`Effect`モナドです。"

#. type: Plain text
#: text/chapter12.md:599
msgid ""
"The examples also demonstrated the power of higher-order functions and "
"_separating data from implementation_. It would be possible to extend these "
"ideas to completely separate the representation of a scene from its "
"rendering function, using an algebraic data type, for example:"
msgstr ""
"この章の例では、高階関数の威力を示すとともに、 _実装からのデータの分離_ も実"
"演してみせました。これは例えば、代数データ型を使用してこれらの概念を次のよう"
"に拡張し、描画関数からシーンの表現を完全に分離できるようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:600
#, no-wrap
msgid ""
"data Scene\n"
"  = Rect Rectangle\n"
"  | Arc Arc\n"
"  | PiecewiseLinear (Array Point)\n"
"  | Transformed Transform Scene\n"
"  | Clipped Rectangle Scene\n"
"  | ...\n"
msgstr ""
"data Scene\n"
"  = Rect Rectangle\n"
"  | Arc Arc\n"
"  | PiecewiseLinear (Array Point)\n"
"  | Transformed Transform Scene\n"
"  | Clipped Rectangle Scene\n"
"  | ...\n"

#. type: Plain text
#: text/chapter12.md:611
msgid ""
"This approach is taken in the `drawing` package, and it brings the "
"flexibility of manipulating the scene as data in various ways before "
"rendering."
msgstr ""
"この手法は`drawing`パッケージで取られており、描画前に様々な方法でシーンをデー"
"タとして操作できる柔軟性を齎しています。"

#. type: Plain text
#: text/chapter12.md:612
msgid ""
"For examples of games rendered to the canvas, see the \"Behavior\" and "
"\"Signal\" recipes in the [cookbook](https://github.com/JordanMartinez/"
"purescript-cookbook/blob/master/README.md#recipes)."
msgstr ""
"キャンバスに描画されるゲームの例については[cookbook](https://github.com/"
"JordanMartinez/purescript-cookbook/blob/master/README.md#recipes)の"
"「Behavior」と「Signal」のレシピを見てください。"

#. type: Title #
#: text/chapter13.md:1
#, no-wrap
msgid "Generative Testing"
msgstr "テストの自動生成"

#. type: Plain text
#: text/chapter13.md:6
msgid ""
"In this chapter, we will see a particularly elegant application of type "
"classes to the problem of testing. Instead of testing our code by telling "
"the compiler _how_ to test, we simply assert _what_ properties our code "
"should have. Test cases can be generated randomly from this specification, "
"using type classes to hide the boilerplate code of random data generation. "
"This is called _generative testing_ (or _property-based testing_), a "
"technique made popular by the [QuickCheck](https://wiki.haskell.org/"
"Introduction_to_QuickCheck1) library in Haskell."
msgstr ""
"この章では、テスティングの問題に対する、型クラスの特に洗練された応用について"
"示します。\n"
"*どのように*テストするのかをコンパイラに教えるのではなく、コードが*どのような"
"*性質を持っているべきかを教えることでテストします。\n"
"型クラスを使って無作為データ生成のための紋切り型なコードを書かずして、テスト"
"項目を仕様から無作為に生成できます。\n"
"これは*生成的テスティング*（generative testing、または*property-based "
"testing*）と呼ばれ、Haskellの[QuickCheck](http://wiki.haskell.org/"
"Introduction_to_QuickCheck1)ライブラリによって普及した手法です。"

#. type: Plain text
#: text/chapter13.md:8
msgid ""
"The `quickcheck` package is a port of Haskell's QuickCheck library to "
"PureScript, and for the most part, it preserves the types and syntax of the "
"original library. We will see how to use `quickcheck` to test a simple "
"library, using Spago to integrate our test suite into our development "
"process."
msgstr ""
"`quickcheck`パッケージはHaskellのQuickCheckライブラリをPureScriptにポーティン"
"グしたもので、型や構文はもとのライブラリとほとんど同じようになっています。 "
"`quickcheck`を使って簡単なライブラリをテストし、Spagoでテストスイートを自動化"
"されたビルドに統合する方法を見ていきます。"

#. type: Plain text
#: text/chapter13.md:12
msgid "This chapter's project adds `quickcheck` as a dependency."
msgstr "この章のプロジェクトには依存関係として `quickcheck`が追加されます。"

#. type: Plain text
#: text/chapter13.md:14
msgid ""
"In a Spago project, test sources should be placed in the `test` directory, "
"and the main module for the test suite should be named `Test.Main`. The test "
"suite can be run using the `spago test` command."
msgstr ""
"Spagoプロジェクトでは、テストソースは `test`ディレクトリに置かれ、テストス"
"イートのメインモジュールは `Test.Main`と名づけられます。 テストスイートは、 "
"`spago test`コマンドを使用して実行できます。"

#. type: Title ##
#: text/chapter13.md:15
#, no-wrap
msgid "Writing Properties"
msgstr "性質を書く"

#. type: Plain text
#: text/chapter13.md:18
msgid ""
"The `Merge` module implements a simple function `merge`, which we will use "
"to demonstrate the features of the `quickcheck` library."
msgstr ""
"`Merge`モジュールでは簡単な関数 `merge`が実装されています。\n"
"これを`quickcheck`ライブラリの機能を実演するために使っていきます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:19
#, no-wrap
msgid "merge :: Array Int -> Array Int -> Array Int\n"
msgstr "merge :: Array Int -> Array Int -> Array Int\n"

#. type: Plain text
#: text/chapter13.md:24
msgid ""
"`merge` takes two sorted arrays of integers and merges their elements so "
"that the result is also sorted. For example:"
msgstr ""
"`merge`は2つの整列された整数の配列を取って、結果が整列されるように要素を統合"
"します。\n"
"例えば次のようになります。"

#. type: Fenced code block (text)
#: text/chapter13.md:25
#, no-wrap
msgid ""
"> import Merge\n"
"> merge [1, 3, 5] [2, 4, 5]\n"
"\n"
"[1, 2, 3, 4, 5, 5]\n"
msgstr ""
"> import Merge\n"
"> merge [1, 3, 5] [2, 4, 5]\n"
"\n"
"[1, 2, 3, 4, 5, 5]\n"

#. type: Plain text
#: text/chapter13.md:33
msgid ""
"In a typical test suite, we might test `merge` by generating a few small "
"test cases like this by hand and asserting that the results were equal to "
"the appropriate values. However, everything we need to know about the "
"`merge` function can be summarized by this property:"
msgstr ""
"典型的なテストスイートでは、手作業でこのような小さなテスト項目を幾つも作成"
"し、結果が正しい値と等しいことを確認することでテストを実施します。\n"
"しかし、`merge`関数について知る必要があるものは全て、この性質に要約できます。"

#. type: Bullet: '- '
#: text/chapter13.md:35
msgid ""
"If `xs` and `ys` are sorted, then `merge xs ys` is the sorted result of both "
"arrays appended together."
msgstr ""
"`xs`と`ys`が整列済みなら、`merge xs ys`は両方の配列が一緒に結合されて整列され"
"た結果になります。"

#. type: Plain text
#: text/chapter13.md:37
msgid ""
"`quickcheck` allows us to test this property directly by generating random "
"test cases. We state the properties we want our code to have as functions. "
"In this case, we have a single property:"
msgstr ""
"`quickcheck`では、無作為なテスト項目を生成することで、直接この性質をテストで"
"きます。\n"
"コードが持つべき性質を関数として述べるだけです。\n"
"この場合は1つの性質があります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:38
#, no-wrap
msgid ""
"main = do\n"
"  quickCheck \\xs ys ->\n"
"    eq (merge (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"main = do\n"
"  quickCheck \\xs ys ->\n"
"    eq (merge (sort xs) (sort ys)) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:45
msgid ""
"When we run this code, `quickcheck` will attempt to disprove the properties "
"we claimed by generating random inputs `xs` and `ys` and passing them to our "
"functions. If our function returns `false` for any inputs, the property will "
"be incorrect, and the library will raise an error. Fortunately, the library "
"is unable to disprove our properties after generating 100 random test cases:"
msgstr ""
"このコードを実行すると、`quickcheck`は無作為な入力`xs`と`ys`を生成してこの関"
"数に渡すことで、主張した性質を反証しようとします。\n"
"何らかの入力に対して関数が`false`を返した場合、性質は正しくなく、ライブラリは"
"エラーを発生させます。\n"
"幸いなことに、次のように100個の無作為なテスト項目を生成しても、ライブラリはこ"
"の性質を反証できません。"

#. type: Fenced code block (text)
#: text/chapter13.md:46
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Installation complete.\n"
"Build succeeded.\n"
"100/100 test(s) passed.\n"
"...\n"
"Tests succeeded.\n"
msgstr ""
"$ spago test\n"
"\n"
"Installation complete.\n"
"Build succeeded.\n"
"100/100 test(s) passed.\n"
"...\n"
"Tests succeeded.\n"

#. type: Plain text
#: text/chapter13.md:57
msgid ""
"If we deliberately introduce a bug into the `merge` function (for example, "
"by changing the less-than check for a greater-than check), then an exception "
"is thrown at runtime after the first failed test case:"
msgstr ""
"もし `merge`関数に意図的にバグを混入した場合（例えば、大なりのチェックを小な"
"りのチェックへと変更するなど）、最初に失敗したテスト項目の後で例外が実行時に"
"投げられます。"

#. type: Fenced code block (text)
#: text/chapter13.md:58
#, no-wrap
msgid ""
"Error: Test 1 failed:\n"
"Test returned false\n"
msgstr ""
"Error: Test 1 failed:\n"
"Test returned false\n"

#. type: Plain text
#: text/chapter13.md:64
msgid ""
"As we can see, this error message is not very helpful, but it can be "
"improved with a little work."
msgstr ""
"見ての通りこのエラー文言ではあまり役に立ちませんが、少し工夫するだけで改良で"
"きます。"

#. type: Title ##
#: text/chapter13.md:65
#, no-wrap
msgid "Improving Error Messages"
msgstr "エラー文言の改善"

#. type: Plain text
#: text/chapter13.md:68
#, no-wrap
msgid "To provide error messages along with our failed test cases, `quickcheck` provides the `<?>` operator. Simply separate the property definition from the error message using `<?>`, as follows:\n"
msgstr ""
"テスト項目が失敗した時に同時にエラー文言を提供する上で、`quickcheck`は`<?>`演算子を提供しています。\n"
"次のように性質の定義とエラー文言を`<?>`で区切って書くだけです。\n"

#. type: Fenced code block (haskell)
#: text/chapter13.md:69
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  let\n"
"    result = merge (sort xs) (sort ys)\n"
"    expected = sort $ xs <> ys\n"
"  in\n"
"    eq result expected <?> \"Result:\\n\" <> show result <> \"\\nnot equal to expected:\\n\" <> show expected\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  let\n"
"    result = merge (sort xs) (sort ys)\n"
"    expected = sort $ xs <> ys\n"
"  in\n"
"    eq result expected <?> \"Result:\\n\" <> show result <> \"\\nnot equal to expected:\\n\" <> show expected\n"

#. type: Plain text
#: text/chapter13.md:79
msgid ""
"This time, if we modify the code to introduce a bug, we see our improved "
"error message after the first failed test case:"
msgstr ""
"このとき、もしバグを混入するようにコードを変更すると、最初のテスト項目が失敗"
"したときに改良されたエラー文言が表示されます。"

#. type: Fenced code block (text)
#: text/chapter13.md:80
#, no-wrap
msgid ""
"Error: Test 1 (seed 534161891) failed:\n"
"Result:\n"
"[-822215,-196136,-116841,618343,887447,-888285]\n"
"not equal to expected:\n"
"[-888285,-822215,-196136,-116841,618343,887447]\n"
msgstr ""
"Error: Test 1 (seed 534161891) failed:\n"
"Result:\n"
"[-822215,-196136,-116841,618343,887447,-888285]\n"
"not equal to expected:\n"
"[-888285,-822215,-196136,-116841,618343,887447]\n"

#. type: Plain text
#: text/chapter13.md:89
msgid ""
"Notice how the input `xs` and `ys` were generated as arrays of randomly-"
"selected integers."
msgstr ""
"入力 `xs`が無作為に選ばれた数の配列として生成されていることに注目してくださ"
"い。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:94
msgid ""
"(Easy) Write a property that asserts that merging an array with an empty one "
"does not modify the original array. _Note_: This new property is redundant "
"since this situation is already covered by our existing property. We're just "
"trying to give readers a simple way to practice using quickCheck."
msgstr ""
"（簡単）配列に空の配列を統合しても元の配列は変更されないことを確かめる性質を"
"書いてください。\n"
"*補足*：この新しい性質は冗長です。\n"
"というのもこの状況は既に既存の性質で押さえられているからです。\n"
"ここでは読者がQuickCheckを使う練習のための簡単なやり方を示そうとしているだけ"
"です。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:94
msgid ""
"(Easy) Add an appropriate error message to the remaining property for "
"`merge`."
msgstr ""
"（簡単）`merge`の残りの性質に対して、適切なエラー文言を追加してください。"

#. type: Title ##
#: text/chapter13.md:95
#, no-wrap
msgid "Testing Polymorphic Code"
msgstr "多相的なコードのテスト"

#. type: Plain text
#: text/chapter13.md:98
msgid ""
"The `Merge` module defines a generalization of the `merge` function, called "
"`mergePoly`, which works not only with arrays of numbers, but also arrays of "
"any type belonging to the `Ord` type class:"
msgstr ""
"`Merge`モジュールでは、数の配列だけでなく、 `Ord`型クラスに属するどんな型の配"
"列に対しても動作する、 `merge`関数を一般化した `mergePoly`という関数が定義さ"
"れています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:99
#, no-wrap
msgid "mergePoly :: forall a. Ord a => Array a -> Array a -> Array a\n"
msgstr "mergePoly :: forall a. Ord a => Array a -> Array a -> Array a\n"

#. type: Plain text
#: text/chapter13.md:104
msgid ""
"If we modify our original test to use `mergePoly` in place of `merge`, we "
"see the following error message:"
msgstr ""
"`merge`の代わりに `mergePoly`を使うように元のテストを変更すると、次のようなエ"
"ラー文言が表示されます。"

#. type: Fenced code block (text)
#: text/chapter13.md:105
#, no-wrap
msgid ""
"No type class instance was found for\n"
"\n"
"  Test.QuickCheck.Arbitrary.Arbitrary t0\n"
"\n"
"The instance head contains unknown type variables.\n"
"Consider adding a type annotation.\n"
msgstr ""
"No type class instance was found for\n"
"\n"
"  Test.QuickCheck.Arbitrary.Arbitrary t0\n"
"\n"
"The instance head contains unknown type variables.\n"
"Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter13.md:115
msgid ""
"This error message indicates that the compiler could not generate random "
"test cases because it did not know what type of elements we wanted our "
"arrays to have. In these sorts of cases, we can use type annotations to "
"force the compiler to infer a particular type, such as `Array Int`:"
msgstr ""
"このエラー文言は、配列に持たせたい要素の型が何なのかわからないので、コンパイ"
"ラが無作為なテスト項目を生成できなかったということを示しています。\n"
"このような場合、型註釈を使ってコンパイラが特定の型を推論するように強制できま"
"す。\n"
"例えば`Array Int`などです。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:116
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:122
msgid ""
"We can alternatively use a helper function to specify the type, which may "
"result in cleaner code. For example, if we define a function `ints` as a "
"synonym for the identity function:"
msgstr ""
"代替案として型を指定する補助関数を使うこともできます。\n"
"こうするとより見通しのよいコードになることがあります。\n"
"例えば同値関数の同義語として関数`ints`を定義したとしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:123
#, no-wrap
msgid ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"
msgstr ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"

#. type: Plain text
#: text/chapter13.md:129
msgid ""
"then we can modify our test so that the compiler infers the type `Array Int` "
"for our two array arguments:"
msgstr ""
"それから、コンパイラが引数の2つの配列の型 `Array Int`を推論するように、テスト"
"を変更します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:130
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:136
msgid ""
"Here, `xs` and `ys` have type `Array Int` since the `ints` function has been "
"used to disambiguate the unknown type."
msgstr ""
"ここで、`ints`関数が不明な型の曖昧さを解消するために使われているため、`xs`と"
"`ys`は型`Array Int`を持っています。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:141
msgid ""
"(Easy) Write a function `bools` that forces the types of `xs` and `ys` to be "
"`Array Boolean`, and add additional properties that test `mergePoly` at that "
"type."
msgstr ""
"（簡単）`xs`と`ys`の型を`Array Boolean`に強制する関数`bools`を書き、"
"`mergePoly`をその型でテストする性質を追加してください。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:141
msgid ""
"(Medium) Choose a pure function from the core libraries (for example, from "
"the `arrays` package), and write a QuickCheck property for it, including an "
"appropriate error message. Your property should use a helper function to fix "
"any polymorphic type arguments to either `Int` or `Boolean`."
msgstr ""
"（普通）標準関数から（例えば`arrays`パッケージから）1つ関数を選び、適切なエ"
"ラー文言を含めてQuickCheckの性質を書いてください。\n"
"その性質は、補助関数を使って多相型引数を `Int`か `Boolean`のどちらかに固定し"
"なければいけません。"

#. type: Title ##
#: text/chapter13.md:142
#, no-wrap
msgid "Generating Arbitrary Data"
msgstr "任意のデータの生成"

#. type: Plain text
#: text/chapter13.md:145
msgid ""
"Now we will see how the `quickcheck` library can randomly generate test "
"cases for our properties."
msgstr ""
"それでは`quickcheck`ライブラリが性質に対するテスト項目をどのように無作為に生"
"成できているのかを見ていきます。"

#. type: Plain text
#: text/chapter13.md:147
msgid ""
"Those types whose values can be randomly generated are captured by the "
"`Arbitrary` type class:"
msgstr ""
"無作為に値を生成できるような型は、次のような型クラス `Arbitary`のインスタンス"
"を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:148
#, no-wrap
msgid ""
"class Arbitrary t where\n"
"  arbitrary :: Gen t\n"
msgstr ""
"class Arbitrary t where\n"
"  arbitrary :: Gen t\n"

#. type: Plain text
#: text/chapter13.md:154
msgid ""
"The `Gen` type constructor represents the side-effects of _deterministic "
"random data generation_. It uses a pseudo-random number generator to "
"generate deterministic random function arguments from a seed value. The "
"`Test.QuickCheck.Gen` module defines several useful combinators for building "
"generators."
msgstr ""
"`Gen`型構築子は*決定的無作為データ生成*の副作用を表しています。\n"
"決定的無作為データ生成は、擬似乱数生成器を使って、シード値から決定的無作為関"
"数の引数を生成します。\n"
"`Test.QuickCheck.Gen`モジュールは、生成器を構築するための幾つかの有用なコンビ"
"ネータを定義しています。"

#. type: Plain text
#: text/chapter13.md:156
msgid ""
"`Gen` is also a monad and an applicative functor, so we have the usual "
"collection of combinators at our disposal for creating new instances of the "
"`Arbitrary` type class."
msgstr ""
"`Gen`はモナドでもアプリカティブ関手でもあるので、 `Arbitary`型クラスの新しい"
"インスタンスを作成するのに、いつも使っているようなコンビネータを自由に使うこ"
"とができます。"

#. type: Plain text
#: text/chapter13.md:158
msgid ""
"For example, we can use the `Arbitrary` instance for the `Int` type, "
"provided in the `quickcheck` library, to create a distribution on the 256-"
"byte values, using the `Functor` instance for `Gen` to map a function from "
"integers to bytes over arbitrary integer values:"
msgstr ""
"例えば、`quickcheck`ライブラリで提供されている`Int`型用の`Arbitrary`インスタ"
"ンスを使い、256個のバイト値上の分布を作れます。\n"
"これには`Gen`用の`Functor`インスタンスを使い、整数からバイトへの関数を任意の"
"整数値に写します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:159
#, no-wrap
msgid ""
"newtype Byte = Byte Int\n"
"\n"
"instance Arbitrary Byte where\n"
"  arbitrary = map intToByte arbitrary\n"
"    where\n"
"    intToByte n | n >= 0 = Byte (n `mod` 256)\n"
"                | otherwise = intToByte (-n)\n"
msgstr ""
"newtype Byte = Byte Int\n"
"\n"
"instance Arbitrary Byte where\n"
"  arbitrary = map intToByte arbitrary\n"
"    where\n"
"    intToByte n | n >= 0 = Byte (n `mod` 256)\n"
"                | otherwise = intToByte (-n)\n"

#. type: Plain text
#: text/chapter13.md:170
msgid ""
"Here, we define a type `Byte` of integral values between 0 and 255. The "
"`Arbitrary` instance uses the `map` function to lift the `intToByte` "
"function over the `arbitrary` action. The type of the inner `arbitrary` "
"action is inferred as `Gen Int`."
msgstr ""
"ここでは、0から255までの間の整数値であるような型`Byte`を定義しています。\n"
"`Arbitrary`インスタンスは`map`演算子を使って、`intToByte`関数を`arbitrary`動"
"作まで持ち上げています。\n"
"`arbitrary`動作内部の型は`Gen Int`と推論されます。"

#. type: Plain text
#: text/chapter13.md:172
msgid "We can also use this idea to improve our test for `merge`:"
msgstr "この考え方を `merge`用のテストに使うこともできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:173
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:179
msgid ""
"In this test, we generated arbitrary arrays `xs` and `ys`, but had to sort "
"them, since `merge` expects sorted input. On the other hand, we could create "
"a newtype representing sorted arrays and write an `Arbitrary` instance that "
"generates sorted data:"
msgstr ""
"このテストでは、任意の配列`xs`と`ys`を生成しますが、`merge`は整列済みの入力を"
"期待しているので、これらを整列しておかなければなりません。\n"
"一方で、整列された配列を表すnewtypeを作成し、整列されたデータを生成する"
"`Arbitrary`インスタンスを書くこともできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:180
#, no-wrap
msgid ""
"newtype Sorted a = Sorted (Array a)\n"
"\n"
"sorted :: forall a. Sorted a -> Array a\n"
"sorted (Sorted xs) = xs\n"
"\n"
"instance (Arbitrary a, Ord a) => Arbitrary (Sorted a) where\n"
"  arbitrary = map (Sorted <<< sort) arbitrary\n"
msgstr ""
"newtype Sorted a = Sorted (Array a)\n"
"\n"
"sorted :: forall a. Sorted a -> Array a\n"
"sorted (Sorted xs) = xs\n"
"\n"
"instance (Arbitrary a, Ord a) => Arbitrary (Sorted a) where\n"
"  arbitrary = map (Sorted <<< sort) arbitrary\n"

#. type: Plain text
#: text/chapter13.md:191
msgid "With this type constructor, we can modify our test as follows:"
msgstr "この型構築子を使うと、テストを次のように変更できます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:192
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs <> sorted ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs <> sorted ys)\n"

#. type: Plain text
#: text/chapter13.md:198
msgid ""
"This may look like a small change, but the types of `xs` and `ys` have "
"changed to `Sorted Int` instead of just `Array Int`. This communicates our "
"_intent_ in a clearer way – the `mergePoly` function takes sorted input. "
"Ideally, the type of the `mergePoly` function itself would be updated to use "
"the `Sorted` type constructor."
msgstr ""
"これは些細な変更に見えるかもしれませんが、`xs`と`ys`の型はただの`Array Int`か"
"ら`Sorted Int`へと変更されています。\n"
"これにより、`mergePoly`関数は整列済みの入力を取る、という*意図*をわかりやすく"
"示すことができます。\n"
"理想的には、`mergePoly`関数自体の型が`Sorted`型構築子を使うようにするといいで"
"しょう。"

#. type: Plain text
#: text/chapter13.md:200
msgid ""
"As a more interesting example, the `Tree` module defines a type of sorted "
"binary trees with values at the branches:"
msgstr ""
"より興味深い例として、 `Tree`モジュールでは枝の値で整列された二分木の型が定義"
"されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:201
#, no-wrap
msgid ""
"data Tree a\n"
"  = Leaf\n"
"  | Branch (Tree a) a (Tree a)\n"
msgstr ""
"data Tree a\n"
"  = Leaf\n"
"  | Branch (Tree a) a (Tree a)\n"

#. type: Plain text
#: text/chapter13.md:208
msgid "The `Tree` module defines the following API:"
msgstr "`Tree`モジュールでは次のAPIが定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:209
#, no-wrap
msgid ""
"insert    :: forall a. Ord a => a -> Tree a -> Tree a\n"
"member    :: forall a. Ord a => a -> Tree a -> Boolean\n"
"fromArray :: forall a. Ord a => Array a -> Tree a\n"
"toArray   :: forall a. Tree a -> Array a\n"
msgstr ""
"insert    :: forall a. Ord a => a -> Tree a -> Tree a\n"
"member    :: forall a. Ord a => a -> Tree a -> Boolean\n"
"fromArray :: forall a. Ord a => Array a -> Tree a\n"
"toArray   :: forall a. Tree a -> Array a\n"

#. type: Plain text
#: text/chapter13.md:217
msgid ""
"The `insert` function inserts a new element into a sorted tree, and the "
"`member` function can query a tree for a particular value. For example:"
msgstr ""
"`insert`関数は新しい要素を整列済みの木に挿入し、`member`関数は特定の値につい"
"て木に問い合わせます。\n"
"例えば次のようになります。"

#. type: Fenced code block (text)
#: text/chapter13.md:218
#, no-wrap
msgid ""
"> import Tree\n"
"\n"
"> member 2 $ insert 1 $ insert 2 Leaf\n"
"true\n"
"\n"
"> member 1 Leaf\n"
"false\n"
msgstr ""
"> import Tree\n"
"\n"
"> member 2 $ insert 1 $ insert 2 Leaf\n"
"true\n"
"\n"
"> member 1 Leaf\n"
"false\n"

#. type: Plain text
#: text/chapter13.md:229
msgid ""
"The `toArray` and `fromArray` functions can convert sorted trees to and from "
"arrays. We can use `fromArray` to write an `Arbitrary` instance for trees:"
msgstr ""
"`toArray`関数と`fromArray`関数は、整列された木と配列を相互に変換できます。\n"
"`fromArray`を使うと、木についての`Arbitrary`インスタンスを書けます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:230
#, no-wrap
msgid ""
"instance (Arbitrary a, Ord a) => Arbitrary (Tree a) where\n"
"  arbitrary = map fromArray arbitrary\n"
msgstr ""
"instance (Arbitrary a, Ord a) => Arbitrary (Tree a) where\n"
"  arbitrary = map fromArray arbitrary\n"

#. type: Plain text
#: text/chapter13.md:236
msgid ""
"We can now use `Tree a` as the type of an argument to our test properties "
"whenever there is an `Arbitrary` instance available for the type `a`. For "
"example, we can test that the `member` test always returns `true` after "
"inserting a value:"
msgstr ""
"型`a`用に使える`Arbitary`インスタンスがあるなら、テストする性質の引数の型とし"
"て`Tree a`を使えます。\n"
"例えば、`member`による木の確認については、値を挿入した後は常に`true`を返すこ"
"とをテストできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:237
#, no-wrap
msgid ""
"quickCheck \\t a ->\n"
"  member a $ insert a $ treeOfInt t\n"
msgstr ""
"quickCheck \\t a ->\n"
"  member a $ insert a $ treeOfInt t\n"

#. type: Plain text
#: text/chapter13.md:243
msgid ""
"Here, the argument `t` is a randomly-generated tree of type `Tree Int`, "
"where the type argument disambiguated by the identity function `treeOfInt`."
msgstr ""
"ここでは、引数 `t`は `Tree Number`型の無作為に生成された木です。\n"
"型引数は、同値関数 `treeOfInt`によって明確にされています。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:248
msgid ""
"(Medium) Create a newtype for `String` with an associated `Arbitrary` "
"instance which generates collections of randomly-selected characters in the "
"range `a-z`. _Hint_: use the `elements` and `arrayOf` functions from the "
"`Test.QuickCheck.Gen` module."
msgstr ""
"（普通）`a-z`の範囲から無作為に選ばれた文字の集まりを生成する `Arbitrary`イン"
"スタンスを持つ、`String`のnewtypeを作ってください。\n"
"*手掛かり*：`Test.QuickCheck.Gen`モジュールから `elements`と `arrayOf`関数を"
"使います。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:248
msgid ""
"(Difficult) Write a property that asserts that a value inserted into a tree "
"is still a member of that tree after arbitrarily many more insertions."
msgstr ""
"（難しい）木に挿入された値は、どれだけ沢山の挿入があった後でも、その木の構成"
"要素であることを主張する性質を書いてください。"

#. type: Title ##
#: text/chapter13.md:249
#, no-wrap
msgid "Testing Higher-Order Functions"
msgstr "高階関数のテスト"

#. type: Plain text
#: text/chapter13.md:252
msgid ""
"The `Merge` module defines another generalization of the `merge` function – "
"the `mergeWith` function takes an additional function as an argument to "
"determine the order in which elements should be merged. That is, `mergeWith` "
"is a higher-order function."
msgstr ""
"`Merge`モジュールは`merge`関数の別の一般化も定義しています。\n"
"`mergeWith`関数は追加の関数を引数として取り、統合される要素の順序を判定しま"
"す。\n"
"つまり`mergeWith`は高階関数です。"

#. type: Plain text
#: text/chapter13.md:254
msgid ""
"For example, we can pass the `length` function as the first argument to "
"merge two arrays already in length-increasing order. The result should also "
"be in length-increasing order:"
msgstr ""
"例えば`length`関数を最初の引数として渡し、既に長さの昇順になっている2つの配列"
"を統合できます。\n"
"その結果もまた長さの昇順になっているでしょう。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:255
#, no-wrap
msgid ""
"> import Data.String\n"
"\n"
"> mergeWith length\n"
"    [\"\", \"ab\", \"abcd\"]\n"
"    [\"x\", \"xyz\"]\n"
"\n"
"[\"\",\"x\",\"ab\",\"xyz\",\"abcd\"]\n"
msgstr ""
"> import Data.String\n"
"\n"
"> mergeWith length\n"
"    [\"\", \"ab\", \"abcd\"]\n"
"    [\"x\", \"xyz\"]\n"
"\n"
"[\"\",\"x\",\"ab\",\"xyz\",\"abcd\"]\n"

#. type: Plain text
#: text/chapter13.md:266
msgid ""
"How might we test such a function? Ideally, we would like to generate values "
"for all three arguments, including the first argument, which is a function."
msgstr ""
"このような関数をテストするにはどうしたらいいでしょうか。\n"
"理想的には、関数である最初の引数を含めた3つの引数全てについて、値を生成したい"
"ところです。"

#. type: Plain text
#: text/chapter13.md:268
msgid ""
"There is a second type class that allows us to create randomly-generated "
"functions. It is called `Coarbitrary`, and it is defined as follows:"
msgstr ""
"無作為に生成された関数を作れるようにする、2つ目の型クラスがあります。\n"
"`Coarbitrary`という名前で次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:269
#, no-wrap
msgid ""
"class Coarbitrary t where\n"
"  coarbitrary :: forall r. t -> Gen r -> Gen r\n"
msgstr ""
"class Coarbitrary t where\n"
"  coarbitrary :: forall r. t -> Gen r -> Gen r\n"

#. type: Plain text
#: text/chapter13.md:275
msgid ""
"The `coarbitrary` function takes a function argument of type `t` and a "
"random generator for a function result of type `r`. It uses the function "
"argument to _perturb_ the random generator. That is, it uses the function "
"argument to modify the random output of the random generator for the result."
msgstr ""
"`coarbitrary`関数は、型`t`の関数の引数と、型`r`の関数の結果の乱数生成器を取り"
"ます。\n"
"この関数引数を使って乱数生成器を*かき乱し*ます。\n"
"つまり、関数の引数を使って乱数生成器の無作為な出力を変更し、結果としているの"
"です。"

#. type: Plain text
#: text/chapter13.md:277
msgid ""
"In addition, there is a type class instance that gives us `Arbitrary` "
"functions if the function domain is `Coarbitrary` and the function codomain "
"is `Arbitrary`:"
msgstr ""
"また、もし関数の定義域が`Coarbitrary`で値域が`Arbitrary`なら、`Arbitrary`の関"
"数を与える型クラスインスタンスが存在します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:278
#, no-wrap
msgid "instance (Coarbitrary a, Arbitrary b) => Arbitrary (a -> b)\n"
msgstr "instance (Coarbitrary a, Arbitrary b) => Arbitrary (a -> b)\n"

#. type: Plain text
#: text/chapter13.md:283
msgid ""
"In practice, we can write properties that take functions as arguments. In "
"the case of the `mergeWith` function, we can generate the first argument "
"randomly, modifying our tests to take account of the new argument."
msgstr ""
"実際のところ、引数として関数を取るような性質を記述できます。\n"
"`mergeWith`関数の場合では、新しい引数を考慮するようにテストを修正すると、最初"
"の引数を無作為に生成できます。"

#. type: Plain text
#: text/chapter13.md:285
msgid ""
"We cannot guarantee that the result will be sorted – we do not even "
"necessarily have an `Ord` instance – but we can expect that the result be "
"sorted with respect to the function `f` that we pass in as an argument. In "
"addition, we need the two input arrays to be sorted concerning `f`, so we "
"use the `sortBy` function to sort `xs` and `ys` based on comparison after "
"the function `f` has been applied:"
msgstr ""
"結果が整列されていることは保証できません。\n"
"`Ord`インスタンスを持っているとさえ限らないのです。\n"
"しかし、引数として渡す関数`f`に従って結果が整列されていることは期待されま"
"す。\n"
"更に、2つの入力配列が`f`に従って整列されている必要がありますので、`sortBy`関"
"数を使って関数`f`が適用されたあとの比較に基づいて`xs`と`ys`を整列します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:286
#, no-wrap
msgid ""
"quickCheck \\xs ys f ->\n"
"  let\n"
"    result =\n"
"      map f $\n"
"        mergeWith (intToBool f)\n"
"                  (sortBy (compare `on` f) xs)\n"
"                  (sortBy (compare `on` f) ys)\n"
"    expected =\n"
"      map f $\n"
"        sortBy (compare `on` f) $ xs <> ys\n"
"  in\n"
"    eq result expected\n"
msgstr ""
"quickCheck \\xs ys f ->\n"
"  let\n"
"    result =\n"
"      map f $\n"
"        mergeWith (intToBool f)\n"
"                  (sortBy (compare `on` f) xs)\n"
"                  (sortBy (compare `on` f) ys)\n"
"    expected =\n"
"      map f $\n"
"        sortBy (compare `on` f) $ xs <> ys\n"
"  in\n"
"    eq result expected\n"

#. type: Plain text
#: text/chapter13.md:302
msgid ""
"Here, we use a function `intToBool` to disambiguate the type of the function "
"`f`:"
msgstr ""
"ここでは、関数 `f`の型を明確にするために、関数 `intToBool`を使用しています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:303
#, no-wrap
msgid ""
"intToBool :: (Int -> Boolean) -> Int -> Boolean\n"
"intToBool = id\n"
msgstr ""
"intToBool :: (Int -> Boolean) -> Int -> Boolean\n"
"intToBool = id\n"

#. type: Plain text
#: text/chapter13.md:309
msgid "In addition to being `Arbitrary`, functions are also `Coarbitrary`:"
msgstr "関数は `Arbitrary`であるだけでなく `Coarbitrary`でもあります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:310
#, no-wrap
msgid "instance (Arbitrary a, Coarbitrary b) => Coarbitrary (a -> b)\n"
msgstr "instance (Arbitrary a, Coarbitrary b) => Coarbitrary (a -> b)\n"

#. type: Plain text
#: text/chapter13.md:315
msgid ""
"This means that we are not limited to just values and functions – we can "
"also randomly generate _higher-order functions_, or functions whose "
"arguments are higher-order functions, and so on."
msgstr ""
"つまり値や関数だけに制限されません。\n"
"*高階関数*や、引数が高階関数であるような関数やその他諸々もまた、無作為に生成"
"できるのです。"

#. type: Title ##
#: text/chapter13.md:316
#, no-wrap
msgid "Writing Coarbitrary Instances"
msgstr "Coarbitraryのインスタンスを書く"

#. type: Plain text
#: text/chapter13.md:319
msgid ""
"Just as we can write `Arbitrary` instances for our data types by using the "
"`Monad` and `Applicative` instances of `Gen`, we can write our own "
"`Coarbitrary` instances as well. This allows us to use our own data types as "
"the domain of randomly-generated functions."
msgstr ""
"`Gen`の `Monad`や `Applicative`インスタンスを使って独自のデータ型に対して "
"`Arbitrary`インスタンスを書くことができるのとちょうど同じように、独自の "
"`Coarbitrary`インスタンスを書くこともできます。\n"
"これにより、無作為に生成される関数の定義域として、独自のデータ型を使うことが"
"できるようになります。"

#. type: Plain text
#: text/chapter13.md:321
msgid ""
"Let's write a `Coarbitrary` instance for our `Tree` type. We will need a "
"`Coarbitrary` instance for the type of the elements stored in the branches:"
msgstr ""
"`Tree`型の `Coarbitrary`インスタンスを書いてみましょう。\n"
"枝に格納されている要素の型に `Coarbitrary`インスタンスが必要になります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:322
#, no-wrap
msgid "instance Coarbitrary a => Coarbitrary (Tree a) where\n"
msgstr "instance Coarbitrary a => Coarbitrary (Tree a) where\n"

#. type: Plain text
#: text/chapter13.md:327
msgid ""
"We have to write a function that perturbs a random generator given a value "
"of type `Tree a`. If the input value is a `Leaf`, then we will return the "
"generator unchanged:"
msgstr ""
"型`Tree a`の値が与えられたときに、乱数発生器をかき乱す関数を記述する必要があ"
"ります。\n"
"入力値が`Leaf`であれば、そのままにしておく生成器を返します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:328
#, no-wrap
msgid "  coarbitrary Leaf = id\n"
msgstr "  coarbitrary Leaf = id\n"

#. type: Plain text
#: text/chapter13.md:333
msgid ""
"If the tree is a `Branch`, then we will perturb the generator using the left "
"subtree, the value, and the right subtree. We use function composition to "
"create our perturbing function:"
msgstr ""
"もし木が `Branch`なら、左の部分木、値、右の部分木を使って生成器をかき乱しま"
"す。\n"
"関数合成を使って独自のかき乱し関数を作ります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:334
#, no-wrap
msgid ""
"  coarbitrary (Branch l a r) =\n"
"    coarbitrary l <<<\n"
"    coarbitrary a <<<\n"
"    coarbitrary r\n"
msgstr ""
"  coarbitrary (Branch l a r) =\n"
"    coarbitrary l <<<\n"
"    coarbitrary a <<<\n"
"    coarbitrary r\n"

#. type: Plain text
#: text/chapter13.md:342
msgid ""
"Now we can write properties whose arguments include functions taking trees "
"as arguments. For example, the `Tree` module defines a function `anywhere`, "
"which tests if a predicate holds on any subtree of its argument:"
msgstr ""
"これで、木を引数にとるような関数を引数に含む性質を自由に書くことができるよう"
"になりました。\n"
"例えば`Tree`モジュールでは関数`anywhere`が定義されています。\n"
"これは述語が引数のどんな部分木についても満たされるかを調べます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:343
#, no-wrap
msgid "anywhere :: forall a. (Tree a -> Boolean) -> Tree a -> Boolean\n"
msgstr "anywhere :: forall a. (Tree a -> Boolean) -> Tree a -> Boolean\n"

#. type: Plain text
#: text/chapter13.md:348
msgid ""
"Now we can generate the predicate function randomly. For example, we expect "
"the `anywhere` function to _respect disjunction_:"
msgstr ""
"今となっては述語関数を無作為に生成できます。\n"
"例えば、`anywhere`関数は*選言の法則を満たす*ことが期待されます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:349
#, no-wrap
msgid ""
"quickCheck \\f g t ->\n"
"  anywhere (\\s -> f s || g s) t ==\n"
"    anywhere f (treeOfInt t) || anywhere g t\n"
msgstr ""
"quickCheck \\f g t ->\n"
"  anywhere (\\s -> f s || g s) t ==\n"
"    anywhere f (treeOfInt t) || anywhere g t\n"

#. type: Plain text
#: text/chapter13.md:356
msgid ""
"Here, the `treeOfInt` function is used to fix the type of values contained "
"in the tree to the type `Int`:"
msgstr ""
"ここで、 `treeOfInt`関数は木に含まれる値の型を型 `Int`に固定するために使われ"
"ています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:357
#, no-wrap
msgid ""
"treeOfInt :: Tree Int -> Tree Int\n"
"treeOfInt = id\n"
msgstr ""
"treeOfInt :: Tree Int -> Tree Int\n"
"treeOfInt = id\n"

#. type: Title ##
#: text/chapter13.md:362
#, no-wrap
msgid "Testing Without Side-Effects"
msgstr "副作用のないテスト"

#. type: Plain text
#: text/chapter13.md:365
msgid ""
"For the purposes of testing, we usually include calls to the `quickCheck` "
"function in the `main` action of our test suite. However, there is a variant "
"of the `quickCheck` function, called `quickCheckPure` which does not use "
"side-effects. Instead, it is a pure function that takes a random seed as an "
"input and returns an array of test results."
msgstr ""
"通常、テストの目的ではテストスイートの`main`動作に`quickCheck`関数の呼び出し"
"が含まれています。\n"
"しかし`quickCheck`関数には亜種があり、`quickCheckPure`という名前です。\n"
"副作用を使わない代わりに、入力として乱数の種を取ってテスト結果の配列を返す純"
"粋な関数です。"

#. type: Plain text
#: text/chapter13.md:367
msgid ""
"We can test `quickCheckPure` using PSCi. Here, we test that the `merge` "
"operation is associative:"
msgstr ""
"PSCiを使用して `quickCheckPure`を試せます。\n"
"ここでは `merge`操作が結合法則を満たすことをテストします。"

#. type: Fenced code block (text)
#: text/chapter13.md:368
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Merge\n"
"> import Test.QuickCheck\n"
"> import Test.QuickCheck.LCG (mkSeed)\n"
"\n"
"> :paste\n"
"… quickCheckPure (mkSeed 12345) 10 \\xs ys zs ->\n"
"…   ((xs `merge` ys) `merge` zs) ==\n"
"…     (xs `merge` (ys `merge` zs))\n"
"… ^D\n"
"\n"
"Success : Success : ...\n"
msgstr ""
"> import Prelude\n"
"> import Merge\n"
"> import Test.QuickCheck\n"
"> import Test.QuickCheck.LCG (mkSeed)\n"
"\n"
"> :paste\n"
"… quickCheckPure (mkSeed 12345) 10 \\xs ys zs ->\n"
"…   ((xs `merge` ys) `merge` zs) ==\n"
"…     (xs `merge` (ys `merge` zs))\n"
"… ^D\n"
"\n"
"Success : Success : ...\n"

#. type: Plain text
#: text/chapter13.md:384
msgid ""
"`quickCheckPure` takes three arguments: the random seed, the number of test "
"cases to generate, and the property to test. If all tests pass, you should "
"see an array of `Success` data constructors printed to the console."
msgstr ""
"`quickCheckPure`は乱数の種、生成するテスト項目数、テストする性質の3つの引数を"
"取ります。\n"
"もし全てのテスト項目が成功したら、`Success`データ構築子の配列がコンソールに出"
"力されます。"

#. type: Plain text
#: text/chapter13.md:386
msgid ""
"`quickCheckPure` might be useful in other situations, such as generating "
"random input data for performance benchmarks or sample form data for web "
"applications."
msgstr ""
"`quickCheckPure`は、性能ベンチマークの入力データ生成や、webアプリケーションの"
"フォームデータ例を無作為に生成するというような状況で便利かもしれません。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
msgid ""
"(Easy) Write `Coarbitrary` instances for the `Byte` and `Sorted` type "
"constructors."
msgstr ""
"（簡単）`Byte`と `Sorted`型構築子についての `Coarbitrary`インスタンスを書いて"
"ください。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
msgid ""
"(Medium) Write a (higher-order) property which asserts associativity of the "
"`mergeWith f` function for any function `f`. Test your property in PSCi "
"using `quickCheckPure`."
msgstr ""
"（普通）任意の関数 `f`について、 `mergeWith f`関数の結合性を主張する（高階）"
"性質を書いてください。 `quickCheckPure`を使ってPSCiでその性質をテストしてくだ"
"さい。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
msgid ""
"(Medium) Write `Arbitrary` and `Coarbitrary` instances for the following "
"data type:"
msgstr ""
"（普通）次のデータ型の`Arbitrary`と`Coarbitrary`インスタンスを書いてくださ"
"い。"

#. type: Plain text
#: text/chapter13.md:396
#, no-wrap
msgid ""
"     ```haskell\n"
"     data OneTwoThree a = One a | Two a a | Three a a a\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data OneTwoThree a = One a | Two a a | Three a a a\n"
"     ```\n"

#. type: Plain text
#: text/chapter13.md:400
#, no-wrap
msgid ""
"     _Hint_: Use the `oneOf` function defined in `Test.QuickCheck.Gen` to define your `Arbitrary` instance.\n"
" 1. (Medium) Use `all` to simplify the result of the `quickCheckPure` function – your new function should have the type `List Result -> Boolean` and should return `true` if every test passes and `false` otherwise.\n"
" 1. (Medium) As another approach to simplifying the result of `quickCheckPure`, try writing a function `squashResults :: List Result -> Result`. Consider using the `First` monoid from `Data.Maybe.First` with the `foldMap` function to preserve the first error in case of failure.\n"
msgstr ""
"     *手掛かり*：`Test.QuickCheck.Gen`で定義された`oneOf`関数を使って`Arbitrary`インスタンスを定義してください。\n"
" 1. （普通）`all`を使って`quickCheckPure`関数の結果を単純化してください。\n"
"    この新しい関数は型`List Result -> Boolean`を持ち、全てのテストが通れば`true`を、そうでなければ`false`を返します。\n"
" 2. （普通）`quickCheckPure`の結果を単純にする別の手法として、関数`squashResults :: List Result -> Result`を書いてみてください。\n"
"    `Data.Maybe.First`の`First`モノイドと共に`foldMap`関数を使うことで、失敗した場合の最初のエラーを保持することを検討してください。\n"

#. type: Plain text
#: text/chapter13.md:404
msgid ""
"In this chapter, we met the `quickcheck` package, which can be used to write "
"tests in a declarative way using the paradigm of _generative testing_. In "
"particular:"
msgstr ""
"この章では`quickcheck`パッケージに出会いました。\n"
"これを使うと*生成的テスティング*のパラダイムを使って、宣言的な方法でテストを"
"書くことができました。具体的には以下です。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid "We saw how to automate QuickCheck tests using `spago test`."
msgstr "`spago test`を使ってQuickCheckのテストを自動化する方法を見ました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid ""
"We saw how to write properties as functions and how to use the `<?>` "
"operator to improve error messages."
msgstr ""
"性質を関数として書く方法とエラー文言を改良する`<?>`演算子の使い方を説明しまし"
"た。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid ""
"We saw how the `Arbitrary` and `Coarbitrary` type classes enable generation "
"of boilerplate testing code and how they allow us to test higher-order "
"properties."
msgstr ""
"`Arbitrary`と`Coarbitrary`型クラスによって定型的なテストコードの自動生成を可"
"能にする方法や、高階な性質のテストを可能にする方法を見ました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid ""
"We saw how to implement custom `Arbitrary` and `Coarbitrary` instances for "
"our own data types."
msgstr ""
"独自のデータ型に対して `Arbitrary`と `Coarbitrary`インスタンスを実装する方法"
"を見ました。"

#. type: Title #
#: text/chapter14.md:1
#, no-wrap
msgid "Domain-Specific Languages"
msgstr "領域特化言語"

#. type: Plain text
#: text/chapter14.md:6
msgid ""
"In this chapter, we will explore the implementation of _domain-specific "
"languages_ (or _DSLs_) in PureScript, using a number of standard techniques."
msgstr ""
"この章では多数の標準的な手法を使い、PureScriptにおける*領域特化言語*（または"
"*DSL*）の実装について探求していきます。"

#. type: Plain text
#: text/chapter14.md:8
msgid ""
"A domain-specific language is a language that is well-suited to development "
"in a particular problem domain. Its syntax and functions are chosen to "
"maximize the readability of code used to express ideas in that domain. We "
"have already seen several examples of domain-specific languages in this book:"
msgstr ""
"領域特化言語とは、特定の問題領域での開発に適した言語のことです。\n"
"構文及び機能は、その領域内の考え方を表現するに使われるコードの読みやすさを最"
"大化すべく選択されます。\n"
"本書の中では、既に領域特化言語の例を幾つか見てきています。"

#. type: Bullet: '- '
#: text/chapter14.md:11
msgid ""
"The `Game` monad and its associated actions, developed in chapter 11, "
"constitute a domain-specific language for the domain of _text adventure game "
"development_."
msgstr ""
"第11章で開発された`Game`モナドと関連する動作は、*テキストアドベンチャーゲーム"
"開発*という領域に対しての領域特化言語を構成しています。"

#. type: Bullet: '- '
#: text/chapter14.md:11
msgid ""
"The `quickcheck` package, covered in Chapter 13, is a domain-specific "
"language for the domain of _generative testing_. Its combinators enable a "
"particularly expressive notation for test properties."
msgstr ""
"第13章で扱った`quickcheck`パッケージは、*生成的テスティング*の領域に向けた領"
"域特化言語です。\n"
"このコンビネータはテストの性質に対して特に表現力の高い記法を可能にします。"

#. type: Plain text
#: text/chapter14.md:13
msgid ""
"This chapter will take a more structured approach to some standard "
"techniques in implementing domain-specific languages. It is by no means a "
"complete exposition of the subject, but should provide you with enough "
"knowledge to build some practical DSLs for your own tasks."
msgstr ""
"この章では、領域特化言語の実装において、幾つかの標準的な技法にについて構造的"
"な手法を取ります。\n"
"この話題の完全な解説では決してありませんが、目的に合う実践的なDSLを構築するの"
"に充分な知識は得られるでしょう。"

#. type: Plain text
#: text/chapter14.md:15
msgid ""
"Our running example will be a domain-specific language for creating HTML "
"documents. We will aim to develop a type-safe language for describing "
"correct HTML documents, and we will work by improving a naive implementation "
"in small steps."
msgstr ""
"ここでの実行例はHTML文書を作成するための領域特化言語です。\n"
"正しいHTML文書を記述するための型安全な言語を開発することが目的で、素朴な実装"
"を徐々に改善しつつ進めていきます。"

#. type: Plain text
#: text/chapter14.md:19
msgid ""
"The project accompanying this chapter adds one new dependency – the `free` "
"library, which defines the _free monad_, one of the tools we will use."
msgstr ""
"この章に付随するプロジェクトには新しい依存性が1つ追加されます。\n"
"これから使う道具の1つである*Freeモナド*が定義されている`free`ライブラリです。"

#. type: Plain text
#: text/chapter14.md:21
msgid "We will test this chapter's project in PSCi."
msgstr "このプロジェクトをPSCiを使って試していきます。"

#. type: Title ##
#: text/chapter14.md:22
#, no-wrap
msgid "An HTML Data Type"
msgstr "HTMLデータ型"

#. type: Plain text
#: text/chapter14.md:25
msgid ""
"The most basic version of our HTML library is defined in the `Data.DOM."
"Simple` module. The module contains the following type definitions:"
msgstr ""
"このHTMLライブラリの最も基本的なバージョンは `Data.DOM.Simple`モジュールで定"
"義されています。このモジュールには次の型定義が含まれています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:26
#, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Array Content)\n"
"  }\n"
"\n"
"data Content\n"
"  = TextContent String\n"
"  | ElementContent Element\n"
"\n"
"newtype Attribute = Attribute\n"
"  { key          :: String\n"
"  , value        :: String\n"
"  }\n"
msgstr ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Array Content)\n"
"  }\n"
"\n"
"data Content\n"
"  = TextContent String\n"
"  | ElementContent Element\n"
"\n"
"newtype Attribute = Attribute\n"
"  { key          :: String\n"
"  , value        :: String\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:44
msgid ""
"The `Element` type represents HTML elements. Each element consists of an "
"element name, an array of attribute pairs, and some content. The content "
"property uses the `Maybe` type to indicate that an element might be open "
"(containing other elements and text) or closed."
msgstr ""
"`Element`型はHTMLの要素を表します。\n"
"各要素は要素名、属性の対の配列と、内容で構成されます。\n"
"内容のプロパティには`Maybe`型を適切に使い、要素が開いている（他の要素やテキス"
"トを含む）か閉じているかを示します。"

#. type: Plain text
#: text/chapter14.md:46
msgid "The key function of our library is a function"
msgstr "このライブラリの鍵となる機能は次の関数です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:47
#, no-wrap
msgid "render :: Element -> String\n"
msgstr "render :: Element -> String\n"

#. type: Plain text
#: text/chapter14.md:52
msgid ""
"which renders HTML elements as HTML strings. We can try out this version of "
"the library by constructing values of the appropriate types explicitly in "
"PSCi:"
msgstr ""
"この関数はHTML要素をHTML文字列として出力します。\n"
"PSCiで明示的に適当な型の値を構築し、ライブラリのこのバージョンを試してみま"
"しょう。"

#. type: Fenced code block (text)
#: text/chapter14.md:53
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Simple\n"
"> import Data.Maybe\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ Element\n"
"…   { name: \"p\"\n"
"…   , attribs: [\n"
"…       Attribute\n"
"…         { key: \"class\"\n"
"…         , value: \"main\"\n"
"…         }\n"
"…     ]\n"
"…   , content: Just [\n"
"…       TextContent \"Hello World!\"\n"
"…     ]\n"
"…   }\n"
"… ^D\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Simple\n"
"> import Data.Maybe\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ Element\n"
"…   { name: \"p\"\n"
"…   , attribs: [\n"
"…       Attribute\n"
"…         { key: \"class\"\n"
"…         , value: \"main\"\n"
"…         }\n"
"…     ]\n"
"…   , content: Just [\n"
"…       TextContent \"Hello World!\"\n"
"…     ]\n"
"…   }\n"
"… ^D\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:81
msgid "As it stands, there are several problems with this library:"
msgstr "現状のライブラリには幾つもの問題があります。"

#. type: Bullet: '- '
#: text/chapter14.md:87
msgid ""
"Creating HTML documents is difficult – every new element requires at least "
"one record and one data constructor."
msgstr ""
"HTML文書の作成に手が掛かります。\n"
"全ての新しい要素に少なくとも1つのレコードと1つのデータ構築子が必要です。"

#. type: Bullet: '- '
#: text/chapter14.md:87
msgid "It is possible to represent invalid documents:"
msgstr "無効な文書を表現できてしまいます。"

#. type: Bullet: '  - '
#: text/chapter14.md:87
msgid "The developer might mistype the element name"
msgstr "開発者が要素名の入力を間違えるかもしれません"

#. type: Bullet: '  - '
#: text/chapter14.md:87
msgid "The developer can associate an attribute with the wrong type of element"
msgstr "開発者が属性を間違った要素に関連付けることができてしまいます"

#. type: Bullet: '  - '
#: text/chapter14.md:87
msgid "The developer can use a closed element when an open element is correct"
msgstr "開いた要素が正しい場合に開発者が閉じた要素を使えてしまいます"

#. type: Plain text
#: text/chapter14.md:89
msgid ""
"In the remainder of the chapter, we will apply certain techniques to solve "
"these problems and turn our library into a usable domain-specific language "
"for creating HTML documents."
msgstr ""
"残りの章ではとある手法を用いてこれらの問題を解決し、このライブラリーをHTML文"
"書を作成するために使える領域特化言語にしていきます。"

#. type: Title ##
#: text/chapter14.md:90
#, no-wrap
msgid "Smart Constructors"
msgstr "スマート構築子"

#. type: Plain text
#: text/chapter14.md:93
msgid ""
"The first technique we will apply is simple but can be very effective. "
"Instead of exposing the representation of the data to the module's users, we "
"can use the module exports list to hide the `Element`, `Content`, and "
"`Attribute` data constructors, and only export so-called _smart "
"constructors_, which construct data known to be correct."
msgstr ""
"最初に導入する手法は単純ですがとても効果的です。\n"
"モジュールの使用者にデータの表現を露出する代わりに、モジュールエクスポートリ"
"ストを使ってデータ構築子`Element`、`Content`、`Attribute`を隠蔽します。\n"
"そして正しいことが分かっているデータを構築する、いわゆる*スマート構築子*だけ"
"をエクスポートします。"

#. type: Plain text
#: text/chapter14.md:95
msgid ""
"Here is an example. First, we provide a convenience function for creating "
"HTML elements:"
msgstr ""
"例を示しましょう。まず、HTML要素を作成するための便利な関数を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:96
#, no-wrap
msgid ""
"element :: String -> Array Attribute -> Maybe (Array Content) -> Element\n"
"element name attribs content = Element\n"
"  { name:      name\n"
"  , attribs:   attribs\n"
"  , content:   content\n"
"  }\n"
msgstr ""
"element :: String -> Array Attribute -> Maybe (Array Content) -> Element\n"
"element name attribs content = Element\n"
"  { name:      name\n"
"  , attribs:   attribs\n"
"  , content:   content\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:106
msgid ""
"Next, we create smart constructors for those HTML elements we want our users "
"to be able to create by applying the `element` function:"
msgstr ""
"次にHTML要素のためのスマート構築子を作成します。\n"
"この要素は利用者が`element`関数を適用して作成できるようになってほしいもので"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:107
#, no-wrap
msgid ""
"a :: Array Attribute -> Array Content -> Element\n"
"a attribs content = element \"a\" attribs (Just content)\n"
"\n"
"p :: Array Attribute -> Array Content -> Element\n"
"p attribs content = element \"p\" attribs (Just content)\n"
"\n"
"img :: Array Attribute -> Element\n"
"img attribs = element \"img\" attribs Nothing\n"
msgstr ""
"a :: Array Attribute -> Array Content -> Element\n"
"a attribs content = element \"a\" attribs (Just content)\n"
"\n"
"p :: Array Attribute -> Array Content -> Element\n"
"p attribs content = element \"p\" attribs (Just content)\n"
"\n"
"img :: Array Attribute -> Element\n"
"img attribs = element \"img\" attribs Nothing\n"

#. type: Plain text
#: text/chapter14.md:119
msgid ""
"Finally, we update the module exports list to only export those functions "
"which are known to construct correct data structures:"
msgstr ""
"最後に、正しいデータ構造だけが構築されることがわかっているこれらの関数をエク"
"スポートするように、モジュールエクスポートリストを更新します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:120
#, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute(..)\n"
"  , Content(..)\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute(..)\n"
"  , Content(..)\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , render\n"
"  ) where\n"

#. type: Plain text
#: text/chapter14.md:135
msgid ""
"The module exports list is provided immediately after the module name inside "
"parentheses. Each module export can be one of three types:"
msgstr ""
"モジュールエクスポートリストはモジュール名の直後の括弧内に書きます。\n"
"各モジュールのエクスポートは次の3種類の何れかになります。"

#. type: Bullet: '- '
#: text/chapter14.md:139
msgid "A value (or function), indicated by the name of the value,"
msgstr "値（ないし関数）。その値の名前により指定されます。"

#. type: Bullet: '- '
#: text/chapter14.md:139
msgid "A type class, indicated by the name of the class,"
msgstr "型クラス。クラス名により指定されます。"

#. type: Bullet: '- '
#: text/chapter14.md:139
msgid ""
"A type constructor and any associated data constructors indicated by the "
"name of the type followed by a parenthesized list of exported data "
"constructors."
msgstr ""
"型構築子とそれに紐付くデータ構築子。\n"
"型名とそれに続くエクスポートされるデータ構築子の括弧で囲まれたリストで指定さ"
"れます。"

#. type: Plain text
#: text/chapter14.md:141
msgid ""
"Here, we export the `Element` _type_, but we do not export its data "
"constructors. If we did, the user could construct invalid HTML elements."
msgstr ""
"ここでは、`Element`の*型*をエクスポートしていますが、データ構築子はエクスポー"
"トしていません。\n"
"もしデータ構築子をエクスポートすると、使用者が不正なHTML要素を構築できてしま"
"います。"

#. type: Plain text
#: text/chapter14.md:143
msgid ""
"In the case of the `Attribute` and `Content` types, we still export all of "
"the data constructors (indicated by the symbol `..` in the exports list). We "
"will apply the technique of smart constructors to these types shortly."
msgstr ""
"`Attribute`と `Content`型についてはデータ構築子を全てエクスポートしています"
"（エクスポートリストの記号 `..`で示されています）。\n"
"すぐ後で、これらの型にもスマート構築子の手法を適用していきます。"

#. type: Plain text
#: text/chapter14.md:145
msgid "Notice that we have already made some big improvements to our library:"
msgstr "既にライブラリに幾つもの大きな改良が加わっていることに注目です。"

#. type: Bullet: '- '
#: text/chapter14.md:148
msgid ""
"It is impossible to represent HTML elements with invalid names (of course, "
"we are restricted to the set of element names provided by the library)."
msgstr ""
"不正な名前を持つHTML要素は表現できません（勿論ライブラリが提供する要素名に制"
"限されています）。"

#. type: Bullet: '- '
#: text/chapter14.md:148
msgid "Closed elements cannot contain content by construction."
msgstr "閉じた要素は構築するときに内容を含められません。"

#. type: Plain text
#: text/chapter14.md:150
msgid ""
"We can apply this technique to the `Content` type very easily. We simply "
"remove the data constructors for the `Content` type from the exports list "
"and provide the following smart constructors:"
msgstr ""
"`Content`型にとても簡単にこの手法を適用できます。\n"
"単にエクスポートリストから`Content`型のデータ構築子を取り除き、次のスマート構"
"築子を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:151
#, no-wrap
msgid ""
"text :: String -> Content\n"
"text = TextContent\n"
"\n"
"elem :: Element -> Content\n"
"elem = ElementContent\n"
msgstr ""
"text :: String -> Content\n"
"text = TextContent\n"
"\n"
"elem :: Element -> Content\n"
"elem = ElementContent\n"

#. type: Plain text
#: text/chapter14.md:160
msgid ""
"Let's apply the same technique to the `Attribute` type. First, we provide a "
"general-purpose smart constructor for attributes. Here is a first attempt:"
msgstr ""
"`Attribute`型にも同じ手法を適用してみましょう。\n"
"まず、属性のための汎用のスマート構築子を用意します。\n"
"以下は最初の試行です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:161
#, no-wrap
msgid ""
"attribute :: String -> String -> Attribute\n"
"attribute key value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
"\n"
"infix 4 attribute as :=\n"
msgstr ""
"attribute :: String -> String -> Attribute\n"
"attribute key value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
"\n"
"infix 4 attribute as :=\n"

#. type: Plain text
#: text/chapter14.md:172
msgid ""
"This representation suffers from the same problem as the original `Element` "
"type – it is possible to represent attributes that do not exist or whose "
"names were entered incorrectly. To solve this problem, we can create a "
"newtype that represents attribute names:"
msgstr ""
"この定義では元の`Element`型と同じ問題に直面しています。\n"
"存在しなかったり、名前が間違って入力された属性を表現できます。\n"
"この問題を解決するために、属性名を表すnewtypeを作成します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:173
#, no-wrap
msgid "newtype AttributeKey = AttributeKey String\n"
msgstr "newtype AttributeKey = AttributeKey String\n"

#. type: Plain text
#: text/chapter14.md:178
msgid "With that, we can modify our operator as follows:"
msgstr "これを使えば演算子を次のように変更できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:179
#, no-wrap
msgid ""
"attribute :: AttributeKey -> String -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
msgstr ""
"attribute :: AttributeKey -> String -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:188
msgid ""
"If we do not export the `AttributeKey` data constructor, then the user has "
"no way to construct values of type `AttributeKey` other than by using "
"functions we explicitly export. Here are some examples:"
msgstr ""
"`AttributeKey`データ構築子をエクスポートしなければ、明示的にエクスポートされ"
"た次のような関数を使う以外に、使用者が型 `AttributeKey`の値を構築する方法はあ"
"りません。\n"
"以下に幾つかの例を示します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:189
#, no-wrap
msgid ""
"href :: AttributeKey\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey\n"
"height = AttributeKey \"height\"\n"
msgstr ""
"href :: AttributeKey\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey\n"
"height = AttributeKey \"height\"\n"

#. type: Plain text
#: text/chapter14.md:207
msgid ""
"Here is the final exports list for our new module. Note that we no longer "
"export any data constructors directly:"
msgstr ""
"新しいモジュールの最終的なエクスポートリストは次のようになります。\n"
"最早どのデータ構築子も直接エクスポートしていない点に注目です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:208
#, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute\n"
"  , Content\n"
"  , AttributeKey\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , href\n"
"  , _class\n"
"  , src\n"
"  , width\n"
"  , height\n"
"\n"
"  , attribute, (:=)\n"
"  , text\n"
"  , elem\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute\n"
"  , Content\n"
"  , AttributeKey\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , href\n"
"  , _class\n"
"  , src\n"
"  , width\n"
"  , height\n"
"\n"
"  , attribute, (:=)\n"
"  , text\n"
"  , elem\n"
"\n"
"  , render\n"
"  ) where\n"

#. type: Plain text
#: text/chapter14.md:234
msgid ""
"If we try this new module in PSCi, we can already see massive improvements "
"in the conciseness of the user code:"
msgstr ""
"PSCiでこの新しいモジュールを試してみると、既にコードの簡潔さにおいて大幅な向"
"上が見て取れます。"

#. type: Fenced code block (text)
#: text/chapter14.md:235
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Smart\n"
"> import Effect.Console\n"
"> log $ render $ p [ _class := \"main\" ] [ text \"Hello World!\" ]\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Smart\n"
"> import Effect.Console\n"
"> log $ render $ p [ _class := \"main\" ] [ text \"Hello World!\" ]\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:248
msgid ""
"Note, however, that no changes had to be made to the `render` function, "
"because the underlying data representation never changed. This is one of the "
"benefits of the smart constructors approach – it allows us to separate the "
"internal data representation for a module from the representation perceived "
"by users of its external API."
msgstr ""
"しかし、基盤をなすデータ表現は全く変更されなかったので、`render`関数を変更す"
"る必要はなかったことにも注目してください。\n"
"これはスマート構築子による手法の利点のひとつです。\n"
"外部APIの使用者によって認識される表現から、モジュールの内部データ表現を分離で"
"きるのです。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:253
msgid ""
"(Easy) Use the `Data.DOM.Smart` module to experiment by creating new HTML "
"documents using `render`."
msgstr ""
"（簡単）`Data.DOM.Smart`モジュールで `render`を使った新しいHTML文書の作成を試"
"してみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:253
msgid ""
"(Medium) Some HTML attributes, such as `checked` and `disabled`, do not "
"require values and may be rendered as _empty attributes_:"
msgstr ""
"（普通）`checked`や`disabled`といったHTML属性は値を要求せず、*空の属性*として"
"書き出せます。"

#. type: Plain text
#: text/chapter14.md:257
#, no-wrap
msgid ""
"     ```html\n"
"     <input disabled>\n"
"     ```\n"
msgstr ""
"     ```html\n"
"     <input disabled>\n"
"     ```\n"

#. type: Plain text
#: text/chapter14.md:259
#, no-wrap
msgid "     Modify the representation of an `Attribute` to take empty attributes into account. Write a function which can be used in place of `attribute` or `:=` to add an empty attribute to an element.\n"
msgstr ""
"     空の属性を扱えるように `Attribute`の表現を変更してください。\n"
"     要素に空の属性を追加するための`attribute`または`:=`の代わりに使える関数を記述してください。\n"

#. type: Title ##
#: text/chapter14.md:260
#, no-wrap
msgid "Phantom Types"
msgstr "幻影型"

#. type: Plain text
#: text/chapter14.md:263
msgid "To motivate the next technique, consider the following code:"
msgstr "次の手法の動機付けとして、以下のコードを考えます。"

#. type: Fenced code block (text)
#: text/chapter14.md:264
#, no-wrap
msgid ""
"> log $ render $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := \"foo\"\n"
"    , height := \"bar\"\n"
"    ]\n"
"\n"
"<img src=\"cat.jpg\" width=\"foo\" height=\"bar\" />\n"
"unit\n"
msgstr ""
"> log $ render $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := \"foo\"\n"
"    , height := \"bar\"\n"
"    ]\n"
"\n"
"<img src=\"cat.jpg\" width=\"foo\" height=\"bar\" />\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:276
msgid ""
"The problem here is that we have provided string values for the `width` and "
"`height` attributes, where we should only be allowed to provide numeric "
"values in units of pixels or percentage points."
msgstr ""
"ここでの問題は、 `width`属性と`height`属性に文字列値を提供しているということ"
"です。\n"
"ここで与えることができるのはピクセル単位ないしパーセントの数値だけであるべき"
"です。"

#. type: Plain text
#: text/chapter14.md:278
msgid ""
"To solve this problem, we can introduce a so-called _phantom type_ argument "
"to our `AttributeKey` type:"
msgstr ""
"`AttributeKey`型にいわゆる _幻影型_ (phantom type) 引数を導入すると、この問題"
"を解決できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:279
#, no-wrap
msgid "newtype AttributeKey a = AttributeKey String\n"
msgstr "newtype AttributeKey a = AttributeKey String\n"

#. type: Plain text
#: text/chapter14.md:284
msgid ""
"The type variable `a` is called a _phantom type_ because there are no values "
"of type `a` involved in the right-hand side of the definition. The type `a` "
"only exists to provide more information at compile-time. Any value of type "
"`AttributeKey a` is simply a string at runtime, but at compile-time, the "
"type of the value tells us the desired type of the values associated with "
"this key."
msgstr ""
"定義の右辺に対応する型 `a`の値が存在しないので、この型変数 `a`は*幻影型*と呼"
"ばれています。\n"
"この型 `a`はコンパイル時に追加の情報を提供するためだけに存在しています。\n"
"型`AttributeKey a`の任意の値は実行時には単なる文字列ですが、コンパイル時はそ"
"の値の型により、このキーに関連する値で求められる型がわかります。"

#. type: Plain text
#: text/chapter14.md:286
msgid ""
"We can modify the type of our `attribute` function to take the new form of "
"`AttributeKey` into account:"
msgstr ""
"`attribute`関数の型を次のように変更すれば、`AttributeKey`の新しい形式を考慮す"
"るようにできます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:287
#, no-wrap
msgid ""
"attribute :: forall a. IsValue a => AttributeKey a -> a -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: toValue value\n"
"  }\n"
msgstr ""
"attribute :: forall a. IsValue a => AttributeKey a -> a -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: toValue value\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:296
msgid ""
"Here, the phantom type argument `a` is used to ensure that the attribute key "
"and attribute value have compatible types. Since the user cannot create "
"values of type `AttributeKey a` directly (only via the constants we provide "
"in the library), every attribute will be correct by construction."
msgstr ""
"ここで、幻影型の引数 `a`は、属性キーと属性値が照応する型を持っていることを確"
"認するために使われます。\n"
"使用者は `AttributeKey a`の型の値を直接作成できないので（ライブラリで提供され"
"ている定数を介してのみ得られます）、全ての属性が構築により正しくなります。"

#. type: Plain text
#: text/chapter14.md:298
msgid ""
"Note that the `IsValue` constraint ensures that whatever value type we "
"associate to a key, its values can be converted to strings and displayed in "
"the generated HTML. The `IsValue` type class is defined as follows:"
msgstr ""
"なお、`IsValue`制約はキーに関連付けられた値の型が何であれその値を文字列に変換"
"し、生成したHTML内に出力できることを保証します。\n"
"`IsValue`型クラスは次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:299
#, no-wrap
msgid ""
"class IsValue a where\n"
"  toValue :: a -> String\n"
msgstr ""
"class IsValue a where\n"
"  toValue :: a -> String\n"

#. type: Plain text
#: text/chapter14.md:305
msgid "We also provide type class instances for the `String` and `Int` types:"
msgstr "`String`と `Int`型についての型クラスインスタンスも提供しておきます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:306
#, no-wrap
msgid ""
"instance IsValue String where\n"
"  toValue = id\n"
"\n"
"instance IsValue Int where\n"
"  toValue = show\n"
msgstr ""
"instance IsValue String where\n"
"  toValue = id\n"
"\n"
"instance IsValue Int where\n"
"  toValue = show\n"

#. type: Plain text
#: text/chapter14.md:315
msgid ""
"We also have to update our `AttributeKey` constants so that their types "
"reflect the new type parameter:"
msgstr ""
"また、これらの型が新しい型変数を反映するように、 `AttributeKey`定数を更新しな"
"ければいけません。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:316
#, no-wrap
msgid ""
"href :: AttributeKey String\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey String\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey String\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey Int\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey Int\n"
"height = AttributeKey \"height\"\n"
msgstr ""
"href :: AttributeKey String\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey String\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey String\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey Int\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey Int\n"
"height = AttributeKey \"height\"\n"

#. type: Plain text
#: text/chapter14.md:334
msgid ""
"Now we find it is impossible to represent these invalid HTML documents, and "
"we are forced to use numbers to represent the `width` and `height` "
"attributes instead:"
msgstr ""
"これで、不正なHTML文書を表現することが不可能になっていることがわかります。\n"
"また、`width`と `height`属性を表現するのに文字列ではなく数を使うことが強制さ"
"れていることがわかります。"

#. type: Fenced code block (text)
#: text/chapter14.md:335
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Phantom\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ img\n"
"…   [ src    := \"cat.jpg\"\n"
"…   , width  := 100\n"
"…   , height := 200\n"
"…   ]\n"
"… ^D\n"
"\n"
"<img src=\"cat.jpg\" width=\"100\" height=\"200\" />\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Phantom\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ img\n"
"…   [ src    := \"cat.jpg\"\n"
"…   , width  := 100\n"
"…   , height := 200\n"
"…   ]\n"
"… ^D\n"
"\n"
"<img src=\"cat.jpg\" width=\"100\" height=\"200\" />\n"
"unit\n"

#. type: Bullet: ' 1. '
#: text/chapter14.md:356
msgid ""
"(Easy) Create a data type representing either pixel or percentage lengths. "
"Write an instance of `IsValue` for your type. Modify the `width` and "
"`height` attributes to use your new type."
msgstr ""
"（簡単）ピクセルまたはパーセントの何れかの長さを表すデータ型を作成してくださ"
"い。\n"
"その型について`IsValue`のインスタンスを書いてください。\n"
"この新しい型を使うように`width`と`height`属性を変更してください。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:356
msgid ""
"(Difficult) By defining type-level representatives for the Boolean values "
"`true` and `false`, we can use a phantom type to encode whether an "
"`AttributeKey` represents an _empty attribute_, such as `disabled` or "
"`checked`."
msgstr ""
"（難しい）真偽値`true`、`false`用の最上位の表現を定義することで、幻影型を使っ"
"て`AttributeKey`が`disabled`や`checked`のような*空の属性*を表現しているかどう"
"かをエンコードできます。"

#. type: Plain text
#: text/chapter14.md:361
#, no-wrap
msgid ""
"     ```haskell\n"
"     data True\n"
"     data False\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data True\n"
"     data False\n"
"     ```\n"

#. type: Plain text
#: text/chapter14.md:363
#, no-wrap
msgid "     Modify your solution to the previous exercise to use a phantom type to prevent the user from using the `attribute` operator with an empty attribute.\n"
msgstr "     幻影型を使って、使用者が `attribute`演算子を空の属性に対して使うことを防ぐように、前の演習の解答を変更してください。\n"

#. type: Title ##
#: text/chapter14.md:364
#, no-wrap
msgid "The Free Monad"
msgstr "Freeモナド"

#. type: Plain text
#: text/chapter14.md:367
msgid ""
"In our final set of modifications to our API, we will use a construction "
"called the _free monad_ to turn our `Content` type into a monad, enabling do "
"notation. This will allow us to structure our HTML documents in a form in "
"which the nesting of elements becomes clearer – instead of this:"
msgstr ""
"APIに施す最後の変更では、`Content`型をモナドにしてdo記法を使えるようにするた"
"めに、*Freeモナド*と呼ばれる構造を使っていきます。\n"
"これによって入れ子になった要素がわかりやすくなるような形式でHTML文書を構造化"
"できます。\n"
"以下の代わりに……"

#. type: Fenced code block (haskell)
#: text/chapter14.md:368
#, no-wrap
msgid ""
"p [ _class := \"main\" ]\n"
"  [ elem $ img\n"
"      [ src    := \"cat.jpg\"\n"
"      , width  := 100\n"
"      , height := 200\n"
"      ]\n"
"  , text \"A cat\"\n"
"  ]\n"
msgstr ""
"p [ _class := \"main\" ]\n"
"  [ elem $ img\n"
"      [ src    := \"cat.jpg\"\n"
"      , width  := 100\n"
"      , height := 200\n"
"      ]\n"
"  , text \"A cat\"\n"
"  ]\n"

#. type: Plain text
#: text/chapter14.md:380
msgid "we will be able to write this:"
msgstr "このように書くことができるようになります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:381
#, no-wrap
msgid ""
"p [ _class := \"main\" ] $ do\n"
"  elem $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := 100\n"
"    , height := 200\n"
"    ]\n"
"  text \"A cat\"\n"
msgstr ""
"p [ _class := \"main\" ] $ do\n"
"  elem $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := 100\n"
"    , height := 200\n"
"    ]\n"
"  text \"A cat\"\n"

#. type: Plain text
#: text/chapter14.md:392
msgid ""
"However, do notation is not the only benefit of a free monad. The free monad "
"allows us to separate the _representation_ of our monadic actions from their "
"_interpretation_ and even support _multiple interpretations_ of the same "
"actions."
msgstr ""
"しかし、do記法だけがFreeモナドの恩恵ではありません。\n"
"Freeモナドがあれば、モナドの動作の*表現*をその*解釈*から分離し、同じ動作に*複"
"数の解釈*を持たせることさえできます。"

#. type: Plain text
#: text/chapter14.md:394
msgid ""
"The `Free` monad is defined in the `free` library in the `Control.Monad."
"Free` module. We can find out some basic information about it using PSCi, as "
"follows:"
msgstr ""
"`Free`モナドは`free`ライブラリの`Control.Monad.Free`モジュールで定義されてい"
"ます。\n"
"PSCiを使うと、次のようにFreeモナドについての基本的な情報を見ることができま"
"す。"

#. type: Fenced code block (text)
#: text/chapter14.md:395
#, no-wrap
msgid ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter14.md:403
msgid ""
"The kind of `Free` indicates that it takes a type constructor as an argument "
"and returns another type constructor. In fact, the `Free` monad can be used "
"to turn any `Functor` into a `Monad`!"
msgstr ""
"`Free`の種は、引数として型構築子を取り、別の型構築子を返すことを示していま"
"す。\n"
"実はなんと、`Free`モナドを使えば任意の`Functor`を`Monad`にできるのです。"

#. type: Plain text
#: text/chapter14.md:405
msgid ""
"We begin by defining the _representation_ of our monadic actions. To do "
"this, we need to create a `Functor` with one data constructor for each "
"monadic action we wish to support. In our case, our two monadic actions will "
"be `elem` and `text`. We can simply modify our `Content` type as follows:"
msgstr ""
"モナドの動作の*表現*の定義から始めます。\n"
"これには対応したい各モナド動作について、1つのデータ構築子を持つ`Functor`を作"
"成する必要があります。\n"
"今回の場合、2つのモナドの動作は`elem`と`text`になります。\n"
"`Content`型を次のように変更するだけでできます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:406
#, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"\n"
"instance Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
msgstr ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"\n"
"instance Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"

#. type: Plain text
#: text/chapter14.md:417
msgid ""
"Here, the `ContentF` type constructor looks just like our old `Content` data "
"type – however, it now takes a type argument `a`, and each data constructor "
"has been modified to take a value of type `a` as an additional argument. The "
"`Functor` instance simply applies the function `f` to the value of type `a` "
"in each data constructor."
msgstr ""
"ここで、この`ContentF`型構築子は以前の`Content`データ型とよく似ています。\n"
"しかし、ここでは型引数`a`を取り、それぞれのデータ構築子は型`a`の値を追加の引"
"数として取るように変更されています。\n"
"`Functor`インスタンスでは、単に各データ構築子で型`a`の値に関数`f`を適用しま"
"す。"

#. type: Plain text
#: text/chapter14.md:419
msgid ""
"With that, we can define our new `Content` monad as a type synonym for the "
"`Free` monad, which we construct by using our `ContentF` type constructor as "
"the first type argument:"
msgstr ""
"これにより、新しい`Content`モナドを`Free`モナド用の型シノニムとして定義できま"
"す。\n"
"これは最初の型引数として `ContentF`型構築子を使うことで構築されます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:420
#, no-wrap
msgid "type Content = Free ContentF\n"
msgstr "type Content = Free ContentF\n"

#. type: Plain text
#: text/chapter14.md:425
msgid ""
"Instead of a type synonym, we might use a `newtype` to avoid exposing the "
"internal representation of our library to our users – by hiding the "
"`Content` data constructor, we restrict our users to only using the monadic "
"actions we provide."
msgstr ""
"型同義語の代わりに`newtype`を使用して、使用者に対してライブラリの内部表現を露"
"出することを避けられます。\n"
"`Content`データ構築子を隠すことで、提供しているモナドの動作だけを使うことを使"
"用者に制限しています。"

#. type: Plain text
#: text/chapter14.md:427
msgid ""
"Because `ContentF` is a `Functor`, we automatically get a `Monad` instance "
"for `Free ContentF`."
msgstr ""
"`ContentF`は `Functor`なので、 `Free ContentF`用の`Monad`インスタンスが自動的"
"に手に入ります。"

#. type: Plain text
#: text/chapter14.md:429
msgid ""
"We have to modify our `Element` data type slightly to take account of the "
"new type argument on `Content`. We will simply require that the return type "
"of our monadic computations be `Unit`:"
msgstr ""
"`Content`の新しい型引数を考慮するように`Element`データ型を僅かに変更する必要"
"があります。\n"
"モナドの計算の戻り値の型が `Unit`であることだけが必要です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:430
#, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Content Unit)\n"
"  }\n"
msgstr ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Content Unit)\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:439
msgid ""
"In addition, we have to modify our `elem` and `text` functions, which become "
"our new monadic actions for the `Content` monad. To do this, we can use the "
"`liftF` function provided by the `Control.Monad.Free` module. Here is its "
"type:"
msgstr ""
"また、`Content`モナドについての新しいモナドの動作になるよう、`elem`と`text`関"
"数を変更する必要があります。\n"
"これには`Control.Monad.Free`モジュールで提供されている `liftF`関数が使えま"
"す。\n"
"以下がその型です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:440
#, no-wrap
msgid "liftF :: forall f a. f a -> Free f a\n"
msgstr "liftF :: forall f a. f a -> Free f a\n"

#. type: Plain text
#: text/chapter14.md:445
msgid ""
"`liftF` allows us to construct an action in our free monad from a value of "
"type `f a` for some type `a`. In our case, we can use the data constructors "
"of our `ContentF` type constructor directly:"
msgstr ""
"`liftF`により、何らかの型`a`について、型`f a`の値からFreeモナドの動作を構築で"
"きるようになります。\n"
"今回の場合、`ContentF`型構築子のデータ構築子をそのまま使えます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:446
#, no-wrap
msgid ""
"text :: String -> Content Unit\n"
"text s = liftF $ TextContent s unit\n"
"\n"
"elem :: Element -> Content Unit\n"
"elem e = liftF $ ElementContent e unit\n"
msgstr ""
"text :: String -> Content Unit\n"
"text s = liftF $ TextContent s unit\n"
"\n"
"elem :: Element -> Content Unit\n"
"elem e = liftF $ ElementContent e unit\n"

#. type: Plain text
#: text/chapter14.md:455
msgid ""
"Some other routine modifications have to be made, but the interesting "
"changes are in the `render` function, where we have to _interpret_ our free "
"monad."
msgstr ""
"他にも同じようなコードの変更はありますが、興味深い変更は `render`関数にありま"
"す。ここでは、このFreeモナドを _解釈_ しなければいけません。"

#. type: Title ##
#: text/chapter14.md:456
#, no-wrap
msgid "Interpreting the Monad"
msgstr "モナドの解釈"

#. type: Plain text
#: text/chapter14.md:459
msgid ""
"The `Control.Monad.Free` module provides a number of functions for "
"interpreting a computation in a free monad:"
msgstr ""
"`Control.Monad.Free`モジュールでは、Freeモナドで計算を解釈するための多数の関"
"数が提供されています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:460
#, no-wrap
msgid ""
"runFree\n"
"  :: forall f a\n"
"   . Functor f\n"
"  => (f (Free f a) -> Free f a)\n"
"  -> Free f a\n"
"  -> a\n"
"\n"
"runFreeM\n"
"  :: forall f m a\n"
"   . (Functor f, MonadRec m)\n"
"  => (f (Free f a) -> m (Free f a))\n"
"  -> Free f a\n"
"  -> m a\n"
msgstr ""
"runFree\n"
"  :: forall f a\n"
"   . Functor f\n"
"  => (f (Free f a) -> Free f a)\n"
"  -> Free f a\n"
"  -> a\n"
"\n"
"runFreeM\n"
"  :: forall f m a\n"
"   . (Functor f, MonadRec m)\n"
"  => (f (Free f a) -> m (Free f a))\n"
"  -> Free f a\n"
"  -> m a\n"

#. type: Plain text
#: text/chapter14.md:477
msgid ""
"The `runFree` function is used to compute a _pure_ result. The `runFreeM` "
"function allows us to use a monad to interpret the actions of our free monad."
msgstr ""
"`runFree`関数は、*純粋な*結果を計算するために使用されます。\n"
"`runFreeM`関数があればFreeモナドの動作を解釈するためにモナドが使えます。"

#. type: Plain text
#: text/chapter14.md:479
msgid ""
"_Note_: Technically, we are restricted to monads `m` that satisfy the "
"stronger `MonadRec` constraint. In practice, we don't need to worry about "
"stack overflow since `m` supports safe _monadic tail recursion_."
msgstr ""
"*補足*：厳密には、より強い`MonadRec`制約を満たすモナド`m`に制限されていま"
"す。\n"
"実際、ら`m`は安全な*末尾再帰モナド*に対応してため、スタックオーバーフローを心"
"配する必要はありません。"

#. type: Plain text
#: text/chapter14.md:481
msgid ""
"First, we have to choose a monad in which we can interpret our actions. We "
"will use the `Writer String` monad to accumulate an HTML string as our "
"result."
msgstr ""
"まず、動作を解釈できるモナドを選ばなければなりません。\n"
"`Writer String`モナドを使って、結果のHTML文字列を累算することにします。"

#. type: Plain text
#: text/chapter14.md:483
msgid ""
"Our new `render` method starts by delegating to a helper function, "
"`renderElement`, and using `execWriter` to run our computation in the "
"`Writer` monad:"
msgstr ""
"新しい`render`メソッドが開始すると、補助関数 `renderElement`に移譲し、"
"`execWriter`を使って`Writer`モナドで計算します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:484
#, no-wrap
msgid ""
"render :: Element -> String\n"
"render = execWriter <<< renderElement\n"
msgstr ""
"render :: Element -> String\n"
"render = execWriter <<< renderElement\n"

#. type: Plain text
#: text/chapter14.md:490
msgid "`renderElement` is defined in a where block:"
msgstr "`renderElement`はwhereブロックで定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:491
#, no-wrap
msgid ""
"  where\n"
"    renderElement :: Element -> Writer String Unit\n"
"    renderElement (Element e) = do\n"
msgstr ""
"  where\n"
"    renderElement :: Element -> Writer String Unit\n"
"    renderElement (Element e) = do\n"

#. type: Plain text
#: text/chapter14.md:498
msgid ""
"The definition of `renderElement` is straightforward, using the `tell` "
"action from the `Writer` monad to accumulate several small strings:"
msgstr ""
"`renderElement`の定義は直感的で、複数の小さな文字列を累算するために`Writer`モ"
"ナドの`tell`動作を使っています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:499
#, no-wrap
msgid ""
"      tell \"<\"\n"
"      tell e.name\n"
"      for_ e.attribs $ \\x -> do\n"
"        tell \" \"\n"
"        renderAttribute x\n"
"      renderContent e.content\n"
msgstr ""
"      tell \"<\"\n"
"      tell e.name\n"
"      for_ e.attribs $ \\x -> do\n"
"        tell \" \"\n"
"        renderAttribute x\n"
"      renderContent e.content\n"

#. type: Plain text
#: text/chapter14.md:509
msgid ""
"Next, we define the `renderAttribute` function, which is equally simple:"
msgstr ""
"次に、`renderAttribute`関数を定義します。\n"
"こちらも同じくらい単純です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:510
#, no-wrap
msgid ""
"    where\n"
"      renderAttribute :: Attribute -> Writer String Unit\n"
"      renderAttribute (Attribute x) = do\n"
"        tell x.key\n"
"        tell \"=\\\"\"\n"
"        tell x.value\n"
"        tell \"\\\"\"\n"
msgstr ""
"    where\n"
"      renderAttribute :: Attribute -> Writer String Unit\n"
"      renderAttribute (Attribute x) = do\n"
"        tell x.key\n"
"        tell \"=\\\"\"\n"
"        tell x.value\n"
"        tell \"\\\"\"\n"

#. type: Plain text
#: text/chapter14.md:521
msgid ""
"The `renderContent` function is more interesting. Here, we use the "
"`runFreeM` function to interpret the computation inside the free monad, "
"delegating to a helper function, `renderContentItem`:"
msgstr ""
"`renderContent`関数は、もっと興味深いものです。\n"
"ここでは`runFreeM`関数を使い、Freeモナドの内部で計算を解釈しています。\n"
"計算は補助関数 `renderContentItem`に移譲しています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:522
#, no-wrap
msgid ""
"      renderContent :: Maybe (Content Unit) -> Writer String Unit\n"
"      renderContent Nothing = tell \" />\"\n"
"      renderContent (Just content) = do\n"
"        tell \">\"\n"
"        runFreeM renderContentItem content\n"
"        tell \"</\"\n"
"        tell e.name\n"
"        tell \">\"\n"
msgstr ""
"      renderContent :: Maybe (Content Unit) -> Writer String Unit\n"
"      renderContent Nothing = tell \" />\"\n"
"      renderContent (Just content) = do\n"
"        tell \">\"\n"
"        runFreeM renderContentItem content\n"
"        tell \"</\"\n"
"        tell e.name\n"
"        tell \">\"\n"

#. type: Plain text
#: text/chapter14.md:534
msgid ""
"The type of `renderContentItem` can be deduced from the type signature of "
"`runFreeM`. The functor `f` is our type constructor `ContentF`, and the "
"monad `m` is the monad in which we are interpreting the computation, namely "
"`Writer String`. This gives the following type signature for "
"`renderContentItem`:"
msgstr ""
"`renderContentItem`の型は `runFreeM`の型シグネチャから推測できます。\n"
"関手 `f`は型構築子 `ContentF`で、モナド `m`は解釈している計算のモナド、つま"
"り `Writer String`です。\n"
"これにより `renderContentItem`は次の型シグネチャだとわかります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:535
#, no-wrap
msgid "      renderContentItem :: ContentF (Content Unit) -> Writer String (Content Unit)\n"
msgstr "      renderContentItem :: ContentF (Content Unit) -> Writer String (Content Unit)\n"

#. type: Plain text
#: text/chapter14.md:540
msgid ""
"We can implement this function by pattern matching on the two data "
"constructors of `ContentF`:"
msgstr ""
"`ContentF`の2つのデータ構築子でパターン照合すればこの関数を実装できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:541
#, no-wrap
msgid ""
"      renderContentItem (TextContent s rest) = do\n"
"        tell s\n"
"        pure rest\n"
"      renderContentItem (ElementContent e rest) = do\n"
"        renderElement e\n"
"        pure rest\n"
msgstr ""
"      renderContentItem (TextContent s rest) = do\n"
"        tell s\n"
"        pure rest\n"
"      renderContentItem (ElementContent e rest) = do\n"
"        renderElement e\n"
"        pure rest\n"

#. type: Plain text
#: text/chapter14.md:551
msgid ""
"In each case, the expression `rest` has the type `Content Unit` and "
"represents the remainder of the interpreted computation. We can complete "
"each case by returning the `rest` action."
msgstr ""
"それぞれの場合において、式`rest`は型`Content Unit`を持っており、解釈された計"
"算の残りを表しています。\n"
"`rest`動作を返すことでそれぞれの場合を完成できます。"

#. type: Plain text
#: text/chapter14.md:553
msgid "That's it! We can test our new monadic API in PSCi, as follows:"
msgstr ""
"できました。\n"
"PSCiで、次のようにすれば新しいモナドのAPIを試すことができます。"

#. type: Fenced code block (text)
#: text/chapter14.md:554
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Free\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ p [] $ do\n"
"…   elem $ img [ src := \"cat.jpg\" ]\n"
"…   text \"A cat\"\n"
"… ^D\n"
"\n"
"<p><img src=\"cat.jpg\" />A cat</p>\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Free\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ p [] $ do\n"
"…   elem $ img [ src := \"cat.jpg\" ]\n"
"…   text \"A cat\"\n"
"… ^D\n"
"\n"
"<p><img src=\"cat.jpg\" />A cat</p>\n"
"unit\n"

#. type: Bullet: ' 1. '
#: text/chapter14.md:572
msgid ""
"(Medium) Add a new data constructor to the `ContentF` type to support a new "
"action `comment`, which renders a comment in the generated HTML. Implement "
"the new action using `liftF`. Update the interpretation `renderContentItem` "
"to interpret your new constructor appropriately."
msgstr ""
"（普通）`ContentF`型に新しいデータ構築子を追加して、生成されたHTMLにコメント"
"を出力する新しい動作`comment`に対応してください。\n"
"`liftF`を使ってこの新しい動作を実装してください。\n"
"新しい構築子を適切に解釈するように、解釈`renderContentItem`を更新してくださ"
"い。"

#. type: Title ##
#: text/chapter14.md:573
#, no-wrap
msgid "Extending the Language"
msgstr "言語の拡張"

#. type: Plain text
#: text/chapter14.md:576
msgid ""
"A monad in which every action returns something of type `Unit` is not "
"particularly interesting. In fact, aside from an arguably nicer syntax, our "
"monad adds no extra functionality over a `Monoid`."
msgstr ""
"全動作が型`Unit`の何かを返すようなモナドは、さほど興味深いものではありませ"
"ん。\n"
"実際のところ、概ね良くなったと思われる構文は別として、このモナドは`Monoid`以"
"上の機能を何ら追加していません。"

#. type: Plain text
#: text/chapter14.md:578
msgid ""
"Let's illustrate the power of the free monad construction by extending our "
"language with a new monadic action that returns a non-trivial result."
msgstr ""
"非自明な結果を返す新しいモナド動作でこの言語を拡張することで、Freeモナドを構"
"築する威力をお見せしましょう。"

#. type: Plain text
#: text/chapter14.md:580
msgid ""
"Suppose we want to generate HTML documents that contain hyperlinks to "
"different sections of the document using _anchors_. We can accomplish this "
"by generating anchor names by hand and including them at least twice in the "
"document: once at the anchor's definition and once in each hyperlink. "
"However, this approach has some basic issues:"
msgstr ""
"*アンカー*を使用して文書の様々な節へのハイパーリンクが含まれているHTML文書を"
"生成したいとします。\n"
"手作業でアンカーの名前を生成して文書中で少なくとも2回それらを含めれば、これは"
"達成できます。\n"
"1つはアンカーの定義自身に、もう1つは各ハイパーリンクにあります。\n"
"しかし、この手法には基本的な問題が幾つかあります。"

#. type: Bullet: '- '
#: text/chapter14.md:583
msgid "The developer might fail to generate unique anchor names."
msgstr "開発者が一意なアンカー名の生成をし損なうかもしれません。"

#. type: Bullet: '- '
#: text/chapter14.md:583
msgid "The developer might mistype one or more instances of the anchor name."
msgstr "開発者がアンカー名を1つ以上の箇所で打ち間違うかもしれません。"

#. type: Plain text
#: text/chapter14.md:585
msgid ""
"To protect the developer from their mistakes, we can introduce a new type "
"that represents anchor names and provide a monadic action for generating new "
"unique names."
msgstr ""
"開発者が誤ちを犯すことを防ぐために、アンカー名を表す新しい型を導入し、新しい"
"一意な名前を生成するためのモナド動作を提供できます。"

#. type: Plain text
#: text/chapter14.md:587
msgid "The first step is to add a new type for names:"
msgstr "最初の工程は名前の型を新しく追加することです。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:588
#, no-wrap
msgid ""
"newtype Name = Name String\n"
"\n"
"runName :: Name -> String\n"
"runName (Name n) = n\n"
msgstr ""
"newtype Name = Name String\n"
"\n"
"runName :: Name -> String\n"
"runName (Name n) = n\n"

#. type: Plain text
#: text/chapter14.md:596
msgid ""
"Again, we define this as a newtype around `String`, but we must be careful "
"not to export the data constructor in the module's export lists."
msgstr ""
"繰り返しになりますが、`Name`は `String`のnewtypeとして定義しているものの、モ"
"ジュールのエクスポートリスト内でデータ構築子をエクスポートしないように注意す"
"る必要があります。"

#. type: Plain text
#: text/chapter14.md:598
msgid ""
"Next, we define an instance for the `IsValue` type class for our new type so "
"that we can use names in attribute values:"
msgstr ""
"次に、属性値に`Name`を使えるよう、新しい型に`IsValue`型クラスのインスタンスを"
"定義します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:599
#, no-wrap
msgid ""
"instance IsValue Name where\n"
"  toValue (Name n) = n\n"
msgstr ""
"instance IsValue Name where\n"
"  toValue (Name n) = n\n"

#. type: Plain text
#: text/chapter14.md:605
msgid ""
"We also define a new data type for hyperlinks which can appear in `a` "
"elements, as follows:"
msgstr ""
"また、次のように `a`要素に現れるハイパーリンク用の新しいデータ型を定義しま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:606
#, no-wrap
msgid ""
"data Href\n"
"  = URLHref String\n"
"  | AnchorHref Name\n"
"\n"
"instance IsValue Href where\n"
"  toValue (URLHref url) = url\n"
"  toValue (AnchorHref (Name nm)) = \"#\" <> nm\n"
msgstr ""
"data Href\n"
"  = URLHref String\n"
"  | AnchorHref Name\n"
"\n"
"instance IsValue Href where\n"
"  toValue (URLHref url) = url\n"
"  toValue (AnchorHref (Name nm)) = \"#\" <> nm\n"

#. type: Plain text
#: text/chapter14.md:617
msgid ""
"With this new type, we can modify the value type of the `href` attribute, "
"forcing our users to use our new `Href` type. We can also create a new "
"`name` attribute, which can be used to turn an element into an anchor:"
msgstr ""
"この新しい型により、`href`属性の型の値を変更して、利用者にこの新しい `Href`型"
"の使用を強制できます。\n"
"また、新しい`name`属性も作成でき、要素をアンカーに変換するのに使えます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:618
#, no-wrap
msgid ""
"href :: AttributeKey Href\n"
"href = AttributeKey \"href\"\n"
"\n"
"name :: AttributeKey Name\n"
"name = AttributeKey \"name\"\n"
msgstr ""
"href :: AttributeKey Href\n"
"href = AttributeKey \"href\"\n"
"\n"
"name :: AttributeKey Name\n"
"name = AttributeKey \"name\"\n"

#. type: Plain text
#: text/chapter14.md:627
msgid ""
"The remaining problem is that our users currently have no way to generate "
"new names. We can provide this functionality in our `Content` monad. First, "
"we need to add a new data constructor to our `ContentF` type constructor:"
msgstr ""
"残っている問題は、現在モジュールの使用者が新しい名前を生成する方法がないとい"
"うことです。\n"
"`Content`モナドでこの機能を提供できます。まず、 `ContentF`型構築子に新しい"
"データ構築子を追加する必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:628
#, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"  | NewName (Name -> a)\n"
msgstr ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"  | NewName (Name -> a)\n"

#. type: Plain text
#: text/chapter14.md:636
#, no-wrap
msgid "The `NewName` data constructor corresponds to an action which returns a value of type `Name`. Notice that instead of requiring a `Name` as a data constructor argument, we require the user to provide a _function_ of type `Name -> a`. Remembering that the type `a` represents the _rest of the computation_, we can see that this function provides a way to continue computation after a value of type `Name` has been returned.\n"
msgstr ""
"`NewName`データ構築子は型`Name`の値を返す動作に対応しています。\n"
"データ構築子の引数として`Name`を要求するのではなく、型`Name -> a`の*関数*を提供するように使用者に要求していることに注意してください。\n"
"型`a`は*計算の残り*を表していることを思い出すと、この関数は、型`Name`の値が返されたあとで、計算を継続する方法を提供しているのだとわかります。\n"

#. type: Plain text
#: text/chapter14.md:638
msgid ""
"We also need to update the `Functor` instance for `ContentF`, taking into "
"account the new data constructor, as follows:"
msgstr ""
"新しいデータ構築子を考慮するよう、次のように`ContentF`用の`Functor`インスタン"
"スを更新する必要もあります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:639
#, no-wrap
msgid ""
"instance Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
"  map f (NewName k) = NewName (f <<< k)\n"
msgstr ""
"instance Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
"  map f (NewName k) = NewName (f <<< k)\n"

#. type: Plain text
#: text/chapter14.md:647
msgid ""
"Now we can build our new action by using the `liftF` function, as before:"
msgstr "これで、以前と同じように`liftF`関数を使って新しい動作を構築できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:648
#, no-wrap
msgid ""
"newName :: Content Name\n"
"newName = liftF $ NewName id\n"
msgstr ""
"newName :: Content Name\n"
"newName = liftF $ NewName id\n"

#. type: Plain text
#: text/chapter14.md:654
msgid ""
"Notice that we provide the `id` function as our continuation, meaning we "
"return the result of type `Name` unchanged."
msgstr ""
"`id`関数を継続として提供していることに注意してください。\n"
"つまり型`Name`の結果を変更せずに返しています。"

#. type: Plain text
#: text/chapter14.md:656
msgid ""
"Finally, we need to update our interpretation function to interpret the new "
"action. We previously used the `Writer String` monad to interpret our "
"computations, but that monad cannot generate new names, so we must switch to "
"something else. The `WriterT` monad transformer can be used with the `State` "
"monad to combine the effects we need. We can define our interpretation monad "
"as a type synonym to keep our type signatures short:"
msgstr ""
"最後に、新しい動作を解釈させるように解釈関数を更新する必要があります。\n"
"以前は計算を解釈するために`Writer String`モナドを使っていましたが、このモナド"
"は新しい名前を生成できないので、何か他のものに切り替えなければなりません。\n"
"`WriterT`モナド変換子を`State`モナドと一緒に使うと、必要な作用を組み合わせら"
"れます。\n"
"型注釈が短く保たれるよう、この解釈モナドを型同義語として定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:657
#, no-wrap
msgid "type Interp = WriterT String (State Int)\n"
msgstr "type Interp = WriterT String (State Int)\n"

#. type: Plain text
#: text/chapter14.md:662
msgid ""
"Here, the state of type `Int` will act as an incrementing counter, used to "
"generate unique names."
msgstr ""
"ここで、`Int`型の状態は増加していくカウンタとして振舞い、一意な名前を生成する"
"のに使われます。"

#. type: Plain text
#: text/chapter14.md:664
msgid ""
"Because the `Writer` and `WriterT` monads use the same type class members to "
"abstract their actions, we do not need to change any actions – we only need "
"to replace every reference to `Writer String` with `Interp`. However, we "
"need to modify the handler used to run our computation. Instead of just "
"`execWriter`, we now need to use `evalState` as well:"
msgstr ""
"`Writer`と`WriterT`モナドはそれらの動作を抽象化するのに同じ型クラスの構成要素"
"を使うので、どの動作も変更する必要がありません。\n"
"必要なのは、`Writer String`への参照全てを`Interp`で置き換えることだけです。\n"
"しかし、計算に使われる制御子は変更する必要があります。\n"
"単なる`execWriter`の代わりに、`evalState`も使う必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:665
#, no-wrap
msgid ""
"render :: Element -> String\n"
"render e = evalState (execWriterT (renderElement e)) 0\n"
msgstr ""
"render :: Element -> String\n"
"render e = evalState (execWriterT (renderElement e)) 0\n"

#. type: Plain text
#: text/chapter14.md:671
msgid ""
"We also need to add a new case to `renderContentItem`, to interpret the new "
"`NewName` data constructor:"
msgstr ""
"また、新しい `NewName`データ構築子を解釈するために、 `renderContentItem`に新"
"しい場合を追加しなければいけません。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:672
#, no-wrap
msgid ""
"renderContentItem (NewName k) = do\n"
"  n <- get\n"
"  let fresh = Name $ \"name\" <> show n\n"
"  put $ n + 1\n"
"  pure (k fresh)\n"
msgstr ""
"renderContentItem (NewName k) = do\n"
"  n <- get\n"
"  let fresh = Name $ \"name\" <> show n\n"
"  put $ n + 1\n"
"  pure (k fresh)\n"

#. type: Plain text
#: text/chapter14.md:681
#, no-wrap
msgid "Here, we are given a continuation `k` of type `Name -> Content a`, and we need to construct an interpretation of type `Content a`. Our interpretation is simple: we use `get` to read the state, use that state to generate a unique name, then use `put` to increment the state. Finally, we pass our new name to the continuation to complete the computation.\n"
msgstr ""
"ここで、型 `Name -> Content a`の継続 `k`が与えられているので、型 `Content a`の解釈を構築しなければいけません。\n"
"この解釈は単純です。\n"
"`get`を使って状態を読み、その状態を使って一意な名前を生成し、それから `put`で状態に1だけ足すのです。\n"
"最後に、継続にこの新しい名前を渡して、計算を完了します。\n"

#. type: Plain text
#: text/chapter14.md:683
msgid ""
"With that, we can try out our new functionality in PSCi, by generating a "
"unique name inside the `Content` monad and using it as both the name of an "
"element and the target of a hyperlink:"
msgstr ""
"以上をもって、この新しい機能をPSCiで試せます。\n"
"これには`Content`モナドの内部で一意な名前を生成し、要素の名前とハイパーリンク"
"のリンク先の両方として使います。"

#. type: Fenced code block (text)
#: text/chapter14.md:684
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Name\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… render $ p [ ] $ do\n"
"…   top <- newName\n"
"…   elem $ a [ name := top ] $\n"
"…     text \"Top\"\n"
"…   elem $ a [ href := AnchorHref top ] $\n"
"…     text \"Back to top\"\n"
"… ^D\n"
"\n"
"<p><a name=\"name0\">Top</a><a href=\"#name0\">Back to top</a></p>\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Name\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… render $ p [ ] $ do\n"
"…   top <- newName\n"
"…   elem $ a [ name := top ] $\n"
"…     text \"Top\"\n"
"…   elem $ a [ href := AnchorHref top ] $\n"
"…     text \"Back to top\"\n"
"… ^D\n"
"\n"
"<p><a name=\"name0\">Top</a><a href=\"#name0\">Back to top</a></p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:703
msgid ""
"You can verify that multiple calls to `newName` do, in fact, result in "
"unique names."
msgstr ""
"複数回の`newName`の呼び出しの結果が、実際に一意な名前になっていることも確かめ"
"られます。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:711
msgid ""
"(Medium) We can simplify the API further by hiding the `Element` type from "
"its users. Make these changes in the following steps:"
msgstr ""
"（普通）使用者から `Element`型を隠蔽すると、更にAPIを簡素にできます。\n"
"次の手順に従って、これらの変更を加えてください。"

#. type: Bullet: '     - '
#: text/chapter14.md:711
msgid ""
"Combine functions like `p` and `img` (with return type `Element`) with the "
"`elem` action to create new actions with return type `Content Unit`."
msgstr ""
"`p`や`img`のような（返る型が`Element`の）関数を`elem`動作と結合して、型"
"`Content Unit`を返す新しい動作を作ってください。"

#. type: Bullet: '     - '
#: text/chapter14.md:711
msgid ""
"Change the `render` function to accept an argument of type `Content Unit` "
"instead of `Element`."
msgstr ""
"`Element`の代わりに型`Content Unit`の引数を受け付けるように`render`関数を変更"
"してください。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:711
msgid ""
"(Medium) Hide the implementation of the `Content` monad using a `newtype` "
"instead of a type synonym. You should not export the data constructor for "
"your `newtype`."
msgstr ""
"（普通）型同義語の代わりに`newtype`を使って`Content`モナドの実装を隠してくだ"
"さい。\n"
"`newtype`用のデータ構築子はエクスポートすべきではありません。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:711
msgid "(Difficult) Modify the `ContentF` type to support a new action"
msgstr "（難しい）`ContentF`型を変更して以下の新しい動作に対応してください。"

#. type: Plain text
#: text/chapter14.md:715
#, no-wrap
msgid ""
"     ```haskell\n"
"     isMobile :: Content Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     isMobile :: Content Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter14.md:717
#, no-wrap
msgid "     which returns a boolean value indicating whether or not the document is being rendered for display on a mobile device.\n"
msgstr "     この動作は、この文書がモバイルデバイス上での表示のために描画されているかどうかを示す真偽値を返します。\n"

#. type: Plain text
#: text/chapter14.md:719
#, no-wrap
msgid "     _Hint_: use the `ask` action and the `ReaderT` monad transformer to interpret this action. Alternatively, you might prefer to use the `RWS` monad.\n"
msgstr ""
"     *手掛かり*：`ask`動作と`ReaderT`モナド変換子を使って、この動作を解釈してください。\n"
"     あるいは、`RWS`モナドを使うほうが好みの人もいるかもしれません。\n"

#. type: Plain text
#: text/chapter14.md:723
msgid ""
"In this chapter, we developed a domain-specific language for creating HTML "
"documents by incrementally improving a naive implementation using some "
"standard techniques:"
msgstr ""
"この章では、幾つかの標準的な技術を使って、素朴な実装を段階的に改善することに"
"より、HTML文書を作成するための領域特化言語を開発しました。"

#. type: Bullet: '- '
#: text/chapter14.md:728
msgid ""
"We used _smart constructors_ to hide the details of our data representation, "
"only permitting the user to create documents that were _correct-by-"
"construction_."
msgstr ""
"*スマート構築子*を使ってデータ表現の詳細を隠し、利用者には*構築により正しい*"
"文書だけを作ることを許しました。"

#. type: Bullet: '- '
#: text/chapter14.md:728
msgid ""
"We used a _user-defined infix binary operator_ to improve the syntax of the "
"language."
msgstr "*独自に定義された中置2引数演算子*を使い、言語の構文を改善しました。"

#. type: Bullet: '- '
#: text/chapter14.md:728
msgid ""
"We used _phantom types_ to encode additional information in the types of our "
"data, preventing the user from providing attribute values of the wrong type."
msgstr ""
"*幻影型*を使ってデータの型の中に追加の情報を折り込みました。\n"
"これにより利用者が誤った型の属性値を与えることを防いでいます。"

#. type: Bullet: '- '
#: text/chapter14.md:728
msgid ""
"We used the _free monad_ to turn our array representation of a collection of "
"content into a monadic representation supporting do notation. We then "
"extended this representation to support a new monadic action and interpreted "
"the monadic computations using standard monad transformers."
msgstr ""
"*Freeモナド*を使って内容の集まりの配列表現をdo記法に対応したモナドな表現に変"
"えました。\n"
"それからこの表現を新しいモナド動作に対応するよう拡張し、標準的なモナド変換子"
"を使ってモナドの計算を解釈しました。"

#. type: Plain text
#: text/chapter14.md:730
msgid ""
"These techniques all leverage PureScript's module and type systems, either "
"to prevent the user from making mistakes or to improve the syntax of the "
"domain-specific language."
msgstr ""
"これらの手法は全て、使用者が間違いを犯すのを防いだり領域特化言語の構文を改良"
"したりするために、PureScriptのモジュールと型システムを活用しています。"

#. type: Plain text
#: text/chapter14.md:731
msgid ""
"Implementing domain-specific languages in functional programming languages "
"is an area of active research. Still, hopefully, this provides a useful "
"introduction to some simple techniques and illustrates the power of working "
"in a language with expressive types."
msgstr ""
"関数型プログラミング言語による領域特化言語の実装は活発に研究されている分野で"
"す。\n"
"それでも、幾つかの単純な技法に対して役に立つ導入を提供し、表現力豊かな型を持"
"つ言語で作業することの威力を示すことができていれば幸いです。"

#. type: Title #
#: text/chapter2.md:1
#, no-wrap
msgid "Getting Started"
msgstr "はじめよう"

#. type: Plain text
#: text/chapter2.md:6
msgid ""
"In this chapter, we'll set up a working PureScript development environment, "
"solve some exercises, and use the tests provided with this book to check our "
"answers. You may also find a [video walkthrough of this chapter](https://www."
"youtube.com/watch?v=GPjPwb6d-70) helpful if that better suits your learning "
"style."
msgstr ""
"本章では実際のPureScriptの開発環境を立ち上げ、幾つかの演習を解き、本書で提供"
"されているテストを使って答えを確認します。\n"
"もし映像を見る学習の仕方が合っているようでしたら、[本章を通しで進めるビデオ]"
"(https://www.youtube.com/watch?v=GPjPwb6d-70)が役に立つでしょう。"

#. type: Title ##
#: text/chapter2.md:7
#, no-wrap
msgid "Environment Setup"
msgstr "環境構築"

#. type: Plain text
#: text/chapter2.md:10
msgid ""
"First, work through this [Getting Started Guide](https://github.com/"
"purescript/documentation/blob/master/guides/Getting-Started.md) in the "
"Documentation Repo to setup your environment and learn a few basics about "
"the language. Don't worry if the code in the example solution to the "
"[Project Euler](http://projecteuler.net/problem=1) problem is confusing or "
"contains unfamiliar syntax. We'll cover all of this in great detail in the "
"upcoming chapters."
msgstr ""
"最初にドキュメンテーションリポジトリにあるこの[はじめの手引き](https://"
"github.com/purescript/documentation/blob/master/guides/Getting-Started.md)を"
"通しで進め、環境の構築と言語の基礎を学んでください。[Project Euler](http://"
"projecteuler.net/problem=1)の解答例にあるコードがわかりにくかったり見慣れない"
"構文を含んでいたとしても心配要りません。来たる章でこの全ての内容をとても丁寧"
"に押さえていきます。"

#. type: Title ###
#: text/chapter2.md:11
#, no-wrap
msgid "Editor support"
msgstr "エディタの対応"

#. type: Plain text
#: text/chapter2.md:14
msgid ""
"You can use your preferred editor to write PureScript (for example, to solve "
"the book exercises). See [Editor Support Documentation](https://github.com/"
"purescript/documentation/blob/master/ecosystem/Editor-and-tool-support."
"md#editor-support)."
msgstr ""
"PureScriptを書く上で（例えば本書の演習を解くなど）お好みのエディタを使えま"
"す。\n"
"[エディタの対応についてのドキュメント](https://github.com/purescript/"
"documentation/blob/master/ecosystem/Editor-and-tool-support.md#editor-"
"support)を参照してください。"

#. type: Plain text
#: text/chapter2.md:18
#, no-wrap
msgid ""
"> Note that some editors expect a `spago.dhall` file in the root of the opened project for full IDE support. For example, you should open the `chapter2` directory to work on the exercises in this chapter.\n"
">\n"
"> If you use VS Code, you can use the provided workspace to open all the chapters simultaneously.\n"
msgstr ""
"> なお、完全なIDEの対応をするために、開いたプロジェクトのルートに`spago.dhall`があることを期待するエディタもあります。\n"
"> 例えば本章の演習に取り組む場合、`chapter2`ディレクトリを開くとよいでしょう。\n"
">\n"
"> VS Codeを使っている場合、提供されているワークスペースを使って全ての章を同時に開くことができます。\n"

#. type: Title ##
#: text/chapter2.md:19
#, no-wrap
msgid "Solving Exercises"
msgstr "演習を解く"

#. type: Plain text
#: text/chapter2.md:22
msgid ""
"Now that you've installed the necessary development tools, clone this book's "
"repo."
msgstr ""
"ここまでで必要な開発ツールをインストールできているので、本書のリポジトリをク"
"ローンしてください。"

#. type: Fenced code block (sh)
#: text/chapter2.md:23
#, no-wrap
msgid "git clone https://github.com/purescript-contrib/purescript-book.git\n"
msgstr "git clone https://github.com/purescript-contrib/purescript-book.git\n"

#. type: Plain text
#: text/chapter2.md:28
msgid ""
"The book repo contains PureScript example code and unit tests for the "
"exercises that accompany each chapter. There's some initial setup required "
"to reset the exercise solutions so they are ready to be solved by you. Use "
"the `resetSolutions.sh` script to simplify this process. While at it, you "
"should also strip out all the anchor comments with the `removeAnchors.sh` "
"script (these anchors are used for copying code snippets into the book's "
"rendered markdown, and you probably don't need this clutter in your local "
"repo):"
msgstr ""
"本書のリポジトリにはPureScriptのコード例と各章に付属する演習のための単体テス"
"トが含まれます。\n"
"演習の解法を白紙に戻すために必要な初期設定があり、この設定をすることで解く準"
"備ができます。\n"
"この工程は`resetSolutions.sh`スクリプトを使えば簡単にできます。\n"
"また`removeAnchors.sh`スクリプトで全てのアンカーコメントを取り除いておくと良"
"いでしょう（これらのアンカーはコード片を本書のMarkdownから書き出した媒体に複"
"製するために使われており、自分のローカルリポジトリではこのアンカーで散らかっ"
"ていないほうが良いでしょう）。"

#. type: Fenced code block (sh)
#: text/chapter2.md:29
#, no-wrap
msgid ""
"cd purescript-book\n"
"./scripts/resetSolutions.sh\n"
"./scripts/removeAnchors.sh\n"
"git add .\n"
"git commit --all --message \"Exercises ready to be solved\"\n"
msgstr ""
"cd purescript-book\n"
"./scripts/resetSolutions.sh\n"
"./scripts/removeAnchors.sh\n"
"git add .\n"
"git commit --all --message \"Exercises ready to be solved\"\n"

#. type: Plain text
#: text/chapter2.md:38
msgid "Now run the tests for this chapter:"
msgstr "それではこの章のテストを走らせましょう。"

#. type: Fenced code block (sh)
#: text/chapter2.md:39
#, no-wrap
msgid ""
"cd exercises/chapter2\n"
"spago test\n"
msgstr ""
"cd exercises/chapter2\n"
"spago test\n"

#. type: Plain text
#: text/chapter2.md:45
msgid "You should see the following successful test output:"
msgstr "以下の成功した旨のテスト出力が出るでしょう。"

#. type: Fenced code block (sh)
#: text/chapter2.md:46
#, no-wrap
msgid ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"\n"
"All 2 tests passed! 🎉\n"
msgstr ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"\n"
"All 2 tests passed! 🎉\n"

#. type: Plain text
#: text/chapter2.md:55
msgid ""
"Note that the `answer` function (found in `src/Euler.purs`) has been "
"modified to find the multiples of 3 and 5 below any integer. The test suite "
"(located in `test/Main.purs`) for this `answer` function is more "
"comprehensive than the test in the earlier getting-started guide. Don't "
"worry about understanding how this test framework code works while reading "
"these early chapters."
msgstr ""
"なお、（`src/Euler.purs`にある）`answer`関数は任意の整数以下の3と5の倍数を見"
"付けるように変更されています。\n"
"（`test/Main.purs`にある）この`answer`関数のためのテストスートははじめの手引"
"きの冒頭にあるテストよりも網羅的です。\n"
"前の方の章を読んでいる間はこのテストフレームワークの仕組みを理解しようと思い"
"詰めなくて大丈夫です。"

#. type: Plain text
#: text/chapter2.md:57
msgid ""
"The remainder of the book contains lots of exercises. If you write your "
"solutions in the `Test.MySolutions` module (`test/MySolutions.purs`), you "
"can check your work against the provided test suite."
msgstr ""
"本書の残りの部分には多くの演習が含まれます。\n"
"`Test.MySolutions`モジュール (`test/MySolutions.purs`) に自分の解法を書けば、"
"提供されているテストスートを使って確認できます。"

#. type: Plain text
#: text/chapter2.md:59
msgid ""
"Let's work through this next exercise together in a test-driven-development "
"style."
msgstr "テスト駆動開発でこの次の演習を一緒に進めてみましょう。"

#. type: Title ##
#: text/chapter2.md:60
#, no-wrap
msgid "Exercise"
msgstr "演習"

#. type: Bullet: '1. '
#: text/chapter2.md:63
msgid ""
"(Medium) Write a `diagonal` function to compute the length of the diagonal "
"(or hypotenuse) of a right-angled triangle when given the lengths of the two "
"other sides."
msgstr ""
"（普通）直角三角形の対角線（あるいは斜辺）の長さを他の2つの辺の長さを使って計"
"算する`diagonal`関数を書いてください。"

#. type: Title ##
#: text/chapter2.md:64
#, no-wrap
msgid "Solution"
msgstr "解法"

#. type: Plain text
#: text/chapter2.md:67
msgid ""
"We'll start by enabling the tests for this exercise. Move the start of the "
"block-comment down a few lines, as shown below. Block comments start with `{-"
"` and end with `-}`:"
msgstr ""
"この演習のテストを有効にするところから始めます。\n"
"以下に示すようにブロックコメントの開始を数行下に下げてください。\n"
"ブロックコメントは`{-`から始まり`-}`で終わります。"

#. type: Fenced code block (hs)
#: text/chapter2.md:68
#, no-wrap
msgid ""
"{{#include ../exercises/chapter2/test/Main.purs:diagonalTests}}\n"
"    {-  Move this block comment starting point to enable more tests\n"
msgstr ""
"{{#include ../exercises/chapter2/test/Main.purs:diagonalTests}}\n"
"    {-  Move this block comment starting point to enable more tests\n"

#. type: Plain text
#: text/chapter2.md:74
msgid ""
"If we attempt to run the test now, we'll encounter a compilation error "
"because we have not yet implemented our `diagonal` function."
msgstr ""
"ここでテストを走らせようとすると、コンパイルエラーに直面します。\n"
"なぜなら`diagonal`関数をまだ実装していないからです。"

#. type: Fenced code block (sh)
#: text/chapter2.md:75
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Error found:\n"
"in module Test.Main\n"
"at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)\n"
"\n"
"  Unknown value diagonal\n"
msgstr ""
"$ spago test\n"
"\n"
"Error found:\n"
"in module Test.Main\n"
"at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)\n"
"\n"
"  Unknown value diagonal\n"

#. type: Plain text
#: text/chapter2.md:86
msgid ""
"Let's first look at what happens with a faulty version of this function. Add "
"the following code to `test/MySolutions.purs`:"
msgstr ""
"まずはこの関数に欠陥があるときに何が起こるのか見てみましょう。\n"
"以下のコードを`test/MySolutions.purs`に追加してください。"

#. type: Fenced code block (hs)
#: text/chapter2.md:87
#, no-wrap
msgid ""
"import Data.Number (sqrt)\n"
"\n"
"diagonal w h = sqrt (w * w + h)\n"
msgstr ""
"import Data.Number (sqrt)\n"
"\n"
"diagonal w h = sqrt (w * w + h)\n"

#. type: Plain text
#: text/chapter2.md:94
msgid "And check our work by running `spago test`:"
msgstr "そして`spago test`を走らせて確認してください。"

#. type: Fenced code block (hs)
#: text/chapter2.md:95
#, no-wrap
msgid ""
"→ Suite: diagonal\n"
"  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989\n"
"  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219\n"
"\n"
"2 tests failed:\n"
msgstr ""
"→ Suite: diagonal\n"
"  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989\n"
"  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219\n"
"\n"
"2 tests failed:\n"

#. type: Plain text
#: text/chapter2.md:104
msgid ""
"Uh-oh, that's not quite right. Let's fix this with the correct application "
"of the Pythagorean formula by changing the function to:"
msgstr ""
"あーあ、全然正しくありませんでした。\n"
"ピタゴラスの定理を正しく適用して修正しましょう。\n"
"関数を以下のように変えます。"

#. type: Fenced code block (hs)
#: text/chapter2.md:105
#, no-wrap
msgid "{{#include ../exercises/chapter2/test/no-peeking/Solutions.purs:diagonal}}\n"
msgstr "{{#include ../exercises/chapter2/test/no-peeking/Solutions.purs:diagonal}}\n"

#. type: Plain text
#: text/chapter2.md:110
msgid "Trying `spago test` again now shows all tests are passing:"
msgstr "ここでもう一度`spago test`としてみると全てのテストが通っています。"

#. type: Fenced code block (hs)
#: text/chapter2.md:111
#, no-wrap
msgid ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"→ Suite: diagonal\n"
"  ✓ Passed: 3 4 5\n"
"  ✓ Passed: 5 12 13\n"
"\n"
"All 4 tests passed! 🎉\n"
msgstr ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"→ Suite: diagonal\n"
"  ✓ Passed: 3 4 5\n"
"  ✓ Passed: 5 12 13\n"
"\n"
"All 4 tests passed! 🎉\n"

#. type: Plain text
#: text/chapter2.md:123
msgid "Success! Now you're ready to try these next exercises on your own."
msgstr ""
"成功です。\n"
"これで次の演習を自力で解くための準備ができました。"

#. type: Bullet: ' 1. '
#: text/chapter2.md:128
msgid ""
"(Easy) Write a function `circleArea` which computes the area of a circle "
"with a given radius. Use the `pi` constant, which is defined in the "
"`Numbers` module. _Hint_: don't forget to import `pi` by modifying the "
"`import Data.Number` statement."
msgstr ""
"（簡単）指定された半径の円の面積を計算する関数`circleArea`を書いてみましょ"
"う。\n"
"`Numbers`モジュールで定義されている `pi`定数を使用してください。\n"
"*手掛かり*： `import Data.Number`文を修正して、 `pi`をインポートすることを忘"
"れないようにしましょう。"

#. type: Bullet: ' 1. '
#: text/chapter2.md:128
msgid ""
"(Medium) Write a function `leftoverCents` which takes an `Int` and returns "
"what's leftover after dividing by `100`. Use the `rem` function. Search "
"[Pursuit](https://pursuit.purescript.org/) for this function to learn about "
"usage and which module to import it from. _Note:_ Your IDE may support auto-"
"importing of this function if you accept the auto-completion suggestion."
msgstr ""
"（普通）`Int`を取って`100`で割ったあとの余りを返す関数`leftoverCents`を書いて"
"みましょう。`rem`関数を使ってください。[Pursuit](https://pursuit.purescript."
"org/)でこの関数を検索して、使用法とどのモジュールからインポートしてくるか調べ"
"ましょう。*補足*：自動補完の提案を有効にしていたら、IDE側でこの関数の自動的な"
"インポートに対応しているかもしれません。"

#. type: Plain text
#: text/chapter2.md:132
msgid ""
"In this chapter, we installed the PureScript compiler and the Spago tool. We "
"also learned how to write solutions to exercises and check these for "
"correctness."
msgstr ""
"この章ではPureScriptコンパイラとSpagoツールをインストールしました。\n"
"演習の解答の書き方と正しさの確認方法も学びました。"

#. type: Plain text
#: text/chapter2.md:134
msgid ""
"There will be many more exercises in the chapters ahead, and working through "
"those helps with learning the material. If any of the exercises stumps you, "
"please reach out to any of the community resources listed in the [Getting "
"Help](https://book.purescript.org/chapter1.html#getting-help) section of "
"this book, or even file an issue in this [book's repo](https://github.com/"
"purescript-contrib/purescript-book/issues). This reader feedback on which "
"exercises could be made more approachable helps us improve the book."
msgstr ""
"この先の章にはもっと沢山の演習があり、それらに取り組むうちに内容を学ぶ助けに"
"なっているでしょう。\n"
"演習のどこかでお手上げになったら、本書の[困ったときは](chapter1.ja."
"md#getting-help)の節に挙げられているコミュニティの資料のどれかに手を伸ばした"
"り、[本書のリポジトリ](https://github.com/purescript-contrib/purescript-book/"
"issues)でイシューを報告したりできます。\n"
"こうした演習の敷居を下げることに繋がる読者のフィードバックのお陰で本書が改善"
"されています。"

#. type: Plain text
#: text/chapter2.md:136
msgid ""
"Once you solve all the exercises in a chapter, you may compare your answers "
"against those in the `no-peeking/Solutions.purs`. No peeking, please, "
"without putting in an honest effort to solve these yourself. And even if you "
"are stuck, try asking a community member for help first, as we would prefer "
"to give you a small hint rather than spoil the exercise. If you found a more "
"elegant solution (that only requires knowledge of the covered content), "
"please send us a PR."
msgstr ""
"章の全ての演習を解いたら、`no-peeking/Solutions.purs`にあるものと解答とを比べ"
"られます。\n"
"カンニングはせず、演習を誠実に自力で解く労力を割いてください。\n"
"そしてたとえ行き詰まったにしても、まずはコミュニティメンバーに尋ねてみるよう"
"にしてください。\n"
"ネタバレをするよりも小さな手掛かりをあげたいからです。\n"
"もっとエレガントな解法（とはいえ本書で押さえられている知識のみで済むもの）を"
"見つけたときはPRを送ってください。"

#. type: Plain text
#: text/chapter2.md:137
msgid ""
"The repo is continuously being revised, so be sure to check for updates "
"before starting each new chapter."
msgstr ""
"リポジトリは継続して改訂されているため、それぞれの新しい章を始める前に更新を"
"確認するようにしてください。"

#. type: Title #
#: text/chapter3.md:1
#, no-wrap
msgid "Functions and Records"
msgstr "関数とレコード"

#. type: Plain text
#: text/chapter3.md:6
msgid ""
"This chapter will introduce two building blocks of PureScript programs: "
"functions and records. In addition, we'll see how to structure PureScript "
"programs, and how to use types as an aid to program development."
msgstr ""
"この章では、関数及びレコードというPureScriptプログラムの2つの構成要素を導入し"
"ます。更に、どのようにPureScriptプログラムを構造化するのか、どのように型をプ"
"ログラム開発に役立てるかを見ていきます。"

#. type: Plain text
#: text/chapter3.md:8
msgid ""
"We will build a simple address book application to manage a list of "
"contacts. This code will introduce some new ideas from the syntax of "
"PureScript."
msgstr ""
"連絡先のリストを管理する簡単な住所録アプリケーションを作成していきます。\n"
"このコード例により、PureScriptの構文から幾つかの新しい概念を導入します。"

#. type: Plain text
#: text/chapter3.md:10
msgid ""
"The front-end of our application will be the interactive mode PSCi, but it "
"would be possible to build on this code to write a front-end in JavaScript. "
"In fact, we will do exactly that in later chapters, adding form validation "
"and save/restore functionality."
msgstr ""
"このアプリケーションのフロントエンドは対話式モードであるPSCiを使うようにして"
"いますが、このコードを土台にJavaScriptでフロントエンドを書くこともできるで"
"しょう。\n"
"実際に後の章で、フォームの検証と保存及び復元の機能を追加します。"

#. type: Plain text
#: text/chapter3.md:14
msgid ""
"The source code for this chapter is contained in the file `src/Data/"
"AddressBook.purs`. This file starts with a module declaration and its import "
"list:"
msgstr ""
"この章のソースコードは `src/Data/AddressBook.purs`というファイルに含まれてい"
"ます。\n"
"このファイルは次のようなモジュール宣言とインポート一覧から始まります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:15
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:imports}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:imports}}\n"

#. type: Plain text
#: text/chapter3.md:20
msgid "Here, we import several modules:"
msgstr "ここでは、幾つかのモジュールをインポートします。"

#. type: Bullet: '- '
#: text/chapter3.md:25
msgid ""
"The `Prelude` module, which contains a small set of standard definitions and "
"functions. It re-exports many foundational modules from the `purescript-"
"prelude` library."
msgstr ""

#. type: Bullet: '- '
#: text/chapter3.md:25
msgid "The `Control.Plus` module, which defines the `empty` value."
msgstr "`Control.Plus`モジュールには`empty`値が定義されています。"

#. type: Bullet: '- '
#: text/chapter3.md:25
msgid ""
"The `Data.List` module, provided by the `lists` package, which can be "
"installed using Spago. It contains a few functions that we will need for "
"working with linked lists."
msgstr ""
"`Data.List`モジュールは`lists`パッケージで提供されています。\n"
"またこのパッケージはSpagoを使ってインストールできます。\n"
"モジュールには連結リストを使うために必要な幾つかの関数が含まれています。"

#. type: Bullet: '- '
#: text/chapter3.md:25
msgid ""
"The `Data.Maybe` module, which defines data types and functions for working "
"with optional values."
msgstr ""
"`Data.Maybe`モジュールは、省略可能な値を扱うためのデータ型と関数を定義してい"
"ます。"

#. type: Plain text
#: text/chapter3.md:27
#, fuzzy
#| msgid ""
#| "Notice that the imports for these modules are listed explicitly in "
#| "parentheses. This is generally a good practice, as it helps to avoid "
#| "conflicting imports."
msgid ""
"Notice that the imports for these modules are listed explicitly in "
"parentheses (except for `Prelude`, which is typically imported as an open "
"import). This is generally a good practice, as it helps to avoid conflicting "
"imports."
msgstr ""
"このモジュールのインポート内容が括弧内で明示的に列挙されていることに注目して"
"ください。明示的な列挙はインポート内容の衝突を避けるのに役に立つので、一般に"
"良い習慣です。"

#. type: Plain text
#: text/chapter3.md:29
msgid ""
"Assuming you have cloned the book's source code repository, the project for "
"this chapter can be built using Spago, with the following commands:"
msgstr ""
"ソースコードリポジトリをクローンしたと仮定すると、この章のプロジェクトは次の"
"コマンドでSpagoを使用して構築できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:30
#, no-wrap
msgid ""
"$ cd chapter3\n"
"$ spago build\n"
msgstr ""
"$ cd chapter3\n"
"$ spago build\n"

#. type: Title ##
#: text/chapter3.md:35
#, no-wrap
msgid "Simple Types"
msgstr "単純な型"

#. type: Plain text
#: text/chapter3.md:38
msgid ""
"PureScript defines three built-in types corresponding to JavaScript's "
"primitive types: numbers, strings, and booleans. These are defined in the "
"`Prim` module, which is implicitly imported by every module. They are called "
"`Number`, `String`, and `Boolean`, respectively, and you can see them in "
"PSCi by using the `:type` command to print the types of some simple values:"
msgstr ""
"JavaScriptの原始型に対応する組み込みデータ型として、PureScriptでは数値型と文"
"字列型、真偽型の3つが定義されています。\n"
"これらは`Prim`モジュールで定義されており、全てのモジュールに暗黙にインポート"
"されます。\n"
"それぞれ`Number`、`String`、`Boolean`と呼ばれており、PSCiで簡単な値の型を表示"
"するのに`:type`コマンドを使うと確認できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:39
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :type 1.0\n"
"Number\n"
"\n"
"> :type \"test\"\n"
"String\n"
"\n"
"> :type true\n"
"Boolean\n"
msgstr ""
"$ spago repl\n"
"\n"
"> :type 1.0\n"
"Number\n"
"\n"
"> :type \"test\"\n"
"String\n"
"\n"
"> :type true\n"
"Boolean\n"

#. type: Plain text
#: text/chapter3.md:53
msgid ""
"PureScript defines other built-in types: integers, characters, arrays, "
"records, and functions."
msgstr ""
"PureScriptには他にも、整数、文字、配列、レコード、関数といった組み込み型が定"
"義されています。"

#. type: Plain text
#: text/chapter3.md:55
msgid ""
"Integers are differentiated from floating point values of type `Number` by "
"the lack of a decimal point:"
msgstr ""
"小数点以下を省くと整数になり、型 `Number`の浮動小数点数の値と区別されます。"

#. type: Fenced code block (text)
#: text/chapter3.md:56
#, no-wrap
msgid ""
"> :type 1\n"
"Int\n"
msgstr ""
"> :type 1\n"
"Int\n"

#. type: Plain text
#: text/chapter3.md:62
msgid ""
"Character literals are wrapped in single quotes, unlike string literals "
"which use double quotes:"
msgstr ""
"二重引用符を使用する文字列直値とは異なり、文字直値は一重引用符で囲みます。"

#. type: Fenced code block (text)
#: text/chapter3.md:63
#, no-wrap
msgid ""
"> :type 'a'\n"
"Char\n"
msgstr ""
"> :type 'a'\n"
"Char\n"

#. type: Plain text
#: text/chapter3.md:69
msgid ""
"Arrays correspond to JavaScript arrays, but unlike in JavaScript, all "
"elements of a PureScript array must have the same type:"
msgstr ""
"配列はJavaScriptの配列に対応していますが、JavaScriptの配列とは異なり、"
"PureScriptの配列の全ての要素は同じ型を持つ必要があります。"

#. type: Fenced code block (text)
#: text/chapter3.md:70
#, no-wrap
msgid ""
"> :type [1, 2, 3]\n"
"Array Int\n"
"\n"
"> :type [true, false]\n"
"Array Boolean\n"
"\n"
"> :type [1, false]\n"
"Could not match type Int with type Boolean.\n"
msgstr ""
"> :type [1, 2, 3]\n"
"Array Int\n"
"\n"
"> :type [true, false]\n"
"Array Boolean\n"
"\n"
"> :type [1, false]\n"
"Could not match type Int with type Boolean.\n"

#. type: Plain text
#: text/chapter3.md:82
msgid ""
"The last example shows an error from the type checker, which failed to "
"_unify_ (i.e., make equal) the types of the two elements."
msgstr ""
"最後の例は型検証器によるエラーを示しています。\n"
"配列の2つの要素の型を*単一化*（つまり等価にする意）するのに失敗したのです。"

#. type: Plain text
#: text/chapter3.md:84
msgid ""
"Records correspond to JavaScript's objects, and record literals have the "
"same syntax as JavaScript's object literals:"
msgstr ""
"レコードはJavaScriptのオブジェクトに対応しており、レコード直値はJavaScriptの"
"オブジェクト直値と同じ構文になっています。"

#. type: Fenced code block (text)
#: text/chapter3.md:85
#, no-wrap
msgid ""
"> author = { name: \"Phil\", interests: [\"Functional Programming\", \"JavaScript\"] }\n"
"\n"
"> :type author\n"
"{ name :: String\n"
", interests :: Array String\n"
"}\n"
msgstr ""
"> author = { name: \"Phil\", interests: [\"Functional Programming\", \"JavaScript\"] }\n"
"\n"
"> :type author\n"
"{ name :: String\n"
", interests :: Array String\n"
"}\n"

#. type: Plain text
#: text/chapter3.md:95
msgid ""
"This type indicates that the specified object has two _fields_: a `name` "
"field with the type `String` and an `interests` field with the type `Array "
"String`, i.e., an array of `String`s."
msgstr ""
"この型が示しているのは指定されたオブジェクトが2つの*フィールド*を持っていると"
"いうことです。\n"
"それぞれ`String`型のフィールド`name`と`Array String`型のフィールド`interests`"
"で、後者は`String`の配列ということです。"

#. type: Plain text
#: text/chapter3.md:97
msgid ""
"Fields of records can be accessed using a dot, followed by the label of the "
"field to access:"
msgstr ""
"ドットに続けて参照したいフィールドのラベルを書くとレコードのフィールドを参照"
"できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:98
#, no-wrap
msgid ""
"> author.name\n"
"\"Phil\"\n"
"\n"
"> author.interests\n"
"[\"Functional Programming\",\"JavaScript\"]\n"
msgstr ""
"> author.name\n"
"\"Phil\"\n"
"\n"
"> author.interests\n"
"[\"Functional Programming\",\"JavaScript\"]\n"

#. type: Plain text
#: text/chapter3.md:107
#, fuzzy
#| msgid ""
#| "Functions can be defined at the top-level of a file by specifying "
#| "arguments before the equals sign:"
msgid ""
"PureScript's functions correspond to JavaScript's functions. Functions can "
"be defined at the top-level of a file by specifying arguments before the "
"equals sign:"
msgstr ""
"ファイルの最上位では、等号の直前に引数を指定することで関数を定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:108
#, fuzzy, no-wrap
#| msgid ""
#| "add :: Int -> Int -> Int\n"
#| "add x y = x + y\n"
msgid ""
"import Prelude -- bring the (+) operator into scope\n"
"\n"
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"
msgstr ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"

#. type: Plain text
#: text/chapter3.md:116
msgid ""
"Alternatively, functions can be defined inline using a backslash character "
"followed by a space-delimited list of argument names. To enter a multi-line "
"declaration in PSCi, we can enter \"paste mode\" using the `:paste` command. "
"In this mode, declarations are terminated using the _Control-D_ key sequence:"
msgstr ""
"代えて、バックスラッシュ文字に続けて空白文字で区切られた引数名のリストを書く"
"ことで、関数をインラインでも定義できます。\n"
"PSCiで複数行の宣言を入力するには、`:paste`コマンドを使用して「貼り付けモー"
"ド」に入ります。\n"
"このモードでは、*Control-D*キーシーケンスを使って宣言を終了します。"

#. type: Fenced code block (text)
#: text/chapter3.md:117
#, fuzzy, no-wrap
#| msgid ""
#| "> :paste\n"
#| "… add :: Int -> Int -> Int\n"
#| "… add = \\x y -> x + y\n"
#| "… ^D\n"
msgid ""
"> import Prelude\n"
"> :paste\n"
"… add :: Int -> Int -> Int\n"
"… add = \\x y -> x + y\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… add :: Int -> Int -> Int\n"
"… add = \\x y -> x + y\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:126
msgid ""
"Having defined this function in PSCi, we can _apply_ it to its arguments by "
"separating the two arguments from the function name by whitespace:"
msgstr ""
"PSCiでこの関数が定義されていると、次のように関数の隣に2つの引数を空白で区切っ"
"て書くことで、関数をこれらの引数に*適用* (apply) できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:127
#, no-wrap
msgid ""
"> add 10 20\n"
"30\n"
msgstr ""
"> add 10 20\n"
"30\n"

#. type: Title ##
#: text/chapter3.md:132
#, no-wrap
msgid "Notes On Indentation"
msgstr "字下げについての注意"

#. type: Plain text
#: text/chapter3.md:135
msgid ""
"PureScript code is _indentation-sensitive_, just like Haskell, but unlike "
"JavaScript. This means that the whitespace in your code is not meaningless, "
"but rather is used to group regions of code, just like curly braces in C-"
"like languages."
msgstr ""
"PureScriptのコードは字下げの大きさに意味があります。ちょうどHaskellと同じで、"
"JavaScriptとは異なります。コード内の空白の多寡は無意味ではなく、Cのような言語"
"で中括弧によってコードのまとまりを示しているように、PureScriptでは空白がコー"
"ドのまとまりを示すために使われているということです。"

#. type: Plain text
#: text/chapter3.md:137
#, fuzzy
#| msgid ""
#| "If a declaration spans multiple lines, then any lines except the first "
#| "must be indented past the indentation level of the first line."
msgid ""
"If a declaration spans multiple lines, any lines except the first must be "
"indented past the indentation level of the first line."
msgstr ""
"宣言が複数行にわたる場合は、最初の行以外は最初の行の字下げより深くしなければ"
"なりません。"

#. type: Plain text
#: text/chapter3.md:139
msgid "Therefore, the following is a valid PureScript code:"
msgstr "したがって、次は正しいPureScriptコードです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:140
#, no-wrap
msgid ""
"add x y z = x +\n"
"  y + z\n"
msgstr ""
"add x y z = x +\n"
"  y + z\n"

#. type: Plain text
#: text/chapter3.md:146
msgid "But this is not a valid code:"
msgstr "しかし、次は正しいコードではありません。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:147
#, no-wrap
msgid ""
"add x y z = x +\n"
"y + z\n"
msgstr ""
"add x y z = x +\n"
"y + z\n"

#. type: Plain text
#: text/chapter3.md:153
msgid ""
"In the second case, the PureScript compiler will try to parse _two_ "
"declarations, one for each line."
msgstr ""
"後者では、PureScriptコンパイラはそれぞれの行毎に1つ、つまり*2つ*の宣言である"
"と構文解析します。"

#. type: Plain text
#: text/chapter3.md:155
msgid ""
"Generally, any declarations defined in the same block should be indented at "
"the same level. For example, in PSCi, declarations in a let statement must "
"be indented equally. This is valid:"
msgstr ""
"一般に、同じブロック内で定義された宣言は同じ深さで字下げする必要がありま"
"す。\n"
"例えばPSCiでlet文の宣言は同じ深さで字下げしなければなりません。\n"
"次は正しいコードです。"

#. type: Fenced code block (text)
#: text/chapter3.md:156
#, no-wrap
msgid ""
"> :paste\n"
"… x = 1\n"
"… y = 2\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… x = 1\n"
"… y = 2\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:164
msgid "But this is not:"
msgstr "しかし、これは正しくありません。"

#. type: Fenced code block (text)
#: text/chapter3.md:165
#, no-wrap
msgid ""
"> :paste\n"
"… x = 1\n"
"…  y = 2\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… x = 1\n"
"…  y = 2\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:173
#, fuzzy
#| msgid ""
#| "Certain PureScript keywords (such as `where`, `of` and `let`) introduce a "
#| "new block of code, in which declarations must be further-indented:"
msgid ""
"Certain PureScript keywords introduce a new block of code, in which "
"declarations must be further-indented:"
msgstr ""
"PureScriptの幾つかの予約語（例えば `where`や `of`、 `let`）は新たなコードのま"
"とまりを導入しますが、そのコードのまとまり内の宣言はそれより深く字下げされて"
"いる必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:174
#, fuzzy, no-wrap
#| msgid ""
#| "example x y z = foo + bar\n"
#| "  where\n"
#| "    foo = x * y\n"
#| "    bar = y * z\n"
msgid ""
"example x y z =\n"
"  let\n"
"    foo = x * y\n"
"    bar = y * z\n"
"  in\n"
"    foo + bar\n"
msgstr ""
"example x y z = foo + bar\n"
"  where\n"
"    foo = x * y\n"
"    bar = y * z\n"

#. type: Plain text
#: text/chapter3.md:184
msgid "This doesn't compile:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter3.md:185
#, fuzzy, no-wrap
#| msgid ""
#| "example x y z = foo + bar\n"
#| "  where\n"
#| "    foo = x * y\n"
#| "    bar = y * z\n"
msgid ""
"example x y z =\n"
"  let\n"
"    foo = x * y\n"
"  bar = y * z\n"
"  in\n"
"    foo + bar\n"
msgstr ""
"example x y z = foo + bar\n"
"  where\n"
"    foo = x * y\n"
"    bar = y * z\n"

#. type: Plain text
#: text/chapter3.md:195
msgid ""
"If you want to learn more (or encounter any problems), see the [Syntax]"
"(https://github.com/purescript/documentation/blob/master/language/Syntax."
"md#syntax) documentation."
msgstr ""

#. type: Title ##
#: text/chapter3.md:196
#, no-wrap
msgid "Defining Our Types"
msgstr "独自の型の定義"

#. type: Plain text
#: text/chapter3.md:199
msgid ""
"A good first step when tackling a new problem in PureScript is to write out "
"type definitions for any values you will be working with. First, let's "
"define a type for records in our address book:"
msgstr ""
"PureScriptで新たな問題に取り組むときは、まずはこれから扱おうとする値の型の定"
"義を書くことから始めるのがよいでしょう。最初に、住所録に含まれるレコードの型"
"を定義してみます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Entry}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Entry}}\n"

#. type: Plain text
#: text/chapter3.md:205
msgid ""
"This defines a _type synonym_ called `Entry` – the type `Entry` is "
"equivalent to the type on the right of the equals symbol: a record type with "
"three fields – `firstName`, `lastName`, and `address`. The two name fields "
"will have the type `String`, and the `address` field will have the type "
"`Address`, defined as follows:"
msgstr ""
"これは`Entry`という*型同義語*を定義しています。\n"
"型`Entry`は等号の右辺と等価ということです。\n"
"レコードの型は`firstName`、`lastName`、`phone`という3つのフィールドからなりま"
"す。\n"
"2つの名前のフィールドは型`String`を持ち、`address`は以下で定義された型"
"`Address`を持ちます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Address}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Address}}\n"

#. type: Plain text
#: text/chapter3.md:211
msgid "Note that records can contain other records."
msgstr "なお、レコードには他のレコードを含めることができます。"

#. type: Plain text
#: text/chapter3.md:213
msgid ""
"Now let's define a third type synonym for our address book data structure, "
"which will be represented simply as a linked list of entries:"
msgstr ""
"それでは、住所録のデータ構造として3つめの型同義語も定義してみましょう。\n"
"単に項目の連結リストとして表すことにします。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:214
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:AddressBook}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:AddressBook}}\n"

#. type: Plain text
#: text/chapter3.md:219
msgid ""
"Note that `List Entry` differs from `Array Entry`, which represents an "
"_array_ of entries."
msgstr ""
"なお、`List Entry`は `Array Entry`とは同じではありません。\n"
"後者は項目の*配列*を表しています。"

#. type: Title ##
#: text/chapter3.md:220
#, no-wrap
msgid "Type Constructors and Kinds"
msgstr "型構築子と種"

#. type: Plain text
#: text/chapter3.md:223
msgid ""
"`List` is an example of a _type constructor_. Values do not have the type "
"`List` directly, but rather `List a` for some type `a`. That is, `List` "
"takes a _type argument_ `a` and _constructs_ a new type `List a`."
msgstr ""
"`List`は*型構築子*の一例になっています。\n"
"`List`そのものは型ではなく、何らかの型 `a`があるとき `List a`が型になっていま"
"す。\n"
"つまり、 `List`は*型引数*`a`を取り、新たな型 `List a`を*構築*するのです。"

#. type: Plain text
#: text/chapter3.md:225
msgid ""
"Note that just like function application, type constructors are applied to "
"other types simply by juxtaposition: the type `List Entry` is, in fact, the "
"type constructor `List` _applied_ to the type `Entry` – it represents a list "
"of entries."
msgstr ""
"なお、ちょうど関数適用と同じように、型構築子は他の型に並置するだけで適用され"
"ます。\n"
"実際、型`List Entry`は型構築子`List`が型`Entry`に*適用*されたもので、項目のリ"
"ストを表しています。"

#. type: Plain text
#: text/chapter3.md:227
msgid ""
"If we try to incorrectly define a value of type `List` (by using the type "
"annotation operator `::`), we will see a new type of error:"
msgstr ""
"もし間違って（型注釈演算子 `::`を使って）型 `List`の値を定義しようとすると、"
"今まで見たことのない種類のエラーが表示されるでしょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:228
#, no-wrap
msgid ""
"> import Data.List\n"
"> Nil :: List\n"
"In a type-annotated expression x :: t, the type t must have kind Type\n"
msgstr ""
"> import Data.List\n"
"> Nil :: List\n"
"In a type-annotated expression x :: t, the type t must have kind Type\n"

#. type: Plain text
#: text/chapter3.md:235
msgid ""
"This is a _kind error_. Just like values are distinguished by their _types_, "
"types are distinguished by their _kinds_, and just like ill-typed values "
"result in _type errors_, _ill-kinded_ types result in _kind errors_."
msgstr ""
"これは*種エラー*です。値がその*型*で区別されるのと同じように、型はその*種*に"
"よって区別されます。間違った型の値が*型エラー*になるように、*間違った種*の型"
"は*種エラー*を引き起こします。"

#. type: Plain text
#: text/chapter3.md:237
msgid ""
"There is a special kind called `Type` which represents the kind of all types "
"which have values, like `Number` and `String`."
msgstr ""
"`Number`や `String`のような、値を持つ全ての型の種を表す `Type`と呼ばれる特別"
"な種があります。"

#. type: Plain text
#: text/chapter3.md:239
#, no-wrap
msgid "There are also kinds for type constructors. For example, the kind `Type -> Type` represents a function from types to types, just like `List`. So the error here occurred because values are expected to have types with kind `Type`, but `List` has kind `Type -> Type`.\n"
msgstr ""
"型構築子にも種があります。\n"
"例えば種 `Type -> Type`はちょうど `List`のような型から型への関数を表しています。\n"
"ここでエラーが発生したのは、値が種 `Type`であるような型を持つと期待されていたのに、 `List`は種 `Type -> Type`を持っているためです。\n"

#. type: Plain text
#: text/chapter3.md:241
msgid ""
"To find out the kind of a type, use the `:kind` command in PSCi. For example:"
msgstr ""
"PSCiで型の種を調べるには、 `:kind`命令を使用します。例えば次のようになりま"
"す。"

#. type: Fenced code block (text)
#: text/chapter3.md:242
#, no-wrap
msgid ""
"> :kind Number\n"
"Type\n"
"\n"
"> import Data.List\n"
"> :kind List\n"
"Type -> Type\n"
"\n"
"> :kind List String\n"
"Type\n"
msgstr ""
"> :kind Number\n"
"Type\n"
"\n"
"> import Data.List\n"
"> :kind List\n"
"Type -> Type\n"
"\n"
"> :kind List String\n"
"Type\n"

#. type: Plain text
#: text/chapter3.md:255
msgid ""
"PureScript's _kind system_ supports other interesting kinds, which we will "
"see later in the book."
msgstr ""
"PureScriptの _種システム_ は他にも面白い種に対応していますが、それらについて"
"は本書の他の部分で見ていくことになるでしょう。"

#. type: Title ##
#: text/chapter3.md:256
#, no-wrap
msgid "Quantified Types"
msgstr "量化された型"

#. type: Plain text
#: text/chapter3.md:259
msgid ""
"For illustration purposes, let's define a primitive function that takes any "
"two arguments and returns the first one:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter3.md:260
#, no-wrap
msgid ""
"> :paste\n"
"… constantlyFirst :: forall a b. a -> b -> a\n"
"… constantlyFirst = \\a b -> a\n"
"… ^D\n"
msgstr ""

#. type: Plain text
#: text/chapter3.md:275
#, no-wrap
msgid ""
"> Note that if you use `:type` to ask about the type of `constantlyFirst`, it will be more verbose:\n"
">\n"
"> ```text\n"
"> : type constantlyFirst\n"
"> forall (a :: Type) (b :: Type). a -> b -> a\n"
"> ```\n"
">\n"
"> The type signature contains additional kind information, which explicitly notes that `a` and `b` should be concrete types.\n"
msgstr ""

#. type: Plain text
#: text/chapter3.md:277
#, fuzzy
#| msgid ""
#| "The keyword `forall` here indicates that `flip` has a _universally "
#| "quantified type_. It means we can substitute any types for `a`, `b`, and "
#| "`c`, and `flip` will work with those types."
msgid ""
"The keyword `forall` indicates that `constantlyFirst` has a _universally "
"quantified type_. It means we can substitute any types for `a` and `b` – "
"`constantlyFirst` will work with these types."
msgstr ""
"この`forall`キーワードは、`flip`が*全称量化された型*を持つことを示していま"
"す。\n"
"つまり`a`や`b`や`c`をどの型に置き換えても良く、`flip`はその型で動作するので"
"す。"

#. type: Plain text
#: text/chapter3.md:279
#, fuzzy
#| msgid ""
#| "For example, we might choose the type `a` to be `Int`, `b` to be "
#| "`String`, and `c` to be `String`. In that case, we could _specialize_ the "
#| "type of `flip` to"
msgid ""
"For example, we might choose the type `a` to be `Int` and `b` – `String`. In "
"that case, we can _specialize_ the type of `constantlyFirst` to"
msgstr ""
"例えば、`a`を`Int`、`b`を`String`、`c`を`String`と選んだとします。\n"
"その場合、`flip`の型を次のように*特殊化*できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:280
#, fuzzy, no-wrap
#| msgid "log :: String -> Effect Unit\n"
msgid "Int -> String -> Int\n"
msgstr "log :: String -> Effect Unit\n"

#. type: Plain text
#: text/chapter3.md:285
#, fuzzy
#| msgid ""
#| "We don't have to indicate in code that we want to specialize a quantified "
#| "type – it happens automatically. For example, we can use `flip` as if it "
#| "had this type already:"
msgid ""
"We don't have to indicate in code that we want to specialize a quantified "
"type – it happens automatically. For example, we can use `constantlyFirst` "
"as if it had this type already:"
msgstr ""
"量化された型を特殊化したいということをコードで示す必要はありません。\n"
"特殊化は自動的に行われます。\n"
"例えば、あたかも既にその型の`flip`を持っていたかのように、`flip`を使えます。"

#. type: Fenced code block (text)
#: text/chapter3.md:286
#, no-wrap
msgid ""
"> constantlyFirst 3 \"ignored\"\n"
"\n"
"3\n"
msgstr ""

#. type: Plain text
#: text/chapter3.md:293
msgid ""
"While we can choose any types for `a` and `b`, the return type of "
"`constantlyFirst` has to be the same as the type of the first argument "
"(because both of them are \"tied\" to the same `a`):"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter3.md:294
#, no-wrap
msgid ""
":type constantlyFirst true \"ignored\"\n"
"Boolean\n"
"\n"
":type constantlyFirst \"keep\" 3\n"
"String\n"
msgstr ""

#. type: Title ##
#: text/chapter3.md:302
#, no-wrap
msgid "Displaying Address Book Entries"
msgstr "住所録の項目の表示"

#. type: Plain text
#: text/chapter3.md:305
msgid ""
"Let's write our first function, which will render an address book entry as a "
"string. We start by giving the function a type. This is optional, but good "
"practice, since it acts as a form of documentation. In fact, the PureScript "
"compiler will give a warning if a top-level declaration does not contain a "
"type annotation. A type declaration separates the name of a function from "
"its type with the `::` symbol:"
msgstr ""
"それでは最初に、文字列で住所録の項目を表現する関数を書いてみましょう。\n"
"まずは関数に型を与えることから始めます。\n"
"型の定義は省略できますが、ドキュメントとしても役立つので型を書いておくように"
"すると良いでしょう。\n"
"実際、最上位の宣言に型註釈が含まれていないと、PureScriptコンパイラが警告を出"
"します。\n"
"型宣言は関数の名前とその型を `::`記号で区切るようにして書きます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:306
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:311
msgid ""
"This type signature says that `showEntry` is a function that takes an "
"`Entry` as an argument and returns a `String`. Here is the code for "
"`showEntry`:"
msgstr ""
"この型シグネチャが言っているのは、`showEntry`は引数として`Entry`を取り"
"`String`を返す関数であるということです。\n"
"以下は`showEntry`のコードです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:312
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_implementation}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_implementation}}\n"

#. type: Plain text
#: text/chapter3.md:317
msgid ""
"This function concatenates the three fields of the `Entry` record into a "
"single string, using the `showAddress` function to turn the record inside "
"the `address` field into a `String`. `showAddress` is defined similarly:"
msgstr ""
"この関数は`Entry`レコードの3つのフィールドを連結し、単一の文字列にします。\n"
"ここで使用される`showAddress`関数は`address`フィールド中のレコードを文字列に"
"変えます。\n"
"`showAddress`の定義は次の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:318
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showAddress}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showAddress}}\n"

#. type: Plain text
#: text/chapter3.md:323
#, no-wrap
msgid "A function definition begins with the name of the function, followed by a list of argument names. The result of the function is specified after the equals sign. Fields are accessed with a dot, followed by the field name. In PureScript, string concatenation uses the diamond operator (`<>`), instead of the plus operator like in JavaScript.\n"
msgstr "関数定義は関数の名前で始まり、引数名のリストが続きます。関数の結果は等号の後ろに定義します。フィールドはドットに続けてフィールド名を書くことで参照できます。PureScriptでは、文字列連結はJavaScriptのような単一のプラス記号ではなく、ダイアモンド演算子（`<>`）を使用します。\n"

#. type: Title ##
#: text/chapter3.md:324
#, no-wrap
msgid "Test Early, Test Often"
msgstr "はやめにテスト、たびたびテスト"

#. type: Plain text
#: text/chapter3.md:327
msgid ""
"The PSCi interactive mode allows for rapid prototyping with immediate "
"feedback, so let's use it to verify that our first few functions behave as "
"expected."
msgstr ""
"PSCi対話式モードでは反応を即座に得られるので、素早い試作開発に向いていま"
"す。\n"
"それではこの最初の関数が正しく動作するかをPSCiを使用して確認してみましょう。"

#. type: Plain text
#: text/chapter3.md:329
msgid "First, build the code you've written:"
msgstr "まず、これまでに書いたコードをビルドします。"

#. type: Plain text
#: text/chapter3.md:335
msgid ""
"Next, load PSCi, and use the `import` command to import your new module:"
msgstr ""
"次に、PSCiを起動し、この新しいモジュールをインポートするために `import`命令を"
"使います。"

#. type: Fenced code block (text)
#: text/chapter3.md:336
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.AddressBook\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.AddressBook\n"

#. type: Plain text
#: text/chapter3.md:343
msgid ""
"We can create an entry by using a record literal, which looks just like an "
"anonymous object in JavaScript."
msgstr ""
"レコード直値を使うと、住所録の項目を作成できます。レコード直値はJavaScriptの"
"無名オブジェクトと同じような構文で名前に束縛します。"

#. type: Fenced code block (text)
#: text/chapter3.md:344
#, no-wrap
msgid "> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
msgstr "> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"

#. type: Plain text
#: text/chapter3.md:349
msgid "Now, try applying our function to the example:"
msgstr "それでは、この例に関数を適用してみてください。"

#. type: Fenced code block (text)
#: text/chapter3.md:350
#, no-wrap
msgid ""
"> showAddress address\n"
"\n"
"\"123 Fake St., Faketown, CA\"\n"
msgstr ""
"> showAddress address\n"
"\n"
"\"123 Fake St., Faketown, CA\"\n"

#. type: Plain text
#: text/chapter3.md:357
msgid ""
"Let's also test `showEntry` by creating an address book entry record "
"containing our example address:"
msgstr "`showEntry`も、住所の例を含む住所録項目レコードを作って試しましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:358
#, no-wrap
msgid ""
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> showEntry entry\n"
"\n"
"\"Smith, John: 123 Fake St., Faketown, CA\"\n"
msgstr ""
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> showEntry entry\n"
"\n"
"\"Smith, John: 123 Fake St., Faketown, CA\"\n"

#. type: Title ##
#: text/chapter3.md:365
#, no-wrap
msgid "Creating Address Books"
msgstr "住所録の作成"

#. type: Plain text
#: text/chapter3.md:368
msgid ""
"Now let's write some utility functions for working with address books. We "
"will need a value representing an empty address book: an empty list."
msgstr ""
"今度は住所録を扱う補助関数を幾つか書いてみましょう。\n"
"空の住所録を表す値が必要ですが、これは空のリストです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:369
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:emptyBook}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:emptyBook}}\n"

#. type: Plain text
#: text/chapter3.md:374
msgid ""
"We will also need a function for inserting a value into an existing address "
"book. We will call this function `insertEntry`. Start by giving its type:"
msgstr ""
"既存の住所録に値を挿入する関数も必要でしょう。この関数を `insertEntry`と呼ぶ"
"ことにします。関数の型を与えることから始めましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:375 text/chapter3.md:459
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:380
msgid ""
"This type signature says that `insertEntry` takes an `Entry` as its first "
"argument, an `AddressBook` as a second argument, and returns a new "
"`AddressBook`."
msgstr ""
"この型シグネチャに書かれているのは、最初の引数として`Entry`、第2引数として"
"`AddressBook`を取り、新しい`AddressBook`を返すということです。"

#. type: Plain text
#: text/chapter3.md:382
msgid ""
"We don't modify the existing `AddressBook` directly. Instead, we return a "
"new `AddressBook`, which contains the same data. As such, `AddressBook` is "
"an example of an _immutable data structure_. This is an important idea in "
"PureScript – mutation is a side-effect of code and inhibits our ability to "
"reason effectively about its behavior, so we prefer pure functions and "
"immutable data where possible."
msgstr ""
"既存の`AddressBook`を直接変更することはしません。\n"
"代わりに、同じデータが含まれている新しい`AddressBook`を返します。\n"
"このように`AddressBook`は*不変データ構造*の一例となっています。\n"
"これはPureScriptにおける重要な考え方です。\n"
"変更はコードの副作用であり、効率良く挙動を探る上で妨げになります。\n"
"そのため可能な限り純粋関数や不変なデータにする方が好ましいのです。"

#. type: Plain text
#: text/chapter3.md:384
msgid ""
"To implement `insertEntry`, we can use the `Cons` function from `Data.List`. "
"To see its type, open PSCi and use the `:type` command:"
msgstr ""
"`insertEntry`を実装するのに`Data.List`の`Cons`関数が使えます。\n"
"この関数の型を見るには、PSCiを起動し `:type`コマンドを使います。"

#. type: Fenced code block (text)
#: text/chapter3.md:385
#, fuzzy, no-wrap
#| msgid ""
#| "$ spago repl\n"
#| "\n"
#| "> import Data.List\n"
#| "> :type Cons\n"
#| "\n"
#| "forall a. a -> List a -> List a\n"
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type Cons\n"
"\n"
"forall (a :: Type). a -> List a -> List a\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type Cons\n"
"\n"
"forall a. a -> List a -> List a\n"

#. type: Plain text
#: text/chapter3.md:395
msgid ""
"This type signature says that `Cons` takes a value of some type `a`, takes a "
"list of elements of type `a`, and returns a new list with entries of the "
"same type. Let's specialize this with `a` as our `Entry` type:"
msgstr ""
"この型シグネチャで書かれているのは、`Cons`が何らかの型`a`の値と型`a`の要素の"
"リストを取り、同じ型の項目を持つ新しいリストを返すということです。\n"
"`a`を`Entry`型として特殊化してみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:396
#, no-wrap
msgid "Entry -> List Entry -> List Entry\n"
msgstr "Entry -> List Entry -> List Entry\n"

#. type: Plain text
#: text/chapter3.md:401
msgid "But `List Entry` is the same as `AddressBook`, so this is equivalent to"
msgstr ""
"しかし、 `List Entry`はまさに `AddressBook`ですから、次と同じになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:402
#, no-wrap
msgid "Entry -> AddressBook -> AddressBook\n"
msgstr "Entry -> AddressBook -> AddressBook\n"

#. type: Plain text
#: text/chapter3.md:407
msgid ""
"In our case, we already have the appropriate inputs: an `Entry`, and an "
"`AddressBook`, so can apply `Cons` and get a new `AddressBook`, which is "
"exactly what we wanted!"
msgstr ""
"今回の場合、既に適切な入力があります。\n"
"`Entry`と `AddressBook`に `Cons`を適用すると、新しい `AddressBook`を得ること"
"ができます。\n"
"これこそがまさに求めていた関数です。"

#. type: Plain text
#: text/chapter3.md:409
msgid "Here is our implementation of `insertEntry`:"
msgstr "`insertEntry`の実装は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:410
#, no-wrap
msgid "insertEntry entry book = Cons entry book\n"
msgstr "insertEntry entry book = Cons entry book\n"

#. type: Plain text
#: text/chapter3.md:415
msgid ""
"This brings the two arguments `entry` and `book` into scope – on the left-"
"hand side of the equals symbol – and then applies the `Cons` function to "
"create the result."
msgstr ""
"こうすると、等号の左側にある2つの引数`entry`と`book`がスコープに導入されま"
"す。\n"
"それから`Cons`関数を適用し、結果を作成しています。"

#. type: Title ##
#: text/chapter3.md:416
#, no-wrap
msgid "Curried Functions"
msgstr "カリー化された関数"

#. type: Plain text
#: text/chapter3.md:419
#, fuzzy
#| msgid ""
#| "Functions in PureScript take exactly one argument. While it looks like "
#| "the `insertEntry` function takes two arguments, it is an example of a "
#| "_curried function_."
msgid ""
"Functions in PureScript take exactly one argument. While it looks like the "
"`insertEntry` function takes two arguments, it is an example of a _curried "
"function_. In PureScript, all functions are considered curried."
msgstr ""
"PureScriptでは、関数は常に1つの引数だけを取ります。\n"
"`insertEntry`関数は2つの引数を取るように見えますが、*カリー化された関数*の一"
"例なのです。"

#. type: Plain text
#: text/chapter3.md:421
msgid ""
"Currying means converting a function that takes multiple arguments into a "
"function that takes them one at a time. When we call a function, we pass it "
"one argument, and it returns another function that also takes one argument "
"until all arguments are passed."
msgstr ""

#. type: Plain text
#: text/chapter3.md:423
msgid ""
"For example, when we pass `5` to `add`, we get another function, which takes "
"an int, adds 5 to it, and returns the sum as a result:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter3.md:424
#, fuzzy, no-wrap
#| msgid ""
#| "add :: Int -> Int -> Int\n"
#| "add x y = x + y\n"
msgid ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"
"\n"
"addFive :: Int -> Int\n"
"addFive = add 5\n"
msgstr ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"

#. type: Plain text
#: text/chapter3.md:433
msgid ""
"`addFive` is the result of _partial application_, which means we pass less "
"than the total number of arguments to a function that takes multiple "
"arguments. Let's give it a try:"
msgstr ""

#. type: Plain text
#: text/chapter3.md:443
#, no-wrap
msgid ""
"> Note that you must define the `add` function if you haven't already:\n"
">\n"
"> ```text\n"
"> > import Prelude\n"
"> > :paste\n"
">… add :: Int -> Int -> Int\n"
">… add x y = x + y\n"
">… ^D\n"
"> ```\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter3.md:444
#, fuzzy, no-wrap
#| msgid ""
#| "> :paste\n"
#| "… add :: Int -> Int -> Int\n"
#| "… add = \\x y -> x + y\n"
#| "… ^D\n"
msgid ""
"> :paste\n"
"… addFive :: Int -> Int\n"
"… addFive = add 5\n"
"… ^D\n"
"\n"
"> addFive 1\n"
"6\n"
"\n"
"> add 5 1\n"
"6\n"
msgstr ""
"> :paste\n"
"… add :: Int -> Int -> Int\n"
"… add = \\x y -> x + y\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:458
msgid ""
"To better understand currying and partial application, try making a few "
"other functions, for example, out of `add`. And when you're done, let's "
"return to the `insertEntry`."
msgstr ""

#. type: Plain text
#: text/chapter3.md:464
#, fuzzy, no-wrap
#| msgid "The `->` operator in the type of `insertEntry` associates to the right, which means that the compiler parses the type as\n"
msgid "The `->` operator (in the type signature) associates to the right, which means that the compiler parses the type as\n"
msgstr "`insertEntry`の型に含まれる `->`は右結合の演算子であり、つまりこの型はコンパイラによって次のように解釈されます。\n"

#. type: Fenced code block (haskell)
#: text/chapter3.md:465
#, no-wrap
msgid "Entry -> (AddressBook -> AddressBook)\n"
msgstr "Entry -> (AddressBook -> AddressBook)\n"

#. type: Plain text
#: text/chapter3.md:470
#, fuzzy
#| msgid ""
#| "That is, `insertEntry` is a function that returns a function! It takes a "
#| "single argument, an `Entry`, and returns a new function, which in turn "
#| "takes a single `AddressBook` argument and returns a new `AddressBook`."
msgid ""
"`insertEntry` takes a single argument, an `Entry`, and returns a new "
"function, which in turn takes a single `AddressBook` argument and returns a "
"new `AddressBook`."
msgstr ""
"すなわち、`insertEntry`は関数を返す関数なのです。\n"
"この関数は単一の引数`Entry`を取り、新しい関数を返します。\n"
"今度はこの関数が単一の引数`AddressBook`を取り、新しい`AddressBook`を返しま"
"す。"

#. type: Plain text
#: text/chapter3.md:472
msgid ""
"This means we can _partially apply_ `insertEntry` by specifying only its "
"first argument, for example. In PSCi, we can see the result type:"
msgstr ""
"これはつまり、最初の引数だけを与えて`insertEntry`を*部分適用*できたりするとい"
"うことです。\n"
"PSCiで結果の型が見られます。"

#. type: Fenced code block (text)
#: text/chapter3.md:473
#, no-wrap
msgid ""
"> :type insertEntry entry\n"
"\n"
"AddressBook -> AddressBook\n"
msgstr ""
"> :type insertEntry entry\n"
"\n"
"AddressBook -> AddressBook\n"

#. type: Plain text
#: text/chapter3.md:480
msgid ""
"As expected, the return type was a function. We can apply the resulting "
"function to a second argument:"
msgstr ""
"期待した通り、戻り値の型は関数になっていました。\n"
"この結果の関数に2つ目の引数も適用できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:481
#, no-wrap
msgid ""
"> :type (insertEntry entry) emptyBook\n"
"AddressBook\n"
msgstr ""
"> :type (insertEntry entry) emptyBook\n"
"AddressBook\n"

#. type: Plain text
#: text/chapter3.md:487
msgid ""
"Note though, that the parentheses here are unnecessary – the following is "
"equivalent:"
msgstr ""
"ただし、ここでの括弧は不要です。\n"
"以下は等価です。"

#. type: Fenced code block (text)
#: text/chapter3.md:488
#, no-wrap
msgid ""
"> :type insertEntry entry emptyBook\n"
"AddressBook\n"
msgstr ""
"> :type insertEntry entry emptyBook\n"
"AddressBook\n"

#. type: Plain text
#: text/chapter3.md:494
msgid ""
"This is because function application associates to the left, which explains "
"why we can specify function arguments one after the other, separated by "
"whitespace."
msgstr ""
"これは関数適用が左に結合するためで、なぜ空白で区切った引数を次々に関数に指定"
"するだけでいいのかの説明にもなっています。"

#. type: Plain text
#: text/chapter3.md:496
#, no-wrap
msgid "The `->` operator in function types is a _type constructor_ for functions. It takes two type arguments: the function's argument type and the return type – the left and right operands, respectively.\n"
msgstr ""
"関数の型の`->`演算子は関数の*型構築子*です。\n"
"この演算子は2つの型引数を取ります。\n"
"左右の被演算子はそれぞれ関数の引数の型と返り値の型です。\n"

#. type: Plain text
#: text/chapter3.md:498
msgid ""
"Note that in the rest of the book, I will talk about things like \"functions "
"of two arguments\". However, it is to be understood that this means a "
"curried function, taking a first argument and returning a function that "
"takes the second."
msgstr ""
"本書では今後、「2引数の関数」というように表現することがあることに注意してくだ"
"さい。\n"
"しかしそれはカリー化された関数を意味していると考えるべきで、その関数は最初の"
"引数を取り2つ目の引数を取る別の関数を返すのです。"

#. type: Plain text
#: text/chapter3.md:500
msgid "Now consider the definition of `insertEntry`:"
msgstr "今度は `insertEntry`の定義について考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:501
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry book = Cons entry book\n"
msgstr ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry book = Cons entry book\n"

#. type: Plain text
#: text/chapter3.md:507
msgid ""
"If we explicitly parenthesize the right-hand side, we get `(Cons entry) "
"book`. That is, `insertEntry entry` is a function whose argument is just "
"passed along to the `(Cons entry)` function. But if two functions have the "
"same result for every input, then they are the same! So we can remove the "
"argument `book` from both sides:"
msgstr ""
"もし式の右辺に明示的に括弧をつけるなら、`(Cons entry) book`となります。\n"
"つまり`insertEntry entry`はその引数が単に関数`(Cons entry)`に渡されるような関"
"数だということです。\n"
"ところがこの2つの関数はどんな入力についても同じ結果を返すので、となると同じ関"
"数ではないですか。\n"
"よって、両辺から引数`book`を削除できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:508
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry = Cons entry\n"
msgstr ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry = Cons entry\n"

#. type: Plain text
#: text/chapter3.md:514
msgid "But now, by the same argument, we can remove `entry` from both sides:"
msgstr "しかし今や同様の議論により、両辺から `entry`も削除できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:515
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry}}\n"

#. type: Plain text
#: text/chapter3.md:520
msgid ""
"This process, called _eta conversion_, can be used (along with other "
"techniques) to rewrite functions in _point-free form_, which means functions "
"defined without reference to their arguments."
msgstr ""
"この処理は*イータ変換*と呼ばれ、（その他の技法を併用して）*ポイントフリー形式"
"*へと関数を書き換えるのに使えます。\n"
"つまり、引数を参照せずに関数を定義できるのです。"

#. type: Plain text
#: text/chapter3.md:522
msgid ""
"In the case of `insertEntry`, _eta conversion_ has resulted in a very clear "
"definition of our function – \"`insertEntry` is just cons on lists\". "
"However, it is arguable whether the point-free form is better in general."
msgstr ""
"`insertEntry`の場合、イータ変換によって「`insertEntry`は単にリストにおける"
"consだ」となり、とても明快な関数の定義になりました。\n"
"しかし、一般にポイントフリー形式のほうがいいのかどうかには議論の余地がありま"
"す。"

#. type: Title ##
#: text/chapter3.md:523
#, no-wrap
msgid "Property Accessors"
msgstr "プロパティ取得子"

#. type: Plain text
#: text/chapter3.md:526
msgid ""
"One common pattern is to use a function to access individual fields (or "
"\"properties\") of a record. An inline function to extract an `Address` from "
"an `Entry` could be written as:"
msgstr ""
"よくあるパターンの1つとして、レコード中の個別のフィールド（または「プロパ"
"ティ」）を取得することがあります。\n"
"`Entry`から`Address`を取り出すインライン関数は次のように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:527
#, no-wrap
msgid "\\entry -> entry.address\n"
msgstr "\\entry -> entry.address\n"

#. type: Plain text
#: text/chapter3.md:532
msgid ""
"PureScript also allows [_property accessor_](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#property-accessors) shorthand, "
"where an underscore acts as the anonymous function argument, so the inline "
"function above is equivalent to:"
msgstr ""
"PureScriptでは[_プロパティ取得子_](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#property-accessors)という略記が"
"使えます。この略記では下線文字は無名関数の引数として振舞うため、上記のインラ"
"イン関数は次と等価です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:533
#, no-wrap
msgid "_.address\n"
msgstr "_.address\n"

#. type: Plain text
#: text/chapter3.md:538
msgid ""
"This works with any number of levels or properties, so a function to extract "
"the city associated with an `Entry` could be written as:"
msgstr ""
"これは何段階のプロパティでも動くため、`Entry`に関連する街を取り出す関数は次の"
"ように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:539
#, no-wrap
msgid "_.address.city\n"
msgstr "_.address.city\n"

#. type: Plain text
#: text/chapter3.md:544 text/chapter5.md:247
msgid "For example:"
msgstr "以下は一例です。"

#. type: Fenced code block (text)
#: text/chapter3.md:545
#, no-wrap
msgid ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> _.lastName entry\n"
"\"Smith\"\n"
"\n"
"> _.address.city entry\n"
"\"Faketown\"\n"
msgstr ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> _.lastName entry\n"
"\"Smith\"\n"
"\n"
"> _.address.city entry\n"
"\"Faketown\"\n"

#. type: Title ##
#: text/chapter3.md:555
#, no-wrap
msgid "Querying the Address Book"
msgstr "住所録に問い合わせる"

#. type: Plain text
#: text/chapter3.md:558
msgid ""
"The last function we need to implement for our minimal address book "
"application will look up a person by name and return the correct `Entry`. "
"This will be a nice application of building programs by composing small "
"functions – a key idea from functional programming."
msgstr ""
"最小限の住所録アプリケーションの実装で必要になる最後の関数は、名前で人を検索"
"し適切な`Entry`を返すものです。\n"
"これは小さな関数を組み合わせることでプログラムを構築するという、関数型プログ"
"ラミングで鍵となる考え方のよい応用例になるでしょう。"

#. type: Plain text
#: text/chapter3.md:560
msgid ""
"We can filter the address book, keeping only those entries with the correct "
"first and last names. Then we can return the head (i.e., first) element of "
"the resulting list."
msgstr ""
"住所録を絞り込めば該当する姓名を持つ項目だけを保持するようにできます。\n"
"そうすれば結果のリストの先頭（つまり最初）の要素を返せます。"

#. type: Plain text
#: text/chapter3.md:562
msgid ""
"With this high-level specification of our approach, we can calculate the "
"type of our function. First, open PSCi, and find the types of the `filter` "
"and `head` functions:"
msgstr ""
"この大まかな道筋の仕様があれば関数の型を計算できます。\n"
"まずPSCiを開いて`filter`関数と`head`関数の型を探してみましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:563
#, fuzzy, no-wrap
#| msgid ""
#| "$ spago repl\n"
#| "\n"
#| "> import Data.List\n"
#| "> :type filter\n"
#| "\n"
#| "forall a. (a -> Boolean) -> List a -> List a\n"
#| "\n"
#| "> :type head\n"
#| "\n"
#| "forall a. List a -> Maybe a\n"
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type filter\n"
"\n"
"forall (a :: Type). (a -> Boolean) -> List a -> List a\n"
"\n"
"> :type head\n"
"\n"
"forall (a :: Type). List a -> Maybe a\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type filter\n"
"\n"
"forall a. (a -> Boolean) -> List a -> List a\n"
"\n"
"> :type head\n"
"\n"
"forall a. List a -> Maybe a\n"

#. type: Plain text
#: text/chapter3.md:577
msgid "Let's pick apart these two types to understand their meaning."
msgstr ""
"型の意味を理解するために、これらの2つの型の一部を取り出してみましょう。"

#. type: Plain text
#: text/chapter3.md:579
msgid ""
"`filter` is a curried function of two arguments. Its first argument is a "
"function, which takes an element of the list and returns a `Boolean` value. "
"Its second argument is a list of elements, and the return value is another "
"list."
msgstr ""
"`filter`は2引数のカリー化された関数です。\n"
"最初の引数は関数で、リストの要素を取り`Boolean`値を返します。\n"
"第2引数は要素のリストで、返り値は別のリストです。"

#. type: Plain text
#: text/chapter3.md:581
msgid ""
"`head` takes a list as its argument and returns a type we haven't seen "
"before: `Maybe a`. `Maybe a` represents an optional value of type `a`, and "
"provides a type-safe alternative to using `null` to indicate a missing value "
"in languages like JavaScript. We will see it again in more detail in later "
"chapters."
msgstr ""
"`head`は引数としてリストを取り、 `Maybe a`という今までに見たことがない型を返"
"します。\n"
"`Maybe a`は型`a`の省略可能な値を表しており、JavaScriptのような言語で値がない"
"ことを示すための`null`を使う代わりとなる、型安全な代替を提供します。\n"
"後の章で改めて詳しく見ていきます。"

#. type: Plain text
#: text/chapter3.md:583
msgid ""
"The universally quantified types of `filter` and `head` can be _specialized_ "
"by the PureScript compiler, to the following types:"
msgstr ""
"`filter`と `head`の全称量化された型は、PureScriptコンパイラによって次のよう"
"に _特殊化_ (specialized) されます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:584
#, no-wrap
msgid ""
"filter :: (Entry -> Boolean) -> AddressBook -> AddressBook\n"
"\n"
"head :: AddressBook -> Maybe Entry\n"
msgstr ""
"filter :: (Entry -> Boolean) -> AddressBook -> AddressBook\n"
"\n"
"head :: AddressBook -> Maybe Entry\n"

#. type: Plain text
#: text/chapter3.md:591
msgid ""
"We know that we will need to pass the first and last names that we want to "
"search for as arguments to our function."
msgstr "関数の引数として姓名を渡す必要があるだろうということは分かっています。"

#. type: Plain text
#: text/chapter3.md:593
#, no-wrap
msgid "We also know that we will need a function to pass to `filter`. Let's call this function `filterEntry`. `filterEntry` will have type `Entry -> Boolean`. The application `filter filterEntry` will then have type `AddressBook -> AddressBook`. If we pass the result of this function to the `head` function, we get our result of type `Maybe Entry`.\n"
msgstr "`filter`に渡す関数も必要になることもわかります。この関数を `filterEntry`と呼ぶことにしましょう。 `filterEntry`は `Entry -> Boolean`という型を持っています。 `filter filterEntry`という関数適用の式は、 `AddressBook -> AddressBook`という型を持つでしょう。もしこの関数の結果を `head`関数に渡すと、型 `Maybe Entry`の結果を得ることになります。\n"

#. type: Plain text
#: text/chapter3.md:595
msgid ""
"Putting these facts together, a reasonable type signature for our function, "
"which we will call `findEntry`, is:"
msgstr ""
"これまでのことを纏めると、関数の妥当な型シグネチャは次のようになります。"
"`findEntry`と呼ぶことにしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:596
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:601
msgid ""
"This type signature says that `findEntry` takes two strings: the first and "
"last names, takes an `AddressBook`, and returns an optional `Entry`. The "
"optional result will contain a value only if the name is found in the "
"address book."
msgstr ""
"この型シグネチャで書かれているのは、`findEntry`が姓と名前の2つの文字列及び"
"`AddressBook`を引数に取り、省略可能な`Entry`を返すということです。\n"
"省略可能な結果は名前が住所録に見付かった場合にのみ値を持ちます。"

#. type: Plain text
#: text/chapter3.md:603
msgid "And here is the definition of `findEntry`:"
msgstr "そして、 `findEntry`の定義は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:604
#, no-wrap
msgid ""
"findEntry firstName lastName book = head (filter filterEntry book)\n"
"  where\n"
"    filterEntry :: Entry -> Boolean\n"
"    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName\n"
msgstr ""
"findEntry firstName lastName book = head (filter filterEntry book)\n"
"  where\n"
"    filterEntry :: Entry -> Boolean\n"
"    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName\n"

#. type: Plain text
#: text/chapter3.md:612
msgid "Let's go over this code step by step."
msgstr "一歩ずつこのコードを調べてみましょう。"

#. type: Plain text
#: text/chapter3.md:614
msgid ""
"`findEntry` brings three names into scope: `firstName` and `lastName`, both "
"representing strings, and `book`, an `AddressBook`."
msgstr ""
"`findEntry`は、どちらも文字列型である `firstName`と `lastName`、`AddressBook`"
"型の `book`という3つの名前をスコープに導入します。"

#. type: Plain text
#: text/chapter3.md:616
msgid ""
"The right-hand side of the definition combines the `filter` and `head` "
"functions: first, the list of entries is filtered, and the `head` function "
"is applied to the result."
msgstr ""
"定義の右辺では`filter`関数と`head`関数が組み合わさっています。\n"
"まず項目のリストを絞り込み、その結果に`head`関数を適用しています。"

#. type: Plain text
#: text/chapter3.md:618
msgid ""
"The predicate function `filterEntry` is defined as an auxiliary declaration "
"inside a `where` clause. This way, the `filterEntry` function is available "
"inside the definition of our function, but not outside it. Also, it can "
"depend on the arguments to the enclosing function, which is essential here "
"because `filterEntry` uses the `firstName` and `lastName` arguments to "
"filter the specified `Entry`."
msgstr ""
"真偽型を返す関数 `filterEntry`は `where`節の内部で補助的な関数として定義され"
"ています。\n"
"このため、 `filterEntry`関数はこの定義の内部では使用できますが、外部では使用"
"できません。\n"
"また、`filterEntry`はそれを包む関数の引数に依存でき、 `filterEntry`は指定され"
"た `Entry`を絞り込むために引数 `firstName`と `lastName`を使用しているので、 "
"`filterEntry`が `findEntry`の内部にあることは必須になっています。"

#. type: Plain text
#: text/chapter3.md:620
msgid ""
"Note that, just like for top-level declarations, it was unnecessary to "
"specify a type signature for `filterEntry`. However, doing so is recommended "
"as a form of documentation."
msgstr ""
"なお、最上位での宣言と同じように、必ずしも`filterEntry`の型シグネチャを指定し"
"なくても構いません。\n"
"ただし、ドキュメントの一形態として指定しておくことが推奨されます。"

#. type: Title ##
#: text/chapter3.md:621
#, no-wrap
msgid "Infix Function Application"
msgstr "中置の関数適用"

#. type: Plain text
#: text/chapter3.md:624
msgid ""
"Most functions discussed so far used _prefix_ function application, where "
"the function name was put _before_ the arguments. For example, when using "
"the `insertEntry` function to add an `Entry` (`john`) to an empty "
"`AddressBook`, we might write:"
msgstr ""
"これまでお話しした関数のほとんどは*前置*関数適用でした。\n"
"関数名が引数の*前*に置かれていたということです。\n"
"例えば`insertEntry`関数を使って`Entry` (`john`) を空の`AddressBook`に追加する"
"場合、以下のように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:625
#, no-wrap
msgid "> book1 = insertEntry john emptyBook\n"
msgstr "> book1 = insertEntry john emptyBook\n"

#. type: Plain text
#: text/chapter3.md:630
msgid ""
"However, this chapter has also included examples of _infix_ [binary "
"operators](https://github.com/purescript/documentation/blob/master/language/"
"Syntax.md#binary-operators), such as the `==` operator in the definition of "
"`filterEntry`, where the operator is put _between_ the two arguments. These "
"infix operators are defined in the PureScript source as infix aliases for "
"their underlying _prefix_ implementations. For example, `==` is defined as "
"an infix alias for the prefix `eq` function with the line:"
msgstr ""
"しかし本章には*中置*[2引数演算子](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#binary-operators)の例も含まれて"
"います。\n"
"`filterEntry`の定義中の`==`演算子がそうで、2つの引数の*間*に置かれていま"
"す。\n"
"PureScriptのソースコードでこうした中置演算子は隠れた*前置*の実装への中置別称"
"として定義されています。\n"
"例えば`==`は以下の行により前置の`eq`関数の中置別称として定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:631
#, no-wrap
msgid "infix 4 eq as ==\n"
msgstr "infix 4 eq as ==\n"

#. type: Plain text
#: text/chapter3.md:636
msgid ""
"Therefore `entry.firstName == firstName` in `filterEntry` could be replaced "
"with the `eq entry.firstName firstName`. We'll cover a few more examples of "
"defining infix operators later in this section."
msgstr ""
"したがって`filterEntry`中の`entry.firstName == firstName`は`eq entry."
"firstName firstName`で置き換えられます。\n"
"この節の後のほうで中置演算子を定義する例にもう少し触れます。"

#. type: Plain text
#: text/chapter3.md:638
msgid ""
"In some situations, putting a prefix function in an infix position as an "
"operator leads to more readable code. One example is the `mod` function:"
msgstr ""
"前置関数を演算子としての中置の位置に置くと、より読みやすいコードになる場面が"
"あります。\n"
"その一例が`mod`関数です。"

#. type: Fenced code block (text)
#: text/chapter3.md:639
#, no-wrap
msgid ""
"> mod 8 3\n"
"2\n"
msgstr ""
"> mod 8 3\n"
"2\n"

#. type: Plain text
#: text/chapter3.md:645
msgid ""
"The above usage works fine but is awkward to read. A more familiar phrasing "
"is \"eight mod three\", which you can achieve by wrapping a prefix function "
"in backticks (\\`):"
msgstr ""
"上の用例でも充分動作しますが、読みにくいです。\n"
"より馴染みのある表現の仕方は「8 mod 3」です。\n"
"バックスラッシュ (\\`) の中に前置関数を包むとそのように書けます。"

#. type: Fenced code block (text)
#: text/chapter3.md:646
#, no-wrap
msgid ""
"> 8 `mod` 3\n"
"2\n"
msgstr ""
"> 8 `mod` 3\n"
"2\n"

#. type: Plain text
#: text/chapter3.md:652
msgid ""
"In the same way, wrapping `insertEntry` in backticks turns it into an infix "
"operator, such that `book1` and `book2` below are equivalent:"
msgstr ""
"同様に、`insertEntry`をバックスラッシュで包むと中置演算子に変わります。\n"
"例えば以下の`book1`と`book2`は等価です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:653
#, no-wrap
msgid ""
"book1 = insertEntry john emptyBook\n"
"book2 = john `insertEntry` emptyBook\n"
msgstr ""
"book1 = insertEntry john emptyBook\n"
"book2 = john `insertEntry` emptyBook\n"

#. type: Plain text
#: text/chapter3.md:659
msgid ""
"We can make an `AddressBook` with multiple entries by using multiple "
"applications of `insertEntry` as a prefix function (`book3`) or as an infix "
"operator (`book4`) as shown below:"
msgstr ""
"複数回`insertEntry`を適用することで複数の項目がある`AddressBook`を作ることが"
"できますが、以下のように前置関数 (`book3`) として適用するか中置演算子 "
"(`book4`) として適用するかの2択があります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:660
#, no-wrap
msgid ""
"book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))\n"
"book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))\n"
msgstr ""
"book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))\n"
"book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))\n"

#. type: Plain text
#: text/chapter3.md:666
msgid ""
"We can also define an infix operator alias (or synonym) for `insertEntry.` "
"We'll arbitrarily choose `++` for this operator, give it a [precedence]"
"(https://github.com/purescript/documentation/blob/master/language/Syntax."
"md#precedence) of `5`, and make it right [associative](https://github.com/"
"purescript/documentation/blob/master/language/Syntax.md#associativity) using "
"`infixr`:"
msgstr ""
"`insertEntry`には中置演算子別称（または同義語）も定義できます。\n"
"この演算子の名前に適当に`++`を選び、[優先度](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#precedence)を`5`にし、そして"
"`infixr`を使って右[結合](https://github.com/purescript/documentation/blob/"
"master/language/Syntax.md#associativity)とします。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:667
#, no-wrap
msgid "infixr 5 insertEntry as ++\n"
msgstr "infixr 5 insertEntry as ++\n"

#. type: Plain text
#: text/chapter3.md:672
msgid "This new operator lets us rewrite the above `book4` example as:"
msgstr "この新しい演算子で上の`book4`の例を次のように書き直せます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:673
#, no-wrap
msgid "book5 = john ++ (peggy ++ (ned ++ emptyBook))\n"
msgstr "book5 = john ++ (peggy ++ (ned ++ emptyBook))\n"

#. type: Plain text
#: text/chapter3.md:678
msgid ""
"The right associativity of our new `++` operator lets us get rid of the "
"parentheses without changing the meaning:"
msgstr "新しい`++`演算子の右結合性により、意味を変えずに括弧を除去できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:679
#, no-wrap
msgid "book6 = john ++ peggy ++ ned ++ emptyBook\n"
msgstr "book6 = john ++ peggy ++ ned ++ emptyBook\n"

#. type: Plain text
#: text/chapter3.md:684
msgid ""
"Another common technique for eliminating parens is to use `apply`'s infix "
"operator `$`, along with your standard prefix functions."
msgstr ""
"括弧を消去する他のよくある技法は、いつもの前置関数と一緒に`apply`の中置演算子"
"`$`を使うというものです。"

#. type: Plain text
#: text/chapter3.md:686
msgid "For example, the earlier `book3` example could be rewritten as:"
msgstr "例えば前の`book3`の例は以下のように書き直せます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:687
#, no-wrap
msgid "book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook\n"
msgstr "book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook\n"

#. type: Plain text
#: text/chapter3.md:692
msgid ""
"Substituting `$` for parens is usually easier to type and (arguably) easier "
"to read. A mnemonic to remember the meaning of this symbol is to think of "
"the dollar sign as being drawn from two parens that are also being crossed-"
"out, suggesting the parens are now unnecessary."
msgstr ""
"括弧を`$`で置き換えるのは大抵入力しやすくなりますし（議論の余地がありますが）"
"読みやすくなります。\n"
"この記号の意味を覚えるための記憶術として、ドル記号を2つの括弧に打ち消し線が引"
"かれたものと見ることで、これで括弧が不必要になったのだと推測できるという方法"
"があります。"

#. type: Plain text
#: text/chapter3.md:694
msgid ""
"Note that `$` isn't a special syntax hardcoded into the language. It's "
"simply the infix operator for a regular function called `apply`, which is "
"defined in `Data.Function` as follows:"
msgstr ""
"なお、`($)`は言語にハードコードされた特別な構文ではありません。\n"
"単に`apply`という名前の普通の関数のための中置演算子であって、`Data.Function`"
"で以下のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:695
#, no-wrap
msgid ""
"apply :: forall a b. (a -> b) -> a -> b\n"
"apply f x = f x\n"
"\n"
"infixr 0 apply as $\n"
msgstr ""
"apply :: forall a b. (a -> b) -> a -> b\n"
"apply f x = f x\n"
"\n"
"infixr 0 apply as $\n"

#. type: Plain text
#: text/chapter3.md:703
#, no-wrap
msgid "The `apply` function takes another function (of type `(a -> b)`) as its first argument and a value (of type `a`) as its second argument, then calls that function with that value. If it seems like this function doesn't contribute anything meaningful, you are absolutely correct! Your program is logically identical without it (see [referential transparency](https://en.wikipedia.org/wiki/Referential_transparency)). The syntactic utility of this function comes from the special properties assigned to its infix operator. `$` is a right-associative (`infixr`), low precedence (`0`) operator, which lets us remove sets of parentheses for deeply-nested applications.\n"
msgstr ""
"`apply`関数は、他の関数（型は`(a -> b)`）を最初の引数に、値（型は`a`）を2つ目の引数に取って、その値に対して関数を呼びます。\n"
"この関数が何ら意味のあることをしていないようだと思ったら、全くもって正しいです。\n"
"この関数がなくてもプログラムは論理的に同一です（[参照透過性](https://en.wikipedia.org/wiki/Referential_transparency)も見てください）。\n"
"この関数の構文的な利便性はその中置演算子に割り当てられた特別な性質からきています。\n"
"`$`は右結合 (`infixr`) で低い優先度 (`0`) の演算子ですが、これにより深い入れ子になった適用から括弧の束を削除できるのです。\n"

#. type: Plain text
#: text/chapter3.md:705
msgid ""
"Another parens-busting opportunity for the `$` operator is in our earlier "
"`findEntry` function:"
msgstr ""
"さらなる`$`演算子を使った括弧退治のチャンスは以前の`findEntry`関数にありま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:706
#, no-wrap
msgid "findEntry firstName lastName book = head $ filter filterEntry book\n"
msgstr "findEntry firstName lastName book = head $ filter filterEntry book\n"

#. type: Plain text
#: text/chapter3.md:711
msgid ""
"We'll see an even more elegant way to rewrite this line with \"function "
"composition\" in the next section."
msgstr "この行をより簡潔に書き換える方法を次節の「関数合成」で見ていきます。"

#. type: Plain text
#: text/chapter3.md:713
msgid ""
"If you'd like to use a concise infix operator alias as a prefix function, "
"you can surround it in parentheses:"
msgstr ""
"名前の短い中置演算子を前置関数として使いたければ括弧で囲むことができます。"

#. type: Fenced code block (text)
#: text/chapter3.md:714
#, no-wrap
msgid ""
"> 8 + 3\n"
"11\n"
"\n"
"> (+) 8 3\n"
"11\n"
msgstr ""
"> 8 + 3\n"
"11\n"
"\n"
"> (+) 8 3\n"
"11\n"

#. type: Plain text
#: text/chapter3.md:723
msgid ""
"Alternatively, operators can be partially applied by surrounding the "
"expression with parentheses and using `_` as an operand in an [operator "
"section](https://github.com/purescript/documentation/blob/master/language/"
"Syntax.md#operator-sections). You can think of this as a more convenient way "
"to create simple anonymous functions (although in the below example, we're "
"then binding that anonymous function to a name, so it's not so anonymous "
"anymore):"
msgstr ""
"その代わりの手段として演算子は部分適用でき、これには式を括弧で囲んで[演算子"
"節](https://github.com/purescript/documentation/blob/master/language/Syntax."
"md#operator-sections)中の引数として`_`を使います。これは簡単な無名関数を作る"
"より便利な方法として考えることができます（以下の例ではそこから無名関数を名前"
"に束縛しているので、もはや別に無名とも言えなくなっていますが）。"

#. type: Fenced code block (text)
#: text/chapter3.md:724
#, no-wrap
msgid ""
"> add3 = (3 + _)\n"
"> add3 2\n"
"5\n"
msgstr ""
"> add3 = (3 + _)\n"
"> add3 2\n"
"5\n"

#. type: Plain text
#: text/chapter3.md:731
msgid ""
"To summarize, the following are equivalent definitions of a function that "
"adds `5` to its argument:"
msgstr "纏めると、以下は引数に`5`を加える関数の等価な定義です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:732
#, no-wrap
msgid ""
"add5 x = 5 + x\n"
"add5 x = add 5 x\n"
"add5 x = (+) 5 x\n"
"add5 x = 5 `add` x\n"
"add5   = add 5\n"
"add5   = \\x -> 5 + x\n"
"add5   = (5 + _)\n"
"add5 x = 5 `(+)` x  -- Yo Dawg, I herd you like infix, so we put infix in your infix!\n"
msgstr ""
"add5 x = 5 + x\n"
"add5 x = add 5 x\n"
"add5 x = (+) 5 x\n"
"add5 x = 5 `add` x\n"
"add5   = add 5\n"
"add5   = \\x -> 5 + x\n"
"add5   = (5 + _)\n"
"add5 x = 5 `(+)` x  -- よおポチ、中置に目がないっていうから、中置の中に中置を入れといたぜ\n"

#. type: Title ##
#: text/chapter3.md:743
#, no-wrap
msgid "Function Composition"
msgstr "関数合成"

#. type: Plain text
#: text/chapter3.md:746
msgid ""
"Just like we were able to simplify the `insertEntry` function by using eta "
"conversion, we can simplify the definition of `findEntry` by reasoning about "
"its arguments."
msgstr ""
"イータ変換を使うと `insertEntry`関数を簡略化できたのと同じように、引数をよく"
"考察すると `findEntry`の定義を簡略化できます。"

#. type: Plain text
#: text/chapter3.md:748
msgid ""
"Note that the `book` argument is passed to the `filter filterEntry` "
"function, and the result of this application is passed to `head`. In other "
"words, `book` is passed to the _composition_ of the functions `filter "
"filterEntry` and `head`."
msgstr ""
"なお、引数 `book`は関数 `filter filterEntry`に渡され、この適用の結果が `head`"
"に渡されます。これは言いかたを変えれば、 `filter filterEntry`と `head`の _合"
"成_ (composition) に `book`が渡されるということです。"

#. type: Plain text
#: text/chapter3.md:750
#, no-wrap
msgid "In PureScript, the function composition operators are `<<<` and `>>>`. The first is \"backwards composition\", and the second is \"forwards composition\".\n"
msgstr "PureScriptの関数合成演算子は `<<<`と `>>>`です。前者は「逆方向の合成」であり、後者は「順方向の合成」です。\n"

#. type: Plain text
#: text/chapter3.md:752
msgid ""
"We can rewrite the right-hand side of `findEntry` using either operator. "
"Using backwards-composition, the right-hand side would be"
msgstr ""
"何れかの演算子を使用して `findEntry`の右辺を書き換えることができます。\n"
"逆順の合成を使用すると、右辺は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:753
#, no-wrap
msgid "(head <<< filter filterEntry) book\n"
msgstr "(head <<< filter filterEntry) book\n"

#. type: Plain text
#: text/chapter3.md:758
msgid ""
"In this form, we can apply the eta conversion trick from earlier, to arrive "
"at the final form of `findEntry`:"
msgstr ""
"この形式なら最初の定義にイータ変換の技を適用でき、 `findEntry`は最終的に次の"
"ような形式に到達します。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:759
#, no-wrap
msgid ""
"{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_implementation}}\n"
"    ...\n"
msgstr ""
"{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_implementation}}\n"
"    ...\n"

#. type: Plain text
#: text/chapter3.md:765
msgid "An equally valid right-hand side would be:"
msgstr "右辺を次のようにしても同じく妥当です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:766
#, no-wrap
msgid "filter filterEntry >>> head\n"
msgstr "filter filterEntry >>> head\n"

#. type: Plain text
#: text/chapter3.md:771
msgid ""
"Either way, this gives a clear definition of the `findEntry` function: "
"\"`findEntry` is the composition of a filtering function and the `head` "
"function\"."
msgstr ""
"どちらにしても、これは「`findEntry`は絞り込み関数と`head`関数の合成である」と"
"いう `findEntry`関数のわかりやすい定義を与えます。"

#. type: Plain text
#: text/chapter3.md:773
msgid ""
"I will let you decide which definition is easier to understand, but it is "
"often useful to think of functions as building blocks in this way: each "
"function executes a single task, and solutions are assembled using function "
"composition."
msgstr ""
"どちらの定義のほうが分かりやすいかの判断はお任せしますが、このように関数を部"
"品として捉えるとしばしば有用です。\n"
"各関数は1つの役目をこなすようにし、解法を関数合成を使って組み立てるのです。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:781
msgid ""
"(Easy) Test your understanding of the `findEntry` function by writing down "
"the types of each of its major subexpressions. For example, the type of the "
"`head` function as used is specialized to `AddressBook -> Maybe Entry`. "
"_Note_: There is no test for this exercise."
msgstr ""
"（簡単）`findEntry`関数の定義の主な部分式の型を書き下し、 `findEntry`関数につ"
"いてよく理解しているか試してみましょう。\n"
"例えば`findEntry`の定義の中にある `head`関数の型は `AddressBook -> Maybe "
"Entry`と特殊化されています。\n"
"*補足*：この問題にはテストがありません。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:781
msgid ""
"(Medium) Write a function `findEntryByStreet :: String -> AddressBook -> "
"Maybe Entry` which looks up an `Entry` given a street address. _Hint_ "
"reusing the existing code in `findEntry`. Test your function in PSCi and by "
"running `spago test`."
msgstr ""
"（普通）関数`findEntryByStreet :: String -> AddressBook -> Maybe Entry`を書い"
"てください。\n"
"この関数は与えられた通りの住所から`Entry`を見付け出します。\n"
"*手掛かり*：`findEntry`にある既存のコードを再利用してください。\n"
"実装した関数をPSCiと`spago test`を走らせてテストしてください。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:781
msgid ""
"(Medium) Rewrite `findEntryByStreet` to replace `filterEntry` with the "
"composition (using `<<<` or `>>>`) of: a property accessor (using the `_.` "
"notation); and a function that tests whether its given string argument is "
"equal to the given street address."
msgstr ""
"（普通）`filterEntry`を（`<<<`や`>>>`を使った）合成で置き換えて、"
"`findEntryByStreet`を書き直してください。\n"
"合成の対象は、プロパティ取得子（`_.`記法を使います）と、与えられた文字列引数"
"が与えられた通りの住所に等しいかを判定する関数です。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:781
msgid ""
"(Medium) Write a function `isInBook` that tests whether a name appears in a "
"`AddressBook`, returning a Boolean value. _Hint_: Use PSCi to find the type "
"of the `Data.List.null` function, which tests whether a list is empty or not."
msgstr ""
"（普通）名前が`AddressBook`に存在するかどうかを調べて真偽値で返す関数"
"`isInBook`を書いてみましょう。\n"
"*手掛かり*：PSCiを使って`Data.List.null`関数の型を見付けてください。\n"
"この関数はリストが空かどうかを調べます。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:781
msgid ""
"(Difficult) Write a function `removeDuplicates` which removes \"duplicate\" "
"address book entries. We'll consider entries duplicated if they share the "
"same first and last names, while ignoring `address` fields. _Hint_: Use PSCi "
"to find the type of the `Data.List.nubByEq` function, which removes "
"duplicate elements from a list based on an equality predicate. Note that the "
"first element in each set of duplicates (closest to the list head) is the "
"one that is kept."
msgstr ""
"（難しい）「重複」している住所録の項目を削除する関数`removeDuplicates`を書い"
"てみましょう。\n"
"項目が同じ姓名を共有していれば`address`フィールドに関係なく、項目が重複してい"
"ると考えます。\n"
"*手掛かり*：`Data.List.nubByEq`関数の型をPSCiを使って調べましょう。\n"
"この関数は等価性の述語に基づいてリストから重複要素を削除します。\n"
"なお、それぞれの重複する項目の集合において最初の要素（リストの先頭に最も近"
"い）が保持する項目です。"

#. type: Plain text
#: text/chapter3.md:785
msgid ""
"In this chapter, we covered several new functional programming concepts and "
"learned how to:"
msgstr ""
"この章では関数型プログラミングの新しい概念を幾つか押さえ、以下の方法を学びま"
"した。"

#. type: Bullet: '- '
#: text/chapter3.md:793
msgid ""
"Use the interactive mode PSCi to experiment with functions and test ideas."
msgstr ""
"対話的モードのPSCiを使用して、関数で実験したり思いついたことを試したりする。"

#. type: Bullet: '- '
#: text/chapter3.md:793
msgid "Use types as both a correctness tool and an implementation tool."
msgstr "正確さのための道具として、また実装のための道具として型を使う。"

#. type: Bullet: '- '
#: text/chapter3.md:793
msgid "Use curried functions to represent functions of multiple arguments."
msgstr "多引数の関数を表現するためにカリー化された関数を使う。"

#. type: Bullet: '- '
#: text/chapter3.md:793
msgid "Create programs from smaller components by composition."
msgstr "合成により小さな部品からプログラムを作る。"

#. type: Bullet: '- '
#: text/chapter3.md:793
msgid "Structure code neatly using `where` expressions."
msgstr "`where`式を使ってコードを手際良く構造化する。"

#. type: Bullet: '- '
#: text/chapter3.md:793
msgid "Avoid null values by using the `Maybe` type."
msgstr "`Maybe`型を使用してnull値を回避する。"

#. type: Bullet: '- '
#: text/chapter3.md:793
msgid ""
"Use techniques like eta conversion and function composition to refactor code "
"into a clear specification."
msgstr ""
"イータ変換や関数合成のような技法を使ってより分かりやすい仕様にリファクタす"
"る。"

#. type: Plain text
#: text/chapter3.md:794
msgid "In the following chapters, we'll build on these ideas."
msgstr "次の章からは、これらの考えかたに基づいて進めていきます。"

#. type: Title #
#: text/chapter4.md:1
#, no-wrap
msgid "Recursion, Maps, And Folds"
msgstr "再帰、マップ、畳み込み"

#. type: Plain text
#: text/chapter4.md:6
msgid ""
"In this chapter, we will look at how recursive functions can be used to "
"structure algorithms. Recursion is a basic technique used in functional "
"programming, which we will use throughout this book."
msgstr ""
"この章では、アルゴリズムを構造化するときに再帰関数をどのように使うかについて"
"見ていきましょう。\n"
"再帰は関数型プログラミングの基本的な手法であり、本書全体に<ruby>亙<rp>（</"
"rp><rt>わた</rt><rp>）</rp></ruby>って使われます。"

#. type: Plain text
#: text/chapter4.md:8
msgid ""
"We will also cover some standard functions from PureScript's standard "
"libraries. We will `map`, `fold`, and some useful special cases, like "
"`filter` and `concatMap`."
msgstr ""
"また、PureScriptの標準ライブラリから標準的な関数を幾つか取り扱います。\n"
"`map`や`fold`といった関数だけでなく、`filter`や`concatMap`といった特別な場合"
"において便利なものについても見ていきます。"

#. type: Plain text
#: text/chapter4.md:10
msgid ""
"The motivating example for this chapter is a library of functions for "
"working with a virtual filesystem. We will apply the techniques learned in "
"this chapter to write functions that compute properties of the files "
"represented by a model of a filesystem."
msgstr ""
"この章では、仮想的なファイルシステムを操作する関数のライブラリを動機付けに用"
"います。\n"
"この章で学ぶ技術を応用し、ファイルシステムのモデルにより表現されるファイルの"
"プロパティを計算する関数を書きます。"

#. type: Plain text
#: text/chapter4.md:14
msgid ""
"The source code for this chapter is contained in `src/Data/Path.purs` and "
"`test/Examples.purs`. The `Data.Path` module contains a model of a virtual "
"filesystem. You do not need to modify the contents of this module. Implement "
"your solutions to the exercises in the `Test.MySolutions` module. Enable "
"accompanying tests in the `Test.Main` module as you complete each exercise "
"and check your work by running `spago test`."
msgstr ""
"この章のソースコードは`src/Data/Path.purs`と`test/Examples.purs`に含まれてい"
"ます。\n"
"`Data.Path`モジュールは仮想ファイルシステムのモデルを含みます。\n"
"このモジュールの内容を変更する必要はありません。\n"
"演習への解答は`Test.MySolutions`モジュールに実装してください。\n"
"それぞれの演習を完了させつつ都度`Test.Main`モジュールにある対応するテストを有"
"効にし、`spago test`を走らせることで解答を確認してください。"

#. type: Plain text
#: text/chapter4.md:16 text/chapter6.md:18
msgid "The project has the following dependencies:"
msgstr "このプロジェクトには以下の依存関係があります。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`maybe`, which defines the `Maybe` type constructor"
msgstr "`maybe`: `Maybe`型構築子が定義されています。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`arrays`, which defines functions for working with arrays"
msgstr "`arrays`: 配列を扱うための関数が定義されています。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`strings`, which defines functions for working with JavaScript strings"
msgstr "`strings`: JavaScriptの文字列を扱うための関数が定義されています。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid ""
"`foldable-traversable`, which defines functions for folding arrays and other "
"data structures"
msgstr ""
"`foldable-traversable`: 配列やその他のデータ構造を畳み込む関数が定義されてい"
"ます。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`console`, which defines functions for printing to the console"
msgstr "`console`: コンソールへの出力を扱うための関数が定義されています。"

#. type: Plain text
#: text/chapter4.md:26
msgid ""
"Recursion is an important technique in programming in general, but "
"particularly common in pure functional programming, because, as we will see "
"in this chapter, recursion helps to reduce the mutable state in our programs."
msgstr ""
"再帰は一般のプログラミングでも重要な手法ですが、特に純粋関数型プログラミング"
"では当たり前のように用いられます。この章で見ていくように、再帰はプログラムの"
"変更可能な状態を減らすために役立つからです。"

#. type: Plain text
#: text/chapter4.md:28
msgid ""
"Recursion is closely linked to the _divide and conquer_ strategy: to solve a "
"problem on certain inputs, we can break down the inputs into smaller parts, "
"solve the problem on those parts, and then assemble a solution from the "
"partial solutions."
msgstr ""
"再帰は*分割統治*戦略と密接な関係があります。\n"
"分割統治とはすなわち、何らかの入力としての問題を解くにあたり、入力を小さな部"
"分に分割してそれぞれの部分について問題を解き、部分毎の答えから最終的な答えを"
"組み立てるということです。"

#. type: Plain text
#: text/chapter4.md:30
msgid "Let's see some simple examples of recursion in PureScript."
msgstr "それでは、PureScriptにおける再帰の簡単な例を幾つか見てみましょう。"

#. type: Plain text
#: text/chapter4.md:32
msgid "Here is the usual _factorial function_ example:"
msgstr "次に示すのは*階乗関数*のありふれた例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:33
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorial}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorial}}\n"

#. type: Plain text
#: text/chapter4.md:38
msgid ""
"Here, we can see how the factorial function is computed by reducing the "
"problem to a subproblem – computing the factorial of a smaller integer. When "
"we reach zero, the answer is immediate."
msgstr ""
"このように、問題を部分問題へ分割することによって階乗関数の計算方法が見てとれ"
"ます。\n"
"より小さい数の階乗を計算していくということです。\n"
"ゼロに到達すると、答えは直ちに求まります。"

#. type: Plain text
#: text/chapter4.md:40
msgid "Here is another common example that computes the _Fibonacci function_:"
msgstr "次は、*フィボナッチ関数*を計算するという、これまたよくある例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:41
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:fib}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:fib}}\n"

#. type: Plain text
#: text/chapter4.md:46
msgid ""
"Again, this problem is solved by considering the solutions to subproblems. "
"In this case, there are two subproblems, corresponding to the expressions "
"`fib (n - 1)` and `fib (n - 2)`. When these two subproblems are solved, we "
"assemble the result by adding the partial results."
msgstr ""
"やはり、部分問題の解決策を考えることで全体を解決していることがわかります。\n"
"このとき、`fib (n - 1)`と`fib (n - 2)`という式に対応した、2つの部分問題があり"
"ます。\n"
"これらの2つの部分問題が解決されていれば、この部分的な答えを加算することで、全"
"体の答えを組み立てることができます。"

#. type: Plain text
#: text/chapter4.md:48
#, no-wrap
msgid "> Note that, while the above examples of `factorial` and `fib` work as intended, a more idiomatic implementation would use pattern matching instead of `if`/`then`/`else`. Pattern-matching techniques are discussed in a later chapter.\n"
msgstr ""
"> なお、上の`factorial`と`fib`の例は意図通りに動きますが、よりPureScriptらしい実装では`if`や`then`や`else`を使う代わりにパターン照合を使うものでしょう。\n"
"> パターン照合の技法は後の章でお話しします。\n"

#. type: Title ##
#: text/chapter4.md:49
#, no-wrap
msgid "Recursion on Arrays"
msgstr "配列上での再帰"

#. type: Plain text
#: text/chapter4.md:52
msgid ""
"We are not limited to defining recursive functions over the `Int` type! We "
"will see recursive functions defined over a wide array of data types when we "
"cover _pattern matching_ later in the book, but for now, we will restrict "
"ourselves to numbers and arrays."
msgstr ""
"再帰関数の定義は`Int`型だけに限定されるものではありません。\n"
"本書の後半で*パターン照合*を扱うときに、いろいろなデータ型の上での再帰関数に"
"ついて見ていきますが、ここでは数と配列に限っておきます。"

#. type: Plain text
#: text/chapter4.md:54
msgid ""
"Just as we branch based on whether the input is non-zero, in the array case, "
"we will branch based on whether the input is non-empty. Consider this "
"function, which computes the length of an array using recursion:"
msgstr ""
"入力がゼロでないかどうかについて分岐するのと同じように、配列の場合も、配列が"
"空でないかどうかについて分岐していきます。再帰を使用して配列の長さを計算する"
"次の関数を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:55
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Data.Array (null, tail)\n"
"import Data.Maybe (fromMaybe)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:length}}\n"
msgstr ""
"import Prelude\n"
"\n"
"import Data.Array (null, tail)\n"
"import Data.Maybe (fromMaybe)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:length}}\n"

#. type: Plain text
#: text/chapter4.md:65
msgid ""
"In this function, we use an `if .. then .. else` expression to branch based "
"on the emptiness of the array. The `null` function returns `true` on an "
"empty array. Empty arrays have a length of zero, and a non-empty array has a "
"length that is one more than the length of its tail."
msgstr ""
"この関数では配列が空かどうかで分岐するために`if ... then ... else`式を使って"
"います。\n"
"この`null`関数は空の配列で`true`を返します。\n"
"空の配列の長さはゼロであり、空でない配列の長さは尾鰭の長さより1大きいというわ"
"けです。"

#. type: Plain text
#: text/chapter4.md:67
msgid ""
"The `tail` function returns a `Maybe` wrapping the given array without its "
"first element. If the array is empty (i.e., it doesn't have a tail), "
"`Nothing` is returned. The `fromMaybe` function takes a default value and a "
"`Maybe` value. If the latter is `Nothing` it returns the default; in the "
"other case, it returns the value wrapped by `Just`."
msgstr ""
"`tail`関数は与えられた配列から最初の要素を除いたものを`Maybe`に包んで返しま"
"す。\n"
"配列が空であれば（つまり尾鰭がなければ）`Nothing`が返ります。\n"
"`fromMaybe`関数は既定値と`Maybe`値を取ります。\n"
"後者が`Nothing`であれば既定値を返し、そうでなければ`Just`に包まれた値を返しま"
"す。"

#. type: Plain text
#: text/chapter4.md:69
msgid ""
"This example is a very impractical way to find the length of an array in "
"JavaScript, but it should provide enough help to allow you to complete the "
"following exercises:"
msgstr ""
"JavaScriptで配列の長さを調べるのには、この例はどう見ても実用的な方法とはいえ"
"ませんが、次の演習を完遂するための手掛かりとしては充分でしょう。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:74
msgid ""
"(Easy) Write a recursive function `isEven` that returns `true` if and only "
"if its input is an even integer."
msgstr ""
"（簡単）入力が偶数であるとき、かつそのときに限り`true`に返す再帰関数`isEven`"
"を書いてみましょう。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:74
msgid ""
"(Medium) Write a recursive function `countEven` that counts the number of "
"even integers in an array. _Hint_: the function `head` (also available in "
"`Data.Array`) can be used to find the first element in a non-empty array."
msgstr ""
"（普通）配列内の偶数の整数を数える再帰関数`countEven`を書いてみましょう。\n"
"*手掛かり*：`head`関数（これも`Data.Array`モジュールから手に入ります）を使う"
"と、空でない配列の最初の要素を見つけられます。"

#. type: Title ##
#: text/chapter4.md:75
#, no-wrap
msgid "Maps"
msgstr "マップ"

#. type: Plain text
#: text/chapter4.md:78
msgid ""
"The `map` function is an example of a recursive function on arrays. It is "
"used to transform the elements of an array by applying a function to each "
"element in turn. Therefore, it changes the _contents_ of the array but "
"preserves its _shape_ (i.e., its length)."
msgstr ""
"`map`関数は配列に対する再帰関数の一例です。\n"
"配列の各要素に順番に関数を適用し、配列の要素を変換するのに使われます。\n"
"そのため、配列の*内容*は変更されますが、その*形状*（ここでは「長さ」）は保存"
"されます。"

#. type: Plain text
#: text/chapter4.md:80
msgid ""
"When we cover _type classes_ later in the book, we will see that the `map` "
"function is an example of a more general pattern of shape-preserving "
"functions which transform a class of type constructors called _functors_."
msgstr ""
"本書の後半で*型クラス*の内容を押さえるとき、`map`関数が形状を保存する関数のよ"
"り一般的な様式の一例であることを見ていきます。\n"
"この関数は*関手*と呼ばれる型構築子のクラスを変換するものです。"

#. type: Plain text
#: text/chapter4.md:82
msgid "Let's try out the `map` function in PSCi:"
msgstr "それでは、PSCiで`map`関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:83
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> map (\\n -> n + 1) [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> map (\\n -> n + 1) [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:92
msgid ""
"Notice how `map` is used – we provide a function that should be \"mapped "
"over\" the array in the first argument, and the array itself in its second."
msgstr ""
"`map`がどのように使われているかに注目してください。\n"
"最初の引数には配列上で「写す」関数、第2引数には配列そのものを渡します。"

#. type: Title ##
#: text/chapter4.md:93
#, no-wrap
msgid "Infix Operators"
msgstr "中置演算子"

#. type: Plain text
#: text/chapter4.md:96
msgid ""
"The `map` function can also be written between the mapping function and the "
"array, by wrapping the function name in backticks:"
msgstr ""
"バッククォートで関数名を囲むと、写す関数と配列の間に、`map`関数を書くことがで"
"きます。"

#. type: Fenced code block (text)
#: text/chapter4.md:97
#, no-wrap
msgid ""
"> (\\n -> n + 1) `map` [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"> (\\n -> n + 1) `map` [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:103
msgid ""
"This syntax is called _infix function application_, and any function can be "
"made infix in this way. It is usually most appropriate for functions with "
"two arguments."
msgstr ""
"この構文は _中置関数適用_ と呼ばれ、どんな関数でもこのように中置できます。普"
"通は2引数の関数に対して使うのが最適でしょう。"

#. type: Plain text
#: text/chapter4.md:105
#, no-wrap
msgid "There is an operator which is equivalent to the `map` function when used with arrays, called `<$>`.\n"
msgstr "配列を扱う際は`map`関数と等価な`<$>`という演算子が存在します。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:106
#, no-wrap
msgid ""
"> (\\n -> n + 1) <$> [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"> (\\n -> n + 1) <$> [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:112
msgid "Let's look at the type of `map`:"
msgstr "それでは`map`の型を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:113
#, fuzzy, no-wrap
#| msgid ""
#| "> :type map\n"
#| "forall a b f. Functor f => (a -> b) -> f a -> f b\n"
msgid ""
"> :type map\n"
"forall (f :: Type -> Type) (a :: Type) (b :: Type). Functor f => (a -> b) -> f a -> f b\n"
msgstr ""
"> :type map\n"
"forall a b f. Functor f => (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter4.md:119
msgid ""
"The type of `map` is actually more general than we need in this chapter. For "
"our purposes, we can treat `map` as if it had the following less general "
"type:"
msgstr ""
"実は`map`の型は、この章で必要とされているものよりも一般的な型になっています。"
"今回の目的では、`map`は次のようなもっと具体的な型であるかのように考えるとよい"
"でしょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:120
#, fuzzy, no-wrap
#| msgid "forall a b. (a -> b) -> Array a -> Array b\n"
msgid "forall (a :: Type) (b :: Type). (a -> b) -> Array a -> Array b\n"
msgstr "forall a b. (a -> b) -> Array a -> Array b\n"

#. type: Plain text
#: text/chapter4.md:125
#, no-wrap
msgid "This type says that we can choose any two types, `a` and `b`, with which to apply the `map` function. `a` is the type of elements in the source array, and `b` is the type of elements in the target array. In particular, there is no reason why `map` has to preserve the type of the array elements. We can use `map` or `<$>` to transform integers to strings, for example:\n"
msgstr ""
"この型では、`map`関数に適用するときには`a`と`b`という2つの型を自由に選ぶことができる、ということも示されています。\n"
"`a`は元の配列の要素の型で、`b`は目的の配列の要素の型です。\n"
"もっと言えば、`map`が配列の要素の型を保存する必要があるわけではありません。\n"
"例えば`map`を使用すると数値を文字列に変換できます。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:126
#, no-wrap
msgid ""
"> show <$> [1, 2, 3, 4, 5]\n"
"\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> show <$> [1, 2, 3, 4, 5]\n"
"\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:133
#, no-wrap
msgid "Even though the infix operator `<$>` looks like special syntax, it is in fact just an alias for a regular PureScript function. The function is simply _applied_ using infix syntax. In fact, the function can be used like a regular function by enclosing its name in parentheses. This means that we can use the parenthesized name `(<$>)` in place of `map` on arrays:\n"
msgstr ""
"中置演算子`<$>`は特別な構文のように見えるかもしれませんが、実はPureScriptの普通の関数の別称です。\n"
"中置構文を使用した単なる*適用*にすぎません。\n"
"実際、括弧でその名前を囲むと、この関数を通常の関数のように使用できます。\n"
"これは、`map`代わりに、括弧で囲まれた`(<$>)`という名前が使えるということです。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:134
#, no-wrap
msgid ""
"> (<$>) show [1, 2, 3, 4, 5]\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> (<$>) show [1, 2, 3, 4, 5]\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:140
msgid ""
"Infix function names are defined as _aliases_ for existing function names. "
"For example, the `Data.Array` module defines an infix operator `(..)` as a "
"synonym for the `range` function, as follows:"
msgstr ""
"中置関数は既存の関数名の別称として定義されます。\n"
"例えば`Data.Array`モジュールでは次のように`range`関数の同義語として中置演算子"
"`(..)`を定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:141
#, no-wrap
msgid "infix 8 range as ..\n"
msgstr "infix 8 range as ..\n"

#. type: Plain text
#: text/chapter4.md:146
msgid "We can use this operator as follows:"
msgstr "この演算子は次のように使うことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:147
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> 1 .. 5\n"
"[1, 2, 3, 4, 5]\n"
"\n"
"> show <$> (1 .. 5)\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> 1 .. 5\n"
"[1, 2, 3, 4, 5]\n"
"\n"
"> show <$> (1 .. 5)\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:158
msgid ""
"_Note_: Infix operators can be a great tool for defining domain-specific "
"languages with a natural syntax. However, used excessively, they can render "
"code unreadable to beginners, so it is wise to exercise caution when "
"defining any new operators."
msgstr ""
"*補足*：独自の中置演算子は、自然な構文を備える領域特化言語を定義する上で優れ"
"た手段になりえます。ただし、乱用すると初心者が読めないコードになることがあり"
"ますから、新たな演算子の定義には慎重になるのが賢明です。"

#. type: Plain text
#: text/chapter4.md:160
#, no-wrap
msgid "In the example above, we parenthesized the expression `1 .. 5`, but this was actually not necessary, because the `Data.Array` module assigns a higher precedence level to the `..` operator than that assigned to the `<$>` operator. In the example above, the precedence of the `..` operator was defined as `8`, the number after the `infix` keyword. This is higher than the precedence level of `<$>`, meaning that we do not need to add parentheses:\n"
msgstr ""
"上記の例では、`1 .. 5`という式は括弧で囲まれていましたが、実際にはこれは必要ありません。\n"
"なぜなら、`Data.Array`モジュールは、`<$>`に割り当てられた優先順位より高い優先順位を`..`演算子に割り当てているからです。\n"
"上の例では、`..`の優先順位は、予約語`infix`のあとに書かれた数の`8` と定義されていました。\n"
"ここでは`<$>`の優先順位よりも高い優先順位を`..`に割り当てており、このため括弧を付け加える必要がないということです。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:161
#, no-wrap
msgid ""
"> show <$> 1 .. 5\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> show <$> 1 .. 5\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:167
msgid ""
"If we wanted to assign an _associativity_ (left or right) to an infix "
"operator, we could do so with the `infixl` and `infixr` keywords instead.  "
"Using `infix` assigns no associativity, meaning that you must parenthesize "
"any expression using the same operator multiple times or using multiple "
"operators of the same precedence."
msgstr ""
"中置演算子に（左または右の）*結合性*を与えたい場合は、代わりに予約語`infixl`"
"と`infixr`を使います。`infix`を使うと何ら結合性は割り当てられず、同じ演算子を"
"複数回使ったり複数の同じ優先度の演算子を使ったりするときに、式を括弧で囲まな"
"ければいけなくなります。"

#. type: Title ##
#: text/chapter4.md:168
#, no-wrap
msgid "Filtering Arrays"
msgstr "配列の絞り込み"

#. type: Plain text
#: text/chapter4.md:171
msgid ""
"The `Data.Array` module provides another function `filter`, which is "
"commonly used together with `map`. It provides the ability to create a new "
"array from an existing array, keeping only those elements which match a "
"predicate function."
msgstr ""
"`Data.Array`モジュールでは他にも、よく`map`と一緒に使われる関数`filter`も提供"
"しています。\n"
"この関数は、述語関数に照合する要素のみを残し、既存の配列から新しい配列を作成"
"する機能を提供します。"

#. type: Plain text
#: text/chapter4.md:173
msgid ""
"For example, suppose we wanted to compute an array of all numbers between 1 "
"and 10 which were even. We could do so as follows:"
msgstr ""
"例えば1から10までの数で、偶数であるような数の配列を計算したいとします。\n"
"これは次のようにできます。"

#. type: Fenced code block (text)
#: text/chapter4.md:174
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> filter (\\n -> n `mod` 2 == 0) (1 .. 10)\n"
"[2,4,6,8,10]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> filter (\\n -> n `mod` 2 == 0) (1 .. 10)\n"
"[2,4,6,8,10]\n"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid ""
"(Easy) Write a function `squared` which calculates the squares of an array "
"of numbers. _Hint_: Use the `map` or `<$>` function."
msgstr ""
"（簡単）`map`関数や`<$>`関数を使用して、 配列に格納された数のそれぞれの平方を"
"計算する関数`squared`を書いてみましょう。\n"
"*手掛かり*：`map`や`<$>`といった関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid ""
"(Easy) Write a function `keepNonNegative` which removes the negative numbers "
"from an array of numbers. _Hint_: Use the `filter` function."
msgstr ""
"（簡単）`filter`関数を使用して、数の配列から負の数を取り除く関数"
"`keepNonNegative`を書いてみましょう。\n"
"*手掛かり*：`filter`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid "(Medium)"
msgstr "（普通）"

#. type: Bullet: '    - '
#: text/chapter4.md:189
msgid ""
"Define an infix synonym `<$?>` for `filter`. _Note_: Infix synonyms may not "
"be defined in the REPL, but you can define it in a file."
msgstr ""
"`filter`の中置同義語`<$?>`を定義してください。\n"
"*補足*：中置同義語はREPLでは定義できないかもしれませんが、ファイルでは定義で"
"きます。"

#. type: Bullet: '    - '
#: text/chapter4.md:189
msgid ""
"Write a `keepNonNegativeRewrite` function, which is the same as "
"`keepNonNegative`, but replaces `filter` with your new infix operator `<$?>`."
msgstr ""
"関数`keepNonNegativeRewrite`を書いてください。この関数は`filter`を独自の新し"
"い中置演算子`<$?>`で置き換えたところ以外、`keepNonNegative`と同じです。"

#. type: Bullet: '    - '
#: text/chapter4.md:189
msgid ""
"Experiment with the precedence level and associativity of your operator in "
"PSCi. _Note_: There are no unit tests for this step."
msgstr ""
"PSCiで独自の演算子の優先度合いと結合性を試してください。\n"
"*補足*：この問題のための単体試験はありません。"

#. type: Title ##
#: text/chapter4.md:190
#, no-wrap
msgid "Flattening Arrays"
msgstr "配列の平坦化"

#. type: Plain text
#: text/chapter4.md:193
msgid ""
"Another standard function on arrays is the `concat` function, defined in "
"`Data.Array`. `concat` flattens an array of arrays into a single array:"
msgstr ""
"配列に関する標準的な関数として`Data.Array`で定義されているものには、`concat`"
"関数もあります。`concat`は配列の配列を1つの配列へと平坦化します。"

#. type: Fenced code block (text)
#: text/chapter4.md:194
#, fuzzy, no-wrap
#| msgid ""
#| "> import Data.Array\n"
#| "\n"
#| "> :type concat\n"
#| "forall a. Array (Array a) -> Array a\n"
#| "\n"
#| "> concat [[1, 2, 3], [4, 5], [6]]\n"
#| "[1, 2, 3, 4, 5, 6]\n"
msgid ""
"> import Data.Array\n"
"\n"
"> :type concat\n"
"forall (a :: Type). Array (Array a) -> Array a\n"
"\n"
"> concat [[1, 2, 3], [4, 5], [6]]\n"
"[1, 2, 3, 4, 5, 6]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> :type concat\n"
"forall a. Array (Array a) -> Array a\n"
"\n"
"> concat [[1, 2, 3], [4, 5], [6]]\n"
"[1, 2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:205
msgid ""
"There is a related function called `concatMap` which is a combination of the "
"`concat` and `map` functions. Where `map` takes a function from values to "
"values (possibly of a different type), `concatMap` takes a function from "
"values to arrays of values."
msgstr ""
"関連する関数として、`concat`と`map`を組み合わせた`concatMap`と呼ばれる関数も"
"あります。\n"
"`map`は（相異なる型の可能性がある）値からの値への関数を引数に取りますが、それ"
"に対して`concatMap`は値から値の配列への関数を取ります。"

#. type: Plain text
#: text/chapter4.md:207
msgid "Let's see it in action:"
msgstr "実際に動かして見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:208
#, fuzzy, no-wrap
#| msgid ""
#| "> import Data.Array\n"
#| "\n"
#| "> :type concatMap\n"
#| "forall a b. (a -> Array b) -> Array a -> Array b\n"
#| "\n"
#| "> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
#| "[1,1,2,4,3,9,4,16,5,25]\n"
msgid ""
"> import Data.Array\n"
"\n"
"> :type concatMap\n"
"forall (a :: Type) (b :: Type). (a -> Array b) -> Array a -> Array b\n"
"\n"
"> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
"[1,1,2,4,3,9,4,16,5,25]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> :type concatMap\n"
"forall a b. (a -> Array b) -> Array a -> Array b\n"
"\n"
"> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
"[1,1,2,4,3,9,4,16,5,25]\n"

#. type: Plain text
#: text/chapter4.md:219
#, no-wrap
msgid "Here, we call `concatMap` with the function `\\n -> [n, n * n]` which sends an integer to the array of two elements consisting of that integer and its square. The result is an array of ten integers: the integers from 1 to 5 along with their squares.\n"
msgstr ""
"ここでは、数をその数とその数の平方の2つの要素からなる配列に写す関数`\\n -> [n, n * n]`を引数に`concatMap`を呼び出しています。\n"
"結果は10個の整数の配列です。\n"
"配列は1から5の数とそのそれぞれの数の平方からなります。\n"

#. type: Plain text
#: text/chapter4.md:221
msgid ""
"Note how `concatMap` concatenates its results. It calls the provided "
"function once for each element of the original array, generating an array "
"for each. Finally, it collapses all of those arrays into a single array, "
"which is its result."
msgstr ""
"`concatMap`がどのように結果を連結しているのかに注目してください。渡された関数"
"を元の配列のそれぞれの要素について一度ずつ呼び出し、その関数はそれぞれ配列を"
"生成します。最後にそれらの配列を単一の配列に押し潰したものが結果となります。"

#. type: Plain text
#: text/chapter4.md:223
msgid ""
"`map`, `filter` and `concatMap` form the basis for a whole range of "
"functions over arrays called \"array comprehensions\"."
msgstr ""
"`map`と`filter`、`concatMap`は、「配列内包表記」(array comprehensions) と呼ば"
"れる、配列に関するあらゆる関数の基盤を形成します。"

#. type: Title ##
#: text/chapter4.md:224
#, no-wrap
msgid "Array Comprehensions"
msgstr "配列内包表記"

#. type: Plain text
#: text/chapter4.md:227
msgid ""
"Suppose we wanted to find the factors of a number `n`. One simple way to do "
"this would be by brute force: we could generate all pairs of numbers between "
"1 and `n`, and try multiplying them together. If the product was `n`, we "
"would have found a pair of factors of `n`."
msgstr ""
"数`n`の2つの因数を見つけたいとしましょう。\n"
"こうするための簡単な方法としては、総当りで調べる方法があります。\n"
"つまり、`1`から`n`の数の全ての組み合わせを生成し、それを乗算してみるわけで"
"す。\n"
"もしその積が`n`なら、`n`の因数の組み合わせを見つけたということになります。"

#. type: Plain text
#: text/chapter4.md:229
msgid ""
"We can perform this computation using array comprehension. We will do so in "
"steps, using PSCi as our interactive development environment."
msgstr ""
"配列内包表記を使用するとこれを計算できます。\n"
"PSCiを対話式の開発環境として使用し、1つずつこの手順を進めていきましょう。"

#. type: Plain text
#: text/chapter4.md:231
msgid ""
"The first step is to generate an array of pairs of numbers below `n`, which "
"we can do using `concatMap`."
msgstr ""
"最初の工程では`n`以下の数の組み合わせの配列を生成しますが、これには"
"`concatMap`を使えばよいです。"

#. type: Plain text
#: text/chapter4.md:233
msgid "Let's start by mapping each number to the array `1 .. n`:"
msgstr ""
"`1 .. n`のそれぞれの数を配列`1 .. n`へとマッピングすることから始めましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:234
#, no-wrap
msgid "> pairs n = concatMap (\\i -> 1 .. n) (1 .. n)\n"
msgstr "> pairs n = concatMap (\\i -> 1 .. n) (1 .. n)\n"

#. type: Plain text
#: text/chapter4.md:239
msgid "We can test our function"
msgstr "この関数をテストしてみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:240
#, no-wrap
msgid ""
"> pairs 3\n"
"[1,2,3,1,2,3,1,2,3]\n"
msgstr ""
"> pairs 3\n"
"[1,2,3,1,2,3,1,2,3]\n"

#. type: Plain text
#: text/chapter4.md:246
msgid ""
"This is not quite what we want. Instead of just returning the second element "
"of each pair, we need to map a function over the inner copy of `1 .. n` "
"which will allow us to keep the entire pair:"
msgstr ""
"これは求めているものとは全然違います。\n"
"単にそれぞれの組み合わせの2つ目の要素を返すのではなく、対全体を保持できるよう"
"に、内側の`1 .. n`の複製について関数を対応付ける必要があります。"

#. type: Fenced code block (text)
#: text/chapter4.md:247
#, no-wrap
msgid ""
"> :paste\n"
"… pairs' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (1 .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"\n"
"> pairs' 3\n"
"[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\n"
msgstr ""
"> :paste\n"
"… pairs' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (1 .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"\n"
"> pairs' 3\n"
"[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\n"

#. type: Plain text
#: text/chapter4.md:260
msgid ""
"This is looking better. However, we are generating too many pairs: we keep "
"both [1, 2] and [2, 1] for example. We can exclude the second case by making "
"sure that `j` only ranges from `i` to `n`:"
msgstr ""
"いい感じになってきました。\n"
"しかし、`[1, 2]`と`[2, 1]`の両方があるように、重複した組み合わせが生成されて"
"います。\n"
"`j`を`i`から`n`の範囲に限定することで、2つ目の場合を取り除くことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:261
#, no-wrap
msgid ""
"> :paste\n"
"… pairs'' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (i .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"> pairs'' 3\n"
"[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n"
msgstr ""
"> :paste\n"
"… pairs'' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (i .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"> pairs'' 3\n"
"[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n"

#. type: Plain text
#: text/chapter4.md:273
msgid ""
"Great! Now that we have all of the pairs of potential factors, we can use "
"`filter` to choose the pairs which multiply to give `n`:"
msgstr ""
"すばらしいです。\n"
"因数の候補の全ての組み合わせを手に入れたので、`filter`を使えば、その積が`n`で"
"あるような組み合わせを選び出すことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:274
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> factors n = filter (\\pair -> product pair == n) (pairs'' n)\n"
"\n"
"> factors 10\n"
"[[1,10],[2,5]]\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> factors n = filter (\\pair -> product pair == n) (pairs'' n)\n"
"\n"
"> factors 10\n"
"[[1,10],[2,5]]\n"

#. type: Plain text
#: text/chapter4.md:284
msgid ""
"This code uses the `product` function from the `Data.Foldable` module in the "
"`foldable-traversable` library."
msgstr ""
"このコードでは、`foldable-traversable`ライブラリの`Data.Foldable`モジュールに"
"ある`product`関数を使っています。"

#. type: Plain text
#: text/chapter4.md:286
msgid ""
"Excellent! We've managed to find the correct set of factor pairs without "
"duplicates."
msgstr ""
"うまくいきました。\n"
"因数の組み合わせの正しい集合を重複なく見つけることができました。"

#. type: Title ##
#: text/chapter4.md:287
#, no-wrap
msgid "Do Notation"
msgstr "do記法"

#. type: Plain text
#: text/chapter4.md:290
msgid ""
"However, we can improve the readability of our code considerably. `map` and "
"`concatMap` are so fundamental, that they (or rather, their generalizations "
"`map` and `bind`) form the basis of a special syntax called _do notation_."
msgstr ""
"しかし、このコードの可読性は大幅に向上できます。`map`や`concatMap`は基本的な"
"関数であり、 _do記法_ (do notation) と呼ばれる特別な構文の基礎になっています"
"（もっと厳密にいえば、それらの一般化である`map`と`bind`が基礎をなしていま"
"す）。"

#. type: Plain text
#: text/chapter4.md:292
#, no-wrap
msgid "> _Note_: Just like `map` and `concatMap` allowed us to write _array comprehensions_, the more general operators `map` and `bind` allow us to write so-called _monad comprehensions_. We'll see plenty more examples of _monads_ later in the book, but in this chapter, we will only consider arrays.\n"
msgstr ""
"> *補足*：`map`と`concatMap`があることで*配列内包表記*を書けるように、もっと一般的な演算子である`map`と`bind`があることで*モナド内包表記*と呼ばれているものが書けます。\n"
"> 本書の後半では*モナド*の例をたっぷり見ていくことになりますが、この章では配列のみを考えます。\n"

#. type: Plain text
#: text/chapter4.md:294
msgid "We can rewrite our `factors` function using do notation as follows:"
msgstr ""
"do記法を使うと、先ほどの`factors`関数を次のように書き直すことができます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:295
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factors}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factors}}\n"

#. type: Plain text
#: text/chapter4.md:300
msgid ""
"The keyword `do` introduces a block of code that uses do notation. The block "
"consists of expressions of a few types:"
msgstr ""
"キーワード`do`はdo記法を使うコードのブロックを導入します。\n"
"このブロックは幾つかの種類の式で構成されています。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid ""
"Expressions that bind elements of an array to a name. These are indicated "
"with the backwards-facing arrow `<-`, with a name on the left, and an "
"expression on the right whose type is an array."
msgstr ""
"配列の要素を名前に束縛する式。\n"
"これは後ろ向きの矢印`<-`で示されており、左側には名前が、右側には配列の型を持"
"つ式があります。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid ""
"Expressions that do not bind elements of the array to names. The `do` "
"_result_ is an example of this kind of expression and is illustrated in the "
"last line, `pure [i, j]`."
msgstr ""
"名前に配列の要素を束縛しない式。\n"
"`do`の*結果*はこの種類の式の一例であり、最後の行の`pure [i, j]`に示されていま"
"す。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid "Expressions that give names to expressions, using the `let` keyword."
msgstr "`let`キーワードを使用し、式に名前を与える式。"

#. type: Plain text
#: text/chapter4.md:306
#, no-wrap
msgid "This new notation hopefully makes the structure of the algorithm clearer. If you mentally replace the arrow `<-` with the word \"choose\", you might read it as follows: \"choose an element `i` between 1 and n, then choose an element `j` between `i` and `n`, and return `[i, j]`\".\n"
msgstr ""
"この新しい記法を使うと、アルゴリズムの構造がわかりやすくなることがあります。\n"
"頭の中で`<-`を「選ぶ」という単語に置き換えるとすると、「1からnの間の要素`i`を選び、それからiからnの間の要素`j`を選び、`[i, j]`を返す」というように読むことができるでしょう。\n"

#. type: Plain text
#: text/chapter4.md:308
msgid ""
"In the last line, we use the `pure` function. This function can be evaluated "
"in PSCi, but we have to provide a type:"
msgstr ""
"最後の行では、`pure`関数を使っています。この関数はPSCiで評価できますが、型を"
"明示する必要があります。"

#. type: Fenced code block (text)
#: text/chapter4.md:309
#, no-wrap
msgid ""
"> pure [1, 2] :: Array (Array Int)\n"
"[[1, 2]]\n"
msgstr ""
"> pure [1, 2] :: Array (Array Int)\n"
"[[1, 2]]\n"

#. type: Plain text
#: text/chapter4.md:315
msgid ""
"In the case of arrays, `pure` simply constructs a singleton array. We can "
"modify our `factors` function to use this form, instead of using `pure`:"
msgstr ""
"配列の場合、`pure`は単に1要素の配列を作成します。\n"
"`factors`関数を変更して、`pure`の代わりにこの形式も使うようにできます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:316
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorsV2}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorsV2}}\n"

#. type: Plain text
#: text/chapter4.md:321
msgid "and the result would be the same."
msgstr "そして、結果は同じになります。"

#. type: Title ##
#: text/chapter4.md:322 text/chapter5.md:77
#, no-wrap
msgid "Guards"
msgstr "ガード"

#. type: Plain text
#: text/chapter4.md:325
msgid ""
"One further change we can make to the `factors` function is to move the "
"filter inside the array comprehension. This is possible using the `guard` "
"function from the `Control.Alternative` module (from the `control` package):"
msgstr ""
"`factors`関数を更に改良する方法としては、このフィルタを配列内包表記の内側に移"
"動するというものがあります。\n"
"これは`control`ライブラリにある`Control.Alternative`モジュールの`guard`関数を"
"使用することで可能になります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:326
#, no-wrap
msgid ""
"import Control.Alternative (guard)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:factorsV3}}\n"
msgstr ""
"import Control.Alternative (guard)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:factorsV3}}\n"

#. type: Plain text
#: text/chapter4.md:333
msgid ""
"Just like `pure`, we can apply the `guard` function in PSCi to understand "
"how it works. The type of the `guard` function is more general than we need "
"here:"
msgstr ""
"`pure`と同じように、どのように動作するかを理解するために、PSCiで`guard`関数を"
"適用して調べてみましょう。\n"
"`guard`関数の型は、ここで必要とされるものよりもっと一般的な型になっています。"

#. type: Fenced code block (text)
#: text/chapter4.md:334
#, fuzzy, no-wrap
#| msgid ""
#| "> import Control.Alternative\n"
#| "\n"
#| "> :type guard\n"
#| "forall m. Alternative m => Boolean -> m Unit\n"
msgid ""
"> import Control.Alternative\n"
"\n"
"> :type guard\n"
"forall (m :: Type -> Type). Alternative m => Boolean -> m Unit\n"
msgstr ""
"> import Control.Alternative\n"
"\n"
"> :type guard\n"
"forall m. Alternative m => Boolean -> m Unit\n"

#. type: Plain text
#: text/chapter4.md:342
msgid "In our case, we can assume that PSCi reported the following type:"
msgstr "今回の場合は、PSCiは次の型を報告するものと考えてください。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:343
#, no-wrap
msgid "Boolean -> Array Unit\n"
msgstr "Boolean -> Array Unit\n"

#. type: Plain text
#: text/chapter4.md:348
msgid ""
"For our purposes, the following calculations tell us everything we need to "
"know about the `guard` function on arrays:"
msgstr ""
"目的からすると、次の計算の結果から配列における`guard`関数について今知りたいこ"
"とは全てわかります。"

#. type: Fenced code block (text)
#: text/chapter4.md:349
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> length $ guard true\n"
"1\n"
"\n"
"> length $ guard false\n"
"0\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> length $ guard true\n"
"1\n"
"\n"
"> length $ guard false\n"
"0\n"

#. type: Plain text
#: text/chapter4.md:360
msgid ""
"If we pass an expression to `guard` that evaluates to `true`, then it "
"returns an array with a single element. If the expression evaluates to "
"`false`, then its result is empty."
msgstr ""
"つまり、`guard`が`true`に評価される式を渡された場合、単一の要素を持つ配列を返"
"すのです。\n"
"もし式が`false`と評価された場合は、その結果は空です。"

#. type: Plain text
#: text/chapter4.md:362
msgid ""
"This means that if the guard fails, then the current branch of the array "
"comprehension will terminate early with no results. This means that a call "
"to `guard` is equivalent to using `filter` on the intermediate array. "
"Depending on the application, you might prefer to use `guard` instead of a "
"`filter`. Try the two definitions of `factors` to verify that they give the "
"same results."
msgstr ""
"ガードが失敗した場合、配列内包表記の現在の分岐は、結果なしで早めに終了される"
"ことを意味します。\n"
"これは、`guard`の呼び出しが、途中の配列に対して`filter`を使用するのと同じだと"
"いうことです。\n"
"実践の場面にもよりますが、`filter`の代わりに`guard`を使いたいことは多いでしょ"
"う。\n"
"これらが同じ結果になることを確認するために、`factors`の2つの定義を試してみて"
"ください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Easy) Write a function `isPrime`, which tests whether its integer argument "
"is prime. _Hint_: Use the `factors` function."
msgstr ""
"（簡単）関数`isPrime`を書いてください。\n"
"この関数は整数の引数が素数であるかを調べます。\n"
"*手掛かり*：`factors`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Medium) Write a function `cartesianProduct` which uses do notation to find "
"the _cartesian product_ of two arrays, i.e., the set of all pairs of "
"elements `a`, `b`, where `a` is an element of the first array, and `b` is an "
"element of the second."
msgstr ""
"（普通）do記法を使い、2つの配列の*直積集合*を見つけるための関数"
"`cartesianProduct`を書いてみましょう。\n"
"直積集合とは、要素`a`、`b`の全ての組み合わせの集合のことです。\n"
"ここで`a`は最初の配列の要素、`b`は2つ目の配列の要素です。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Medium) Write a function `triples :: Int -> Array (Array Int)`, which takes "
"a number `n` and returns all Pythagorean triples whose components (the `a`, "
"`b`, and `c` values) are each less than or equal to `n`. A _Pythagorean "
"triple_ is an array of numbers `[a, b, c]` such that `a² + b² = c²`. _Hint_: "
"Use the `guard` function in an array comprehension."
msgstr ""
"（普通）関数`triples :: Int -> Array (Array Int)`を書いてください。\n"
"この関数は数値`n`を取り、構成要素（値`a`、`b`、`c`）がそれぞれ`n`以下であるよ"
"うな全てのピタゴラスの3つ組 (pythagorean triples) を返します。\n"
"*ピタゴラスの3つ組*は`a² + b² = c²`であるような数値の配列`[a, b, c]`です。\n"
"*手掛かり*：配列内包表記で`guard`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Difficult) Write a function `primeFactors` which produces the [prime "
"factorization](https://www.mathsisfun.com/prime-factorization.html) of `n`, "
"i.e., the array of prime integers whose product is `n`. _Hint_: for an "
"integer greater than 1, break the problem into two subproblems: finding the "
"first factor and the remaining factors."
msgstr ""
"（難しい）`factors`関数を使用して、`n`の[素因数分解](https://www.mathsisfun."
"com/prime-factorization.html)を求める関数`primeFactors`を定義してみましょ"
"う。\n"
"`n`の素因数分解とは、積が`n`であるような素数の配列のことです。\n"
"*手掛かり*：1より大きい整数について、問題を2つの部分問題に分解してくださ"
"い。\n"
"最初の因数を探し、それから残りの因数を探すのです。"

#. type: Title ##
#: text/chapter4.md:370
#, no-wrap
msgid "Folds"
msgstr "畳み込み"

#. type: Plain text
#: text/chapter4.md:373
msgid ""
"Left and right folds over arrays provide another class of interesting "
"functions that can be implemented using recursion."
msgstr ""
"配列における左右の畳み込みは、再帰を用いて実装できる別の興味深い一揃いの関数"
"を提供します。"

#. type: Plain text
#: text/chapter4.md:375
msgid ""
"Start by importing the `Data.Foldable` module and inspecting the types of "
"the `foldl` and `foldr` functions using PSCi:"
msgstr ""
"PSCiを使って、`Data.Foldable`モジュールをインポートし、`foldl`と`foldr`関数の"
"型を調べることから始めましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:376
#, fuzzy, no-wrap
#| msgid ""
#| "> import Data.Foldable\n"
#| "\n"
#| "> :type foldl\n"
#| "forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b\n"
#| "\n"
#| "> :type foldr\n"
#| "forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b\n"
msgid ""
"> import Data.Foldable\n"
"\n"
"> :type foldl\n"
"forall (f :: Type -> Type) (a :: Type) (b :: Type). Foldable f => (b -> a -> b) -> b -> f a -> b\n"
"\n"
"> :type foldr\n"
"forall (f :: Type -> Type) (a :: Type) (b :: Type). Foldable f => (a -> b -> b) -> b -> f a -> b\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> :type foldl\n"
"forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b\n"
"\n"
"> :type foldr\n"
"forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b\n"

#. type: Plain text
#: text/chapter4.md:387
#, fuzzy
#| msgid ""
#| "These types are more general than we are interested in right now. For "
#| "this chapter, we can assume that PSCi has given the following (more "
#| "specific) answer:"
msgid ""
"These types are more general than we are interested in right now. For this "
"chapter, we can simplify and assume the following (more specific) type "
"signatures:"
msgstr ""
"これらの型は、現在興味があるものよりも一般化されています。\n"
"この章では、PSCiは以下の（より具体的な）答えをくれていると考えておきましょ"
"う。"

#. type: Fenced code block (text)
#: text/chapter4.md:388
#, fuzzy, no-wrap
#| msgid ""
#| "> :type foldl\n"
#| "forall a b. (b -> a -> b) -> b -> Array a -> b\n"
#| "\n"
#| "> :type foldr\n"
#| "forall a b. (a -> b -> b) -> b -> Array a -> b\n"
msgid ""
"-- foldl\n"
"forall a b. (b -> a -> b) -> b -> Array a -> b\n"
"\n"
"-- foldr\n"
"forall a b. (a -> b -> b) -> b -> Array a -> b\n"
msgstr ""
"> :type foldl\n"
"forall a b. (b -> a -> b) -> b -> Array a -> b\n"
"\n"
"> :type foldr\n"
"forall a b. (a -> b -> b) -> b -> Array a -> b\n"

#. type: Plain text
#: text/chapter4.md:397
msgid ""
"In both cases, the type `a` corresponds to the type of elements of our "
"array. The type `b` can be thought of as the type of an \"accumulator\", "
"which will accumulate a result as we traverse the array."
msgstr ""
"どちらの場合でも、型`a`は配列の要素の型に対応しています。\n"
"型`b`は「累算器」の型として考えることができます。\n"
"累算器とは配列を走査しつつ結果を累算するものです。"

#. type: Plain text
#: text/chapter4.md:399
msgid ""
"The difference between the `foldl` and `foldr` functions is the direction of "
"the traversal. `foldl` folds the array \"from the left\", whereas `foldr` "
"folds the array \"from the right\"."
msgstr ""
"`foldl`関数と`foldr`関数の違いは走査の方向です。\n"
"`foldr`が「右から」配列を畳み込むのに対して、`foldl`は「左から」配列を畳み込"
"みます。"

#. type: Plain text
#: text/chapter4.md:401
#, no-wrap
msgid "Let's see these functions in action. Let's use `foldl` to sum an array of integers. The type `a` will be `Int`, and we can also choose the result type `b` to be `Int`. We need to provide three arguments: a function `Int -> Int -> Int`, which will add the next element to the accumulator, an initial value for the accumulator of type `Int`, and an array of `Int`s to add. For the first argument, we can use the addition operator, and the initial value of the accumulator will be zero:\n"
msgstr ""
"実際にこれらの関数の動きを見てみましょう。\n"
"`foldl`を使用して数の配列の和を求めてみます。\n"
"型`a`は`Int`になり、結果の型`b`も`Int`として選択できます。\n"
"ここでは3つの引数を与える必要があります。\n"
"1つ目は次の要素を累算器に加算する`Int -> Int -> Int`という型の関数です。\n"
"2つ目は累算器の`Int`型の初期値です。\n"
"3つ目は和を求めたい`Int`の配列です。\n"
"最初の引数としては、加算演算子を使用できますし、累算器の初期値はゼロになります。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:402
#, no-wrap
msgid ""
"> foldl (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""
"> foldl (+) 0 (1 .. 5)\n"
"15\n"

#. type: Plain text
#: text/chapter4.md:408
msgid ""
"In this case, it didn't matter whether we used `foldl` or `foldr`, because "
"the result is the same, no matter what order the additions happen in:"
msgstr ""
"この場合では、引数が逆になっていても`(+)`関数は同じ結果を返すので、`foldl`と"
"`foldr`のどちらでも問題ありません。"

#. type: Fenced code block (text)
#: text/chapter4.md:409
#, no-wrap
msgid ""
"> foldr (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""
"> foldr (+) 0 (1 .. 5)\n"
"15\n"

#. type: Plain text
#: text/chapter4.md:415
msgid ""
"Let's write an example where the choice of folding function matters to "
"illustrate the difference. Instead of the addition function, let's use "
"string concatenation to build a string:"
msgstr ""
"違いを説明するために、畳み込み関数の選択が大事になってくる例も書きましょ"
"う。\n"
"加算関数の代わりに、文字列連結を使用して文字列を構築しましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:416
#, no-wrap
msgid ""
"> foldl (\\acc n -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"12345\"\n"
"\n"
"> foldr (\\n acc -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"54321\"\n"
msgstr ""
"> foldl (\\acc n -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"12345\"\n"
"\n"
"> foldr (\\n acc -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"54321\"\n"

#. type: Plain text
#: text/chapter4.md:425
msgid ""
"This illustrates the difference between the two functions. The left fold "
"expression is equivalent to the following application:"
msgstr ""
"これは、2つの関数の違いを示しています。左畳み込み式は、以下の関数適用と同等で"
"す。"

#. type: Fenced code block (text)
#: text/chapter4.md:426
#, no-wrap
msgid "(((((\"\" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)\n"
msgstr "(((((\"\" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)\n"

#. type: Plain text
#: text/chapter4.md:431
msgid "Whereas the right fold is equivalent to this:"
msgstr "それに対し、右畳み込みは以下と等価です。"

#. type: Fenced code block (text)
#: text/chapter4.md:432
#, no-wrap
msgid "(((((\"\" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)\n"
msgstr "(((((\"\" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)\n"

#. type: Title ##
#: text/chapter4.md:436
#, no-wrap
msgid "Tail Recursion"
msgstr "末尾再帰"

#. type: Plain text
#: text/chapter4.md:439
msgid ""
"Recursion is a powerful technique for specifying algorithms but comes with a "
"problem: evaluating recursive functions in JavaScript can lead to stack "
"overflow errors if our inputs are too large."
msgstr ""
"再帰はアルゴリズムを指定する強力な手法ですが、問題も抱えています。\n"
"JavaScriptで再帰関数を評価するとき、入力が大き過ぎるとスタックオーバーフロー"
"でエラーを起こす可能性があるのです。"

#. type: Plain text
#: text/chapter4.md:441
msgid "It is easy to verify this problem with the following code in PSCi:"
msgstr "PSCiで次のコードを入力すると、この問題を簡単に検証できます。"

#. type: Fenced code block (text)
#: text/chapter4.md:442
#, no-wrap
msgid ""
"> :paste\n"
"… f n =\n"
"…   if n == 0\n"
"…     then 0\n"
"…     else 1 + f (n - 1)\n"
"… ^D\n"
"\n"
"> f 10\n"
"10\n"
"\n"
"> f 100000\n"
"RangeError: Maximum call stack size exceeded\n"
msgstr ""
"> :paste\n"
"… f n =\n"
"…   if n == 0\n"
"…     then 0\n"
"…     else 1 + f (n - 1)\n"
"… ^D\n"
"\n"
"> f 10\n"
"10\n"
"\n"
"> f 100000\n"
"RangeError: Maximum call stack size exceeded\n"

#. type: Plain text
#: text/chapter4.md:458
msgid ""
"This is a problem. If we adopt recursion as a standard technique from "
"functional programming, we need a way to deal with possibly unbounded "
"recursion."
msgstr ""
"これは問題です。\n"
"関数型プログラミングの標準的な手法として再帰を採用しようとするなら、境界がな"
"い再帰がありうるときでも扱える方法が必要です。"

#. type: Plain text
#: text/chapter4.md:460
msgid ""
"PureScript provides a partial solution to this problem through _tail "
"recursion optimization_."
msgstr ""
"PureScriptは*末尾再帰最適化*の形でこの問題に対する部分的な解決策を提供してい"
"ます。"

#. type: Plain text
#: text/chapter4.md:462
#, no-wrap
msgid "> _Note_: more complete solutions to the problem can be implemented in libraries using so-called _trampolining_, but that is beyond the scope of this chapter. The interested reader can consult the documentation for the [`free`](https://pursuit.purescript.org/packages/purescript-free) and [`tailrec`](https://pursuit.purescript.org/packages/purescript-tailrec) packages.\n"
msgstr ""
"> *補足*：この問題へのより完全な解決策としては、いわゆる*トランポリン*を使用するライブラリで実装できますが、それはこの章で扱う範囲を超えています。\n"
"> 興味のある読者は[`free`](https://pursuit.purescript.org/packages/purescript-free)や[`tailrec`](https://pursuit.purescript.org/packages/purescript-tailrec)パッケージのドキュメントをあたると良いでしょう。\n"

#. type: Plain text
#: text/chapter4.md:464
msgid ""
"The key observation that enables tail recursion optimization: a recursive "
"call in _tail position_ to a function can be replaced with a _jump_, which "
"does not allocate a stack frame. A call is in _tail position_ when it is the "
"last call made before a function returns. This is why we observed a stack "
"overflow in the example – the recursive call to `f` was _not_ in tail "
"position."
msgstr ""
"末尾再帰最適化を可能にする上で鍵となる観点は以下となります。\n"
"*末尾位置*にある関数の再帰的な呼び出しは*ジャンプ*に置き換えられます。\n"
"このジャンプではスタックフレームが確保されません。\n"
"関数が戻るより前の最後の呼び出しであるとき、呼び出しが*末尾位置*にあるといい"
"ます。\n"
"なぜ先の例でスタックオーバーフローが見られたのかはこれが理由です。\n"
"`f`の再帰呼び出しが末尾位置*でなかったからです。"

#. type: Plain text
#: text/chapter4.md:466
msgid ""
"In practice, the PureScript compiler does not replace the recursive call "
"with a jump, but rather replaces the entire recursive function with a _while "
"loop_."
msgstr ""
"実際には、PureScriptコンパイラは再帰呼び出しをジャンプに置き換えるのではな"
"く、再帰的な関数全体を _whileループ_ に置き換えます。"

#. type: Plain text
#: text/chapter4.md:468
msgid ""
"Here is an example of a recursive function with all recursive calls in tail "
"position:"
msgstr "以下は全ての再帰呼び出しが末尾位置にある再帰関数の例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:469
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorialTailRec}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorialTailRec}}\n"

#. type: Plain text
#: text/chapter4.md:474
msgid ""
"Notice that the recursive call to `factorialTailRec` is the last thing in "
"this function – it is in tail position."
msgstr ""
"`factorialTailRec`への再帰呼び出しがこの関数の最後にある点に注目してくださ"
"い。\n"
"つまり末尾位置にあるのです。"

#. type: Title ##
#: text/chapter4.md:475
#, no-wrap
msgid "Accumulators"
msgstr "累算器"

#. type: Plain text
#: text/chapter4.md:478
msgid ""
"One common way to turn a not tail recursive function into a tail recursive "
"is to use an _accumulator parameter_. An accumulator parameter is an "
"additional parameter added to a function that _accumulates_ a return value, "
"as opposed to using the return value to accumulate the result."
msgstr ""
"末尾再帰ではない関数を末尾再帰関数に変える一般的な方法は、*累算器引数*を使用"
"することです。\n"
"累算器引数は関数に追加される余剰の引数で、返り値を*累算*するものです。\n"
"これは結果を累算するために返り値を使うのとは対照的です。"

#. type: Plain text
#: text/chapter4.md:480
msgid ""
"For example, consider again the `length` function presented at the beginning "
"of the chapter:"
msgstr "例えば章の初めに示した`length`関数を再考しましょう。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:481
#, no-wrap
msgid ""
"length :: forall a. Array a -> Int\n"
"length arr =\n"
"  if null arr\n"
"    then 0\n"
"    else 1 + (length $ fromMaybe [] $ tail arr)\n"
msgstr ""
"length :: forall a. Array a -> Int\n"
"length arr =\n"
"  if null arr\n"
"    then 0\n"
"    else 1 + (length $ fromMaybe [] $ tail arr)\n"

#. type: Plain text
#: text/chapter4.md:490
msgid ""
"This implementation is not tail recursive, so the generated JavaScript will "
"cause a stack overflow when executed on a large input array. However, we can "
"make it tail recursive, by introducing a second function argument to "
"accumulate the result instead:"
msgstr ""
"この実装は末尾再帰ではないので、大きな入力配列に対して実行されると、生成され"
"たJavaScriptはスタックオーバーフローを発生させるでしょう。\n"
"しかし代わりに、結果を蓄積するための2つ目の引数を関数に導入することで、これを"
"末尾再帰に変えることができます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:491
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:lengthTailRec}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:lengthTailRec}}\n"

#. type: Plain text
#: text/chapter4.md:496
msgid ""
"In this case, we delegate to the helper function `length'`, which is tail "
"recursive – its only recursive call is in the last case, in tail position. "
"This means that the generated code will be a _while loop_ and not blow the "
"stack for large inputs."
msgstr ""
"ここでは補助関数`length'`に委譲しています。\n"
"この関数は末尾再帰です。\n"
"その唯一の再帰呼び出しは、最後の場合の末尾位置にあります。\n"
"つまり、生成されるコードは*whileループ*となり、大きな入力でもスタックが溢れま"
"せん。"

#. type: Plain text
#: text/chapter4.md:498
msgid ""
"To understand the implementation of `lengthTailRec`, note that the helper "
"function `length'` essentially uses the accumulator parameter to maintain an "
"additional piece of state – the partial result. It starts at 0 and grows by "
"adding 1 for every element in the input array."
msgstr ""
"`lengthTailRec`の実装を理解する上では、補助関数`length'`が基本的に累算器引数"
"を使って追加の状態を保持していることに注目してください。\n"
"追加の状態とは、部分的な結果です。\n"
"0から始まり、入力の配列中の全ての各要素について1ずつ足されて大きくなっていき"
"ます。"

#. type: Plain text
#: text/chapter4.md:500
msgid ""
"Note also that while we might think of the accumulator as a \"state\", there "
"is no direct mutation."
msgstr ""
"なお、累算器を「状態」と考えることもできますが、直接には変更されていません。"

#. type: Title ##
#: text/chapter4.md:501
#, no-wrap
msgid "Prefer Folds to Explicit Recursion"
msgstr "明示的な再帰より畳み込みを選ぼう"

#. type: Plain text
#: text/chapter4.md:504
msgid ""
"If we can write our recursive functions using tail recursion, we can benefit "
"from tail recursion optimization, so it becomes tempting to try to write all "
"of our functions in this form. However, it is often easy to forget that many "
"functions can be written directly as a fold over an array or similar data "
"structure. Writing algorithms directly in terms of combinators such as `map` "
"and `fold` has the added advantage of code simplicity – these combinators "
"are well-understood, and as such, communicate the _intent_ of the algorithm "
"much better than explicit recursion."
msgstr ""
"末尾再帰を使用して再帰関数を記述できれば末尾再帰最適化の恩恵を受けられるの"
"で、全ての関数をこの形で書こうとする誘惑にかられます。\n"
"しかし、多くの関数は配列やそれに似たデータ構造に対する折り畳みとして直接書く"
"ことができることを忘れがちです。\n"
"`map`や`fold`のような組み合わせの部品を使って直接アルゴリズムを書くことには、"
"コードの単純さという利点があります。\n"
"これらの部品はよく知られており、だからこそ明示的な再帰よりもアルゴリズムの*意"
"図*がより良く伝わるのです。"

#. type: Plain text
#: text/chapter4.md:506
msgid "For example, we can reverse an array using `foldr`:"
msgstr "例えば`foldr`を使って配列を反転できます。"

#. type: Fenced code block (text)
#: text/chapter4.md:507
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> :paste\n"
"… reverse :: forall a. Array a -> Array a\n"
"… reverse = foldr (\\x xs -> xs <> [x]) []\n"
"… ^D\n"
"\n"
"> reverse [1, 2, 3]\n"
"[3,2,1]\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> :paste\n"
"… reverse :: forall a. Array a -> Array a\n"
"… reverse = foldr (\\x xs -> xs <> [x]) []\n"
"… ^D\n"
"\n"
"> reverse [1, 2, 3]\n"
"[3,2,1]\n"

#. type: Plain text
#: text/chapter4.md:520
msgid ""
"Writing `reverse` in terms of `foldl` will be left as an exercise for the "
"reader."
msgstr ""
"`foldl`を使って`reverse`を書くことは、読者への課題として残しておきます。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:527
msgid ""
"(Easy) Write a function `allTrue` which uses `foldl` to test whether an "
"array of boolean values are all true."
msgstr ""
"（簡単）`foldl`を使って真偽値配列の値が全て真か検査する関数`allTrue`を書いて"
"ください。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:527
msgid ""
"(Medium - No Test) Characterize those arrays `xs` for which the function "
"`foldl (==) false xs` returns `true`. In other words, complete the sentence: "
"\"The function returns `true` when `xs` contains ...\""
msgstr ""
"（普通。テストなし）関数`foldl (==) false xs`が真を返すような配列`xs`とはどの"
"ようなものか説明してください。\n"
"言い換えると、「関数は`xs`が……を含むときに`true`を返す」という文を完成させる"
"ことになります。"

#. type: Bullet: ' 3. '
#: text/chapter4.md:527
msgid ""
"(Medium) Write a function `fibTailRec` which is the same as `fib` but in "
"tail recursive form. _Hint_: Use an accumulator parameter."
msgstr ""
"（普通）末尾再帰の形式を取っていること以外は`fib`と同じような関数`fibTailRec`"
"を書いてください。\n"
"*手掛かり*：累算器引数を使ってください。"

#. type: Bullet: ' 4. '
#: text/chapter4.md:527
msgid "(Medium) Write `reverse` in terms of `foldl`."
msgstr "（普通）`foldl`を使って`reverse`を書いてみましょう。"

#. type: Title ##
#: text/chapter4.md:528
#, no-wrap
msgid "A Virtual Filesystem"
msgstr "仮想ファイルシステム"

#. type: Plain text
#: text/chapter4.md:531
msgid ""
"In this section, we'll apply what we've learned, writing functions that will "
"work with a model of a filesystem. We will use maps, folds, and filters to "
"work with a predefined API."
msgstr ""
"この節ではこれまで学んだことを応用してファイルシステムのモデルを扱う関数を書"
"きます。\n"
"事前に定義されたAPIを扱う上でマップ、畳み込み、及びフィルタを使用します。"

#. type: Plain text
#: text/chapter4.md:533
msgid ""
"The `Data.Path` module defines an API for a virtual filesystem as follows:"
msgstr ""
"`Data.Path`モジュールでは、次のように仮想ファイルシステムのAPIが定義されてい"
"ます。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "There is a type `Path` which represents a path in the filesystem."
msgstr "ファイルシステム内のパスを表す型`Path`があります。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "There is a path `root` which represents the root directory."
msgstr "ルートディレクトリを表すパス`root`があります。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "The `ls` function enumerates the files in a directory."
msgstr "`ls`関数はディレクトリ内のファイルを列挙します。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "The `filename` function returns the file name for a `Path`."
msgstr "`filename`関数は`Path`のファイル名を返します。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid ""
"The `size` function returns the file size for a `Path` representing a file."
msgstr "`size`関数はファイルを表す`Path`のファイルの大きさを返します。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid ""
"The `isDirectory` function tests whether a `Path` is a file or a directory."
msgstr "`isDirectory`関数はファイルかディレクトリかを調べます。"

#. type: Plain text
#: text/chapter4.md:542
msgid "In terms of types, we have the following type definitions:"
msgstr "型について言うと、次のような型定義があります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:543
#, no-wrap
msgid ""
"root :: Path\n"
"\n"
"ls :: Path -> Array Path\n"
"\n"
"filename :: Path -> String\n"
"\n"
"size :: Path -> Maybe Int\n"
"\n"
"isDirectory :: Path -> Boolean\n"
msgstr ""
"root :: Path\n"
"\n"
"ls :: Path -> Array Path\n"
"\n"
"filename :: Path -> String\n"
"\n"
"size :: Path -> Maybe Int\n"
"\n"
"isDirectory :: Path -> Boolean\n"

#. type: Plain text
#: text/chapter4.md:556
msgid "We can try out the API in PSCi:"
msgstr "PSCiでこのAPIを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:557
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Path\n"
"\n"
"> root\n"
"/\n"
"\n"
"> isDirectory root\n"
"true\n"
"\n"
"> ls root\n"
"[/bin/,/etc/,/home/]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.Path\n"
"\n"
"> root\n"
"/\n"
"\n"
"> isDirectory root\n"
"true\n"
"\n"
"> ls root\n"
"[/bin/,/etc/,/home/]\n"

#. type: Plain text
#: text/chapter4.md:573
msgid ""
"The `Test.Examples` module defines functions that use the `Data.Path` API. "
"You do not need to modify the `Data.Path` module, or understand its "
"implementation. We will work entirely in the `Test.Examples` module."
msgstr ""
"`Test.Examples`モジュールでは`Data.Path` APIを使用する関数を定義していま"
"す。\n"
"`Data.Path`モジュールを変更したり定義を理解したりする必要はありません。\n"
"全て`Test.Examples`モジュールだけで作業します。"

#. type: Title ##
#: text/chapter4.md:574
#, no-wrap
msgid "Listing All Files"
msgstr "全てのファイルの一覧"

#. type: Plain text
#: text/chapter4.md:577
msgid ""
"Let's write a function that performs a deep enumeration of all files inside "
"a directory. This function will have the following type:"
msgstr ""
"それでは、ディレクトリの中身を含めた全てのファイルを深く列挙する関数を書いて"
"みましょう。\n"
"この関数は以下のような型を持つでしょう。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:578
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_signature}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_signature}}\n"

#. type: Plain text
#: text/chapter4.md:583
msgid ""
"We can define this function by recursion. First, we can use `ls` to "
"enumerate the immediate children of the directory. For each child, we can "
"recursively apply `allFiles`, which will return an array of paths. "
"`concatMap` will allow us to apply `allFiles` and flatten the results "
"simultaneously."
msgstr ""
"再帰を使ってこの関数を定義できます。\n"
"`ls`を使うとディレクトリ直下の子が列挙されます。\n"
"それぞれの子について再帰的に`allFiles`を適用すると、それぞれパスの配列が返り"
"ます。\n"
"`concatMap`を使うと、`allFiles`を適用して平坦化するまでを一度にできます。"

#. type: Plain text
#: text/chapter4.md:585
msgid "Finally, we use the cons operator `:` to include the current file:"
msgstr "最後に、cons演算子`:`を使って現在のファイルも含めます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:586
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_implementation}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_implementation}}\n"

#. type: Plain text
#: text/chapter4.md:591
#, no-wrap
msgid "> _Note_: the cons operator `:` has poor performance on immutable arrays, so it is not generally recommended. Performance can be improved by using other data structures, such as linked lists and sequences.\n"
msgstr ""
"> *補足*：実はcons演算子`:`は、不変な配列に対して効率性が悪いので、一般的には推奨されません。\n"
"> 連結リストやシーケンスなどの他のデータ構造を使用すると、効率性を向上させられます。\n"

#. type: Plain text
#: text/chapter4.md:593
msgid "Let's try this function in PSCi:"
msgstr "それではPSCiでこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:594
#, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.Path\n"
"\n"
"> allFiles root\n"
"\n"
"[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]\n"
msgstr ""
"> import Test.Examples\n"
"> import Data.Path\n"
"\n"
"> allFiles root\n"
"\n"
"[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]\n"

#. type: Plain text
#: text/chapter4.md:604
msgid ""
"Great! Now let's see if we can write this function using an array "
"comprehension using do notation."
msgstr ""
"すばらしいです。\n"
"do記法で配列内包表記を使ってもこの関数を書くことができるので見ていきましょ"
"う。"

#. type: Plain text
#: text/chapter4.md:606
msgid ""
"Recall that a backwards arrow corresponds to choosing an element from an "
"array. The first step is to choose an element from the immediate children of "
"the argument. Then we call the function recursively for that file. Since we "
"use do notation, there is an implicit call to `concatMap`, which "
"concatenates all of the recursive results."
msgstr ""
"逆向きの矢印は配列から要素を選択するのに相当することを思い出してください。\n"
"最初の工程は引数の直接の子から要素を選択することです。\n"
"それからそのファイルに対して再帰関数を呼び出します。\n"
"do記法を使用しているので`concatMap`が暗黙に呼び出されています。\n"
"この関数は再帰的な結果を全て連結します。"

#. type: Plain text
#: text/chapter4.md:608
msgid "Here is the new version:"
msgstr "新しいバージョンは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:609
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_2}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_2}}\n"

#. type: Plain text
#: text/chapter4.md:614
msgid ""
"Try out the new version in PSCi – you should get the same result. I'll let "
"you decide which version you find clearer."
msgstr ""
"PSCiで新しいコードを試してみてください。\n"
"同じ結果が返ってくるはずです。\n"
"どちらのほうがわかりやすいかの選定はお任せします。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:619
msgid ""
"(Easy) Write a function `onlyFiles` which returns all _files_ (not "
"directories) in all subdirectories of a directory."
msgstr ""
"（簡単）ディレクトリの全てのサブディレクトリの中にある（ディレクトリを除く）"
"全てのファイルを返すような関数`onlyFiles`を書いてみてください。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:619
msgid ""
"(Medium) Write a function `whereIs` to search for a file by name. The "
"function should return a value of type `Maybe Path`, indicating the "
"directory containing the file, if it exists. It should behave as follows:"
msgstr ""
"（普通）ファイルを名前で検索する関数`whereIs`を書いてください。\n"
"この関数は型`Maybe Path`の値を返すものとします。\n"
"この値が存在するなら、そのファイルがそのディレクトリに含まれているということ"
"を表します。\n"
"この関数は次のように振る舞う必要があります。"

#. type: Plain text
#: text/chapter4.md:623
#, no-wrap
msgid ""
"     ```text\n"
"     > whereIs root \"ls\"\n"
"     Just (/bin/)\n"
msgstr ""
"     ```text\n"
"     > whereIs root \"ls\"\n"
"     Just (/bin/)\n"

#. type: Plain text
#: text/chapter4.md:627
#, no-wrap
msgid ""
"     > whereIs root \"cat\"\n"
"     Nothing\n"
"     ```\n"
msgstr ""
"     > whereIs root \"cat\"\n"
"     Nothing\n"
"     ```\n"

#. type: Plain text
#: text/chapter4.md:630
#, no-wrap
msgid ""
"     _Hint_: Try to write this function as an array comprehension using do notation.\n"
" 3. (Difficult) Write a function `largestSmallest` which takes a `Path` and returns an array containing the single largest and single smallest files in the `Path`. _Note_: consider the cases where there are zero or one files in the `Path` by returning an empty or one-element array, respectively.\n"
msgstr ""
"     *手掛かり*：この関数をdo記法を使った配列内包表記で書いてみましょう。\n"
" 3. （難しい）`Path`中の最大のファイルと最小のファイルを1つずつ含む配列を返す関数`largestSmallest`を書いてください。\n"
"    *補足*：空配列や1要素の配列を返すことで、`Path`にそれぞれゼロか1個のファイルがある場合についても考慮してください。\n"

#. type: Plain text
#: text/chapter4.md:633
msgid ""
"In this chapter, we covered the basics of recursion in PureScript to express "
"algorithms concisely. We also introduced user-defined infix operators, "
"standard functions on arrays such as maps, filters, and folds, and array "
"comprehensions that combine these ideas. Finally, we showed the importance "
"of using tail recursion to avoid stack overflow errors and how to use "
"accumulator parameters to convert functions to tail recursive form."
msgstr ""
"この章ではアルゴリズムを簡潔に表現するためにPureScriptでの再帰の基本を押さえ"
"ました。\n"
"また、独自の中置演算子や、マップ、絞り込みや畳み込みなどの配列に対する標準関"
"数、及びこれらの概念を組み合わせた配列内包表記を導入しました。\n"
"最後に、スタックオーバーフローエラーを回避するために末尾再帰を使用することの"
"重要性、累算器引数を使用して末尾再帰形に関数を変換する方法を示しました。"

#. type: Title #
#: text/chapter5.md:1
#, no-wrap
msgid "Pattern Matching"
msgstr "パターン照合"

#. type: Plain text
#: text/chapter5.md:6
msgid ""
"This chapter will introduce two new concepts: algebraic data types and "
"pattern matching. We will also briefly cover an interesting feature of the "
"PureScript type system: row polymorphism."
msgstr ""
"この章では、代数的データ型とパターン照合という、2つの新しい概念を導入しま"
"す。\n"
"また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱"
"います。"

#. type: Plain text
#: text/chapter5.md:8
msgid ""
"Pattern matching is a common technique in functional programming and allows "
"the developer to write compact functions, which express potentially complex "
"ideas by breaking their implementation down into multiple cases."
msgstr ""
"パターン照合は関数型プログラミングにおける一般的な手法であり、開発者が簡潔に"
"関数を書けるようになります。\n"
"関数の実装を複数の場合に分解することにより、水面下の複雑なアイディアが表現さ"
"れるのです。"

#. type: Plain text
#: text/chapter5.md:10
msgid ""
"Algebraic data types are a feature of the PureScript type system, which "
"enables a similar level of expressiveness in the language of types – they "
"are closely related to pattern matching."
msgstr ""
"代数的データ型はPureScriptの型システムの機能であり、型のある言語において同等"
"の水準の表現力を可能にしています。\n"
"パターン照合とも密接に関連しています。"

#. type: Plain text
#: text/chapter5.md:12
msgid ""
"The chapter's goal will be to write a library to describe and manipulate "
"simple vector graphics using algebraic types and pattern matching."
msgstr ""
"この章の目的は、代数的データ型やパターン照合を使用して、単純なベクターグラ"
"フィックスを記述し操作するためのライブラリを書くことです。"

#. type: Plain text
#: text/chapter5.md:16
msgid ""
"The source code for this chapter is defined in the file `src/Data/Picture."
"purs`."
msgstr ""
"この章のソースコードはファイル `src/Data/Picture.purs`で定義されています。"

#. type: Plain text
#: text/chapter5.md:18
msgid ""
"The `Data.Picture` module defines a data type `Shape` for simple shapes and "
"a type `Picture` for collections of shapes, along with functions for working "
"with those types."
msgstr ""
"`Data.Picture`モジュールは簡単な図形を表すデータ型`Shape`やその図形の集合であ"
"る型`Picture`を定義します。\n"
"また、これらの型を扱うための関数もあります。"

#. type: Plain text
#: text/chapter5.md:20
msgid ""
"The module imports the `Data.Foldable` module, which provides functions for "
"folding data structures:"
msgstr ""
"このモジュールでは、データ構造を畳込む関数を提供する`Data.Foldable`モジュール"
"もインポートします。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:21
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:module_picture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:module_picture}}\n"

#. type: Plain text
#: text/chapter5.md:26
msgid ""
"The `Data.Picture` module also imports the `Number` module, but this time "
"using the `as` keyword:"
msgstr ""
"`Data.Picture`モジュールは`Number`モジュールもインポートしますが、こちらは"
"`as`キーワードを使います。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:27
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:picture_import_as}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:picture_import_as}}\n"

#. type: Plain text
#: text/chapter5.md:32
msgid ""
"This makes the types and functions in that module available for use, but "
"only by using the _qualified name_, like `Number.max`. This can be useful to "
"avoid overlapping imports or clarify which modules certain things are "
"imported from."
msgstr ""
"こうすると型や関数をモジュール内で使用できるようになりますが、\n"
"`Number.max`のように*修飾名*を使ったときに限定されます。\n"
"重複したインポートを避けたり、どのモジュールからインポートされたのかを明らか"
"にするのに役立ちます。"

#. type: Plain text
#: text/chapter5.md:34
#, no-wrap
msgid "> _Note_: Using the same module name as the original module for a qualified import is unnecessary  – shorter qualified names like `import Data.Number as N` are possible and quite common.\n"
msgstr ""
"> *補足*：元のモジュールと同じモジュール名を修飾名に使用する必要はありません。\n"
"> `import Math as M`などのより短い名前にできますし、かなりよく見掛けます。\n"

#. type: Title ##
#: text/chapter5.md:35
#, no-wrap
msgid "Simple Pattern Matching"
msgstr "単純なパターン照合"

#. type: Plain text
#: text/chapter5.md:38
msgid ""
"Let's begin by looking at an example. Here is a function that computes the "
"greatest common divisor of two integers using pattern matching:"
msgstr ""
"例を見ることから始めましょう。\n"
"パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになりま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:39
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcd}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcd}}\n"

#. type: Plain text
#: text/chapter5.md:44
msgid ""
"This algorithm is called the Euclidean Algorithm. If you search for its "
"definition online, you will likely find a set of mathematical equations that "
"look like the code above. One benefit of pattern matching is that it allows "
"you to define code by cases, writing simple, declarative code that looks "
"like a mathematical function specification."
msgstr ""
"このアルゴリズムはユークリッドの互除法と呼ばれています。\n"
"その定義をオンラインで検索すると、恐らく上記のコードによく似た数学の方程式が"
"見つかるでしょう。\n"
"パターン照合の利点の1つは、コードを場合分けして定義でき、数学関数の仕様に似た"
"単純で宣言型なコードを定義できることです。"

#. type: Plain text
#: text/chapter5.md:46
msgid ""
"A function written using pattern matching works by pairing sets of "
"conditions with their results. Each line is called an _alternative_ or a "
"_case_. The expressions on the left of the equals sign are called "
"_patterns_, and each case consists of one or more patterns separated by "
"spaces. Cases describe which conditions the arguments must satisfy before "
"the expression on the right of the equals sign should be evaluated and "
"returned. Each case is tried in order, and the first case whose patterns "
"match their inputs determines the return value."
msgstr ""
"パターン照合を使用して書かれた関数は、条件と結果の組み合わせによって動作しま"
"す。\n"
"この定義の各行は*選択肢*や*場合*と呼ばれています。\n"
"等号の左辺の式は*パターン*と呼ばれており、それぞれの場合は空白で区切られた1つ"
"以上のパターンで構成されています。\n"
"場合の集まりは、等号の右側の式が評価され値が返される前に、引数が満たさなけれ"
"ばならない条件を表現しています。\n"
"それぞれの場合は上からこの順番に試されていき、最初にパターンが入力に照合した"
"場合が返り値を決定します。"

#. type: Plain text
#: text/chapter5.md:48
msgid "For example, the `gcd` function is evaluated using the following steps:"
msgstr "例えば`gcd`関数は次の手順で評価されます。"

#. type: Bullet: '- '
#: text/chapter5.md:52
msgid ""
"The first case is tried: if the second argument is zero, the function "
"returns `n` (the first argument)."
msgstr ""
"まず最初の場合が試されます。\n"
"第2引数がゼロの場合、関数は `n`（最初の引数）を返します。"

#. type: Bullet: '- '
#: text/chapter5.md:52
msgid ""
"If not, the second case is tried: if the first argument is zero, the "
"function returns `m` (the second argument)."
msgstr ""
"そうでなければ、2番目の場合が試されます。\n"
"最初の引数がゼロの場合、関数は `m`（第2引数）を返します。"

#. type: Bullet: '- '
#: text/chapter5.md:52
msgid ""
"Otherwise, the function evaluates and returns the expression in the last "
"line."
msgstr "それ以外の場合、関数は最後の行の式を評価して返します。"

#. type: Plain text
#: text/chapter5.md:54
msgid ""
"Note that patterns can bind values to names – each line in the example binds "
"one or both of the names `n` and `m` to the input values. As we learn about "
"different patterns, we will see that different patterns correspond to "
"different ways to choose names from the input arguments."
msgstr ""
"なお、パターンでは値を名前に束縛できます。\n"
"この例の各行では `n`や`m`という名前の何れかまたは両方に入力された値を束縛して"
"います。\n"
"様々な種類のパターンについて学んでいくうちに、それぞれの種類のパターンが入力"
"の引数から名前を選ぶ様々な方法に対応することがわかるでしょう。"

#. type: Title ##
#: text/chapter5.md:55
#, no-wrap
msgid "Simple Patterns"
msgstr "単純なパターン"

#. type: Plain text
#: text/chapter5.md:58
msgid "The example code above demonstrates two types of patterns:"
msgstr "上記のコード例では、2種類のパターンを示しました。"

#. type: Bullet: '- '
#: text/chapter5.md:61
msgid ""
"Integer literals patterns, which match something of type `Int`, only if the "
"value matches exactly."
msgstr "`Int`型の値が正確に一致する場合にのみ照合する、整数直値パターン"

#. type: Bullet: '- '
#: text/chapter5.md:61
msgid "Variable patterns, which bind their argument to a name"
msgstr "引数を名前に束縛する、変数パターン"

#. type: Plain text
#: text/chapter5.md:63
msgid "There are other types of simple patterns:"
msgstr "単純なパターンには他にも種類があります。"

#. type: Bullet: '- '
#: text/chapter5.md:66
msgid "`Number`, `String`, `Char`, and `Boolean` literals"
msgstr "`Number`、`String`、`Char`、そして`Boolean`といった直値"

#. type: Bullet: '- '
#: text/chapter5.md:66
msgid ""
"Wildcard patterns, indicated with an underscore (`_`), match any argument "
"and do not bind any names."
msgstr ""
"どんな引数とも照合するが名前に束縛はしない、アンダースコア (`_`) で表されるワ"
"イルドカードパターン"

#. type: Plain text
#: text/chapter5.md:68
msgid ""
"Here are two more examples that demonstrate using these simple patterns:"
msgstr "これらの単純なパターンを使用する実演として、もう2つの例が以下です。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:69
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:fromString}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:toString}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:fromString}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:toString}}\n"

#. type: Plain text
#: text/chapter5.md:76
msgid "Try these functions in PSCi."
msgstr "PSCiでこれらの関数を試してみてください。"

#. type: Plain text
#: text/chapter5.md:80
#, no-wrap
msgid "In the Euclidean algorithm example, we used an `if .. then .. else` expression to switch between the two alternatives when `m > n` and `m <= n`. Another option, in this case, would be to use a _guard_.\n"
msgstr ""
"ユークリッドの互除法の例では、`m > n`のときと`m <= n`のときの2つの選択肢の間を切り替えるために`if .. then .. else`式を使いました。\n"
"こういうときには*ガード*を使うという他の選択肢もあります。\n"

#. type: Plain text
#: text/chapter5.md:82
msgid ""
"A guard is a boolean-valued expression that must be satisfied in addition to "
"the constraints imposed by the patterns. Here is the Euclidean algorithm "
"rewritten to use a guard:"
msgstr ""
"ガードとは、パターンにより課された制約に加えて満たされなくてはいけない真偽値"
"の式です。\n"
"ガードを使用してユークリッドのアルゴリズムを書き直すと、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:83
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcdV2}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcdV2}}\n"

#. type: Plain text
#: text/chapter5.md:88
msgid ""
"In this case, the third line uses a guard to impose the extra condition that "
"the first argument is strictly larger than the second. The guard in the "
"final line uses the expression `otherwise`, which might seem like a keyword "
"but is, in fact, just a regular binding in `Prelude`:"
msgstr ""
"この場合、3行目ではガードを使用して、最初の引数が第2引数よりも厳密に大きいと"
"いう条件を課しています。\n"
"最後の行でのガードは式`otherwise`を使っています。\n"
"これはキーワードのようにも見えますが、実際はただの`Prelude`にある普通の束縛で"
"す。"

#. type: Fenced code block (text)
#: text/chapter5.md:89
#, no-wrap
msgid ""
"> :type otherwise\n"
"Boolean\n"
"\n"
"> otherwise\n"
"true\n"
msgstr ""
"> :type otherwise\n"
"Boolean\n"
"\n"
"> otherwise\n"
"true\n"

#. type: Plain text
#: text/chapter5.md:98
msgid ""
"This example demonstrates that guards appear on the left of the equals "
"symbol, separated from the list of patterns by a pipe character (`|`)."
msgstr ""
"この例が示すように、ガードは等号の左側に現れ、パイプ文字 (`|`) でパターンのリ"
"ストと区切られています。"

#. type: Bullet: '1. '
#: text/chapter5.md:104
msgid ""
"(Easy) Write the `factorial` function using pattern matching. _Hint_: "
"Consider the two corner cases of zero and non-zero inputs. _Note_: This is a "
"repeat of an example from the previous chapter, but see if you can rewrite "
"it here on your own."
msgstr ""
"（簡単）パターン照合を使用して、階乗関数`factorial`を書いてみましょう。\n"
"*手掛かり*：入力がゼロのときとゼロでないときの、2つの特殊な場合を考えてみてく"
"ださい。\n"
"*補足*：これは前の章の例の反復ですが、ここでは自力で書き直せるかやってみてく"
"ださい。"

#. type: Bullet: '1. '
#: text/chapter5.md:104
msgid ""
"(Medium) Write a function `binomial` which finds the coefficient of the "
"x^`k`th term in the polynomial expansion of (1 + x)^`n`. This is the same as "
"the number of ways to choose a subset of `k` elements from a set of `n` "
"elements. Use the formula `n! / k! (n - k)!`, where `!` is the factorial "
"function written earlier. _Hint_: Use pattern matching to handle corner "
"cases. If it takes a long time to complete or crashes with an error about "
"the call stack, try adding more corner cases."
msgstr ""
"（普通）\\\\( (1 + x) ^ n \\\\)を多項式展開した式にある\\\\( x ^ k \\\\)の項"
"の係数を求める関数`binomial`を書いてください。\n"
"これは`n`要素の集合から`k`要素の部分集合を選ぶ方法の数と同じです。\n"
"数式\\\\( n! / k! (n - k)! \\\\)を使ってください。\n"
"ここで \\\\( ! \\\\) は前に書いた階乗関数です。\n"
"*手掛かり*：パターン照合を使って特殊な場合を取り扱ってください。\n"
"長い時間が掛かったりコールスタックのエラーでクラッシュしたりしたら、特殊な場"
"合を更に追加してみてください。"

#. type: Bullet: '1. '
#: text/chapter5.md:104
msgid ""
"(Medium) Write a function `pascal` which uses [_Pascal`s Rule_](https://en."
"wikipedia.org/wiki/Pascal%27s_rule) for computing the same binomial "
"coefficients as the previous exercise."
msgstr ""
"（普通）[_パスカルの法則_](https://en.wikipedia.org/wiki/Pascal%27s_rule)を"
"使って前の演習と同じ2項係数を計算する関数`pascal`を書いてください。"

#. type: Title ##
#: text/chapter5.md:105
#, no-wrap
msgid "Array Patterns"
msgstr "配列パターン"

#. type: Plain text
#: text/chapter5.md:108
msgid ""
"_Array literal patterns_ provide a way to match arrays of a fixed length. "
"For example, suppose we want to write a function `isEmpty` which identifies "
"empty arrays. We could do this by using an empty array pattern (`[]`) in the "
"first alternative:"
msgstr ""
"*配列直値パターン*は、固定長の配列に対して照合する方法を提供します。\n"
"例えば空の配列であるか判定する関数`isEmpty`を書きたいとします。\n"
"最初の選択肢に空の配列パターン (`[]`) を用いるとこれを実現できます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:109
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:isEmpty}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:isEmpty}}\n"

#. type: Plain text
#: text/chapter5.md:114
msgid ""
"Here is another function that matches arrays of length five, binding each of "
"its five elements differently:"
msgstr ""
"次の関数では、長さ5の配列と照合し、配列の5つの要素をそれぞれ違った方法で束縛"
"しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:115
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:takeFive}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:takeFive}}\n"

#. type: Plain text
#: text/chapter5.md:120
msgid ""
"The first pattern only matches arrays with five elements, whose first and "
"second elements are 0 and 1, respectively. In that case, the function "
"returns the product of the third and fourth elements. In every other case, "
"the function returns zero. For example, in PSCi:"
msgstr ""
"最初のパターンは、第1要素と第2要素がそれぞれ0と1であるような、5要素の配列にの"
"み照合します。\n"
"その場合、関数は第3要素と第4要素の積を返します。\n"
"それ以外の場合は、関数は0を返します。\n"
"例えばPSCiで試してみると次のようになります。"

#. type: Fenced code block (text)
#: text/chapter5.md:121
#, no-wrap
msgid ""
"> :paste\n"
"… takeFive [0, 1, a, b, _] = a * b\n"
"… takeFive _ = 0\n"
"… ^D\n"
"\n"
"> takeFive [0, 1, 2, 3, 4]\n"
"6\n"
"\n"
"> takeFive [1, 2, 3, 4, 5]\n"
"0\n"
"\n"
"> takeFive []\n"
"0\n"
msgstr ""
"> :paste\n"
"… takeFive [0, 1, a, b, _] = a * b\n"
"… takeFive _ = 0\n"
"… ^D\n"
"\n"
"> takeFive [0, 1, 2, 3, 4]\n"
"6\n"
"\n"
"> takeFive [1, 2, 3, 4, 5]\n"
"0\n"
"\n"
"> takeFive []\n"
"0\n"

#. type: Plain text
#: text/chapter5.md:138
msgid ""
"Array literal patterns allow us to match arrays of a fixed length. Still, "
"PureScript does _not_ provide any means of matching arrays of an unspecified "
"length since destructuring immutable arrays in these sorts of ways can lead "
"to poor performance. If you need a data structure that supports this sort of "
"matching, the recommended approach is to use `Data.List`. Other data "
"structures exist which provide improved asymptotic performance for different "
"operations."
msgstr ""
"配列の直値パターンでは、固定長の配列と一致させることはできます。\n"
"しかしPureScriptは不特定の長さの配列を照合させる手段は全く提供して*いません"
"*。\n"
"そのような類の方法で不変な配列を分解すると、実行速度が低下する可能性があるた"
"めです。\n"
"このように照合できるデータ構造が必要な場合は、`Data.List`を使うことをお勧めし"
"ます。\n"
"その他の操作について、より優れた漸近性能を提供するデータ構造も存在します。"

#. type: Title ##
#: text/chapter5.md:139
#, no-wrap
msgid "Record Patterns and Row Polymorphism"
msgstr "レコードパターンと行多相"

#. type: Plain text
#: text/chapter5.md:142
msgid "_Record patterns_ are used to match – you guessed it – records."
msgstr "*レコードパターン*は（ご想像の通り）レコードに照合します。"

#. type: Plain text
#: text/chapter5.md:144
msgid ""
"Record patterns look just like record literals, but instead of values on the "
"right of the colon, we specify a binder for each field."
msgstr ""
"レコードパターンはレコード直値にほぼ見た目が似ていますが、コロンの右に値を置"
"くのではなく、それぞれのフィールドで束縛子を指定します。"

#. type: Plain text
#: text/chapter5.md:146
msgid ""
"For example, this pattern matches any record which contains fields called "
"`first` and `last`, and binds their values to the names `x` and `y`, "
"respectively:"
msgstr ""
"例えば次のパターンは`first`と`last`という名前のフィールドが含まれた任意のレ"
"コードに照合し、これらのフィールドの値はそれぞれ `x`と `y`という名前に束縛さ"
"れます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:147
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPerson}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPerson}}\n"

#. type: Plain text
#: text/chapter5.md:152
msgid ""
"Record patterns provide a good example of an interesting feature of the "
"PureScript type system: _row polymorphism_. Suppose we had defined "
"`showPerson` without a type signature above. What would its inferred type "
"have been? Interestingly, it is not the same as the type we gave:"
msgstr ""
"レコードパターンはPureScriptの型システムの興味深い機能である*行多相*の良い例"
"となっています。\n"
"もし上の`showPerson`を型シグネチャなしで定義していたとすると、この型はどのよ"
"うに推論されるのでしょうか。\n"
"面白いことに、推論される型は上で与えた型とは同じではありません。"

#. type: Fenced code block (text)
#: text/chapter5.md:153
#, fuzzy, no-wrap
#| msgid ""
#| "> showPerson { first: x, last: y } = y <> \", \" <> x\n"
#| "\n"
#| "> :type showPerson\n"
#| "forall r. { first :: String, last :: String | r } -> String\n"
msgid ""
"> showPerson { first: x, last: y } = y <> \", \" <> x\n"
"\n"
"> :type showPerson\n"
"forall (r :: Row Type). { first :: String, last :: String | r } -> String\n"
msgstr ""
"> showPerson { first: x, last: y } = y <> \", \" <> x\n"
"\n"
"> :type showPerson\n"
"forall r. { first :: String, last :: String | r } -> String\n"

#. type: Plain text
#: text/chapter5.md:161
msgid ""
"What is the type variable `r` here? Well, if we try `showPerson` in PSCi, we "
"see something interesting:"
msgstr ""
"この型変数 `r`は何でしょうか。\n"
"PSCiで`showPerson`を使ってみると、面白いことがわかります。"

#. type: Fenced code block (text)
#: text/chapter5.md:162
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\", last: \"Freeman\" }\n"
"\"Freeman, Phil\"\n"
"\n"
"> showPerson { first: \"Phil\", last: \"Freeman\", location: \"Los Angeles\" }\n"
"\"Freeman, Phil\"\n"
msgstr ""
"> showPerson { first: \"Phil\", last: \"Freeman\" }\n"
"\"Freeman, Phil\"\n"
"\n"
"> showPerson { first: \"Phil\", last: \"Freeman\", location: \"Los Angeles\" }\n"
"\"Freeman, Phil\"\n"

#. type: Plain text
#: text/chapter5.md:171
msgid ""
"We can append additional fields to the record, and the `showPerson` function "
"will still work. As long as the record contains the `first` and `last` "
"fields of type `String`, the function application is well-typed. However, it "
"is _not_ valid to call `showPerson` with too _few_ fields:"
msgstr ""
"レコードにそれ以外のフィールドが追加されていても、`showPerson`関数はそのまま"
"動作するのです。\n"
"レコードに少なくとも型が`String`であるようなフィールド`first`と`last`が含まれ"
"ていれば、関数適用は正しく型付けされます。\n"
"しかし、フィールドが*不足*していると、`showPerson`の呼び出しは*不正*となりま"
"す。"

#. type: Fenced code block (text)
#: text/chapter5.md:172
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\" }\n"
"\n"
"Type of expression lacks required label \"last\"\n"
msgstr ""
"> showPerson { first: \"Phil\" }\n"
"\n"
"Type of expression lacks required label \"last\"\n"

#. type: Plain text
#: text/chapter5.md:179
msgid ""
"We can read the new type signature of `showPerson` as \"takes any record "
"with `first` and `last` fields which are `Strings` _and any other fields_, "
"and returns a `String`\". This function is polymorphic in the _row_ `r` of "
"record fields, hence the name _row polymorphism_.  Note that this behavior "
"is different than that of the original `showPerson`. Without the row "
"variable `r`, `showPerson` only accepts records with _exactly_ a `first` and "
"`last` field and no others."
msgstr ""
"`showPerson`の新しい型シグネチャを読むと、「`String`な`first`と`last`フィール"
"ド _と他のフィールドを何でも_ 持つあらゆるレコードを取り、`String`を返す」と"
"なります。なお、この挙動は元の`showPerson`のものとは異なります。行変数`r`がな"
"ければ`showPerson`は _厳密に_ `first`と`last`フィールドしかないレコードのみを"
"受け付けます。"

#. type: Plain text
#: text/chapter5.md:181
msgid "Note that we could have also written"
msgstr "なお、次のように書くこともできます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:182
#, no-wrap
msgid "> showPerson p = p.last <> \", \" <> p.first\n"
msgstr "> showPerson p = p.last <> \", \" <> p.first\n"

#. type: Plain text
#: text/chapter5.md:187
msgid "And PSCi would have inferred the same type."
msgstr "そしてPSCiは同じ型を推論することでしょう。"

#. type: Title ##
#: text/chapter5.md:188
#, no-wrap
msgid "Record Puns"
msgstr "レコード同名利用"

#. type: Plain text
#: text/chapter5.md:191
msgid ""
"Recall that the `showPerson` function matches a record inside its argument, "
"binding the `first` and `last` fields to values named `x` and `y`. We could "
"alternatively reuse the field names themselves and simplify this sort of "
"pattern match as follows:"
msgstr ""
"`showPerson`関数は引数内のレコードと照合し、`first`と`last`フィールドを`x`と"
"`y`という名前の値に束縛していたのでした。\n"
"別の方法として、フィールド名自体を再利用してこのような類のパターン照合を次の"
"ように単純化できます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:192
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPersonV2}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPersonV2}}\n"

#. type: Plain text
#: text/chapter5.md:197
msgid ""
"Here, we only specify the names of the fields, and we do not need to specify "
"the names of the values we want to introduce. This is called a _record pun_."
msgstr ""
"ここでは、プロパティの名前のみを指定し、名前に導入したい値を指定する必要はあ"
"りません。これは _レコード同名利用_ (record pun) と呼ばれます。"

#. type: Plain text
#: text/chapter5.md:199
msgid ""
"It is also possible to use record puns to _construct_ records. For example, "
"if we have values named `first` and `last` in scope, we can construct a "
"person record using `{ first, last }`:"
msgstr ""
"レコード同名利用はレコードの*構築*にも使用できます。\n"
"例えば、スコープに `first`と `last`という名前の値があれば、`{ first, last }`"
"を使って人物レコードを作ることができます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:unknownPerson}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:unknownPerson}}\n"

#. type: Plain text
#: text/chapter5.md:205
msgid "This may improve the readability of code in some circumstances."
msgstr "こうすると、状況によってはコードの可読性が向上します。"

#. type: Title ##
#: text/chapter5.md:206
#, no-wrap
msgid "Nested Patterns"
msgstr "入れ子になったパターン"

#. type: Plain text
#: text/chapter5.md:209
msgid ""
"Array patterns and record patterns both combine smaller patterns to build "
"larger patterns. For the most part, the examples above have only used simple "
"patterns inside array patterns and record patterns. Still, it is important "
"to note that patterns can be arbitrarily _nested_, which allows functions to "
"be defined using conditions on potentially complex data types."
msgstr ""
"配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大"
"きなパターンを構築しています。\n"
"これまでのほとんどの例では配列パターンとレコードパターンの内部で単純なパター"
"ンを使用していました。\n"
"しかし特筆すべきこととして、パターンは自由に*入れ子*にできます。\n"
"これにより潜在的に複雑なデータ型についての条件を使って関数を定義できます。"

#. type: Plain text
#: text/chapter5.md:211
msgid "For example, this code combines two record patterns:"
msgstr "例えばこのコードは2つのレコードパターンを組み合わせています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:212
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:livesInLA}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:livesInLA}}\n"

#. type: Title ##
#: text/chapter5.md:216
#, no-wrap
msgid "Named Patterns"
msgstr "名前付きパターン"

#. type: Plain text
#: text/chapter5.md:219
msgid ""
"Patterns can be _named_ to bring additional names into scope when using "
"nested patterns. Any pattern can be named by using the `@` symbol."
msgstr ""
"入れ子のパターンを使う場合、パターンには*名前を付け*てスコープに名前を追加で"
"持ち込むことができます。\n"
"任意のパターンに名前を付けるには、 `@`記号を使います。"

#. type: Plain text
#: text/chapter5.md:221
msgid ""
"For example, this function sorts two-element arrays, naming the two "
"elements, but also naming the array itself:"
msgstr ""
"例えば次の関数は2要素配列を整列するもので、2つの要素に名前を付けていますが、"
"配列自身にも名前を付けています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:222
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:sortPair}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:sortPair}}\n"

#. type: Plain text
#: text/chapter5.md:227
msgid ""
"This way, we save ourselves from allocating a new array if the pair is "
"already sorted. Note that if the input array does not contain _exactly_ two "
"elements, then this function returns it unchanged, even if it's unsorted."
msgstr ""
"このようにすれば対が既に整列されているときに新しい配列を割り当てなくて済みま"
"す。\n"
"なお、もし入力の配列が*厳密に*2つの要素を含んでいなければ、たとえ整列されてい"
"なかったとしても、この関数は単に元のまま変えずに返します。"

#. type: Bullet: '1. '
#: text/chapter5.md:233
msgid ""
"(Easy) Write a function `sameCity` which uses record patterns to test "
"whether two `Person` records belong to the same city."
msgstr ""
"（簡単）レコードパターンを使って、2つの `Person`レコードが同じ都市にいるか調"
"べる関数 `sameCity`を定義してみましょう。"

#. type: Bullet: '1. '
#: text/chapter5.md:233
msgid ""
"(Medium) What is the most general type of the `sameCity` function, "
"considering row polymorphism? What about the `livesInLA` function defined "
"above? _Note_: There is no test for this exercise."
msgstr ""
"（普通）行多相を考慮すると、 `sameCity`関数の最も一般的な型は何でしょうか。\n"
"先ほど定義した`livesInLA`関数についてはどうでしょうか。\n"
"*補足*：この演習にテストはありません。"

#. type: Bullet: '1. '
#: text/chapter5.md:233
msgid ""
"(Medium) Write a function `fromSingleton` that uses an array literal pattern "
"to extract the sole member of a singleton array. If the array is not a "
"singleton, your function should return a provided default value. Your "
"function should have type `forall a. a -> Array a -> a`"
msgstr ""
"（普通）配列直値パターンを使って、1要素の配列の唯一のメンバーを抽出する関数"
"`fromSingleton`を書いてみましょう。\n"
"1要素だけを持つ配列でない場合、関数は与えられた既定値を返します。\n"
"この関数は`forall a. a -> Array a -> a`という型を持ちます。"

#. type: Title ##
#: text/chapter5.md:234
#, no-wrap
msgid "Case Expressions"
msgstr "case式"

#. type: Plain text
#: text/chapter5.md:237
msgid ""
"Patterns do not only appear in top-level function declarations. It is "
"possible to use patterns to match on an intermediate value in a computation "
"using a `case` expression. Case expressions provide a similar type of "
"utility to anonymous functions: it is not always desirable to give a name to "
"a function, and a `case` expression allows us to avoid naming a function "
"just because we want to use a pattern."
msgstr ""
"パターンが現れるのは最上位にある関数宣言だけではありません。\n"
"`case`式を使う計算中の途中の値に対してパターン照合を使えます。\n"
"case式には無名関数に似た便利さがあります。\n"
"関数に名前を与えることがいつも望ましいわけではないように、パターンを使いたい"
"ためだけに関数に名前をつけるようなことを避けられるようになります。"

#. type: Plain text
#: text/chapter5.md:239
msgid ""
"Here is an example. This function computes the \"longest zero suffix\" of an "
"array (the longest suffix which sums to zero):"
msgstr ""
"例を示しましょう。\n"
"次の関数は、配列の「最長ゼロ末尾」（和がゼロであるような、最も長い配列の末"
"尾）を計算します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:240
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzsImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzs}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzsImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzs}}\n"

#. type: Fenced code block (text)
#: text/chapter5.md:248
#, no-wrap
msgid ""
"> lzs [1, 2, 3, 4]\n"
"[]\n"
"\n"
"> lzs [1, -1, -2, 3]\n"
"[-1, -2, 3]\n"
msgstr ""
"> lzs [1, 2, 3, 4]\n"
"[]\n"
"\n"
"> lzs [1, -1, -2, 3]\n"
"[-1, -2, 3]\n"

#. type: Plain text
#: text/chapter5.md:257
msgid ""
"This function works by case analysis. If the array is empty, our only option "
"is to return an empty array. If the array is non-empty, we first use a "
"`case` expression to split it into two cases. If the sum of the array is "
"zero, we return the whole array. If not, we recurse on the tail of the array."
msgstr ""
"この関数は場合毎の分析によって動作します。\n"
"もし配列が空なら、唯一の選択肢は空の配列を返すことです。\n"
"配列が空でない場合は、更に2つの場合に分けるためにまず`case`式を使用します。\n"
"配列の合計がゼロであれば、配列全体を返します。\n"
"そうでなければ、配列の残りに対して再帰します。"

#. type: Title ##
#: text/chapter5.md:258
#, no-wrap
msgid "Pattern Match Failures and Partial Functions"
msgstr "パターン照合の失敗と部分関数"

#. type: Plain text
#: text/chapter5.md:261
msgid ""
"If patterns in a case expression are tried in order, what happens when none "
"of the patterns in a case alternatives match their inputs? In this case, the "
"case expression will fail at runtime with a _pattern match failure_."
msgstr ""
"case式のパターンを順番に照合していって、どの選択肢の場合も入力が照合しなかっ"
"た時はどうなるのでしょう。\n"
"この場合、*パターン照合失敗*によって、case式は実行時に失敗します。"

#. type: Plain text
#: text/chapter5.md:263
msgid "We can see this behavior with a simple example:"
msgstr "簡単な例でこの動作を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:264
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:unsafePartialImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:partialFunction}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:unsafePartialImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:partialFunction}}\n"

#. type: Plain text
#: text/chapter5.md:271
msgid ""
"This function contains only a single case, which only matches a single "
"input, `true`. If we compile this file and test in PSCi with any other "
"argument, we will see an error at runtime:"
msgstr ""
"この関数は単一の場合しか含んでいません。\n"
"そしてその場合は単一の入力である`true`にのみ照合します。\n"
"このファイルをコンパイルしてPSCiでそれ以外の値を与えて試すと実行時エラーが発"
"生します。"

#. type: Fenced code block (text)
#: text/chapter5.md:272
#, no-wrap
msgid ""
"> partialFunction false\n"
"\n"
"Failed pattern match\n"
msgstr ""
"> partialFunction false\n"
"\n"
"Failed pattern match\n"

#. type: Plain text
#: text/chapter5.md:279
msgid ""
"Functions that return a value for any combination of inputs are called "
"_total_ functions, and functions that do not are called _partial_."
msgstr ""
"どんな入力の組み合わせに対しても値を返すような関数は*全関数*と呼ばれ、そうで"
"ない関数は*部分的*であると呼ばれます。"

#. type: Plain text
#: text/chapter5.md:281
msgid ""
"It is generally considered better to define total functions where possible. "
"If it is known that a function does not return a result for some valid set "
"of inputs, it is usually better to return a value capable of indicating "
"failure, such as type `Maybe a` for some `a`, using `Nothing` when it cannot "
"return a valid result. This way, the presence or absence of a value can be "
"indicated in a type-safe way."
msgstr ""
"一般的には、可能な限り全関数として定義したほうが良いと考えられています。\n"
"もし関数が何らかの妥当な入力の集合について結果を返さないことがわかっているな"
"ら、大抵は失敗であることを示すことができる値を返すほうがよいでしょう。\n"
"例えば何らかの`a`についての型`Maybe a`で、妥当な結果を返せないときは`Nothing`"
"を使います。\n"
"この方法なら、型安全な方法で値の有無を示すことができます。"

#. type: Plain text
#: text/chapter5.md:283
msgid ""
"The PureScript compiler will generate an error if it can detect that your "
"function is not total due to an incomplete pattern match. The "
"`unsafePartial` function can be used to silence these errors (if you are "
"sure your partial function is safe!) If we removed the call to the "
"`unsafePartial` function above, then the compiler would generate the "
"following error:"
msgstr ""
"PureScriptコンパイラは、パターン照合が不完全であるために関数が全関数ではない"
"ことが検出されると、エラーを出します。\n"
"`unsafePartial`関数を使うとこうしたエラーを抑制できます（ただしその部分関数が"
"安全だと言い切れるなら）。\n"
"もし上記の`unsafePartial`関数の呼び出しを取り除くと、コンパイラは次のエラーを"
"出します。"

#. type: Fenced code block (text)
#: text/chapter5.md:284
#, no-wrap
msgid ""
"A case expression could not be determined to cover all inputs.\n"
"The following additional cases are required to cover all inputs:\n"
"\n"
"  false\n"
msgstr ""
"A case expression could not be determined to cover all inputs.\n"
"The following additional cases are required to cover all inputs:\n"
"\n"
"  false\n"

#. type: Plain text
#: text/chapter5.md:292
msgid ""
"This tells us that the value `false` is not matched by any pattern. In "
"general, these warnings might include multiple unmatched cases."
msgstr ""
"これは値`false`が、定義されたどのパターンとも一致しないことを示しています。\n"
"一般にこれらの警告には、複数の不一致な場合が含まれることがあります。"

#. type: Plain text
#: text/chapter5.md:294
msgid "If we also omit the type signature above:"
msgstr "上記の型シグネチャも省略した場合は、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:295
#, no-wrap
msgid "partialFunction true = true\n"
msgstr "partialFunction true = true\n"

#. type: Plain text
#: text/chapter5.md:300
msgid "then PSCi infers a curious type:"
msgstr "このとき、PSCiは興味深い型を推論します。"

#. type: Fenced code block (text)
#: text/chapter5.md:301
#, no-wrap
msgid ""
"> :type partialFunction\n"
"\n"
"Partial => Boolean -> Boolean\n"
msgstr ""
"> :type partialFunction\n"
"\n"
"Partial => Boolean -> Boolean\n"

#. type: Plain text
#: text/chapter5.md:308
#, no-wrap
msgid "We will see more types that involve the `=>` symbol later on in the book (they are related to _type classes_), but for now, it suffices to observe that PureScript keeps track of partial functions using the type system and that we must explicitly tell the type checker when they are safe.\n"
msgstr ""
"本書では以降、`=>`記号が絡む（*型クラス*に関連する）型をもっと見ていきます。\n"
"しかし現時点では、PureScriptは型システムを使って部分関数を把握していることと、安全な場合に型検証器に明示する必要があることを確認すれば充分です。\n"

#. type: Plain text
#: text/chapter5.md:310
msgid ""
"The compiler will also generate a warning in certain cases when it can "
"detect that cases are _redundant_ (that is, a case only matches values which "
"a prior case would have matched):"
msgstr ""
"コンパイラは、*冗長*な場合を検出したとき（つまり、その場合より前の方に定義さ"
"れた場合にのみ一致するとき）などにも警告を出します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:311
#, no-wrap
msgid ""
"redundantCase :: Boolean -> Boolean\n"
"redundantCase true = true\n"
"redundantCase false = false\n"
"redundantCase false = false\n"
msgstr ""
"redundantCase :: Boolean -> Boolean\n"
"redundantCase true = true\n"
"redundantCase false = false\n"
"redundantCase false = false\n"

#. type: Plain text
#: text/chapter5.md:319
msgid "In this case, the last case is correctly identified as redundant:"
msgstr "このとき、最後の場合は冗長であると正しく検出されます。"

#. type: Fenced code block (text)
#: text/chapter5.md:320
#, no-wrap
msgid ""
"A case expression contains unreachable cases:\n"
"\n"
"  false\n"
msgstr ""
"A case expression contains unreachable cases:\n"
"\n"
"  false\n"

#. type: Plain text
#: text/chapter5.md:327
#, no-wrap
msgid "> _Note_: PSCi does not show warnings, so to reproduce this example, you will need to save this function as a file and compile it using `spago build`.\n"
msgstr ""
"> *補足*：PSCiは警告を表示しません。\n"
"> そのため、この例を再現するには、この関数をファイルとして保存し、`spago build`を使ってコンパイルします。\n"

#. type: Title ##
#: text/chapter5.md:328
#, no-wrap
msgid "Algebraic Data Types"
msgstr "代数的データ型"

#. type: Plain text
#: text/chapter5.md:331
msgid ""
"This section will introduce a feature of the PureScript type system called "
"_Algebraic Data Types_ (or _ADTs_), which are fundamentally related to "
"pattern matching."
msgstr ""
"この節では _代数的データ型_ (algebraic data type, _ADT_) と呼ばれる、"
"PureScriptの型システムの機能を導入します。この機能はパターン照合と地続きの関"
"係があります。"

#. type: Plain text
#: text/chapter5.md:333
msgid ""
"However, we'll first consider a motivating example, which will provide the "
"basis of a solution to this chapter's problem of implementing a simple "
"vector graphics library."
msgstr ""
"しかしまずは切り口となる例について考えていきます。この例では単純なベクターグ"
"ラフィックスライブラリの実装というこの章の課題を解決する基礎を与えます。"

#. type: Plain text
#: text/chapter5.md:335
msgid ""
"Suppose we wanted to define a type to represent some simple shapes: lines, "
"rectangles, circles, text, etc. In an object oriented language, we would "
"probably define an interface or abstract class `Shape`, and one concrete "
"subclass for each type of shape that we wanted to be able to work with."
msgstr ""
"直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとしま"
"す。\n"
"オブジェクト指向言語では、恐らくインターフェースもしくは抽象クラス `Shape`を"
"定義し、使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。"

#. type: Plain text
#: text/chapter5.md:337
msgid ""
"However, this approach has one major drawback: to work with `Shape`s "
"abstractly, it is necessary to identify all of the operations one might wish "
"to perform and to define them on the `Shape` interface. It becomes difficult "
"to add new operations without breaking modularity."
msgstr ""
"しかし、この方針は大きな欠点を1つ抱えています。\n"
"`Shape`を抽象的に扱うためには、実行したいと思う可能性のある全ての操作を事前に"
"把握し、`Shape`インターフェースに定義する必要があるのです。\n"
"モジュール性を壊さずに新しい操作を追加することが難しくなります。"

#. type: Plain text
#: text/chapter5.md:339
msgid ""
"Algebraic data types provide a type-safe way to solve this problem if the "
"set of shapes is known in advance. It is possible to define new operations "
"on `Shape` in a modular way and still maintain type-safety."
msgstr ""
"もし図形の種類が事前にわかっているなら、代数的データ型はこうした問題を解決す"
"る型安全な方法を提供します。\n"
"モジュール性のある方法で `Shape`に新たな操作を定義しつつ、型安全性を維持でき"
"ます。"

#. type: Plain text
#: text/chapter5.md:341
msgid "Here is how `Shape` might be represented as an algebraic data type:"
msgstr "代数的データ型としてどのように`Shape`が表現されるかを次に示します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:342
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Shape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Point}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Shape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Point}}\n"

#. type: Plain text
#: text/chapter5.md:349
msgid ""
"This declaration defines `Shape` as a sum of different constructors, and for "
"each constructor identifies the included data. A `Shape` is either a "
"`Circle` that contains a center `Point` and a radius (a number), or a "
"`Rectangle`, or a `Line`, or `Text`. There are no other ways to construct a "
"value of type `Shape`."
msgstr ""
"この宣言では`Shape`をそれぞれの構築子の直和として定義しており、各構築子では含"
"まれるデータを指定します。\n"
"`Shape`は、中央 `Point`と半径（数値）を持つ `Circle`か、`Rectangle`、 "
"`Line`、 `Text`の何れかです。\n"
"他に`Shape`型の値を構築する方法はありません。"

# 頭字語のADTの意味が分かるような註釈は必要です。
#. type: Plain text
#: text/chapter5.md:351
msgid ""
"An algebraic data type is introduced using the `data` keyword, followed by "
"the name of the new type and any type arguments. The type's constructors (i."
"e., its _data constructors_) are defined after the equals symbol and "
"separated by pipe characters (`|`). The data carried by an ADT's "
"constructors doesn't have to be restricted to primitive types: constructors "
"can include records, arrays, or even other ADTs."
msgstr ""
"代数的データ型 (algebraic data type; ADT) の定義はキーワード`data`から始ま"
"り、それに新しい型の名前と任意個の型引数が続きます。\n"
"その型の構築子（これを*データ構築子*と言います）は等号の後に定義され、パイプ"
"文字 (`|`) で区切られます。\n"
"ADTの構築子が持つデータは原始型に限りません。\n"
"構築子にはレコード、配列、また他のADTさえも含められます。"

#. type: Plain text
#: text/chapter5.md:353
msgid ""
"Let's see another example from PureScript's standard libraries. We saw the "
"`Maybe` type, which is used to define optional values, earlier in the book. "
"Here is its definition from the `maybe` package:"
msgstr ""
"それではPureScriptの標準ライブラリから別の例を見てみましょう。\n"
"省略可能な値を定義するのに使われる `Maybe`型を本書の冒頭で扱いました。\n"
"`maybe`パッケージでは `Maybe`を次のように定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:354
#, no-wrap
msgid "data Maybe a = Nothing | Just a\n"
msgstr "data Maybe a = Nothing | Just a\n"

#. type: Plain text
#: text/chapter5.md:359
msgid ""
"This example demonstrates the use of a type parameter `a`. Reading the pipe "
"character as the word \"or\", its definition almost reads like English: \"a "
"value of type `Maybe a` is either `Nothing`, or `Just` a value of type `a`\"."
msgstr ""
"この例では型引数 `a`の使用方法を示しています。パイプ文字を「または」と読むこ"
"とにすると、この定義は「`Maybe a`型の値は、無い (`Nothing`) か、ただの "
"(`Just`) 型 `a`の値だ」とほぼ英語のように読むことができます。"

#. type: Plain text
#: text/chapter5.md:361
msgid ""
"Note that we don't use the syntax `forall a.` anywhere in our data "
"definition. `forall` syntax is necessary for functions but is not used when "
"defining ADTs with `data` or type aliases with `type`."
msgstr ""
"なお、データ定義のどこにも構文`forall a`を使っていません。\n"
"`forall`構文は関数には必須ですが、`data`によるADTや`type`での型別称を定義する"
"ときは使われません。"

#. type: Plain text
#: text/chapter5.md:363
msgid ""
"Data constructors can also be used to define recursive data structures. Here "
"is one more example, defining a data type of singly-linked lists of elements "
"of type `a`:"
msgstr ""
"データ構築子は再帰的なデータ構造を定義するためにも使用できます。更に例を挙げ"
"ると、要素が型 `a`の単方向連結リストのデータ型の定義はこのようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:364
#, no-wrap
msgid "data List a = Nil | Cons a (List a)\n"
msgstr "data List a = Nil | Cons a (List a)\n"

#. type: Plain text
#: text/chapter5.md:369
msgid ""
"This example is taken from the `lists` package. Here, the `Nil` constructor "
"represents an empty list, and `Cons` is used to create non-empty lists from "
"a head element and a tail. Notice how the tail is defined using the data "
"type `List a`, making this a recursive data type."
msgstr ""
"この例は `lists`パッケージから持ってきました。\n"
"ここで `Nil`構築子は空のリストを表しており、`Cons`は先頭となる要素と尾鰭から"
"空でないリストを作成するために使われます。\n"
"`Cons`の2つ目のフィールドでデータ型 `List a`を使用しており、再帰的なデータ型"
"になっていることに注目してください。"

#. type: Title ##
#: text/chapter5.md:370
#, no-wrap
msgid "Using ADTs"
msgstr "ADTの使用"

#. type: Plain text
#: text/chapter5.md:373
msgid ""
"It is simple enough to use the constructors of an algebraic data type to "
"construct a value: simply apply them like functions, providing arguments "
"corresponding to the data included with the appropriate constructor."
msgstr ""
"代数的データ型の構築子を使用して値を構築するのはとても簡単です。\n"
"対応する構築子に含まれるデータに応じた引数を用意し、その構築子を単に関数のよ"
"うに適用するだけです。"

#. type: Plain text
#: text/chapter5.md:375
msgid ""
"For example, the `Line` constructor defined above required two `Point`s, so "
"to construct a `Shape` using the `Line` constructor, we have to provide two "
"arguments of type `Point`:"
msgstr ""
"例えば、上で定義した `Line`構築子は2つの `Point`を必要としていますので、"
"`Line`構築子を使って `Shape`を構築するには、型 `Point`の2つの引数を与えなけれ"
"ばなりません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:376
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:exampleLine}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:exampleLine}}\n"

#. type: Plain text
#: text/chapter5.md:381
msgid ""
"So, constructing values of algebraic data types is simple, but how do we use "
"them? This is where the important connection with pattern matching appears: "
"the only way to consume a value of an algebraic data type is to use a "
"pattern to match its constructor."
msgstr ""
"さて、代数的データ型で値を構築することは簡単ですが、これをどうやって使ったら"
"よいのでしょうか。\n"
"ここで代数的データ型とパターン照合との重要な接点が見えてきます。\n"
"代数的データ型の値を消費する唯一の方法は構築子に照合するパターンを使うことで"
"す。"

#. type: Plain text
#: text/chapter5.md:383
msgid ""
"Let's see an example. Suppose we want to convert a `Shape` into a `String`. "
"We have to use pattern matching to discover which constructor was used to "
"construct the `Shape`. We can do this as follows:"
msgstr ""
"例を見てみましょう。\n"
"`Shape`を `String`に変換したいとします。\n"
"`Shape`を構築するのにどの構築子が使用されたかを調べるには、パターン照合を使用"
"しなければなりません。\n"
"これには次のようにします。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:384
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showShape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showPoint}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showShape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showPoint}}\n"

#. type: Plain text
#: text/chapter5.md:391
msgid ""
"Each constructor can be used as a pattern, and the arguments to the "
"constructor can themselves be bound using patterns of their own. Consider "
"the first case of `showShape`: if the `Shape` matches the `Circle` "
"constructor, then we bring the arguments of `Circle` (center and radius) "
"into scope using two variable patterns, `c` and `r`. The other cases are "
"similar."
msgstr ""
"各構築子はパターンとして使用でき、構築子への引数はそのパターンで束縛できま"
"す。\n"
"`showShape`の最初の場合を考えてみましょう。\n"
"もし `Shape`が `Circle`構築子に照合した場合、2つの変数パターン `c`と `r`を"
"使って`Circle`の引数（中心と半径）がスコープに導入されます。\n"
"その他の場合も同様です。"

#. type: Bullet: '1. '
#: text/chapter5.md:397
msgid ""
"(Easy) Write a function `circleAtOrigin` which constructs a `Circle` (of "
"type `Shape`) centered at the origin with a radius `10.0`."
msgstr ""
"（簡単）`Circle`（型は`Shape`）を構築する関数`circleAtOrigin`を書いてくださ"
"い。\n"
"中心は原点にあり、半径は`10.0`です。"

#. type: Bullet: '1. '
#: text/chapter5.md:397
msgid ""
"(Medium) Write a function `doubleScaleAndCenter` that scales the size of a "
"`Shape` by a factor of `2.0` and centers it at the origin."
msgstr ""
"（普通）原点を中心として`Shape`の大きさを`2.0`倍に拡大する関数"
"`doubleScaleAndCenter`を書いてみましょう。"

#. type: Bullet: '1. '
#: text/chapter5.md:397
msgid ""
"(Medium) Write a function `shapeText` which extracts the text from a "
"`Shape`. It should return `Maybe String`, and use the `Nothing` constructor "
"if the input is not constructed using `Text`."
msgstr ""
"（普通）`Shape`からテキストを抽出する関数`shapeText`を書いてください。\n"
"この関数は`Maybe String`を返しますが、もし入力が`Text`を使用して構築されたの"
"でなければ、返り値には`Nothing`構築子を使ってください。"

#. type: Title ##
#: text/chapter5.md:398
#, no-wrap
msgid "Newtypes"
msgstr "Newtype"

#. type: Plain text
#: text/chapter5.md:401
msgid ""
"There is a special case of algebraic data types, called _newtypes_. Newtypes "
"are introduced using the `newtype` keyword instead of the `data` keyword."
msgstr ""
"代数的データ型の特殊な場合として、 _newtype_ と呼ばれるものがあります。"
"newtypeはキーワード `data`の代わりにキーワード `newtype`を使用して導入しま"
"す。"

#. type: Plain text
#: text/chapter5.md:403
msgid ""
"Newtypes must define _exactly one_ constructor, and that constructor must "
"take _exactly one_ argument. That is, a newtype gives a new name to an "
"existing type. In fact, the values of a newtype have the same runtime "
"representation as the underlying type, so there is no runtime performance "
"overhead. They are, however, distinct from the point of view of the type "
"system. This gives an extra layer of type safety."
msgstr ""
"newtype宣言では*過不足なく1つだけの*構築子を定義しなければならず、その構築子"
"は*過不足なく1つだけの*引数を取る必要があります。\n"
"つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。\n"
"実際、newtypeの値は、元の型と同じ実行時表現を持ってるので、実行時性能のオー"
"バーヘッドがありません。\n"
"しかし、これらは型システムの観点から区別されます。\n"
"型安全性に追加の層を与えるのです。"

#. type: Plain text
#: text/chapter5.md:405
msgid ""
"As an example, we might want to define newtypes as type-level aliases for "
"`Number`, to ascribe units like volts, amps, and ohms:"
msgstr ""
"例として、ボルト、アンペア、オームのような単位を表現するために、`Number`の型"
"レベルの別名を定義したくなる場合があるかもしれません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:406
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:electricalUnits}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:electricalUnits}}\n"

#. type: Plain text
#: text/chapter5.md:411
msgid "Then we define functions and values using these types:"
msgstr "それからこれらの型を使う関数と値を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:412
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:calculateCurrent}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:calculateCurrent}}\n"

#. type: Plain text
#: text/chapter5.md:417
msgid ""
"This prevents us from making silly mistakes, such as attempting to calculate "
"the current produced by _two_ lightbulbs _without_ a voltage source."
msgstr ""
"これによりつまらないミスを防ぐことができます。例えば電源 _なし_ に _2つ_ の電"
"球により生み出される電流を計算しようとするなどです。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:418
#, no-wrap
msgid ""
"current :: Amp\n"
"current = calculateCurrent lightbulb lightbulb\n"
"{-\n"
"TypesDoNotUnify:\n"
"  current = calculateCurrent lightbulb lightbulb\n"
"                             ^^^^^^^^^\n"
"  Could not match type\n"
"    Ohm\n"
"  with type\n"
"    Volt\n"
"-}\n"
msgstr ""
"current :: Amp\n"
"current = calculateCurrent lightbulb lightbulb\n"
"{-\n"
"TypesDoNotUnify:\n"
"  current = calculateCurrent lightbulb lightbulb\n"
"                             ^^^^^^^^^\n"
"  Could not match type\n"
"    Ohm\n"
"  with type\n"
"    Volt\n"
"-}\n"

#. type: Plain text
#: text/chapter5.md:433
msgid ""
"If we instead just used `Number` without `newtype`, then the compiler can't "
"help us catch this mistake:"
msgstr ""
"もし`newtype`なしに単なる`Number`を使っていたら、コンパイラはこのミスを捕捉で"
"きません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:434
#, no-wrap
msgid ""
"-- This also compiles, but is not as type safe.\n"
"calculateCurrent :: Number -> Number -> Number\n"
"calculateCurrent v r = v / r\n"
"\n"
"battery :: Number\n"
"battery = 1.5\n"
"\n"
"lightbulb :: Number\n"
"lightbulb = 500.0\n"
"\n"
"current :: Number\n"
"current = calculateCurrent lightbulb lightbulb -- uncaught mistake\n"
msgstr ""
"-- これもコンパイルできますが、型安全ではありません。\n"
"calculateCurrent :: Number -> Number -> Number\n"
"calculateCurrent v r = v / r\n"
"\n"
"battery :: Number\n"
"battery = 1.5\n"
"\n"
"lightbulb :: Number\n"
"lightbulb = 500.0\n"
"\n"
"current :: Number\n"
"current = calculateCurrent lightbulb lightbulb -- 捕捉されないミス\n"

#. type: Plain text
#: text/chapter5.md:450
msgid ""
"Note that while a newtype can only have a single constructor, and the "
"constructor must be of a single value, a newtype _can_ take any number of "
"type variables. For example, the following newtype would be a valid "
"definition (`err` and `a` are the type variables, and the `CouldError` "
"constructor expects a _single_ value of type `Either err a`):"
msgstr ""
"なお、newtypeは単一の構築子しかとれず、構築子は単一の値でなくてはなりません"
"が、newtypeは任意の数の型変数を取ることが*できます*。\n"
"例えば以下のnewtypeは妥当な定義です（`err`と`a`は型変数で、`CouldError`構築子"
"は型`Either err a`の*単一*の値を期待します）。"

#. type: Fenced code block (Haskell)
#: text/chapter5.md:451
#, no-wrap
msgid "newtype CouldError err a = CouldError (Either err a)\n"
msgstr "newtype CouldError err a = CouldError (Either err a)\n"

#. type: Plain text
#: text/chapter5.md:456
msgid ""
"Also, note that the constructor of a newtype often has the same name as the "
"newtype itself, but this is not a requirement. For example, unique names are "
"also valid:"
msgstr ""
"また、newtypeの構築子はよくnewtype自身と同じ名前を持つことがあります。\n"
"ただこれは必須ではありません。\n"
"例えば別個の名前であっても正しいものです。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:457
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:Coulomb}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:Coulomb}}\n"

#. type: Plain text
#: text/chapter5.md:462
msgid ""
"In this case, `Coulomb` is the _type constructor_ (of zero arguments), and "
"`MakeCoulomb` is the _data constructor_. These constructors live in "
"different namespaces, even when the names are identical, such as with the "
"`Volt` example. This is true for all ADTs. Note that although the type "
"constructor and data constructor can have different names, in practice, it "
"is idiomatic for them to share the same name. This is the case with `Amp` "
"and `Volt` types above."
msgstr ""
"この場合`Coulomb`は（引数ゼロの）*型構築子*で、`MakeCoulomb`は*データ構築子*"
"です。\n"
"これらの構築子は異なる名前空間に属しており、`Volt`の例でそうだったように、名"
"前には一意性があります。\n"
"これは全てのADTについて言えることです。\n"
"なお、型構築子とデータ構築子には異なる名前を付けられますが、実際には同じ名前"
"を共有するのが普通です。\n"
"前述の`Amp`と`Volt`の場合がこれです。"

#. type: Plain text
#: text/chapter5.md:464
msgid ""
"Another application of newtypes is to attach different _behavior_ to an "
"existing type without changing its representation at runtime. We cover that "
"use case in the next chapter when we discuss _type classes_."
msgstr ""
"newtypeの別の応用は、実行時表現を変えることなく、既存の型に異なる _挙動_ を加"
"えることです。その利用例については次章で _型クラス_ をお話しするときに押さえ"
"ます。"

#. type: Bullet: '1. '
#: text/chapter5.md:468
msgid ""
"(Easy) Define `Watt` as a `newtype` of `Number`. Then define a "
"`calculateWattage` function using this new `Watt` type and the above "
"definitions `Amp` and `Volt`:"
msgstr ""
"（簡単）`Watt`を`Number`の`newtype`として定義してください。それからこの新しい"
"`Watt`型と前述の`Amp`と`Volt`の定義を使って`calculateWattage`関数を定義してく"
"ださい。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:469
#, no-wrap
msgid "calculateWattage :: Amp -> Volt -> Watt\n"
msgstr "calculateWattage :: Amp -> Volt -> Watt\n"

#. type: Plain text
#: text/chapter5.md:474
msgid ""
"A wattage in `Watt`s can be calculated as the product of a given current in "
"`Amp`s and a given voltage in `Volt`s."
msgstr ""
"`Watt`中のワット数は与えられた`Amp`中の電流と与えられた`Volt`の電圧の積で計算"
"できます。"

#. type: Title ##
#: text/chapter5.md:475
#, no-wrap
msgid "A Library for Vector Graphics"
msgstr "ベクターグラフィックスライブラリ"

#. type: Plain text
#: text/chapter5.md:478
msgid ""
"Let's use the data types we have defined above to create a simple library "
"for using vector graphics."
msgstr ""
"これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライ"
"ブラリを作成していきましょう。"

#. type: Plain text
#: text/chapter5.md:480
msgid "Define a type synonym for a `Picture` – just an array of `Shape`s:"
msgstr ""
"`Picture`という型同義語を定義しておきます。\n"
"これはただの`Shape`の配列です。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:481
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:Picture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:Picture}}\n"

#. type: Plain text
#: text/chapter5.md:486
msgid ""
"For debugging purposes, we'll want to be able to turn a `Picture` into "
"something readable. The `showPicture` function lets us do that:"
msgstr ""
"デバッグしていると `Picture`を `String`として表示できるようにしたくなることも"
"あるでしょう。これはパターン照合を使用して定義された `showPicture`関数ででき"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:487
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:showPicture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:showPicture}}\n"

#. type: Plain text
#: text/chapter5.md:492
msgid ""
"Let's try it out. Compile your module with `spago build` and open PSCi with "
"`spago repl`:"
msgstr ""
"試してみましょう。\n"
"モジュールを `spago build`でコンパイルし、 `spago repl`でPSCiを開きます。"

#. type: Fenced code block (text)
#: text/chapter5.md:493
#, no-wrap
msgid ""
"$ spago build\n"
"$ spago repl\n"
"\n"
"> import Data.Picture\n"
"\n"
"> showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]\n"
"\n"
"[\"Line [start: (0.0, 0.0), end: (1.0, 1.0)]\"]\n"
msgstr ""
"$ spago build\n"
"$ spago repl\n"
"\n"
"> import Data.Picture\n"
"\n"
"> showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]\n"
"\n"
"[\"Line [start: (0.0, 0.0), end: (1.0, 1.0)]\"]\n"

#. type: Title ##
#: text/chapter5.md:504
#, no-wrap
msgid "Computing Bounding Rectangles"
msgstr "外接矩形の算出"

#. type: Plain text
#: text/chapter5.md:507
msgid ""
"The example code for this module contains a function `bounds` which computes "
"the smallest bounding rectangle for a `Picture`."
msgstr ""
"このモジュールのコード例には、 `Picture`の最小外接矩形を計算する関数 `bounds`"
"が含まれています。"

#. type: Plain text
#: text/chapter5.md:509
msgid "The `Bounds` type defines a bounding rectangle."
msgstr "`Bounds`型は外接矩形を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:510
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:Bounds}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:Bounds}}\n"

#. type: Plain text
#: text/chapter5.md:515
msgid ""
"`bounds` uses the `foldl` function from `Data.Foldable` to traverse the "
"array of `Shapes` in a `Picture`, and accumulate the smallest bounding "
"rectangle:"
msgstr ""
"`Picture`内の `Shape`の配列を走査し、最小の外接矩形を累算するため、`bounds`に"
"は `Data.Foldable`の `foldl`関数を使用しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:516
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:bounds}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:bounds}}\n"

#. type: Plain text
#: text/chapter5.md:521
msgid ""
"In the base case, we need to find the smallest bounding rectangle of an "
"empty `Picture`, and the empty bounding rectangle defined by `emptyBounds` "
"suffices."
msgstr ""
"基底の場合では、空の `Picture`の最小外接矩形を求める必要がありますが、"
"`emptyBounds`で定義される空の外接矩形がその条件を満たしています。"

#. type: Plain text
#: text/chapter5.md:523
msgid ""
"The accumulating function `combine` is defined in a `where` block. `combine` "
"takes a bounding rectangle computed from `foldl`'s recursive call, and the "
"next `Shape` in the array, and uses the `union` function to compute the "
"union of the two bounding rectangles. The `shapeBounds` function computes "
"the bounds of a single shape using pattern matching."
msgstr ""
"累算関数`combine`は`where`ブロックで定義されています。\n"
"`combine`は`foldl`の再帰呼び出しで計算された外接矩形と、配列内の次の `Shape`"
"を引数に取り、ユーザ定義の演算子`union`を使って2つの外接矩形の和を計算してい"
"ます。\n"
"`shapeBounds`関数は、パターン照合を使用して、単一の図形の外接矩形を計算しま"
"す。"

#. type: Bullet: '1. '
#: text/chapter5.md:528
msgid ""
"(Medium) Extend the vector graphics library with a new operation `area` that "
"computes the area of a `Shape`. For the purpose of this exercise, the area "
"of a line or a piece of text is assumed to be zero."
msgstr ""
"（普通）ベクターグラフィックライブラリを拡張し、`Shape`の面積を計算する新しい"
"操作 `area`を追加してください。\n"
"この演習の目的上は、線分やテキストの面積は0であるものとしてください。"

#. type: Bullet: '1. '
#: text/chapter5.md:528
msgid ""
"(Difficult) Extend the `Shape` type with a new data constructor `Clipped`, "
"which clips another `Picture` to a rectangle. Extend the `shapeBounds` "
"function to compute the bounds of a clipped picture. Note that this makes "
"`Shape` into a recursive data type. _Hint_: The compiler will walk you "
"through extending other functions as required."
msgstr ""
"（難しい）`Shape`型を新しいデータ構築子 `Clipped`で拡張してください。\n"
"`Clipped`は他の `Picture`を矩形に切り抜きます。\n"
"切り抜かれた図形の境界を計算できるよう、`shapeBounds`関数を拡張してくださ"
"い。\n"
"なお、これにより`Shape`は再帰的なデータ型になります。\n"
"*手掛かり* ：コンパイラは必要に応じて他の関数を拡張するのに付き添ってくれるで"
"しょう。"

#. type: Plain text
#: text/chapter5.md:532
msgid ""
"In this chapter, we covered pattern matching, a basic but powerful technique "
"from functional programming. We saw how to use simple patterns as well as "
"array and record patterns to match parts of deep data structures."
msgstr ""
"この章では、関数型プログラミングから基本的ながら強力なテクニックであるパター"
"ン照合を扱いました。複雑なデータ構造の一部分と照合するために、簡単なパターン"
"の使い方だけではなく、配列パターンやレコードパターンを使った深さのあるデータ"
"構造の一部分との照合方法を見てきました。"

#. type: Plain text
#: text/chapter5.md:534
msgid ""
"This chapter also introduced algebraic data types, which are closely related "
"to pattern matching. We saw how algebraic data types allow concise "
"descriptions of data structures and provide a modular way to extend data "
"types with new operations."
msgstr ""
"また、この章ではパターン照合に密接に関連する代数的データ型も紹介しました。\n"
"代数的データ型のおかげでデータ構造を簡潔に記述でき、新たな操作でデータ型を拡"
"張する上で、モジュール性のある方法が齎されるのでした。"

#. type: Plain text
#: text/chapter5.md:536
msgid ""
"Finally, we covered _row polymorphism_, a powerful type of abstraction that "
"allows many idiomatic JavaScript functions to be given a type."
msgstr ""
"最後に*行多相*を扱いました。\n"
"これは強力な抽象化をする型であり、これにより多くの既存のJavaScript関数に型を"
"与えられます。"

#. type: Plain text
#: text/chapter5.md:537
msgid ""
"In the rest of the book, we will use ADTs and pattern matching extensively, "
"so it will pay dividends to become familiar with them now. Try creating your "
"own algebraic data types and writing functions to consume them using pattern "
"matching."
msgstr ""
"本書では今後も代数的データ型とパターン照合をいろんなところで使用するので、今"
"のうちにこれらに習熟しておくと後で実を結ぶことでしょう。これ以外にも独自の代"
"数的データ型を作成し、パターン照合を使用してそれらの型を使う関数を書いてみて"
"ください。"

#. type: Title #
#: text/chapter6.md:1
#, no-wrap
msgid "Type Classes"
msgstr "型クラス"

#. type: Plain text
#: text/chapter6.md:6
msgid ""
"This chapter will introduce a powerful form of abstraction enabled by "
"PureScript's type system – type classes."
msgstr ""
"この章では、PureScriptの型システムにより可能になっている強力な抽象化の形式を"
"導入します。\n"
"そう、型クラスです。"

#. type: Plain text
#: text/chapter6.md:8
msgid ""
"This motivating example for this chapter will be a library for hashing data "
"structures. We will see how the machinery of type classes allows us to hash "
"complex data structures without having to think directly about the structure "
"of the data itself."
msgstr ""
"データ構造をハッシュ化するためのライブラリを本章の動機付けの例とします。\n"
"データ自体の構造について直接考えることなく複雑な構造のデータのハッシュ値を求"
"める上で、型クラスの仕組みがどのように働くかを見ていきます。"

#. type: Plain text
#: text/chapter6.md:10
msgid ""
"We will also see a collection of standard type classes from PureScript's "
"Prelude and standard libraries. PureScript code leans heavily on the power "
"of type classes to express ideas concisely, so it will be beneficial to "
"familiarize yourself with these classes."
msgstr ""
"また、PureScriptのPreludeや標準ライブラリに含まれる、標準的な型クラスも見てい"
"きます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大き"
"く依存しているので、これらのクラスに慣れておくと役に立つでしょう。"

#. type: Plain text
#: text/chapter6.md:12
msgid ""
"If you come from an Object Oriented background, please note that the word "
"\"class\" means something _very_ different in this context than what you're "
"used to. A type class serves a purpose more similar to an OO interface."
msgstr ""
"オブジェクト指向の方面から入って来た方は、「クラス」という単語がそれまで馴染"
"みのあるものとこの文脈とでは _かなり_ 異なるものを意味していることに注意して"
"ください。"

#. type: Plain text
#: text/chapter6.md:16
msgid ""
"The source code for this chapter is defined in the file `src/Data/Hashable."
"purs`."
msgstr ""
"この章のソースコードは、ファイル `src/data/Hashable.purs`で定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`maybe`, which defines the `Maybe` data type, which represents optional "
"values."
msgstr "`maybe`: 省略可能な値を表す `Maybe`データ型が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`tuples`, which defines the `Tuple` data type, which represents pairs of "
"values."
msgstr "`tuples`: 値の組を表す `Tuple`データ型が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`either`, which defines the `Either` data type, which represents disjoint "
"unions."
msgstr "`either`: 非交和を表す `Either`データ型が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid "`strings`, which defines functions that operate on strings."
msgstr "`strings`: 文字列を操作する関数が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`functions`, which defines some helper functions for defining PureScript "
"functions."
msgstr ""
"`functions`: PureScriptの関数を定義するための補助関数が定義されています。"

#. type: Plain text
#: text/chapter6.md:26
msgid ""
"The module `Data.Hashable` imports several modules provided by these "
"packages."
msgstr ""
"モジュール `Data.Hashable`では、これらのパッケージによって提供されるモジュー"
"ルの幾つかをインポートしています。"

#. type: Title ##
#: text/chapter6.md:27
#, no-wrap
msgid "Show Me!"
msgstr "見せて！"

#. type: Plain text
#: text/chapter6.md:30
msgid ""
"Our first simple example of a type class is provided by a function we've "
"seen several times already: the `show` function, which takes a value and "
"displays it as a string."
msgstr ""
"型クラスの最初の簡単な例は、既に何回か見たことがある関数で提供されていま"
"す。\n"
"`show`は何らかの値を取り、文字列として表示する関数です。"

#. type: Plain text
#: text/chapter6.md:32
msgid ""
"`show` is defined by a type class in the `Prelude` module called `Show`, "
"which is defined as follows:"
msgstr ""
"`show`は `Prelude`モジュールの `Show`と呼ばれる型クラスで次のように定義されて"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:33
#, no-wrap
msgid ""
"class Show a where\n"
"  show :: a -> String\n"
msgstr ""
"class Show a where\n"
"  show :: a -> String\n"

#. type: Plain text
#: text/chapter6.md:39
msgid ""
"This code declares a new _type class_ called `Show`, which is parameterized "
"by the type variable `a`."
msgstr ""
"このコードでは、型変数`a`を引数に取る`Show`という新しい*型クラス*を宣言してい"
"ます。"

#. type: Plain text
#: text/chapter6.md:41
msgid ""
"A type class _instance_ contains implementations of the functions defined in "
"a type class, specialized to a particular type."
msgstr ""
"型クラス _インスタンス_ には、型クラスで定義された関数の、その型に特殊化され"
"た実装が含まれています。"

#. type: Plain text
#: text/chapter6.md:43
msgid ""
"For example, here is the definition of the `Show` type class instance for "
"`Boolean` values, taken from the Prelude:"
msgstr ""
"例えば、Preludeにある `Boolean`値に対する `Show`型クラスインスタンスの定義は"
"次の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:44
#, no-wrap
msgid ""
"instance Show Boolean where\n"
"  show true = \"true\"\n"
"  show false = \"false\"\n"
msgstr ""
"instance Show Boolean where\n"
"  show true = \"true\"\n"
"  show false = \"false\"\n"

#. type: Plain text
#: text/chapter6.md:51
msgid ""
"This code declares a type class instance called `showBoolean` – in "
"PureScript, type class instances can be named to aid the readability of the "
"generated JavaScript. We say that the `Boolean` type _belongs to the `Show` "
"type class_."
msgstr ""
"このコードは `showBool​​ean`という名前の型クラスのインスタンスを宣言します。\n"
"PureScriptでは、生成されたJavaScriptの可読性を良くするために、型クラスインス"
"タンスに名前を付けられます。\n"
"このとき、`Boolean`型は*`Show`型クラスに属している*といいます。"

#. type: Plain text
#: text/chapter6.md:53
msgid ""
"We can try out the `Show` type class in PSCi, by showing a few values with "
"different types:"
msgstr "PSCiで、いろいろな型の値を`Show`型クラスを使って表示してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:54
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> show true\n"
"\"true\"\n"
"\n"
"> show 1.0\n"
"\"1.0\"\n"
"\n"
"> show \"Hello World\"\n"
"\"\\\"Hello World\\\"\"\n"
msgstr ""
"> import Prelude\n"
"\n"
"> show true\n"
"\"true\"\n"
"\n"
"> show 1.0\n"
"\"1.0\"\n"
"\n"
"> show \"Hello World\"\n"
"\"\\\"Hello World\\\"\"\n"

#. type: Plain text
#: text/chapter6.md:68
msgid ""
"These examples demonstrate how to `show` values of various primitive types, "
"but we can also `show` values with more complicated types:"
msgstr ""
"この例では様々な原始型の値を `show`しましたが、もっと複雑な型を持つ値も`show`"
"できます。"

#. type: Fenced code block (text)
#: text/chapter6.md:69
#, no-wrap
msgid ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"
msgstr ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"

#. type: Plain text
#: text/chapter6.md:82
msgid ""
"The output of `show` should be a string that you can paste back into the "
"repl (or `.purs` file) to recreate the item being shown. Here we'll use "
"`logShow`, which just calls `show` and then `log`, to render the string "
"without quotes. Ignore the `unit` print – that will be covered in Chapter 8 "
"when we examine `Effect`s, like `log`."
msgstr ""
"`show`の出力は、REPLに（あるいは`.purs`ファイルに）貼り戻せば、表示されたもの"
"を再作成できるような文字列であるべきです。\n"
"以下では`logShow`を使っていますが、これは単に`show`と`log`を順に呼び出すもの"
"であり、引用符なしに文字列が表示されます。\n"
"`unit`の表示は無視してください。\n"
"第8章で`log`のような`Effect`を調べるときに押さえます。"

#. type: Fenced code block (text)
#: text/chapter6.md:83
#, no-wrap
msgid ""
"> import Effect.Console\n"
"\n"
"> logShow (Tuple 1 true)\n"
"(Tuple 1 true)\n"
"unit\n"
"\n"
"> logShow (Just \"testing\")\n"
"(Just \"testing\")\n"
"unit\n"
msgstr ""
"> import Effect.Console\n"
"\n"
"> logShow (Tuple 1 true)\n"
"(Tuple 1 true)\n"
"unit\n"
"\n"
"> logShow (Just \"testing\")\n"
"(Just \"testing\")\n"
"unit\n"

#. type: Plain text
#: text/chapter6.md:96
msgid ""
"If we try to show a value of type `Data.Either`, we get an interesting error "
"message:"
msgstr ""
"型 `Data.Either`の値を表示しようとすると、興味深いエラー文言が表示されます。"

#. type: Fenced code block (text)
#: text/chapter6.md:97
#, no-wrap
msgid ""
"> import Data.Either\n"
"> show (Left 10)\n"
"\n"
"The inferred type\n"
"\n"
"    forall a. Show a => String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"> import Data.Either\n"
"> show (Left 10)\n"
"\n"
"The inferred type\n"
"\n"
"    forall a. Show a => String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:109
msgid ""
"The problem here is not that there is no `Show` instance for the type we "
"intended to `show`, but rather that PSCi could not infer the type. This is "
"indicated by the _unknown type_ `a` in the inferred type."
msgstr ""
"ここでの問題は `show`しようとしている型に対する `Show`インスタンスが存在しな"
"いということではなく、PSCiがこの型を推論できなかったということです。\n"
"これは推論された型で*未知の型*`a`とされていることが示しています。"

#. type: Plain text
#: text/chapter6.md:111
msgid ""
"We can annotate the expression with a type using the `::` operator, so that "
"PSCi can choose the correct type class instance:"
msgstr ""
"`::`演算子を使って式に註釈を付けてPSCiが正しい型クラスインスタンスを選べるよ"
"うにできます。"

#. type: Fenced code block (text)
#: text/chapter6.md:112
#, no-wrap
msgid ""
"> show (Left 10 :: Either Int String)\n"
"\"(Left 10)\"\n"
msgstr ""
"> show (Left 10 :: Either Int String)\n"
"\"(Left 10)\"\n"

#. type: Plain text
#: text/chapter6.md:118
#, no-wrap
msgid "Some types do not have a `Show` instance defined at all. One example of this is the function type `->`. If we try to `show` a function from `Int` to `Int`, we get an appropriate error message from the type checker:\n"
msgstr ""
"`Show`インスタンスを全く持っていない型もあります。\n"
"関数の型 `->`がその一例です。\n"
"`Int`から `Int`への関数を `show`しようとすると、型検証器によってその旨のエラー文言が表示されます。\n"

#. type: Fenced code block (text)
#: text/chapter6.md:119
#, no-wrap
msgid ""
"> import Prelude\n"
"> show $ \\n -> n + 1\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Data.Show.Show (Int -> Int)\n"
msgstr ""
"> import Prelude\n"
"> show $ \\n -> n + 1\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Data.Show.Show (Int -> Int)\n"

#. type: Plain text
#: text/chapter6.md:129
msgid ""
"Type class instances can be defined in one of two places: in the same module "
"that the type class is defined, or in the same module that the type "
"\"belonging to\" the type class is defined. An instance defined in any other "
"spot is called an [\"orphan instance\"](https://github.com/purescript/"
"documentation/blob/master/language/Type-Classes.md#orphan-instances) and is "
"not allowed by the PureScript compiler. Some of the exercises in this "
"chapter will require you to copy the definition of a type into your "
"MySolutions module so that you can define type class instances for that type."
msgstr ""
"型クラスインスタンスは次の2つのうち何れかの形で定義されます。\n"
"型クラスが定義されている同じモジュールで定義するか、型クラスに「属して」いる"
"型と同じモジュールで定義するかです。\n"
"これらとは別の場所で定義されるインスタンスは[「孤立インスタンス」](https://"
"github.com/purescript/documentation/blob/master/language/Type-Classes."
"md#orphan-instances)と呼ばれ、PureScriptコンパイラでは許されていません。\n"
"この章の演習の幾つかでは、その型の型クラスインスタンスを定義できるように、型"
"の定義を自分の`MySolutions`モジュールに複製する必要があります。"

#. type: Bullet: '1. '
#: text/chapter6.md:133
msgid ""
"(Easy) Define a `Show` instance for `Point`. Match the same output as the "
"`showPoint` function from the previous chapter. _Note:_ Point is now a "
"`newtype` (instead of a `type` synonym), which allows us to customize how to "
"`show` it. Otherwise, we'd be stuck with the default `Show` instance for "
"records."
msgstr ""
"（簡単）`Show`インスタンスを`Point`に定義してください。\n"
"前の章の`showPoint`関数と同じ出力に一致するようにしてください。\n"
"*補足*：`Point`はここでは（`type`同義語ではなく）`newtype`です。\n"
"そのため`show`の仕方を変えられます。\n"
"こうでもしないとレコードへの既定の`Show`インスタンスから逃れられません。"

#. type: Plain text
#: text/chapter6.md:137
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Point}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Point}}\n"
"    ```\n"

#. type: Title ##
#: text/chapter6.md:138
#, no-wrap
msgid "Common Type Classes"
msgstr "よく見かける型クラス"

#. type: Plain text
#: text/chapter6.md:141
msgid ""
"In this section, we'll look at some standard type classes defined in the "
"Prelude and standard libraries. These type classes form the basis of many "
"common patterns of abstraction in idiomatic PureScript code, so a basic "
"understanding of their functions is highly recommended."
msgstr ""
"この節では、Preludeや標準ライブラリで定義されている標準的な型クラスを幾つか見"
"ていきましょう。\n"
"これらの型クラスはPureScript特有の抽象化をする上で多くのよくあるパターンの基"
"礎を形成しています。\n"
"そのため、これらの関数の基本についてよく理解しておくことを強くお勧めします。"

#. type: Title ###
#: text/chapter6.md:142
#, no-wrap
msgid "Eq"
msgstr "Eq"

#. type: Plain text
#: text/chapter6.md:145
msgid ""
"The `Eq` type class defines the `eq` function, which tests two values for "
"equality. The `==` operator is actually an alias for `eq`."
msgstr ""
"`Eq`型クラスは`eq`関数を定義しています。\n"
"この関数は2つの値について等値性を調べます。\n"
"実は`==`演算子は`eq`の別名です。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:146
#, no-wrap
msgid ""
"class Eq a where\n"
"  eq :: a -> a -> Boolean\n"
msgstr ""
"class Eq a where\n"
"  eq :: a -> a -> Boolean\n"

#. type: Plain text
#: text/chapter6.md:152
msgid ""
"In either case, the two arguments must have the same type: it does not make "
"sense to compare two values of different types for equality."
msgstr ""
"何れにせよ、2つの引数は同じ型を持つ必要があります。\n"
"異なる型の2つの値を等値性に関して比較しても意味がありません。"

#. type: Plain text
#: text/chapter6.md:154
msgid "Try out the `Eq` type class in PSCi:"
msgstr "PSCiで `Eq`型クラスを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:155
#, no-wrap
msgid ""
"> 1 == 2\n"
"false\n"
"\n"
"> \"Test\" == \"Test\"\n"
"true\n"
msgstr ""
"> 1 == 2\n"
"false\n"
"\n"
"> \"Test\" == \"Test\"\n"
"true\n"

#. type: Title ###
#: text/chapter6.md:163
#, no-wrap
msgid "Ord"
msgstr "Ord"

#. type: Plain text
#: text/chapter6.md:166
#, no-wrap
msgid "The `Ord` type class defines the `compare` function, which can be used to compare two values, for types that support ordering. The comparison operators `<` and `>` along with their non-strict companions `<=` and `>=`, can be defined in terms of `compare`.\n"
msgstr ""
"`Ord`型クラスは`compare`関数を定義します。\n"
"この関数は2つの値を比較するのに使えるもので、その値の型は順序付けに対応したものです。\n"
"比較演算子`<`、`>`と厳密な大小比較ではない`<=`、`>=`は`compare`を用いて定義されます。\n"

#. type: Plain text
#: text/chapter6.md:168
#, no-wrap
msgid "_Note_: In the example below, the class signature contains `<=`. This usage of `<=` in this context indicates that Eq is a subclass of Ord and is not intended to represent the use of `<=` as a comparison operator. See the section [Superclasses](#superclasses) below.\n"
msgstr ""
"*補足*：以下の例ではクラスシグネチャに`<=`が含まれています。\n"
"この文脈での`<=`の使われ方はEqがOrdの上位クラスであり、比較演算子としての`<=`の用途を表す意図はありません。\n"
"後述の[上位クラス](#上位クラス)の節を参照してください。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:169
#, no-wrap
msgid ""
"data Ordering = LT | EQ | GT\n"
"\n"
"class Eq a <= Ord a where\n"
"  compare :: a -> a -> Ordering\n"
msgstr ""
"data Ordering = LT | EQ | GT\n"
"\n"
"class Eq a <= Ord a where\n"
"  compare :: a -> a -> Ordering\n"

#. type: Plain text
#: text/chapter6.md:177
msgid ""
"The `compare` function compares two values and returns an `Ordering`, which "
"has three alternatives:"
msgstr ""
"`compare`関数は2つの値を比較して`Ordering`を返します。\n"
"これには3つ選択肢があります。"

#. type: Bullet: '- '
#: text/chapter6.md:181
msgid "`LT` – if the first argument is less than the second."
msgstr "`LT`- 最初の引数が2番目の値より小さいとき。"

#. type: Bullet: '- '
#: text/chapter6.md:181
msgid "`EQ` – if the first argument is equal to the second."
msgstr "`EQ`- 最初の引数が2番目の値と等しいとき。"

#. type: Bullet: '- '
#: text/chapter6.md:181
msgid "`GT` – if the first argument is greater than the second."
msgstr "`GT`- 最初の引数が2番目の値より大きいとき。"

#. type: Plain text
#: text/chapter6.md:183
msgid "Again, we can try out the `compare` function in PSCi:"
msgstr "ここでも`compare`関数についてPSCiで試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:184
#, no-wrap
msgid ""
"> compare 1 2\n"
"LT\n"
"\n"
"> compare \"A\" \"Z\"\n"
"LT\n"
msgstr ""
"> compare 1 2\n"
"LT\n"
"\n"
"> compare \"A\" \"Z\"\n"
"LT\n"

#. type: Title ###
#: text/chapter6.md:192
#, no-wrap
msgid "Field"
msgstr "Field"

#. type: Plain text
#: text/chapter6.md:195
msgid ""
"The `Field` type class identifies those types which support numeric "
"operators such as addition, subtraction, multiplication, and division. It is "
"provided to abstract over those operators, so that they can be reused where "
"appropriate."
msgstr ""
"`Field`型クラスは加算、減算、乗算、除算などの数値演算子に対応した型を示しま"
"す。\n"
"これらの演算子を抽象化して提供されているので、適切な場合に再利用できるので"
"す。"

#. type: Plain text
#: text/chapter6.md:197
#, no-wrap
msgid "> _Note_: Just like the `Eq` and `Ord` type classes, the `Field` type class has special support in the PureScript compiler, so that simple expressions such as `1 + 2 * 3` get translated into simple JavaScript, as opposed to function calls which dispatch based on a type class implementation.\n"
msgstr ""
"> *補足*：型クラス`Eq`ないし`Ord`とちょうど同じように、`Field`型クラスはPureScriptコンパイラで特別に扱われ、`1 + 2 * 3`のような単純な式は単純なJavaScriptへと変換されます。\n"
"> 型クラスの実装に基いて呼び出される関数呼び出しとは対照的です。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:198
#, no-wrap
msgid "class EuclideanRing a <= Field a\n"
msgstr "class EuclideanRing a <= Field a\n"

#. type: Plain text
#: text/chapter6.md:203
msgid ""
"The `Field` type class is composed from several more general _superclasses_. "
"This allows us to talk abstractly about types that support some but not all "
"of the `Field` operations. For example, a type of natural numbers would be "
"closed under addition and multiplication, but not necessarily under "
"subtraction, so that type might have an instance of the `Semiring` class "
"(which is a superclass of `Num`), but not an instance of `Ring` or `Field`."
msgstr ""
"`Field`型クラスは、幾つかのより抽象的な*上位クラス*が組み合わさってできていま"
"す。\n"
"このため、`Field`の操作の全てを提供しているわけではないが、その一部を提供する"
"型について抽象的に説明できます。\n"
"例えば、自然数の型は加算及び乗算については閉じていますが、減算については必ず"
"しも閉じていません。\n"
"そのため、この型は`Semiring`クラス（これは`Num`の上位クラスです）のインスタン"
"スですが、`Ring`や`Field`のインスタンスではありません。"

#. type: Plain text
#: text/chapter6.md:205
msgid ""
"Superclasses will be explained later in this chapter, but the full [numeric "
"type class hierarchy](https://a-guide-to-the-purescript-numeric-hierarchy."
"readthedocs.io/en/latest/introduction.html) ([cheatsheet](https://harry."
"garrood.me/numeric-hierarchy-overview/)) is beyond the scope of this "
"chapter. The interested reader is encouraged to read the documentation for "
"the superclasses of `Field` in `prelude`."
msgstr ""
"上位クラスについては、この章の後半で詳しく説明します。\n"
"しかし、全ての[数値型クラスの階層](https://a-guide-to-the-purescript-numeric-"
"hierarchy.readthedocs.io/en/latest/introduction.html)（[チートシート]"
"(https://harry.garrood.me/numeric-hierarchy-overview/)）について述べるのはこ"
"の章の目的から外れています。\n"
"この内容に興味のある読者は`prelude`内の `Field`に関するドキュメントを参照して"
"ください。"

#. type: Title ###
#: text/chapter6.md:206
#, no-wrap
msgid "Semigroups and Monoids"
msgstr "半群とモノイド"

#. type: Plain text
#: text/chapter6.md:209
msgid ""
"The `Semigroup` type class identifies those types which support an `append` "
"operation to combine two values:"
msgstr ""
"`Semigroup`（半群）型クラスは、2つの値を連結する演算子 `append`を提供する型を"
"示します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:210
#, no-wrap
msgid ""
"class Semigroup a where\n"
"  append :: a -> a -> a\n"
msgstr ""
"class Semigroup a where\n"
"  append :: a -> a -> a\n"

#. type: Plain text
#: text/chapter6.md:216
msgid ""
"Strings form a semigroup under regular string concatenation, and so do "
"arrays. The `prelude` package provides several other standard instances."
msgstr ""
"文字列は普通の文字列連結について半群をなし、配列も同様です。\n"
"その他の標準的なインスタンスは`prelude`パッケージで提供されています。"

#. type: Plain text
#: text/chapter6.md:218
#, no-wrap
msgid "The `<>` concatenation operator, which we have already seen, is provided as an alias for `append`.\n"
msgstr "以前に見た `<>`連結演算子は、 `append`の別名として提供されています。\n"

#. type: Plain text
#: text/chapter6.md:220
msgid ""
"The `Monoid` type class (provided by the `prelude` package) extends the "
"`Semigroup` type class with the concept of an empty value, called `mempty`:"
msgstr ""
"（`prelude`パッケージで提供されている）`Monoid`型クラスには`mempty`という名前"
"の空の値の概念があり、`Semigroup`型クラスを拡張します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:221
#, no-wrap
msgid ""
"class Semigroup m <= Monoid m where\n"
"  mempty :: m\n"
msgstr ""
"class Semigroup m <= Monoid m where\n"
"  mempty :: m\n"

#. type: Plain text
#: text/chapter6.md:227
msgid "Again, strings and arrays are simple examples of monoids."
msgstr "ここでも文字列や配列はモノイドの簡単な例になっています。"

#. type: Plain text
#: text/chapter6.md:229
msgid ""
"A `Monoid` type class instance for a type describes how to _accumulate_ a "
"result with that type by starting with an \"empty\" value and combining new "
"results. For example, we can write a function that concatenates an array of "
"values in some monoid using a fold. In PSCi:"
msgstr ""
"ある型にとっての`Monoid`型クラスインスタンスとは、「空」の値から始めて新たな"
"結果に組み合わせ、その型を持つ結果を*累算*する方法を記述するものです。\n"
"例えば、畳み込みを使って何らかのモノイドの値の配列を連結する関数を書けま"
"す。\n"
"PSCiで以下の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:230
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.Monoid\n"
"> import Data.Foldable\n"
"\n"
"> foldl append mempty [\"Hello\", \" \", \"World\"]\n"
"\"Hello World\"\n"
"\n"
"> foldl append mempty [[1, 2, 3], [4, 5], [6]]\n"
"[1,2,3,4,5,6]\n"
msgstr ""
"> import Prelude\n"
"> import Data.Monoid\n"
"> import Data.Foldable\n"
"\n"
"> foldl append mempty [\"Hello\", \" \", \"World\"]\n"
"\"Hello World\"\n"
"\n"
"> foldl append mempty [[1, 2, 3], [4, 5], [6]]\n"
"[1,2,3,4,5,6]\n"

#. type: Plain text
#: text/chapter6.md:243
msgid ""
"The `prelude` package provides many examples of monoids and semigroups, "
"which we will use in the rest of the book."
msgstr ""
"`prelude`パッケージにはモノイドと半群の多くの例を提供しており、以降もこれらを"
"本書で扱っていきます。"

#. type: Title ###
#: text/chapter6.md:244
#, no-wrap
msgid "Foldable"
msgstr "Foldable"

#. type: Plain text
#: text/chapter6.md:247
msgid ""
"If the `Monoid` type class identifies those types which act as the result of "
"a fold, then the `Foldable` type class identifies those type constructors "
"which can be used as the source of a fold."
msgstr ""
"`Monoid`型クラスが畳み込みの結果になるような型を示す一方、`Foldable`型クラス"
"は畳み込みの元のデータとして使えるような型構築子を示しています。"

#. type: Plain text
#: text/chapter6.md:249
msgid ""
"The `Foldable` type class is provided in the `foldable-traversable` package, "
"which also contains instances for some standard containers such as arrays "
"and `Maybe`."
msgstr ""
"また、 `Foldable`型クラスは配列や `Maybe`などの幾つかの標準的なコンテナのイン"
"スタンスを含む`foldable-traversable`パッケージで提供されています。"

#. type: Plain text
#: text/chapter6.md:251
msgid ""
"The type signatures for the functions belonging to the `Foldable` class are "
"a little more complicated than the ones we've seen so far:"
msgstr ""
"`Foldable`クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し"
"複雑です。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:252
#, no-wrap
msgid ""
"class Foldable f where\n"
"  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n"
"  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n"
"  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n"
msgstr ""
"class Foldable f where\n"
"  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n"
"  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n"
"  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n"

#. type: Plain text
#: text/chapter6.md:260
msgid ""
"It is instructive to specialize to the case where `f` is the array type "
"constructor. In this case, we can replace `f a` with `Array a` for any a, "
"and we notice that the types of `foldl` and `foldr` become the types we saw "
"when we first encountered folds over arrays."
msgstr ""
"`f`を配列の型構築子として特殊化すると分かりやすいです。\n"
"この場合、任意の`a`について`f a`を`Array a`に置き換えられますが、そうすると"
"`foldl`と`foldr`の型が、最初に配列に対する畳み込みで見た型になると気付きま"
"す。"

#. type: Plain text
#: text/chapter6.md:262
#, no-wrap
msgid "What about `foldMap`? Well, that becomes `forall a m. Monoid m => (a -> m) -> Array a -> m`. This type signature says that we can choose any type `m` for our result type, as long as that type is an instance of the `Monoid` type class. If we can provide a function that turns our array elements into values in that monoid, then we can accumulate over our array using the structure of the monoid and return a single value.\n"
msgstr ""
"`foldMap`についてはどうでしょうか。\n"
"これは `forall a m. Monoid m => (a -> m) -> Array a -> m`になります。\n"
"この型シグネチャでは、型`m`が`Monoid`型クラスのインスタンスであれば、返り値の型として任意に選べると書かれています。\n"
"配列の要素をそのモノイドの値へと変える関数を与えられれば、そのモノイドの構造を利用して配列上で累算し、1つの値にして返せます。\n"

#. type: Plain text
#: text/chapter6.md:264
msgid "Let's try out `foldMap` in PSCi:"
msgstr "それではPSCiで `foldMap`を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:265
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> foldMap show [1, 2, 3, 4, 5]\n"
"\"12345\"\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> foldMap show [1, 2, 3, 4, 5]\n"
"\"12345\"\n"

#. type: Plain text
#: text/chapter6.md:273
msgid ""
"Here, we choose the monoid for strings, which concatenates strings together, "
"and the `show` function, which renders an `Int` as a `String`. Then, passing "
"in an array of integers, we see that the results of `show`ing each integer "
"have been concatenated into a single `String`."
msgstr ""
"ここでは文字列用のモノイドと`show`関数を選んでいます。\n"
"前者は文字列を連結するもので、後者は`Int`を文字列として書き出すものです。\n"
"そうして数の配列を渡すと、それぞれの数を`show`して1つの文字列へと連結した結果"
"を得ました。"

#. type: Plain text
#: text/chapter6.md:275
msgid ""
"But arrays are not the only types that are foldable. `foldable-traversable` "
"also defines `Foldable` instances for types like `Maybe` and `Tuple`, and "
"other libraries like `lists` define `Foldable` instances for their own data "
"types. `Foldable` captures the notion of an _ordered container_."
msgstr ""
"しかし畳み込み可能な型は配列だけではありません。\n"
"`foldable-traversable`では`Maybe`や`Tuple`のような型にも`Foldable`インスタン"
"スが定義されており、`lists`のような他のライブラリでは、各々のデータ型に対して"
"`Foldable`インスタンスが定義されています。\n"
"`Foldable`は*順序付きコンテナ*の概念を見据えたものなのです。"

#. type: Title ###
#: text/chapter6.md:276
#, no-wrap
msgid "Functor and Type Class Laws"
msgstr "関手と型クラス則"

#. type: Plain text
#: text/chapter6.md:279
msgid ""
"The Prelude also defines a collection of type classes that enable a "
"functional style of programming with side-effects in PureScript: `Functor`, "
"`Applicative`, and `Monad`. We will cover these abstractions later in the "
"book, but for now, let's look at the definition of the `Functor` type class, "
"which we have seen already in the form of the `map` function:"
msgstr ""
"PureScriptでは、副作用を伴う関数型プログラミングのスタイルを可能にするための"
"型クラスの集まりも定義されています。\n"
"`Functor`や`Applicative`、`Monad`といったものです。\n"
"これらの抽象化については後ほど本書で扱いますが、ここでは`Functor`型クラスの定"
"義を見てみましょう。\n"
"既に`map`関数の形で見たものです。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:280
#, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
msgstr ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter6.md:286
#, no-wrap
msgid "The `map` function (and its alias `<$>`) allows a function to be \"lifted\" over a data structure. The precise definition of the word \"lifted\" here depends on the data structure in question, but we have already seen its behavior for some simple types:\n"
msgstr ""
"`map`関数（別名`<$>`）は関数をそのデータ構造まで「持ち上げる」(lift) ことができます。\n"
"ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、既に幾つかの単純な型についてその動作を見てきました。\n"

#. type: Fenced code block (text)
#: text/chapter6.md:287
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> map (\\n -> n < 3) [1, 2, 3, 4, 5]\n"
"[true, true, false, false, false]\n"
"\n"
"> import Data.Maybe\n"
"> import Data.String (length)\n"
"\n"
"> map length (Just \"testing\")\n"
"(Just 7)\n"
msgstr ""
"> import Prelude\n"
"\n"
"> map (\\n -> n < 3) [1, 2, 3, 4, 5]\n"
"[true, true, false, false, false]\n"
"\n"
"> import Data.Maybe\n"
"> import Data.String (length)\n"
"\n"
"> map length (Just \"testing\")\n"
"(Just 7)\n"

#. type: Plain text
#: text/chapter6.md:301
msgid ""
"How can we understand the meaning of the `map` function, when it acts on "
"many different structures, each in a different way?"
msgstr ""
"`map`演算子は様々な構造の上でそれぞれ異なる挙動をしますが、 `map`演算子の意味"
"はどのように理解すればいいのでしょうか。"

#. type: Plain text
#: text/chapter6.md:303
msgid ""
"Well, we can build an intuition that the `map` function applies the function "
"it is given to each element of a container, and builds a new container from "
"the results, with the same shape as the original. But how do we make this "
"concept precise?"
msgstr ""
"直感的には、 `map`演算子はコンテナのそれぞれの要素へ関数を適用し、その結果か"
"ら元のデータと同じ形状を持った新しいコンテナを構築するものとできます。\n"
"しかし、この着想を精密にするにはどうしたらいいでしょうか。"

#. type: Plain text
#: text/chapter6.md:305
msgid ""
"Type class instances for `Functor` are expected to adhere to a set of "
"_laws_, called the _functor laws_:"
msgstr ""
"`Functor`の型クラスのインスタンスは、*関手則*と呼ばれる法則を順守するものと期"
"待されています。"

#. type: Bullet: '- '
#: text/chapter6.md:308
msgid "`map identity xs = xs`"
msgstr "`map identity xs = xs`"

#. type: Bullet: '- '
#: text/chapter6.md:308
msgid "`map g (map f xs) = map (g <<< f) xs`"
msgstr "`map g (map f xs) = map (g <<< f) xs`"

#. type: Plain text
#: text/chapter6.md:310
msgid ""
"The first law is the _identity law_. It states that lifting the identity "
"function (the function which returns its argument unchanged) over a "
"structure just returns the original structure. This makes sense since the "
"identity function does not modify its input."
msgstr ""
"最初の法則は _恒等射律_ (identity law) です。これは、恒等関数（引数を変えずに"
"返す関数）をその構造まで持ち上げると、元の構造をそのまま返すという意味です。"
"恒等関数は入力を変更しませんから、これは理にかなっています。"

#. type: Plain text
#: text/chapter6.md:312
msgid ""
"The second law is the _composition law_. It states that mapping one function "
"over a structure and then mapping a second is the same as mapping the "
"composition of the two functions over the structure."
msgstr ""
"第2の法則は*合成律*です。\n"
"構造を1つの関数で写してから2つめの関数で写すのは、2つの関数の合成で構造を写す"
"のと同じだ、と言っています。"

#. type: Plain text
#: text/chapter6.md:314
msgid ""
"Whatever \"lifting\" means in the general sense, it should be true that any "
"reasonable definition of lifting a function over a data structure should "
"obey these rules."
msgstr ""
"「持ち上げ」の一般的な意味が何であれ、データ構造に対する持ち上げ関数の正しい"
"定義はこれらの法則に従っていなければなりません。"

#. type: Plain text
#: text/chapter6.md:316
msgid ""
"Many standard type classes come with their own set of similar laws. The laws "
"given to a type class give structure to the functions of that type class and "
"allow us to study its instances in generality. The interested reader can "
"research the laws ascribed to the standard type classes that we have seen "
"already."
msgstr ""
"標準の型クラスの多くには、このような法則が付随しています。\n"
"一般に、型クラスに与えられた法則は、型クラスの関数に構造を与え、普遍的にイン"
"スタンスについて調べられるようにします。\n"
"興味のある読者は、既に見てきた標準の型クラスに属する法則について調べてみても"
"よいでしょう。"

#. type: Title ###
#: text/chapter6.md:317
#, no-wrap
msgid "Deriving Instances"
msgstr "インスタンスの導出"

#. type: Plain text
#: text/chapter6.md:320
msgid ""
"Rather than writing instances manually, you can let the compiler do most of "
"the work for you. Take a look at this [Type Class Deriving guide](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md). That information will help you solve the following exercises."
msgstr ""
"インスタンスを手作業で描く代わりに、ほとんどの作業をコンパイラにさせることが"
"できます。\n"
"この[型クラス導出手引き](https://github.com/purescript/documentation/blob/"
"master/guides/Type-Class-Deriving.md)を見てください。\n"
"そちらの情報が以下の演習を解く手助けになることでしょう。"

#. type: Plain text
#: text/chapter6.md:324
msgid "The following newtype represents a complex number:"
msgstr "（簡単）次のnewtypeは複素数を表します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:325
#, no-wrap
msgid "{{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Complex}}\n"
msgstr "{{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Complex}}\n"

#. type: Bullet: '1. '
#: text/chapter6.md:330
msgid ""
"(Easy) Define a `Show` instance for `Complex`. Match the output format "
"expected by the tests (e.g. `1.2+3.4i`, `5.6-7.8i`, etc.)."
msgstr ""
"（簡単）`Complex`に`Show`インスタンスを定義してください。\n"
"出力の形式はテストで期待される形式と一致させてください（例：`1.2+3.4i`、"
"`5.6-7.7i`など）。"

#. type: Bullet: '2. '
#: text/chapter6.md:332
msgid ""
"(Easy) Derive an `Eq` instance for `Complex`. _Note_: You may instead write "
"this instance manually, but why do more work if you don't have to?"
msgstr ""
"（簡単）`Eq`インスタンスを`Complex`に導出してください。\n"
"*補足*：代わりにこのインスタンスを手作業で書いてもよいですが、しなくていいの"
"になぜすることがありましょう。"

#. type: Bullet: '3. '
#: text/chapter6.md:334
msgid ""
"(Medium) Define a `Semiring` instance for `Complex`. _Note_: You can use "
"`wrap` and `over2` from [`Data.Newtype`](https://pursuit.purescript.org/"
"packages/purescript-newtype/docs/Data.Newtype) to create a more concise "
"solution. If you do so, you will also need to import `class Newtype` from "
"`Data.Newtype` and derive a `Newtype` instance for `Complex`."
msgstr ""
"（普通）`Semiring`インタンスを`Complex`に定義してください。\n"
"*補足*：[`Data.Newtype`](https://pursuit.purescript.org/packages/purescript-"
"newtype/docs/Data.Newtype)の`wrap`と`over2`を使ってより簡潔な解答を作れま"
"す。\n"
"もしそうするのでしたら、`Data.Newtype`から`class Newtype`をインポートしたり、"
"`Newtype`インスタンスを`Complex`に導出したりする必要も出てくるでしょう。"

#. type: Bullet: '4. '
#: text/chapter6.md:336
msgid ""
"(Easy) Derive (via `newtype`) a `Ring` instance for `Complex`. _Note_: You "
"may instead write this instance manually, but that's not as convenient."
msgstr ""
"（簡単）（`newtype`を介して）`Ring`インスタンスを`Complex`に導出してくださ"
"い。\n"
"*補足*：代わりにこのインスタンスを手作業で書くこともできますが、そう手軽には"
"できません。"

#. type: Plain text
#: text/chapter6.md:338
#, no-wrap
msgid "    Here's the `Shape` ADT from the previous chapter:\n"
msgstr "    以下は前章からの`Shape`のADTです。\n"

#. type: Plain text
#: text/chapter6.md:342
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Shape}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Shape}}\n"
"    ```\n"

#. type: Bullet: '5. '
#: text/chapter6.md:344
msgid ""
"(Medium) Derive (via `Generic`) a `Show` instance for `Shape`. How does the "
"amount of code written and `String` output compare to `showShape` from the "
"previous chapter? _Hint_: See the [Deriving from `Generic`](https://github."
"com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md#deriving-from-generic) section of the [Type Class Deriving](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md) guide."
msgstr ""
"（普通）（`Generic`を介して）`Show`インスタンスを`Shape`に導出してくださ"
"い。\n"
"コードの量はどのくらいになりましたか。\n"
"また、前の章の`showShape`と比較して`String`の出力はどうなりましたか。\n"
"*手掛かり*：[型クラス導出](https://github.com/purescript/documentation/blob/"
"master/guides/Type-Class-Deriving.md)手引きの[`Generic`から導出する](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md#deriving-from-generic)節を見てください。"

#. type: Title ##
#: text/chapter6.md:345
#, no-wrap
msgid "Type Class Constraints"
msgstr "型クラス制約"

#. type: Plain text
#: text/chapter6.md:348
msgid ""
"Types of functions can be constrained by using type classes. Here is an "
"example: suppose we want to write a function that tests if three values are "
"equal, by using equality defined using an `Eq` type class instance."
msgstr ""
"型クラスを使うと、関数の型に制約を加えられます。\n"
"例を示しましょう。\n"
"`Eq`型クラスインスタンスを使って定義された等値性を使って、3つの値が等しいかど"
"うかを調べる関数を書きたいとします。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:349
#, no-wrap
msgid ""
"threeAreEqual :: forall a. Eq a => a -> a -> a -> Boolean\n"
"threeAreEqual a1 a2 a3 = a1 == a2 && a2 == a3\n"
msgstr ""
"threeAreEqual :: forall a. Eq a => a -> a -> a -> Boolean\n"
"threeAreEqual a1 a2 a3 = a1 == a2 && a2 == a3\n"

#. type: Plain text
#: text/chapter6.md:355
#, no-wrap
msgid "The type declaration looks like an ordinary polymorphic type defined using `forall`. However, there is a type class constraint `Eq a`, separated from the rest of the type by a double arrow `=>`.\n"
msgstr ""
"この型宣言は `forall`を使って定義された通常の多相型のようにも見えます。\n"
"しかし、二重線矢印 `=>`で型の残りの部分から区切られた、型クラス制約 (type class constraint) `Eq a`があります。\n"

#. type: Plain text
#: text/chapter6.md:357
msgid ""
"This type says that we can call `threeAreEqual` with any choice of type `a`, "
"as long as there is an `Eq` instance available for `a` in one of the "
"imported modules."
msgstr ""
"インポートされたモジュールのどれかに `a`に対する `Eq`インスタンスが存在するな"
"ら、どんな型 `a`を選んでも `threeAsEqual`を呼び出すことができる、とこの型は"
"言っています。"

#. type: Plain text
#: text/chapter6.md:359
msgid ""
"Constrained types can contain several type class instances, and the types of "
"the instances are not restricted to simple type variables. Here is another "
"example which uses `Ord` and `Show` instances to compare two values:"
msgstr ""
"制約された型には複数の型クラスインスタンスを含めることができますし、インスタ"
"ンスの型は単純な型変数に限定されません。 `Ord`と `Show`のインスタンスを使って"
"2つの値を比較する例を次に示します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:360
#, no-wrap
msgid ""
"showCompare :: forall a. Ord a => Show a => a -> a -> String\n"
"showCompare a1 a2 | a1 < a2 =\n"
"  show a1 <> \" is less than \" <> show a2\n"
"showCompare a1 a2 | a1 > a2 =\n"
"  show a1 <> \" is greater than \" <> show a2\n"
"showCompare a1 a2 =\n"
"  show a1 <> \" is equal to \" <> show a2\n"
msgstr ""
"showCompare :: forall a. Ord a => Show a => a -> a -> String\n"
"showCompare a1 a2 | a1 < a2 =\n"
"  show a1 <> \" is less than \" <> show a2\n"
"showCompare a1 a2 | a1 > a2 =\n"
"  show a1 <> \" is greater than \" <> show a2\n"
"showCompare a1 a2 =\n"
"  show a1 <> \" is equal to \" <> show a2\n"

#. type: Plain text
#: text/chapter6.md:372
#, no-wrap
msgid ""
"Note that multiple constraints can be specified by using the `=>` symbol multiple times, just like we specify curried functions\n"
"of multiple arguments. But remember not to confuse the two symbols:\n"
msgstr ""
"`=>`シンボルを複数回使って複数の制約を指定できることに注意してください。\n"
"複数の引数のカリー化された関数を定義するのと同様です。\n"
"しかし、2つの記号を混同しないように注意してください。\n"

# whereasは次の項目に移します
#. type: Bullet: '- '
#: text/chapter6.md:375
msgid ""
"`a -> b` denotes the type of functions from _type_ `a` to _type_ `b`, whereas"
msgstr "`a -> b`は _型_ `a`から _型_ `b`への関数の型を表します。"

# 「一方で」は前の項目から来ています
#. type: Bullet: '- '
#: text/chapter6.md:375
msgid "`a => b` applies the _constraint_ `a` to the type `b`."
msgstr "一方で、`a => b`は _制約_ `a`を型`b`に適用します。"

#. type: Plain text
#: text/chapter6.md:377
msgid ""
"The PureScript compiler will try to infer constrained types when a type "
"annotation is not provided. This can be useful if we want to use the most "
"general type possible for a function."
msgstr ""
"PureScriptコンパイラは、型の注釈が提供されていない場合、制約付きの型を推論し"
"ようとします。これは、関数に対してできる限り最も一般的な型を使用したい場合に"
"便利です。"

#. type: Plain text
#: text/chapter6.md:379
msgid ""
"To see this, try using one of the standard type classes like `Semiring` in "
"PSCi:"
msgstr ""
"PSCiで `Semiring`のような標準の型クラスの何れかを使って、このことを試してみま"
"しょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:380
#, fuzzy, no-wrap
#| msgid ""
#| "> import Prelude\n"
#| "\n"
#| "> :type \\x -> x + x\n"
#| "forall a. Semiring a => a -> a\n"
msgid ""
"> import Prelude\n"
"\n"
"> :type \\x -> x + x\n"
"forall (a :: Type). Semiring a => a -> a\n"
msgstr ""
"> import Prelude\n"
"\n"
"> :type \\x -> x + x\n"
"forall a. Semiring a => a -> a\n"

#. type: Plain text
#: text/chapter6.md:388
#, no-wrap
msgid "Here, we might have annotated this function as `Int -> Int` or `Number -> Number`, but PSCi shows us that the most general type works for any `Semiring`, allowing us to use our function with both `Int`s and `Number.\n"
msgstr ""
"ここで、この関数に`Int -> Int`または`Number -> Number`と註釈を付けることはできます。\n"
"しかし、PSCiでは最も一般的な型が`Semiring`で動作することが示されています。\n"
"こうすると`Int`と`Number`の両方で関数を使えます。\n"

#. type: Title ##
#: text/chapter6.md:389
#, no-wrap
msgid "Instance Dependencies"
msgstr "インスタンスの依存関係"

#. type: Plain text
#: text/chapter6.md:392
msgid ""
"Just as the implementation of functions can depend on type class instances "
"using constrained types, so can the implementation of type class instances "
"depend on other type class instances. This provides a powerful form of "
"program inference, in which the implementation of a program can be inferred "
"using its types."
msgstr ""
"制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、型ク"
"ラスインスタンスの実装は他の型クラスインスタンスに依存できます。これにより、"
"型を使ってプログラムの実装を推論するという、プログラム推論の強力な形式を提供"
"します。"

#. type: Plain text
#: text/chapter6.md:394
msgid ""
"For example, consider the `Show` type class. We can write a type class "
"instance to `show` arrays of elements, as long as we have a way to `show` "
"the elements themselves:"
msgstr ""
"`Show`型クラスを例に考えてみましょう。\n"
"それぞれの要素を `show`する方法がある限り、その要素の配列を `show`する型クラ"
"スインスタンスを書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:395
#, no-wrap
msgid ""
"instance Show a => Show (Array a) where\n"
"  ...\n"
msgstr ""
"instance Show a => Show (Array a) where\n"
"  ...\n"

#. type: Plain text
#: text/chapter6.md:401
#, no-wrap
msgid "If a type class instance depends on multiple other instances, those instances should be grouped in parentheses and separated by commas on the left-hand side of the `=>` symbol:\n"
msgstr "型クラスインスタンスが複数の他のインスタンスに依存する場合、括弧で囲んでそれらのインスタンスをコンマで区切り、それを`=>`シンボルの左側に置くことになります。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:402
#, no-wrap
msgid ""
"instance (Show a, Show b) => Show (Either a b) where\n"
"  ...\n"
msgstr ""
"instance (Show a, Show b) => Show (Either a b) where\n"
"  ...\n"

#. type: Plain text
#: text/chapter6.md:408
msgid "These two type class instances are provided in the `prelude` library."
msgstr "これらの2つの型クラスインスタンスは `prelude`ライブラリにあります。"

#. type: Plain text
#: text/chapter6.md:410
msgid ""
"When the program is compiled, the correct type class instance for `Show` is "
"chosen based on the inferred type of the argument to `show`. The selected "
"instance might depend on many such instance relationships, but this "
"complexity is not exposed to the developer."
msgstr ""
"プログラムがコンパイルされると、`Show`の正しい型クラスのインスタンスは `show`"
"の引数の推論された型に基づいて選ばれます。\n"
"選択されたインスタンスが沢山のそうしたインスタンスの関係に依存しているかもし"
"れませんが、このあたりの複雑さに開発者が関与することはありません。"

#. type: Bullet: '1. '
#: text/chapter6.md:414
msgid ""
"(Easy) The following declaration defines a type of non-empty arrays of "
"elements of type `a`:"
msgstr "（簡単）以下の宣言では型 `a`の要素の空でない配列の型を定義しています。"

#. type: Plain text
#: text/chapter6.md:418
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:NonEmpty}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:NonEmpty}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:420
#, no-wrap
msgid "    Write an `Eq` instance for the type `NonEmpty a` that reuses the instances for `Eq a` and `Eq (Array a)`. _Note:_ you may instead derive the `Eq` instance.\n"
msgstr ""
"    `Eq a`と`Eq (Array a)`のインスタンスを再利用し、型`NonEmpty`に`Eq`インスタンスを書いてください。\n"
"    *補足*：代わりに`Eq`インスタンスを導出できます。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:422
msgid ""
"(Medium) Write a `Semigroup` instance for `NonEmpty a` by reusing the "
"`Semigroup` instance for `Array`."
msgstr ""
"（普通）`Array`の`Semigroup`インスタンスを再利用して、`NonEmpty`への"
"`Semigroup`インスタンスを書いてください。"

#. type: Bullet: '1. '
#: text/chapter6.md:424
msgid "(Medium) Write a `Functor` instance for `NonEmpty`."
msgstr "（普通）`NonEmpty`に`Functor`インスタンスを書いてください。"

#. type: Bullet: '1. '
#: text/chapter6.md:426
msgid ""
"(Medium) Given any type `a` with an instance of `Ord`, we can add a new "
"\"infinite\" value that is greater than any other value:"
msgstr ""
"（普通）`Ord`のインスタンス付きの任意の型`a`が与えられているとすると、新しく"
"それ以外のどんな値よりも大きい「無限の」値を付け加えられます。"

#. type: Plain text
#: text/chapter6.md:430
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Extended}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Extended}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:432
#, no-wrap
msgid "    Write an `Ord` instance for `Extended a` that reuses the `Ord` instance for `a`.\n"
msgstr "    `a`への`Ord`インスタンスを再利用して、`Extended a`に`Ord`インスタンスを書いてください。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:434
msgid ""
"(Difficult) Write a `Foldable` instance for `NonEmpty`. _Hint_: reuse the "
"`Foldable` instance for arrays."
msgstr ""
"（難しい）`NonEmpty`に`Foldable`インスタンスを書いてください。\n"
"*手掛かり*：配列への`Foldable`インスタンスを再利用してください。"

#. type: Bullet: '1. '
#: text/chapter6.md:436
msgid ""
"(Difficult) Given a type constructor `f` which defines an ordered container "
"(and so has a `Foldable` instance), we can create a new container type that "
"includes an extra element at the front:"
msgstr ""
"（難しい）順序付きコンテナを定義する（そして `Foldable`のインスタンスを持って"
"いる）ような型構築子 `f`が与えられたとき、追加の要素を先頭に含める新たなコン"
"テナ型を作れます。"

#. type: Plain text
#: text/chapter6.md:440
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:442
#, no-wrap
msgid "    The container `OneMore f` also has an ordering, where the new element comes before any element of `f`. Write a `Foldable` instance for `OneMore f`:\n"
msgstr ""
"   このコンテナ `OneMore f`もまた順序を持っています。\n"
"   ここで、新しい要素は任意の `f`の要素よりも前にきます。\n"
"   この `OneMore f`の `Foldable`インスタンスを書いてみましょう。\n"

#. type: Plain text
#: text/chapter6.md:447
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore_Foldable}}\n"
"      ...\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore_Foldable}}\n"
"      ...\n"
"    ```\n"

#. type: Bullet: '1. '
#: text/chapter6.md:449
msgid ""
"(Medium) Write a `dedupShapes :: Array Shape -> Array Shape` function that "
"removes duplicate `Shape`s from an array using the `nubEq` function."
msgstr ""
"（普通）`nubEq`関数を使い、配列から重複する`Shape`を削除する`dedupShapes :: "
"Array Shape -> Array Shape`関数を書いてください。"

#. type: Bullet: '1. '
#: text/chapter6.md:451
msgid ""
"(Medium) Write a `dedupShapesFast` function which is the same as "
"`dedupShapes`, but uses the more efficient `nub` function."
msgstr ""
"（普通）`dedupShapesFast`関数を書いてください。\n"
"`dedupShapes`とほぼ同じですが、より効率の良い`nub`関数を使います。"

#. type: Title ##
#: text/chapter6.md:452
#, no-wrap
msgid "Multi-Parameter Type Classes"
msgstr "多変数型クラス"

#. type: Plain text
#: text/chapter6.md:455
msgid ""
"It's not the case that a type class can only take a single type as an "
"argument. This is the most common case, but a type class can be "
"parameterized by _zero or more_ type arguments."
msgstr ""
"型クラスが引数として1つの型だけを取れるのかというと、そうではありません。\n"
"その場合がほとんどですが、型クラスは*ゼロ個以上の*型変数を持てます。"

#. type: Plain text
#: text/chapter6.md:457
msgid "Let's see an example of a type class with two type arguments."
msgstr "それでは2つの型引数を持つ型クラスの例を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:458
#, no-wrap
msgid ""
"module Stream where\n"
"\n"
"import Data.Array as Array\n"
"import Data.Maybe (Maybe)\n"
"import Data.String.CodeUnits as String\n"
"\n"
"class Stream stream element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
"\n"
"instance Stream (Array a) a where\n"
"  uncons = Array.uncons\n"
"\n"
"instance Stream String Char where\n"
"  uncons = String.uncons\n"
msgstr ""
"module Stream where\n"
"\n"
"import Data.Array as Array\n"
"import Data.Maybe (Maybe)\n"
"import Data.String.CodeUnits as String\n"
"\n"
"class Stream stream element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
"\n"
"instance Stream (Array a) a where\n"
"  uncons = Array.uncons\n"
"\n"
"instance Stream String Char where\n"
"  uncons = String.uncons\n"

#. type: Plain text
#: text/chapter6.md:476
msgid ""
"The `Stream` module defines a class `Stream` which identifies types that "
"look like streams of elements, where elements can be pulled from the front "
"of the stream using the `uncons` function."
msgstr ""
"この `Stream`モジュールでは、要素のストリームのような型を示すクラス `Stream`"
"が定義されています。\n"
"`uncons`関数を使ってストリームの先頭から要素を取り出すことができます。"

#. type: Plain text
#: text/chapter6.md:478
msgid ""
"Note that the `Stream` type class is parameterized not only by the type of "
"the stream itself, but also by its elements. This allows us to define type "
"class instances for the same stream type but different element types."
msgstr ""
"`Stream`型クラスは、ストリーム自身の型だけでなくその要素の型も型変数として"
"持っていることに注意してください。これによって、ストリームの型が同じでも要素"
"の型について異なる型クラスインスタンスを定義できます。"

#. type: Plain text
#: text/chapter6.md:480
msgid ""
"The module defines two type class instances: an instance for arrays, where "
"`uncons` removes the head element of the array using pattern matching, and "
"an instance for String, which removes the first character from a String."
msgstr ""
"このモジュールでは2つの型クラスインスタンスが定義されています。\n"
"`uncons`がパターン照合で配列の先頭の要素を取り除くような配列のインスタンス"
"と、文字列から最初の文字を取り除くような文字列のインスタンスです。"

#. type: Plain text
#: text/chapter6.md:482
msgid ""
"We can write functions that work over arbitrary streams. For example, here "
"is a function that accumulates a result in some `Monoid` based on the "
"elements of a stream:"
msgstr ""
"任意のストリーム上で動作する関数を記述できます。\n"
"例えば、ストリームの要素に基づいて `Monoid`に結果を累算する関数は次のようにな"
"ります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:483
#, no-wrap
msgid ""
"import Prelude\n"
"import Data.Monoid (class Monoid, mempty)\n"
"\n"
"foldStream :: forall l e m. Stream l e => Monoid m => (e -> m) -> l -> m\n"
"foldStream f list =\n"
"  case uncons list of\n"
"    Nothing -> mempty\n"
"    Just cons -> f cons.head <> foldStream f cons.tail\n"
msgstr ""
"import Prelude\n"
"import Data.Monoid (class Monoid, mempty)\n"
"\n"
"foldStream :: forall l e m. Stream l e => Monoid m => (e -> m) -> l -> m\n"
"foldStream f list =\n"
"  case uncons list of\n"
"    Nothing -> mempty\n"
"    Just cons -> f cons.head <> foldStream f cons.tail\n"

#. type: Plain text
#: text/chapter6.md:495
msgid ""
"Try using `foldStream` in PSCi for different types of `Stream` and different "
"types of `Monoid`."
msgstr ""
"PSCiで使って、異なる `Stream`の型や異なる `Monoid`の型について `foldStream`を"
"呼び出してみましょう。"

#. type: Title ##
#: text/chapter6.md:496
#, no-wrap
msgid "Functional Dependencies"
msgstr "関数従属性"

#. type: Plain text
#: text/chapter6.md:499
msgid ""
"Multi-parameter type classes can be very useful but can easily lead to "
"confusing types and even issues with type inference. As a simple example, "
"consider writing a generic `tail` function on streams using the `Stream` "
"class given above:"
msgstr ""
"多変数型クラスは非常に便利ですが、紛らわしい型や型推論の問題にも繋がりま"
"す。\n"
"単純な例として、上記で与えられた`Stream`クラスを使い、ストリームに対して汎用"
"的な`tail`関数を書くことを考えてみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:500
#, no-wrap
msgid "genericTail xs = map _.tail (uncons xs)\n"
msgstr "genericTail xs = map _.tail (uncons xs)\n"

#. type: Plain text
#: text/chapter6.md:505
msgid "This gives a somewhat confusing error message:"
msgstr "これはやや複雑なエラー文言を出力します。"

#. type: Fenced code block (text)
#: text/chapter6.md:506
#, no-wrap
msgid ""
"The inferred type\n"
"\n"
"  forall stream a. Stream stream a => stream -> Maybe stream\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"The inferred type\n"
"\n"
"  forall stream a. Stream stream a => stream -> Maybe stream\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:515
msgid ""
"The problem is that the `genericTail` function does not use the `element` "
"type mentioned in the definition of the `Stream` type class, so that type is "
"left unsolved."
msgstr ""
"エラーは、 `genericTail`関数が `Stream`型クラスの定義で言及された `element`型"
"を使用しないので、その型は未解決のままであることを指しています。"

#. type: Plain text
#: text/chapter6.md:517
msgid ""
"Worse still, we cannot even use `genericTail` by applying it to a specific "
"type of stream:"
msgstr ""
"更に残念なことに、特定の型のストリームに`genericTail`を適用できません。"

#. type: Fenced code block (text)
#: text/chapter6.md:518
#, no-wrap
msgid ""
"> map _.tail (uncons \"testing\")\n"
"\n"
"The inferred type\n"
"\n"
"  forall a. Stream String a => Maybe String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"> map _.tail (uncons \"testing\")\n"
"\n"
"The inferred type\n"
"\n"
"  forall a. Stream String a => Maybe String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:529
msgid ""
"Here, we might expect the compiler to choose the `streamString` instance. "
"After all, a `String` is a stream of `Char`s, and cannot be a stream of any "
"other type of elements."
msgstr ""
"ここでは、コンパイラが `streamString`インスタンスを選択することを期待していま"
"す。\n"
"結局のところ、 `String`は `Char`のストリームであり、他の型のストリームであっ"
"てはなりません。"

#. type: Plain text
#: text/chapter6.md:531
msgid ""
"The compiler cannot make that deduction automatically or commit to the "
"`streamString` instance. However, we can help the compiler by adding a hint "
"to the type class definition:"
msgstr ""
"コンパイラは自動的にそう推論できず、`streamString`インスタンスに目が向きませ"
"ん。\n"
"しかし、型クラス定義に手掛かりを追加すると、コンパイラを補助できます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:532
#, no-wrap
msgid ""
"class Stream stream element | stream -> element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
msgstr ""
"class Stream stream element | stream -> element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"

#. type: Plain text
#: text/chapter6.md:538
#, no-wrap
msgid "Here, `stream -> element` is called a _functional dependency_. A functional dependency asserts a functional relationship between the type arguments of a multi-parameter type class. This functional dependency tells the compiler that there is a function from stream types to (unique) element types, so if the compiler knows the stream type, then it can commit to the element type.\n"
msgstr "ここで、 `stream -> element`は _関数従属性_ (functional dependency) と呼ばれます。関数従属性は、多変数型クラスの型引数間の関数関係を宣言します。この関数の依存関係は、ストリーム型から（一意の）要素型への関数があることをコンパイラに伝えるので、コンパイラがストリーム型を知っていれば要素の型を割り当てられます。\n"

#. type: Plain text
#: text/chapter6.md:540
msgid ""
"This hint is enough for the compiler to infer the correct type for our "
"generic tail function above:"
msgstr ""
"この手掛かりがあれば、コンパイラが上記の汎用的な尾鰭関数の正しい型を推論する"
"のに充分です。"

#. type: Fenced code block (text)
#: text/chapter6.md:541
#, fuzzy, no-wrap
#| msgid ""
#| "> :type genericTail\n"
#| "forall stream element. Stream stream element => stream -> Maybe stream\n"
#| "\n"
#| "> genericTail \"testing\"\n"
#| "(Just \"esting\")\n"
msgid ""
"> :type genericTail\n"
"forall (stream :: Type) (element :: Type). Stream stream element => stream -> Maybe stream\n"
"\n"
"> genericTail \"testing\"\n"
"(Just \"esting\")\n"
msgstr ""
"> :type genericTail\n"
"forall stream element. Stream stream element => stream -> Maybe stream\n"
"\n"
"> genericTail \"testing\"\n"
"(Just \"esting\")\n"

#. type: Plain text
#: text/chapter6.md:550
msgid ""
"Functional dependencies can be useful when designing certain APIs using "
"multi-parameter type classes."
msgstr ""
"多変数の型クラスを使用して何らかのAPIを設計する場合、関数従属性が便利なことが"
"あります。"

#. type: Title ##
#: text/chapter6.md:551
#, no-wrap
msgid "Nullary Type Classes"
msgstr "型変数のない型クラス"

#. type: Plain text
#: text/chapter6.md:554
msgid ""
"We can even define type classes with zero-type arguments! These correspond "
"to compile-time assertions about our functions, allowing us to track the "
"global properties of our code in the type system."
msgstr ""
"ゼロ個の型変数を持つ型クラスさえも定義できます。\n"
"これらは関数に対するコンパイル時の表明に対応しており、型システム内においてそ"
"のコードの大域的な性質を把握できます。"

#. type: Plain text
#: text/chapter6.md:556
msgid ""
"An important example is the `Partial` class we saw earlier when discussing "
"partial functions. Take, for example, the functions `head` and `tail` "
"defined in `Data.Array.Partial` that allow us to get the head or tail of an "
"array without wrapping them in a `Maybe`, so they can fail if the array is "
"empty:"
msgstr ""
"重要な一例として、前に部分関数についてお話しした際に見た`Partial`クラスがあり"
"ます。\n"
"`Data.Array.Partial`に定義されている関数`head`と`tail`を例に取りましょう。\n"
"この関数は配列の先頭と尾鰭を`Maybe`に包むことなく取得できます。\n"
"そのため配列が空のときに失敗する可能性があります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:557
#, no-wrap
msgid ""
"head :: forall a. Partial => Array a -> a\n"
"\n"
"tail :: forall a. Partial => Array a -> Array a\n"
msgstr ""
"head :: forall a. Partial => Array a -> a\n"
"\n"
"tail :: forall a. Partial => Array a -> Array a\n"

#. type: Plain text
#: text/chapter6.md:564
msgid ""
"Note that there is no instance defined for the `Partial` type class! Doing "
"so would defeat its purpose: attempting to use the `head` function directly "
"will result in a type error:"
msgstr ""
"`Partial`モジュールの `Partial`型クラスのインスタンスを定義していないことに注"
"意してください。\n"
"こうすると目的を達成できます。\n"
"このままの定義では `head`関数を使用しようとすると型エラーになるのです。"

#. type: Fenced code block (text)
#: text/chapter6.md:565
#, no-wrap
msgid ""
"> head [1, 2, 3]\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Prim.Partial\n"
msgstr ""
"> head [1, 2, 3]\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Prim.Partial\n"

#. type: Plain text
#: text/chapter6.md:574
msgid ""
"Instead, we can republish the `Partial` constraint for any functions making "
"use of partial functions:"
msgstr ""
"代わりに、これらの部分関数を利用する全ての関数で `Partial`制約を再発行できま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:575
#, no-wrap
msgid ""
"secondElement :: forall a. Partial => Array a -> a\n"
"secondElement xs = head (tail xs)\n"
msgstr ""
"secondElement :: forall a. Partial => Array a -> a\n"
"secondElement xs = head (tail xs)\n"

#. type: Plain text
#: text/chapter6.md:581
msgid ""
"We've already seen the `unsafePartial` function, which allows us to treat a "
"partial function as a regular function (unsafely). This function is defined "
"in the `Partial.Unsafe` module:"
msgstr ""
"前章で見た`unsafePartial`関数を使用し、部分関数を通常の関数として（不用心に）"
"扱うことができます。この関数は `Partial.Unsafe`モジュールで定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:582
#, no-wrap
msgid "unsafePartial :: forall a. (Partial => a) -> a\n"
msgstr "unsafePartial :: forall a. (Partial => a) -> a\n"

#. type: Plain text
#: text/chapter6.md:587
msgid ""
"Note that the `Partial` constraint appears _inside the parentheses_ on the "
"left of the function arrow, but not in the outer `forall`. That is, "
"`unsafePartial` is a function from partial values to regular values:"
msgstr ""
"`Partial`制約は関数の矢印の左側の括弧の中に現れますが、外側の `forall`では現"
"れません。\n"
"つまり、 `unsafePartial`は部分的な値から通常の値への関数です。"

#. type: Fenced code block (text)
#: text/chapter6.md:588
#, no-wrap
msgid ""
"> unsafePartial head [1, 2, 3]\n"
"1\n"
"\n"
"> unsafePartial secondElement [1, 2, 3]\n"
"2\n"
msgstr ""
"> unsafePartial head [1, 2, 3]\n"
"1\n"
"\n"
"> unsafePartial secondElement [1, 2, 3]\n"
"2\n"

#. type: Title ##
#: text/chapter6.md:596
#, no-wrap
msgid "Superclasses"
msgstr "上位クラス"

#. type: Plain text
#: text/chapter6.md:599
msgid ""
"Just as we can express relationships between type class instances by making "
"an instance dependent on another instance, we can express relationships "
"between type classes themselves using so-called _superclasses_."
msgstr ""
"インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス"
"間の関係を表現できるように、いわゆる*上位クラス*を使って型クラス間の関係を表"
"現できます。"

#. type: Plain text
#: text/chapter6.md:601
#, no-wrap
msgid "We say that one type class is a superclass of another if every instance of the second class is required to be an instance of the first, and we indicate a superclass relationship in the class definition by using a backwards facing double arrow ( `<=` ).\n"
msgstr ""
"あるクラスのどんなインスタンスも、別のクラスのインスタンスである必要があるとき、後者の型クラスは前者の型クラスの上位クラスであるといいます。\n"
"そしてクラス定義で逆向きの太い矢印 (`<=`) を使って上位クラス関係を示します。\n"

#. type: Plain text
#: text/chapter6.md:603
msgid ""
"We've [already seen an example of superclass relationships](#ord): the `Eq` "
"class is a superclass of `Ord`, and the `Semigroup` class is a superclass of "
"`Monoid`. For every type class instance of the `Ord` class, there must be a "
"corresponding `Eq` instance for the same type. This makes sense since, in "
"many cases, when the `compare` function reports that two values are "
"incomparable, we often want to use the `Eq` class to determine if they are "
"equal."
msgstr ""
"[既に上位クラスの関係の例を目にしました](#ord)。\n"
"`Eq`クラスは`Ord`の上位クラスですし、`Semigroup`クラスは`Monoid`の上位クラス"
"です。\n"
"`Ord`クラスの全ての型クラスインスタンスについて、その同じ型に対応する `Eq`イ"
"ンスタンスが存在しなければなりません。\n"
"これは理に適っています。\n"
"多くの場合、`compare`関数が2つの値の大小を付けられないと報告した時は、同値で"
"あるかを判定するために`Eq`クラスを使うことでしょう。"

#. type: Plain text
#: text/chapter6.md:605
msgid ""
"In general, it makes sense to define a superclass relationship when the laws "
"for the subclass mention the superclass members. For example, for any pair "
"of Ord and Eq instances, it is reasonable to assume that if two values are "
"equal under the `Eq` instance, then the `compare` function should return "
"`EQ`. In other words, `a == b` should be true exactly when `compare a b` "
"evaluates to `EQ`. This relationship on the level of laws justifies the "
"superclass relationship between `Eq` and `Ord`."
msgstr ""
"一般に、下位クラスの法則が上位クラスの構成要素に言及しているとき、上位クラス"
"関係を定義するのは筋が通っています。\n"
"例えば、任意の`Ord`と`Eq`のインスタンスの対について、もし2つの値が`Eq`インス"
"タンスの下で同値であるなら、`compare`関数は`EQ`を返すはずだと推定するのは理に"
"適っています。\n"
"言い換えれば、`a == b`が真であるのは`compare a b`が厳密に`EQ`に評価されるとき"
"なのです。\n"
"法則のレベルでのこの関係は、`Eq`と`Ord`の間の上位クラス関係の正当性を示しま"
"す。"

#. type: Plain text
#: text/chapter6.md:607
msgid ""
"Another reason to define a superclass relationship is when there is a clear "
"\"is-a\" relationship between the two classes. That is, every member of the "
"subclass _is a_ member of the superclass as well."
msgstr ""
"上位クラス関係を定義する別の理由となるのは、この2つのクラスの間に明白な \"is-"
"a\" の関係があることです。\n"
"下位クラスの全ての構成要素は、上位クラスの構成要素でもあるということです。"

#. type: Bullet: '1. '
#: text/chapter6.md:611
msgid ""
"(Medium) Define a partial function `unsafeMaximum :: Partial => Array Int -> "
"Int` that finds the maximum of a non-empty array of integers. Test out your "
"function in PSCi using `unsafePartial`. _Hint_: Use the `maximum` function "
"from `Data.Foldable`."
msgstr ""
"（普通）部分関数`unsafeMaximum :: Partial => Array Int -> Int`を定義してくだ"
"さい。\n"
"この関数は空でない整数の配列の最大値を求めます。\n"
"`unsafePartial`を使ってPSCiで関数を試してください。\n"
"*手掛かり*：`Data.Foldable`の`maximum`関数を使います。"

#. type: Bullet: '1. '
#: text/chapter6.md:613
msgid ""
"(Medium) The `Action` class is a multi-parameter type class that defines an "
"action of one type on another:"
msgstr ""
"（普通）次の `Action`クラスは、ある型の別の型での動作を定義する、多変数型クラ"
"スです。"

#. type: Plain text
#: text/chapter6.md:617
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Action}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Action}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:619
#, no-wrap
msgid "    An _action_ is a function that describes how monoidal values are used to determine how to modify a value of another type. There are two laws for the `Action` type class:\n"
msgstr ""
"   *動作*とは、他の型の値を変更する方法を決めるために使われるモノイドな値を記述する関数です。\n"
"   `Action`型クラスには2つの法則があります。\n"

#. type: Bullet: '    - '
#: text/chapter6.md:622
msgid "`act mempty a = a`"
msgstr "`act mempty a = a`"

#. type: Bullet: '    - '
#: text/chapter6.md:622
msgid "`act (m1 <> m2) a = act m1 (act m2 a)`"
msgstr "`act (m1 <> m2) a = act m1 (act m2 a)`"

#. type: Plain text
#: text/chapter6.md:624
#, no-wrap
msgid "    Applying an empty action is a no-op. And applying two actions in sequence is the same as applying the actions combined. That is, actions respect the operations defined by the `Monoid` class.\n"
msgstr ""
"    空の動作を提供しても何も起こりません。\n"
"    そして2つの動作を連続で適用することは結合した動作を適用することと同じです。\n"
"    つまり、動作は`Monoid`クラスで定義される操作に倣っています。\n"

#. type: Plain text
#: text/chapter6.md:626
#, no-wrap
msgid "    For example, the natural numbers form a monoid under multiplication:\n"
msgstr "   例えば自然数は乗算のもとでモノイドを形成します。\n"

#. type: Plain text
#: text/chapter6.md:629
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply}}\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply}}\n"

#. type: Plain text
#: text/chapter6.md:631
#, no-wrap
msgid "    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:semigroupMultiply}}\n"
msgstr "    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:semigroupMultiply}}\n"

#. type: Plain text
#: text/chapter6.md:634
#, no-wrap
msgid ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:monoidMultiply}}\n"
"    ```\n"
msgstr ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:monoidMultiply}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:636
#, no-wrap
msgid "    Write an instance that implements this action:\n"
msgstr "    この動作を実装するインスタンスを書いてください。\n"

#. type: Plain text
#: text/chapter6.md:641
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply_Action}}\n"
"      ...\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply_Action}}\n"
"      ...\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:643
#, no-wrap
msgid "    Remember, your instance must satisfy the laws listed above.\n"
msgstr "    インスタンスが上で挙げた法則を見たさなくてはならないことを思い出してください。\n"

# FIXME: PureScriptではなくPurescriptになっています。
#. type: Bullet: '1. '
#: text/chapter6.md:645
msgid ""
"(Difficult) There are multiple ways to implement an instance of `Action "
"Multiply Int`. How many can you think of? Purescript does not allow multiple "
"implementations of the same instance, so you will have to replace your "
"original implementation. _Note_: the tests cover 4 implementations."
msgstr ""
"（難しい）`Action Multiply Int`のインスタンスを実装するには複数の方法がありま"
"す。\n"
"どれだけ思い付きますか。\n"
"PureScriptは同じインスタンスの複数の実装を許さないため、元の実装を置き換える"
"必要があるでしょう。\n"
"*補足*：テストでは4つの実装を押さえています。"

#. type: Bullet: '1. '
#: text/chapter6.md:647
msgid ""
"(Medium) Write an `Action` instance that repeats an input string some number "
"of times:"
msgstr ""
"（普通）入力の文字列を何回か繰り返す`Action`インスタンスを書いてください。"

#. type: Plain text
#: text/chapter6.md:652
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:actionMultiplyString}}\n"
"      ...\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:actionMultiplyString}}\n"
"      ...\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:654
#, no-wrap
msgid "    _Hint_: Search Pursuit for a helper-function with the signature [`String -> Int -> String`](https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String). Note that `String` might appear as a more generic type (such as `Monoid`).\n"
msgstr ""
"    *手掛かり*：Pursuitでシグネチャが[`String -> Int -> String`](https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String)の補助関数を検索してください。\n"
"    なお、`String`は（`Monoid`のような）より汎用的な型として現れます。\n"

#. type: Plain text
#: text/chapter6.md:656
#, no-wrap
msgid "    Does this instance satisfy the laws listed above?\n"
msgstr "    このインスタンスは上に挙げた法則を満たすでしょうか。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:658
msgid ""
"(Medium) Write an instance `Action m a => Action m (Array a)`, where the "
"action on arrays is defined by acting on each array element independently."
msgstr ""
"（普通）インスタンス `Action m a => Action m (Array a)`を書いてみましょう。\n"
"ここで、 配列上の動作はそれぞれの要素を独立に実行するものとして定義されます。"

#. type: Bullet: '1. '
#: text/chapter6.md:660
msgid ""
"(Difficult) Given the following newtype, write an instance for `Action m "
"(Self m)`, where the monoid `m` acts on itself using `append`:"
msgstr ""
"（難しい）以下のnewtypeが与えらえているとき、`Action m (Self m)`のインスタン"
"スを書いてください。\n"
"ここでモノイド`m`はそれ自体が持つ`append`を用いて動作します。"

#. type: Plain text
#: text/chapter6.md:664
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Self}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Self}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:666
#, no-wrap
msgid "    _Note_: The testing framework requires `Show` and `Eq` instances for the `Self` and `Multiply` types. You may either write these instances manually, or let the compiler handle this for you with [`derive newtype instance`](https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype) shorthand.\n"
msgstr ""
"    *補足*：テストフレームワークでは`Self`と`Multiply`型に`Show`と`Eq`インスタンスが必要になります。\n"
"    手作業でこれらのインスタンスを書いてもよいですし、[`derive newtype instance`](https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype)と書くだけでコンパイラに取り仕切ってもらうこともできます。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:668
msgid ""
"(Difficult) Should the arguments of the multi-parameter type class `Action` "
"be related by some functional dependency? Why or why not? _Note_: There is "
"no test for this exercise."
msgstr ""
"（難しい）多変数型のクラス `Action`の引数は、何らかの関数従属性によって関連づ"
"けられるべきですか。\n"
"なぜそうすべき、あるいはそうすべきでないでしょうか。\n"
"*補足*：この演習にはテストがありません。"

#. type: Title ##
#: text/chapter6.md:669
#, no-wrap
msgid "A Type Class for Hashes"
msgstr "ハッシュの型クラス"

#. type: Plain text
#: text/chapter6.md:672
msgid ""
"In the last section of this chapter, we will use the lessons from the rest "
"of the chapter to create a library for hashing data structures."
msgstr ""
"この最後の節では、章の残りを使ってデータ構造をハッシュ化するライブラリを作り"
"ます。"

#. type: Plain text
#: text/chapter6.md:674
#, no-wrap
msgid "> Note that this library is for demonstration purposes only and is not intended to provide a robust hashing mechanism.\n"
msgstr "> なお、このライブラリは説明だけを目的としており、堅牢なハッシュ化の仕組みの提供は意図していません。\n"

#. type: Plain text
#: text/chapter6.md:676
msgid "What properties might we expect of a hash function?"
msgstr "ハッシュ関数に期待される性質とはどのようなものでしょうか。"

#. type: Bullet: '- '
#: text/chapter6.md:679
msgid ""
"A hash function should be deterministic and map equal values to equal hash "
"codes."
msgstr ""
"ハッシュ関数は決定的でなくてはなりません。\n"
"つまり、同じ値は同じハッシュコードに写さなければなりません。"

#. type: Bullet: '- '
#: text/chapter6.md:679
msgid ""
"A hash function should distribute its results approximately uniformly over "
"some set of hash codes."
msgstr ""
"ハッシュ関数はいろいろなハッシュ値の集合で結果が一様に分布しなければなりませ"
"ん。"

#. type: Plain text
#: text/chapter6.md:681
msgid ""
"The first property looks a lot like a law for a type class, whereas the "
"second property is more along the lines of an informal contract and "
"certainly would not be enforceable by PureScript's type system. However, "
"this should provide the intuition for the following type class:"
msgstr ""
"最初の性質はちゃんとした型クラスの法則のように見えます。\n"
"その一方で、2番目の性質はよりくだけた規約の条項のようなもので、PureScriptの型"
"システムによって確実に強制できるようなものではなさそうです。\n"
"しかし、これは型クラスから次のような直感が得られるでしょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:682
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:Hashable}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:Hashable}}\n"

#. type: Plain text
#: text/chapter6.md:687
msgid "with the associated law that `a == b` implies `hash a == hash b`."
msgstr ""
"これに、 `a == b`ならば `hash a == hash b`を示唆するという関係性の法則が付随"
"しています。"

#. type: Plain text
#: text/chapter6.md:689
msgid ""
"We'll spend the rest of this section building a library of instances and "
"functions associated with the `Hashable` type class."
msgstr ""
"この節の残りの部分を費やして、`Hashable`型クラスに関連付けられているインスタ"
"ンスと関数のライブラリを構築していきます。"

#. type: Plain text
#: text/chapter6.md:691
msgid "We will need a way to combine hash codes in a deterministic way:"
msgstr "決定的な方法でハッシュ値を結合する方法が必要になります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:692
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:combineHashes}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:combineHashes}}\n"

#. type: Plain text
#: text/chapter6.md:697
msgid ""
"The `combineHashes` function will mix two hash codes and redistribute the "
"result over the interval 0-65535."
msgstr ""
"`combineHashes`関数は2つのハッシュ値を混ぜて結果を0-65535の間に分布します。"

#. type: Plain text
#: text/chapter6.md:699
msgid ""
"Let's write a function that uses the `Hashable` constraint to restrict the "
"types of its inputs. One common task which requires a hashing function is to "
"determine if two values hash to the same hash code. The `hashEqual` relation "
"provides such a capability:"
msgstr ""
"それでは、`Hashable`制約を使って入力の種類を制限する関数を書いてみましょ"
"う。\n"
"ハッシュ関数を必要とするよくある目的としては、2つの値が同じハッシュコードに"
"ハッシュ化されるかどうかを判定することです。\n"
"`hashEqual`関係はそのような機能を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:700
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashEqual}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashEqual}}\n"

#. type: Plain text
#: text/chapter6.md:705
msgid ""
"This function uses the `on` function from `Data.Function` to define hash-"
"equality in terms of equality of hash codes, and should read like a "
"declarative definition of hash-equality: two values are \"hash-equal\" if "
"they are equal after each value passed through the `hash` function."
msgstr ""
"この関数はハッシュコードの等値性を利用したハッシュ同値性を定義するために"
"`Data.Function`の `on`関数を使っていますが、これはハッシュ同値性の宣言的な定"
"義として読めるはずです。\n"
"つまり、それぞれの値が `hash`関数に渡されたあとで2つの値が等しいなら、それら"
"の値は「ハッシュ同値」です。"

#. type: Plain text
#: text/chapter6.md:707
msgid ""
"Let's write some `Hashable` instances for some primitive types. Let's start "
"with an instance for integers. Since a `HashCode` is really just a wrapped "
"integer, this is simple – we can use the `hashCode` helper function:"
msgstr ""
"原始型の `Hashable`インスタンスを幾つか書いてみましょう。\n"
"まずは整数のインスタンスです。\n"
"`HashCode`は実際には単なる梱包された整数なので、単純です。\n"
"`hashCode`補助関数を使えます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:708
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashInt}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashInt}}\n"

#. type: Plain text
#: text/chapter6.md:713
msgid ""
"We can also define a simple instance for `Boolean` values using pattern "
"matching:"
msgstr "パターン照合を使うと、`Boolean`値の単純なインスタンスも定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:714
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashBoolean}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashBoolean}}\n"

#. type: Plain text
#: text/chapter6.md:719
msgid ""
"With an instance for hashing integers, we can create an instance for hashing "
"`Char`s by using the `toCharCode` function from `Data.Char`:"
msgstr ""
"整数のインスタンスでは、`Data.Char`の `toCharCode`関数を使うと`Char`をハッ"
"シュ化するインスタンスを作成できます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:720
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashChar}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashChar}}\n"

#. type: Plain text
#: text/chapter6.md:725
msgid ""
"To define an instance for arrays, we can `map` the `hash` function over the "
"elements of the array (if the element type is also an instance of "
"`Hashable`) and then perform a left fold over the resulting hashes using the "
"`combineHashes` function:"
msgstr ""
"（要素型が `Hashable`のインスタンスでもあるならば）配列の要素に `hash`関数を "
"`map`してから、`combineHashes`関数を使って結果のハッシュを左側に畳み込むこと"
"で、配列のインスタンスを定義します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:726
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashArray}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashArray}}\n"

#. type: Plain text
#: text/chapter6.md:731
msgid ""
"Notice how we build up instances using the simpler instances we have already "
"written. Let's use our new `Array` instance to define an instance for "
"`String`s, by turning a `String` into an array of `Char`s:"
msgstr ""
"既に書いたものより単純なインスタンスを使用して、新たなインスタンスを構築して"
"いるやり方に注目してください。\n"
"`String`を`Char`の配列に変換し、この新たな`Array`インスタンスを使って`String`"
"のインスタンスを定義しましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:732
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashString}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashString}}\n"

#. type: Plain text
#: text/chapter6.md:737
msgid ""
"How can we prove that these `Hashable` instances satisfy the type class law "
"that we stated above? We need to make sure that equal values have equal hash "
"codes. In cases like `Int`, `Char`, `String`, and `Boolean`, this is simple "
"because there are no values of those types that are equal in the sense of "
"`Eq` but not equal identically."
msgstr ""
"これらの `Hashable`インスタンスが先ほどの型クラスの法則を満たしていることを証"
"明するにはどうしたらいいでしょうか。\n"
"同じ値が等しいハッシュコードを持っていることを確認する必要があります。\n"
"`Int`、`Char`、`String`、`Boolean`のような場合は単純です。\n"
"`Eq`の意味では同じ値でも厳密には同じではない、というような型の値は存在しない"
"からです。"

#. type: Plain text
#: text/chapter6.md:739
msgid ""
"What about some more interesting types? To prove the type class law for the "
"`Array` instance, we can use induction on the length of the array. The only "
"array with a length zero is `[]`. Any two non-empty arrays are equal only if "
"they have equal head elements and equal tails, by the definition of `Eq` on "
"arrays. By the inductive hypothesis, the tails have equal hashes, and we "
"know that the head elements have equal hashes if the `Hashable a` instance "
"must satisfy the law. Therefore, the two arrays have equal hashes, and so "
"the `Hashable (Array a)` obeys the type class law as well."
msgstr ""
"もっと面白い型についてはどうでしょうか。\n"
"`Array`インスタンスの型クラスの法則を証明するにあたっては、配列の長さに関する"
"帰納を使えます。\n"
"長さゼロの唯一の配列は `[]`です。\n"
"配列の `Eq`の定義により、任意の2つの空でない配列は、それらの先頭の要素が同じ"
"で配列の残りの部分が等しいとき、またその時に限り等しくなります。\n"
"この帰納的な仮定により、配列の残りの部分は同じハッシュ値を持ちますし、もし "
"`Hashable a`インスタンスがこの法則を満たすなら、先頭の要素も同じハッシュ値を"
"持つことがわかります。\n"
"したがって、2つの配列は同じハッシュ値を持ち、`Hashable (Array a)`も同様に型ク"
"ラス法則に従います。"

#. type: Plain text
#: text/chapter6.md:741
msgid ""
"The source code for this chapter includes several other examples of "
"`Hashable` instances, such as instances for the `Maybe` and `Tuple` type."
msgstr ""
"この章のソースコードには、 `Maybe`と `Tuple`型のインスタンスなど、他にも "
"`Hashable`インスタンスの例が含まれています。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:747
msgid ""
"(Easy) Use PSCi to test the hash functions for each of the defined "
"instances. _Note_: There is no provided unit test for this exercise."
msgstr ""
"（簡単）PSCiを使って、定義した各インスタンスのハッシュ関数をテストしてくださ"
"い。\n"
"*補足*：この演習には単体試験がありません。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:747
msgid ""
"(Medium) Write a function `arrayHasDuplicates`, which tests if an array has "
"any duplicate elements based on both hash and value equality. First, check "
"for hash equality with the `hashEqual` function, then check for value "
"equality with `==` if a duplicate pair of hashes is found. _Hint_: the "
"`nubByEq` function in `Data.Array` should make this task much simpler."
msgstr ""
"（普通）関数`arrayHasDuplicates`を書いてください。\n"
"この関数はハッシュと値の同値性に基づいて配列が重複する要素を持っているかどう"
"かを調べます。\n"
"まずハッシュ同値性を`hashEqual`関数で確認し、それからもし重複するハッシュの対"
"が見付かったら`==`で値の同値性を確認してください。\n"
"*手掛かり*：`Data.Array`の `nubByEq`関数はこの問題をずっと簡単にしてくれるで"
"しょう。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:747
msgid ""
"(Medium) Write a `Hashable` instance for the following newtype which "
"satisfies the type class law:"
msgstr ""
"（普通）型クラスの法則を満たす、次のnewtypeの `Hashable`インスタンスを書いて"
"ください。"

#. type: Plain text
#: text/chapter6.md:750
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Hour}}\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Hour}}\n"

#. type: Plain text
#: text/chapter6.md:753
#, no-wrap
msgid ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:eqHour}}\n"
"    ```\n"
msgstr ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:eqHour}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:756
#, no-wrap
msgid ""
"    The newtype `Hour` and its `Eq` instance represent the type of integers modulo 12, so that 1 and 13 are identified as equal, for example. Prove that the type class law holds for your instance.\n"
" 1. (Difficult) Prove the type class laws for the `Hashable` instances for `Maybe`, `Either` and `Tuple`. _Note_: There is no test for this exercise.\n"
msgstr ""
"   newtypeの `Hour`とその `Eq`インスタンスは、12を法とする整数の型を表します。\n"
"   したがって、例えば1と13は等しいと見なされます。\n"
"   そのインスタンスが型クラスの法則を満たしていることを証明してください。\n"
" 1. （難しい）`Maybe`、`Either`そして`Tuple`への`Hashable`インスタンスについて型クラスの法則を証明してください。\n"
"    *補足*：この演習にテストはありません。\n"

#. type: Plain text
#: text/chapter6.md:760
msgid ""
"In this chapter, we've been introduced to _type classes_, a type-oriented "
"form of abstraction that enables powerful forms of code reuse. We've seen a "
"collection of standard type classes from the PureScript standard libraries "
"and defined our own library based on a type class for computing hash codes."
msgstr ""
"この章では*型クラス*を導入しました。\n"
"型クラスは型に基づく抽象化で、コードの再利用のために強力な形式化ができま"
"す。\n"
"PureScriptの標準ライブラリから標準の型クラスを幾つか見てきました。\n"
"また、ハッシュ値を計算するための型クラスに基づく独自のライブラリを定義しまし"
"た。"

#. type: Plain text
#: text/chapter6.md:761
msgid ""
"This chapter also introduced type class laws, a technique for proving "
"properties about code that uses type classes for abstraction. Type class "
"laws are part of a larger subject called _equational reasoning_, in which "
"the properties of a programming language and its type system are used to "
"enable logical reasoning about its programs. This is an important idea and a "
"theme that we will return to throughout the rest of the book."
msgstr ""
"この章では型クラス法則も導入しましたが、これは抽象化に型クラスを使うコードに"
"ついての性質を証明する手法でした。\n"
"型クラス法則は*等式推論*と呼ばれるより大きな分野の一部です。\n"
"そちらではプログラミング言語の性質と型システムがプログラムを論理的に追究する"
"ために使われています。\n"
"これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話題となるでしょう。"

#. type: Title ##
#: text/chapter7.md:1 text/chapter7.md:387
#, no-wrap
msgid "Applicative Validation"
msgstr "アプリカティブによる検証"

#. type: Plain text
#: text/chapter7.md:6
msgid ""
"In this chapter, we will meet an important new abstraction – the "
"_applicative functor_, described by the `Applicative` type class. Don't "
"worry if the name sounds confusing – we will motivate the concept with a "
"practical example – validating form data. This technique allows us to "
"convert code which usually involves a lot of boilerplate checking into a "
"simple, declarative description of our form."
msgstr ""
"この章では重要な抽象化と新たに出会うことになります。\n"
"`Applicative`型クラスによって表現される*アプリカティブ関手*です。\n"
"名前が難しそうに思えても心配しないでください。\n"
"フォームデータの検証という実用的な例を使ってこの概念の動機付けをします。\n"
"アプリカティブ関手の技法があることにより、通常であれば大量の決まり文句の検証"
"を伴うようなコードを、簡潔で宣言的なフォームの記述へと変えられます。"

#. type: Plain text
#: text/chapter7.md:8
msgid ""
"We will also meet another type class, `Traversable`, which describes "
"_traversable functors_, and see how this concept also arises very naturally "
"from solutions to real-world problems."
msgstr ""
"また、*巡回可能関手*を表現する`Traversable`という別の型クラスにも出会います。"
"現実の問題への解決策からこの概念が自然に生じることがわかるでしょう。"

#. type: Plain text
#: text/chapter7.md:10
msgid ""
"The example code for this chapter will be a continuation of the address book "
"example from Chapter 3. This time, we will extend our address book data "
"types and write functions to validate values for those types. The "
"understanding is that these functions could be used, for example, in a web "
"user interface, to display errors to the user as part of a data entry form."
msgstr ""
"この章のコードでは第3章に引き続き住所録を例とします。\n"
"今回は住所録のデータ型を拡張し、これらの型の値を検証する関数を書きます。\n"
"これらの関数は、例えばwebユーザインターフェースで使えることが分かります。\n"
"データ入力フォームの一部として、使用者へエラーを表示するのに使われます。"

#. type: Plain text
#: text/chapter7.md:14
msgid ""
"The source code for this chapter is defined in the files `src/Data/"
"AddressBook.purs` and `src/Data/AddressBook/Validation.purs`."
msgstr ""
"この章のソースコードは、2つのファイル`src/Data/AddressBook.purs`、及び`src/"
"Data/AddressBook/Validation.purs`で定義されています。"

#. type: Plain text
#: text/chapter7.md:16
msgid ""
"The project has a number of dependencies, many of which we have seen before. "
"There are two new dependencies:"
msgstr ""
"このプロジェクトには多くの依存関係がありますが、その大半は既に見てきたもので"
"す。\n"
"新しい依存関係は2つです。"

#. type: Bullet: '- '
#: text/chapter7.md:19
msgid ""
"`control`, which defines functions for abstracting control flow using type "
"classes like `Applicative`."
msgstr ""
"`control` - `Applicative`のような、型クラスを使用して制御フローを抽象化する関"
"数が定義されています。"

#. type: Bullet: '- '
#: text/chapter7.md:19
msgid ""
"`validation`, which defines a functor for _applicative validation_, the "
"subject of this chapter."
msgstr ""
"`validation` - この章の主題である _アプリカティブによる検証_ のための関手が定"
"義されています。"

#. type: Plain text
#: text/chapter7.md:21
msgid ""
"The `Data.AddressBook` module defines data types and `Show` instances for "
"the types in our project and the `Data.AddressBook.Validation` module "
"contains validation rules for those types."
msgstr ""
"`Data.AddressBook`モジュールにはこのプロジェクトのデータ型とそれらの型に対す"
"る`Show`インスタンスが定義されています。\n"
"また、`Data.AddressBook.Validation`モジュールにはそれらの型の検証規則が含まれ"
"ています。"

#. type: Title ##
#: text/chapter7.md:22
#, no-wrap
msgid "Generalizing Function Application"
msgstr "関数適用の一般化"

#. type: Plain text
#: text/chapter7.md:25
msgid ""
"To explain the concept of an _applicative functor_, let's consider the type "
"constructor `Maybe` that we met earlier."
msgstr ""
"_アプリカティブ関手_ の概念を理解するために、以前扱った型構築子`Maybe`につい"
"て考えてみましょう。"

#. type: Plain text
#: text/chapter7.md:27
msgid ""
"The source code for this module defines a function `address` that has the "
"following type:"
msgstr ""
"このモジュールのソースコードでは、次の型を持つ`address`関数が定義されていま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:28
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"

#. type: Plain text
#: text/chapter7.md:33
msgid ""
"This function is used to construct a value of type `Address` from three "
"strings: a street name, a city, and a state."
msgstr ""
"この関数は、通りの名前、市、州という3つの文字列から型`Address`の値を構築する"
"ために使います。"

#. type: Plain text
#: text/chapter7.md:35
msgid "We can apply this function easily and see the result in PSCi:"
msgstr "この関数は簡単に適用できますので、PSCiでどうなるか見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:36
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> address \"123 Fake St.\" \"Faketown\" \"CA\"\n"
"{ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
msgstr ""
"> import Data.AddressBook\n"
"\n"
"> address \"123 Fake St.\" \"Faketown\" \"CA\"\n"
"{ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"

#. type: Plain text
#: text/chapter7.md:44
msgid ""
"However, suppose we did not necessarily have a street, city, or state, and "
"wanted to use the `Maybe` type to indicate a missing value in each of the "
"three cases."
msgstr ""
"しかし、通り、市、州の3つ全てが必ずしも入力されないものとすると、3つの場合が"
"それぞれ省略可能であることを示すために`Maybe`型を使用したくなります。"

#. type: Plain text
#: text/chapter7.md:46
msgid ""
"In one case, we might have a missing city. If we try to apply our function "
"directly, we will receive an error from the type checker:"
msgstr ""
"考えられる場合としては、市が省略されている場合があるでしょう。\n"
"もし`address`関数を直接適用しようとすると、型検証器からエラーが表示されます。"

#. type: Fenced code block (text)
#: text/chapter7.md:47
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"> address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Could not match type\n"
"\n"
"  Maybe String\n"
"\n"
"with type\n"
"\n"
"  String\n"
msgstr ""
"> import Data.Maybe\n"
"> address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Could not match type\n"
"\n"
"  Maybe String\n"
"\n"
"with type\n"
"\n"
"  String\n"

#. type: Plain text
#: text/chapter7.md:61
msgid ""
"Of course, this is an expected type error – `address` takes strings as "
"arguments, not values of type `Maybe String`."
msgstr ""
"勿論、これは期待通り型エラーになります。\n"
"`address`は`Maybe String`型の値ではなく、文字列を引数として取るためです。"

#. type: Plain text
#: text/chapter7.md:63
msgid ""
"However, it is reasonable to expect that we should be able to \"lift\" the "
"`address` function to work with optional values described by the `Maybe` "
"type. In fact, we can, and the `Control.Apply` provides the function `lift3` "
"function which does exactly what we need:"
msgstr ""
"しかし、もし`address`関数を「持ち上げる」ことができれば、`Maybe`型で示される"
"省略可能な値を扱うことができるはずだという予想は理に適っています。実際それは"
"可能で、`Control.Apply`で提供されている関数`lift3`が、まさに求めているもので"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:64
#, no-wrap
msgid ""
"> import Control.Apply\n"
"> lift3 address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Nothing\n"
msgstr ""
"> import Control.Apply\n"
"> lift3 address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:72
msgid ""
"In this case, the result is `Nothing`, because one of the arguments (the "
"city) was missing. If we provide all three arguments using the `Just` "
"constructor, then the result will contain a value as well:"
msgstr ""
"このとき、引数の1つ（市）が欠落していたので、結果は`Nothing`になります。\n"
"もし3つの引数全てに`Just`構築子を使ったものが与えられたら、結果は値を含むこと"
"になります。"

#. type: Fenced code block (text)
#: text/chapter7.md:73
#, no-wrap
msgid ""
"> lift3 address (Just \"123 Fake St.\") (Just \"Faketown\") (Just \"CA\")\n"
"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
msgstr ""
"> lift3 address (Just \"123 Fake St.\") (Just \"Faketown\") (Just \"CA\")\n"
"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"

#. type: Plain text
#: text/chapter7.md:80
msgid ""
"The name of the function `lift3` indicates that it can be used to lift "
"functions of 3 arguments. There are similar functions defined in `Control."
"Apply` for functions of other numbers of arguments."
msgstr ""
"`lift3`という関数の名前は、3引数の関数を持ち上げるために使えることを示してい"
"ます。関数を持ち上げる同様の関数で、引数の数が異なるものが`Control.Apply`で定"
"義されています。"

#. type: Title ##
#: text/chapter7.md:81
#, no-wrap
msgid "Lifting Arbitrary Functions"
msgstr "任意個の引数を持つ関数の持ち上げ"

#. type: Plain text
#: text/chapter7.md:84
msgid ""
"So, we can lift functions with small numbers of arguments by using `lift2`, "
"`lift3`, etc. But how can we generalize this to arbitrary functions?"
msgstr ""
"これで、`lift2`や`lift3`のような関数を使えば、引数が2個や3個の関数を持ち上げ"
"ることができるのはわかりました。\n"
"でも、これを任意個の引数の関数へと一般化できるのでしょうか。"

#. type: Plain text
#: text/chapter7.md:86
msgid "It is instructive to look at the type of `lift3`:"
msgstr "`lift3`の型を見てみるとわかりやすいでしょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:87
#, fuzzy, no-wrap
#| msgid ""
#| "> :type lift3\n"
#| "forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
msgid ""
"> :type lift3\n"
"forall (a :: Type) (b :: Type) (c :: Type) (d :: Type) (f :: Type -> Type). Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
msgstr ""
"> :type lift3\n"
"forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"

#. type: Plain text
#: text/chapter7.md:93
msgid ""
"In the `Maybe` example above, the type constructor `f` is `Maybe`, so that "
"`lift3` is specialized to the following type:"
msgstr ""
"上の`Maybe`の例では型構築子`f`は`Maybe`ですから、`lift3`は次のように特殊化さ"
"れます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:94
#, no-wrap
msgid "forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
msgstr "forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"

#. type: Plain text
#: text/chapter7.md:99
msgid ""
"This type says that we can take any function with three arguments and lift "
"it to give a new function whose argument and result types are wrapped with "
"`Maybe`."
msgstr ""
"この型で書かれているのは、3引数の任意の関数を取り、その関数を引数と返り値が"
"`Maybe`で包まれた新しい関数へと持ち上げられる、ということです。"

#. type: Plain text
#: text/chapter7.md:101
msgid ""
"Certainly, this is not possible for every type constructor `f`, so what is "
"it about the `Maybe` type which allowed us to do this? Well, in specializing "
"the type above, we removed a type class constraint on `f` from the `Apply` "
"type class. `Apply` is defined in the Prelude as follows:"
msgstr ""
"勿論、どんな型構築子`f`についても持ち上げができるわけではないのですが、それで"
"は`Maybe`型を持ち上げができるようにしているものは何なのでしょうか。\n"
"さて、先ほどの型の特殊化では、`f`に対する型クラス制約から`Apply`型クラスを取"
"り除いていました。\n"
"`Apply`はPreludeで次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:102
#, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
"\n"
"class Functor f <= Apply f where\n"
"  apply :: forall a b. f (a -> b) -> f a -> f b\n"
msgstr ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
"\n"
"class Functor f <= Apply f where\n"
"  apply :: forall a b. f (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter7.md:111
#, no-wrap
msgid "The `Apply` type class is a subclass of `Functor`, and defines an additional function `apply`. As `<$>` was defined as an alias for `map`, the `Prelude` module defines `<*>` as an alias for `apply`. As we'll see, these two operators are often used together.\n"
msgstr "`Apply`型クラスは`Functor`の下位クラスであり、追加の関数`apply`を定義しています。`<$>`が`map`の別名として定義されているように、`Prelude`モジュールでは`<*>`を`apply`の別名として定義しています。これから見ていきますが、これら2つの演算子はよく一緒に使われます。\n"

#. type: Plain text
#: text/chapter7.md:113
msgid ""
"Note that this [`apply`](https://pursuit.purescript.org/packages/purescript-"
"prelude/docs/Control.Apply#v:apply) is different than the [`apply`](https://"
"pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:"
"apply) from `Data.Function` (infixed as `$`). Luckily, infix notation is "
"almost always used for the latter, so you don't need to worry about name "
"collisions."
msgstr ""
"なお、この[`apply`](https://pursuit.purescript.org/packages/purescript-"
"prelude/docs/Control.Apply#v:apply)は`Data.Function`の[`apply`](https://"
"pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:"
"apply)（中置で`$`）とは異なります。\n"
"幸いにも後者はほぼ常に中置記法として使われるので、名前の衝突については心配ご"
"無用です。"

#. type: Plain text
#: text/chapter7.md:115
msgid ""
"The type of `apply` looks a lot like the type of `map`. The difference "
"between `map` and `apply` is that `map` takes a function as an argument, "
"whereas the first argument to `apply` is wrapped in the type constructor "
"`f`. We'll see how this is used soon, but first, let's see how to implement "
"the `Apply` type class for the `Maybe` type:"
msgstr ""
"`apply`の型は`map`の型と実によく似ています。\n"
"`map`と`apply`の違いは、`map`がただの関数を引数に取るのに対し、`apply`の最初"
"の引数は型構築子`f`で包まれているという点です。\n"
"これをどのように使うのかはこれからすぐに見ていきますが、その前にまず`Maybe`型"
"について`Apply`型クラスをどう実装するのかを見ていきましょう。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:116
#, no-wrap
msgid ""
"instance Functor Maybe where\n"
"  map f (Just a) = Just (f a)\n"
"  map f Nothing  = Nothing\n"
"\n"
"instance Apply Maybe where\n"
"  apply (Just f) (Just x) = Just (f x)\n"
"  apply _        _        = Nothing\n"
msgstr ""
"instance Functor Maybe where\n"
"  map f (Just a) = Just (f a)\n"
"  map f Nothing  = Nothing\n"
"\n"
"instance Apply Maybe where\n"
"  apply (Just f) (Just x) = Just (f x)\n"
"  apply _        _        = Nothing\n"

#. type: Plain text
#: text/chapter7.md:127
msgid ""
"This type class instance says that we can apply an optional function to an "
"optional value, and the result is defined only if both are defined."
msgstr ""
"この型クラスのインスタンスで書かれているのは、任意の省略可能な値に省略可能な"
"関数を適用でき、その両方が定義されている時に限り結果も定義される、ということ"
"です。"

#. type: Plain text
#: text/chapter7.md:129
msgid ""
"Now we'll see how `map` and `apply` can be used together to lift functions "
"of an arbitrary number of arguments."
msgstr ""
"それでは、`map`と`apply`を一緒に使い、引数が任意個の関数を持ち上げる方法を見"
"ていきましょう。"

#. type: Plain text
#: text/chapter7.md:131
msgid "For functions of one argument, we can use `map` directly."
msgstr "1引数の関数については、`map`をそのまま使うだけです。"

#. type: Plain text
#: text/chapter7.md:133
#, no-wrap
msgid "For functions of two arguments, we have a curried function `g` with type `a -> b -> c`, say. This is equivalent to the type `a -> (b -> c)`, so we can apply `map` to `g` to get a new function of type `f a -> f (b -> c)` for any type constructor `f` with a `Functor` instance. Partially applying this function to the first lifted argument (of type `f a`), we get a new wrapped function of type `f (b -> c)`. If we also have an `Apply` instance for `f`, we can then use `apply` to apply the second lifted argument (of type `f b`) to get our final value of type `f c`.\n"
msgstr "2引数関数については、型`a -> b -> c`のカリー化された関数`g`があるとします。これは型`a -> (b -> c)`と同じですから、`Functor`インスタンス付きのあらゆる型構築子`f`について、`map`を`f`に適用すると型`f a -> f (b -> c)`の新たな関数を得ることになります。持ち上げられた（型`f a`の）最初の引数にその関数を部分適用すると、型`f (b -> c)`の新たな包まれた関数が得られます。`f`に`Apply`インスタンスもあるなら、そこから、2番目の持ち上げられた（型`f b`の）引数へ`apply`を適用でき、型`f c`の最終的な値を得ます。\n"

#. type: Plain text
#: text/chapter7.md:135
#, no-wrap
msgid "Putting this all together, we see that if we have values `x :: f a` and `y :: f b`, then the expression `(g <$> x) <*> y` has type `f c` (remember, this expression is equivalent to `apply (map g x) y`). The precedence rules defined in the Prelude allow us to remove the parentheses: `g <$> x <*> y`.\n"
msgstr "纏めると、`x :: f a`と`y :: f b`があるとき、式`(g <$> x) <*> y`の型は`f c`になります（この式は`apply (map g x)  y`と同じ意味だということを思い出しましょう）。Preludeで定義された優先順位の規則に従うと、`g <$> x <*> y`というように括弧を外すことができます。\n"

#. type: Plain text
#: text/chapter7.md:137
#, no-wrap
msgid "In general, we can use `<$>` on the first argument, and `<*>` for the remaining arguments, as illustrated here for `lift3`:\n"
msgstr "一般的には、最初の引数に`<$>`を使い、残りの引数に対しては`<*>`を使います。`lift3`で説明すると次のようになります。\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:138
#, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z\n"
msgstr ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z\n"

#. type: Plain text
#: text/chapter7.md:150
#, no-wrap
msgid "> It is left as an exercise for the reader to verify the types involved in this expression.\n"
msgstr "> この式に関する型の検証は、読者への演習として残しておきます。\n"

#. type: Plain text
#: text/chapter7.md:152
#, no-wrap
msgid "As an example, we can try lifting the address function over `Maybe`, directly using the `<$>` and `<*>` functions:\n"
msgstr "例として、`<$>`と`<*>`をそのまま使うと、`Maybe`上に`address`関数を持ち上げることができます。\n"

#. type: Fenced code block (text)
#: text/chapter7.md:153
#, no-wrap
msgid ""
"> address <$> Just \"123 Fake St.\" <*> Just \"Faketown\" <*> Just \"CA\"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
"\n"
"> address <$> Just \"123 Fake St.\" <*> Nothing <*> Just \"CA\"\n"
"Nothing\n"
msgstr ""
"> address <$> Just \"123 Fake St.\" <*> Just \"Faketown\" <*> Just \"CA\"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
"\n"
"> address <$> Just \"123 Fake St.\" <*> Nothing <*> Just \"CA\"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:162
msgid ""
"Try lifting some other functions of various numbers of arguments over "
"`Maybe` in this way."
msgstr ""
"同様にして、引数が異なる他のいろいろな関数を`Maybe`上に持ち上げてみてくださ"
"い。"

#. type: Plain text
#: text/chapter7.md:164
msgid ""
"Alternatively, _applicative do notation_ can be used for the same purpose in "
"a way that looks similar to the familiar _do notation_. Here is `lift3` "
"using _applicative do notation_. Note `ado` is used instead of `do`, and "
"`in` is used on the final line to denote the yielded value:"
msgstr ""
"この代わりに、お馴染の*do記法*に似た見た目の*アプリカティブdo記法*が同じ目的"
"で使えます。\n"
"以下では`lift3`に*アプリカティブdo記法*を使っています。\n"
"なお、`ado`が`do`の代わりに使われており、生み出された値を示すために最後の行で"
"`in`が使われています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:165
#, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = ado\n"
"  a <- x\n"
"  b <- y\n"
"  c <- z\n"
"  in f a b c\n"
msgstr ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = ado\n"
"  a <- x\n"
"  b <- y\n"
"  c <- z\n"
"  in f a b c\n"

#. type: Title ##
#: text/chapter7.md:180
#, no-wrap
msgid "The Applicative Type Class"
msgstr "アプリカティブ型クラス"

#. type: Plain text
#: text/chapter7.md:183
msgid "There is a related type class called `Applicative`, defined as follows:"
msgstr ""
"関連する`Applicative`という型クラスが存在しており、次のように定義されていま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:184
#, no-wrap
msgid ""
"class Apply f <= Applicative f where\n"
"  pure :: forall a. a -> f a\n"
msgstr ""
"class Apply f <= Applicative f where\n"
"  pure :: forall a. a -> f a\n"

#. type: Plain text
#: text/chapter7.md:190
msgid ""
"`Applicative` is a subclass of `Apply` and defines the `pure` function. "
"`pure` takes a value and returns a value whose type has been wrapped with "
"the type constructor `f`."
msgstr ""
"`Applicative`は`Apply`の下位クラスであり、`pure`関数が定義されています。\n"
"`pure`は値を取り、その型の型構築子`f`で包まれた値を返します。"

#. type: Plain text
#: text/chapter7.md:192
msgid "Here is the `Applicative` instance for `Maybe`:"
msgstr "`Maybe`についての`Applicative`インスタンスは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:193
#, no-wrap
msgid ""
"instance Applicative Maybe where\n"
"  pure x = Just x\n"
msgstr ""
"instance Applicative Maybe where\n"
"  pure x = Just x\n"

#. type: Plain text
#: text/chapter7.md:199
msgid ""
"If we think of applicative functors as functors that allow lifting of "
"functions, then `pure` can be thought of as lifting functions of zero "
"arguments."
msgstr ""
"アプリカティブ関手は関数を持ち上げることを可能にする関手だと考えるとすると、"
"`pure`は引数のない関数の持ち上げだというように考えられます。"

#. type: Title ##
#: text/chapter7.md:200
#, no-wrap
msgid "Intuition for Applicative"
msgstr "アプリカティブに対する直感的理解"

#. type: Plain text
#: text/chapter7.md:203
msgid ""
"Functions in PureScript are pure and do not support side-effects. "
"Applicative functors allow us to work in larger \"programming languages\" "
"which support some sort of side-effect encoded by the functor `f`."
msgstr ""
"PureScriptの関数は純粋であり、副作用は持っていません。Applicative関手は、関手"
"`f`によって表現されるある種の副作用を提供するような、より大きな「プログラミン"
"グ言語」を扱えるようにします。"

#. type: Plain text
#: text/chapter7.md:205
#, no-wrap
msgid "As an example, the functor `Maybe` represents the side effect of possibly-missing values. Some other examples include `Either err`, which represents the side effect of possible errors of type `err`, and the arrow functor `r ->`, which represents the side-effect of reading from a global configuration. For now, we'll only consider the `Maybe` functor.\n"
msgstr ""
"例えば関手`Maybe`は欠けている可能性がある値の副作用を表現しています。\n"
"その他の例としては、型`err`のエラーの可能性の副作用を表す`Either err`や、大域的な構成を読み取る副作用を表すArrow関手 (arrow functor) `r ->`があります。\n"
"ここでは`Maybe`関手についてのみ考えることにします。\n"

#. type: Plain text
#: text/chapter7.md:207
msgid ""
"If the functor `f` represents this larger programming language with effects, "
"then the `Apply` and `Applicative` instances allow us to lift values and "
"function applications from our smaller programming language (PureScript) "
"into the new language."
msgstr ""
"もし関手`f`が作用を持つ、より大きなプログラミング言語を表すとすると、`Apply`"
"と`Applicative`インスタンスは小さなプログラミング言語 (PureScript) から新しい"
"大きな言語へと値や関数を持ち上げることを可能にします。"

#. type: Plain text
#: text/chapter7.md:209
msgid ""
"`pure` lifts pure (side-effect free) values into the larger language; for "
"functions, we can use `map` and `apply` as described above."
msgstr ""
"`pure`は純粋な（副作用がない）値をより大きな言語へと持ち上げますし、関数につ"
"いては上で述べた通り`map`と`apply`を使えます。"

#. type: Plain text
#: text/chapter7.md:211
msgid ""
"This raises a question: if we can use `Applicative` to embed PureScript "
"functions and values into this new language, then how is the new language "
"any larger? The answer depends on the functor `f`. If we can find "
"expressions of type `f a` which cannot be expressed as `pure x` for some "
"`x`, then that expression represents a term which only exists in the larger "
"language."
msgstr ""
"ここで疑問が生まれます。\n"
"もしPureScriptの関数と値を新たな言語へ埋め込むのに`Applicative`が使えるなら、"
"どうやって新たな言語は大きくなっているというのでしょうか。\n"
"この答えは関手`f`に依存します。\n"
"もしなんらかの`x`について`pure x`で表せないような型`f a`の式を見つけたなら、"
"その式はそのより大きな言語だけに存在する項を表しているということです。"

#. type: Plain text
#: text/chapter7.md:213
msgid ""
"When `f` is `Maybe`, an example is the expression `Nothing`: we cannot write "
"`Nothing` as `pure x` for any `x`. Therefore, we can think of PureScript as "
"having been enlarged to include the new term `Nothing`, which represents a "
"missing value."
msgstr ""
"`f`が`Maybe`のときは、式`Nothing`がその例になっています。\n"
"どんな`x`があっても`Nothing`を`pure x`というように書くことはできません。\n"
"したがって、PureScriptは値の欠落を表す新しい項`Nothing`を含むように拡大された"
"と考えることができます。"

#. type: Title ##
#: text/chapter7.md:214
#, no-wrap
msgid "More Effects"
msgstr "もっと作用を"

#. type: Plain text
#: text/chapter7.md:217
msgid ""
"Let's see some more examples of lifting functions over different "
"`Applicative` functors."
msgstr ""
"様々な`Applicative`関手へと関数を持ち上げる例をもっと見ていきましょう。"

#. type: Plain text
#: text/chapter7.md:219
msgid ""
"Here is a simple example function defined in PSCi, which joins three names "
"to form a full name:"
msgstr ""
"以下は、PSCiで定義された3つの名前を結合して完全な名前を作る簡単な関数の例で"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:220
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> fullName first middle last = last <> \", \" <> first <> \" \" <> middle\n"
"\n"
"> fullName \"Phillip\" \"A\" \"Freeman\"\n"
"Freeman, Phillip A\n"
msgstr ""
"> import Prelude\n"
"\n"
"> fullName first middle last = last <> \", \" <> first <> \" \" <> middle\n"
"\n"
"> fullName \"Phillip\" \"A\" \"Freeman\"\n"
"Freeman, Phillip A\n"

# XXX: Maybeを行中コードとしてマークアップしたいです。
#. type: Plain text
#: text/chapter7.md:230
msgid ""
"Suppose that this function forms the implementation of a (very simple!) web "
"service with the three arguments provided as query parameters. We want to "
"ensure that the user provided each of the three parameters, so we might use "
"the Maybe type to indicate the presence or absence of a parameter. We can "
"lift `fullName` over `Maybe` to create an implementation of the web service "
"which checks for missing parameters:"
msgstr ""
"この関数が、クエリ引数として与えられた3つの引数を持つ、（とっても簡単な）web"
"サービスの実装を形成しているとしましょう。\n"
"使用者が3つの各引数を与えたことを確かめたいので、引数が存在するかどうかを表す"
"`Maybe`型を使うことになるでしょう。\n"
"`fullName`を`Maybe`の上へ持ち上げると、欠けている引数を検査するwebサービスの"
"実装を作成できます。"

#. type: Fenced code block (text)
#: text/chapter7.md:231
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"
msgstr ""
"> import Data.Maybe\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:242 text/chapter7.md:292 text/chapter7.md:444
#: text/chapter7.md:479 text/chapter7.md:525
msgid "Or with _applicative do_:"
msgstr "または*アプリカティブdo*で次のようにします。"

#. type: Fenced code block (text)
#: text/chapter7.md:243
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> :paste…\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Just \"A\"\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"(Just \"Freeman, Phillip A\")\n"
"\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Nothing\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"Nothing\n"
msgstr ""
"> import Data.Maybe\n"
"\n"
"> :paste…\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Just \"A\"\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"(Just \"Freeman, Phillip A\")\n"
"\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Nothing\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:265
msgid ""
"Note that the lifted function returns `Nothing` if any of the arguments was "
"`Nothing`."
msgstr ""
"この持ち上げた関数は、引数の何れかが`Nothing`なら`Nothing`を返すことに注意し"
"てください。"

#. type: Plain text
#: text/chapter7.md:267
msgid ""
"This is good because now we can send an error response back from our web "
"service if the parameters are invalid. However, it would be better if we "
"could indicate which field was incorrect in the response."
msgstr ""
"引数が不正のときにwebサービスからエラー応答を送り返せるのは良いことです。\n"
"しかし、どのフィールドが不正確なのかを応答で示せると、もっと良くなるでしょ"
"う。"

#. type: Plain text
#: text/chapter7.md:269
msgid ""
"Instead of lifting over `Maybe`, we can lift over `Either String`, which "
"allows us to return an error message. First, let's write an operator to "
"convert optional inputs into computations which can signal an error using "
"`Either String`:"
msgstr ""
"`Meybe`上へ持ち上げる代わりに`Either String`上へ持ち上げるようにすると、エ"
"ラー文言を返せるようになります。\n"
"まずは`Either String`を使い、省略可能な入力からエラーを発信できる計算に変換す"
"る演算子を書きましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:270
#, no-wrap
msgid ""
"> import Data.Either\n"
"> :paste\n"
"… withError Nothing  err = Left err\n"
"… withError (Just a) _   = Right a\n"
"… ^D\n"
msgstr ""
"> import Data.Either\n"
"> :paste\n"
"… withError Nothing  err = Left err\n"
"… withError (Just a) _   = Right a\n"
"… ^D\n"

#. type: Plain text
#: text/chapter7.md:279
msgid ""
"_Note_: In the `Either err` applicative functor, the `Left` constructor "
"indicates an error, and the `Right` constructor indicates success."
msgstr ""
"*補足*：`Either err`アプリカティブ関手において、`Left`構築子は失敗を表してお"
"り、`Right`構築子は成功を表しています。"

#. type: Plain text
#: text/chapter7.md:281
msgid ""
"Now we can lift over `Either String`, providing an appropriate error message "
"for each parameter:"
msgstr ""
"これで`Either String`上へ持ち上げることで、それぞれの引数について適切なエラー"
"文言を提供できるようになります。"

#. type: Fenced code block (text)
#: text/chapter7.md:282
#, no-wrap
msgid ""
"> :paste\n"
"… fullNameEither first middle last =\n"
"…   fullName <$> (first  `withError` \"First name was missing\")\n"
"…            <*> (middle `withError` \"Middle name was missing\")\n"
"…            <*> (last   `withError` \"Last name was missing\")\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… fullNameEither first middle last =\n"
"…   fullName <$> (first  `withError` \"First name was missing\")\n"
"…            <*> (middle `withError` \"Middle name was missing\")\n"
"…            <*> (last   `withError` \"Last name was missing\")\n"
"… ^D\n"

#. type: Fenced code block (text)
#: text/chapter7.md:293
#, no-wrap
msgid ""
"> :paste\n"
"… fullNameEither first middle last = ado\n"
"…  f <- first  `withError` \"First name was missing\"\n"
"…  m <- middle `withError` \"Middle name was missing\"\n"
"…  l <- last   `withError` \"Last name was missing\"\n"
"…  in fullName f m l\n"
"… ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"
msgstr ""
"> :paste\n"
"… fullNameEither first middle last = ado\n"
"…  f <- first  `withError` \"First name was missing\"\n"
"…  m <- middle `withError` \"Middle name was missing\"\n"
"…  l <- last   `withError` \"Last name was missing\"\n"
"…  in fullName f m l\n"
"… ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"

# FIXME: Maybeの行中コードのマークアップが崩れている気がします。
#. type: Plain text
#: text/chapter7.md:307
msgid ""
"Now our function takes three optional arguments using `Maybe, and returns "
"either a`String` error message or a `String` result."
msgstr ""
"これでこの関数は`Maybe`を使う3つの省略可能な引数を取り、`String`のエラー文言"
"か`String`の結果のどちらかを返します。"

#. type: Plain text
#: text/chapter7.md:309
msgid "We can try out the function with different inputs:"
msgstr "いろいろな入力でこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:310
#, no-wrap
msgid ""
"> fullNameEither (Just \"Phillip\") (Just \"A\") (Just \"Freeman\")\n"
"(Right \"Freeman, Phillip A\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") Nothing (Just \"Freeman\")\n"
"(Left \"Middle name was missing\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") (Just \"A\") Nothing\n"
"(Left \"Last name was missing\")\n"
msgstr ""
"> fullNameEither (Just \"Phillip\") (Just \"A\") (Just \"Freeman\")\n"
"(Right \"Freeman, Phillip A\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") Nothing (Just \"Freeman\")\n"
"(Left \"Middle name was missing\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") (Just \"A\") Nothing\n"
"(Left \"Last name was missing\")\n"

#. type: Plain text
#: text/chapter7.md:322
msgid ""
"In this case, we see the error message corresponding to the first missing "
"field or a successful result if every field was provided. However, if we are "
"missing multiple inputs, we still only see the first error:"
msgstr ""
"このとき、全てのフィールドが与えられば成功の結果が表示され、そうでなければ省"
"略されたフィールドのうち最初のものに対応するエラー文言が表示されます。\n"
"しかし、もし複数の入力が省略されているとき、最初のエラーしか見られません。"

#. type: Fenced code block (text)
#: text/chapter7.md:323
#, no-wrap
msgid ""
"> fullNameEither Nothing Nothing Nothing\n"
"(Left \"First name was missing\")\n"
msgstr ""
"> fullNameEither Nothing Nothing Nothing\n"
"(Left \"First name was missing\")\n"

#. type: Plain text
#: text/chapter7.md:329
msgid ""
"This might be good enough, but if we want to see a list of _all_ missing "
"fields in the error, then we need something more powerful than `Either "
"String`. We will see a solution later in this chapter."
msgstr ""
"これでも充分なときもありますが、エラー時に*全ての*省略されたフィールドの一覧"
"がほしいときは、`Either String`よりも強力なものが必要です。この章の後半で解決"
"策を見ていきます。"

#. type: Title ##
#: text/chapter7.md:330
#, no-wrap
msgid "Combining Effects"
msgstr "作用の結合"

#. type: Plain text
#: text/chapter7.md:333
msgid ""
"As an example of working with applicative functors abstractly, this section "
"will show how to write a function that generically combines side-effects "
"encoded by an applicative functor `f`."
msgstr ""
"抽象的にアプリカティブ関手を扱う例として、この節ではアプリカティブ関手`f`に"
"よって表現された副作用を一般的に組み合わせる関数を書く方法を示します。"

#. type: Plain text
#: text/chapter7.md:335
msgid ""
"What does this mean? Well, suppose we have a list of wrapped arguments of "
"type `f a` for some `a`. That is, suppose we have a list of type `List (f "
"a)`. Intuitively, this represents a list of computations with side-effects "
"tracked by `f`, each with return type `a`. If we could run all of these "
"computations in order, we would obtain a list of results of type `List a`. "
"However, we would still have side-effects tracked by `f`. That is, we expect "
"to be able to turn something of type `List (f a)` into something of type `f "
"(List a)` by \"combining\" the effects inside the original list."
msgstr ""
"これはどういう意味でしょうか。\n"
"何らかの`a`について型`f a`で包まれた引数のリストがあるとしましょう。\n"
"それは型`List (f a)`のリストがあるということです。\n"
"直感的には、これは`f`によって追跡される副作用を持つ、返り値の型が`a`の計算の"
"リストを表しています。\n"
"これらの計算の全てを順番に実行できれば、`List a`型の結果のリストを得るでしょ"
"う。\n"
"しかし、まだ`f`によって追跡される副作用が残ります。\n"
"つまり、元のリストの中の作用を「結合する」ことにより、型`List (f a)`の何かを"
"型`f (List a)`の何かへと変換できると考えられます。"

#. type: Plain text
#: text/chapter7.md:337
#, no-wrap
msgid "For any fixed list size `n`, there is a function of `n` arguments that builds a list of size `n` out of those arguments. For example, if `n` is `3`, the function is `\\x y z -> x : y : z : Nil`. This function has type `a -> a -> a -> List a`. We can use the `Applicative` instance for `List` to lift this function over `f`, to get a function of type `f a -> f a -> f a -> f (List a)`. But, since we can do this for any `n`, it makes sense that we should be able to perform the same lifting for any _list_ of arguments.\n"
msgstr ""
"任意の固定長リストの長さ`n`について、`n`引数からその引数を要素に持つ長さ`n`のリストを構築する関数が存在します。\n"
"例えばもし`n`が`3`なら、関数は`\\x y z -> x : y : z : Nil`です。\n"
"この関数は型`a -> a -> a -> List a`を持ちます。\n"
"`Applicative`インスタンスを使うと、この関数を`f`の上へ持ち上げられ、関数型`f a -> f a -> f a -> f (List a)`が得られます。\n"
"しかし、いかなる`n`についてもこれが可能なので、いかなる引数の*リスト*についても同じように持ち上げられることが確かめられます。\n"

#. type: Plain text
#: text/chapter7.md:339
msgid "That means that we should be able to write a function"
msgstr "したがって、次のような関数を書くことができるはずです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:340 text/chapter7.md:602
#, no-wrap
msgid "combineList :: forall f a. Applicative f => List (f a) -> f (List a)\n"
msgstr "combineList :: forall f a. Applicative f => List (f a) -> f (List a)\n"

#. type: Plain text
#: text/chapter7.md:345
msgid ""
"This function will take a list of arguments, which possibly have side-"
"effects, and return a single wrapped list, applying the side-effects of each."
msgstr ""
"この関数は副作用を持つかもしれない引数のリストを取り、それぞれの副作用を適用"
"することで、`f`に包まれた単一のリストを返します。"

#. type: Plain text
#: text/chapter7.md:347
msgid ""
"To write this function, we'll consider the length of the list of arguments. "
"If the list is empty, then we do not need to perform any effects, and we can "
"use `pure` to simply return an empty list:"
msgstr ""
"この関数を書くためには、引数のリストの長さについて考えます。\n"
"リストが空の場合はどんな作用も実行する必要がありませんから、`pure`を使用して"
"単に空のリストを返すことができます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:348
#, no-wrap
msgid "combineList Nil = pure Nil\n"
msgstr "combineList Nil = pure Nil\n"

#. type: Plain text
#: text/chapter7.md:353
msgid "In fact, this is the only thing we can do!"
msgstr "実際のところこれがたった1つのできることです。"

#. type: Plain text
#: text/chapter7.md:355
#, no-wrap
msgid "If the list is non-empty, then we have a head element, which is a wrapped argument of type `f a`, and a tail of type `List (f a)`. We can recursively combine the effects in the tail, giving a result of type `f (List a)`. We can then use `<$>` and `<*>` to lift the `Cons` constructor over the head and new tail:\n"
msgstr ""
"入力のリストが空でないならば、型`f a`の包まれた引数である先頭要素と、型`List (f a)`の尾鰭について考えます。\n"
"また、再帰的にリストの残りを結合すると、型`f (List a)`の結果が得られます。\n"
"それから`<$>`と`<*>`を使うと、`Cons`構築子を先頭と新しい尾鰭の上に持ち上げることができます。\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:356
#, no-wrap
msgid "combineList (Cons x xs) = Cons <$> x <*> combineList xs\n"
msgstr "combineList (Cons x xs) = Cons <$> x <*> combineList xs\n"

#. type: Plain text
#: text/chapter7.md:361
msgid ""
"Again, this was the only sensible implementation, based on the types we were "
"given."
msgstr ""
"繰り返しになりますが、これは与えられた型に基づいている唯一の妥当な実装です。"

#. type: Plain text
#: text/chapter7.md:363
msgid ""
"We can test this function in PSCi, using the `Maybe` type constructor as an "
"example:"
msgstr "`Maybe`型構築子を例にとって、PSCiでこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:364
#, no-wrap
msgid ""
"> import Data.List\n"
"> import Data.Maybe\n"
"\n"
"> combineList (fromFoldable [Just 1, Just 2, Just 3])\n"
"(Just (Cons 1 (Cons 2 (Cons 3 Nil))))\n"
"\n"
"> combineList (fromFoldable [Just 1, Nothing, Just 2])\n"
"Nothing\n"
msgstr ""
"> import Data.List\n"
"> import Data.Maybe\n"
"\n"
"> combineList (fromFoldable [Just 1, Just 2, Just 3])\n"
"(Just (Cons 1 (Cons 2 (Cons 3 Nil))))\n"
"\n"
"> combineList (fromFoldable [Just 1, Nothing, Just 2])\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:376
msgid ""
"When specialized to `Maybe`, our function returns a `Just` only if every "
"list element is `Just`; otherwise, it returns `Nothing`. This is consistent "
"with our intuition of working in a larger language supporting optional "
"values – a list of computations that produce optional results only has a "
"result itself if every computation contained a result."
msgstr ""
"`Meybe`へ特殊化すると、リストの全ての要素が`Just`であるときに限りこの関数は"
"`Just`を返しますし、そうでなければ`Nothing`を返します。\n"
"これは省略可能な値に対応する、より大きな言語に取り組む上での直感と一貫してい"
"ます。\n"
"省略可能な結果を生む計算のリストは、全ての計算が結果を持っているならばそれ自"
"身の結果のみを持つのです。"

#. type: Plain text
#: text/chapter7.md:378
#, no-wrap
msgid "But the `combineList` function works for any `Applicative`! We can use it to combine computations that possibly signal an error using `Either err`, or which read from a global configuration using `r ->`.\n"
msgstr ""
"ところが`combineList`関数はどんな`Applicative`に対しても機能するのです。\n"
"`Either err`を使ってエラーを発信する可能性を持たせたり、`r ->`を使って大域的な構成を読み取る計算を組み合わせるためにも使えます。\n"

#. type: Plain text
#: text/chapter7.md:380
msgid ""
"We will see the `combineList` function again later when we consider "
"`Traversable` functors."
msgstr ""
"`combineList`関数については、後ほど`Traversable`関手について考えるときに再訪"
"します。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Medium) Write versions of the numeric operators `+`, `-`, `*`, and `/` "
"which work with optional arguments (i.e., arguments wrapped in `Maybe`) and "
"return a value wrapped in `Maybe`. Name these functions `addMaybe`, "
"`subMaybe`, `mulMaybe`, and `divMaybe`. _Hint_: Use `lift2`."
msgstr ""
"（普通）数値演算子`+`、`-`、`*`、`/`の別のバージョンを書いてください。\n"
"ただし省略可能な引数（つまり`Maybe`に包まれた引数）を扱って`Maybe`に包まれた"
"値を返します。\n"
"これらの関数には`addMaybe`、`subMaybe`、`mulMaybe`、`divMaybe`と名前を付けて"
"ください。\n"
"*手掛かり*：`lift2`を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Medium) Extend the above exercise to work with all `Apply` types (not just "
"`Maybe`). Name these new functions `addApply`, `subApply`, `mulApply`, and "
"`divApply`."
msgstr ""
"（普通）上の演習を（`Maybe`だけでなく）全ての`Apply`型で動くように拡張してく"
"ださい。\n"
"これらの新しい関数には`addApply`、`subApply`、`mulApply`、`divApply`と名前を"
"付けます。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Difficult) Write a function `combineMaybe` which has type `forall a f. "
"Applicative f => Maybe (f a) -> f (Maybe a)`. This function takes an "
"optional computation with side-effects and returns a side-effecting "
"computation with an optional result."
msgstr ""
"（難しい）型`forall a f. Applicative f => Maybe (f a) -> f (Maybe a)`を持つ関"
"数`combineMaybe`を書いてください。\n"
"この関数は副作用を持つ省略可能な計算を取り、省略可能な結果を持つ副作用のある"
"計算を返します。"

#. type: Plain text
#: text/chapter7.md:390
msgid ""
"The source code for this chapter defines several data types which might be "
"used in an address book application. The details are omitted here, but the "
"key functions exported by the `Data.AddressBook` module have the following "
"types:"
msgstr ""
"この章のソースコードでは住所録アプリケーションで使うであろう幾つかのデータ型"
"が定義されています。\n"
"詳細はここでは割愛しますが、`Data.AddressBook`モジュールからエクスポートされ"
"る鍵となる関数は次のような型を持ちます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:391
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:phoneNumber_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:person_anno}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:phoneNumber_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:person_anno}}\n"

#. type: Plain text
#: text/chapter7.md:400
msgid "Where `PhoneType` is defined as an algebraic data type:"
msgstr "ここで、`PhoneType`は次のような代数的データ型として定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:401
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:PhoneType}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:PhoneType}}\n"

#. type: Plain text
#: text/chapter7.md:406
msgid ""
"These functions can construct a `Person` representing an address book entry. "
"For example, the following value is defined in `Data.AddressBook`:"
msgstr ""
"これらの関数は住所録の項目を表す`Person`を構築できます。\n"
"例えば、`Data.AddressBook`では以下の値が定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:407
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:examplePerson}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:examplePerson}}\n"

#. type: Plain text
#: text/chapter7.md:412
msgid "Test this value in PSCi (this result has been formatted):"
msgstr "PSCiでこれらの値を試してみましょう（結果は整形されています）。"

#. type: Fenced code block (text)
#: text/chapter7.md:413
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> examplePerson\n"
"{ firstName: \"John\"\n"
", lastName: \"Smith\"\n"
", homeAddress:\n"
"    { street: \"123 Fake St.\"\n"
"    , city: \"FakeTown\"\n"
"    , state: \"CA\"\n"
"    }\n"
", phones:\n"
"    [ { type: HomePhone\n"
"      , number: \"555-555-5555\"\n"
"      }\n"
"    , { type: CellPhone\n"
"      , number: \"555-555-0000\"\n"
"      }\n"
"    ]\n"
"}\n"
msgstr ""
"> import Data.AddressBook\n"
"\n"
"> examplePerson\n"
"{ firstName: \"John\"\n"
", lastName: \"Smith\"\n"
", homeAddress:\n"
"    { street: \"123 Fake St.\"\n"
"    , city: \"FakeTown\"\n"
"    , state: \"CA\"\n"
"    }\n"
", phones:\n"
"    [ { type: HomePhone\n"
"      , number: \"555-555-5555\"\n"
"      }\n"
"    , { type: CellPhone\n"
"      , number: \"555-555-0000\"\n"
"      }\n"
"    ]\n"
"}\n"

#. type: Plain text
#: text/chapter7.md:436
msgid ""
"We saw in a previous section how we could use the `Either String` functor to "
"validate a data structure of type `Person`. For example, provided functions "
"to validate the two names in the structure, we might validate the entire "
"data structure as follows:"
msgstr ""
"前の章では型`Person`のデータ構造を検証する上で`Either String`関手の使い方を見"
"ました。例えば、データ構造の2つの名前を検証する関数が与えられたとき、データ構"
"造全体を次のように検証できます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:437
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty1}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty1}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1}}\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:445
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1Ado}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1Ado}}\n"

#. type: Plain text
#: text/chapter7.md:450
msgid ""
"In the first two lines, we use the `nonEmpty1` function to validate a non-"
"empty string. `nonEmpty1` returns an error indicated with the `Left` "
"constructor if its input is empty. Otherwise, it returns the value wrapped "
"with the `Right` constructor."
msgstr ""
"最初の2行では`nonEmpty1`関数を使って空文字列でないことを検証しています。\n"
"もし入力が空なら`nonEmpty1`は`Left`構築子で示されるエラーを返します。\n"
"そうでなければ`Right`構築子で包まれた値を返します。"

#. type: Plain text
#: text/chapter7.md:452
msgid ""
"The final lines do not perform any validation but simply provide the "
"`address` and `phones` fields to the `person` function as the remaining "
"arguments."
msgstr ""
"最後の2行では何の検証も実行せず、単に`address`フィールドと`phones`フィールド"
"を残りの引数として`person`関数へと提供しています。"

#. type: Plain text
#: text/chapter7.md:454
msgid ""
"This function can be seen to work in PSCi, but it has a limitation that we "
"have seen before:"
msgstr ""
"この関数はPSCiでうまく動作するように見えますが、以前見たような制限がありま"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:455
#, no-wrap
msgid ""
"> validatePerson $ person \"\" \"\" (address \"\" \"\" \"\") []\n"
"(Left \"Field cannot be empty\")\n"
msgstr ""
"> validatePerson $ person \"\" \"\" (address \"\" \"\" \"\") []\n"
"(Left \"Field cannot be empty\")\n"

#. type: Plain text
#: text/chapter7.md:461
msgid ""
"The `Either String` applicative functor only provides the first error "
"encountered. Given the input here, we would prefer to see two errors – one "
"for the missing first name and a second for the missing last name."
msgstr ""
"`Either String`アプリカティブ関手は最初に遭遇したエラーだけを返します。\n"
"仮にこの入力だったとすると、2つのエラーが分かったほうが良いでしょう。\n"
"1つは名前の不足で、2つ目は姓の不足です。"

#. type: Plain text
#: text/chapter7.md:463
msgid ""
"There is another applicative functor that the `validation` library provides. "
"This functor is called `V`, and it can return errors in any _semigroup_. For "
"example, we can use `V (Array String)` to return an array of `String`s as "
"errors, concatenating new errors onto the end of the array."
msgstr ""
"`validation`ライブラリでは別のアプリカティブ関手も提供されています。\n"
"これは`V`という名前で、何らかの*半群*でエラーを返せます。\n"
"例えば`V (Array String)`を使うと、新しいエラーを配列の最後に連結していき、"
"`String`の配列をエラーとして返せます。"

#. type: Plain text
#: text/chapter7.md:465
msgid ""
"The `Data.AddressBook.Validation` module uses the `V (Array String)` "
"applicative functor to validate the data structures in the `Data."
"AddressBook` module."
msgstr ""
"`Data.Validation`モジュールは`Data.AddressBook`モジュールのデータ構造を検証す"
"るために`V (Array String)`アプリカティブ関手を使っています。"

#. type: Plain text
#: text/chapter7.md:467
msgid ""
"Here is an example of a validator taken from the `Data.AddressBook."
"Validation` module:"
msgstr ""
"`Data.AddressBook.Validation`モジュールから取材した検証器の例は次のようになり"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:468
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:Errors}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:lengthIs}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddress}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:Errors}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:lengthIs}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddress}}\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:480
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddressAdo}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddressAdo}}\n"

#. type: Plain text
#: text/chapter7.md:485
msgid ""
"`validateAddress` validates an `Address` structure. It checks that the "
"`street` and `city` fields are non-empty and that the string in the `state` "
"field has length 2."
msgstr ""
"`validateAddress`は`Address`の構造を検証します。\n"
"`street`と`city`が空でないかどうか、`state`の文字列の長さが2であるかどうかを"
"検証します。"

#. type: Plain text
#: text/chapter7.md:487
msgid ""
"Notice how the `nonEmpty` and `lengthIs` validator functions both use the "
"`invalid` function provided by the `Data.Validation` module to indicate an "
"error. Since we are working in the `Array String` semigroup, `invalid` takes "
"an array of strings as its argument."
msgstr ""
"`nonEmpty`と`lengthIs`の2つの検証関数が何れも、`Data.Validation`モジュールで"
"提供されている`invalid`関数をエラーを示すために使っているところに注目してくだ"
"さい。\n"
"`Array String`半群を扱っているので、`invalid`は引数として文字列の配列を取りま"
"す。"

#. type: Plain text
#: text/chapter7.md:489
msgid "We can try this function in PSCi:"
msgstr "PSCiでこの関数を試しましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:490
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> validateAddress $ address \"\" \"\" \"\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         , \"Field 'State' must have length 2\"\n"
"         ])\n"
"\n"
"> validateAddress $ address \"\" \"\" \"CA\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         ])\n"
msgstr ""
"> import Data.AddressBook\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> validateAddress $ address \"\" \"\" \"\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         , \"Field 'State' must have length 2\"\n"
"         ])\n"
"\n"
"> validateAddress $ address \"\" \"\" \"CA\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         ])\n"

#. type: Plain text
#: text/chapter7.md:507
msgid "This time, we receive an array of all validation errors."
msgstr "これで、全ての検証エラーの配列を受け取ることができるようになりました。"

#. type: Title ##
#: text/chapter7.md:508
#, no-wrap
msgid "Regular Expression Validators"
msgstr "正規表現検証器"

#. type: Plain text
#: text/chapter7.md:511
msgid ""
"The `validatePhoneNumber` function uses a regular expression to validate the "
"form of its argument. The key is a `matches` validation function, which uses "
"a `Regex` from the `Data.String.Regex` module to validate its input:"
msgstr ""
"`validatePhoneNumber`関数では引数の形式を検証するために正規表現を使っていま"
"す。重要なのは`matches`検証関数で、この関数は`Data.String.Regex`モジュールで"
"定義されている`Regex`を使って入力を検証しています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:512
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:matches}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:matches}}\n"

#. type: Plain text
#: text/chapter7.md:517
msgid ""
"Again, notice how `pure` is used to indicate successful validation, and "
"`invalid` is used to signal an array of errors."
msgstr ""
"繰り返しになりますが、`pure`は常に成功する検証を表しており、エラーの配列の伝"
"達には`invalid`が使われています。"

#. type: Plain text
#: text/chapter7.md:519
msgid ""
"`validatePhoneNumber` is built from the `matches` function in the same way "
"as before:"
msgstr ""
"これまでと同様に、`validatePhoneNumber`は`matches`関数から構築されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:520
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumber}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumber}}\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:526
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumberAdo}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumberAdo}}\n"

#. type: Plain text
#: text/chapter7.md:531
msgid ""
"Again, try running this validator against some valid and invalid inputs in "
"PSCi:"
msgstr ""
"また、PSCiでいろいろな有効な入力や無効な入力に対して、この検証器を実行してみ"
"てください。"

#. type: Fenced code block (text)
#: text/chapter7.md:532
#, no-wrap
msgid ""
"> validatePhoneNumber $ phoneNumber HomePhone \"555-555-5555\"\n"
"pure ({ type: HomePhone, number: \"555-555-5555\" })\n"
"\n"
"> validatePhoneNumber $ phoneNumber HomePhone \"555.555.5555\"\n"
"invalid ([\"Field 'Number' did not match the required format\"])\n"
msgstr ""
"> validatePhoneNumber $ phoneNumber HomePhone \"555-555-5555\"\n"
"pure ({ type: HomePhone, number: \"555-555-5555\" })\n"
"\n"
"> validatePhoneNumber $ phoneNumber HomePhone \"555.555.5555\"\n"
"invalid ([\"Field 'Number' did not match the required format\"])\n"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Easy) Write a regular expression `stateRegex :: Regex` to check that a "
"string only contains two alphabetic characters. _Hint_: see the source code "
"for `phoneNumberRegex`."
msgstr ""
"（簡単）正規表現`stateRegex :: Regex`を書いて文字列が2文字のアルファベットで"
"あることを確かめてください。\n"
"*手掛かり*：`phoneNumberRegex`のソースコードを参照してみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Medium) Write a regular expression `nonEmptyRegex :: Regex` to check that a "
"string is not entirely whitespace. _Hint_: If you need help developing this "
"regex expression, check out [RegExr](https://regexr.com), which has a great "
"cheatsheet and interactive test environment."
msgstr ""
"（普通）文字列全体が空白でないことを検査する正規表現`nonEmptyRegex :: Regex`"
"を書いてください。\n"
"*手掛かり*：この正規表現を開発するのに手助けが必要なら、[RegExr](https://"
"regexr.com)をご確認ください。\n"
"素晴しい早見表と対話的なお試し環境があります。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Medium) Write a function `validateAddressImproved` that is similar to "
"`validateAddress`, but uses the above `stateRegex` to validate the `state` "
"field and `nonEmptyRegex` to validate the `street` and `city` fields. "
"_Hint_: see the source for `validatePhoneNumber` for an example of how to "
"use `matches`."
msgstr ""
"（普通）`validateAddress`に似ていますが、上の`stateRegex`を使って`state`"
"フィールドを検証し、`nonEmptyRegex`を使って`street`と`city`フィールドを検証す"
"る関数`validateAddressImproved`を書いてください。\n"
"*手掛かり*：`matches`の用例については`validatePhoneNumber`のソースを見てくだ"
"さい。"

#. type: Title ##
#: text/chapter7.md:546
#, no-wrap
msgid "Traversable Functors"
msgstr "巡回可能関手"

#. type: Plain text
#: text/chapter7.md:549
msgid ""
"The remaining validator is `validatePerson`, which combines the validators "
"we have seen so far to validate an entire `Person` structure, including the "
"following new `validatePhoneNumbers` function:"
msgstr ""
"残った検証器は`validatePerson`です。\n"
"これはこれまで見てきた検証器と以下の新しい`validatePhoneNumbers`関数を組み合"
"わせて`Person`全体を検証するものです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:550
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumbers}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumbers}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson}}\n"

#. type: Plain text
#: text/chapter7.md:557
msgid "or with _applicative do_"
msgstr "または*アプリカティブdo*で次のようにします。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:558
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePersonAdo}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePersonAdo}}\n"

#. type: Plain text
#: text/chapter7.md:563
msgid ""
"`validatePhoneNumbers` uses a new function we haven't seen before – "
"`traverse`."
msgstr ""
"`validatePhoneNumbers`はこれまでに見たことのない新しい関数である`traverse`を"
"使っています。"

#. type: Plain text
#: text/chapter7.md:565
msgid ""
"`traverse` is defined in the `Data.Traversable` module, in the `Traversable` "
"type class:"
msgstr ""
"`traverse`は`Data.Traversable`モジュールの`Traversable`型クラスで定義されてい"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:566
#, no-wrap
msgid ""
"class (Functor t, Foldable t) <= Traversable t where\n"
"  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n"
"  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr ""
"class (Functor t, Foldable t) <= Traversable t where\n"
"  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n"
"  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"

#. type: Plain text
#: text/chapter7.md:573
msgid ""
"`Traversable` defines the class of _traversable functors_. The types of its "
"functions might look a little intimidating, but `validatePerson` provides a "
"good motivating example."
msgstr ""
"`Traversable`は _巡回可能関手_ の型クラスを定義します。これらの関数の型は少し"
"難しそうに見えるかもしれませんが、`validatePerson`は良いきっかけとなる例で"
"す。"

#. type: Plain text
#: text/chapter7.md:575
msgid ""
"Every traversable functor is both a `Functor` and `Foldable` (recall that a "
"_foldable functor_ was a type constructor that supported a fold operation, "
"reducing a structure to a single value). In addition, a traversable functor "
"can combine a collection of side-effects that depend on its structure."
msgstr ""
"全ての巡回可能関手は`Functor`と`Foldable`のどちらでもあります（*畳み込み可能"
"関手*は畳み込み操作に対応する型構築子であったことを思い出してください。\n"
"畳み込みとは構造を1つの値へと簡約するものでした）。\n"
"それに加えて、巡回可能関手はその構造に依存した副作用の集まりを組み合わせられ"
"ます。"

#. type: Plain text
#: text/chapter7.md:577
msgid ""
"This may sound complicated, but let's simplify things by specializing to the "
"case of arrays. The array type constructor is traversable, which means that "
"there is a function:"
msgstr ""
"複雑そうに聞こえるかもしれませんが、配列の場合に特殊化して簡単にした上で考え"
"てみましょう。配列型構築子は`Traversable`であり、つまりは次のような関数が存在"
"するということです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:578
#, no-wrap
msgid "traverse :: forall a b m. Applicative m => (a -> m b) -> Array a -> m (Array b)\n"
msgstr "traverse :: forall a b m. Applicative m => (a -> m b) -> Array a -> m (Array b)\n"

#. type: Plain text
#: text/chapter7.md:583
msgid ""
"Intuitively, given any applicative functor `m`, and a function which takes a "
"value of type `a` and returns a value of type `b` (with side-effects tracked "
"by `m`), we can apply the function to each element of an array of type "
"`Array a` to obtain a result of type `Array b` (with side-effects tracked by "
"`m`)."
msgstr ""
"直感的にはこうです。\n"
"任意のアプリカティブ関手`m`と、型`a`の値を取って型`b`の値を返す（`f`で追跡さ"
"れる副作用を持つ）関数が与えられたとします。\n"
"このとき、その関数を型`Array a`の配列のそれぞれの要素に適用して型`Array b`の"
"（`f`で追跡される副作用を持つ）結果を得ることができます。"

#. type: Plain text
#: text/chapter7.md:585
msgid ""
"Still not clear? Let's specialize further to the case where `m` is the `V "
"Errors` applicative functor above. Now, we have a function of type"
msgstr ""
"まだよくわからないでしょうか。それでは更に、`f`を上記の`V Errors`アプリカティ"
"ブ関手に特殊化して考えてみましょう。これで次の型を持つ関数が得られます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:586
#, no-wrap
msgid "traverse :: forall a b. (a -> V Errors b) -> Array a -> V Errors (Array b)\n"
msgstr "traverse :: forall a b. (a -> V Errors b) -> Array a -> V Errors (Array b)\n"

#. type: Plain text
#: text/chapter7.md:591
msgid ""
"This type signature says that if we have a validation function `m` for a "
"type `a`, then `traverse m` is a validation function for arrays of type "
"`Array a`. But that's exactly what we need to be able to validate the "
"`phones` field of the `Person` data structure! We pass `validatePhoneNumber` "
"to `traverse` to create a validation function that validates each element "
"successively."
msgstr ""
"この型シグネチャでは、型`a`についての検証関数`m`があれば、`traverse m`は型"
"`Array a`の配列についての検証関数であると書かれています。\n"
"ところがこれは正に`Person`データ構造体の`phones`フィールドを検証できるように"
"するのに必要なものです。\n"
"各要素が成功するかを検証する検証関数を作るために、`validatePhoneNumber`を"
"`traverse`へ渡しています。"

#. type: Plain text
#: text/chapter7.md:593
msgid ""
"In general, `traverse` walks over the elements of a data structure, "
"performing computations with side-effects and accumulating a result."
msgstr ""
"一般に、`traverse`はデータ構造の要素を1つずつ辿っていき、副作用を伴いつつ計算"
"し、結果を累算します。"

#. type: Plain text
#: text/chapter7.md:595
msgid ""
"The type signature for `Traversable`'s other function `sequence` might look "
"more familiar:"
msgstr ""
"`Traversable`のもう1つの関数、`sequence`の型シグネチャには見覚えがあるかもし"
"れません。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:596
#, no-wrap
msgid "sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr "sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"

#. type: Plain text
#: text/chapter7.md:601
msgid ""
"In fact, the `combineList` function that we wrote earlier is just a special "
"case of the `sequence` function from the `Traversable` type class. Setting "
"`t` to be the type constructor `List`, we recover the type of the "
"`combineList` function:"
msgstr ""
"実際、先ほど書いた`combineList`関数は`Traversable`型クラスの`sequence`関数の"
"特別な場合に過ぎません。\n"
"`t`を型構築子`List`だとすると、`combineList`関数の型が復元されます。"

#. type: Plain text
#: text/chapter7.md:607
msgid ""
"Traversable functors capture the idea of traversing a data structure, "
"collecting a set of effectful computations, and combining their effects. In "
"fact, `sequence` and `traverse` are equally important to the definition of "
"`Traversable` – each can be implemented in terms of the other. This is left "
"as an exercise for the interested reader."
msgstr ""
"巡回可能関手はデータ構造走査の考え方を見据えたものです。\n"
"これにより作用のある計算の集合を集めてその作用を結合します。\n"
"実際、`sequence`と`traversable`は`Traversable`を定義する上でどちらも同じくら"
"い重要です。\n"
"これらはお互いがお互いを利用して実装できます。\n"
"これについては興味ある読者への演習として残しておきます。"

#. type: Plain text
#: text/chapter7.md:609
msgid ""
"The `Traversable` instance for lists given in the `Data.List` module is:"
msgstr ""
"`Data.List`で与えられているリストの`Traversable`インスタンスは次の通り。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:610
#, no-wrap
msgid ""
"instance Traversable List where\n"
"-- traverse :: forall a b m. Applicative m => (a -> m b) -> List a -> m (List b)\n"
"traverse _ Nil         = pure Nil\n"
"traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs\n"
msgstr ""
"instance Traversable List where\n"
"-- traverse :: forall a b m. Applicative m => (a -> m b) -> List a -> m (List b)\n"
"traverse _ Nil         = pure Nil\n"
"traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs\n"

#. type: Plain text
#: text/chapter7.md:618
msgid ""
"(The actual definition was later modified to improve stack safety. You can "
"read more about that change [here](https://github.com/purescript/purescript-"
"lists/pull/87).)"
msgstr ""
"（実際の定義は後にスタック安全性を向上するために変更されました。その変更につ"
"いてより詳しくは[こちら](https://github.com/purescript/purescript-lists/"
"pull/87)で読むことができます）"

#. type: Plain text
#: text/chapter7.md:620
msgid ""
"In the case of an empty list, we can return an empty list using `pure`. If "
"the list is non-empty, we can use the function `f` to create a computation "
"of type `f b` from the head element. We can also call `traverse` recursively "
"on the tail. Finally, we can lift the `Cons` constructor over the "
"applicative functor `m` to combine the two results."
msgstr ""
"入力が空のリストのときには、`pure`を使って空のリストを返せます。\n"
"リストが空でないときは、関数`f`を使うと先頭の要素から型`f b`の計算を作成でき"
"ます。\n"
"また、尾鰭に対して`traverse`を再帰的に呼び出せます。\n"
"最後に、アプリカティブ関手`m`まで`Cons`構築子を持ち上げて、2つの結果を組み合"
"わせられます。"

#. type: Plain text
#: text/chapter7.md:622
msgid ""
"But there are more examples of traversable functors than just arrays and "
"lists. The `Maybe` type constructor we saw earlier also has an instance for "
"`Traversable`. We can try it in PSCi:"
msgstr ""
"巡回可能関手の例はただの配列やリスト以外にもあります。\n"
"以前に見た`Maybe`型構築子も`Traversable`のインスタンスを持っています。\n"
"PSCiで試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:623
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"> import Data.Traversable\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> traverse (nonEmpty \"Example\") Nothing\n"
"pure (Nothing)\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"\")\n"
"invalid ([\"Field 'Example' cannot be empty\"])\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"Testing\")\n"
"pure ((Just \"Testing\"))\n"
msgstr ""
"> import Data.Maybe\n"
"> import Data.Traversable\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> traverse (nonEmpty \"Example\") Nothing\n"
"pure (Nothing)\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"\")\n"
"invalid ([\"Field 'Example' cannot be empty\"])\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"Testing\")\n"
"pure ((Just \"Testing\"))\n"

#. type: Plain text
#: text/chapter7.md:639
msgid ""
"These examples show that traversing the `Nothing` value returns `Nothing` "
"with no validation, and traversing `Just x` uses the validation function to "
"validate `x`. That is, `traverse` takes a validation function for type `a` "
"and returns a validation function for `Maybe a`, i.e., a validation function "
"for optional values of type `a`."
msgstr ""
"これらの例では、`Nothing`の値の走査は検証なしで`Nothing`の値を返し、`Just x`"
"を走査すると`x`を検証するのに検証関数が使われるということを示しています。\n"
"要は、`traverse`は型`a`についての検証関数を取り、`Maybe a`についての検証関"
"数、つまり型`a`の省略可能な値についての検証関数を返すのです。"

# FIXME: Arrayに型変数を入れた方が種として分かりやすそうです。
#. type: Plain text
#: text/chapter7.md:641
msgid ""
"Other traversable functors include `Array`, `Tuple a`, and `Either a` for "
"any type `a`. Generally, most \"container\" data type constructors have "
"`Traversable` instances. As an example, the exercises will include writing a "
"`Traversable` instance for a type of binary trees."
msgstr ""
"他の巡回可能関手には、任意の型`a`についての`Array a`、`Tuple a`、`Either a`が"
"含まれます。\n"
"一般に、「容器」のようなほとんどのデータ型構築子は`Traversable`インスタンスを"
"持っています。\n"
"一例として、演習には二分木の型の`Traversable`インスタンスを書くことが含まれま"
"す。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:645
msgid ""
"(Easy) Write `Eq` and `Show` instances for the following binary tree data "
"structure:"
msgstr ""
"（簡単）`Eq`と`Show`インスタンスを以下の2分木データ構造に対して書いてくださ"
"い。"

#. type: Plain text
#: text/chapter7.md:649
#, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"
"     ```\n"

#. type: Plain text
#: text/chapter7.md:651
#, no-wrap
msgid "     Recall from the previous chapter that you may either write these instances manually or let the compiler derive them.\n"
msgstr "     これらのインスタンスを手作業で書くこともできますし、コンパイラに導出してもらうこともできることを前の章から思い起こしてください。\n"

#. type: Plain text
#: text/chapter7.md:653
#, no-wrap
msgid "     There are many \"correct\" formatting options for `Show` output. The test for this exercise expects the following whitespace style. This matches the default formatting of the generic show, so you only need to note this if you're planning on writing this instance manually.\n"
msgstr ""
"     `Show`の出力には多くの「正しい」書式の選択肢があります。\n"
"     この演習のテストでは以下の空白スタイルを期待しています。\n"
"     これは一般化されたshowの既定の書式と合致しているため、このインスタンスを手作業で書くつもりのときだけ、このことを念頭に置いておいてください。\n"

#. type: Plain text
#: text/chapter7.md:657
#, no-wrap
msgid ""
"     ```haskell\n"
"     (Branch (Branch Leaf 8 Leaf) 42 Leaf)\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     (Branch (Branch Leaf 8 Leaf) 42 Leaf)\n"
"     ```\n"

#. type: Bullet: ' 1. '
#: text/chapter7.md:659
msgid ""
"(Medium) Write a `Traversable` instance for `Tree a`, which combines side-"
"effects left-to-right. _Hint_: There are some additional instance "
"dependencies that need to be defined for `Traversable`."
msgstr ""
"（普通）`Traversable`インスタンスを`Tree a`に対して書いてください。\n"
"これは副作用を左から右に結合するものです。\n"
"*手掛かり*：`Traversable`に定義する必要のある追加のインスタンス依存関係が幾つ"
"かあります。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:661
msgid ""
"(Medium) Write a function `traversePreOrder :: forall a m b. Applicative m "
"=> (a -> m b) -> Tree a -> m (Tree b)` that performs a pre-order traversal "
"of the tree. This means the order of effect execution is root-left-right, "
"instead of left-root-right as was done for the previous in-order traverse "
"exercise. _Hint_: No additional instances need to be defined, and you don't "
"need to call any of the functions defined earlier. Applicative do notation "
"(`ado`) is the easiest way to write this function."
msgstr ""
"（普通）行き掛け順に木を巡回する関数`traversePreOrder :: forall a m b. "
"Applicative m => (a -> m b) -> Tree a -> m (Tree b)`を書いてください。\n"
"つまり作用の実行は根左右と行われ、以前の通り掛け順の巡回の演習でしたような左"
"根右ではありません。\n"
"*手掛かり*：追加でインスタンスを定義する必要はありませんし、前に定義した関数"
"は何も呼ぶ必要はありません。\n"
"アプリカティブdo記法 (`ado`) はこの関数を書く最も簡単な方法です。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:663
msgid ""
"(Medium) Write a function `traversePostOrder` that performs a post-order "
"traversal of the tree where effects are executed left-right-root."
msgstr ""
"（普通）木を帰り掛け順に巡回する関数`traversePostOrder`を書いてください。作用"
"は左右根と実行されます。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:665
msgid ""
"(Medium) Create a new version of the `Person` type where the `homeAddress` "
"field is optional (using `Maybe`). Then write a new version of "
"`validatePerson` (renamed as `validatePersonOptionalAddress`) to validate "
"this new `Person`. _Hint_: Use `traverse` to validate a field of type `Maybe "
"a`."
msgstr ""
"（普通）`homeAddress`フィールドが省略可能（`Maybe`を使用）な新しい版の"
"`Person`型をつくってください。\n"
"それからこの新しい`Person`を検証する新しい版の`validatePerson`"
"（`validatePersonOptionalAddress`と改名します）を書いてください。\n"
"*手掛かり*：`traverse`を使って型`Maybe a`のフィールドを検証してください。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:667
msgid ""
"(Difficult) Write a function `sequenceUsingTraverse` which behaves like "
"`sequence`, but is written in terms of `traverse`."
msgstr ""
"（難しい）`sequence`のように振る舞う関数`sequenceUsingTraverse`を書いてくださ"
"い。\n"
"ただし`traverse`を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:669
msgid ""
"(Difficult) Write a function `traverseUsingSequence` which behaves like "
"`traverse`, but is written in terms of `sequence`."
msgstr ""
"（難しい）`traverse`のように振る舞う関数`traverseUsingSequence`を書いてくださ"
"い。\n"
"ただし`sequence`を使ってください。"

#. type: Title ##
#: text/chapter7.md:670
#, no-wrap
msgid "Applicative Functors for Parallelism"
msgstr "アプリカティブ関手による並列処理"

#. type: Plain text
#: text/chapter7.md:673
msgid ""
"In the discussion above, I chose the word \"combine\" to describe how "
"applicative functors \"combine side-effects\". However, in all the examples "
"given, it would be equally valid to say that applicative functors allow us "
"to \"sequence\" effects. This would be consistent with the intuition that "
"traversable functors provide a `sequence` function to combine effects in "
"sequence based on a data structure."
msgstr ""
"これまでの議論では、アプリカティブ関手がどのように「副作用を結合」させるかを"
"説明するときに、「結合」(combine) という単語を選びました。\n"
"しかし、これらの全ての例において、アプリカティブ関手は作用を「連鎖」"
"(sequence) させる、というように言っても同じく妥当です。\n"
"巡回可能関手がデータ構造に従って作用を順番に結合させる`sequence`関数を提供し"
"ていることと、この直感的理解とは一致するでしょう。"

#. type: Plain text
#: text/chapter7.md:675
msgid ""
"However, in general, applicative functors are more general than this. The "
"applicative functor laws do not impose any ordering on the side-effects that "
"their computations perform. It would be valid for an applicative functor to "
"perform its side-effects in parallel."
msgstr ""
"しかし一般には、アプリカティブ関手はこれよりももっと一般的です。\n"
"アプリカティブ関手の規則は、その計算の副作用にどんな順序付けも強制しませ"
"ん。\n"
"実際、並列に副作用を実行するアプリカティブ関手は妥当でしょう。"

#. type: Plain text
#: text/chapter7.md:677
msgid ""
"For example, the `V` validation functor returned an _array_ of errors, but "
"it would work just as well if we picked the `Set` semigroup, in which case "
"it would not matter what order we ran the various validators. We could even "
"run them in parallel over the data structure!"
msgstr ""
"例えば`V`検証関手はエラーの*配列*を返しますが、その代わりに`Set`半群を選んだ"
"としてもやはり正常に動き、このときどんな順序で各検証器を実行しても問題はあり"
"ません。\n"
"データ構造に対して並列にこれの実行さえできるのです。"

#. type: Plain text
#: text/chapter7.md:679
msgid ""
"As a second example, the `parallel` package provides a type class `Parallel` "
"which supports _parallel computations_. `Parallel` provides a function "
"`parallel` that uses some `Applicative` functor to compute the result of its "
"input computation _in parallel_:"
msgstr ""
"2つ目の例として、`parallel`パッケージは*並列計算*に対応する`Parallel`型クラス"
"を提供します。\n"
"`Parallel`は関数`parallel`を提供しており、何らかの`Applicative`関手を使って入"
"力の計算の結果を*並列に*計算します。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:680
#, no-wrap
msgid ""
"f <$> parallel computation1\n"
"  <*> parallel computation2\n"
msgstr ""
"f <$> parallel computation1\n"
"  <*> parallel computation2\n"

#. type: Plain text
#: text/chapter7.md:686
msgid ""
"This computation would start computing values asynchronously using "
"`computation1` and `computation2`. When both results have been computed, "
"they would be combined into a single result using the function `f`."
msgstr ""
"この計算は`computation1`と`computation2`を非同期に使って値の計算を始めるで"
"しょう。そして両方の結果の計算が終わった時に、関数`f`を使って1つの結果へと結"
"合するでしょう。"

#. type: Plain text
#: text/chapter7.md:688
msgid ""
"We will see this idea in more detail when we apply applicative functors to "
"the problem of _callback hell_ later in the book."
msgstr ""
"この考え方の詳細は、本書の後半で _コールバック地獄_ の問題に対してアプリカ"
"ティブ関手を応用するときに見ていきます。"

#. type: Plain text
#: text/chapter7.md:690
msgid ""
"Applicative functors are a natural way to capture side-effects that can be "
"combined in parallel."
msgstr "アプリカティブ関手は並列に結合できる副作用を捉える自然な方法です。"

#. type: Plain text
#: text/chapter7.md:694
msgid "In this chapter, we covered a lot of new ideas:"
msgstr "この章では新しい考え方を沢山扱いました。"

#. type: Bullet: '- '
#: text/chapter7.md:698
msgid ""
"We introduced the concept of an _applicative functor_ which generalizes the "
"idea of function application to type constructors that captures some notion "
"of side-effect."
msgstr ""
"*アプリカティブ関手*の概念を導入しました。\n"
"これは、関数適用の概念から副作用の観念を捉えた型構築子へと一般化するもので"
"す。"

#. type: Bullet: '- '
#: text/chapter7.md:698
msgid ""
"We saw how applicative functors solved the problem of validating data "
"structures and how by switching the applicative functor, we could change "
"from reporting a single error to reporting all errors across a data "
"structure."
msgstr ""
"データ構造の検証という課題をアプリカティブ関手やその切り替えで解く方法を見て"
"きました。\n"
"単一のエラーの報告からデータ構造を横断する全てのエラーの報告へ変更できまし"
"た。"

#. type: Bullet: '- '
#: text/chapter7.md:698
msgid ""
"We met the `Traversable` type class, which encapsulates the idea of a "
"_traversable functor_, or a container whose elements can be used to combine "
"values with side-effects."
msgstr ""
"`Traversable`型クラスに出会いました。*巡回可能関手*の考え方を内包するものであ"
"り、要素が副作用を持つ値の結合に使うことができる容れ物でした。"

# FIXME: DSLの行中強調が欠けています。
#. type: Plain text
#: text/chapter7.md:700
msgid ""
"Applicative functors are an interesting abstraction that provides neat "
"solutions to a number of problems. We will see them a few more times "
"throughout the book. In this case, the validation applicative functor "
"provided a way to write validators in a declarative style, allowing us to "
"define _what_ our validators should validate and not _how_ they should "
"perform that validation. In general, we will see that applicative functors "
"are a useful tool for the design of _domain specific languages."
msgstr ""
"アプリカティブ関手は多くの問題に対して優れた解決策を与える興味深い抽象化で"
"す。\n"
"本書を通じて何度も見ることになるでしょう。\n"
"今回の場合、アプリカティブ関手は宣言的な流儀で書く手段を提供していましたが、"
"これにより検証器が*どうやって*検証を実施するかではなく、*何を*検証すべきなの"
"かを定義できました。\n"
"一般にアプリカティブ関手が*領域特化言語*を設計する上で便利な道具になることを"
"見ていきます。"

#. type: Plain text
#: text/chapter7.md:701
msgid ""
"In the next chapter, we will see a related idea, the class of _monads_, and "
"extend our address book example to run in the browser!"
msgstr ""
"次の章では、これに関連する考え方である*モナド*クラスを見て、アドレス帳の例を"
"ブラウザで実行させられるように拡張しましょう。"

#. type: Title ##
#: text/chapter8.md:1 text/chapter8.md:393
#, no-wrap
msgid "The Effect Monad"
msgstr "作用モナド"

#. type: Plain text
#: text/chapter8.md:6
msgid ""
"In the last chapter, we introduced applicative functors, an abstraction we "
"used to deal with _side-effects_: optional values, error messages, and "
"validation. This chapter will introduce another abstraction for dealing with "
"side-effects more expressively: _monads_."
msgstr ""
"前章では、*副作用*を扱うのに使う抽象化であるアプリカティブ関手を導入しまし"
"た。\n"
"副作用とは省略可能な値、エラー文言、検証などです。\n"
"この章では、副作用を扱うためのより表現力の高い別の抽象化である*モナド*を導入"
"します。"

#. type: Plain text
#: text/chapter8.md:8
msgid ""
"The goal of this chapter is to explain why monads are a useful abstraction "
"and their connection with _do notation_."
msgstr ""
"この章の目的は、なぜモナドが便利な抽象化なのかということと、*do記法*との関係"
"を説明することです。"

#. type: Plain text
#: text/chapter8.md:12
msgid "The project adds the following dependencies:"
msgstr "このプロジェクトでは、以下の依存関係が追加されています。"

#. type: Bullet: '- '
#: text/chapter8.md:15
msgid ""
"`effect` – defines the `Effect` monad, the subject of the second half of the "
"chapter. This dependency is often listed in every starter project (it's been "
"a dependency of every chapter so far), so you'll rarely have to install it "
"explicitly."
msgstr ""
"`effect`: 章の後半の主題である`Effect`モナドを定義しています。\n"
"この依存関係は全てのプロジェクトで始めから入っているものなので（これまでの全"
"ての章でも依存関係にありました）、明示的にインストールしなければいけないこと"
"は稀です。"

#. type: Bullet: '- '
#: text/chapter8.md:15
msgid ""
"`react-basic-hooks` – a web framework we will use for our Address Book app."
msgstr "`react-basic-hooks`: アドレス帳アプリに使うwebフレームワークです。"

#. type: Title ##
#: text/chapter8.md:16
#, no-wrap
msgid "Monads and Do Notation"
msgstr "モナドとdo記法"

#. type: Plain text
#: text/chapter8.md:19
msgid ""
"Do notation was first introduced when we covered _array comprehensions_. "
"Array comprehensions provide syntactic sugar for the `concatMap` function "
"from the `Data.Array` module."
msgstr ""
"do記法は*配列内包表記*を扱うときに初めて導入されました。\n"
"配列内包表記は`Data.Array`モジュールの`concatMap`関数の構文糖として提供されて"
"います。"

#. type: Plain text
#: text/chapter8.md:21
msgid ""
"Consider the following example. Suppose we throw two dice and want to count "
"the number of ways in which we can score a total of `n`. We could do this "
"using the following non-deterministic algorithm:"
msgstr ""
"次の例を考えてみましょう。2つのサイコロを振って出た目を数え、出た目の合計が "
"`n`のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使"
"うとこれを実現できます。"

#. type: Bullet: '- '
#: text/chapter8.md:25
msgid "_Choose_ the value `x` of the first throw."
msgstr "最初の投擲で値 `x`を _選択_ します。"

#. type: Bullet: '- '
#: text/chapter8.md:25
msgid "_Choose_ the value `y` of the second throw."
msgstr "2回目の投擲で値 `y`を _選択_ します。"

#. type: Bullet: '- '
#: text/chapter8.md:25
msgid "If the sum of `x` and `y` is `n`, return the pair `[x, y]`, else fail."
msgstr "もし`x`と`y`の和が`n`なら組`[x, y]`を返し、そうでなければ失敗します。"

#. type: Plain text
#: text/chapter8.md:27
msgid ""
"Array comprehensions allow us to write this non-deterministic algorithm "
"naturally:"
msgstr "配列内包表記を使うと、この非決定的アルゴリズムを自然に書けます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:28
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Plus (empty)\n"
"import Data.Array ((..))\n"
"\n"
"{{#include ../exercises/chapter8/test/Examples.purs:countThrows}}\n"
msgstr ""
"import Prelude\n"
"\n"
"import Control.Plus (empty)\n"
"import Data.Array ((..))\n"
"\n"
"{{#include ../exercises/chapter8/test/Examples.purs:countThrows}}\n"

#. type: Plain text
#: text/chapter8.md:38
msgid "We can see that this function works in PSCi:"
msgstr "PSCiでこの関数の動作を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter8.md:39
#, no-wrap
msgid ""
"> import Test.Examples\n"
"\n"
"> countThrows 10\n"
"[[4,6],[5,5],[6,4]]\n"
"\n"
"> countThrows 12\n"
"[[6,6]]\n"
msgstr ""
"> import Test.Examples\n"
"\n"
"> countThrows 10\n"
"[[4,6],[5,5],[6,4]]\n"
"\n"
"> countThrows 12\n"
"[[6,6]]\n"

#. type: Plain text
#: text/chapter8.md:50
msgid ""
"In the last chapter, we formed an intuition for the `Maybe` applicative "
"functor, embedding PureScript functions into a larger programming language "
"supporting _optional values_. In the same way, we can form an intuition for "
"the _array monad_, embedding PureScript functions into a larger programming "
"language supporting _non-deterministic choice_."
msgstr ""
"前の章では、*省略可能な値*に対応したより大きなプログラミング言語へと"
"PureScriptの関数を埋め込む、`Maybe`アプリカティブ関手についての直感的理解を養"
"いました。\n"
"同様に*配列モナド*についても、*非決定選択*に対応したより大きなプログラミング"
"言語へPureScriptの関数を埋め込む、というような直感的理解を得ることができま"
"す。"

#. type: Plain text
#: text/chapter8.md:52
msgid ""
"Generally, a _monad_ for some type constructor `m` provides a way to use do "
"notation with values of type `m a`. Note that in the array comprehension "
"above, every line contains a computation of type `Array a` for some type "
"`a`. In general, every line of a do notation block will contain a "
"computation of type `m a` for some type `a` and our monad `m`. The monad `m` "
"must be the same on every line (i.e., we fix the side-effect), but the types "
"`a` can differ (i.e., individual computations can have different result "
"types)."
msgstr ""
"一般に、ある型構築子`m`のモナドは、型`m a`の値を持つdo記法を使う手段を提供し"
"ます。\n"
"上の配列内包表記に注意すると、何らかの型`a`について全行に型`Array a`の計算が"
"含まれています。\n"
"一般に、do記法ブロックの全行は、何らかの型`a`とモナド`m`について、型`m a`の計"
"算を含みます。\n"
"モナド`m`は全行で同じでなければなりません（つまり副作用は固定）が、型`a`は異"
"なることもあります（つまり個々の計算は異なる型の結果にできる）。"

#. type: Plain text
#: text/chapter8.md:54
msgid ""
"Here is another example of do notation, this time applied to the type "
"constructor `Maybe`. Suppose we have some type `XML` representing XML nodes, "
"and a function"
msgstr ""
"以下はdo記法の別の例です。\n"
"今回は型構築子 `Maybe`に適用されています。\n"
"XMLノードを表す型 `XML`と次の関数があるとします。"

#. type: Fenced code block (hs)
#: text/chapter8.md:55
#, no-wrap
msgid "child :: XML -> String -> Maybe XML\n"
msgstr "child :: XML -> String -> Maybe XML\n"

#. type: Plain text
#: text/chapter8.md:60
msgid ""
"Which looks for a child element of a node and returns `Nothing` if no such "
"element exists."
msgstr ""
"この関数はノードの子の要素を探し、もしそのような要素が存在しなければ "
"`Nothing`を返します。"

#. type: Plain text
#: text/chapter8.md:62
msgid ""
"In this case, we can look for a deeply-nested element using do notation. "
"Suppose we wanted to read a user's city from a user profile that had been "
"encoded as an XML document:"
msgstr ""
"この場合、do記法を使うと深い入れ子になった要素を検索できます。\n"
"XML文書としてエンコードされた利用者情報から、利用者の住んでいる市町村を読み取"
"りたいとします。"

#. type: Fenced code block (hs)
#: text/chapter8.md:63 text/chapter8.md:293
#, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root = do\n"
"  prof <- child root \"profile\"\n"
"  addr <- child prof \"address\"\n"
"  city <- child addr \"city\"\n"
"  pure city\n"
msgstr ""
"userCity :: XML -> Maybe XML\n"
"userCity root = do\n"
"  prof <- child root \"profile\"\n"
"  addr <- child prof \"address\"\n"
"  city <- child addr \"city\"\n"
"  pure city\n"

#. type: Plain text
#: text/chapter8.md:73
msgid ""
"The `userCity` function looks for a child element `profile`, an element "
"`address` inside the `profile` element, and finally, an element `city` "
"inside the `address` element. If any of these elements are missing, the "
"return value will be `Nothing`. Otherwise, the return value is constructed "
"using `Just` from the `city` node."
msgstr ""
"`userCity`関数は子の`profile`要素、`profile`要素の中にある`address`要素、最後"
"に`address`要素の中にある`city`要素を探します。\n"
"これらの要素の何れかが欠落している場合、返り値は`Nothing`になります。\n"
"そうでなければ、返り値は`city`ノードから`Just`を使って構築されます。"

#. type: Plain text
#: text/chapter8.md:75
msgid ""
"Remember, the `pure` function in the last line is defined for every "
"`Applicative` functor. Since `pure` is defined as `Just` for the `Maybe` "
"applicative functor, it would be equally valid to change the last line to "
"`Just city`."
msgstr ""
"最後の行にある`pure`関数は、全ての`Applicative`関手について定義されているので"
"した。\n"
"`Maybe`の`Applicative`関手の`pure`関数は`Just`として定義されており、最後の行"
"を `Just city`へ変更しても同じように正しく動きます。"

#. type: Title ##
#: text/chapter8.md:76
#, no-wrap
msgid "The Monad Type Class"
msgstr "モナド型クラス"

#. type: Plain text
#: text/chapter8.md:79
msgid "The `Monad` type class is defined as follows:"
msgstr "`Monad`型クラスは次のように定義されています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:80
#, no-wrap
msgid ""
"class Apply m <= Bind m where\n"
"  bind :: forall a b. m a -> (a -> m b) -> m b\n"
"\n"
"class (Applicative m, Bind m) <= Monad m\n"
msgstr ""
"class Apply m <= Bind m where\n"
"  bind :: forall a b. m a -> (a -> m b) -> m b\n"
"\n"
"class (Applicative m, Bind m) <= Monad m\n"

#. type: Plain text
#: text/chapter8.md:88
#, no-wrap
msgid "The key function here is `bind`, defined in the `Bind` type class. Just like for the `<$>` and `<*>` operators in the `Functor` and `Apply` type classes, the Prelude defines an infix alias `>>=` for the `bind` function.\n"
msgstr "ここで鍵となる関数は `Bind`型クラスで定義されている演算子 `bind`で、`Functor`及び `Apply`型クラスにある `<$>`や `<*>`などの演算子と同様に、`Prelude`では `>>=`として `bind`の中置の別名が定義されています。\n"

#. type: Plain text
#: text/chapter8.md:90
msgid ""
"The `Monad` type class extends `Bind` with the operations of the "
"`Applicative` type class we've already seen."
msgstr ""
"`Monad`型クラスは、既に見てきた`Applicative`型クラスの操作で`Bind`を拡張しま"
"す。"

#. type: Plain text
#: text/chapter8.md:92
msgid ""
"It will be useful to see some examples of the `Bind` type class. A sensible "
"definition for `Bind` on arrays can be given as follows:"
msgstr ""
"`Bind`型クラスの例を幾つか見てみるのがわかりやすいでしょう。\n"
"配列についての `Bind`の妥当な定義は次のようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:93
#, no-wrap
msgid ""
"instance Bind Array where\n"
"  bind xs f = concatMap f xs\n"
msgstr ""
"instance Bind Array where\n"
"  bind xs f = concatMap f xs\n"

#. type: Plain text
#: text/chapter8.md:99
msgid ""
"This explains the connection between array comprehensions and the "
"`concatMap` function that has been alluded to before."
msgstr ""
"これは以前に仄めかした、配列内包表記と `concatMap`関数の関係を説明していま"
"す。"

#. type: Plain text
#: text/chapter8.md:101
msgid "Here is an implementation of `Bind` for the `Maybe` type constructor:"
msgstr "`Maybe`型構築子についての `Bind`の実装は次のようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:102
#, no-wrap
msgid ""
"instance Bind Maybe where\n"
"  bind Nothing  _ = Nothing\n"
"  bind (Just a) f = f a\n"
msgstr ""
"instance Bind Maybe where\n"
"  bind Nothing  _ = Nothing\n"
"  bind (Just a) f = f a\n"

#. type: Plain text
#: text/chapter8.md:109
msgid ""
"This definition confirms the intuition that missing values are propagated "
"through a do notation block."
msgstr ""
"この定義は欠落した値がdo記法ブロックを通じて伝播するという直感的理解を裏付け"
"るものです。"

#. type: Plain text
#: text/chapter8.md:111
msgid ""
"Let's see how the `Bind` type class is related to do notation. Consider a "
"simple do notation block that starts by binding a value from the result of "
"some computation:"
msgstr ""
"`Bind`型クラスとdo記法がどのように関係しているかを見て行きましょう。\n"
"最初に、何らかの計算結果からの値の束縛から始まる、単純なdo記法ブロックについ"
"て考えてみましょう。"

#. type: Fenced code block (hs)
#: text/chapter8.md:112
#, no-wrap
msgid ""
"do value <- someComputation\n"
"   whatToDoNext\n"
msgstr ""
"do value <- someComputation\n"
"   whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:118
msgid ""
"Every time the PureScript compiler sees this pattern, it replaces the code "
"with this:"
msgstr ""
"PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置"
"き換えます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:119
#, no-wrap
msgid "bind someComputation \\value -> whatToDoNext\n"
msgstr "bind someComputation \\value -> whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:124
msgid "or, written infix:"
msgstr "あるいは中置で書くと以下です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:125
#, no-wrap
msgid "someComputation >>= \\value -> whatToDoNext\n"
msgstr "someComputation >>= \\value -> whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:130
msgid "The computation `whatToDoNext` is allowed to depend on `value`."
msgstr "この計算 `whatToDoNext`は `value`に依存できます。"

#. type: Plain text
#: text/chapter8.md:132
msgid ""
"If there are multiple binds involved, this rule is applied multiple times, "
"starting from the top. For example, the `userCity` example that we saw "
"earlier gets desugared as follows:"
msgstr ""
"複数の束縛が関係している場合、この規則は先頭のほうから複数回適用されます。例"
"えば、先ほど見た `userCity`の例では次のように脱糖されます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:133
#, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root =\n"
"  child root \"profile\" >>= \\prof ->\n"
"    child prof \"address\" >>= \\addr ->\n"
"      child addr \"city\" >>= \\city ->\n"
"        pure city\n"
msgstr ""
"userCity :: XML -> Maybe XML\n"
"userCity root =\n"
"  child root \"profile\" >>= \\prof ->\n"
"    child prof \"address\" >>= \\addr ->\n"
"      child addr \"city\" >>= \\city ->\n"
"        pure city\n"

#. type: Plain text
#: text/chapter8.md:143
#, no-wrap
msgid "Notably, code expressed using do notation is often much clearer than the equivalent code using the `>>=` operator. However, writing binds explicitly using `>>=` can often lead to opportunities to write code in _point-free_ form – but the usual warnings about readability apply.\n"
msgstr ""
"do記法を使って表現されたコードは、`>>=`演算子を使う等価なコードより遥かに読みやすくなることがよくあることも特筆すべき点です。\n"
"しかしながら、明示的に`>>=`を使って束縛を書くと、*ポイントフリー*形式でコードが書けるようになることがよくあります。\n"
"ただし、読みやすさにはやはり注意が要ります。\n"

#. type: Title ##
#: text/chapter8.md:144
#, no-wrap
msgid "Monad Laws"
msgstr "モナド則"

#. type: Plain text
#: text/chapter8.md:147
msgid ""
"The `Monad` type class comes equipped with three laws, called the _monad "
"laws_. These tell us what we can expect from sensible implementations of the "
"`Monad` type class."
msgstr ""
"`Monad`型クラスは*モナド則*と呼ばれる3つの規則を持っています。これらは "
"`Monad`型クラスの合理的な実装から何を期待できるかを教えてくれます。"

#. type: Plain text
#: text/chapter8.md:149
msgid "It is simplest to explain these laws using do notation."
msgstr "do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。"

#. type: Title ###
#: text/chapter8.md:150
#, no-wrap
msgid "Identity Laws"
msgstr "単位元律"

#. type: Plain text
#: text/chapter8.md:153
msgid ""
"The _right-identity_ law is the simplest of the three laws. It tells us that "
"we can eliminate a call to `pure` if it is the last expression in a do "
"notation block:"
msgstr ""
"*右単位元則* (right-identity law) が3つの規則の中で最も簡単です。この規則はdo"
"記法ブロックの最後の式であれば、`pure`の呼び出しを排除できると言っています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:154
#, no-wrap
msgid ""
"do\n"
"  x <- expr\n"
"  pure x\n"
msgstr ""
"do\n"
"  x <- expr\n"
"  pure x\n"

#. type: Plain text
#: text/chapter8.md:161
msgid "The right-identity law says that this is equivalent to just `expr`."
msgstr "右単位元則は、この式は単なる `expr`と同じだと言っています。"

#. type: Plain text
#: text/chapter8.md:163
msgid ""
"The _left-identity_ law states that we can eliminate a call to `pure` if it "
"is the first expression in a do notation block:"
msgstr ""
"*左単位元則* (left-identity law) は、もしそれがdo記法ブロックの最初の式であれ"
"ば、`pure`の呼び出しを除去できると述べています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:164
#, no-wrap
msgid ""
"do\n"
"  x <- pure y\n"
"  next\n"
msgstr ""
"do\n"
"  x <- pure y\n"
"  next\n"

#. type: Plain text
#: text/chapter8.md:171
msgid ""
"This code is equivalent to `next`, after the name `x` has been replaced with "
"the expression `y`."
msgstr "このコードは`next`の名前`x`を式`y`で置き換えたものと同じです。"

#. type: Plain text
#: text/chapter8.md:173
msgid ""
"The last law is the _associativity law_. It tells us how to deal with nested "
"do notation blocks. It states that the following piece of code:"
msgstr ""
"最後の規則は _結合則_ (associativity law) です。これは入れ子になったdo記法ブ"
"ロックをどう扱うのかについて教えてくれます。この規則が述べているのは以下の"
"コード片のことです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:174
#, no-wrap
msgid ""
"c1 = do\n"
"  y <- do\n"
"    x <- m1\n"
"    m2\n"
"  m3\n"
msgstr ""
"c1 = do\n"
"  y <- do\n"
"    x <- m1\n"
"    m2\n"
"  m3\n"

#. type: Plain text
#: text/chapter8.md:183
msgid "is equivalent to this code:"
msgstr "上記のコード片は、次のコードと同じです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:184
#, no-wrap
msgid ""
"c2 = do\n"
"  x <- m1\n"
"  y <- m2\n"
"  m3\n"
msgstr ""
"c2 = do\n"
"  x <- m1\n"
"  y <- m2\n"
"  m3\n"

#. type: Plain text
#: text/chapter8.md:192
msgid ""
"Each of these computations involves three monadic expressions `m1`, `m2`, "
"and `m3`. In each case, the result of `m1` is eventually bound to the name "
"`x`, and the result of `m2` is bound to the name `y`."
msgstr ""
"これらの各計算には3つのモナドの式`m1`、`m2`、`m3`が含まれています。\n"
"どちらの場合でも`m1`の結果は結局は名前`x`に束縛され、`m2`の結果は名前`y`に束"
"縛されます。"

#. type: Plain text
#: text/chapter8.md:194
msgid ""
"In `c1`, the two expressions `m1` and `m2` are grouped into their own do "
"notation block."
msgstr ""
"`c1`では2つの式`m1`と`m2`が各do記法ブロック内にグループ化されています。"

#. type: Plain text
#: text/chapter8.md:196
msgid ""
"In `c2`, all three expressions `m1`, `m2`, and `m3` appear in the same do "
"notation block."
msgstr ""
"`c2`では`m1`、`m2`、`m3`の3つ全ての式が同じdo記法ブロックに現れています。"

#. type: Plain text
#: text/chapter8.md:198
msgid ""
"The associativity law tells us that it is safe to simplify nested do "
"notation blocks in this way."
msgstr ""
"結合法則は入れ子になったdo記法ブロックをこのように単純化しても問題ないことを"
"言っています。"

#. type: Plain text
#: text/chapter8.md:200
msgid ""
"_Note_ that by the definition of how do notation gets desugared into calls "
"to `bind`, both of `c1` and `c2` are also equivalent to this code:"
msgstr ""
"*補足*：do記法を`bind`の呼び出しへと脱糖する定義により、 `c1`と `c2`は何れも"
"次のコードと同じです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:201
#, no-wrap
msgid ""
"c3 = do\n"
"  x <- m1\n"
"  do\n"
"    y <- m2\n"
"    m3\n"
msgstr ""
"c3 = do\n"
"  x <- m1\n"
"  do\n"
"    y <- m2\n"
"    m3\n"

#. type: Title ##
#: text/chapter8.md:209
#, no-wrap
msgid "Folding With Monads"
msgstr "モナドで畳み込む"

#. type: Plain text
#: text/chapter8.md:212
msgid ""
"As an example of working with monads abstractly, this section will present a "
"function that works with any type constructor in the `Monad` type class. "
"This should solidify the intuition that monadic code corresponds to "
"programming \"in a larger language\" with side-effects, and also illustrate "
"the generality which programming with monads brings."
msgstr ""
"抽象的にモナドを扱う例として、この節では `Monad`型クラス中の任意の型構築子で"
"機能する関数を紹介していきます。\n"
"これはモナドによるコードが副作用を伴う「より大きな言語」でのプログラミングと"
"対応しているという直感的理解を補強しますし、モナドによるプログラミングが齎す"
"一般性も示しています。"

#. type: Plain text
#: text/chapter8.md:214
msgid ""
"The function we will write is called `foldM`. It generalizes the `foldl` "
"function we met earlier to a monadic context. Here is its type signature:"
msgstr ""
"これから書いていく関数は`foldM`という名前です。\n"
"以前見た`foldl`関数をモナドの文脈へと一般化するものです。\n"
"型シグネチャは以下です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:215
#, no-wrap
msgid ""
"foldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> List b -> m a\n"
"foldl :: forall   a b.            (a -> b ->   a) -> a -> List b ->   a\n"
msgstr ""
"foldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> List b -> m a\n"
"foldl :: forall   a b.            (a -> b ->   a) -> a -> List b ->   a\n"

#. type: Plain text
#: text/chapter8.md:221
msgid ""
"Notice that this is the same as the type of `foldl`, except for the "
"appearance of the monad `m`."
msgstr ""
"モナド `m`が現れている点を除いて、 `foldl`の型と同じであることに注意しましょ"
"う。"

#. type: Plain text
#: text/chapter8.md:223
msgid ""
"Intuitively, `foldM` performs a fold over a list in some context supporting "
"some set of side-effects."
msgstr ""
"直感的には、`foldM`は様々な副作用の組み合わせに対応した文脈で配列を畳み込むも"
"のと捉えられます。"

#. type: Plain text
#: text/chapter8.md:225
msgid ""
"For example, if we picked `m` to be `Maybe`, then our fold would be allowed "
"to fail by returning `Nothing` at any stage – every step returns an optional "
"result, and the result of the fold is therefore also optional."
msgstr ""
"例として`m`として`Maybe`を選ぶとすると、各段階で`Nothing`を返すことでこの畳み"
"込みを失敗させられます。\n"
"各段階では省略可能な結果を返しますから、それ故畳み込みの結果も省略可能になり"
"ます。"

#. type: Plain text
#: text/chapter8.md:227
msgid ""
"If we picked `m` to be the `Array` type constructor, then every step of the "
"fold would be allowed to return zero or more results, and the fold would "
"proceed to the next step independently for each result. In the end, the set "
"of results would consist of all folds over all possible paths. This "
"corresponds to a traversal of a graph!"
msgstr ""
"もし`m`として型構築子`Array`を選ぶとすると、畳み込みの各段階で0以上の結果を返"
"せるため、畳み込みは各結果に対して独立に次の手順を継続します。\n"
"最後に、結果の集まりは可能な経路の全ての畳み込みから構成されることになりま"
"す。\n"
"これはグラフの走査と対応していますね。"

#. type: Plain text
#: text/chapter8.md:229
msgid "To write `foldM`, we can simply break the input list into cases."
msgstr "`foldM`を書くには、単に入力のリストについて場合分けをするだけです。"

#. type: Plain text
#: text/chapter8.md:231
msgid ""
"If the list is empty, then to produce the result of type `a`, we only have "
"one option: we have to return the second argument:"
msgstr ""
"リストが空なら、型 `a`の結果を生成するための選択肢は1つしかありません。第2引"
"数を返します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:232
#, no-wrap
msgid "foldM _ a Nil = pure a\n"
msgstr "foldM _ a Nil = pure a\n"

#. type: Plain text
#: text/chapter8.md:237
msgid "Note that we have to use `pure` to lift `a` into the monad `m`."
msgstr ""
"なお、`a`をモナド `m`まで持ち上げるために `pure`を使わなくてはいけません。"

#. type: Plain text
#: text/chapter8.md:239
#, no-wrap
msgid "What if the list is non-empty? In that case, we have a value of type `a`, a value of type `b`, and a function of type `a -> b -> m a`. If we apply the function, we obtain a monadic result of type `m a`. We can bind the result of this computation with a backwards arrow `<-`.\n"
msgstr ""
"リストが空でない場合はどうでしょうか。\n"
"その場合、型 `a`の値、型 `b`の値、型 `a -> b -> m a`の関数があります。\n"
"もしこの関数を適用すると、型 `m a`のモナドの結果を手に入れることになります。\n"
"この計算の結果を逆向きの矢印 `<-`で束縛できます。\n"

#. type: Plain text
#: text/chapter8.md:241
msgid ""
"It only remains to recurse on the tail of the list. The implementation is "
"simple:"
msgstr "あとはリストの残りに対して再帰するだけです。実装は簡単です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:242
#, no-wrap
msgid ""
"foldM f a (b : bs) = do\n"
"  a' <- f a b\n"
"  foldM f a' bs\n"
msgstr ""
"foldM f a (b : bs) = do\n"
"  a' <- f a b\n"
"  foldM f a' bs\n"

#. type: Plain text
#: text/chapter8.md:249
msgid ""
"Note that this implementation is almost identical to that of `foldl` on "
"lists, except for do notation."
msgstr ""
"なお、この実装はリストに対する`foldl`の実装とほとんど同じです。\n"
"ただしdo記法である点を除きます。"

#. type: Plain text
#: text/chapter8.md:251
msgid ""
"We can define and test this function in PSCi. Here is an example – suppose "
"we defined a \"safe division\" function on integers, which tested for "
"division by zero and used the `Maybe` type constructor to indicate failure:"
msgstr ""
"PSCiでこの関数を定義して試せます。\n"
"以下は一例です。\n"
"整数の「安全な除算」関数を定義するとします。\n"
"0による除算かを確認し、失敗を示すために `Maybe`型構築子を使うのです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:252
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Examples.purs:safeDivide}}\n"
msgstr "{{#include ../exercises/chapter8/test/Examples.purs:safeDivide}}\n"

#. type: Plain text
#: text/chapter8.md:257
msgid "Then we can use `foldM` to express iterated safe division:"
msgstr "これで、 `foldM`で安全な除算の繰り返しを表現できます。"

#. type: Fenced code block (text)
#: text/chapter8.md:258
#, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.List (fromFoldable)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [5, 2, 2])\n"
"(Just 5)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [2, 0, 4])\n"
"Nothing\n"
msgstr ""
"> import Test.Examples\n"
"> import Data.List (fromFoldable)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [5, 2, 2])\n"
"(Just 5)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [2, 0, 4])\n"
"Nothing\n"

#. type: Plain text
#: text/chapter8.md:270
msgid ""
"The `foldM safeDivide` function returns `Nothing` if a division by zero was "
"attempted at any point. Otherwise, it returns the result of repeatedly "
"dividing the accumulator, wrapped in the `Just` constructor."
msgstr ""
"もし何れかの時点で0による除算が試みられたら、`foldM safeDivide`関数は"
"`Nothing`を返します。\n"
"そうでなければ、累算値を繰り返し除算した結果を`Just`構築子に包んで返します。"

#. type: Title ##
#: text/chapter8.md:271
#, no-wrap
msgid "Monads and Applicatives"
msgstr "モナドとアプリカティブ"

#. type: Plain text
#: text/chapter8.md:274
msgid ""
"Every instance of the `Monad` type class is also an instance of the `Apply` "
"type class, by virtue of the superclass relationship between the two classes."
msgstr ""
"クラス間に上位クラス関係の効能があるため、`Monad`型クラスの全てのインスタンス"
"は `Apply`型クラスのインスタンスでもあります。"

#. type: Plain text
#: text/chapter8.md:276
msgid ""
"However, there is also an implementation of the `Apply` type class which "
"comes \"for free\" for any instance of `Monad`, given by the `ap` function:"
msgstr ""
"しかし、あらゆる`Monad`のインスタンスに「無料で」ついてくる`Apply`型クラスの"
"実装もあります。これは`ap`関数により与えられます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:277
#, no-wrap
msgid ""
"ap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\n"
"ap mf ma = do\n"
"  f <- mf\n"
"  a <- ma\n"
"  pure (f a)\n"
msgstr ""
"ap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\n"
"ap mf ma = do\n"
"  f <- mf\n"
"  a <- ma\n"
"  pure (f a)\n"

#. type: Plain text
#: text/chapter8.md:286
msgid ""
"If `m` is a law-abiding member of the `Monad` type class, then there is a "
"valid `Apply` instance for `m` given by `ap`."
msgstr ""
"もし`m`に`Monad`型クラスの法則の縛りがあれば、`ap`で与えられる`m`について妥当"
"な `Apply`インスタンスが存在します。"

#. type: Plain text
#: text/chapter8.md:288
msgid ""
"The interested reader can check that `ap` agrees with `apply` for the monads "
"we have already encountered: `Array`, `Maybe`, and `Either e`."
msgstr ""
"興味のある読者はこれまで登場したモナドについてこの`ap`が`apply`として充足する"
"ことを確かめてみてください。\n"
"モナドは`Array`、`Maybe`、`Either e`といったものです。"

#. type: Plain text
#: text/chapter8.md:290
msgid ""
"If every monad is also an applicative functor, then we should be able to "
"apply our intuition for applicative functors to every monad. In particular, "
"we can reasonably expect a monad to correspond, in some sense, to "
"programming \"in a larger language\" augmented with some set of additional "
"side-effects. We should be able to lift functions of arbitrary arities, "
"using `map` and `apply`, into this new language."
msgstr ""
"もし全てのモナドがアプリカティブ関手でもあるなら、アプリカティブ関手について"
"の直感的理解を全てのモナドについても適用できるはずです。\n"
"特に、モナドが更なる副作用の組み合わせで増強された「より大きな言語」でのプロ"
"グラミングといろいろな意味で一致することを予想するのはもっともです。\n"
"`map`と `apply`を使って、引数が任意個の関数をこの新しい言語へと持ち上げること"
"ができるはずです。"

#. type: Plain text
#: text/chapter8.md:292
msgid ""
"But monads allow us to do more than we could do with just applicative "
"functors, and the key difference is highlighted by the syntax of do "
"notation. Consider the `userCity` example again, in which we looked for a "
"user's city in an XML document that encoded their user profile:"
msgstr ""
"しかし、モナドはアプリカティブ関手でできること以上ができ、重要な違いはdo記法"
"の構文で強調されています。\n"
"`userCity`の例についてもう一度考えてみましょう。\n"
"利用者情報をエンコードしたXML文書から利用者の市町村を検索するものでした。"

#. type: Plain text
#: text/chapter8.md:303
msgid ""
"Do notation allows the second computation to depend on the result `prof` of "
"the first, and the third computation to depend on the result `addr` of the "
"second, and so on. This dependence on previous values is not possible using "
"only the interface of the `Applicative` type class."
msgstr ""
"do記法では2番目の計算が最初の結果 `prof`に依存し、3番目の計算が2番目の計算の"
"結果`addr`に依存するというようなことができます。\n"
"`Applicative`型クラスのインターフェイスだけを使うのでは、このように以前の値へ"
"依存できません。"

#. type: Plain text
#: text/chapter8.md:305
msgid ""
"Try writing `userCity` using only `pure` and `apply`: you will see that it "
"is impossible. Applicative functors only allow us to lift function arguments "
"which are independent of each other, but monads allow us to write "
"computations which involve more interesting data dependencies."
msgstr ""
"`pure`と `apply`だけを使って `userCity`を書こうとしてみれば、これが不可能であ"
"ることがわかるでしょう。\n"
"アプリカティブ関手ができるのは関数の互いに独立した引数を持ち上げることだけで"
"すが、モナドはもっと興味深いデータの依存関係に関わる計算を書くことを可能にし"
"ます。"

#. type: Plain text
#: text/chapter8.md:307
msgid ""
"In the last chapter, we saw that the `Applicative` type class can be used to "
"express parallelism. This was precisely because the function arguments being "
"lifted were independent of one another. Since the `Monad` type class allows "
"computations to depend on the results of previous computations, the same "
"does not apply – a monad has to combine its side-effects in sequence."
msgstr ""
"前の章では`Applicative`型クラスは並列処理を表現できることを見ました。\n"
"持ち上げられた関数の引数は互いに独立していますから、これはまさにその通りで"
"す。\n"
"`Monad`型クラスは計算が前の計算の結果に依存できるようになっており、同じように"
"はなりません。\n"
"つまりモナドは副作用を順番に組み合わせなければならないのです。"

#. type: Bullet: ' 1. '
#: text/chapter8.md:312
msgid ""
"(Easy) Write a function `third` that returns the third element of an array "
"with three or more elements. Your function should return an appropriate "
"`Maybe` type. _Hint:_ Look up the types of the `head` and `tail` functions "
"from the `Data.Array` module in the `arrays` package. Use do notation with "
"the `Maybe` monad to combine these functions."
msgstr ""
"（簡単）3つ以上の要素がある配列の3つ目の要素を返す関数`third`を書いてくださ"
"い。\n"
"関数は適切な`Maybe`型で返します。\n"
"*手掛かり*：`arrays`パッケージの`Data.Array`モジュールから`head`と`tail`関数"
"の型を見つけ出してください。\n"
"これらの関数を組み合わせるには`Maybe`モナドと共にdo記法を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter8.md:312
msgid ""
"(Medium) Write a function `possibleSums` which uses `foldM` to determine all "
"possible totals that could be made using a set of coins. The coins will be "
"specified as an array which contains the value of each coin. Your function "
"should have the following result:"
msgstr ""
"（普通）一掴みの硬貨を使ってできる可能な全ての合計を決定する関数 "
"`possibleSums`を、 `foldM`を使って書いてみましょう。\n"
"入力の硬貨は、硬貨の価値の配列として与えられます。この関数は次のような結果に"
"ならなくてはいけません。"

#. type: Plain text
#: text/chapter8.md:316
#, no-wrap
msgid ""
"     ```text\n"
"     > possibleSums []\n"
"     [0]\n"
msgstr ""
"     ```text\n"
"     > possibleSums []\n"
"     [0]\n"

#. type: Plain text
#: text/chapter8.md:320
#, no-wrap
msgid ""
"     > possibleSums [1, 2, 10]\n"
"     [0,1,2,3,10,11,12,13]\n"
"     ```\n"
msgstr ""
"     > possibleSums [1, 2, 10]\n"
"     [0,1,2,3,10,11,12,13]\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:325
#, no-wrap
msgid ""
"     _Hint_: This function can be written as a one-liner using `foldM`. You might want to use the `nub` and `sort` functions to remove duplicates and sort the result.\n"
" 1. (Medium) Confirm that the `ap` function and the `apply` operator agree for the `Maybe` monad. _Note:_ There are no tests for this exercise.\n"
" 1. (Medium) Verify that the monad laws hold for the `Monad` instance for the `Maybe` type, as defined in the `maybe` package. _Note:_ There are no tests for this exercise.\n"
" 1. (Medium) Write a function `filterM` which generalizes the `filter` function on lists. Your function should have the following type signature:\n"
msgstr ""
"     *手掛かり*：`foldM`を使うと1行でこの関数を書けます。\n"
"     重複を取り除いたり、結果を並び替えたりするのに、`nub`関数や`sort`関数を使うことでしょう。\n"
"1. （普通）`ap`関数と`apply`演算子が`Maybe`モナドを充足することを確かめてください。\n"
"   *補足*：この演習にはテストがありません。\n"
"1. （普通）`Maybe`型についての`Monad`インスタンスが、モナド則を満たしていることを検証してください。\n"
"   このインスタンスは`maybe`パッケージで定義されています。\n"
"   *補足*：この演習にはテストがありません。\n"
"1. （普通）リスト上の`filter`の関数を一般化した関数`filterM`を書いてください。\n"
"   この関数は次の型シグネチャを持ちます。\n"

#. type: Plain text
#: text/chapter8.md:329
#, no-wrap
msgid ""
"     ```hs\n"
"     filterM :: forall m a. Monad m => (a -> m Boolean) -> List a -> m (List a)\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     filterM :: forall m a. Monad m => (a -> m Boolean) -> List a -> m (List a)\n"
"     ```\n"

#. type: Bullet: ' 1. '
#: text/chapter8.md:331
msgid "(Difficult) Every monad has a default `Functor` instance given by:"
msgstr ""
"（難しい）全てのモナドには次で与えられるような既定の`Functor`インスタンスがあ"
"ります。"

#. type: Plain text
#: text/chapter8.md:337
#, no-wrap
msgid ""
"     ```hs\n"
"     map f a = do\n"
"       x <- a\n"
"       pure (f x)\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     map f a = do\n"
"       x <- a\n"
"       pure (f x)\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:339
#, no-wrap
msgid "     Use the monad laws to prove that for any monad, the following holds:\n"
msgstr "     モナド則を使って、全てのモナドが次を満たすことを証明してください。\n"

#. type: Plain text
#: text/chapter8.md:343
#, no-wrap
msgid ""
"     ```hs\n"
"     lift2 f (pure a) (pure b) = pure (f a b)\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     lift2 f (pure a) (pure b) = pure (f a b)\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:345
#, no-wrap
msgid "     Where the `Apply` instance uses the `ap` function defined above. Recall that `lift2` was defined as follows:\n"
msgstr ""
"     ここで、`Applly`インスタンスは上で定義された`ap`関数を使用しています。\n"
"     `lift2`が次のように定義されていたことを思い出してください。\n"

#. type: Plain text
#: text/chapter8.md:350
#, no-wrap
msgid ""
"     ```hs\n"
"     lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n"
"     lift2 f a b = f <$> a <*> b\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n"
"     lift2 f a b = f <$> a <*> b\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:352
#, no-wrap
msgid "    _Note:_ There are no tests for this exercise.\n"
msgstr "    *補足*：この演習にはテストがありません。\n"

#. type: Title ##
#: text/chapter8.md:353
#, no-wrap
msgid "Native Effects"
msgstr "ネイティブな作用"

#. type: Plain text
#: text/chapter8.md:356
msgid ""
"We will now look at one particular monad of central importance in PureScript "
"– the `Effect` monad."
msgstr ""
"ここではPureScriptで中心的な重要性のあるモナドの1つ、`Effect`モナドについて見"
"ていきます。"

#. type: Plain text
#: text/chapter8.md:358
msgid ""
"The `Effect` monad is defined in the `Effect` module. It is used to manage "
"so-called _native_ side-effects. If you are familiar with Haskell, it is the "
"equivalent of the `IO` monad."
msgstr ""
"`Effect`モナドは `Effect`モジュールで定義されています。かつてはいわゆる _ネイ"
"ティブ_ 副作用を管理していました。Haskellに馴染みがあれば、これは`IO`モナドと"
"同等のものです。"

#. type: Plain text
#: text/chapter8.md:360
msgid ""
"What are native side-effects? They are the side-effects that distinguish "
"JavaScript expressions from idiomatic PureScript expressions, which "
"typically are free from side-effects. Some examples of native effects are:"
msgstr ""
"ネイティブな副作用とは何でしょうか。\n"
"この副作用はPureScript特有の式とJavaScriptの式とを2分するものです。\n"
"PureScriptの式は概して副作用とは無縁なのです。\n"
"ネイティブな作用の例を以下に示します。"

#. type: Bullet: '- '
#: text/chapter8.md:365
msgid "Console IO"
msgstr "コンソール入出力"

#. type: Bullet: '- '
#: text/chapter8.md:365
msgid "Random number generation"
msgstr "乱数生成"

#. type: Bullet: '- '
#: text/chapter8.md:365
msgid "Reading/writing mutable state"
msgstr "変更可能な状態の読み書き"

#. type: Plain text
#: text/chapter8.md:367
msgid "And in the browser:"
msgstr "また、ブラウザでは次のようなものがあります。"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "DOM manipulation"
msgstr "DOM操作"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "XMLHttpRequest / AJAX calls"
msgstr "XMLHttpRequest / AJAX呼び出し"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "Interacting with a websocket"
msgstr "WebSocketによる相互作用"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "Writing/reading to/from local storage"
msgstr "Local Storageの読み書き"

#. type: Plain text
#: text/chapter8.md:374
msgid "We have already seen plenty of examples of \"non-native\" side-effects:"
msgstr "既に「ネイティブでない」副作用の例については数多く見てきています。"

#. type: Bullet: '- '
#: text/chapter8.md:378
msgid "Optional values, as represented by the `Maybe` data type"
msgstr "`Maybe`データ型で表現される省略可能な値"

#. type: Bullet: '- '
#: text/chapter8.md:378
msgid "Errors, as represented by the `Either` data type"
msgstr "`Either`データ型で表現されるエラー"

#. type: Bullet: '- '
#: text/chapter8.md:378
msgid "Multi-functions, as represented by arrays or lists"
msgstr "配列やリストで表現される多値関数"

#. type: Plain text
#: text/chapter8.md:380
msgid ""
"Note that the distinction is subtle. It is true, for example, that an error "
"message is a possible side-effect of a JavaScript expression in the form of "
"an exception. In that sense, exceptions do represent native side-effects, "
"and it is possible to represent them using `Effect`. However, error messages "
"implemented using `Either` are not a side-effect of the JavaScript runtime, "
"and so it is not appropriate to implement error messages in that style using "
"`Effect`. So it is not the effect itself, which is native, but rather how it "
"is implemented at runtime."
msgstr ""
"これらの区別はわかりにくいので注意してください。\n"
"例えば、エラー文言は例外の形でJavaScriptの式の副作用となることがあると言えま"
"す。\n"
"その意味では例外はネイティブな副作用を表していて、`Effect`を使用して表現でき"
"ます。\n"
"しかし、`Either`を使用して実装されたエラー文言はJavaScript実行時の副作用では"
"なく、`Effect`を使うスタイルでエラー文言を実装するのは不適切です。\n"
"そのため、ネイティブなのは作用自体というより、実行時にどのように実装されてい"
"るかです。"

#. type: Title ##
#: text/chapter8.md:381
#, no-wrap
msgid "Side-Effects and Purity"
msgstr "副作用と純粋性"

#. type: Plain text
#: text/chapter8.md:384
msgid ""
"In a pure language like PureScript, one question presents itself: without "
"side-effects, how can one write useful real-world code?"
msgstr ""
"PureScriptのような純粋な言語では、ある疑問が浮かんできます。\n"
"副作用がないなら、どうやって役に立つ実際のコードを書くことができるのでしょう"
"か。"

#. type: Plain text
#: text/chapter8.md:386
msgid ""
"The answer is that PureScript does not aim to eliminate side-effects but to "
"represent them in such a way that pure computations can be distinguished "
"from computations with side-effects in the type system. In this sense, the "
"language is still pure."
msgstr ""
"その答えはPureScriptの目的は副作用を排除することではないということです。\n"
"純粋な計算と副作用のある計算とを、型システムにおいて区別できるような方法で表"
"現します。\n"
"この意味で、言語はあくまで純粋なのです。"

#. type: Plain text
#: text/chapter8.md:388
msgid ""
"Values with side-effects have different types from pure values. As such, it "
"is impossible to pass a side-effecting argument to a function, for example, "
"and have side-effects performed unexpectedly."
msgstr ""
"副作用のある値は、純粋な値とは異なる型を持っています。\n"
"そういうわけで、例えば副作用のある引数を関数に渡すことはできず、予期せず副作"
"用を持つようなことが起こらなくなります。"

#. type: Plain text
#: text/chapter8.md:390
msgid ""
"The only way side-effects managed by the `Effect` monad will be presented is "
"to run a computation of type `Effect a` from JavaScript."
msgstr ""
"`Effect`モナドで管理された副作用を現す手段は、型`Effect a`の計算をJavaScript"
"から実行することです。"

#. type: Plain text
#: text/chapter8.md:392
msgid ""
"The Spago build tool (and other tools) provide a shortcut by generating "
"additional JavaScript to invoke the `main` computation when the application "
"starts. `main` is required to be a computation in the `Effect` monad."
msgstr ""
"Spagoビルドツール（や他のツール）は早道を用意しており、アプリケーションの起動"
"時に`main`計算を呼び出すための追加のJavaScriptコードを生成します。\n"
"`main`は`Effect`モナドでの計算であることが要求されます。"

#. type: Plain text
#: text/chapter8.md:396
msgid ""
"The `Effect` monad provides a well-typed API for computations with side-"
"effects, while at the same time generating efficient JavaScript."
msgstr ""
"`Effect`は副作用のある計算を充分に型付けするAPIを提供すると同時に、効率的な"
"JavaScriptを生成します。"

#. type: Plain text
#: text/chapter8.md:398
msgid ""
"Let's look at the return type of the familiar `log` function. `Effect` "
"indicates that this function produces a native effect, console IO in this "
"case."
msgstr ""
"馴染みのある`log`関数から返る型を見てみましょう。\n"
"`Effect`はこの関数がネイティブな作用を生み出すことを示しており、この場合はコ"
"ンソールIOです。"

#. type: Plain text
#: text/chapter8.md:400
msgid ""
"`Unit` indicates that no _meaningful_ data is returned. You can think of "
"`Unit` as analogous to the `void` keyword in other languages, such as C, "
"Java, etc."
msgstr ""
"`Unit`はいかなる*意味のある*データも返らないことを示しています。\n"
"`Unit`はC、Javaなど他の言語での`void`キーワードと似たものとして考えられます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:401
#, no-wrap
msgid "log :: String -> Effect Unit\n"
msgstr "log :: String -> Effect Unit\n"

#. type: Plain text
#: text/chapter8.md:410
#, no-wrap
msgid ""
"> _Aside:_ You may encounter IDE suggestions for the more general (and more elaborately typed) `log` function from `Effect.Class.Console`. This is interchangeable with the one from `Effect.Console` when dealing with the basic `Effect` monad. Reasons for the more general version will become clearer after reading about \"Monad Transformers\" in the \"Monadic Adventures\" chapter. For the curious (and impatient), this works because there's a `MonadEffect` instance for `Effect`.\n"
">\n"
"> ```hs\n"
"> log :: forall m. MonadEffect m => String -> m Unit\n"
"> ```\n"
msgstr ""
"> _余談_ ：より一般的な（そしてより込み入った型を持つ）`Effect.Class.Console`の`log`関数をIDEから提案されるかもしれません。\n"
"> これは基本的な`Effect`モナドを扱う際は`Effect.Console`からの関数と交換可能です。\n"
"> より一般的なバージョンがあることの理由は「モナドな冒険」章の「モナド変換子」について読んだあとにより明らかになっていることでしょう。\n"
"> 好奇心のある（そしてせっかちな）読者のために言うと、これは`Effect`に`MonadEffect`インスタンスがあるから機能するのです。\n"
">\n"
"> ```hs\n"
"> log :: forall m. MonadEffect m => String -> m Unit\n"
"> ```\n"

#. type: Plain text
#: text/chapter8.md:412
msgid ""
"Now let's consider an `Effect` that returns meaningful data. The `random` "
"function from `Effect.Random` produces a random `Number`."
msgstr ""
"それでは意味のあるデータを返す`Effect`を考えましょう。\n"
"`Effect.Random`の`random`関数は乱択された`Number`を生み出します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:413
#, no-wrap
msgid "random :: Effect Number\n"
msgstr "random :: Effect Number\n"

#. type: Plain text
#: text/chapter8.md:418
msgid ""
"Here's a full example program (found in `test/Random.purs` of this chapter's "
"exercises folder)."
msgstr ""
"以下は完全なプログラムの例です（この章の演習フォルダの`test/Random.purs`にあ"
"ります）。"

#. type: Fenced code block (hs)
#: text/chapter8.md:419
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Random.purs}}\n"
msgstr "{{#include ../exercises/chapter8/test/Random.purs}}\n"

#. type: Plain text
#: text/chapter8.md:424
msgid ""
"Because `Effect` is a monad, we use do notation to _unwrap_ the data it "
"contains before passing this data on to the effectful `logShow` function. As "
"a refresher, here's the equivalent code written using the `bind` operator:"
msgstr ""
"`Effect`はモナドなので、do記法を使って含まれるデータを開封し、それからこの"
"データを作用のある`logShow`関数に渡します。\n"
"気分転換に、以下は`bind`演算子を使って書かれた同等なコードです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:425
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = random >>= logShow\n"
msgstr ""
"main :: Effect Unit\n"
"main = random >>= logShow\n"

#. type: Plain text
#: text/chapter8.md:431
msgid "Try running this yourself with:"
msgstr "これを手元で走らせてみてください。"

#. type: Fenced code block (shell)
#: text/chapter8.md:432
#, no-wrap
msgid "spago run --main Test.Random\n"
msgstr "spago run --main Test.Random\n"

#. type: Plain text
#: text/chapter8.md:437
msgid ""
"You should see a randomly chosen number between `0.0` and `1.0` printed to "
"the console."
msgstr ""
"コンソールに出力 `0.0`と `1.0`の間で無作為に選ばれた数が表示されるでしょう。"

#. type: Plain text
#: text/chapter8.md:439
#, no-wrap
msgid "> _Aside:_ `spago run` defaults to searching in the `Main` module for a `main` function. You may also specify an alternate module as an entry point with the `--main` flag, as in the above example. Just be sure that this alternate module also contains a `main` function.\n"
msgstr ""
"> 余談：`spago run`は既定で`main`関数を`Main`モジュールの中から探索します。\n"
"> `--main`フラグで代替のモジュールを入口として指定することも可能で、上の例ではそうしています。\n"
"> この代替のモジュールにも`main`関数が含まれているようにはしてください。\n"

#. type: Plain text
#: text/chapter8.md:441
msgid ""
"Note that it's also possible to generate \"random\" (technically "
"pseudorandom) data without resorting to impure effectful code. We'll cover "
"these techniques in the \"Generative Testing\" chapter."
msgstr ""
"なお、不浄な作用付きのコードに訴えることなく、「乱択された」（技術的には疑似"
"乱択された）データも生成できます。\n"
"この技法は「テストを生成する」章で押さえます。"

#. type: Plain text
#: text/chapter8.md:443
msgid ""
"As mentioned previously, the `Effect` monad is of central importance to "
"PureScript. The reason why it's central is that it is the conventional way "
"to interoperate with PureScript's `Foreign Function Interface`, which "
"provides the mechanism to execute a program and perform side effects. While "
"it's desirable to avoid using the `Foreign Function Interface`, it's fairly "
"critical to understand how it works and how to use it, so I recommend "
"reading that chapter before doing any serious PureScript work. That said, "
"the `Effect` monad is fairly simple. It has a few helper functions but "
"doesn't do much except encapsulate side effects."
msgstr ""
"以前言及したように`Effect`モナドはPureScriptで核心的な重要さがあります。\n"
"なぜ核心かというと、それはPureScriptの`外部関数インターフェース`とやり取りす"
"る上での常套手段だからです。\n"
"`外部関数インターフェース`はプログラムを実行したり副作用を発生させたりする仕"
"組みを提供します。\n"
"`外部関数インターフェース`を使うことは避けるのが望ましいのですが、どのように"
"動作しどう使うのか理解することもまた極めて大事なことですので、実際に"
"PureScriptで何か動かす前にその章を読まれることをお勧めします。\n"
"要は`Effect`モナドは結構単純なのです。\n"
"幾つかの補助関数がありますが、副作用を内包すること以外には大したことはしませ"
"ん。"

#. type: Plain text
#: text/chapter8.md:447
msgid ""
"Let's examine a function from the `node-fs` package that involves two "
"_native_ side effects: reading mutable state and exceptions:"
msgstr ""
"2つの*ネイティブな*副作用が絡む`node-fs`パッケージの関数を調べましょう。\n"
"ここでの副作用は可変状態の読み取りと例外です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:448
#, no-wrap
msgid "readTextFile :: Encoding -> String -> Effect String\n"
msgstr "readTextFile :: Encoding -> String -> Effect String\n"

#. type: Plain text
#: text/chapter8.md:453
msgid "If we attempt to read a file that does not exist:"
msgstr "もし存在しないファイルを読もうとすると……"

#. type: Fenced code block (hs)
#: text/chapter8.md:454
#, no-wrap
msgid ""
"import Node.Encoding (Encoding(..))\n"
"import Node.FS.Sync (readTextFile)\n"
"\n"
"main :: Effect Unit\n"
"main = do\n"
"  lines <- readTextFile UTF8 \"iDoNotExist.md\"\n"
"  log lines\n"
msgstr ""
"import Node.Encoding (Encoding(..))\n"
"import Node.FS.Sync (readTextFile)\n"
"\n"
"main :: Effect Unit\n"
"main = do\n"
"  lines <- readTextFile UTF8 \"iDoNotExist.md\"\n"
"  log lines\n"

#. type: Plain text
#: text/chapter8.md:465
msgid "We encounter the following exception:"
msgstr "以下の例外に遭遇します。"

#. type: Fenced code block (text)
#: text/chapter8.md:466
#, no-wrap
msgid ""
"    throw err;\n"
"    ^\n"
"Error: ENOENT: no such file or directory, open 'iDoNotExist.md'\n"
"...\n"
"  errno: -2,\n"
"  syscall: 'open',\n"
"  code: 'ENOENT',\n"
"  path: 'iDoNotExist.md'\n"
msgstr ""
"    throw err;\n"
"    ^\n"
"Error: ENOENT: no such file or directory, open 'iDoNotExist.md'\n"
"...\n"
"  errno: -2,\n"
"  syscall: 'open',\n"
"  code: 'ENOENT',\n"
"  path: 'iDoNotExist.md'\n"

#. type: Plain text
#: text/chapter8.md:478
msgid ""
"To manage this exception gracefully, we can wrap the potentially problematic "
"code in `try` to handle either outcome:"
msgstr ""
"この例外をうまく管理するには、潜在的に問題があるコードを`try`に包めばどのよう"
"な出力でも制御できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:479
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = do\n"
"  result <- try $ readTextFile UTF8 \"iDoNotExist.md\"\n"
"  case result of\n"
"    Right lines -> log $ \"Contents: \\n\" <> lines\n"
"    Left  error -> log $ \"Couldn't open file. Error was: \" <> message error\n"
msgstr ""
"main :: Effect Unit\n"
"main = do\n"
"  result <- try $ readTextFile UTF8 \"iDoNotExist.md\"\n"
"  case result of\n"
"    Right lines -> log $ \"Contents: \\n\" <> lines\n"
"    Left  error -> log $ \"Couldn't open file. Error was: \" <> message error\n"

#. type: Plain text
#: text/chapter8.md:489
msgid ""
"`try` runs an `Effect` and returns eventual exceptions as a `Left` value. If "
"the computation succeeds, the result gets wrapped in a `Right`:"
msgstr ""
"`try`は`Effect`を走らせて起こりうる例外を`Left`値として返します。\n"
"もし計算が成功すれば結果は`Right`に包まれます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:490
#, no-wrap
msgid "try :: forall a. Effect a -> Effect (Either Error a)\n"
msgstr "try :: forall a. Effect a -> Effect (Either Error a)\n"

#. type: Plain text
#: text/chapter8.md:495
msgid ""
"We can also generate our own exceptions. Here is an alternative "
"implementation of `Data.List.head` that throws an exception if the list is "
"empty rather than returning a `Maybe` value of `Nothing`."
msgstr ""
"独自の例外も生成できます。\n"
"以下は`Data.List.head`の代替実装で、`Maybe`の値の`Nothing`を返す代わりにリス"
"トが空のとき例外を投げます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:496
#, no-wrap
msgid ""
"exceptionHead :: List Int -> Effect Int\n"
"exceptionHead l = case l of\n"
"  x : _ -> pure x\n"
"  Nil -> throwException $ error \"empty list\"\n"
msgstr ""
"exceptionHead :: List Int -> Effect Int\n"
"exceptionHead l = case l of\n"
"  x : _ -> pure x\n"
"  Nil -> throwException $ error \"empty list\"\n"

#. type: Plain text
#: text/chapter8.md:504
msgid ""
"Note that the `exceptionHead` function is a somewhat impractical example, as "
"it is best to avoid generating exceptions in PureScript code and instead use "
"non-native effects such as `Either` and `Maybe` to manage errors and missing "
"values."
msgstr ""
"ただし`exceptionHead`関数はどこかしら非実用的な例です。\n"
"というのも、PureScriptのコードで例外を生成するのは避け、代わりに`Either`や"
"`Maybe`のようなネイティブでない作用でエラーや欠けた値を使うのが一番だからで"
"す。"

#. type: Title ##
#: text/chapter8.md:505
#, no-wrap
msgid "Mutable State"
msgstr "可変状態"

#. type: Plain text
#: text/chapter8.md:508
msgid "There is another effect defined in the core libraries: the `ST` effect."
msgstr ""
"中核ライブラリには `ST`作用という、これまた別の作用も定義されています。"

#. type: Plain text
#: text/chapter8.md:510
msgid ""
"The `ST` effect is used to manipulate mutable state. As pure functional "
"programmers, we know that shared mutable state can be problematic. However, "
"the `ST` effect uses the type system to restrict sharing in such a way that "
"only safe _local_ mutation is allowed."
msgstr ""
"`ST`作用は変更可能な状態を操作するために使われます。\n"
"純粋関数プログラミングを知っているなら、共有される変更可能な状態は問題を引き"
"起こしやすいということも知っているでしょう。\n"
"しかし、`ST`作用は型システムを使って安全で*局所的な*状態変化を可能にし、状態"
"の共有を制限するのです。"

#. type: Plain text
#: text/chapter8.md:512
msgid ""
"The `ST` effect is defined in the `Control.Monad.ST` module. To see how it "
"works, we need to look at the types of its actions:"
msgstr ""
"`ST`作用は `Control.Monad.ST`モジュールで定義されています。\n"
"この挙動を確認するには、その動作の型を見る必要があります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:513
#, no-wrap
msgid ""
"new :: forall a r. a -> ST r (STRef r a)\n"
"\n"
"read :: forall a r. STRef r a -> ST r a\n"
"\n"
"write :: forall a r. a -> STRef r a -> ST r a\n"
"\n"
"modify :: forall r a. (a -> a) -> STRef r a -> ST r a\n"
msgstr ""
"new :: forall a r. a -> ST r (STRef r a)\n"
"\n"
"read :: forall a r. STRef r a -> ST r a\n"
"\n"
"write :: forall a r. a -> STRef r a -> ST r a\n"
"\n"
"modify :: forall r a. (a -> a) -> STRef r a -> ST r a\n"

#. type: Plain text
#: text/chapter8.md:524
msgid ""
"`new` is used to create a new mutable reference cell of type `STRef r a`, "
"which can be read using the `read` action and modified using the `write` and "
"`modify` actions. The type `a` is the type of the value stored in the cell, "
"and the type `r` is used to indicate a _memory region_ (or _heap_) in the "
"type system."
msgstr ""
"`new`は型`STRef r a`の可変参照領域を新規作成するのに使われます。\n"
"この領域は`read`動作を使って読み取ったり、`write`動作や`modify`動作で状態を変"
"更するのに使えます。\n"
"型`a`は領域に格納された値の型を、型`r`は*メモリ領域*（または*ヒープ*）を、そ"
"れぞれ型システムで表しています。"

#. type: Plain text
#: text/chapter8.md:526
msgid ""
"Here is an example. Suppose we want to simulate the movement of a particle "
"falling under gravity by iterating a simple update function over many small "
"time steps."
msgstr ""
"例を示します。\n"
"重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。\n"
"これには小さな時間刻みで簡単な更新関数の実行を何度も繰り返します。"

#. type: Plain text
#: text/chapter8.md:528
msgid ""
"We can do this by creating a mutable reference cell to hold the position and "
"velocity of the particle, and then using a `for` loop to update the value "
"stored in that cell:"
msgstr ""
"粒子の位置と速度を保持する変更可能な参照領域を作成し、領域に格納された値を更"
"新するのにforループを使うことでこれを実現できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:529
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Monad.ST.Ref (modify, new, read)\n"
"import Control.Monad.ST (ST, for, run)\n"
"\n"
"simulate :: forall r. Number -> Number -> Int -> ST r Number\n"
"simulate x0 v0 time = do\n"
"  ref <- new { x: x0, v: v0 }\n"
"  for 0 (time * 1000) \\_ ->\n"
"    modify\n"
"      ( \\o ->\n"
"          { v: o.v - 9.81 * 0.001\n"
"          , x: o.x + o.v * 0.001\n"
"          }\n"
"      )\n"
"      ref\n"
"  final <- read ref\n"
"  pure final.x\n"
msgstr ""
"import Prelude\n"
"\n"
"import Control.Monad.ST.Ref (modify, new, read)\n"
"import Control.Monad.ST (ST, for, run)\n"
"\n"
"simulate :: forall r. Number -> Number -> Int -> ST r Number\n"
"simulate x0 v0 time = do\n"
"  ref <- new { x: x0, v: v0 }\n"
"  for 0 (time * 1000) \\_ ->\n"
"    modify\n"
"      ( \\o ->\n"
"          { v: o.v - 9.81 * 0.001\n"
"          , x: o.x + o.v * 0.001\n"
"          }\n"
"      )\n"
"      ref\n"
"  final <- read ref\n"
"  pure final.x\n"

#. type: Plain text
#: text/chapter8.md:551
msgid ""
"At the end of the computation, we read the final value of the reference cell "
"and return the position of the particle."
msgstr ""
"計算の最後では、参照領域の最終的な値を読み取り、粒子の位置を返しています。"

#. type: Plain text
#: text/chapter8.md:553
msgid ""
"Note that even though this function uses a mutable state, it is still a pure "
"function, so long as the reference cell `ref` is not allowed to be used by "
"other program parts. We will see that this is exactly what the `ST` effect "
"disallows."
msgstr ""
"なお、この関数が変更可能な状態を使っていても、その参照領域`ref`がプログラムの"
"他の部分での使用が許されない限り、これは純粋な関数のままです。\n"
"このことが正に`ST`作用が禁止するものであることを見ていきます。"

#. type: Plain text
#: text/chapter8.md:555
msgid ""
"To run a computation with the `ST` effect, we have to use the `run` function:"
msgstr "`ST`作用付きで計算するには、`run`関数を使用する必要があります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:556
#, no-wrap
msgid "run :: forall a. (forall r. ST r a) -> a\n"
msgstr "run :: forall a. (forall r. ST r a) -> a\n"

#. type: Plain text
#: text/chapter8.md:561
msgid ""
"The thing to notice here is that the region type `r` is quantified _inside "
"the parentheses_ on the left of the function arrow. That means that whatever "
"action we pass to `run` has to work with _any region_ `r` whatsoever."
msgstr ""
"ここで注目して欲しいのは、領域型 `r`が関数矢印の左辺にある*括弧の内側で*量化"
"されているということです。\n"
"`run`に渡したどんな動作でも、*任意の領域*`r`が何であれ動作するということを意"
"味しています。"

#. type: Plain text
#: text/chapter8.md:563
msgid ""
"However, once a reference cell has been created by `new`, its region type is "
"already fixed, so it would be a type error to try to use the reference cell "
"outside the code delimited by `run`.  This allows `run` to safely remove the "
"`ST` effect and turn `simulate` into a pure function!"
msgstr ""
"しかし、ひとたび参照領域が`new`によって作成されると、その領域の型は既に固定さ"
"れており、`run`によって限定されたコードの外側で参照領域を使おうとしても型エ"
"ラーになるでしょう。\n"
"`run`が安全に`ST`作用を除去でき、`simulate`を純粋関数にできるのはこれが理由な"
"のです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:564
#, no-wrap
msgid ""
"simulate' :: Number -> Number -> Int -> Number\n"
"simulate' x0 v0 time = run (simulate x0 v0 time)\n"
msgstr ""
"simulate' :: Number -> Number -> Int -> Number\n"
"simulate' x0 v0 time = run (simulate x0 v0 time)\n"

#. type: Plain text
#: text/chapter8.md:570
msgid "You can even try running this function in PSCi:"
msgstr "PSCiでもこの関数を実行してみることができます。"

#. type: Fenced code block (text)
#: text/chapter8.md:571
#, no-wrap
msgid ""
"> import Main\n"
"\n"
"> simulate' 100.0 0.0 0\n"
"100.00\n"
"\n"
"> simulate' 100.0 0.0 1\n"
"95.10\n"
"\n"
"> simulate' 100.0 0.0 2\n"
"80.39\n"
"\n"
"> simulate' 100.0 0.0 3\n"
"55.87\n"
"\n"
"> simulate' 100.0 0.0 4\n"
"21.54\n"
msgstr ""
"> import Main\n"
"\n"
"> simulate' 100.0 0.0 0\n"
"100.00\n"
"\n"
"> simulate' 100.0 0.0 1\n"
"95.10\n"
"\n"
"> simulate' 100.0 0.0 2\n"
"80.39\n"
"\n"
"> simulate' 100.0 0.0 3\n"
"55.87\n"
"\n"
"> simulate' 100.0 0.0 4\n"
"21.54\n"

#. type: Plain text
#: text/chapter8.md:591
msgid ""
"In fact, if we inline the definition of `simulate` at the call to `run`, as "
"follows:"
msgstr ""
"実は、もし `simulate`の定義を `run`の呼び出しのところへ埋め込むとすると、次の"
"ようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:592
#, no-wrap
msgid ""
"simulate :: Number -> Number -> Int -> Number\n"
"simulate x0 v0 time =\n"
"  run do\n"
"    ref <- new { x: x0, v: v0 }\n"
"    for 0 (time * 1000) \\_ ->\n"
"      modify\n"
"        ( \\o ->\n"
"            { v: o.v - 9.81 * 0.001\n"
"            , x: o.x + o.v * 0.001\n"
"            }\n"
"        )\n"
"        ref\n"
"    final <- read ref\n"
"    pure final.x\n"
msgstr ""
"simulate :: Number -> Number -> Int -> Number\n"
"simulate x0 v0 time =\n"
"  run do\n"
"    ref <- new { x: x0, v: v0 }\n"
"    for 0 (time * 1000) \\_ ->\n"
"      modify\n"
"        ( \\o ->\n"
"            { v: o.v - 9.81 * 0.001\n"
"            , x: o.x + o.v * 0.001\n"
"            }\n"
"        )\n"
"        ref\n"
"    final <- read ref\n"
"    pure final.x\n"

#. type: Plain text
#: text/chapter8.md:610
msgid ""
"Then the compiler will notice that the reference cell cannot escape its "
"scope and can safely turn `ref` into a `var`. Here is the generated "
"JavaScript for `simulate` inlined with `run`:"
msgstr ""
"そうして、参照領域はそのスコープから逃れられないことと、安全に`ref`を`var`に"
"変換できることにコンパイラが気付きます。\n"
"`run`が埋め込まれた`simulate`に対して生成されたJavaScriptは次のようになりま"
"す。"

#. type: Fenced code block (javascript)
#: text/chapter8.md:611
#, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return (function __do() {\n"
"\n"
"        var ref = { value: { x: x0, v: v0 } };\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        return ref.value.x;\n"
"\n"
"      })();\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return (function __do() {\n"
"\n"
"        var ref = { value: { x: x0, v: v0 } };\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        return ref.value.x;\n"
"\n"
"      })();\n"
"    };\n"
"  };\n"
"};\n"

#. type: Plain text
#: text/chapter8.md:637
#, no-wrap
msgid "> Note that this resulting JavaScript is not as optimal as it could be. See [this issue](https://github.com/purescript-contrib/purescript-book/issues/121) for more details. The above snippet should be updated once that issue is resolved.\n"
msgstr ""
"> なお、この結果として得られたJavaScriptは最適化の余地があります。\n"
"> 詳細は[こちらの課題](https://github.com/purescript-contrib/purescript-book/issues/121)を参照してください。\n"
"> 上記の抜粋はそちらの課題が解決されたら更新されるでしょう。\n"

#. type: Plain text
#: text/chapter8.md:639
msgid ""
"For comparison, this is the generated JavaScript of the non-inlined form:"
msgstr "比較としてこちらが埋め込まれていない形式で生成されたJavaScriptです。"

#. type: Fenced code block (js)
#: text/chapter8.md:640
#, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return function __do() {\n"
"\n"
"        var ref = Control_Monad_ST_Internal[\"new\"]({ x: x0, v: v0 })();\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        var $$final = Control_Monad_ST_Internal.read(ref)();\n"
"        return $$final.x;\n"
"      };\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return function __do() {\n"
"\n"
"        var ref = Control_Monad_ST_Internal[\"new\"]({ x: x0, v: v0 })();\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        var $$final = Control_Monad_ST_Internal.read(ref)();\n"
"        return $$final.x;\n"
"      };\n"
"    };\n"
"  };\n"
"};\n"

#. type: Plain text
#: text/chapter8.md:666
msgid ""
"The `ST` effect is a good way to generate short JavaScript when working with "
"locally-scoped mutable state, especially when used together with actions "
"like `for`, `foreach`, and `while`, which generate efficient loops."
msgstr ""
"局所的な変更可能状態を扱うとき、`ST`作用は短いJavaScriptを生成する良い方法と"
"なります。\n"
"作用を持つ繰り返しを生成する`for`、`foreach`、`while`のような動作を一緒に使う"
"ときは特にそうです。"

#. type: Bullet: '1. '
#: text/chapter8.md:672
msgid ""
"(Medium) Rewrite the `safeDivide` function as `exceptionDivide` and throw an "
"exception using `throwException` with the message `\"div zero\"` if the "
"denominator is zero."
msgstr ""
"（普通）`safeDivide`関数を書き直し、もし分母がゼロなら`throwException`を使っ"
"て文言`\"div zero\"`の例外を投げるようにしたものを`exceptionDivide`としてくだ"
"さい。"

#. type: Bullet: '1. '
#: text/chapter8.md:672
msgid ""
"(Medium) Write a function `estimatePi :: Int -> Number` that uses `n` terms "
"of the [Gregory Series](https://mathworld.wolfram.com/GregorySeries.html) to "
"calculate an approximation of `pi`. _Hints:_ You can pattern your answer "
"like the definition of `simulate` above. You might need to convert an `Int` "
"into a `Number` using `toNumber :: Int -> Number` from `Data.Int`."
msgstr ""
"（普通）関数`estimatePi :: Int -> Number`を書いてください。\n"
"この関数は`n`項[Gregory Series](https://mathworld.wolfram.com/GregorySeries."
"html)を使って`pi`の近似を計算するものです。\n"
"*手掛かり*：解答は上記の`simulate`の定義に倣うことができます。\n"
"また`Data.Int`の`toNumber :: Int -> Number`を使って、`Int`を`Number`に変換す"
"る必要があるかもしれません。"

#. type: Bullet: '1. '
#: text/chapter8.md:672
msgid ""
"(Medium) Write a function `fibonacci :: Int -> Int` to compute the `n`th "
"Fibonacci number, using `ST` to track the values of the previous two "
"Fibonacci numbers. Using PSCi, compare the speed of your new `ST`-based "
"implementation against the recursive implementation (`fib`) from Chapter 4."
msgstr ""
"（普通）`n`番目のフィボナッチ数を計算する関数`fibonacci :: Int -> Int`を書い"
"てください。`ST`を使って前の2つのフィボナッチ数の値を把握します。新しい`ST`に"
"基づく実装の実行速度を第4章の再帰実装に対して比較してください。"

#. type: Title ##
#: text/chapter8.md:673
#, no-wrap
msgid "DOM Effects"
msgstr "DOM作用"

#. type: Plain text
#: text/chapter8.md:676
msgid ""
"In the final sections of this chapter, we will apply what we have learned "
"about effects in the `Effect` monad to the problem of working with the DOM."
msgstr ""
"この章の最後の節では、`Effect`モナドでの作用についてこれまで学んだことを、実"
"際のDOM操作の問題に応用します。"

#. type: Plain text
#: text/chapter8.md:678
msgid ""
"There are several PureScript packages for working directly with the DOM or "
"open-source DOM libraries. For example:"
msgstr ""
"DOMを直接扱ったり、オープンソースのDOMライブラリを扱ったりするPureScriptパッ"
"ケージが沢山あります。\n"
"例えば以下です。"

#. type: Bullet: '- '
#: text/chapter8.md:682
msgid ""
"[`web-dom`](https://github.com/purescript-web/purescript-web-dom) provides "
"type definitions and low-level interface implementations for the W3C DOM "
"spec."
msgstr ""
"[`web-dom`](https://github.com/purescript-web/purescript-web-dom)はW3CのDOM規"
"格に向けた型定義と低水準インターフェース実装を提供します。"

#. type: Bullet: '- '
#: text/chapter8.md:682
msgid ""
"[`web-html`](https://github.com/purescript-web/purescript-web-html) provides "
"type definitions and low-level interface implementations for the W3C HTML5 "
"spec."
msgstr ""
"[`web-html`](https://github.com/purescript-web/purescript-web-html)はW3Cの"
"HTML5規格に向けた型定義と低水準インターフェース実装を提供します。"

#. type: Bullet: '- '
#: text/chapter8.md:682
msgid ""
"[`jquery`](https://github.com/paf31/purescript-jquery) is a set of bindings "
"to the [jQuery](http://jquery.org) library."
msgstr ""
"[`jquery`](http://github.com/paf31/purescript-jquery)は[jQuery](http://"
"jquery.org)ライブラリのバインディングの集まりです。"

#. type: Plain text
#: text/chapter8.md:684
msgid ""
"There are also PureScript libraries that build abstractions on top of these "
"libraries, such as"
msgstr ""
"上記のライブラリを土台に抽象化を進めたPureScriptライブラリもあります。\n"
"以下のようなものです。"

#. type: Bullet: '- '
#: text/chapter8.md:688
msgid ""
"[`thermite`](https://github.com/paf31/purescript-thermite) builds on "
"[`react`](https://github.com/purescript-contrib/purescript-react)"
msgstr ""
"[`thermite`](https://github.com/paf31/purescript-thermite)は[`react`]"
"(https://github.com/purescript-contrib/purescript-react)を土台に構築されてい"
"ます。"

#. type: Bullet: '- '
#: text/chapter8.md:688
msgid ""
"[`react-basic-hooks`](https://github.com/megamaddu/purescript-react-basic-"
"hooks) builds on [`react-basic`](https://github.com/lumihq/purescript-react-"
"basic)"
msgstr ""
"[`react-basic-hooks`](https://github.com/megamaddu/purescript-react-basic-"
"hooks)は[`react-basic`](https://github.com/lumihq/purescript-react-basic)を土"
"台に構築されています。"

#. type: Bullet: '- '
#: text/chapter8.md:688
msgid ""
"[`halogen`](https://github.com/purescript-halogen/purescript-halogen) "
"provides a type-safe set of abstractions on top of a custom virtual DOM "
"library."
msgstr ""
"[`halogen`](https://github.com/purescript-halogen/purescript-halogen)は独自の"
"仮想DOMライブラリを土台とする型安全な一揃いの抽象化を提供します。"

#. type: Plain text
#: text/chapter8.md:690
msgid ""
"In this chapter, we will use the `react-basic-hooks` library to add a user "
"interface to our address book application, but the interested reader is "
"encouraged to explore alternative approaches."
msgstr ""
"この章では `react-basic-hooks`ライブラリを使用し、住所簿アプリケーションに"
"ユーザーインターフェイスを追加しますが、興味のあるユーザは異なるアプローチで"
"進めることをお勧めします。"

#. type: Title ##
#: text/chapter8.md:691
#, no-wrap
msgid "An Address Book User Interface"
msgstr "住所録のユーザーインターフェース"

#. type: Plain text
#: text/chapter8.md:694
msgid ""
"Using the `react-basic-hooks` library, we will define our application as a "
"React _component_. React components describe HTML elements in code as pure "
"data structures, which are then efficiently rendered to the DOM. In "
"addition, components can respond to events like button clicks. The `react-"
"basic-hooks` library uses the `Effect` monad to describe how to handle these "
"events."
msgstr ""
"`react-basic-hooks`ライブラリを使い、アプリケーションをReact*コンポーネント*"
"として定義していきます。ReactコンポーネントはHTML要素を純粋なデータ構造として"
"コードで記述します。それからこのデータ構造は効率的にDOMへ描画されます。加えて"
"コンポーネントはボタンクリックのようなイベントに応答できます。`react-basic-"
"hooks`ライブラリは`Effect`モナドを使ってこれらのイベントの制御方法を記述しま"
"す。"

#. type: Plain text
#: text/chapter8.md:696
msgid ""
"A full tutorial for the React library is well beyond the scope of this "
"chapter, but the reader is encouraged to consult its documentation where "
"needed. For our purposes, React will provide a practical example of the "
"`Effect` monad."
msgstr ""
"Reactライブラリの完全な入門はこの章の範囲をはるかに超えていますが、読者は必要"
"に応じて説明書を参照することをお勧めします。\n"
"目的に応じて、Reactは `Effect`モナドの実用的な例を提供してくれます。"

#. type: Plain text
#: text/chapter8.md:698
msgid ""
"We are going to build a form that will allow a user to add a new entry into "
"our address book. The form will contain text boxes for the various fields "
"(first name, last name, city, state, etc.) and an area where validation "
"errors will be displayed. As the user types text into the text boxes, the "
"validation errors will be updated."
msgstr ""
"利用者が住所録に新しい項目を追加できるフォームを構築することにしましょう。\n"
"フォームには、様々なフィールド（姓、名、市町村、州など）のテキストボックス、"
"及び検証エラーが表示される領域が含まれます。\n"
"テキストボックスに利用者がテキストを入力する度に、検証エラーが更新されます。"

#. type: Plain text
#: text/chapter8.md:700
msgid ""
"To keep things simple, the form will have a fixed shape: the different phone "
"number types (home, cell, work, other) will be expanded into separate text "
"boxes."
msgstr ""
"簡潔さを保つために、フォームは固定の形状とします。電話番号は種類（自宅、携帯"
"電話、仕事、その他）ごとに別々のテキストボックスへ分けることにします。"

#. type: Plain text
#: text/chapter8.md:702
msgid ""
"You can launch the web app from the `exercises/chapter8` directory with the "
"following commands:"
msgstr ""
"`exercises/chapter8`ディレクトリから以下のコマンドでwebアプリを立ち上げること"
"ができます。"

#. type: Fenced code block (shell)
#: text/chapter8.md:703
#, no-wrap
msgid ""
"$ npm install\n"
"$ npx spago build\n"
"$ npx parcel src/index.html --open\n"
msgstr ""
"$ npm install\n"
"$ npx spago build\n"
"$ npx parcel src/index.html --open\n"

#. type: Plain text
#: text/chapter8.md:710
msgid ""
"If development tools such as `spago` and `parcel` are installed globally, "
"then the `npx` prefix may be omitted. You have likely already installed "
"`spago` globally with `npm i -g spago`, and the same can be done for "
"`parcel`."
msgstr ""
"もし`spago`や`parcel`のような開発ツールが大域的にインストールされていれば、"
"`npx`の前置は省けるでしょう。\n"
"恐らく既に`spago`を`npm i -g spago`で大域的にインストールしていますし、"
"`parcel`についても同じことができるでしょう。"

#. type: Plain text
#: text/chapter8.md:712
msgid ""
"`parcel` should launch a browser window with our \"Address Book\" app. If "
"you keep the `parcel` terminal open and rebuild with `spago` in another "
"terminal, the page should automatically refresh with your latest edits. You "
"can also configure automatic rebuilds (and therefore automatic page refresh) "
"on file-save if you're using an [editor](https://github.com/purescript/"
"documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors) that "
"supports [`purs ide`](https://github.com/purescript/purescript/tree/master/"
"psc-ide) or are running [`pscid`](https://github.com/kRITZCREEK/pscid)."
msgstr ""
"`parcel`は「アドレス帳」アプリのブラウザ窓を立ち上げます。\n"
"`parcel`の端末を開いたままにし、他の端末で`spago`で再構築すると、最新の編集を"
"含むページが自動的に再読み込みされるでしょう。\n"
"また、[`purs ide`](https://github.com/purescript/purescript/tree/master/psc-"
"ide)に対応していたり[`pscid`](https://github.com/kRITZCREEK/pscid)を走らせて"
"いたりする[エディタ](https://github.com/purescript/documentation/blob/master/"
"ecosystem/Editor-and-tool-support.md#editors)を使っていれば、ファイルを保存し"
"たときに自動的にページが再構築される（そして自動的にページが再読み込みされ"
"る）ように設定できます。"

#. type: Plain text
#: text/chapter8.md:714
msgid ""
"In this Address Book app, you can enter some values into the form fields and "
"see the validation errors printed onto the page."
msgstr ""
"このアドレス帳アプリでフォームフィールドにいろいろな値を入力すると、ページ上"
"で出力された検証エラーが見られます。"

#. type: Plain text
#: text/chapter8.md:716
msgid "Let's explore how it works."
msgstr "動作の仕組みを散策しましょう。"

#. type: Plain text
#: text/chapter8.md:718
msgid "The `src/index.html` file is minimal:"
msgstr "`src/index.html`ファイルは最小限です。"

#. type: Fenced code block (html)
#: text/chapter8.md:719
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.html}}\n"
msgstr "{{#include ../exercises/chapter8/src/index.html}}\n"

#. type: Plain text
#: text/chapter8.md:724
#, no-wrap
msgid "The `<script` line includes the JavaScript entry point, `index.js`, which contains this single line:\n"
msgstr "`<script`の行にJavaScriptの入口が含まれており、`index.js`にはこの実質1行だけが含まれています。\n"

#. type: Fenced code block (js)
#: text/chapter8.md:725
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.js}}\n"
msgstr "{{#include ../exercises/chapter8/src/index.js}}\n"

#. type: Plain text
#: text/chapter8.md:730
msgid ""
"It calls our generated JavaScript equivalent of the `main` function of "
"`module Main` (`src/main.purs`). Recall that `spago build` puts all "
"generated JavaScript in the `output` directory."
msgstr ""
"`module Main` (`src/main.purs`) の`main`関数と等価な、生成したJavaScriptを呼"
"び出しています。\n"
"`spago build`は生成された全てのJavaScriptを`output`ディレクトリに置くことを思"
"い出してください。"

#. type: Plain text
#: text/chapter8.md:732
msgid ""
"The `main` function uses the DOM and HTML APIs to render our address book "
"component within the `container` element we defined in `index.html`:"
msgstr ""
"`main`関数はDOMとHTML APIを使い、`index.html`に定義した`container`要素の中に"
"アドレス帳コンポーネントを描画します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:733
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:main}}\n"
msgstr "{{#include ../exercises/chapter8/src/Main.purs:main}}\n"

#. type: Plain text
#: text/chapter8.md:738
msgid "Note that these three lines:"
msgstr "これら3行に注目してください。"

#. type: Fenced code block (hs)
#: text/chapter8.md:739
#, no-wrap
msgid ""
"w <- window\n"
"doc <- document w\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""
"w <- window\n"
"doc <- document w\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"

#. type: Plain text
#: text/chapter8.md:746
msgid "Can be consolidated to:"
msgstr "これは次のように統合できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:747
#, no-wrap
msgid ""
"doc <- document =<< window\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""
"doc <- document =<< window\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"

#. type: Plain text
#: text/chapter8.md:753
msgid "Or consolidated even further to:"
msgstr "あるいは更なる統合さえできます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:754
#, no-wrap
msgid ""
"ctr <- getElementById \"container\" <<< toNonElementParentNode =<< document =<< window\n"
"-- or, equivalently:\n"
"ctr <- window >>= document >>= toNonElementParentNode >>> getElementById \"container\"\n"
msgstr ""
"ctr <- getElementById \"container\" <<< toNonElementParentNode =<< document =<< window\n"
"-- or, equivalently:\n"
"ctr <- window >>= document >>= toNonElementParentNode >>> getElementById \"container\"\n"

#. type: Plain text
#: text/chapter8.md:761
msgid ""
"It is a matter of personal preference whether the intermediate `w` and `doc` "
"variables aid in readability."
msgstr ""
"途中の`w`や`doc`変数が読みやすさの助けになるかは主観的な好みの問題です。"

#. type: Plain text
#: text/chapter8.md:763
msgid ""
"Let's dig into our AddressBook `reactComponent`. We'll start with a "
"simplified component and then build up to the actual code in `Main.purs`."
msgstr ""
"AddressBookの`reactComponent`を深堀りしましょう。\n"
"単純化されたコンポーネントから始め、それから`Main.purs`で実際のコードに構築し"
"ていきます。"

#. type: Plain text
#: text/chapter8.md:765
msgid ""
"Take a look at this minimal component. Feel free to substitute the full "
"component with this one to see it run:"
msgstr ""
"以下の最小限のコンポーネントをご覧ください。\n"
"遠慮なく全体のコンポーネントをこれに置き換えて実行の様子を見てみましょう。"

#. type: Fenced code block (hs)
#: text/chapter8.md:766
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp =\n"
"  reactComponent\n"
"    \"AddressBookApp\"\n"
"    (\\props -> pure $ D.text \"Hi! I'm an address book\")\n"
msgstr ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp =\n"
"  reactComponent\n"
"    \"AddressBookApp\"\n"
"    (\\props -> pure $ D.text \"Hi! I'm an address book\")\n"

#. type: Plain text
#: text/chapter8.md:775
msgid "`reactComponent` has this intimidating signature:"
msgstr "`reactComponent`にはこのような威圧的なシグネチャがあります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:776
#, no-wrap
msgid ""
"reactComponent ::\n"
"  forall hooks props.\n"
"  Lacks \"children\" props =>\n"
"  Lacks \"key\" props =>\n"
"  Lacks \"ref\" props =>\n"
"  String ->\n"
"  ({ | props } -> Render Unit hooks JSX) ->\n"
"  Effect (ReactComponent { | props })\n"
msgstr ""
"reactComponent ::\n"
"  forall hooks props.\n"
"  Lacks \"children\" props =>\n"
"  Lacks \"key\" props =>\n"
"  Lacks \"ref\" props =>\n"
"  String ->\n"
"  ({ | props } -> Render Unit hooks JSX) ->\n"
"  Effect (ReactComponent { | props })\n"

#. type: Plain text
#: text/chapter8.md:788
msgid ""
"The important points to note are the arguments after all the type class "
"constraints. It takes a `String` (an arbitrary component name), a function "
"that describes how to convert `props` into rendered `JSX`, and returns our "
"`ReactComponent` wrapped in an `Effect`."
msgstr ""
"重要な注意点は全ての型クラス制約の後の引数にあります。\n"
"`String`（任意のコンポーネント名）、`props`を描画された`JSX`に変換する方法を"
"記述する関数を取り、そして`Effect`に包まれた`ReactComponent`を返します。"

#. type: Plain text
#: text/chapter8.md:790
msgid "The props-to-JSX function is simply:"
msgstr "propsからJSXへの関数は単にこうです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:791
#, no-wrap
msgid "\\props -> pure $ D.text \"Hi! I'm an address book\"\n"
msgstr "\\props -> pure $ D.text \"Hi! I'm an address book\"\n"

#. type: Plain text
#: text/chapter8.md:796
msgid ""
"`props` are ignored, `D.text` returns `JSX`, and `pure` lifts to rendered "
"JSX. Now `component` has everything it needs to produce the `ReactComponent`."
msgstr ""
"`props`は無視されており、`D.text`は`JSX`を返し、そして`pure`は描画されたJSXに"
"持ち上げます。\n"
"これで`component`には`ReactComponent`を生成するのに必要な全てがあります。"

#. type: Plain text
#: text/chapter8.md:798
msgid ""
"Next, we'll examine some of the additional complexities of the full Address "
"Book component."
msgstr ""
"次に、完全なアドレス帳コンポーネントにある幾つかの複雑な事柄を調べていきま"
"す。"

#. type: Plain text
#: text/chapter8.md:800
msgid "These are the first few lines of our full component:"
msgstr "これらは完全なコンポーネントの最初の数行です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:801
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp = do\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState examplePerson\n"
msgstr ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp = do\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState examplePerson\n"

#. type: Plain text
#: text/chapter8.md:809
msgid "We track `person` as a piece of state with the `useState` hook."
msgstr "`person`を`useState`フックの状態の一部として追跡します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:810
#, no-wrap
msgid "Tuple person setPerson <- useState examplePerson\n"
msgstr "Tuple person setPerson <- useState examplePerson\n"

#. type: Plain text
#: text/chapter8.md:815
msgid ""
"Note that you are free to break-up component state into multiple pieces of "
"state with multiple calls to `useState`. For example, we could rewrite this "
"app to use a separate piece of state for each record field of `Person`, but "
"that results in a slightly less convenient architecture in this case."
msgstr ""
"なお、複数回`useState`を呼び出すことで、コンポーネントの状態を複数の状態の部"
"品に分解することが自在にできます。\n"
"例えば`Person`の各レコードフィールドについて分離した状態の部品を使って、この"
"アプリを書き直すことができるでしょう。\n"
"しかしこの場合にそうすると僅かに利便性を損なうアーキテクチャになってしまいま"
"す。"

#. type: Plain text
#: text/chapter8.md:817
msgid ""
"In other examples, you may encounter the `/\\` infix operator for `Tuple`. "
"This is equivalent to the above line:"
msgstr ""
"他の例では`Tuple`用の`/\\`中置演算子に出喰わすかもしれません。\n"
"これは先の行と等しいものです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:818
#, no-wrap
msgid "firstName /\\ setFirstName <- useState p.firstName\n"
msgstr "firstName /\\ setFirstName <- useState p.firstName\n"

#. type: Plain text
#: text/chapter8.md:823
msgid ""
"`useState` takes a default initial value and returns the current value and a "
"way to update the value. We can check the type of `useState` to gain more "
"insight of the types `person` and `setPerson`:"
msgstr ""
"`useState`は、既定の初期値を取って現在の値と値を更新する方法を取ります。\n"
"`useState`の型を確認すれば型`person`と`setPerson`についてより深い洞察が得られ"
"ます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:824
#, no-wrap
msgid ""
"useState ::\n"
"  forall state.\n"
"  state ->\n"
"  Hook (UseState state) (Tuple state ((state -> state) -> Effect Unit))\n"
msgstr ""
"useState ::\n"
"  forall state.\n"
"  state ->\n"
"  Hook (UseState state) (Tuple state ((state -> state) -> Effect Unit))\n"

#. type: Plain text
#: text/chapter8.md:832
msgid ""
"We can strip the `Hook (UseState state)` wrapper off of the return value "
"because `useState` is called within an `R.do` block. We'll elaborate on `R."
"do` later."
msgstr ""
"結果の値の梱包`Hook (UseState state)`は取り去ることができますが、それは"
"`useState`が`R.do`ブロックの中で呼ばれているからです。\n"
"`R.do`は後で詳述します。"

#. type: Plain text
#: text/chapter8.md:834
msgid "So now we can observe the following signatures:"
msgstr "さてこれで以下のシグネチャを観察できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:835
#, no-wrap
msgid ""
"person :: state\n"
"setPerson :: (state -> state) -> Effect Unit\n"
msgstr ""
"person :: state\n"
"setPerson :: (state -> state) -> Effect Unit\n"

#. type: Plain text
#: text/chapter8.md:841
msgid ""
"The specific type of `state` is determined by our initial default value. "
"`Person` `Record` in this case because that is the type of `examplePerson`."
msgstr ""
"`state`の限定された型は初期の既定値によって決定されます。\n"
"これは`examplePerson`の型なのでこの場合は`Person` `Record`です。"

#. type: Plain text
#: text/chapter8.md:843
msgid "`person` is how we access the current state at each rerender."
msgstr "`person`は各再描画の時点で現在の状態にアクセスする方法です。"

#. type: Plain text
#: text/chapter8.md:845
msgid ""
"`setPerson` is how we update the state. We provide a function describing how "
"to transform the current state into the new one. The record update syntax is "
"perfect for this when the type of `state` happens to be a `Record`, for "
"example:"
msgstr ""
"`setPerson`は状態を更新する方法です。\n"
"単に現在の状態を新しい状態に変形する方法を記述する関数を提供します。\n"
"`state`の型が偶然`Record`のときは、レコード更新構文がこれにぴったり合いま"
"す。\n"
"例えば以下。"

#. type: Fenced code block (hs)
#: text/chapter8.md:846
#, no-wrap
msgid ""
"setPerson (\\currentPerson -> currentPerson {firstName = \"NewName\"})\n"
"\n"
msgstr ""
"setPerson (\\currentPerson -> currentPerson {firstName = \"NewName\"})\n"
"\n"

#. type: Plain text
#: text/chapter8.md:852
msgid "Or as shorthand:"
msgstr "あるいは短かく以下です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:853
#, no-wrap
msgid "setPerson _ {firstName = \"NewName\"}\n"
msgstr "setPerson _ {firstName = \"NewName\"}\n"

#. type: Plain text
#: text/chapter8.md:858
msgid ""
"Non-`Record` states can also follow this update pattern. See [this guide]"
"(https://github.com/megamaddu/purescript-react-basic-hooks/"
"pull/24#issuecomment-620300541) for more details on best practices."
msgstr ""
"`Record`でない状態もまた、この更新パターンに従います。\n"
"ベストプラクティスについて、より詳しいことは[この手引き](https://github.com/"
"megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541)を参照"
"してください。"

#. type: Plain text
#: text/chapter8.md:860
msgid ""
"Recall that `useState` is used within an `R.do` block. `R.do` is a special "
"react hooks variant of `do`. The `R.` prefix \"qualifies\" this as coming "
"from `React.Basic.Hooks`, and means we use their hooks-compatible version of "
"`bind` in the `R.do` block. This is known as a \"qualified do\". It lets us "
"ignore the `Hook (UseState state)` wrapping and bind the inner `Tuple` of "
"values to variables."
msgstr ""
"`useState`が`R.do`ブロックの中で使われていることを思い出しましょう。\n"
"`R.do`は`do`の特別なreactフックの派生です。\n"
"`R.`の前置はこれが`React.Basic.Hooks`から来たものとして「限定する」もので、"
"`R.do`ブロックの中でフック互換版の`bind`を使うことを意味しています。\n"
"これは「限定されたdo」として知られています。\n"
"`Hook (UseState state)`の梱包を無視し、内部の値の`Tuple`と変数に束縛してくれ"
"ます。"

#. type: Plain text
#: text/chapter8.md:862
msgid ""
"Another possible state management strategy is with `useReducer`, but that is "
"outside the scope of this chapter."
msgstr ""
"他の状態管理戦略として挙げられるのは`useReducer`ですが、それはこの章の範疇外"
"です。"

#. type: Plain text
#: text/chapter8.md:864
msgid "Rendering `JSX` occurs here:"
msgstr "以下では`JSX`の描画が行われています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:865
#, no-wrap
msgid ""
"pure\n"
"  $ D.div\n"
"      { className: \"container\"\n"
"      , children:\n"
"          renderValidationErrors errors\n"
"            <> [ D.div\n"
"                  { className: \"row\"\n"
"                  , children:\n"
"                      [ D.form_\n"
"                          $ [ D.h3_ [ D.text \"Basic Information\" ]\n"
"                            , formField \"First Name\" \"First Name\" person.firstName \\s ->\n"
"                                setPerson _ { firstName = s }\n"
"                            , formField \"Last Name\" \"Last Name\" person.lastName \\s ->\n"
"                                setPerson _ { lastName = s }\n"
"                            , D.h3_ [ D.text \"Address\" ]\n"
"                            , formField \"Street\" \"Street\" person.homeAddress.street \\s ->\n"
"                                setPerson _ { homeAddress { street = s } }\n"
"                            , formField \"City\" \"City\" person.homeAddress.city \\s ->\n"
"                                setPerson _ { homeAddress { city = s } }\n"
"                            , formField \"State\" \"State\" person.homeAddress.state \\s ->\n"
"                                setPerson _ { homeAddress { state = s } }\n"
"                            , D.h3_ [ D.text \"Contact Information\" ]\n"
"                            ]\n"
"                          <> renderPhoneNumbers\n"
"                      ]\n"
"                  }\n"
"              ]\n"
"      }\n"
msgstr ""
"pure\n"
"  $ D.div\n"
"      { className: \"container\"\n"
"      , children:\n"
"          renderValidationErrors errors\n"
"            <> [ D.div\n"
"                  { className: \"row\"\n"
"                  , children:\n"
"                      [ D.form_\n"
"                          $ [ D.h3_ [ D.text \"Basic Information\" ]\n"
"                            , formField \"First Name\" \"First Name\" person.firstName \\s ->\n"
"                                setPerson _ { firstName = s }\n"
"                            , formField \"Last Name\" \"Last Name\" person.lastName \\s ->\n"
"                                setPerson _ { lastName = s }\n"
"                            , D.h3_ [ D.text \"Address\" ]\n"
"                            , formField \"Street\" \"Street\" person.homeAddress.street \\s ->\n"
"                                setPerson _ { homeAddress { street = s } }\n"
"                            , formField \"City\" \"City\" person.homeAddress.city \\s ->\n"
"                                setPerson _ { homeAddress { city = s } }\n"
"                            , formField \"State\" \"State\" person.homeAddress.state \\s ->\n"
"                                setPerson _ { homeAddress { state = s } }\n"
"                            , D.h3_ [ D.text \"Contact Information\" ]\n"
"                            ]\n"
"                          <> renderPhoneNumbers\n"
"                      ]\n"
"                  }\n"
"              ]\n"
"      }\n"

#. type: Plain text
#: text/chapter8.md:897
msgid ""
"Here we produce `JSX`, which represents the intended state of the DOM. This "
"JSX is typically created by applying functions corresponding to HTML tags (e."
"g., `div`, `form`, `h3`, `li`, `ul`, `label`, `input`) which create single "
"HTML elements. These HTML elements are React components themselves, "
"converted to JSX. There are usually three variants of each of these "
"functions:"
msgstr ""
"ここでDOMの意図した状態を表現する`JSX`を生成しています。\n"
"このJSXは単一のHTML要素を作るHTMLタグ（例：`div`、`form`、`h3`、`li`、`ul`、"
"`label`、`input`）に対応する関数を適用することで作られるのが普通です。\n"
"これらのHTML要素はそれ自体がReactコンポーネントであり、JSXに変換されます。\n"
"通常これらの関数にはそれぞれ3つの種類があります。"

#. type: Bullet: '- '
#: text/chapter8.md:901
msgid "`div_`: Accepts an array of child elements. Uses default attributes."
msgstr ""
"`div_`: 子要素の配列を受け付けます。\n"
"既定の属性を使います。"

#. type: Bullet: '- '
#: text/chapter8.md:901
msgid ""
"`div`: Accepts a `Record` of attributes. An array of child elements may be "
"passed to the `children` field of this record."
msgstr ""
"`div`: 属性の`Record`を受け付けます。\n"
"子要素の配列をこのレコードの`children`フィールドに渡すことができます。"

#. type: Bullet: '- '
#: text/chapter8.md:901
msgid ""
"`div'`: Same as `div`, but returns the `ReactComponent` before conversion to "
"`JSX`."
msgstr ""
"`div'`: `div`と同じですが、`JSX`に変換する前に`ReactComponent`を返します。"

#. type: Plain text
#: text/chapter8.md:903
msgid ""
"To display validation errors (if any) at the top of our form, we create a "
"`renderValidationErrors` helper function that turns the `Errors` structure "
"into an array of JSX. This array is prepended to the rest of our form."
msgstr ""
"検証エラーをフォームの一番上に（もしあれば）表示するため、`Errors`構造体をJSX"
"の配列に変える`renderValidationErrors`補助関数を作ります。この配列はフォーム"
"の残り部分の手前に付けます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:904
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:renderValidationErrors}}\n"
msgstr "{{#include ../exercises/chapter8/src/Main.purs:renderValidationErrors}}\n"

#. type: Plain text
#: text/chapter8.md:909
msgid ""
"Note that since we are simply manipulating regular data structures here, we "
"can use functions like `map` to build up more interesting elements:"
msgstr ""
"なお、ここでは単に通常のデータ構造体を操作しているので、`map`のような関数を"
"使ってもっと面白い要素を構築できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:910
#, no-wrap
msgid "children: [ D.ul_ (map renderError xs)]\n"
msgstr "children: [ D.ul_ (map renderError xs)]\n"

#. type: Plain text
#: text/chapter8.md:915
msgid ""
"We use the `className` property to define classes for CSS styling. We're "
"using the [Bootstrap](https://getbootstrap.com/) `stylesheet` for this "
"project, which is imported in `index.html`. For example, we want items in "
"our form arranged as `row`s, and validation errors to be emphasized with "
"`alert-danger` styling:"
msgstr ""
"`className`プロパティを使ってCSSスタイルのクラスを定義します。\n"
"このプロジェクトでは[Bootstrap](https://getbootstrap.com/)の`stylesheet`を"
"使っており、これは`index.html`でインポートされています。\n"
"例えばフォーム中のアイテムは`row`として配置されてほしいですし、検証エラーは"
"`alert-danger`の装飾で強調されていてほしいです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:916
#, no-wrap
msgid "className: \"alert alert-danger row\"\n"
msgstr "className: \"alert alert-danger row\"\n"

#. type: Plain text
#: text/chapter8.md:921
msgid ""
"A second helper function is `formField`, which creates a text input for a "
"single form field:"
msgstr ""
"2番目の補助関数は `formField`です。\n"
"これは、単一フォームフィールドのテキスト入力を作ります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:922
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:formField}}\n"
msgstr "{{#include ../exercises/chapter8/src/Main.purs:formField}}\n"

#. type: Plain text
#: text/chapter8.md:927
msgid ""
"Putting the `input` and display `text` in a `label` aids in accessibility "
"for screen readers."
msgstr ""
"`input`を置いて`label`の中に`text`を表示すると、スクリーンリーダーのアクセシ"
"ビリティの助けになります。"

#. type: Plain text
#: text/chapter8.md:929
msgid ""
"The `onChange` attribute allows us to describe how to respond to user input. "
"We use the `handler` function, which has the following type:"
msgstr ""
"`onChange`属性があれば利用者の入力に応答する方法を記述できます。`handler`関数"
"を使いますが、これは以下の型を持ちます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:930
#, no-wrap
msgid "handler :: forall a. EventFn SyntheticEvent a -> (a -> Effect Unit) -> EventHandler\n"
msgstr "handler :: forall a. EventFn SyntheticEvent a -> (a -> Effect Unit) -> EventHandler\n"

#. type: Plain text
#: text/chapter8.md:935
msgid ""
"For the first argument to `handler` we use `targetValue`, which provides the "
"value of the text within the HTML `input` element. It matches the signature "
"expected by `handler` where the type variable `a` in this case is `Maybe "
"String`:"
msgstr ""
"`handler`への最初の引数には`targetValue`を使いますが、これはHTMLの`input`要素"
"中のテキストの値を提供します。\n"
"この場合は型変数`a`が`Maybe String`で、`handler`が期待するシグネチャに合致し"
"ています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:936
#, no-wrap
msgid "targetValue :: EventFn SyntheticEvent (Maybe String)\n"
msgstr "targetValue :: EventFn SyntheticEvent (Maybe String)\n"

#. type: Plain text
#: text/chapter8.md:941
msgid ""
"In JavaScript, the `input` element's `onChange` event is accompanied by a "
"`String` value, but since strings in JavaScript can be null, `Maybe` is used "
"for safety."
msgstr ""
"JavaScriptでは`input`要素の`onChange`イベントには`String`値が伴います。\n"
"しかし、JavaScriptの文字列はnullになり得るので、安全のために`Maybe`が使われて"
"います。"

#. type: Plain text
#: text/chapter8.md:943
#, no-wrap
msgid "The second argument to `handler`, `(a -> Effect Unit)`, must therefore have this signature:\n"
msgstr "したがって`(a -> Effect Unit)`の`handler`への2つ目の引数は、このシグネチャを持ちます。\n"

#. type: Fenced code block (hs)
#: text/chapter8.md:944
#, no-wrap
msgid "Maybe String -> Effect Unit\n"
msgstr "Maybe String -> Effect Unit\n"

#. type: Plain text
#: text/chapter8.md:949
msgid ""
"It is a function that describes how to convert this `Maybe String` value "
"into our desired effect. We define a custom `handleValue` function for this "
"purpose and pass it to `handler` as follows:"
msgstr ""
"この関数は`Maybe String`値を求める作用に変換する方法を記述します。\n"
"この目的のために以下のように独自の`handleValue`関数を定義して`handler`を渡し"
"ます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:950
#, no-wrap
msgid ""
"onChange:\n"
"  let\n"
"    handleValue :: Maybe String -> Effect Unit\n"
"    handleValue (Just v) = setValue v\n"
"    handleValue Nothing  = pure unit\n"
"  in\n"
"    handler targetValue handleValue\n"
msgstr ""
"onChange:\n"
"  let\n"
"    handleValue :: Maybe String -> Effect Unit\n"
"    handleValue (Just v) = setValue v\n"
"    handleValue Nothing  = pure unit\n"
"  in\n"
"    handler targetValue handleValue\n"

#. type: Plain text
#: text/chapter8.md:961
msgid ""
"`setValue` is the function we provided to each `formField` call that takes a "
"string and makes the appropriate record-update call to the `setPerson` hook."
msgstr ""
"`setValue`は`formField`の各呼び出しに与えた関数で、文字列を取り`setPerson`"
"フックに適切なレコード更新呼び出しを実施します。"

#. type: Plain text
#: text/chapter8.md:963
msgid "Note that `handleValue` can be substituted as:"
msgstr "なお、`handleValue`は以下のようにも置き換えられます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:964
#, no-wrap
msgid "onChange: handler targetValue $ traverse_ setValue\n"
msgstr "onChange: handler targetValue $ traverse_ setValue\n"

#. type: Plain text
#: text/chapter8.md:969
msgid ""
"Feel free to investigate the definition of `traverse_` to see how both forms "
"are indeed equivalent."
msgstr ""
"`traverse_`の定義を調査して、両方の形式が確かに等価であることをご確認くださ"
"い。"

# ここでのsourceはソースコードを意味していると思われます。
#. type: Plain text
#: text/chapter8.md:971
msgid ""
"That covers the basics of our component implementation. However, you should "
"read the source accompanying this chapter to get a full understanding of the "
"way the component works."
msgstr ""
"これでコンポーネント実装の基本を押さえました。\n"
"しかし、コンポーネントの仕組みを完全に理解するためには、この章に付随するソー"
"スをお読みください。"

#. type: Plain text
#: text/chapter8.md:973
msgid ""
"Obviously, this user interface can be improved in a number of ways. The "
"exercises will explore some ways in which we can make the application more "
"usable."
msgstr ""
"明らかに、このユーザーインターフェースには改善すべき点が沢山あります。\n"
"演習ではアプリケーションがより使いやすくなるような方法を追究していきます。"

#. type: Plain text
#: text/chapter8.md:977
msgid ""
"Modify `src/Main.purs` in the following exercises. There are no unit tests "
"for these exercises."
msgstr ""
"以下の演習では`src/Main.purs`を変更してください。\n"
"これらの演習には単体試験はありません。"

#. type: Bullet: '1. '
#: text/chapter8.md:980
msgid "(Easy) Modify the application to include a work phone number text box."
msgstr ""
"（簡単）このアプリケーションを変更し、職場の電話番号を入力できるテキストボッ"
"クスを追加してください。"

#. type: Bullet: '1. '
#: text/chapter8.md:980
msgid ""
"(Medium) Right now, the application shows validation errors collected in a "
"single \"pink-alert\" background.  Modify to give each validation error its "
"own pink-alert background by separating them with blank lines."
msgstr ""
"（普通）現時点でアプリケーションは検証エラーを単一の「pink-alert」背景に集め"
"て表示させています。\n"
"空行で分離することにより、各検証エラーにpink-alert背景を持たせるように変更し"
"てください。"

#. type: Plain text
#: text/chapter8.md:983
#, no-wrap
msgid ""
"    _Hint_: Instead of using a `ul` element to show the validation errors in a list, modify the code to create one `div` with the `alert` and `alert-danger` styles for each error.\n"
"1. (Difficult, Extended) One problem with this user interface is that the validation errors are not displayed next to the form fields they originated from. Modify the code to fix this problem.\n"
msgstr ""
"    *手掛かり*：リスト中の検証エラーを表示するのに`ul`要素を使う代わりに、コードを変更し、各エラーに`alert`と`alert-danger`装飾を持つ`div`を作ってください。\n"
"1. （難しい、発展）このユーザーインターフェイスの問題の1つは、検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。\n"
"   コードを変更してこの問題を解決してください。\n"

#. type: Plain text
#: text/chapter8.md:985
#, no-wrap
msgid "    _Hint_: The error type returned by the validator should be extended to indicate which field caused the error. You might want to use the following modified `Errors` type:\n"
msgstr ""
"    *手掛かり*：検証器によって返されるエラーの型を、エラーの原因となっているフィールドを示すために拡張するべきです。\n"
"    以下の変更されたエラー型を使うと良いでしょう。\n"

#. type: Plain text
#: text/chapter8.md:993
#, no-wrap
msgid ""
"    ```hs\n"
"    data Field = FirstNameField\n"
"               | LastNameField\n"
"               | StreetField\n"
"               | CityField\n"
"               | StateField\n"
"               | PhoneField PhoneType\n"
msgstr ""
"    ```hs\n"
"    data Field = FirstNameField\n"
"               | LastNameField\n"
"               | StreetField\n"
"               | CityField\n"
"               | StateField\n"
"               | PhoneField PhoneType\n"

#. type: Plain text
#: text/chapter8.md:995
#, no-wrap
msgid "    data ValidationError = ValidationError String Field\n"
msgstr "    data ValidationError = ValidationError String Field\n"

#. type: Plain text
#: text/chapter8.md:998
#, no-wrap
msgid ""
"    type Errors = Array ValidationError\n"
"    ```\n"
msgstr ""
"    type Errors = Array ValidationError\n"
"    ```\n"

#. type: Plain text
#: text/chapter8.md:1000
#, no-wrap
msgid "    You will need to write a function that extracts the validation error for a particular `Field` from the `Errors` structure.\n"
msgstr "   `Error`構造体から特定の`Field`のための検証エラーを取り出す関数を書く必要があるでしょう。\n"

#. type: Plain text
#: text/chapter8.md:1004
msgid ""
"This chapter has covered a lot of ideas about handling side-effects in "
"PureScript:"
msgstr ""
"この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。"

#. type: Bullet: '- '
#: text/chapter8.md:1011
msgid "We met the `Monad` type class and its connection to do notation."
msgstr "`Monad`型クラスとdo記法との関係性を見ました。"

# they allow usが訳せているかどうか……
#. type: Bullet: '- '
#: text/chapter8.md:1011
msgid ""
"We introduced the monad laws and saw how they allow us to transform code "
"written using do notation."
msgstr ""
"モナド則を導入し、do記法を使って書かれたコードを変換する方法を見ました。"

# monads can be usedが訳せているかどうか……
#. type: Bullet: '- '
#: text/chapter8.md:1011
msgid ""
"We saw how monads can be used abstractly to write code that works with "
"different side-effects."
msgstr ""
"異なる副作用を扱うコードを書く上で、モナドを抽象的に使う方法を見ました。"

#. type: Bullet: '- '
#: text/chapter8.md:1011
msgid ""
"We saw how monads are examples of applicative functors, how both allow us to "
"compute with side-effects, and the differences between the two approaches."
msgstr ""
"モナドがアプリカティブ関手の一例であること、両者がどのように副作用のある計算"
"を可能にするのかということ、そして2つの手法の違いを説明しました。"

#. type: Bullet: '- '
#: text/chapter8.md:1011
msgid ""
"The concept of native effects was defined, and we met the `Effect` monad, "
"which handles native side-effects."
msgstr ""
"ネイティブな作用の概念を定義し、`Effect`モナドを見ました。\n"
"これはネイティブな副作用を扱うものでした。"

#. type: Bullet: '- '
#: text/chapter8.md:1011
msgid ""
"We used the `Effect` monad to handle a variety of effects: random number "
"generation, exceptions, console IO, mutable state, and DOM manipulation "
"using React."
msgstr ""
"乱数生成、例外、コンソール入出力、変更可能な状態、及びReactを使ったDOM操作と"
"いった、様々な作用を扱うために `Effect`モナドを使いました。"

#. type: Plain text
#: text/chapter8.md:1012
msgid ""
"The `Effect` monad is a fundamental tool in real-world PureScript code. It "
"will be used in the rest of the book to handle side-effects in a number of "
"other use-cases."
msgstr ""
"`Effect`モナドは実際のPureScriptコードにおける基本的なツールです。本書ではこ"
"のあとも、多くの場面で副作用を処理するために使っていきます。"

#. type: Title #
#: text/chapter9.md:1
#, no-wrap
msgid "Asynchronous Effects"
msgstr "非同期作用"

#. type: Plain text
#: text/chapter9.md:6
msgid ""
"This chapter focuses on the `Aff` monad, which is similar to the `Effect` "
"monad, but represents _asynchronous_ side-effects. We'll demonstrate "
"examples of asynchronously interacting with the filesystem and making HTTP "
"requests. We'll also cover managing sequential and parallel execution of "
"asynchronous effects."
msgstr ""
"この章では`Aff`モナドに集中します。\n"
"これは`Effect`モナドに似ていますが、*非同期*な副作用を表現するものです。\n"
"非同期にファイルシステムとやり取りしたりHTTPリクエストしたりする例を実演して"
"いきます。\n"
"また非同期作用の直列ないし並列な実行の管理方法も押さえます。"

#. type: Plain text
#: text/chapter9.md:10
msgid "New PureScript libraries introduced in this chapter are:"
msgstr "この章で導入する新しいPureScriptライブラリは以下です。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`aff` - defines the `Aff` monad."
msgstr "`aff` - `Aff`モナドを定義します。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`node-fs-aff` - asynchronous filesystem operations with `Aff`."
msgstr "`node-fs-aff` - `Aff`を使った非同期のファイルシステム操作。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`affjax` - HTTP requests with AJAX and `Aff`."
msgstr "`affjax` - AJAXと`Aff`を使ったHTTPリクエスト。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`parallel` - parallel execution of `Aff`."
msgstr "`parallel` - `Aff`の並列実行。"

#. type: Plain text
#: text/chapter9.md:17
msgid ""
"When running outside of the browser (such as in our Node.js environment), "
"the `affjax` library requires the `xhr2` NPM module, which is listed as a "
"dependency in the `package.json` of this chapter. Install that by running:"
msgstr ""
"（Node.js環境のような）ブラウザ外で実行する場合、`affjax`ライブラリには"
"`xhr2`NPMモジュールが必要です。\n"
"このモジュールはこの章の`package.json`中の依存関係に挙げられています。\n"
"以下を走らせてインストールします。"

#. type: Fenced code block (shell)
#: text/chapter9.md:18
#, no-wrap
msgid "$ npm install\n"
msgstr "$ npm install\n"

#. type: Title ##
#: text/chapter9.md:22
#, no-wrap
msgid "Asynchronous JavaScript"
msgstr "非同期なJavaScript"

#. type: Plain text
#: text/chapter9.md:25
msgid ""
"A convenient way to work with asynchronous code in JavaScript is with "
"[`async` and `await`](https://developer.mozilla.org/en-US/docs/Learn/"
"JavaScript/Asynchronous/Async_await). See [this article on asynchronous "
"JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/"
"Asynchronous/Introducing) for more background information."
msgstr ""
"JavaScriptで非同期なコードに取り組む上で便利な手段は[`async`と`await`]"
"(https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/"
"Async_await)です。\n"
"[非同期なJavaScriptに関するこの記事](https://developer.mozilla.org/en-US/"
"docs/Learn/JavaScript/Asynchronous/Introducing)を見るとより背景情報がわかりま"
"す。"

#. type: Plain text
#: text/chapter9.md:27
msgid ""
"Here is an example of using this technique to copy the contents of one file "
"to another file:"
msgstr ""
"以下は、この技法を使ってあるファイルの内容を別のファイルに複製する例です。"

#. type: Fenced code block (js)
#: text/chapter9.md:28
#, no-wrap
msgid ""
"import { promises as fsPromises } from 'fs'\n"
"\n"
"async function copyFile(file1, file2) {\n"
"  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });\n"
"  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });\n"
"}\n"
"\n"
"copyFile('file1.txt', 'file2.txt')\n"
".catch(e => {\n"
"  console.log('There was a problem with copyFile: ' + e.message);\n"
"});\n"
msgstr ""
"import { promises as fsPromises } from 'fs'\n"
"\n"
"async function copyFile(file1, file2) {\n"
"  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });\n"
"  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });\n"
"}\n"
"\n"
"copyFile('file1.txt', 'file2.txt')\n"
".catch(e => {\n"
"  console.log('There was a problem with copyFile: ' + e.message);\n"
"});\n"

#. type: Plain text
#: text/chapter9.md:43
msgid ""
"It is also possible to use callbacks or synchronous functions, but those are "
"less desirable because:"
msgstr ""
"コールバックや同期関数を使うことも可能ですが、以下の理由から望ましくありませ"
"ん。"

#. type: Bullet: '- '
#: text/chapter9.md:46
msgid ""
"Callbacks lead to excessive nesting, known as \"Callback Hell\" or the "
"\"Pyramid of Doom\"."
msgstr ""
"コールバックは過剰な入れ子に繋がります。これは「コールバック地獄」や「悪夢の"
"ピラミッド」として知られています。"

#. type: Bullet: '- '
#: text/chapter9.md:46
msgid "Synchronous functions block execution of the other code in your app."
msgstr "同期関数はアプリ中の他のコードの実行を堰き止めてしまいます。"

#. type: Title ##
#: text/chapter9.md:47
#, no-wrap
msgid "Asynchronous PureScript"
msgstr "非同期なPureScript"

#. type: Plain text
#: text/chapter9.md:50
msgid ""
"The `Aff` monad in PureScript offers similar ergonomics of JavaScript's "
"`async`/`await` syntax. Here is the same `copyFile` example from before, but "
"rewritten in PureScript using `Aff`:"
msgstr ""
"PureScriptでの`Aff`モナドはJavaScriptの`async`/`await`構文に似た人間工学を供"
"します。以下は前と同じ`copyFile`の例ですが、`Aff`を使ってPureScriptで書き換え"
"られています。"

#. type: Fenced code block (hs)
#: text/chapter9.md:51
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/Copy.purs:copyFile}}\n"
msgstr "{{#include ../exercises/chapter9/test/Copy.purs:copyFile}}\n"

#. type: Plain text
#: text/chapter9.md:56
msgid ""
"Note that we have to use `launchAff_` to convert the `Aff` to `Effect` "
"because `main` must be `Effect Unit`."
msgstr ""
"なお、`main`は`Effect Unit`でなければならないので、`launchAff_`を使って`Aff`"
"から`Effect`へと変換せねばなりません。"

#. type: Plain text
#: text/chapter9.md:58
msgid ""
"It is also possible to re-write the above snippet using callbacks or "
"synchronous functions (for example, with `Node.FS.Async` and `Node.FS.Sync`, "
"respectively), but those share the same downsides as discussed earlier with "
"JavaScript, so that coding style is not recommended."
msgstr ""
"上のコード片をコールバックや同期関数を使って書き換えることも可能です（例えば"
"`Node.FS.Async`や`Node.FS.Sync`をそれぞれ使います）。\n"
"しかし、JavaScriptで前にお話ししたのと同じ短所がここでも通用するため、それら"
"のコーディング形式は推奨されません。"

#. type: Plain text
#: text/chapter9.md:60
msgid ""
"The syntax for working with `Aff` is very similar to working with `Effect`. "
"They are both monads and can therefore be written with do notation."
msgstr ""
"`Aff`を扱う文法は`Effect`を扱うものと大変似ています。\n"
"どちらもモナドですし、したがってdo記法で書けます。"

#. type: Plain text
#: text/chapter9.md:62
msgid ""
"For example, if we look at the signature of `readTextFile`, we see that it "
"returns the file contents as a `String` wrapped in `Aff`:"
msgstr ""
"例えば`readTextFile`のシグネチャを見れば、これがファイルの内容を`String`と"
"し、`Aff`に包んで返していることがわかります。"

#. type: Fenced code block (hs)
#: text/chapter9.md:63
#, no-wrap
msgid "readTextFile :: Encoding -> FilePath -> Aff String\n"
msgstr "readTextFile :: Encoding -> FilePath -> Aff String\n"

#. type: Plain text
#: text/chapter9.md:68
#, no-wrap
msgid "We can \"unwrap\" the returned string with a bind arrow (`<-`) in do notation:\n"
msgstr "do記法中では束縛矢印 (`<-`) で返却された文字列を「開封」できます。\n"

#. type: Fenced code block (hs)
#: text/chapter9.md:69
#, no-wrap
msgid "my_data <- readTextFile UTF8 file1\n"
msgstr "my_data <- readTextFile UTF8 file1\n"

#. type: Plain text
#: text/chapter9.md:74
msgid "Then pass it as the string argument to `writeTextFile`:"
msgstr "それから`writeTextFile`に文字列引数として渡します。"

#. type: Fenced code block (hs)
#: text/chapter9.md:75
#, no-wrap
msgid "writeTextFile :: Encoding -> FilePath -> String -> Aff Unit\n"
msgstr "writeTextFile :: Encoding -> FilePath -> String -> Aff Unit\n"

#. type: Plain text
#: text/chapter9.md:80
msgid ""
"The only other notable feature unique to `Aff` in the above example is "
"`attempt`, which captures errors or exceptions encountered while running "
"`Aff` code and stores them in an `Either`:"
msgstr ""
"上の例で他に目を引く`Aff`固有の特徴は`attempt`のみです。これは`Aff`のコードの"
"実行中に遭遇したエラーや例外を捕捉して`Either`内に保管するものです。"

#. type: Fenced code block (hs)
#: text/chapter9.md:81
#, no-wrap
msgid "attempt :: forall a. Aff a -> Aff (Either Error a)\n"
msgstr "attempt :: forall a. Aff a -> Aff (Either Error a)\n"

#. type: Plain text
#: text/chapter9.md:86
msgid ""
"You should hopefully be able to draw on your knowledge of concepts from "
"previous chapters and combine this with the new `Aff` patterns learned in "
"the above `copyFile` example to tackle the following exercises:"
msgstr ""
"読者ならきっと、前の章から概念の知識を引き出し、その知識と上の`copyFile`の例"
"で学んだ新しい`Aff`パターンを組み合わせることで、以下の演習に挑戦できるでしょ"
"う。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:90
msgid ""
"(Easy) Write a `concatenateFiles` function that concatenates two text files."
msgstr ""
"（簡単）2つのテキストファイルを連結する関数`concatenateFiles`を書いてくださ"
"い。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:92
msgid ""
"(Medium) Write a function `concatenateMany` to concatenate multiple text "
"files, given an array of input and output file names. _Hint_: use `traverse`."
msgstr ""
"（普通）複数のテキストファイルを連結する関数`concatenateMany`を書いてくださ"
"い。\n"
"入力ファイル名の配列と出力ファイル名が与えられます。\n"
"*手掛かり*：`traverse`を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:94
msgid ""
"(Medium) Write a function `countCharacters :: FilePath -> Aff (Either Error "
"Int)` that returns the number of characters in a file, or an error if one is "
"encountered."
msgstr ""
"（普通）ファイル中の文字数を返すか、エラーがあればそれを返す関数"
"`countCharacters :: FilePath -> Aff (Either Error Int)`を書いてください。"

#. type: Title ##
#: text/chapter9.md:95
#, no-wrap
msgid "Additional Aff Resources"
msgstr "更なるAffの資料"

#. type: Plain text
#: text/chapter9.md:98
msgid ""
"If you haven't already looked at the [official Aff guide](https://pursuit."
"purescript.org/packages/purescript-aff/), skim through that now. It's not a "
"direct prerequisite for completing the remaining exercises in this chapter, "
"but you may find it helpful to lookup some functions on Pursuit."
msgstr ""
"もしまだ[公式のAffの手引き](https://pursuit.purescript.org/packages/"
"purescript-aff/)を見ていなければ、今ざっと目を通してください。\n"
"この章の残りの演習を完了する上で事前に直接必要なことではありませんが、Pursuit"
"で何らかの関数を見付けだす助けになるかもしれません。"

#. type: Plain text
#: text/chapter9.md:100
msgid ""
"You're also welcome to consult these supplemental resources too, but again, "
"the exercises in this chapter don't depend on them:"
msgstr ""
"以下の補足資料についてもあたってみるとよいでしょう。しかし繰り返しになります"
"がこの章の演習はこれらの内容に依りません。"

#. type: Bullet: '- '
#: text/chapter9.md:103
msgid "[Drew's Aff Post](https://blog.drewolson.org/asynchronous-purescript)"
msgstr ""
"[DrewのAffに関する投稿](https://blog.drewolson.org/asynchronous-purescript)"

#. type: Bullet: '- '
#: text/chapter9.md:103
msgid ""
"[Additional Aff Explanation and Examples](https://github.com/JordanMartinez/"
"purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-"
"Aff/src/03-Aff)"
msgstr ""
"[更なるAffの説明と例](https://github.com/JordanMartinez/purescript-jordans-"
"reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff)"

#. type: Title ##
#: text/chapter9.md:104
#, no-wrap
msgid "A HTTP Client"
msgstr "HTTPクライアント"

#. type: Plain text
#: text/chapter9.md:107
msgid ""
"The `affjax` library offers a convenient way to make asynchronous AJAX HTTP "
"requests with `Aff`. Depending on what environment you are targeting, you "
"need to use either the [purescript-affjax-web](https://github.com/purescript-"
"contrib/purescript-affjax-web) or the [purescript-affjax-node](https://"
"github.com/purescript-contrib/purescript-affjax-node) library."
msgstr ""
"`affjax`ライブラリは`Aff`で非同期なAJAXのHTTP要求をする上での便利な手段を提供"
"します。\n"
"対象としている環境が何であるかによって、[purescript-affjax-web](https://"
"github.com/purescript-contrib/purescript-affjax-web)または[purescript-affjax-"
"node](https://github.com/purescript-contrib/purescript-affjax-node)のどちらか"
"のライブラリを使う必要があります。"

#. type: Plain text
#: text/chapter9.md:110
msgid ""
"In the rest of this chapter, we will be targeting node and thus using "
"`purescript-affjax-node`.  Consult the [Affjax docs](https://pursuit."
"purescript.org/packages/purescript-affjax) for more usage information. Here "
"is an example that makes HTTP GET requests at a provided URL and returns the "
"response body or an error message:"
msgstr ""
"この章の以降ではnodeを対象としていくので、`purescript-affjax-node`を使いま"
"す。\n"
"より詳しい使用上の情報は[affjaxのドキュメント](https://pursuit.purescript."
"org/packages/purescript-affjax)にあたってください。\n"
"以下は与えられたURLに向けてHTTPのGET要求をして、応答本文ないしエラー文言を返"
"す例です。"

#. type: Fenced code block (hs)
#: text/chapter9.md:111
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/HTTP.purs:getUrl}}\n"
msgstr "{{#include ../exercises/chapter9/test/HTTP.purs:getUrl}}\n"

#. type: Plain text
#: text/chapter9.md:116
msgid ""
"When calling this in the repl, `launchAff_` is required to convert the `Aff` "
"to a repl-compatible `Effect`:"
msgstr ""
"これをREPLで呼び出す際は、`launchAff_`で`Aff`からREPLに互換性のある`Effect`へ"
"と変換する必要があります。"

#. type: Fenced code block (shell)
#: text/chapter9.md:117
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :pa\n"
"… import Prelude\n"
"… import Effect.Aff (launchAff_)\n"
"… import Effect.Class.Console (log)\n"
"… import Test.HTTP (getUrl)\n"
"…\n"
"… launchAff_ do\n"
"…   str <- getUrl \"https://reqres.in/api/users/1\"\n"
"…   log str\n"
"…\n"
"unit\n"
"{\"data\":{\"id\":1,\"email\":\"george.bluth@reqres.in\",\"first_name\":\"George\",\"last_name\":\"Bluth\", ...}}\n"
msgstr ""
"$ spago repl\n"
"\n"
"> :pa\n"
"… import Prelude\n"
"… import Effect.Aff (launchAff_)\n"
"… import Effect.Class.Console (log)\n"
"… import Test.HTTP (getUrl)\n"
"…\n"
"… launchAff_ do\n"
"…   str <- getUrl \"https://reqres.in/api/users/1\"\n"
"…   log str\n"
"…\n"
"unit\n"
"{\"data\":{\"id\":1,\"email\":\"george.bluth@reqres.in\",\"first_name\":\"George\",\"last_name\":\"Bluth\", ...}}\n"

#. type: Bullet: '1. '
#: text/chapter9.md:137
msgid ""
"(Easy) Write a function `writeGet` which makes an HTTP `GET` request to a "
"provided url, and writes the response body to a file."
msgstr ""
"（簡単）与えられたURLにHTTPの`GET`を要求し、応答本文をファイルに書き込む関数"
"`writeGet`を書いてください。"

#. type: Title ##
#: text/chapter9.md:138
#, no-wrap
msgid "Parallel Computations"
msgstr "並列計算"

#. type: Plain text
#: text/chapter9.md:141
msgid ""
"We've seen how to use the `Aff` monad and do notation to compose "
"asynchronous computations in sequence. It would also be useful to be able to "
"compose asynchronous computations _in parallel_. With `Aff`, we can compute "
"in parallel simply by initiating our two computations one after the other."
msgstr ""
"`Aff`モナドとdo記法を使って、非同期計算を順番に実行されるように合成する方法を"
"見てきました。\n"
"非同期計算を*並列にも*合成できたら便利でしょう。\n"
"`Aff`があれば2つの計算を次々に開始するだけで並列に計算できます。"

#. type: Plain text
#: text/chapter9.md:143
msgid ""
"The `parallel` package defines a type class `Parallel` for monads like "
"`Aff`, which support parallel execution. When we met applicative functors "
"earlier in the book, we observed how applicative functors can be useful for "
"combining parallel computations. In fact, an instance for `Parallel` defines "
"a correspondence between a monad `m` (such as `Aff`) and an applicative "
"functor `f` that can be used to combine computations in parallel:"
msgstr ""
"`parallel`パッケージは`Aff`のようなモナドのための型クラス`Parallel`を定義して"
"おり、並列実行に対応しています。\n"
"以前に本書でアプリカティブ関手に出会ったとき、並列計算を合成するときにアプリ"
"カティブ関手がどれほど便利なのかを見ました。\n"
"実は`Parallel`のインスタンスは、（`Aff`のような）モナド`m`と、並列に計算を組"
"み合わせるために使えるアプリカティブ関手`f`との対応関係を定義しているのです。"

#. type: Fenced code block (hs)
#: text/chapter9.md:144
#, no-wrap
msgid ""
"class (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n"
"  sequential :: forall a. f a -> m a\n"
"  parallel :: forall a. m a -> f a\n"
msgstr ""
"class (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n"
"  sequential :: forall a. f a -> m a\n"
"  parallel :: forall a. m a -> f a\n"

#. type: Plain text
#: text/chapter9.md:151
msgid "The class defines two functions:"
msgstr "このクラスは2つの関数を定義しています。"

#. type: Bullet: '- '
#: text/chapter9.md:154
msgid ""
"`parallel`, which takes computations in the monad `m` and turns them into "
"computations in the applicative functor `f`, and"
msgstr ""
"`parallel`：モナド`m`中の計算を取り、アプリカティブ関手`f`中の計算に変えま"
"す。"

#. type: Bullet: '- '
#: text/chapter9.md:154
msgid "`sequential`, which performs a conversion in the opposite direction."
msgstr "`sequential`：反対方向に変換します。"

#. type: Plain text
#: text/chapter9.md:156
msgid ""
"The `aff` library provides a `Parallel` instance for the `Aff` monad. It "
"uses mutable references to combine `Aff` actions in parallel by keeping "
"track of which of the two continuations has been called. When both results "
"have been returned, we can compute the final result and pass it to the main "
"continuation."
msgstr ""
"`aff`ライブラリは`Aff`モナドの`Parallel`インスタンスを提供します。\n"
"これは、2つの継続のどちらが呼び出されたかを把握することによって、変更可能な参"
"照を使用して並列に`Aff`動作を組み合わせます。\n"
"両方の結果が返されたら、最終結果を計算してメインの継続に渡せます。"

#. type: Plain text
#: text/chapter9.md:158
msgid ""
"Because applicative functors support lifting of functions of arbitrary "
"arity, we can perform more computations in parallel by using the applicative "
"combinators. We can also benefit from all of the standard library functions "
"which work with applicative functors, such as `traverse` and `sequence`!"
msgstr ""
"アプリカティブ関手では任意個の引数の関数の持ち上げができるので、このアプリカ"
"ティブコンビネータを使ってより多くの計算を並列に実行できます。\n"
"`traverse`や`sequence`といった、アプリカティブ関手を扱う全ての標準ライブラリ"
"関数から恩恵を受けることもできます。"

#. type: Plain text
#: text/chapter9.md:160
msgid ""
"We can also combine parallel computations with sequential portions of code "
"by using applicative combinators in a do notation block, or vice versa, "
"using `parallel` and `sequential` to change type constructors where "
"appropriate."
msgstr ""
"直列的なコードの一部と並列計算を組み合わせることもできます。\n"
"それにはdo記法ブロック中でアプリカティブコンビネータを使います。\n"
"その逆も然りで、必要に応じて`parralel`と`sequential`を使って型構築子を変更す"
"れば良いのです。"

#. type: Plain text
#: text/chapter9.md:164
msgid ""
"To demonstrate the difference between sequential and parallel execution, "
"we'll create an array of 100 10-millisecond delays, then execute those "
"delays with both techniques.  You'll notice in the repl that `seqDelay` is "
"much slower than `parDelay`.  Note that parallel execution is enabled by "
"simply replacing `sequence_` with `parSequence_`."
msgstr ""
"直列実行と並列実行の間の違いを実演するために、100個の10ミリ秒の遅延からなる配"
"列をつくり、それからその遅延を両方の手法で実行します。REPLで試すと`seqDelay`"
"が`parDelay`より遥かに遅いことに気付くでしょう。並列実行が`sequence_`を"
"`parSequence_`で置き換えるだけで有効になるところに注目です。"

#. type: Fenced code block (hs)
#: text/chapter9.md:165
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelDelay.purs:delays}}\n"
msgstr "{{#include ../exercises/chapter9/test/ParallelDelay.purs:delays}}\n"

#. type: Fenced code block (shell)
#: text/chapter9.md:169
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelDelay\n"
"\n"
"> seqDelay -- This is slow\n"
"unit\n"
"\n"
"> parDelay -- This is fast\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.ParallelDelay\n"
"\n"
"> seqDelay -- This is slow\n"
"unit\n"
"\n"
"> parDelay -- This is fast\n"
"unit\n"

#. type: Plain text
#: text/chapter9.md:182
msgid ""
"Here's a more real-world example of making multiple HTTP requests in "
"parallel. We're reusing our `getUrl` function to fetch information from two "
"users in parallel. Note that `parTraverse` (the parallel version of "
"`traverse`) is used in this case. This example would also work fine with "
"`traverse` instead, but it will be slower."
msgstr ""
"以下は並列で複数回HTTP要求する、より現実味のある例です。\n"
"`getUrl`関数を再利用して2人の利用者から並列で情報を取得します。\n"
"この場合では`parTarverse`（`traverse`の並列版）が使われていますね。\n"
"この例は代わりに`traverse`でも問題なく動きますがより遅くなるでしょう。"

#. type: Fenced code block (hs)
#: text/chapter9.md:183
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelFetch.purs:fetchPar}}\n"
msgstr "{{#include ../exercises/chapter9/test/ParallelFetch.purs:fetchPar}}\n"

#. type: Fenced code block (shell)
#: text/chapter9.md:187
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelFetch\n"
"\n"
"> fetchPar\n"
"unit\n"
"[\"{\\\"data\\\":{\\\"id\\\":1,\\\"email\\\":\\\"george.bluth@reqres.in\\\", ... }\"\n"
",\"{\\\"data\\\":{\\\"id\\\":2,\\\"email\\\":\\\"janet.weaver@reqres.in\\\", ... }\"\n"
"]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.ParallelFetch\n"
"\n"
"> fetchPar\n"
"unit\n"
"[\"{\\\"data\\\":{\\\"id\\\":1,\\\"email\\\":\\\"george.bluth@reqres.in\\\", ... }\"\n"
",\"{\\\"data\\\":{\\\"id\\\":2,\\\"email\\\":\\\"janet.weaver@reqres.in\\\", ... }\"\n"
"]\n"

#. type: Plain text
#: text/chapter9.md:200
msgid ""
"A full listing of available parallel functions can be found in the "
"[`parallel` docs on Pursuit](https://pursuit.purescript.org/packages/"
"purescript-parallel/docs/Control.Parallel). The [aff docs section on "
"parallel](https://github.com/purescript-contrib/purescript-aff#parallel-"
"execution) also contains more examples."
msgstr ""
"利用できる並列関数の完全な一覧は[Pursuitの`parallel`のドキュメント](https://"
"pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel)に"
"あります。[parallelのaffのドキュメントの節](https://github.com/purescript-"
"contrib/purescript-aff#parallel-execution)にもより多くの例が含まれています。"

#. type: Bullet: '1. '
#: text/chapter9.md:204
msgid ""
"(Easy) Write a `concatenateManyParallel` function with the same signature as "
"the earlier `concatenateMany` function but reads all input files in parallel."
msgstr ""
"（簡単）前の`concatenateMany`関数と同じシグネチャを持つ"
"`concatenateManyParallel`関数を書いてください。\n"
"ただし全ての入力ファイルを並列に読むようにしてください。"

#. type: Bullet: '1. '
#: text/chapter9.md:208
msgid ""
"(Medium) Write a `getWithTimeout :: Number -> String -> Aff (Maybe String)` "
"function which makes an HTTP `GET` request at the provided URL and returns "
"either:"
msgstr ""
"（普通）与えられたURLへHTTP `GET`を要求して以下の何れかを返す"
"`getWithTimeout :: Number -> String -> Aff (Maybe String)`関数を書いてくださ"
"い。"

#. type: Bullet: '    - '
#: text/chapter9.md:208
msgid ""
"`Nothing`: if the request takes longer than the provided timeout (in "
"milliseconds)."
msgstr ""
"`Nothing`: 要求してから与えられた時間制限（ミリ秒単位）より長く掛かった場合。"

#. type: Bullet: '    - '
#: text/chapter9.md:208
msgid ""
"The string response: if the request succeeds before the timeout elapses."
msgstr "文字列の応答：時間制限を越える前に要求が成功した場合。"

#. type: Bullet: '1. '
#: text/chapter9.md:210
msgid ""
"(Difficult) Write a `recurseFiles` function that takes a \"root\" file and "
"returns an array of all paths listed in that file (and listed in the listed "
"files too). Read listed files in parallel. Paths are relative to the "
"directory of the file they appear in. _Hint:_ The `node-path` module has "
"some helpful functions for negotiating directories."
msgstr ""
"（難しい）「根」のファイルを取り、そのファイルの中の全てのパスの一覧（そして"
"一覧にあるファイルの中の一覧も）の配列を返す`recurseFiles`関数を書いてくださ"
"い。\n"
"一覧にあるファイルを並列に読んでください。\n"
"パスはそのファイルが現れたディレクトリから相対的なものです。\n"
"*手掛かり*：`node-path`モジュールにはディレクトリを扱う上で便利な関数がありま"
"す。"

#. type: Plain text
#: text/chapter9.md:212
msgid "For example, if starting from the following `root.txt` file:"
msgstr "例えば次のような`root.txt`ファイルから始まるとします。"

#. type: Fenced code block (shell)
#: text/chapter9.md:213
#, no-wrap
msgid ""
"$ cat root.txt\n"
"a.txt\n"
"b/a.txt\n"
"c/a/a.txt\n"
"\n"
"$ cat a.txt\n"
"b/b.txt\n"
"\n"
"$ cat b/b.txt\n"
"c/a.txt\n"
"\n"
"$ cat b/c/a.txt\n"
"\n"
"$ cat b/a.txt\n"
"\n"
"$ cat c/a/a.txt\n"
msgstr ""
"$ cat root.txt\n"
"a.txt\n"
"b/a.txt\n"
"c/a/a.txt\n"
"\n"
"$ cat a.txt\n"
"b/b.txt\n"
"\n"
"$ cat b/b.txt\n"
"c/a.txt\n"
"\n"
"$ cat b/c/a.txt\n"
"\n"
"$ cat b/a.txt\n"
"\n"
"$ cat c/a/a.txt\n"

#. type: Plain text
#: text/chapter9.md:233
msgid "The expected output is:"
msgstr "期待される出力は次の通り。"

#. type: Fenced code block (hs)
#: text/chapter9.md:234
#, no-wrap
msgid "[\"root.txt\",\"a.txt\",\"b/a.txt\",\"b/b.txt\",\"b/c/a.txt\",\"c/a/a.txt\"]\n"
msgstr "[\"root.txt\",\"a.txt\",\"b/a.txt\",\"b/b.txt\",\"b/c/a.txt\",\"c/a/a.txt\"]\n"

#. type: Plain text
#: text/chapter9.md:241
msgid "In this chapter, we covered asynchronous effects and learned how to:"
msgstr "この章では非同期作用と以下の方法を押さえました。"

#. type: Bullet: '- '
#: text/chapter9.md:244
msgid "Run asynchronous code in the `Aff` monad with the `aff` library."
msgstr "`aff`ライブラリを使って`Aff`モナド中で非同期コードを走らせる。"

#. type: Bullet: '- '
#: text/chapter9.md:244
msgid "Make HTTP requests asynchronously with the `affjax` library."
msgstr "`affjax`ライブラリを使って非同期にHTTPリクエストする。"

#. type: Bullet: '- '
#: text/chapter9.md:244
msgid "Run asynchronous code in parallel with the `parallel` library."
msgstr "`parallel`ライブラリを使って並列に非同期コードを走らせる。"

#~ msgid ""
#~ "PureScript's functions correspond to JavaScript's functions. The "
#~ "PureScript standard libraries provide plenty of examples of functions, "
#~ "and we will see more in this chapter:"
#~ msgstr ""
#~ "PureScriptの関数はJavaScriptの関数に対応しています。PureScriptの標準ライブ"
#~ "ラリは多くの関数の例を提供しており、この章ではそれらをもう少し詳しく見てい"
#~ "きます。"

#, no-wrap
#~ msgid ""
#~ "> import Prelude\n"
#~ "> :type flip\n"
#~ "forall a b c. (a -> b -> c) -> b -> a -> c\n"
#~ "\n"
#~ "> :type const\n"
#~ "forall a b. a -> b -> a\n"
#~ msgstr ""
#~ "> import Prelude\n"
#~ "> :type flip\n"
#~ "forall a b c. (a -> b -> c) -> b -> a -> c\n"
#~ "\n"
#~ "> :type const\n"
#~ "forall a b. a -> b -> a\n"

#~ msgid ""
#~ "In the previous section, we saw the types of some functions defined in "
#~ "the Prelude. For example, the `flip` function had the following type:"
#~ msgstr ""
#~ "前の節ではPreludeで定義された関数の型を幾つか見てきました。\n"
#~ "例えば`flip`関数は次のような型を持っていました。"

#, no-wrap
#~ msgid ""
#~ "> :type flip\n"
#~ "forall a b c. (a -> b -> c) -> b -> a -> c\n"
#~ msgstr ""
#~ "> :type flip\n"
#~ "forall a b c. (a -> b -> c) -> b -> a -> c\n"

#, no-wrap
#~ msgid "(Int -> String -> String) -> String -> Int -> String\n"
#~ msgstr "(Int -> String -> String) -> String -> Int -> String\n"

#, no-wrap
#~ msgid ""
#~ "> flip (\\n s -> show n <> s) \"Ten\" 10\n"
#~ "\n"
#~ "\"10Ten\"\n"
#~ msgstr ""
#~ "> flip (\\n s -> show n <> s) \"Ten\" 10\n"
#~ "\n"
#~ "\"10Ten\"\n"

#~ msgid ""
#~ "While we can choose any types for `a`, `b`, and `c`, we have to be "
#~ "consistent. The type of function passed to `flip` had to be consistent "
#~ "with the types of the other arguments. That is why we passed the string "
#~ "`\"Ten\"` as the second argument and the number `10` as the third. It "
#~ "would not work if the arguments were reversed:"
#~ msgstr ""
#~ "`a`、`b`、`c`の型はどんな型でも選べるといっても、一貫していなければなりま"
#~ "せん。\n"
#~ "`flip`に渡す関数の型は他の引数の型と整合性がなくてはなりません。\n"
#~ "第2引数として文字列`\"Ten\"`、第3引数として数`10`を渡したのはそれが理由で"
#~ "す。\n"
#~ "もし引数が逆になっているとうまくいかないでしょう。"

#, no-wrap
#~ msgid ""
#~ "> flip (\\n s -> show n <> s) 10 \"Ten\"\n"
#~ "\n"
#~ "Could not match type Int with type String\n"
#~ msgstr ""
#~ "> flip (\\n s -> show n <> s) 10 \"Ten\"\n"
#~ "\n"
#~ "Could not match type Int with type String\n"

#~ msgid ""
#~ "Note how the declarations for `foo` and `bar` are indented past the "
#~ "declaration of `example`."
#~ msgstr ""
#~ "ここで `foo`や `bar`の宣言は `example`の宣言より深く字下げされていることに"
#~ "注意してください。"

#~ msgid ""
#~ "The only exception to this rule is the `where` keyword in the initial "
#~ "`module` declaration at the top of a source file."
#~ msgstr ""
#~ "ただし、ソースファイルの先頭、最初の `module`宣言における予約語 `where`だ"
#~ "けは、この規則の唯一の例外になっています。"

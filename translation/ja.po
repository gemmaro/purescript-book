# 実例によるPureScript
# Copyright (c) 2014-2017 Phil Freeman.
# Copyright (C) 2015-2018 aratama.
# Copyright (C) 2022 gemmaro.
# This file is distributed under the same license as the original document.
#
# 改行は行毎に入れるようにします。
# つまり、文字数で区切ったり全く入れないようにしたりはしません。
# ただしGettextの折り返しのせいでマークアップが崩れる場合はその限りではありません。
#
# 強調は*で囲みます。
# 全角文字と_は相性が悪いからです。
# なお、原訳では強い強調**を使っていましたが、意味が異なってくるので弱い強調に直しました。
#
msgid ""
msgstr ""
"Project-Id-Version: com.github.gemmaro.purescript-book.v0.1.0\n"
"POT-Creation-Date: 2023-04-22 13:30+0900\n"
"PO-Revision-Date: 2023-05-03 11:52+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

# mdBookのSUMMARY.mdの文言なので訳す必要がありません。
#. type: Title #
#: text/SUMMARY.md:1
#, no-wrap
msgid "Summary"
msgstr "Summary"

#. type: Plain text
#: text/SUMMARY.md:4
msgid "[Foreword](../README.md)"
msgstr "[序文](index.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Introduction](chapter1.md)"
msgstr "[導入](chapter1.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Getting Started](chapter2.md)"
msgstr "[はじめよう](chapter2.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Functions and Records](chapter3.md)"
msgstr "[関数とレコード](chapter3.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Recursion, Maps And Folds](chapter4.md)"
msgstr "[再帰、マップ、畳み込み](chapter4.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Pattern Matching](chapter5.md)"
msgstr "[パターン照合](chapter5.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Type Classes](chapter6.md)"
msgstr "[型クラス](chapter6.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Applicative Validation](chapter7.md)"
msgstr "[アプリカティブによる検証](chapter7.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[The Effect Monad](chapter8.md)"
msgstr "[作用モナド](chapter8.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Asynchronous Effects](chapter9.md)"
msgstr "[非同期作用](chapter9.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[The Foreign Function Interface](chapter10.md)"
msgstr "[外部関数インターフェース](chapter10.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Monadic Adventures](chapter11.md)"
msgstr "[モナドな冒険](chapter11.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Canvas Graphics](chapter12.md)"
msgstr "[Canvasグラフィックス](chapter12.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Generative Testing](chapter13.md)"
msgstr "[テストの自動生成](chapter13.md)"

#. type: Bullet: '* '
#: text/SUMMARY.md:18
msgid "[Domain-Specific Languages](chapter14.md)"
msgstr "[領域特化言語](chapter14.md)"

#. type: Title #
#: README.md:1
#, no-wrap
msgid "PureScript by Example"
msgstr "実例によるPureScript"

#. type: Plain text
#: README.md:4
msgid ""
"This repository contains a [community fork](https://github.com/purescript-"
"contrib/purescript-book/) of _PureScript by Example_ by Phil Freeman, also "
"known as \"the PureScript book\". This version differs from the original in "
"that it has been updated so that the code and exercises work with up-to-date "
"versions of the compiler, libraries, and tools. Some chapters have also been "
"rewritten to showcase the latest features of the PureScript ecosystem."
msgstr ""
"このリポジトリには、Phil Freemanによる*PureScript by Example*の[コミュニティ"
"フォーク](https://github.com/purescript-contrib/purescript-book/)が含まれま"
"す。\n"
"同書は \"The PureScript book\" としても知られています。\n"
"このバージョンはコードと演習が最近のバージョンのコンパイラ、ライブラリ、ツー"
"ルで動くように更新されています。\n"
"PureScriptのエコシステムの最新の機能を紹介すべく書き直された章もあります。"

#. type: Plain text
#: README.md:6
msgid ""
"If you enjoyed the book or found it useful, please consider buying a copy of "
"[the original on Leanpub](https://leanpub.com/purescript)."
msgstr ""
"本書をお楽しみいただき、お役立ちいただけましたら、[Leanpubの原書](https://"
"leanpub.com/purescript)の購入をご検討ください。"

#. type: Title ##
#: README.md:7
#, no-wrap
msgid "Status"
msgstr "現状"

#. type: Plain text
#: README.md:10
msgid ""
"This book is being continuously updated as the language evolves, so please "
"report any [issues](https://github.com/purescript-contrib/purescript-book/"
"issues) you discover with the material. We appreciate any feedback you have "
"to share, even if it's as simple as pointing out a confusing section that we "
"could make more beginner-friendly."
msgstr ""
"この本は言語の進化に伴って継続的に更新されているため、内容に関して発見したど"
"んな[問題](https://github.com/purescript-contrib/purescript-book/issues)でも"
"ご報告ください。\n"
"より初心者にやさしくできそうな分かりづらい節を指摘するような単純なものであ"
"れ、共有いただいたどんなフィードバックにも感謝します。"

#. type: Plain text
#: README.md:12
msgid ""
"Unit tests are also being added to each chapter so you can check if your "
"answers to the exercises are correct. See [#79](https://github.com/"
"purescript-contrib/purescript-book/issues/79) for the latest status on tests."
msgstr ""
"それぞれの章には単体テストも加えられているので、演習への自分の回答が正しいか"
"どうか確かめることができます。\n"
"テストの最新の状態については[#79](https://github.com/purescript-contrib/"
"purescript-book/issues/79)を見てください。"

#. type: Title ##
#: README.md:13
#, no-wrap
msgid "About the Book"
msgstr "本書について"

#. type: Plain text
#: README.md:16
msgid ""
"PureScript is a small, strongly, statically typed programming language with "
"expressive types, written in and inspired by Haskell, and compiling to "
"Javascript."
msgstr ""
"PureScriptは、表現力のある型を持つ、小さくて強力で静的に型付けされたプログラ"
"ミング言語です。\n"
"Haskellで書かれ、またこの言語から着想を得ています。\n"
"そしてJavaScriptにコンパイルされます。"

#. type: Plain text
#: README.md:18
msgid ""
"Functional programming in JavaScript has seen quite a lot of popularity "
"recently, but large-scale application development is hindered by the lack of "
"a disciplined environment in which to write code. PureScript aims to solve "
"that problem by bringing the power of strongly-typed functional programming "
"to the world of JavaScript development."
msgstr ""
"JavaScriptでの関数型プログラミングは最近かなりの人気を誇るようになりました"
"が、コードを書く上で統制された環境が欠けていることが大規模なアプリケーション"
"開発の妨げとなっています。\n"
"PureScriptは、強力に型付けされた関数型プログラミングの力をJavaScriptでの開発"
"の世界に持ち込むことにより、この問題の解決を目指しています。"

#. type: Plain text
#: README.md:20
msgid ""
"This book will show you how to get started with the PureScript programming "
"language, from the basics (setting up a development environment) to the "
"advanced."
msgstr ""
"この本は、基礎（開発環境の立ち上げ）から応用に至るまでの、PureScriptプログラ"
"ミング言語の始め方を示します。"

#. type: Plain text
#: README.md:22
msgid ""
"Each chapter will be motivated by a particular problem, and in the course of "
"solving that problem, new functional programming tools and techniques will "
"be introduced. Here are some examples of problems that will be solved in "
"this book:"
msgstr ""
"それぞれの章は特定の課題により動機付けられており、その問題を解いていく過程に"
"おいて、新しい関数型プログラミングの道具と技法が導入されていきます。\n"
"以下はこの本で解いていく課題の幾つかの例です。"

#. type: Bullet: '- '
#: README.md:31
msgid "Transforming data structures with maps and folds"
msgstr "マップと畳み込みを使ったデータ構造の変換"

#. type: Bullet: '- '
#: README.md:31
msgid "Form field validation using applicative functors"
msgstr "アプリカティブ関手を使ったフォームフィールドの検証"

#. type: Bullet: '- '
#: README.md:31
msgid "Testing code with QuickCheck"
msgstr "QuickCheckによるコードの検査"

#. type: Bullet: '- '
#: README.md:31
msgid "Using the canvas"
msgstr "Canvasの使用"

#. type: Bullet: '- '
#: README.md:31
msgid "Domain specific language implementation"
msgstr "領域特化言語の実装"

#. type: Bullet: '- '
#: README.md:31
msgid "Working with the DOM"
msgstr "DOMの取り回し"

#. type: Bullet: '- '
#: README.md:31
msgid "JavaScript interoperability"
msgstr "JavaScriptの相互運用性"

#. type: Bullet: '- '
#: README.md:31
msgid "Parallel asynchronous execution"
msgstr "並列非同期実行"

#. type: Title ##
#: README.md:32
#, no-wrap
msgid "License"
msgstr "使用許諾"

#. type: Plain text
#: README.md:35
msgid "Copyright (c) 2014-2017 Phil Freeman."
msgstr "Copyright (c) 2014-2017 Phil Freeman."

#. type: Plain text
#: README.md:37
msgid ""
"The text of this book is licensed under the Creative Commons Attribution-"
"NonCommercial-ShareAlike 3.0 Unported License: <https://creativecommons.org/"
"licenses/by-nc-sa/3.0/deed.en_US>."
msgstr ""
"The text of this book is licensed under the Creative Commons Attribution-"
"NonCommercial-ShareAlike 3.0 Unported License: <https://creativecommons.org/"
"licenses/by-nc-sa/3.0/deed.en_US>.\n"
"\n"
"<small>※以降の原文の使用許諾に関する和訳は法的効力を持ちません。<br>\n"
"本書のテキストは<a href=\"https://creativecommons.org/licenses/by-nc-sa/3.0/"
"deed.ja\">表示 - 非営利 - 継承3.0非移植 (CC BY-NC-SA 3.0)</a>のもとに使用が許"
"諾される。</small>"

#. type: Plain text
#: README.md:39
msgid ""
"Some text is derived from the [PureScript Documentation Repo](https://github."
"com/purescript/documentation), which uses the same license, and is copyright "
"[various contributors](https://github.com/purescript/documentation/blob/"
"master/CONTRIBUTORS.md)."
msgstr ""
"Some text is derived from the [PureScript Documentation Repo](https://github."
"com/purescript/documentation), which uses the same license, and is copyright "
"[various contributors](https://github.com/purescript/documentation/blob/"
"master/CONTRIBUTORS.md).\n"
"\n"
"<small>幾つかのテキストは[PureScriptのドキュメントリポジトリ](https://github."
"com/purescript/documentation)から派生している。\n"
"派生元も同じ使用許諾であり、[様々な形で貢献された方々](https://github.com/"
"purescript/documentation/blob/master/CONTRIBUTORS.md)の著作権が含まれる。</"
"small>"

#. type: Plain text
#: README.md:40
msgid "The exercises are licensed under the MIT license."
msgstr ""
"The exercises are licensed under the MIT license.\n"
"\n"
"<small>演習はMITライセンスの下に使用が許諾される。</small>"

#. type: Title ##
#: text/chapter1.md:1 text/chapter4.md:23
#, no-wrap
msgid "Introduction"
msgstr "導入"

#. type: Title ##
#: text/chapter1.md:3
#, no-wrap
msgid "Functional JavaScript"
msgstr "関数型JavaScript"

#. type: Plain text
#: text/chapter1.md:6
msgid ""
"Functional programming techniques have been making appearances in JavaScript "
"for some time now:"
msgstr ""
"関数型プログラミングの手法がJavaScriptに姿を現しはじめてからしばらく経ちま"
"す。"

#. type: Bullet: '- '
#: text/chapter1.md:8
msgid ""
"Libraries such as [UnderscoreJS](https://underscorejs.org) allow the "
"developer to leverage tried-and-trusted functions such as `map`, `filter` "
"and `reduce` to create larger programs from smaller programs by composition:"
msgstr ""
"[UnderscoreJS](https://underscorejs.org)などのライブラリがあれば、開発者は"
"`map`や `filter`、`reduce`といった実績のある関数を活用して、小さいプログラム"
"を組み合わせることで大きなプログラムを作ることができます。"

#. type: Plain text
#: text/chapter1.md:18
#, no-wrap
msgid ""
"    ```javascript\n"
"    var sumOfPrimes =\n"
"        _.chain(_.range(1000))\n"
"         .filter(isPrime)\n"
"         .reduce(function(x, y) {\n"
"             return x + y;\n"
"         })\n"
"         .value();\n"
"    ```\n"
msgstr ""
"    ```javascript\n"
"    var sumOfPrimes =\n"
"        _.chain(_.range(1000))\n"
"         .filter(isPrime)\n"
"         .reduce(function(x, y) {\n"
"             return x + y;\n"
"         })\n"
"         .value();\n"
"    ```\n"

#. type: Bullet: '- '
#: text/chapter1.md:20
msgid ""
"Asynchronous programming in NodeJS leans heavily on functions as first-class "
"values to define callbacks."
msgstr ""
"NodeJSにおける非同期プログラミングでは、第一級の値としての関数をコールバック"
"を定義するために多用しています。"

#. type: Plain text
#: text/chapter1.md:23
#, no-wrap
msgid ""
"    ```javascript\n"
"    import { readFile, writeFile } from 'fs'\n"
msgstr ""
"    ```javascript\n"
"    import { readFile, writeFile } from 'fs'\n"

#. type: Plain text
#: text/chapter1.md:34
#, no-wrap
msgid ""
"    readFile(sourceFile, function (error, data) {\n"
"      if (!error) {\n"
"        writeFile(destFile, data, function (error) {\n"
"          if (!error) {\n"
"            console.log(\"File copied\");\n"
"          }\n"
"        });\n"
"      }\n"
"    });\n"
"    ```\n"
msgstr ""
"    readFile(sourceFile, function (error, data) {\n"
"      if (!error) {\n"
"        writeFile(destFile, data, function (error) {\n"
"          if (!error) {\n"
"            console.log(\"File copied\");\n"
"          }\n"
"        });\n"
"      }\n"
"    });\n"
"    ```\n"

#. type: Bullet: '- '
#: text/chapter1.md:36
msgid ""
"Libraries such as [React](https://reactjs.org) and [virtual-dom](https://"
"github.com/Matt-Esch/virtual-dom) model views as pure functions of "
"application state."
msgstr ""
"[React](https://reactjs.org)や[virtual-dom](https://github.com/Matt-Esch/"
"virtual-dom)などのライブラリは、アプリケーションの状態についての純粋な関数と"
"してその外観をモデル化しています"

#. type: Plain text
#: text/chapter1.md:38
msgid ""
"Functions enable a simple form of abstraction which can yield great "
"productivity gains. However, functional programming in JavaScript has its "
"own disadvantages: JavaScript is verbose, untyped, and lacks powerful forms "
"of abstraction. Unrestricted JavaScript code also makes equational reasoning "
"very difficult."
msgstr ""
"関数は単純な抽象化を可能にし、優れた生産性をもたらしてくれます。\n"
"しかし、JavaScriptでの関数型プログラミングには欠点があります。\n"
"JavaScriptは冗長で、型付けされず、強力な抽象化を欠いているのです。\n"
"また、無秩序に書かれたJavaScriptコードでは、等式推論がとても困難です。"

#. type: Plain text
#: text/chapter1.md:40
msgid ""
"PureScript is a programming language which aims to address these issues. It "
"features lightweight syntax, which allows us to write very expressive code "
"which is still clear and readable. It uses a rich type system to support "
"powerful abstractions. It also generates fast, understandable code, which is "
"important when interoperating with JavaScript, or other languages which "
"compile to JavaScript. All in all, I hope to convince you that PureScript "
"strikes a very practical balance between the theoretical power of purely "
"functional programming, and the fast-and-loose programming style of "
"JavaScript."
msgstr ""
"PureScriptはこのような問題を解決すべく作られたプログラミング言語です。\n"
"PureScriptは、とても表現力豊かでありながらわかりやすく読みやすいコードを書け"
"るようにする、軽量な構文を備えています。\n"
"強力な抽象化を提供する豊かな型システムも採用しています。\n"
"また、JavaScriptやJavaScriptへとコンパイルされる他の言語と相互運用するときに"
"重要な、高速で理解しやすいコードを生成します。\n"
"PureScriptを一言で言えば、純粋関数型プログラミングの理論的な強力さと、"
"JavaScriptのお手軽で緩いプログラミングスタイルとの、とても現実的なバランスを"
"狙った言語だということを理解して頂けたらと思います。"

#. type: Title ##
#: text/chapter1.md:41
#, no-wrap
msgid "Types and Type Inference"
msgstr "型と型推論"

#. type: Plain text
#: text/chapter1.md:44
msgid ""
"The debate over statically typed languages versus dynamically typed "
"languages is well-documented. PureScript is a _statically typed_ language, "
"meaning that a correct program can be given a _type_ by the compiler which "
"indicates its behavior. Conversely, programs which cannot be given a type "
"are _incorrect programs_, and will be rejected by the compiler. In "
"PureScript, unlike in dynamically typed languages, types exist only at "
"_compile-time_, and have no representation at runtime."
msgstr ""
"動的型付けの言語と静的型付けの言語をめぐる議論についてはよく知られています。"
"PureScriptは*静的型付け*の言語、つまり正しいプログラムはコンパイラによってそ"
"の動作を示すような*型*を与えられる言語です。逆にいえば、型を与えることができ"
"ないプログラムは _誤ったプログラム_ であり、コンパイラによって拒否されます。"
"動的型付けの言語とは異なり、PureScriptでは型は*コンパイル時*のみに存在し、実"
"行時には型の表現はありません。"

#. type: Plain text
#: text/chapter1.md:46
msgid ""
"It is important to note that in many ways, the types in PureScript are "
"unlike the types that you might have seen in other languages like Java or "
"C#. While they serve the same purpose at a high level, the types in "
"PureScript are inspired by languages like ML and Haskell. PureScript's types "
"are expressive, allowing the developer to assert strong claims about their "
"programs. Most importantly, PureScript's type system supports _type "
"inference_ - it requires far fewer explicit type annotations than other "
"languages, making the type system a _tool_ rather than a hindrance. As a "
"simple example, the following code defines a _number_, but there is no "
"mention of the `Number` type anywhere in the code:"
msgstr ""
"PureScriptの型は、これまでJavaやC#のような他の言語で見たような型とは、いろい"
"ろな意味で異なっていることにも注意することが大切です。\n"
"おおまかに言えばPureScriptの型はJavaやC#と同じ目的を持っているものの、"
"PureScriptの型はMLやHaskellのような言語に影響を受けています。\n"
"開発者がプログラムについての強い主張を表明できるので、PureScriptの型は表現力"
"豊かなのです。\n"
"最も重要なのは、PureScriptの型システムは*型推論*に対応していることです。\n"
"型推論があれば他の言語より遥かに少ない型注釈で済み、型システムを厄介者ではな"
"く*道具*にしてくれます。\n"
"簡単な例を示すと、次のコードは*数*を定義していますが、それが `Number`型だとい"
"う注釈はコードのどこにもありません。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:47
#, no-wrap
msgid ""
"iAmANumber =\n"
"  let square x = x * x\n"
"  in square 42.0\n"
msgstr ""
"iAmANumber =\n"
"  let square x = x * x\n"
"  in square 42.0\n"

#. type: Plain text
#: text/chapter1.md:54
msgid ""
"A more involved example shows that type-correctness can be confirmed without "
"type annotations, even when there exist types which are _unknown to the "
"compiler_:"
msgstr ""
"次のもっと複雑な例では、 _コンパイラにとって未知_ の型が存在しているときでさ"
"えも、型注釈なしで型の正しさを確かめることができるということが示されていま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:55
#, no-wrap
msgid ""
"iterate f 0 x = x\n"
"iterate f n x = iterate f (n - 1) (f x)\n"
msgstr ""
"iterate f 0 x = x\n"
"iterate f n x = iterate f (n - 1) (f x)\n"

#. type: Plain text
#: text/chapter1.md:61
msgid ""
"Here, the type of `x` is unknown, but the compiler can still verify that "
"`iterate` obeys the rules of the type system, no matter what type `x` might "
"have."
msgstr ""
"ここで `x`の型は不明ですが、`x`がどんな型を持っているかにかかわらず、"
"`iterate`が型システムの規則に従っていることをコンパイラは検証できます。"

#. type: Plain text
#: text/chapter1.md:63
msgid ""
"In this book, I will try to convince you (or reaffirm your belief) that "
"static types are not only a means of gaining confidence in the correctness "
"of your programs, but also an aid to development in their own right. "
"Refactoring a large body of code in JavaScript can be difficult when using "
"any but the simplest of abstractions, but an expressive type system together "
"with a type checker can even make refactoring into an enjoyable, interactive "
"experience."
msgstr ""
"本書で納得していただきたい（または既にお持ちの信条に寄り添って改めて断言した"
"い）ことは、静的型が単にプログラムの正しさに自信を持つためだけのものではな"
"く、それ自体の正しさによって開発の手助けになるものでもあるということです。"
"JavaScriptではごく単純な抽象化を施すのでも大規模なコードのリファクタリングを"
"することは難しいですが、型検証器のある表現力豊かな型システムは、リファクタリ"
"ングさえ楽しく対話的な体験にしてくれます。"

#. type: Plain text
#: text/chapter1.md:65
msgid ""
"In addition, the safety net provided by a type system enables more advanced "
"forms of abstraction. In fact, PureScript provides a powerful form of "
"abstraction which is fundamentally type-driven: type classes, made popular "
"in the functional programming language Haskell."
msgstr ""
"加えて、型システムによって提供されるこの安全網は、より高度な抽象化をも可能に"
"します。\n"
"実際に、関数型プログラミング言語Haskellによって知られるようになった、型駆動の"
"強力な抽象化の形式である『型クラス』をPureScriptは備えています。"

#. type: Title ##
#: text/chapter1.md:66
#, no-wrap
msgid "Polyglot Web Programming"
msgstr "多言語Webプログラミング"

#. type: Plain text
#: text/chapter1.md:69
msgid ""
"Functional programming has its success stories - applications where it has "
"been particularly successful: data analysis, parsing, compiler "
"implementation, generic programming, parallelism, to name a few."
msgstr ""
"関数型プログラミングは既に多くの成功を収めています。\n"
"枚挙に暇がありませんが、特に成功している応用例を幾つか挙げると、データ解析、"
"構文解析、コンパイラの実装、ジェネリックプログラミング、並列処理などがありま"
"す。"

#. type: Plain text
#: text/chapter1.md:71
msgid ""
"It would be possible to practice end-to-end application development in a "
"functional language like PureScript. PureScript provides the ability to "
"import existing JavaScript code, by providing types for its values and "
"functions, and then to use those functions in regular PureScript code. We'll "
"see this approach later in the book."
msgstr ""
"PureScriptのような関数型言語でアプリケーション開発の最初から最後までを実施で"
"きるでしょう。\n"
"値や関数の型を提供することで既存のJavaScriptコードをインポートし、通常の"
"PureScriptコードからこれらの関数を使用する機能をPureScriptは提供していま"
"す。\n"
"この手法については本書の後半で見ていくことになります。"

#. type: Plain text
#: text/chapter1.md:73
msgid ""
"However, one of PureScript's strengths is its interoperability with other "
"languages which target JavaScript. Another approach would be to use "
"PureScript for a subset of your application's development, and to use one or "
"more other languages to write the rest of the JavaScript."
msgstr ""
"しかし、PureScriptの強みの1つは、JavaScriptを対象とする他の言語との相互運用性"
"にあります。\n"
"アプリケーションの開発の一部にだけPureScriptを使用し、JavaScriptの残りの部分"
"を記述するのに他の言語を使用するという方法もあります。"

#. type: Plain text
#: text/chapter1.md:75
msgid "Here are some examples:"
msgstr "幾つかの例を示します。"

#. type: Bullet: '- '
#: text/chapter1.md:79
msgid ""
"Core logic written in PureScript, with the user interface written in "
"JavaScript."
msgstr ""
"中核となる処理はPureScriptで記述し、ユーザーインターフェイスはJavaScriptで記"
"述する"

#. type: Bullet: '- '
#: text/chapter1.md:79
msgid ""
"Application written in JavaScript or another compile-to-JS language, with "
"tests written in PureScript."
msgstr ""
"JavaScriptや、他のJavaScriptにコンパイルする言語でアプリケーションを書き、"
"PureScriptでそのテストを書く"

#. type: Bullet: '- '
#: text/chapter1.md:79
msgid ""
"PureScript used to automate user interface tests for an existing application."
msgstr "既存のアプリケーションのユーザインターフェースのテストを自動化するためにPureScriptを使用する"

#. type: Plain text
#: text/chapter1.md:81
msgid ""
"In this book, we'll focus on solving small problems with PureScript. The "
"solutions could be integrated into a larger application, but we will also "
"look at how to call PureScript code from JavaScript, and vice versa."
msgstr ""
"この本では小規模な課題をPureScriptで解決することに焦点を当てます。\n"
"ここで学ぶ手法は大規模なアプリケーションに組み込むこともできますが、"
"JavaScriptからPureScriptコードを呼び出す方法、及びその逆についても見ていきま"
"す。"

#. type: Title ##
#: text/chapter1.md:82
#, no-wrap
msgid "Prerequisites"
msgstr "ソフトウェア要件"

#. type: Plain text
#: text/chapter1.md:85
msgid ""
"The software requirements for this book are minimal: the first chapter will "
"guide you through setting up a development environment from scratch, and the "
"tools we will use are available in the standard repositories of most modern "
"operating systems."
msgstr ""
"この本でのソフトウェア要件は最小限です。\n"
"第1章では開発環境の構築を一から案内します。\n"
"これから使用するツールは、ほとんどの現代のオペレーティングシステムの標準リポ"
"ジトリで使用できるものです。"

#. type: Plain text
#: text/chapter1.md:87
msgid ""
"The PureScript compiler itself can be downloaded as a binary distribution, "
"or built from source on any system running an up-to-date installation of the "
"GHC Haskell compiler, and we will walk through this process in the next "
"chapter."
msgstr ""
"PureScriptコンパイラ自体はバイナリ形式でもダウンロードできますし、最新の"
"Haskellコンパイラが動くシステム上でソースからもビルドできます。\n"
"次の章ではこの手順を説明していきます。"

#. type: Plain text
#: text/chapter1.md:90
msgid ""
"The code in this version of the book is compatible with versions `0.15.*` of "
"the PureScript compiler."
msgstr ""
"本書のこのバージョンのコードは`0.15.*`バージョンのPureScriptコンパイラと互換"
"性があります。"

#. type: Title ##
#: text/chapter1.md:91
#, no-wrap
msgid "About You"
msgstr "読者について"

#. type: Plain text
#: text/chapter1.md:94
msgid ""
"I will assume that you are familiar with the basics of JavaScript. Any prior "
"familiarity with common tools from the JavaScript ecosystem, such as NPM and "
"Gulp, will be beneficial if you wish to customize the standard setup to your "
"own needs, but such knowledge is not necessary."
msgstr ""
"読者はJavaScriptの基本を既に理解しているものと仮定します。\n"
"既にNPMやBowerのようなJavaScriptのエコシステムでの経験があれば、自身の好みに"
"応じて標準設定をカスタマイズしたい場合などに役に立ちます。\n"
"ですがそのような知識は必要ありません。"

#. type: Plain text
#: text/chapter1.md:96
msgid ""
"No prior knowledge of functional programming is required, but it certainly "
"won't hurt. New ideas will be accompanied by practical examples, so you "
"should be able to form an intuition for the concepts from functional "
"programming that we will use."
msgstr ""
"関数型プログラミングの予備知識は必要ありませんが、あっても害にはならないで"
"しょう。\n"
"新しい考えかたは実例とともに登場するので、これから使う関数型プログラミングか"
"らこうした概念に対する直感的な理解を得ることができるはずです。"

#. type: Plain text
#: text/chapter1.md:98
msgid ""
"Readers who are familiar with the Haskell programming language will "
"recognize a lot of the ideas and syntax presented in this book, because "
"PureScript is heavily influenced by Haskell. However, those readers should "
"understand that there are a number of important differences between "
"PureScript and Haskell. It is not necessarily always appropriate to try to "
"apply ideas from one language in the other, although many of the concepts "
"presented here will have some interpretation in Haskell."
msgstr ""
"PureScriptはプログラミング言語Haskellに強く影響を受けているため、Haskellに通"
"じている読者はこの本の中で提示された概念や構文の多くに見覚えがあるでしょ"
"う。\n"
"しかし、読者はPureScriptとHaskellの間には幾らか重要な違いがあることも理解して"
"おかなければなりません。\n"
"ここで紹介する概念の多くはHaskellでも同じように解釈できるとはいえ、どちらかの"
"言語での考え方を他方の言語でそのまま応用しようとすることは、必ずしも適切では"
"ありません。"

#. type: Title ##
#: text/chapter1.md:99
#, no-wrap
msgid "How to Read This Book"
msgstr "本書の読み進めかた"

#. type: Plain text
#: text/chapter1.md:102
msgid ""
"The chapters in this book are largely self contained. A beginner with little "
"functional programming experience would be well-advised, however, to work "
"through the chapters in order. The first few chapters lay the groundwork "
"required to understand the material later on in the book. A reader who is "
"comfortable with the ideas of functional programming (especially one with "
"experience in a strongly-typed language like ML or Haskell) will probably be "
"able to gain a general understanding of the code in the later chapters of "
"the book without reading the preceding chapters."
msgstr ""
"本書の各章は、概ね章ごとに完結しています。\n"
"しかし、多少の関数型プログラミングの経験がある初心者でも、まずは各章を順番に進めていくことをお勧めします。\n"
"最初の数章では、本書の後半の内容を理解するために必要な基礎知識を養います。\n"
"関数型プログラミングの考え方に充分通じた読者（特にMLやHaskellのような強く型付けされた言語での経験を持つ読者）なら、本書の前半の章を読まなくても、後半の章のコードの大まかな理解を得ることが恐らく可能でしょう。"

#. type: Plain text
#: text/chapter1.md:104
msgid ""
"Each chapter will focus on a single practical example, providing the "
"motivation for any new ideas introduced. Code for each chapter are available "
"from the book's [GitHub repository](https://github.com/purescript-contrib/"
"purescript-book). Some chapters will include code snippets taken from the "
"chapter's source code, but for a full understanding, you should read the "
"source code from the repository alongside the material from the book. Longer "
"sections will contain shorter snippets which you can execute in the "
"interactive mode PSCi to test your understanding."
msgstr ""
"各章ではそれぞれ1つの実用的な例に焦点をあて、新しい考え方を導入するための動機"
"付けとして用います。各章のコードは本書の[GitHubのリポジトリ](https://github."
"com/purescript-contrib/purescript-book)から入手できます。ソースコードから抜粋"
"したコード片が掲載されている章もありますが、完全に理解するためには本書に掲載"
"されたコードと平行してリポジトリのソースコードを読む必要があります。対話式環"
"境PSCiで実行し理解を確かめられるように、長めの節には短いコード片が掲載されて"
"いることがあります。"

#. type: Plain text
#: text/chapter1.md:106
msgid "Code samples will appear in a monospaced font, as follows:"
msgstr "コード例は次のように等幅フォントで示されています。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:107
#, no-wrap
msgid ""
"module Example where\n"
"\n"
"import Effect.Console (log)\n"
"\n"
"main = log \"Hello, World!\"\n"
msgstr ""
"module Example where\n"
"\n"
"import Effect.Console (log)\n"
"\n"
"main = log \"Hello, World!\"\n"

#. type: Plain text
#: text/chapter1.md:116
msgid ""
"Commands which should be typed at the command line will be preceded by a "
"dollar symbol:"
msgstr "先頭にドル記号がついた行は、コマンドラインに入力されたコマンドです。"

#. type: Fenced code block (text)
#: text/chapter1.md:117 text/chapter3.md:313
#, no-wrap
msgid "$ spago build\n"
msgstr "$ spago build\n"

#. type: Plain text
#: text/chapter1.md:122
msgid ""
"Usually, these commands will be tailored to Linux/Mac OS users, so Windows "
"users may need to make small changes such as modifying the file separator, "
"or replacing shell built-ins with their Windows equivalents."
msgstr ""
"通常、これらのコマンドはLinuxやMac OSの利用者ならそのまま適用できますが、"
"Windowsの利用者はファイル区切り文字を変更する、シェルの組み込み機能をWindows"
"の相当するものに置き換えるなどの小さな変更を加える必要があるかもしれません。"

#. type: Plain text
#: text/chapter1.md:124
msgid ""
"Commands which should be typed at the PSCi interactive mode prompt will be "
"preceded by an angle bracket:"
msgstr ""
"PSCi対話式モードプロンプトに入力するコマンドは、行の先頭に山括弧が付けられて"
"います。"

#. type: Fenced code block (text)
#: text/chapter1.md:125
#, no-wrap
msgid ""
"> 1 + 2\n"
"3\n"
msgstr ""
"> 1 + 2\n"
"3\n"

#. type: Plain text
#: text/chapter1.md:131
msgid ""
"Each chapter will contain exercises, labelled with their difficulty level. "
"It is strongly recommended that you attempt the exercises in each chapter to "
"fully understand the material."
msgstr ""
"各章には演習が付いており、それぞれ難易度も示されています。各章の内容を完全に"
"理解するために、演習に取り組むことを強くお勧めします。"

#. type: Plain text
#: text/chapter1.md:133
msgid ""
"This book aims to provide an introduction to the PureScript language for "
"beginners, but it is not the sort of book that provides a list of template "
"solutions to problems. For beginners, this book should be a fun challenge, "
"and you will get the most benefit if you read the material, attempt the "
"exercises, and most importantly of all, try to write some code of your own."
msgstr ""
"この本は初心者にPureScriptへの導入を提供することを目的としており、問題につい"
"てのお決まりの解決策の一覧を提供するような種類の本ではありません。初心者に"
"とってこの本を読むのは楽しい挑戦になるはずですし、本書の内容を読み演習に挑戦"
"すればだいたいの利益を得られるでしょうが、なにより重要なのは、あなたが自分自"
"身のコードを書いてみることです。"

#. type: Title ##
#: text/chapter1.md:134
#, no-wrap
msgid "Getting Help"
msgstr "困ったときには"

#. type: Plain text
#: text/chapter1.md:137
msgid ""
"If you get stuck at any point, there are a number of resources available "
"online for learning PureScript:"
msgstr ""
"もしどこかでつまずいたときには、PureScriptを学べるオンラインで利用可能な資料"
"が沢山あります。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"The [PureScript Discord server](https://discord.gg/vKn9up84bp) is a great "
"place to chat about issues you may be having. The server is dedicated to "
"chat about PureScript"
msgstr ""
"[PureScriptのDiscordサーバ](https://discord.gg/vKn9up84bp)は抱えている問題に"
"ついてチャットするのに良い場所です。\n"
"サーバはPureScriptについてのチャット専用です。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"The [Purescript Discourse Forum](https://discourse.purescript.org/) is "
"another good place to search for solutions to common problems. Questions you "
"ask here will be available to help future readers, whereas on Slack, message "
"history is only kept for approximately 2 weeks."
msgstr ""
"[PurescriptのDiscourseフォーラム](https://discourse.purescript.org/)もよくあ"
"る問題への解決策を探すのに良い場所です。メッセージ履歴が約2週間しか保たない"
"Slackとは違い、ここで質問した内容は将来の読者の助けとして使えるでしょう。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"[PureScript: Jordan's Reference](https://github.com/jordanmartinez/"
"purescript-jordans-reference)  is an alternative learning resource that goes "
"into great depth. If a concept in this book is difficult to understand, "
"consider reading the corresponding section in that reference."
msgstr ""
"[PureScript: Jordan's Reference](https://github.com/jordanmartinez/"
"purescript-jordans-reference)は別のかなり深く踏み込んだ学習資料です。\n"
"この本の中のある概念が理解しにくかったら、そちらの参考書の対応する節を読むと"
"よいでしょう。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"[Pursuit](https://pursuit.purescript.org) is a searchable database of "
"PureScript types and functions. Read Pursuit's help page to [learn what "
"kinds of searches you can do](https://pursuit.purescript.org/help/users)."
msgstr ""
"[Pursuit](https://pursuit.purescript.org)はPureScriptの型と関数を検索できる"
"データベースです。\n"
"Pursuitのヘルプページを読むと[どのような種類の検索ができるのかがわかります]"
"(https://pursuit.purescript.org/help/users)。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"The unofficial [PureScript Cookbook](https://github.com/JordanMartinez/"
"purescript-cookbook) provides answers via code to \"How do I do X?\"-type "
"questions."
msgstr ""
"非公式の[PureScript Cookbook](https://github.com/JordanMartinez/purescript-"
"cookbook)は「Xするにはどうするの」といった類の質問にコードを混じえて答えを提"
"供します。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"The [PureScript documentation repository](https://github.com/purescript/"
"documentation) collects articles and examples on a wide variety of topics, "
"written by PureScript developers and users."
msgstr ""
"[PureScriptドキュメントリポジトリ](https://github.com/purescript/"
"documentation)には、PureScriptの開発者や利用者が書いた幅広い話題の記事と例が"
"集まっています。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"The [PureScript website](https://www.purescript.org) contains links to "
"several learning resources, including code samples, videos and other "
"resources for beginners."
msgstr ""
"[PureScriptのWebサイト](https://www.purescript.org)には、コード例、映像、他の"
"初心者向け資料を含む幾つかの学習資料へのリンクがあります。"

#. type: Bullet: '- '
#: text/chapter1.md:146
msgid ""
"[Try PureScript!](https://try.purescript.org) is a website which allows "
"users to compile PureScript code in the web browser, and contains several "
"simple examples of code."
msgstr ""
"[Try PureScript!](https://try.purescript.org)は利用者がWebブラウザで"
"PureScriptのコードをコンパイルできるWebサイトです。\n"
"幾つかの簡単なコードの例があります。"

#. type: Plain text
#: text/chapter1.md:148
msgid ""
"If you prefer to learn by reading examples, the `purescript`, `purescript-"
"node` and `purescript-contrib` GitHub organizations contain plenty of "
"examples of PureScript code."
msgstr ""
"もし例を読んで学ぶ方が好きでしたら、GitHubの `purescript`組織、`purescript-"
"node`組織及び`purescript-contrib`組織にはPureScriptコードの例が沢山あります。"

#. type: Title ##
#: text/chapter1.md:149
#, no-wrap
msgid "About the Author"
msgstr "著者について"

#. type: Plain text
#: text/chapter1.md:152
msgid ""
"I am the original developer of the PureScript compiler. I'm based in Los "
"Angeles, California, and started programming at an early age in BASIC on an "
"8-bit personal computer, the Amstrad CPC. Since then I have worked "
"professionally in a variety of programming languages (including Java, Scala, "
"C#, F#, Haskell and PureScript)."
msgstr ""
"私はPureScriptコンパイラの最初の開発者です。私はカリフォルニア州ロサンゼルス"
"を拠点にしており、8ビットパーソナルコンピュータ、Amstrad CPC上のBASICでまだ幼"
"い時にプログラミングを始めました。\n"
"それ以来、私は幾つものプログラミング言語（JavaやScala、C#、F#、Haskell、そし"
"てPureScript）で業務に携わってきました。"

#. type: Plain text
#: text/chapter1.md:154
msgid ""
"Not long into my professional career, I began to appreciate functional "
"programming and its connections with mathematics, and enjoyed learning "
"functional concepts using the Haskell programming language."
msgstr ""
"プロとしての経歴が始まって間もなく、私は関数型プログラミングと数学の関係を理"
"解するようになり、そしてプログラミング言語Haskellを使って関数型の概念の学習を"
"楽しみました。"

#. type: Plain text
#: text/chapter1.md:156
msgid ""
"I started working on the PureScript compiler in response to my experience "
"with JavaScript. I found myself using functional programming techniques that "
"I had picked up in languages like Haskell, but wanted a more principled "
"environment in which to apply them. Solutions at the time included various "
"attempts to compile Haskell to JavaScript while preserving its semantics "
"(Fay, Haste, GHCJS), but I was interested to see how successful I could be "
"by approaching the problem from the other side - attempting to keep the "
"semantics of JavaScript, while enjoying the syntax and type system of a "
"language like Haskell."
msgstr ""
"JavaScriptでの経験をもとに、私はPureScriptコンパイラの開発を始めることにしま"
"した。\n"
"気が付くとHaskellのような言語から取り上げた関数型プログラミングの手法を使って"
"いましたが、それを応用するためのもっと理に適った環境を求めていました。\n"
"そのとき検討した案のなかには、Haskellからその意味論を維持しながらJavaScriptへ"
"とコンパイルするいろいろな試み（Fay、Haste、GHCJS）もありました。\n"
"しかし私が興味を持っていたのはこの問題への別の切り口からのアプローチ、すなわ"
"ちHaskellのような言語の構文と型システムを楽しみながらJavaScriptの意味論も維持"
"するということが、どのようにすれば可能になるのかでした。"

#. type: Plain text
#: text/chapter1.md:158
msgid ""
"I maintain [a blog](https://blog.functorial.com), and can be [reached on "
"Twitter](https://twitter.com/paf31)."
msgstr ""
"私は[ブログ](http://blog.functorial.com)を運営しており、[Twitterで連絡をとる]"
"(http://twitter.com/paf31)こともできます。"

#. type: Title ##
#: text/chapter1.md:159
#, no-wrap
msgid "Acknowledgements"
msgstr "謝辞"

#. type: Plain text
#: text/chapter1.md:162
msgid ""
"I would like to thank the many contributors who helped PureScript to reach "
"its current state. Without the huge collective effort which has been made on "
"the compiler, tools, libraries, documentation and tests, the project would "
"certainly have failed."
msgstr ""
"現在の状態に到達するまでPureScriptを手伝ってくれた多くの協力者に感謝したいと"
"思います。コンパイラやツール、ライブラリ、ドキュメント、テストでの組織的で弛"
"まぬ努力がなかったら、プロジェクトは間違いなく失敗していたことでしょう。"

#. type: Plain text
#: text/chapter1.md:164
msgid ""
"The PureScript logo which appears on the cover of this book was created by "
"Gareth Hughes, and is gratefully reused here under the terms of the "
"[Creative Commons Attribution 4.0 license](https://creativecommons.org/"
"licenses/by/4.0/)."
msgstr ""
"この本の表紙に表示されたPureScriptのロゴはGareth Hughesによって作成されたもの"
"で、[Creative Commons Attribution 4.0 license](https://creativecommons.org/"
"licenses/by/4.0/)の条件の下で再利用させて頂いています 。"

#. type: Plain text
#: text/chapter1.md:165
msgid ""
"Finally, I would like to thank everyone who has given me feedback and "
"corrections on the contents of this book."
msgstr ""
"最後に、この本の内容に関する反応や訂正をくださった全ての方に、心より感謝した"
"いと思います。"

#. type: Title #
#: text/chapter10.md:1
#, no-wrap
msgid "The Foreign Function Interface"
msgstr "外部関数インターフェース"

#. type: Title ##
#: text/chapter10.md:3 text/chapter11.md:3 text/chapter12.md:3
#: text/chapter13.md:3 text/chapter14.md:3 text/chapter2.md:3
#: text/chapter3.md:3 text/chapter4.md:3 text/chapter5.md:3 text/chapter6.md:3
#: text/chapter7.md:3 text/chapter8.md:3 text/chapter9.md:3
#, no-wrap
msgid "Chapter Goals"
msgstr "この章の目標"

#. type: Plain text
#: text/chapter10.md:6
msgid ""
"This chapter will introduce PureScript's _foreign function interface_ (or "
"_FFI_), which enables communication from PureScript code to JavaScript code, "
"and vice versa. We will cover how to:"
msgstr ""
"この章でPureScriptの _外部関数インターフェース_ (foreign function interface; "
"_FFI_) を紹介します。\n"
"これによりPureScriptコードからJavaScriptコードへの呼び出し、及びその逆が可能"
"になります。\n"
"これから扱うのは次のようなものです。"

#. type: Bullet: '- '
#: text/chapter10.md:10
msgid ""
"Call pure, effectful, and asynchronous JavaScript functions from PureScript."
msgstr "純粋で、作用のある、非同期なJavaScript関数をPureScriptから呼び出す。"

#. type: Bullet: '- '
#: text/chapter10.md:10
msgid "Work with untyped data."
msgstr "型付けされていないデータを扱う。"

#. type: Bullet: '- '
#: text/chapter10.md:10
msgid "Encode and parse JSON using the `argonaut` package."
msgstr ""
"`argonaut`パッケージを使ってJSONに符号化したりJSONを構文解析したりする。"

#. type: Plain text
#: text/chapter10.md:12
msgid ""
"Towards the end of this chapter, we will revisit our recurring address book "
"example. The goal of the chapter will be to add the following new "
"functionality to our application using the FFI:"
msgstr ""
"この章の終わりにかけて、住所録の例に立ち返ります。\n"
"この章の目的は、FFIを使ってアプリケーションに次の新しい機能を追加することで"
"す。"

#. type: Bullet: '- '
#: text/chapter10.md:15
msgid "Alert the user with a popup notification."
msgstr "利用者にポップアップ通知で警告する。"

#. type: Bullet: '- '
#: text/chapter10.md:15
msgid ""
"Store the serialized form data in the browser's local storage, and reload it "
"when the application restarts."
msgstr ""
"フォームのデータを直列化してブラウザのローカルストレージに保存し、アプリケー"
"ションが再起動したときにそれを再読み込みする"

#. type: Plain text
#: text/chapter10.md:17
msgid ""
"There is also an addendum which covers some additional topics which are not "
"as commonly sought-after. Feel free to read these sections, but don't let "
"them stand in the way of progressing through the remainder of the book if "
"they're less relevant to your learning objectives:"
msgstr ""
"さらに一般にはそこまで重用されない幾つかの話題を押さえた補遺もあります。\n"
"ご自由にこれらの節を読んで構いませんが、学習目標にあまり関係しなければ、本の"
"残りを読み進める妨げにならないようにしてください。"

#. type: Bullet: '- '
#: text/chapter10.md:20
msgid "Understand the representation of PureScript values at runtime."
msgstr "実行時のPureScriptの値の表現を理解する。"

#. type: Bullet: '- '
#: text/chapter10.md:20
msgid "Call PureScript functions from JavaScript."
msgstr "JavaScriptからPureScriptを呼び出す。"

#. type: Title ##
#: text/chapter10.md:21 text/chapter11.md:7 text/chapter12.md:7
#: text/chapter13.md:9 text/chapter14.md:16 text/chapter3.md:11
#: text/chapter4.md:11 text/chapter5.md:13 text/chapter6.md:13
#: text/chapter7.md:11 text/chapter8.md:9 text/chapter9.md:7
#, no-wrap
msgid "Project Setup"
msgstr "プロジェクトの準備"

#. type: Plain text
#: text/chapter10.md:24
msgid ""
"The source code for this module is a continuation of the source code from "
"chapters 3, 7 and 8. As such, the source tree includes the appropriate "
"source files from those chapters."
msgstr ""
"このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。そうし"
"たわけでソースツリーにはこれらの章からの適切なソースファイルが含まれていま"
"す。"

#. type: Plain text
#: text/chapter10.md:26
msgid ""
"This chapter introduces the `argonaut` library as a dependency. This library "
"is used for encoding and decoding JSON."
msgstr ""
"この章は`argonaut`ライブラリを依存関係として導入しています。\n"
"このライブラリはJSONに符号化したりJSONを復号化したりするために使います。"

#. type: Plain text
#: text/chapter10.md:28
msgid ""
"The exercises for this chapter should be written in `test/MySolutions.purs` "
"and can be checked against the unit tests in `test/Main.purs` by running "
"`spago test`."
msgstr ""
"この章の演習は`test/MySolutions.purs`に書き、`spago test`を走らせることによっ"
"て`test/Main.purs`中の単体試験について確認できます。"

#. type: Plain text
#: text/chapter10.md:30
msgid ""
"The Address Book app can be launched with `parcel src/index.html --open`. It "
"uses the same workflow from Chapter 8, so refer to that chapter for more "
"detailed instructions."
msgstr ""
"住所録アプリは`parcel src/index.html --open`で立ち上げることができます。8章と"
"同じ作業の流れになっているので、より詳しい説明についてはそちらの章を参照して"
"ください。"

#. type: Title ##
#: text/chapter10.md:31
#, no-wrap
msgid "A Disclaimer"
msgstr "免責事項"

#. type: Plain text
#: text/chapter10.md:34
msgid ""
"PureScript provides a straightforward foreign function interface to make "
"working with JavaScript as simple as possible. However, it should be noted "
"that the FFI is an _advanced_ feature of the language. To use it safely and "
"effectively, you should have an understanding of the runtime representation "
"of the data you plan to work with. This chapter aims to impart such an "
"understanding as pertains to code in PureScript's standard libraries."
msgstr ""
"JavaScriptを扱う作業をできる限り簡単にするため、PureScriptは直感的な外部関数インターフェースを提供しています。\n"
"しかし、FFIはPureScriptの*応用的な*機能であることには留意していただきたいと思います。\n"
"FFIを安全かつ効率的に使用するには、扱うつもりであるデータの実行時の表現についてよく理解していなければなりません。\n"
"この章では、PureScriptの標準ライブラリのコードに付いて回るそのような理解を伝授することを目指します。"

#. type: Plain text
#: text/chapter10.md:36
msgid ""
"PureScript's FFI is designed to be very flexible. In practice, this means "
"that developers have a choice, between giving their foreign functions very "
"simple types, or using the type system to protect against accidental misuses "
"of foreign code. Code in the standard libraries tends to favor the latter "
"approach."
msgstr ""
"PureScriptのFFIはとても柔軟に設計されています。\n"
"実際には、外部関数に最低限の型だけを与えるか、それとも型システムを利用して外"
"部のコードの誤った使い方を防ぐようにするか、開発者が選べるということを意味し"
"ています。\n"
"標準ライブラリのコードは、後者の手法を好む傾向にあります。"

#. type: Plain text
#: text/chapter10.md:38
msgid ""
"As a simple example, a JavaScript function makes no guarantees that its "
"return value will not be `null`. Indeed, idiomatic JavaScript code returns "
"`null` quite frequently! However, PureScript's types are usually not "
"inhabited by a null value. Therefore, it is the responsibility of the "
"developer to handle these corner cases appropriately when designing their "
"interfaces to JavaScript code using the FFI."
msgstr ""
"簡単な例としては、JavaScriptの関数で戻り値が `null`にならないことは保証できま"
"せん。\n"
"実のところ、JavaScriptらしさのあるコードはかなり頻繁に `null`を返します。\n"
"しかし、大抵PureScriptの型にnull値が巣喰うことはありません。\n"
"そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するとき、これら"
"の特殊な場合を適切に処理するのは開発者の責任です。"

#. type: Title ##
#: text/chapter10.md:39
#, no-wrap
msgid "Calling JavaScript From PureScript"
msgstr "PureScriptからJavaScriptを呼び出す"

#. type: Plain text
#: text/chapter10.md:42
msgid ""
"The simplest way to use JavaScript code from PureScript is to give a type to "
"an existing JavaScript value using a _foreign import_ declaration. Foreign "
"import declarations must have a corresponding JavaScript declaration "
"_exported_ from a _foreign JavaScript module_."
msgstr ""
"PureScriptからJavaScriptコードを使用する最も簡単な方法は、 _外部インポート宣"
"言_ (foreign import declaration) を使用し、既存のJavaScriptの値に型を与えるこ"
"とです。\n"
"外部インポート宣言には _外部JavaScriptモジュール_ (foreign JavaScript "
"module) から _エクスポートされた_ 対応するJavaScriptでの宣言がなくてはなりま"
"せん。"

#. type: Plain text
#: text/chapter10.md:44
msgid ""
"For example, consider the `encodeURIComponent` function, which can be used "
"in JavaScript to encode a component of a URI by escaping special characters:"
msgstr ""
"例えば特殊文字をエスケープすることによりURIのコンポーネントを符号化する"
"JavaScriptの `encodeURIComponent`関数について考えてみます。"

#. type: Fenced code block (text)
#: text/chapter10.md:45
#, no-wrap
msgid ""
"$ node\n"
"\n"
"node> encodeURIComponent('Hello World')\n"
"'Hello%20World'\n"
msgstr ""
"$ node\n"
"\n"
"node> encodeURIComponent('Hello World')\n"
"'Hello%20World'\n"

#. type: Plain text
#: text/chapter10.md:53
#, no-wrap
msgid "This function has the correct runtime representation for the function type `String -> String`, since it takes non-null strings to non-null strings, and has no other side-effects.\n"
msgstr "`null`でない文字列から `null`でない文字列への関数であり、副作用を持っていないので、この関数は型 `String -> String`について適切な実行時表現を持っています。\n"

#. type: Plain text
#: text/chapter10.md:55
msgid ""
"We can assign this type to the function with the following foreign import "
"declaration:"
msgstr ""
"次のような外部インポート宣言を使うと、この関数に型を割り当てることができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:56
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.purs}}\n"
msgstr "{{#include ../exercises/chapter10/test/URI.purs}}\n"

#. type: Plain text
#: text/chapter10.md:62
msgid ""
"We also need to write a foreign JavaScript module to import it from. A "
"corresponding foreign JavaScript module is one of the same name but "
"extension changed from `.purs` to `.js`. If the Purescript module above is "
"saved as `URI.purs`, then the foreign JavaScript module is saved as `URI."
"js`.  Since `encodeURIComponent` is already defined, we have to export it as "
"`_encodeURIComponent`:"
msgstr ""
"インポートしてくるための外部JavaScriptモジュールを書く必要もあります。\n"
"対応する外部JavaScriptモジュールは、同名で拡張子が`.purs`から`.js`に変わった"
"ものです。\n"
"上のPureScriptモジュールが`URI.purs`として保存されているなら、外部JavaScript"
"モジュールを`URI.js`として保存します。\n"
"`encodeURIComponent`は既に定義されているので、`_encodeURIComponent`としてエク"
"スポートせねばなりません。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:63
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.js}}\n"
msgstr "{{#include ../exercises/chapter10/test/URI.js}}\n"

#. type: Plain text
#: text/chapter10.md:68
msgid ""
"Since version 0.15, Purescript uses the ES module system when interoperating "
"with JavaScript. In ES modules, functions and values are exported from a "
"module by providing the `export` keyword on an object."
msgstr ""
"バージョン0.15からPureScriptはJavaScriptと通訳する際にESモジュールシステムを"
"使います。\n"
"ESモジュールではオブジェクトに`export`キーワードを与えることで関数と値がモ"
"ジュールからエクスポートされます。"

#. type: Plain text
#: text/chapter10.md:70
msgid ""
"With these two pieces in place, we can now use the `_encodeURIComponent` "
"function from PureScript like any function written in PureScript. For "
"example, in PSCi, we can reproduce the calculation above:"
msgstr ""
"これら2つの部品を使うことで、PureScriptで書かれた関数のように、PureScriptから"
"`encodeURIComponent`関数を使うことができます。\n"
"例えばPSCiで上記の計算を再現できます。"

#. type: Fenced code block (text)
#: text/chapter10.md:71
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.URI\n"
"> _encodeURIComponent \"Hello World\"\n"
"\"Hello%20World\"\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.URI\n"
"> _encodeURIComponent \"Hello World\"\n"
"\"Hello%20World\"\n"

#. type: Plain text
#: text/chapter10.md:80
msgid ""
"We can also define our own functions in foreign modules. Here's an example "
"of how to create and call a custom JavaScript function that squares a "
"`Number`:"
msgstr ""
"外部モジュールには独自の関数も定義できます。\n"
"以下は`Number`を平方する独自のJavaScript関数を作って呼び出す方法の一例です。"

#. type: Plain text
#: text/chapter10.md:82
msgid "`test/Examples.js`:"
msgstr "`test/Examples.js`:"

#. type: Fenced code block (js)
#: text/chapter10.md:83
#, no-wrap
msgid ""
"\"use strict\";\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.js:square}}\n"
msgstr ""
"\"use strict\";\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.js:square}}\n"

#. type: Plain text
#: text/chapter10.md:90
msgid "`test/Examples.purs`:"
msgstr "`test/Examples.purs`:"

#. type: Fenced code block (hs)
#: text/chapter10.md:91
#, no-wrap
msgid ""
"module Test.Examples where\n"
"\n"
"foreign import square :: Number -> Number\n"
msgstr ""
"module Test.Examples where\n"
"\n"
"foreign import square :: Number -> Number\n"

#. type: Fenced code block (text)
#: text/chapter10.md:97
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> square 5.0\n"
"25.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> square 5.0\n"
"25.0\n"

#. type: Title ##
#: text/chapter10.md:105
#, no-wrap
msgid "Functions of Multiple Arguments"
msgstr "多変数関数"

#. type: Plain text
#: text/chapter10.md:108
msgid ""
"Let's rewrite our `diagonal` function from Chapter 2 in a foreign module. "
"This function calculates the diagonal of a right-angled triangle."
msgstr ""
"第2章の`diagonal`関数を外部モジュールで書き直してみましょう。\n"
"この関数は直角三角形の対角線を計算します。"

#. type: Fenced code block (hs)
#: text/chapter10.md:109
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:diagonal}}\n"

#. type: Plain text
#: text/chapter10.md:114
msgid ""
"Recall that functions in PureScript are _curried_. `diagonal` is a function "
"that takes a `Number` and returns a _function_, that takes a `Number` and "
"returns a `Number`."
msgstr ""
"PureScriptの関数は _カリー化_ されていることを思い出してください。\n"
"`diagonal`は`Number`を取って _関数_ を返す関数です。\n"
"そして返された関数は`Number`を取って`Number`を返します。"

#. type: Fenced code block (js)
#: text/chapter10.md:115
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.js:diagonal}}\n"

#. type: Plain text
#: text/chapter10.md:120
msgid "Or with ES6 arrow syntax (see ES6 note below)."
msgstr ""
"もしくはES6の矢印構文ではこうです（後述するES6についての補足を参照してくださ"
"い）。"

#. type: Fenced code block (js)
#: text/chapter10.md:121
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_arrow}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.js:diagonal_arrow}}\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:125
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_arrow}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_arrow}}\n"

#. type: Fenced code block (text)
#: text/chapter10.md:129
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> diagonal 3.0 4.0\n"
"5.0\n"
"> diagonalArrow 3.0 4.0\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> diagonal 3.0 4.0\n"
"5.0\n"
"> diagonalArrow 3.0 4.0\n"
"5.0\n"

#. type: Title ##
#: text/chapter10.md:139
#, no-wrap
msgid "Uncurried Functions"
msgstr "カリー化されていない関数"

#. type: Plain text
#: text/chapter10.md:142
msgid ""
"Writing curried functions in JavaScript isn't always feasible, despite being "
"scarcely idiomatic. A typical multi-argument JavaScript function would be of "
"the _uncurried_ form:"
msgstr ""
"JavaScriptでカリー化された関数を書くことは、ただでさえJavaScriptらしいもので"
"はない上に、常に可能というわけでもありません。\n"
"よくある多変数なJavaScriptの関数は _カリー化されていない_ 形式を取るでしょ"
"う。"

#. type: Fenced code block (js)
#: text/chapter10.md:143
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_uncurried}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.js:diagonal_uncurried}}\n"

#. type: Plain text
#: text/chapter10.md:148
msgid ""
"The module `Data.Function.Uncurried` exports _wrapper_ types and utility "
"functions to work with uncurried functions."
msgstr ""
"モジュール`Data.Function.Uncurried`は*梱包*型とカリー化されていない関数を取り"
"扱う関数をエクスポートします。"

#. type: Fenced code block (hs)
#: text/chapter10.md:149
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_uncurried}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_uncurried}}\n"

#. type: Plain text
#: text/chapter10.md:154
msgid "Inspecting the type constructor `Fn2`:"
msgstr "型構築子`Fn2`を調べると以下です。"

#. type: Fenced code block (text)
#: text/chapter10.md:155
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Function.Uncurried \n"
"> :kind Fn2\n"
"Type -> Type -> Type -> Type\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.Function.Uncurried \n"
"> :kind Fn2\n"
"Type -> Type -> Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:164
msgid ""
"`Fn2` takes three type arguments. `Fn2 a b c` is a type representing an "
"uncurried function of two arguments of types `a` and `b`, that returns a "
"value of type `c`. We used it to import `diagonalUncurried` from the foreign "
"module."
msgstr ""
"`Fn2`は3つの型引数を取ります。\n"
"`Fn2 a b c`は、型 `a`と `b`の2つの引数、返り値の型 `c`をもつカリー化されてい"
"ない関数の型を表現しています。\n"
"これを使って外部モジュールから`diagonalUncurried`をインポートしました。"

#. type: Plain text
#: text/chapter10.md:166
msgid ""
"We can then call it with `runFn2` which takes the uncurried function then "
"the arguments."
msgstr "カリー化されていない関数と引数を取る`runFn2`で呼び出すことができます。"

#. type: Fenced code block (text)
#: text/chapter10.md:167
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Function.Uncurried\n"
"> runFn2 diagonalUncurried 3.0 4.0\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Function.Uncurried\n"
"> runFn2 diagonalUncurried 3.0 4.0\n"
"5.0\n"

#. type: Plain text
#: text/chapter10.md:177
msgid ""
"The `functions` package defines similar type constructors for function "
"arities from 0 to 10."
msgstr ""
"`functions`パッケージでは0引数から10引数までの関数について同様の型構築子が定"
"義されています。"

#. type: Title ##
#: text/chapter10.md:178
#, no-wrap
msgid "A Note About Uncurried Functions"
msgstr "カリー化されていない関数についての補足"

#. type: Plain text
#: text/chapter10.md:181
msgid ""
"PureScript's curried functions has certain advantages. It allows us to "
"partially apply functions, and to give type class instances for function "
"types - but it comes with a performance penalty. For performance critical "
"code, it is sometimes necessary to define uncurried JavaScript functions "
"which accept multiple arguments."
msgstr ""
"PureScriptのカリー化された関数にはもちろん利点があります。部分的に関数を適用"
"でき、関数型に型クラスインスタンスを与えられます。しかし効率上の代償も付いて"
"くるのです。効率性が決定的に重要なコードでは多変数を受け付けるカリー化されて"
"いないJavaScript関数を定義する必要が時々あります。"

#. type: Plain text
#: text/chapter10.md:183
msgid ""
"We can also create uncurried functions from PureScript. For a function of "
"two arguments, we can use the `mkFn2` function."
msgstr ""
"PureScriptでカリー化されていない関数を作ることもできます。\n"
"2引数の関数については`mkFn2`関数が使えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:184
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_add}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_add}}\n"

#. type: Plain text
#: text/chapter10.md:189
msgid ""
"We can apply the uncurried function of two arguments by using `runFn2` as "
"before:"
msgstr ""
"前と同様に`runFn2`関数を使うと、カリー化されていない2引数の関数を適用できま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:190
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_sum}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_sum}}\n"

#. type: Plain text
#: text/chapter10.md:195
msgid ""
"The key here is that the compiler _inlines_ the `mkFn2` and `runFn2` "
"functions whenever they are fully applied. The result is that the generated "
"code is very compact:"
msgstr ""
"ここで重要なのは、引数が全て適用されるなら、コンパイラは `mkFn2`関数や "
"`runFn2`関数を*インライン化*するということです。\n"
"そのため、生成されるコードはとても簡潔になります。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:196
#, no-wrap
msgid ""
"var uncurriedAdd = function (n, m) {\n"
"  return m + n | 0;\n"
"};\n"
"\n"
"var uncurriedSum = uncurriedAdd(3, 10);\n"
msgstr ""
"var uncurriedAdd = function (n, m) {\n"
"  return m + n | 0;\n"
"};\n"
"\n"
"var uncurriedSum = uncurriedAdd(3, 10);\n"

#. type: Plain text
#: text/chapter10.md:205
msgid "For contrast, here is a traditional curried function:"
msgstr "対照的に、こちらがこれまでのカリー化された関数です。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:curried_add}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:curried_add}}\n"

#. type: Plain text
#: text/chapter10.md:211
msgid ""
"and the resulting generated code, which is less compact due to the nested "
"functions:"
msgstr ""
"そして生成結果のコードが以下です。\n"
"入れ子の関数のため比較的簡潔ではありません。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:212
#, no-wrap
msgid ""
"var curriedAdd = function (n) {\n"
"  return function (m) {\n"
"    return m + n | 0;\n"
"  };\n"
"};\n"
"\n"
"var curriedSum = curriedAdd(3)(10);\n"
msgstr ""
"var curriedAdd = function (n) {\n"
"  return function (m) {\n"
"    return m + n | 0;\n"
"  };\n"
"};\n"
"\n"
"var curriedSum = curriedAdd(3)(10);\n"

#. type: Title ##
#: text/chapter10.md:222
#, no-wrap
msgid "A Note About Modern JavaScript Syntax"
msgstr "現代的なJavaScriptの構文についての補足"

#. type: Plain text
#: text/chapter10.md:225
msgid ""
"The arrow function syntax we saw earlier is an ES6 feature, and so it is "
"incompatible with some older browsers (namely IE11). As of writing, it is "
"[estimated that arrow functions are unavailable for the 6% of users](https://"
"caniuse.com/#feat=arrow-functions) who have not yet updated their web "
"browser."
msgstr ""
"前に見た矢印関数構文はES6の機能であり、そのため幾つかの古いブラウザ（名指しす"
"ればIE11）と互換性がありません。\n"
"執筆時点でWebブラウザをまだ更新していない[6%の利用者が矢印関数を使うことがで"
"きないと推計](https://caniuse.com/#feat=arrow-functions)されています。"

#. type: Plain text
#: text/chapter10.md:227
msgid ""
"In order to be compatible with the most users, the JavaScript code generated "
"by the PureScript compiler does not use arrow functions. It is also "
"recommended to **avoid arrow functions in public libraries** for the same "
"reason."
msgstr ""
"ほとんどの利用者にとって互換性があるようにするため、PureScriptコンパイラに"
"よって生成されるJavaScriptコードは矢印関数を使っていません。\n"
"また、同じ理由で**公開するライブラリでも矢印関数を避ける**ことが推奨されま"
"す。"

#. type: Plain text
#: text/chapter10.md:229
msgid ""
"You may still use arrow functions in your own FFI code, but then should "
"include a tool such as [Babel](https://github.com/babel/babel#intro) in your "
"deployment workflow to convert these back to ES5 compatible functions."
msgstr ""
"それでも自分のFFIコードで矢印関数を使うこともできますが、デプロイの作業工程で"
"ES5に互換性のある関数へ変換するために[Babel](https://github.com/babel/"
"babel#intro)などのツールを含めるべきです。"

#. type: Plain text
#: text/chapter10.md:231
msgid ""
"If you find arrow functions in ES6 more readable, you may transform "
"JavaScript code in the compiler's `output` directory with a tool like [Lebab]"
"(https://github.com/lebab/lebab):"
msgstr ""
"ES6の矢印関数がより読みやすく感じたら[Lebab](https://github.com/lebab/lebab)"
"のようなツールを使ってコンパイラの`output`ディレクトリにJavaScriptのコードを"
"変換できます。"

#. type: Fenced code block (sh)
#: text/chapter10.md:232
#, no-wrap
msgid ""
"npm i -g lebab\n"
"lebab --replace output/ --transform arrow,arrow-return\n"
msgstr ""
"npm i -g lebab\n"
"lebab --replace output/ --transform arrow,arrow-return\n"

#. type: Plain text
#: text/chapter10.md:238
msgid "This operation would convert the above `curriedAdd` function to:"
msgstr "この操作により上の`curriedAdd`関数は以下に変換されます。"

#. type: Fenced code block (js)
#: text/chapter10.md:239
#, no-wrap
msgid ""
"var curriedAdd = n => m =>\n"
"  m + n | 0;\n"
msgstr ""
"var curriedAdd = n => m =>\n"
"  m + n | 0;\n"

#. type: Plain text
#: text/chapter10.md:245
msgid ""
"The remaining examples in this book will use arrow functions instead of "
"nested functions."
msgstr "本書の残りの例では入れ子の関数の代わりに矢印関数を使います。"

#. type: Title ##
#: text/chapter10.md:246 text/chapter10.md:321 text/chapter10.md:476
#: text/chapter10.md:714 text/chapter10.md:891 text/chapter10.md:1074
#: text/chapter10.md:1314 text/chapter11.md:140 text/chapter11.md:224
#: text/chapter11.md:343 text/chapter11.md:549 text/chapter11.md:716
#: text/chapter11.md:915 text/chapter11.md:960 text/chapter12.md:153
#: text/chapter12.md:361 text/chapter12.md:555 text/chapter13.md:90
#: text/chapter13.md:137 text/chapter13.md:244 text/chapter13.md:387
#: text/chapter14.md:249 text/chapter14.md:352 text/chapter14.md:569
#: text/chapter14.md:704 text/chapter2.md:116 text/chapter3.md:714
#: text/chapter4.md:70 text/chapter4.md:181 text/chapter4.md:363
#: text/chapter4.md:521 text/chapter4.md:615 text/chapter5.md:99
#: text/chapter5.md:228 text/chapter5.md:392 text/chapter5.md:465
#: text/chapter5.md:524 text/chapter6.md:130 text/chapter6.md:319
#: text/chapter6.md:410 text/chapter6.md:607 text/chapter6.md:741
#: text/chapter7.md:381 text/chapter7.md:540 text/chapter7.md:642
#: text/chapter8.md:308 text/chapter8.md:666 text/chapter8.md:973
#: text/chapter9.md:85 text/chapter9.md:131 text/chapter9.md:198
#, no-wrap
msgid "Exercises"
msgstr "演習"

#. type: Bullet: '1. '
#: text/chapter10.md:250
msgid ""
"(Medium) Write a JavaScript function `volumeFn` in the `Test.MySolutions` "
"module that finds the volume of a box. Use an `Fn` wrapper from `Data."
"Function.Uncurried`."
msgstr ""
"（普通）`Test.MySolutions`モジュールの中に箱の体積を求めるJavaScriptの関数"
"`volumeFn`を書いてください。\n"
"`Data.Function.Uncurried`の梱包`Fn`を使ってください。"

#. type: Bullet: '2. '
#: text/chapter10.md:250
msgid "(Medium) Rewrite `volumeFn` with arrow functions as `volumeArrow`."
msgstr ""
"（普通）`volumeFn`を矢印関数を使って書き直し、`volumeArrow`としてください。"

#. type: Title ##
#: text/chapter10.md:251
#, no-wrap
msgid "Passing Simple Types"
msgstr "単純な型を渡す"

#. type: Plain text
#: text/chapter10.md:254
msgid ""
"The following data types may be passed between PureScript and JavaScript as-"
"is:"
msgstr ""
"以下のデータ型はPureScriptとJavaScriptの間でそのまま渡し合うことができます。"

#. type: Plain text
#: text/chapter10.md:262
msgid ""
"PureScript | JavaScript --- | --- Boolean | Boolean String | String Int, "
"Number | Number Array | Array Record | Object"
msgstr ""
"PureScript  | JavaScript\n"
"---         | ---\n"
"Boolean     | Boolean\n"
"String      | String\n"
"Int, Number | Number\n"
"Array       | Array\n"
"Record      | Object"

#. type: Plain text
#: text/chapter10.md:264
msgid ""
"We've already seen examples with the primitive types `String` and `Number`. "
"We'll now take a look at the structural types `Array` and `Record` (`Object` "
"in JavaScript)."
msgstr ""
"`String`と`Number`という原始型の例は既に見てきました。\n"
"ここから`Array`や`Record`（JavaScriptでは`Object`）といった構造的な型を眺めて"
"いきます。"

#. type: Plain text
#: text/chapter10.md:266
msgid ""
"To demonstrate passing `Array`s, here's how to call a JavaScript function "
"which takes an `Array` of `Int` and returns the cumulative sum as another "
"array. Recall that, since JavaScript does not have a separate type for "
"`Int`, both `Int` and `Number` in PureScript translate to `Number` in "
"JavaScript."
msgstr ""
"`Array`の受け渡しを実演するために、以下に`Int`の`Array`を取って別の配列として"
"累計の和を返すJavaScriptの関数の呼び出し方を示します。前にありましたが、"
"JavaScriptは`Int`のための分離した型を持たないため、PureScriptでの`Int`と"
"`Number`はJavaScriptでの`Number`に翻訳されます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:267
#, no-wrap
msgid "foreign import cumulativeSums :: Array Int -> Array Int\n"
msgstr "foreign import cumulativeSums :: Array Int -> Array Int\n"

#. type: Fenced code block (js)
#: text/chapter10.md:271
#, no-wrap
msgid ""
"export const cumulativeSums = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  return sums;\n"
"};\n"
msgstr ""
"export const cumulativeSums = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  return sums;\n"
"};\n"

#. type: Fenced code block (text)
#: text/chapter10.md:283
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> cumulativeSums [1, 2, 3]\n"
"[1,3,6]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> cumulativeSums [1, 2, 3]\n"
"[1,3,6]\n"

#. type: Plain text
#: text/chapter10.md:292
msgid ""
"To demonstrate passing `Records`, here's how to call a JavaScript function "
"which takes two `Complex` numbers as records, and returns their sum as "
"another record. Note that a `Record` in PureScript is represented as an "
"`Object` in JavaScript:"
msgstr ""
"`Record`の受け渡しを実演するために、以下に2つの`Complex`な数をレコードとして"
"取り、和を別のレコードとして返すJavaScriptの呼び出し方を示します。\n"
"PureScriptでの`Record`がJavaScriptでは`Object`として表現されることに注意して"
"ください。"

#. type: Fenced code block (hs)
#: text/chapter10.md:293
#, no-wrap
msgid ""
"type Complex = {\n"
"  real :: Number,\n"
"  imag :: Number\n"
"}\n"
"\n"
"foreign import addComplex :: Complex -> Complex -> Complex\n"
msgstr ""
"type Complex = {\n"
"  real :: Number,\n"
"  imag :: Number\n"
"}\n"
"\n"
"foreign import addComplex :: Complex -> Complex -> Complex\n"

#. type: Fenced code block (js)
#: text/chapter10.md:302
#, no-wrap
msgid ""
"export const addComplex = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    imag: a.imag + b.imag\n"
"  }\n"
"};\n"
msgstr ""
"export const addComplex = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    imag: a.imag + b.imag\n"
"  }\n"
"};\n"

#. type: Fenced code block (text)
#: text/chapter10.md:311
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"{ imag: 6.0, real: 4.0 }\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"{ imag: 6.0, real: 4.0 }\n"

#. type: Plain text
#: text/chapter10.md:320
msgid ""
"Note that the above techniques require trusting that JavaScript will return "
"the expected types, as PureScript is not able to apply type checking to "
"JavaScript code. We will describe this type safety concern in more detail "
"later on in the JSON section, as well as cover techniques to protect against "
"type mismatches."
msgstr ""
"なお、上の手法にはJavaScriptが期待通りの型を返すことを信用する必要がありま"
"す。PureScriptはJavaScriptのコードに型検査を適用できないからです。この型安全"
"性の配慮について後のJSONの節でより詳しく記述していきます。型の不整合から身を"
"守る手法についても押さえます。"

#. type: Bullet: '1. '
#: text/chapter10.md:324
msgid ""
"(Medium) Write a JavaScript function `cumulativeSumsComplex` (and "
"corresponding PureScript foreign import) that takes an `Array` of `Complex` "
"numbers and returns the cumulative sum as another array of complex numbers."
msgstr ""
"（普通）`Complex`な数の配列を取って別の複素数の配列として累計の和を返す"
"JavaScriptの関数`cumulativeSumsComplex`（と対応するPureScriptの外部インポー"
"ト）を書いてください。"

#. type: Title ##
#: text/chapter10.md:325
#, no-wrap
msgid "Beyond Simple Types"
msgstr "単純な型を越えて"

#. type: Plain text
#: text/chapter10.md:328
msgid ""
"We have seen examples of how to send and receive types with a native "
"JavaScript representation, such as `String`, `Number`, `Array`, and "
"`Record`, over FFI. Now we'll cover how to use some of the other types "
"available in PureScript, like `Maybe`."
msgstr ""
"`String`、`Number`、`Array`、そして`Record`といった、JavaScript固有の表現を持"
"つ型をFFI越しに送ったり受け取ったりする方法を数例見てきました。\n"
"ここから`Maybe`のようなPureScriptで使える幾つかの他の型の使い方を押さえていき"
"ます。"

#. type: Plain text
#: text/chapter10.md:330
msgid ""
"Suppose we wanted to recreate the `head` function on arrays by using a "
"foreign declaration. In JavaScript, we might write the function as follows:"
msgstr ""
"外部宣言を使用して、配列についての `head`関数を改めて作成したいとしましょ"
"う。\n"
"JavaScriptでは次のような関数を書くことになるでしょう。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:331
#, no-wrap
msgid ""
"export const head = arr =>\n"
"  arr[0];\n"
msgstr ""
"export const head = arr =>\n"
"  arr[0];\n"

#. type: Plain text
#: text/chapter10.md:337
#, no-wrap
msgid "How would we type this function? We might try to give it the type `forall a. Array a -> a`, but for empty arrays, this function returns `undefined`. Therefore, the type `forall a. Array a -> a` does not correctly represent this implementation.\n"
msgstr ""
"この関数をどう型付けましょうか。\n"
"型 `forall a. Array a -> a`を与えようとしても、空の配列に対してこの関数は `undefined`を返します。\n"
"したがって型`forall a. Array a -> a`は正しくこの実装を表現していないのです。\n"

#. type: Plain text
#: text/chapter10.md:339
msgid "We instead want to return a `Maybe` value to handle this corner case:"
msgstr "代わりにこの特殊な場合を扱うために`Maybe`値を返したいところです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:340
#, no-wrap
msgid "foreign import maybeHead :: forall a. Array a -> Maybe a\n"
msgstr "foreign import maybeHead :: forall a. Array a -> Maybe a\n"

#. type: Plain text
#: text/chapter10.md:345
msgid "But how do we return a `Maybe`? It is tempting to write the following:"
msgstr ""
"しかしどうやって`Maybe`を返しましょうか。\n"
"つい以下のように書きたくなります。"

#. type: Fenced code block (js)
#: text/chapter10.md:346
#, no-wrap
msgid ""
"// Don't do this\n"
"import Data_Maybe from '../Data.Maybe'\n"
"\n"
"export const maybeHead = arr => {\n"
"  if (arr.length) {\n"
"    return Data_Maybe.Just.create(arr[0]);\n"
"  } else {\n"
"    return Data_Maybe.Nothing.value;\n"
"  }\n"
"}\n"
msgstr ""
"// こうしないでください\n"
"import Data_Maybe from '../Data.Maybe'\n"
"\n"
"export const maybeHead = arr => {\n"
"  if (arr.length) {\n"
"    return Data_Maybe.Just.create(arr[0]);\n"
"  } else {\n"
"    return Data_Maybe.Nothing.value;\n"
"  }\n"
"}\n"

#. type: Plain text
#: text/chapter10.md:360
msgid ""
"Importing and using the `Data.Maybe` module directly in the foreign module "
"isn't recommended as it makes our code brittle to changes in the code "
"generator &mdash; `create` and `value` are not public APIs. Additionally, "
"doing this can cause problems when using `purs bundle` for dead code "
"elimination."
msgstr ""
"外部モジュールで直接`Data.Maybe`モジュールをインポートして使うことはお勧めし"
"ません。というのもコードがコード生成器の変化に対して脆くなるからです。"
"`create`や`value`は公開のAPIではありません。加えて、このようにすると、不要な"
"コードを消去する`purs bundle`を使う際に問題を引き起こす可能性があります。"

#. type: Plain text
#: text/chapter10.md:362
msgid ""
"The recommended approach is to add extra parameters to our FFI-defined "
"function to accept the functions we need."
msgstr ""
"推奨されるやり方はFFIで定義された関数に余剰の引数を加えて必要な関数を受け付け"
"ることです。"

#. type: Fenced code block (js)
#: text/chapter10.md:363
#, no-wrap
msgid ""
"export const maybeHeadImpl = just => nothing => arr => {\n"
"  if (arr.length) {\n"
"    return just(arr[0]);\n"
"  } else {\n"
"    return nothing;\n"
"  }\n"
"};\n"
msgstr ""
"export const maybeHeadImpl = just => nothing => arr => {\n"
"  if (arr.length) {\n"
"    return just(arr[0]);\n"
"  } else {\n"
"    return nothing;\n"
"  }\n"
"};\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:373
#, no-wrap
msgid ""
"foreign import maybeHeadImpl :: forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
"\n"
"maybeHead :: forall a. Array a -> Maybe a\n"
"maybeHead arr = maybeHeadImpl Just Nothing arr\n"
msgstr ""
"foreign import maybeHeadImpl :: forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
"\n"
"maybeHead :: forall a. Array a -> Maybe a\n"
"maybeHead arr = maybeHeadImpl Just Nothing arr\n"

#. type: Plain text
#: text/chapter10.md:381
msgid "Note that we wrote:"
msgstr "ただし、次のように書きますが、"

#. type: Fenced code block (hs)
#: text/chapter10.md:382
#, no-wrap
msgid "forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
msgstr "forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"

#. type: Plain text
#: text/chapter10.md:387
msgid "and not:"
msgstr "以下ではないことに注意です。"

#. type: Fenced code block (hs)
#: text/chapter10.md:388
#, no-wrap
msgid "forall a. ( a -> Maybe a) -> Maybe a -> Array a -> Maybe a\n"
msgstr "forall a. ( a -> Maybe a) -> Maybe a -> Array a -> Maybe a\n"

#. type: Plain text
#: text/chapter10.md:394
msgid ""
"While both forms work, the latter is more vulnerable to unwanted inputs in "
"place of `Just` and `Nothing`.  For example, in the more vulnerable case we "
"could call it as follows:"
msgstr ""
"どちらの形式でも動きますが、後者は`Just`と`Nothing`の場所での招かれざる入力に"
"侵されやすくなります。例えばより脆弱な場合では以下のようにして呼ぶことができ"
"ます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:395
#, no-wrap
msgid "maybeHeadImpl (\\_ -> Just 1000) (Just 1000) [1,2,3]\n"
msgstr "maybeHeadImpl (\\_ -> Just 1000) (Just 1000) [1,2,3]\n"

#. type: Plain text
#: text/chapter10.md:401
#, no-wrap
msgid ""
"which returns `Just 1000` for any array input.\n"
"This vulnerability is allowed because `(\\_ -> Just 1000)` and `Just 1000` match the signatures of `(a -> Maybe a)` and `Maybe a` respectively when `a` is `Int` (based on input array).\n"
msgstr ""
"これはいかなる配列についても`Just 1000`を返します。\n"
"この脆弱性は`a`が`Int`のときに（これは入力の配列に基づきます）`(\\_ -> Just 1000)`と`Just 1000`がシグネチャ`(a -> Maybe a)`と`Maybe a`にそれぞれ合致しているために許されているのです。\n"

#. type: Plain text
#: text/chapter10.md:404
#, no-wrap
msgid ""
"In the more secure type signature, even when `a` is determined to be `Int` based on the input array, we still need to provide valid functions matching the signatures involving `forall x`.\n"
"The _only_ option for `(forall x. Maybe x)` is `Nothing`, since a `Just` value would assume a type for `x` and will no longer be valid for all `x`. The only options for `(forall x. x -> Maybe x)` are `Just` (our desired argument) and `(\\_ -> Nothing)`, which is the only remaining vulnerability.\n"
msgstr "より安全な型シグネチャでは、入力の配列に基づいて`a`が`Int`に決定されたとしても、`forall x`に絡むシグネチャに合致する妥当な関数を提供する必要があります。`(forall x. Maybe x)`の *唯一* の選択肢は`Nothing`ですが、それは`Just`値が`x`の型を前提にしてしまうと、もはや全ての`x`については妥当でなくなってしまうからです。`(forall x. x -> Maybe x)`の唯一の選択肢は`Just`（望まれている引数）と`(\\_ -> Nothing)`であり、後者は唯一残っている脆弱性になるのです。\n"

#. type: Title ##
#: text/chapter10.md:405
#, no-wrap
msgid "Defining Foreign Types"
msgstr "外部型の定義"

#. type: Plain text
#: text/chapter10.md:408
msgid ""
"Suppose instead of returning a `Maybe a`, we want to actually return "
"`arr[0]`. We want a type that represents a value either of type `a` or the "
"`undefined` value (but not `null`). We'll call this type `Undefined a`."
msgstr ""
"`Maybe a`を返す代わりに実は`arr[0]`を返したいのだとしましょう。\n"
"型`a`ないし`undefined`値（ただし`null`ではありません）の何れかの値を表現する"
"型がほしいです。\n"
"この型を`Undefined a`と呼びましょう。"

#. type: Plain text
#: text/chapter10.md:410
msgid ""
"We can define a _foreign type_ using a _foreign type declaration_. The "
"syntax is similar to defining a foreign function:"
msgstr ""
"_外部インポート宣言_ を使うと、*外部型* (foreign type) を定義できます。構文は"
"外部関数を定義するのと似ています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:411
#, no-wrap
msgid "foreign import data Undefined :: Type -> Type\n"
msgstr "foreign import data Undefined :: Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:416
#, no-wrap
msgid "The `data` keyword here indicates that we are defining a _type_, not a value. Instead of a type signature, we give the _kind_ of the new type. In this case, we declare the kind of `Undefined` to be `Type -> Type`. In other words, `Undefined` is a type constructor.\n"
msgstr ""
"このキーワード`data`は*型*を定義していることを表しています。\n"
"値ではありせん。\n"
"型シグネチャの代わりに、新しい型の*種*を与えます。\n"
"この場合は`Undefined`の種が `Type -> Type`であると宣言しています。\n"
"言い換えれば`Undefined`は型構築子です。\n"

#. type: Plain text
#: text/chapter10.md:418
msgid "We can now simply reuse our original definition for `head`:"
msgstr "これで元の`head`の定義を単に再利用できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:419
#, no-wrap
msgid ""
"export const undefinedHead = arr =>\n"
"  arr[0];\n"
msgstr ""
"export const undefinedHead = arr =>\n"
"  arr[0];\n"

#. type: Plain text
#: text/chapter10.md:425
msgid "And in the PureScript module:"
msgstr "PureScriptモジュールには以下を追加します。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:426
#, no-wrap
msgid "foreign import undefinedHead :: forall a. Array a -> Undefined a\n"
msgstr "foreign import undefinedHead :: forall a. Array a -> Undefined a\n"

#. type: Plain text
#: text/chapter10.md:431
msgid ""
"The body of the `undefinedHead` function returns `arr[0]` which may be "
"`undefined`, and the type signature correctly reflects that fact."
msgstr ""
"`undefinedHead`関数の本体は`undefined`かもしれない`arr[0]`を返します。\n"
"そしてこの型シグネチャはその事実を正しく反映しています。"

#. type: Plain text
#: text/chapter10.md:433
msgid ""
"This function has the correct runtime representation for its type, but is "
"quite useless since we have no way to use a value of type `Undefined a`. "
"Well, not exactly. We can use this type in another FFI!"
msgstr ""
"この関数はその型の適切な実行時表現を持っていますが、型 `Undefined a`の値を使"
"用する方法がないので、全く役に立ちません。\n"
"いや、言い過ぎました。\n"
"別のFFIでこの型を使えますからね。"

#. type: Plain text
#: text/chapter10.md:435
msgid ""
"We can write a function that will tell us whether a value is undefined or "
"not:"
msgstr "値が未定義かどうかを教えてくれる関数を書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:436
#, no-wrap
msgid "foreign import isUndefined :: forall a. Undefined a -> Boolean\n"
msgstr "foreign import isUndefined :: forall a. Undefined a -> Boolean\n"

#. type: Plain text
#: text/chapter10.md:441
msgid "This is defined in our foreign JavaScript module as follows:"
msgstr "外部JavaScriptモジュールで次のように定義できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:442
#, no-wrap
msgid ""
"export const isUndefined = value =>\n"
"  value === undefined;\n"
msgstr ""
"export const isUndefined = value =>\n"
"  value === undefined;\n"

#. type: Plain text
#: text/chapter10.md:448
msgid ""
"We can now use `isUndefined` and `undefinedHead` together from PureScript to "
"define a useful function:"
msgstr ""
"これでPureScriptで `isUndefined`と `undefinedHead`を一緒に使用すると、便利な"
"関数を定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:449
#, no-wrap
msgid ""
"isEmpty :: forall a. Array a -> Boolean\n"
"isEmpty = isUndefined <<< undefinedHead\n"
msgstr ""
"isEmpty :: forall a. Array a -> Boolean\n"
"isEmpty = isUndefined <<< undefinedHead\n"

#. type: Plain text
#: text/chapter10.md:455
msgid ""
"Here, the foreign function we defined is very simple, which means we can "
"benefit from the use of PureScript's typechecker as much as possible. This "
"is good practice in general: foreign functions should be kept as small as "
"possible, and application logic moved into PureScript code wherever possible."
msgstr ""
"このように、定義したこの外部関数はとても簡単です。\n"
"つまりPureScriptの型検査器を使うことによる利益が最大限得られるのです。\n"
"一般に、外部関数は可能な限り小さく保ち、できるだけアプリケーションの処理は"
"PureScriptコードへ移動しておくことをお勧めします。"

#. type: Title ##
#: text/chapter10.md:456 text/chapter8.md:365 text/chapter8.md:443
#, no-wrap
msgid "Exceptions"
msgstr "例外"

#. type: Plain text
#: text/chapter10.md:459
msgid ""
"Another option is to simply throw an exception in the case of an empty "
"array. Strictly speaking, pure functions should not throw exceptions, but we "
"have the flexibility to do so. We indicate the lack of safety in the "
"function name:"
msgstr ""
"他の選択肢としては、空の配列の場合に例外を投げる方法があります。\n"
"厳密に言えば、純粋な関数は例外を投げるべきではありませんが、そうする柔軟さは"
"あります。\n"
"安全性に欠けていることを関数名で示します。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:460
#, no-wrap
msgid "foreign import unsafeHead :: forall a. Array a -> a\n"
msgstr "foreign import unsafeHead :: forall a. Array a -> a\n"

#. type: Plain text
#: text/chapter10.md:465
msgid ""
"In our foreign JavaScript module, we can define `unsafeHead` as follows:"
msgstr "JavaScriptモジュールでは、`unsafeHead`を以下のように定義できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:466
#, no-wrap
msgid ""
"export const unsafeHead = arr => {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"
msgstr ""
"export const unsafeHead = arr => {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"

#. type: Bullet: '1. '
#: text/chapter10.md:479
msgid ""
"(Medium) Given a record that represents a quadratic polynomial `a*x^2 + b*x "
"+ c = 0`:"
msgstr ""
"（普通）二次多項式`a*x^2 + b*x + c = 0`を表現するレコードが与えられているとし"
"ます。"

#. type: Plain text
#: text/chapter10.md:487
#, no-wrap
msgid ""
"    ```hs\n"
"    type Quadratic = {\n"
"      a :: Number,\n"
"      b :: Number,\n"
"      c :: Number\n"
"    }\n"
"    ```\n"
msgstr ""
"    ```hs\n"
"    type Quadratic = {\n"
"      a :: Number,\n"
"      b :: Number,\n"
"      c :: Number\n"
"    }\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:489
#, no-wrap
msgid "    Write a JavaScript function `quadraticRootsImpl` and a wrapper `quadraticRoots :: Quadratic -> Pair Complex` that uses the quadratic formula to find the roots of this polynomial. Return the two roots as a `Pair` of `Complex` numbers. _Hint:_ Use the `quadraticRoots` wrapper to pass a constructor for `Pair` to `quadraticRootsImpl`.\n"
msgstr ""
"    二次多項式を使ってこの多項式の根を求めるJavaScriptの関数`quadraticRootsImpl`とその梱包の`quadraticRoots :: Quadratic -> Pair Complex`を書いてください。\n"
"    2つの根を`Complex`の数の`Pair`として返してください。\n"
"    *手掛かり*：梱包`quadraticRoots`を使って`Pair`の構築子を`quadraticRootsImpl`に渡してください。\n"

#. type: Bullet: '1. '
#: text/chapter10.md:491
msgid ""
"(Medium) Write the function `toMaybe :: forall a. Undefined a -> Maybe a`. "
"This function converts `undefined` to `Nothing` and `a` values to `Just`s."
msgstr ""
"（普通）関数`toMaybe :: forall a. Undefined a -> Maybe a`を書いてください。\n"
"この関数は`undefined`を`Nothing`に、`a`の値を`Just a`に変換します。"

#. type: Bullet: '1. '
#: text/chapter10.md:493
msgid "(Difficult) With `toMaybe` in place, we can rewrite `maybeHead` as"
msgstr ""
"（難しい）`toMaybe`が準備できたら、`maybeHead`を以下に書き換えられます。"

#. type: Plain text
#: text/chapter10.md:498
#, no-wrap
msgid ""
"    ```hs\n"
"    maybeHead :: forall a. Array a -> Maybe a\n"
"    maybeHead = toMaybe <<< undefinedHead\n"
"    ```\n"
msgstr ""
"    ```hs\n"
"    maybeHead :: forall a. Array a -> Maybe a\n"
"    maybeHead = toMaybe <<< undefinedHead\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:500
#, no-wrap
msgid "    Is this a better approach than our previous implementation? _Note:_ There is no unit test for this exercise.\n"
msgstr ""
"    これは前の実装よりも良いやり方なのでしょうか。\n"
"    *補足*：この演習のための単体試験はありません。\n"

#. type: Title ##
#: text/chapter10.md:501
#, no-wrap
msgid "Using Type Class Member Functions"
msgstr "型クラスメンバー関数を使う"

#. type: Plain text
#: text/chapter10.md:504
msgid ""
"Just like our earlier guide on passing the `Maybe` constructor over FFI, "
"this is another case of writing PureScript that calls JavaScript, which in "
"turn calls PureScript functions again. Here we will explore how to pass type "
"class member functions over the FFI."
msgstr ""
"つい先程までFFI越しに`Maybe`の構築子を渡す手引きをしましたが、今回は"
"JavaScriptを呼び出すPureScriptを書く別の場合です。\n"
"JavaScriptの呼び出しでも続けざまにPureScriptの関数を呼び出します。\n"
"ここでは型クラスのメンバー関数をFFI越しに渡す方法を探ります。"

#. type: Plain text
#: text/chapter10.md:506
msgid ""
"We start with writing a foreign JavaScript function which expects the "
"appropriate instance of `show` to match the type of `x`."
msgstr ""
"型`x`に合う適切な`show`のインスタンスを期待する外部JavaScript関数を書くことか"
"ら始めます。"

#. type: Fenced code block (js)
#: text/chapter10.md:507
#, no-wrap
msgid ""
"export const boldImpl = show => x =>\n"
"  show(x).toUpperCase() + \"!!!\";\n"
msgstr ""
"export const boldImpl = show => x =>\n"
"  show(x).toUpperCase() + \"!!!\";\n"

#. type: Plain text
#: text/chapter10.md:513
msgid "Then we write the matching signature:"
msgstr "それから対応するシグネチャを書きます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:514
#, no-wrap
msgid "foreign import boldImpl :: forall a. (a -> String) -> a -> String\n"
msgstr "foreign import boldImpl :: forall a. (a -> String) -> a -> String\n"

#. type: Plain text
#: text/chapter10.md:519
msgid "and a wrapper function that passes the correct instance of `show`:"
msgstr "そして`show`の正しいインスタンスを渡す梱包関数も書きます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:520
#, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold x = boldImpl show x\n"
msgstr ""
"bold :: forall a. Show a => a -> String\n"
"bold x = boldImpl show x\n"

#. type: Plain text
#: text/chapter10.md:526
msgid "Alternatively in point-free form:"
msgstr "代わりにポイントフリー形式だとこうです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:527
#, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold = boldImpl show\n"
msgstr ""
"bold :: forall a. Show a => a -> String\n"
"bold = boldImpl show\n"

#. type: Plain text
#: text/chapter10.md:533
msgid "We can then call the wrapper:"
msgstr "そうして梱包を呼び出すことができます。"

#. type: Fenced code block (text)
#: text/chapter10.md:534
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> bold (Tuple 1 \"Hat\")\n"
"\"(TUPLE 1 \\\"HAT\\\")!!!\"\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> bold (Tuple 1 \"Hat\")\n"
"\"(TUPLE 1 \\\"HAT\\\")!!!\"\n"

#. type: Plain text
#: text/chapter10.md:544
msgid ""
"Here's another example demonstrating passing multiple functions, including a "
"function of multiple arguments (`eq`):"
msgstr ""
"以下は複数の関数を渡す別の実演例です。\n"
"これらの関数には複数引数の関数 (`eq`) が含まれます。"

#. type: Fenced code block (js)
#: text/chapter10.md:545
#, no-wrap
msgid ""
"export const showEqualityImpl = eq => show => a => b => {\n"
"  if (eq(a)(b)) {\n"
"    return \"Equivalent\";\n"
"  } else {\n"
"    return show(a) + \" is not equal to \" + show(b);\n"
"  }\n"
"}\n"
msgstr ""
"export const showEqualityImpl = eq => show => a => b => {\n"
"  if (eq(a)(b)) {\n"
"    return \"Equivalent\";\n"
"  } else {\n"
"    return show(a) + \" is not equal to \" + show(b);\n"
"  }\n"
"}\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:555
#, no-wrap
msgid ""
"foreign import showEqualityImpl :: forall a. (a -> a -> Boolean) -> (a -> String) -> a -> a -> String\n"
"\n"
"showEquality :: forall a. Eq a => Show a => a -> a -> String\n"
"showEquality = showEqualityImpl eq show\n"
msgstr ""
"foreign import showEqualityImpl :: forall a. (a -> a -> Boolean) -> (a -> String) -> a -> a -> String\n"
"\n"
"showEquality :: forall a. Eq a => Show a => a -> a -> String\n"
"showEquality = showEqualityImpl eq show\n"

#. type: Fenced code block (text)
#: text/chapter10.md:562
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Maybe\n"
"> showEquality Nothing (Just 5)\n"
"\"Nothing is not equal to (Just 5)\"\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Maybe\n"
"> showEquality Nothing (Just 5)\n"
"\"Nothing is not equal to (Just 5)\"\n"

#. type: Title ##
#: text/chapter10.md:571
#, no-wrap
msgid "Effectful Functions"
msgstr "作用のある関数"

#. type: Plain text
#: text/chapter10.md:574
msgid ""
"Let's extend our `bold` function to log to the console. Logging is an "
"`Effect`, and `Effect`s are represented in JavaScript as a function of zero "
"arguments, `()` with arrow notation:"
msgstr ""
"`bold`関数を拡張してコンソールにログ出力するようにしましょう。\n"
"ログ出力は`Effect`であり、`Effect`はJavaScriptにおいて無引数関数として表現さ"
"れます。\n"
"つまり`()`と矢印記法だとこうです。"

#. type: Fenced code block (js)
#: text/chapter10.md:575
#, no-wrap
msgid ""
"export const yellImpl = show => x => () =>\n"
"  console.log(show(x).toUpperCase() + \"!!!\");\n"
msgstr ""
"export const yellImpl = show => x => () =>\n"
"  console.log(show(x).toUpperCase() + \"!!!\");\n"

#. type: Plain text
#: text/chapter10.md:581
msgid ""
"The new foreign import is the same as before, except that the return type "
"changed from `String` to `Effect Unit`."
msgstr ""
"新しくなった外部インポートは、返る型が`String`から`Effect Unit`に変わった点以"
"外は以前と同じです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:582
#, no-wrap
msgid ""
"foreign import yellImpl :: forall a. (a -> String) -> a -> Effect Unit\n"
"\n"
"yell :: forall a. Show a => a -> Effect Unit\n"
"yell = yellImpl show\n"
msgstr ""
"foreign import yellImpl :: forall a. (a -> String) -> a -> Effect Unit\n"
"\n"
"yell :: forall a. Show a => a -> Effect Unit\n"
"yell = yellImpl show\n"

#. type: Plain text
#: text/chapter10.md:590
msgid ""
"When testing this in the repl, notice that the string is printed directly to "
"the console (instead of being quoted) and a `unit` value is returned."
msgstr ""
"REPLで試すと文字列が（引用符で囲まれず）直接コンソールに印字され`unit`値が返"
"ることがわかります。"

#. type: Fenced code block (text)
#: text/chapter10.md:591
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> yell (Tuple 1 \"Hat\")\n"
"(TUPLE 1 \"HAT\")!!!\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> yell (Tuple 1 \"Hat\")\n"
"(TUPLE 1 \"HAT\")!!!\n"
"unit\n"

#. type: Plain text
#: text/chapter10.md:602
msgid ""
"There are also `EffectFn` wrappers from `Effect.Uncurried`. These are "
"similar to the `Fn` wrappers from `Data.Function.Uncurried` that we've "
"already seen. These wrappers let you call uncurried effectful functions in "
"PureScript."
msgstr ""
"`Effect.Uncurried`に梱包`EffectFn`というものもあります。\n"
"これらは既に見た`Data.Function.Uncurried`の梱包`Fn`に似ています。\n"
"これらの梱包があればカリー化されていない作用のある関数をPureScriptで呼び出す"
"ことができます。"

#. type: Plain text
#: text/chapter10.md:604
msgid ""
"You'd generally only use these if you want to call existing JavaScript "
"library APIs directly, rather than wrapping those APIs in curried functions. "
"So it doesn't make much sense to present an example of uncurried `yell`, "
"where the JavaScript relies on PureScript type class members, since you "
"wouldn't find that in the existing JavaScript ecosystem."
msgstr ""
"一般的にこれらを使うのは、こうしたAPIをカリー化された関数に包むのではなく、既"
"存のJavaScriptライブラリのAPIを直接呼び出したいときぐらいです。\n"
"したがってカリー化していない`yell`の例を見せてもあまり意味がありません。\n"
"というのもJavaScriptがPureScriptの型クラスのメンバーに依っているからで、更に"
"それは既存のJavaScriptの生態系にそのメンバーが見付からないためです。"

#. type: Plain text
#: text/chapter10.md:606
msgid ""
"Instead, we'll modify our previous `diagonal` example to include logging in "
"addition to returning the result:"
msgstr ""
"翻って以前の`diagonal`の例を変更し、結果を返すことに加えてログ出力を含めると"
"こうなります。"

#. type: Fenced code block (js)
#: text/chapter10.md:607
#, no-wrap
msgid ""
"export const diagonalLog = function(w, h) {\n"
"  let result = Math.sqrt(w * w + h * h);\n"
"  console.log(\"Diagonal is \" + result);\n"
"  return result;\n"
"};\n"
msgstr ""
"export const diagonalLog = function(w, h) {\n"
"  let result = Math.sqrt(w * w + h * h);\n"
"  console.log(\"Diagonal is \" + result);\n"
"  return result;\n"
"};\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:615
#, no-wrap
msgid "foreign import diagonalLog :: EffectFn2 Number Number Number\n"
msgstr "foreign import diagonalLog :: EffectFn2 Number Number Number\n"

#. type: Fenced code block (text)
#: text/chapter10.md:619
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Effect.Uncurried\n"
"> runEffectFn2 diagonalLog 3.0 4.0\n"
"Diagonal is 5\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Effect.Uncurried\n"
"> runEffectFn2 diagonalLog 3.0 4.0\n"
"Diagonal is 5\n"
"5.0\n"

#. type: Title ##
#: text/chapter10.md:629
#, no-wrap
msgid "Asynchronous Functions"
msgstr "非同期関数"

#. type: Plain text
#: text/chapter10.md:632
msgid ""
"Promises in JavaScript translate directly to asynchronous effects in "
"PureScript with the help of the `aff-promise` library. See that library's "
"[documentation](https://pursuit.purescript.org/packages/purescript-aff-"
"promise) for more information. We'll just go through a few examples."
msgstr ""
"`aff-promise`ライブラリの助けを借りるとJavaScriptのプロミスは直接PureScriptの"
"非同期作用に翻訳されます。\n"
"詳細についてはライブラリの[ドキュメント](https://pursuit.purescript.org/"
"packages/purescript-aff-promise)をあたってください。\n"
"ここでは幾つかの例に触れるだけとします。"

#. type: Plain text
#: text/chapter10.md:634
msgid ""
"Suppose we want to use this JavaScript `wait` promise (or asynchronous "
"function) in our PureScript project. It may be used to delay execution for "
"`ms` milliseconds."
msgstr ""
"JavaScriptの`wait`プロミス（または非同期関数）をPureScriptのプロジェクトで使"
"いたいとします。\n"
"`ms`ミリ秒分だけ送らせて実行させるのに使うことができます。"

#. type: Fenced code block (js)
#: text/chapter10.md:635
#, no-wrap
msgid "const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n"
msgstr "const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n"

#. type: Plain text
#: text/chapter10.md:640
msgid ""
"We just need to export it wrapped as an `Effect` (function of zero "
"arguments):"
msgstr "単に`Effect`（無引数関数）に包んで公開するだけで大丈夫です。"

#. type: Fenced code block (js)
#: text/chapter10.md:641
#, no-wrap
msgid ""
"export const sleepImpl = ms => () =>\n"
"  wait(ms);\n"
msgstr ""
"export const sleepImpl = ms => () =>\n"
"  wait(ms);\n"

#. type: Plain text
#: text/chapter10.md:647
msgid "Then import it as follows:"
msgstr "そして以下のようにインポートします。"

#. type: Fenced code block (hs)
#: text/chapter10.md:648
#, no-wrap
msgid ""
"foreign import sleepImpl :: Int -> Effect (Promise Unit)\n"
"\n"
"sleep :: Int -> Aff Unit\n"
"sleep = sleepImpl >>> toAffE\n"
msgstr ""
"foreign import sleepImpl :: Int -> Effect (Promise Unit)\n"
"\n"
"sleep :: Int -> Aff Unit\n"
"sleep = sleepImpl >>> toAffE\n"

#. type: Plain text
#: text/chapter10.md:656
msgid "We can then run this `Promise` in an `Aff` block like so:"
msgstr ""
"そうして`Aff`ブロック中でこの`Promise`を以下のように走らせることができます。"

#. type: Fenced code block (text)
#: text/chapter10.md:657
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Test.Examples\n"
"> import Effect.Class.Console\n"
"> import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   log \"waiting\"\n"
"…   sleep 300\n"
"…   log \"done waiting\"\n"
"…\n"
"waiting\n"
"unit\n"
"done waiting\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Test.Examples\n"
"> import Effect.Class.Console\n"
"> import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   log \"waiting\"\n"
"…   sleep 300\n"
"…   log \"done waiting\"\n"
"…\n"
"waiting\n"
"unit\n"
"done waiting\n"

#. type: Plain text
#: text/chapter10.md:676
msgid ""
"Note that asynchronous logging in the repl just waits to print until the "
"entire block has finished executing. This code behaves more predictably when "
"run with `spago test` where there is a slight delay _between_ prints."
msgstr ""
"REPLでの非同期ログ出力はブロック全体が実行を終了するまで印字を待機する点に注"
"意しましょう。\n"
"このコードを`spago test`で走らせた場合、印字の _合間に_ 僅かな遅延があり、よ"
"り予測に近い挙動をします。"

#. type: Plain text
#: text/chapter10.md:678
msgid ""
"Let's look at another example where we return a value from a promise. This "
"function is written with `async` and `await`, which is just syntactic sugar "
"for promises."
msgstr ""
"他にプロミスから値を返す例を見てみましょう。\n"
"この関数は`async`と`await`を使って書かれていますが、これはプロミスの糖衣構文"
"に過ぎません。"

#. type: Fenced code block (js)
#: text/chapter10.md:679
#, no-wrap
msgid ""
"async function diagonalWait(delay, w, h) {\n"
"  await wait(delay);\n"
"  return Math.sqrt(w * w + h * h);\n"
"}\n"
"\n"
"export const diagonalAsyncImpl = delay => w => h => () =>\n"
"  diagonalWait(delay, w, h);\n"
msgstr ""
"async function diagonalWait(delay, w, h) {\n"
"  await wait(delay);\n"
"  return Math.sqrt(w * w + h * h);\n"
"}\n"
"\n"
"export const diagonalAsyncImpl = delay => w => h => () =>\n"
"  diagonalWait(delay, w, h);\n"

#. type: Plain text
#: text/chapter10.md:690
msgid ""
"Since we're returning a `Number`, we represent this type in the `Promise` "
"and `Aff` wrappers:"
msgstr "`Number`を返すため、この型を`Promise`と`Aff`の梱包の中で表現します。"

#. type: Fenced code block (hs)
#: text/chapter10.md:691
#, no-wrap
msgid ""
"foreign import diagonalAsyncImpl :: Int -> Number -> Number -> Effect (Promise Number)\n"
"\n"
"diagonalAsync :: Int -> Number -> Number -> Aff Number\n"
"diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y\n"
msgstr ""
"foreign import diagonalAsyncImpl :: Int -> Number -> Number -> Effect (Promise Number)\n"
"\n"
"diagonalAsync :: Int -> Number -> Number -> Aff Number\n"
"diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y\n"

#. type: Fenced code block (text)
#: text/chapter10.md:698
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"import Prelude\n"
"import Test.Examples\n"
"import Effect.Class.Console\n"
"import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   res <- diagonalAsync 300 3.0 4.0\n"
"…   logShow res\n"
"…\n"
"unit\n"
"5.0\n"
msgstr ""
"$ spago repl\n"
"\n"
"import Prelude\n"
"import Test.Examples\n"
"import Effect.Class.Console\n"
"import Effect.Aff\n"
"> :pa\n"
"… launchAff_ do\n"
"…   res <- diagonalAsync 300 3.0 4.0\n"
"…   logShow res\n"
"…\n"
"unit\n"
"5.0\n"

#. type: Plain text
#: text/chapter10.md:717
msgid ""
"Exercises for the above sections are still on the ToDo list. If you have any "
"ideas for good exercises, please make a suggestion."
msgstr ""
"上の節の演習はまだやるべきことの一覧にあります。\n"
"もし何か良い演習の考えがあればご提案ください。"

#. type: Title ##
#: text/chapter10.md:718
#, no-wrap
msgid "JSON"
msgstr "JSON"

#. type: Plain text
#: text/chapter10.md:721
msgid ""
"There are many reasons to use JSON in an application, for example, it's a "
"common means of communicating with web APIs. This section will discuss other "
"use-cases too, beginning with a technique to improve type safety when "
"passing structural data over the FFI."
msgstr ""
"アプリケーションでJSONを使うことには多くの理由があります。\n"
"例えばWebのAPIと疎通するよくある手段であるためです。\n"
"この節では他の用例についてもお話ししましょう。\n"
"構造的なデータをFFI越しに渡すことで型安全性を向上させる手法から始めます。"

#. type: Plain text
#: text/chapter10.md:723
msgid ""
"Let's revisit our earlier FFI functions `cumulativeSums` and `addComplex` "
"and introduce a bug to each:"
msgstr ""
"少し前のFFI関数`cumulativeSums`と`addComplex`を再訪し、それぞれに1つバグを混"
"入させてみましょう。"

#. type: Fenced code block (js)
#: text/chapter10.md:724
#, no-wrap
msgid ""
"export const cumulativeSumsBroken = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  sums.push(\"Broken\"); // Bug\n"
"  return sums;\n"
"};\n"
"\n"
"export const addComplexBroken = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    broken: a.imag + b.imag // Bug\n"
"  }\n"
"};\n"
msgstr ""
"export const cumulativeSumsBroken = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  sums.push(\"Broken\"); // Bug\n"
"  return sums;\n"
"};\n"
"\n"
"export const addComplexBroken = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    broken: a.imag + b.imag // Bug\n"
"  }\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:745
msgid ""
"We can use the original type signatures, and the code will still compile, "
"despite the fact that the return types are incorrect."
msgstr ""
"実際は返る型が正しくないのですが、元々の型シグネチャを使うことができ、依然と"
"してコードはコンパイルされます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:746
#, no-wrap
msgid ""
"foreign import cumulativeSumsBroken :: Array Int -> Array Int\n"
"\n"
"foreign import addComplexBroken :: Complex -> Complex -> Complex\n"
msgstr ""
"foreign import cumulativeSumsBroken :: Array Int -> Array Int\n"
"\n"
"foreign import addComplexBroken :: Complex -> Complex -> Complex\n"

#. type: Plain text
#: text/chapter10.md:753
msgid ""
"We can even execute the code, which might either produce unexpected results "
"or a runtime error:"
msgstr ""
"コードの実行さえ可能で、そうすると予期しない結果を生み出すか実行時エラーにな"
"ります。"

#. type: Fenced code block (text)
#: text/chapter10.md:754
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Foldable (sum)\n"
"\n"
"> sums = cumulativeSumsBroken [1, 2, 3]\n"
"> sums\n"
"[1,3,6,Broken]\n"
"> sum sums\n"
"0\n"
"\n"
"> complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"> complex.real\n"
"4.0\n"
"> complex.imag + 1.0\n"
"NaN\n"
"> complex.imag\n"
"  var str = n.toString();\n"
"              ^\n"
"TypeError: Cannot read property 'toString' of undefined\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Foldable (sum)\n"
"\n"
"> sums = cumulativeSumsBroken [1, 2, 3]\n"
"> sums\n"
"[1,3,6,Broken]\n"
"> sum sums\n"
"0\n"
"\n"
"> complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"> complex.real\n"
"4.0\n"
"> complex.imag + 1.0\n"
"NaN\n"
"> complex.imag\n"
"  var str = n.toString();\n"
"              ^\n"
"TypeError: Cannot read property 'toString' of undefined\n"

#. type: Plain text
#: text/chapter10.md:778
msgid ""
"For example, our resulting `sums` is no-longer a valid `Array Int`, now that "
"a `String` is included in the Array. And further operations produce "
"unexpected behavior, rather than an outright error, as the `sum` of these "
"`sums` is `0` rather than `10`. This could be a difficult bug to track down!"
msgstr ""
"例えば結果の`sums`はもはや正しい`Array Int`ではありませんが、それは`String`が"
"配列に含まれているからです。\n"
"そして更なる操作は即時のエラーではなく予期しない挙動を生み出します。\n"
"というのもこれらの`sums`の`sum`は`10`ではなく`0`だからです。\n"
"これでは捜索の難しいバグになりかねませんね。"

#. type: Plain text
#: text/chapter10.md:780
msgid ""
"Likewise, there are no errors when calling `addComplexBroken`; however, "
"accessing the `imag` field of our `Complex` result will either produce "
"unexpected behavior (returning `NaN` instead of `7.0`), or a non-obvious "
"runtime error."
msgstr ""
"同様に`addComplexBroken`を呼び出すときは1つもエラーが出ません。\n"
"しかし、`Complex`の結果の`imag`フィールドにアクセスすると予期しない挙動"
"（`7.0`ではなく`Nan`を返すため）やはっきりしない実行時エラーを生じることで"
"しょう。"

#. type: Plain text
#: text/chapter10.md:782
msgid ""
"Let's use JSON to make our PureScript code more impervious to bugs in "
"JavaScript code."
msgstr ""
"PureScriptのコードにバグ一匹通さないようにするため、JavaScriptのコードでJSON"
"を使いましょう。"

#. type: Plain text
#: text/chapter10.md:784
msgid ""
"The `argonaut` library contains the JSON decoding and encoding capabilities "
"we need. That library has excellent [documentation](https://github.com/"
"purescript-contrib/purescript-argonaut#documentation), so we will only cover "
"basic usage in this book."
msgstr ""
"`argonaut`ライブラリにはこのために必要なJSONの復号化と符号化の機能が備わって"
"います。\n"
"このライブラリには素晴らしい[ドキュメント](https://github.com/purescript-"
"contrib/purescript-argonaut#documentation)があるので、本書では基本的な用法だ"
"けを押さえます。"

#. type: Plain text
#: text/chapter10.md:786
msgid ""
"If we create an alternate foreign import that defines the return type as "
"`Json`:"
msgstr ""
"返る型を`Json`として定義するようにして、代わりとなる外部インポートをつくると"
"こうなります。"

#. type: Fenced code block (hs)
#: text/chapter10.md:787
#, no-wrap
msgid ""
"foreign import cumulativeSumsJson :: Array Int -> Json\n"
"foreign import addComplexJson :: Complex -> Complex -> Json\n"
msgstr ""
"foreign import cumulativeSumsJson :: Array Int -> Json\n"
"foreign import addComplexJson :: Complex -> Complex -> Json\n"

#. type: Plain text
#: text/chapter10.md:793
msgid "Note that we're simply pointing to our existing broken functions:"
msgstr "単純に既存の壊れた関数を指している点に注意します。"

#. type: Fenced code block (js)
#: text/chapter10.md:794
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSumsBroken\n"
"export const addComplexJson = addComplexBroken\n"
msgstr ""
"export const cumulativeSumsJson = cumulativeSumsBroken\n"
"export const addComplexJson = addComplexBroken\n"

#. type: Plain text
#: text/chapter10.md:800
msgid "And then write a wrapper to decode the returned foreign `Json` value:"
msgstr "そして返された`Json`の値を復号化する梱包を書きます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:801
#, no-wrap
msgid ""
"{{#include ../exercises/chapter10/test/Examples.purs:cumulativeSumsDecoded}}\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.purs:addComplexDecoded}}\n"
msgstr ""
"{{#include ../exercises/chapter10/test/Examples.purs:cumulativeSumsDecoded}}\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.purs:addComplexDecoded}}\n"

#. type: Plain text
#: text/chapter10.md:808
msgid ""
"Then any values that can't be successfully decoded to our return type appear "
"as a `Left` error `String`:"
msgstr ""
"そうすると返る型への復号が成功しなかったどんな値も`Left`の`String`なエラーと"
"して表れます。"

#. type: Fenced code block (text)
#: text/chapter10.md:809
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Left \"Couldn't decode Array (Failed at index 3): Value is not a Number\")\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Left \"JSON was missing expected field: imag\")\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Left \"Couldn't decode Array (Failed at index 3): Value is not a Number\")\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Left \"JSON was missing expected field: imag\")\n"

#. type: Plain text
#: text/chapter10.md:822
msgid "If we call the working versions, a `Right` value is returned."
msgstr "正常に動作するバージョンで呼び出すと`Right`の値が返ります。"

#. type: Plain text
#: text/chapter10.md:824
msgid ""
"Try this yourself by modifying `test/Examples.js` with the following change "
"to point to the working versions before running the next repl block."
msgstr ""
"次のREPLブロックを走らせる前に、正常に動作するバージョンを指すように、`test/"
"Examples.js`へ以下の変更を加えて、手元で試してみましょう。"

#. type: Fenced code block (js)
#: text/chapter10.md:825
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSums\n"
"export const addComplexJson = addComplex\n"
msgstr ""
"export const cumulativeSumsJson = cumulativeSums\n"
"export const addComplexJson = addComplex\n"

#. type: Fenced code block (text)
#: text/chapter10.md:830
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Right [1,3,6])\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Right { imag: 6.0, real: 4.0 })\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Right [1,3,6])\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Right { imag: 6.0, real: 4.0 })\n"

#. type: Plain text
#: text/chapter10.md:843
msgid ""
"Using JSON is also the easiest way to pass other structural types, such as "
"`Map` and `Set` through the FFI. Note that since JSON only consists of "
"booleans, numbers, strings, arrays, and objects of other JSON values, we "
"can't write a `Map` and `Set` directly in JSON. But we can represent these "
"structures as arrays (assuming the keys and values can also be represented "
"in JSON), and then decode them back to `Map` or `Set`."
msgstr ""
"JSONを使うことは、`Map`や`Set`のような他の構造的な型をFFI越しに渡す最も簡単な"
"方法でもあります。\n"
"ただしJSONは真偽値、数値、文字列、配列、そして他のJSONの値からなるオブジェク"
"トのみから構成されるため、JSONでは直接`Map`や`Set`を書けません。\n"
"しかしこれらの構造を配列としては表現でき（キーとバリューもまたJSONで表現され"
"ているとします）、それから`Map`や`Set`に復号し直すことができるのです。"

#. type: Plain text
#: text/chapter10.md:845
msgid ""
"Here's an example of a foreign function signature that modifies a `Map` of "
"`String` keys and `Int` values, along with the wrapper function that handles "
"JSON encoding and decoding."
msgstr ""
"以下は`String`のキーと`Int`のバリューからなる`Map`を変更する外部関数シグネ"
"チャと、それに伴うJSONの符号化と復号化を扱う梱包関数の例です。"

#. type: Fenced code block (hs)
#: text/chapter10.md:846
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:mapSetFooJson}}\n"
msgstr "{{#include ../exercises/chapter10/test/Examples.purs:mapSetFooJson}}\n"

#. type: Plain text
#: text/chapter10.md:851
msgid ""
"Note that this is a prime use case for function composition. Both of these "
"alternatives are equivalent to the above:"
msgstr ""
"関数合成の絶好の用例になっていますね。\n"
"以下の代案は両方とも上のものと等価です。"

#. type: Fenced code block (hs)
#: text/chapter10.md:852
#, no-wrap
msgid ""
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = decodeJson <<< mapSetFooJson <<< encodeJson\n"
"\n"
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = encodeJson >>> mapSetFooJson >>> decodeJson\n"
msgstr ""
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = decodeJson <<< mapSetFooJson <<< encodeJson\n"
"\n"
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = encodeJson >>> mapSetFooJson >>> decodeJson\n"

#. type: Plain text
#: text/chapter10.md:861
msgid ""
"Here is the JavaScript implementation. Note the `Array.from` step which is "
"necessary to convert the JavaScript `Map` into a JSON-friendly format before "
"decoding converts it back to a PureScript `Map`."
msgstr ""
"以下はJavaScriptでの実装です。\n"
"なお、`Array.from`の工程は、復号の前にJavaScriptの`Map`をJSONに親和性のある形"
"式に変換し、PureScriptの`Map`に変換し直すために必須です。"

#. type: Fenced code block (js)
#: text/chapter10.md:862
#, no-wrap
msgid ""
"export const mapSetFooJson = j => {\n"
"  let m = new Map(j);\n"
"  m.set(\"Foo\", 42);\n"
"  return Array.from(m);\n"
"};\n"
msgstr ""
"export const mapSetFooJson = j => {\n"
"  let m = new Map(j);\n"
"  m.set(\"Foo\", 42);\n"
"  return Array.from(m);\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:871
msgid "Now we can send and receive a `Map` over the FFI:"
msgstr "これで`Map`をFFI越しに送ったり受け取ったりできます。"

#. type: Fenced code block (text)
#: text/chapter10.md:872
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Map\n"
"> import Data.Tuple\n"
"\n"
"> myMap = fromFoldable [ Tuple \"hat\" 1, Tuple \"cat\" 2 ]\n"
"\n"
"> :type myMap\n"
"Map String Int\n"
"\n"
"> myMap\n"
"(fromFoldable [(Tuple \"cat\" 2),(Tuple \"hat\" 1)])\n"
"\n"
"> mapSetFoo myMap\n"
"(Right (fromFoldable [(Tuple \"Foo\" 42),(Tuple \"cat\" 2),(Tuple \"hat\" 1)]))\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Map\n"
"> import Data.Tuple\n"
"\n"
"> myMap = fromFoldable [ Tuple \"hat\" 1, Tuple \"cat\" 2 ]\n"
"\n"
"> :type myMap\n"
"Map String Int\n"
"\n"
"> myMap\n"
"(fromFoldable [(Tuple \"cat\" 2),(Tuple \"hat\" 1)])\n"
"\n"
"> mapSetFoo myMap\n"
"(Right (fromFoldable [(Tuple \"Foo\" 42),(Tuple \"cat\" 2),(Tuple \"hat\" 1)]))\n"

#. type: Bullet: '1. '
#: text/chapter10.md:900
msgid ""
"(Medium) Write a JavaScript function and PureScript wrapper `valuesOfMap :: "
"Map String Int -> Either JsonDecodeError (Set Int)` that returns a `Set` of "
"all the values in a `Map`. _Hint_: The `.values()` instance method for Map "
"may be useful in your JavaScript code."
msgstr ""
"（普通）`Map`中の全てのバリューの`Set`を返すJavaScriptの関数とPureScriptの梱"
"包`valuesOfMap :: Map String Int -> Either JsonDecodeError (Set Int)`を書いて"
"ください。"

#. type: Bullet: '1. '
#: text/chapter10.md:900
msgid ""
"(Easy) Write a new wrapper for the previous JavaScript function with the "
"signature `valuesOfMapGeneric :: forall k v. Map k v -> Either "
"JsonDecodeError (Set v)` so it works with a wider variety of maps. Note that "
"you'll need to add some type class constraints for `k` and `v`. The compiler "
"will guide you."
msgstr ""
"（簡単）より広い種類のマップに関して動作するよう、前のJavaScriptの関数の新し"
"い梱包を書いてください。\n"
"シグネチャは`valuesOfMapGeneric :: forall k v. Map k v -> Either "
"JsonDecodeError (Set v)`です。\n"
"なお`k`と`v`に幾つかの型クラス制約を加える必要があるでしょう。\n"
"コンパイラが導いてくれます。"

#. type: Bullet: '1. '
#: text/chapter10.md:900
msgid ""
"(Medium) Rewrite the earlier `quadraticRoots` function as "
"`quadraticRootsSet` which returns the `Complex` roots as a `Set` via JSON "
"(instead of as a `Pair`)."
msgstr ""
"（普通）少し前の`quadraticRoots`を書き換えて`quadraticRootSet`としてくださ"
"い。\n"
"この関数は`Complex`の根をJSONを介して（`Pair`の代わりに）`Set`として返しま"
"す。"

#. type: Plain text
#: text/chapter10.md:900
#, no-wrap
msgid ""
"1. (Difficult) Rewrite the earlier `quadraticRoots` function as `quadraticRootsSafe` which uses JSON to pass the `Pair` of `Complex` roots over FFI. Don't use the `Pair` constructor in JavaScript, but instead, just return the pair in a decoder-compatible format.\n"
"_Hint_: You'll need to write a `DecodeJson` instance for `Pair`. Consult the [argonaut docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances) for instruction on writing your own decode instance. Their [decodeJsonTuple](https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs) instance may also be a helpful reference.  Note that you'll need a `newtype` wrapper for `Pair` to avoid creating an \"orphan instance\".\n"
"1. (Medium) Write a `parseAndDecodeArray2D :: String -> Either String (Array (Array Int))` function to parse and decode a JSON string containing a 2D array, such as `\"[[1, 2, 3], [4, 5], [6]]\"`. _Hint_: You'll need to use `jsonParser` to convert the `String` into `Json` before decoding.\n"
"1. (Medium) The following data type represents a binary tree with values at the leaves:\n"
msgstr ""
"1. （難しい）少し前の`quadraticRoots`を書き換えて`quadraticRootsSafe`としてください。\n"
"   この関数はJSONを使って`Complex`の根の`Pair`をFFI越しに渡します。\n"
"   JavaScriptでは`Pair`構築子を使わないでください。\n"
"   その代わり、復号器に互換性のある形式で対を返すだけにしてください。\n"
"   *手掛かり*：`DecodeJson`インタンスを`Pair`用に書く必要があるでしょう。\n"
"   独自の復号インスタンスを書く上での説明については[argonautのドキュメント](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances)をあたってください。\n"
"   [decodeJsonTuple](https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs)インスタンスも参考になるかもしれません。\n"
"  「孤立インスタンス」を作ることを避けるために、`Pair`に`newtype`の梱包が必要になる点に注意してください。\n"
"1. （普通）2次元配列を含むJSON文字列を構文解析して復号する`parseAndDecodeArray2D :: String -> Either String (Array (Array Int))`関数を書いてください。\n"
"   例えば`\"[[1, 2, 3], [4, 5], [6]]\"`です。\n"
"   *手掛かり*：復号の前に`jsonParser`を使って`String`を`Json`に変換する必要があるでしょう。\n"
"1. （普通）以下のデータ型は値が葉にある二分木を表現します。\n"

#. type: Plain text
#: text/chapter10.md:906
#, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a\n"
"       = Leaf a\n"
"       | Branch (Tree a) (Tree a)\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data Tree a\n"
"       = Leaf a\n"
"       | Branch (Tree a) (Tree a)\n"
"     ```\n"

#. type: Plain text
#: text/chapter10.md:911
#, no-wrap
msgid ""
"     Derive generic `EncodeJson` and `DecodeJson` instances for the `Tree` type.\n"
"     Consult the [argonaut docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics) for instructions on how to do this.\n"
"     Note that you'll also need generic instances of `Show` and `Eq` to enable unit testing for this exercise, but those should be straightforward to implement after tackling the JSON instances.\n"
"1. (Difficult) The following `data` type should be represented directly in JSON as either an integer or a string:\n"
msgstr ""
"     汎化された`EncodeJson`及び`DecodeJson`インスタンスを`Tree`型用に導出してください。\n"
"     このやり方についての説明は[argonautのドキュメント](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics)をあたってください。\n"
"     なお、この演習の単体試験を有効にするには、汎化された`Show`及び`Eq`インスタンスも必要になります。\n"
"     しかしJSONのインスタンスと格闘したあとでは、これらの実装は直感的に進むことでしょう。\n"
"1. （難しい）以下の`data`型は整数か文字列かによってJSONで異なって表現されます。\n"

#. type: Plain text
#: text/chapter10.md:917
#, no-wrap
msgid ""
"     ```haskell\n"
"     data IntOrString\n"
"       = IntOrString_Int Int\n"
"       | IntOrString_String String\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data IntOrString\n"
"       = IntOrString_Int Int\n"
"       | IntOrString_String String\n"
"     ```\n"

#. type: Plain text
#: text/chapter10.md:919
#, no-wrap
msgid "     Write instances of `EncodeJson` and `DecodeJson` for the `IntOrString` data type which implement this behavior. _Hint_: The `alt` operator from `Control.Alt` may be helpful.\n"
msgstr ""
"     この挙動を実装する`IntOrString`データ型に、`EncodeJson`及び`DecodeJson`インスタンスを書いてください。\n"
"     *手掛かり*：`Control.Alt`の`alt`演算子が役立つかもしれません。\n"

#. type: Title ##
#: text/chapter10.md:920
#, no-wrap
msgid "Address book"
msgstr "住所録"

#. type: Plain text
#: text/chapter10.md:923
msgid ""
"In this section we will apply our newly-acquired FFI and JSON knowledge to "
"build on our address book example from chapter 8. We will add the following "
"features:"
msgstr ""
"この節では新しく獲得したFFIとJSONの知識を応用して、第8章の住所録の例を構築し"
"ていきたいと思います。\n"
"以下の機能を加えていきます。"

#. type: Bullet: '- '
#: text/chapter10.md:927
msgid ""
"A Save button at the bottom of the form that, when clicked, serializes the "
"state of the form to JSON and saves it in local storage."
msgstr ""
"保存ボタンをフォームの一番下に配置し、クリックしたときにフォームの状態をJSON"
"に直列化してローカルストレージに保存します。"

#. type: Bullet: '- '
#: text/chapter10.md:927
msgid ""
"Automatic retrieval of the JSON document from local storage upon page "
"reload. The form fields are populated with the contents of this document."
msgstr ""
"ページの再読み込み時にローカルストレージからJSON文書を自動的に取得します。\n"
"フォームのフィールドにはこの文書の内容を入れます。"

#. type: Bullet: '- '
#: text/chapter10.md:927
msgid "A pop-up alert if there is an issue saving or loading the form state."
msgstr ""
"フォームの状態を保存したり読み込んだりするのに問題があればポップアップの警告"
"を出します。"

#. type: Plain text
#: text/chapter10.md:929
msgid ""
"We'll start by creating FFI wrappers for the following Web Storage APIs in "
"our `Effect.Storage` module:"
msgstr ""
"`Effect.Storage`モジュールに以下のWebストレージAPIのためのFFIの梱包をつくるこ"
"とから始めていきます。"

#. type: Bullet: '- '
#: text/chapter10.md:932
msgid ""
"`setItem` takes a key and a value (both strings), and returns a computation "
"which stores (or updates) the value in local storage at the specified key."
msgstr ""
"`setItem`はキーと値（両方とも文字列）を受け取り、指定されたキーでローカルスト"
"レージに値を格納する計算を返します。"

#. type: Bullet: '- '
#: text/chapter10.md:932
msgid ""
"`getItem` takes a key, and attempts to retrieve the associated value from "
"local storage. However, since the `getItem` method on `window.localStorage` "
"can return `null`, the return type is not `String`, but `Json`."
msgstr ""
"`getItem`はキーを取り、ローカルストレージから関連付けられたバリューの取得を試"
"みます。\n"
"しかし`window.localStorage`の`getItem`メソッドは`null`を返しうるので、返る型"
"は`String`ではなく`Json`です。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:933
#, no-wrap
msgid ""
"foreign import setItem :: String -> String -> Effect Unit\n"
"\n"
"foreign import getItem :: String -> Effect Json\n"
msgstr ""
"foreign import setItem :: String -> String -> Effect Unit\n"
"\n"
"foreign import getItem :: String -> Effect Json\n"

#. type: Plain text
#: text/chapter10.md:940
msgid ""
"Here is the corresponding JavaScript implementation of these functions in "
"`Effect/Storage.js`:"
msgstr ""
"以下はこれらの関数に対応するJavaScriptの実装で、`Effect/Storage.js`にありま"
"す。"

#. type: Fenced code block (js)
#: text/chapter10.md:941
#, no-wrap
msgid ""
"export const setItem = key => value => () =>\n"
"  window.localStorage.setItem(key, value);\n"
"\n"
"export const getItem = key => () =>\n"
"  window.localStorage.getItem(key);\n"
msgstr ""
"export const setItem = key => value => () =>\n"
"  window.localStorage.setItem(key, value);\n"
"\n"
"export const getItem = key => () =>\n"
"  window.localStorage.getItem(key);\n"

#. type: Plain text
#: text/chapter10.md:950
msgid "We'll create a save button like so:"
msgstr "以下のように保存ボタンを作ります。"

#. type: Fenced code block (hs)
#: text/chapter10.md:951
#, no-wrap
msgid ""
"saveButton :: R.JSX\n"
"saveButton =\n"
"  D.label\n"
"    { className: \"form-group row col-form-label\"\n"
"    , children:\n"
"        [ D.button\n"
"            { className: \"btn-primary btn\"\n"
"            , onClick: handler_ validateAndSave\n"
"            , children: [ D.text \"Save\" ]\n"
"            }\n"
"        ]\n"
"    }\n"
msgstr ""
"saveButton :: R.JSX\n"
"saveButton =\n"
"  D.label\n"
"    { className: \"form-group row col-form-label\"\n"
"    , children:\n"
"        [ D.button\n"
"            { className: \"btn-primary btn\"\n"
"            , onClick: handler_ validateAndSave\n"
"            , children: [ D.text \"Save\" ]\n"
"            }\n"
"        ]\n"
"    }\n"

#. type: Plain text
#: text/chapter10.md:967
msgid ""
"And write our validated `person` as a JSON string with `setItem` in the "
"`validateAndSave` function:"
msgstr ""
"そして`validateAndSave`関数中では、検証された`person`をJSON文字列とし、"
"`setItem`を使って書き込みます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:968
#, no-wrap
msgid ""
"validateAndSave :: Effect Unit\n"
"validateAndSave = do\n"
"  log \"Running validators\"\n"
"  case validatePerson' person of\n"
"    Left errs -> log $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"    Right validPerson -> do\n"
"      setItem \"person\" $ stringify $ encodeJson validPerson\n"
"      log \"Saved\"\n"
msgstr ""
"validateAndSave :: Effect Unit\n"
"validateAndSave = do\n"
"  log \"Running validators\"\n"
"  case validatePerson' person of\n"
"    Left errs -> log $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"    Right validPerson -> do\n"
"      setItem \"person\" $ stringify $ encodeJson validPerson\n"
"      log \"Saved\"\n"

#. type: Plain text
#: text/chapter10.md:980
msgid ""
"Note that if we attempt to compile at this stage, we'll encounter the "
"following error:"
msgstr "なおこの段階でコンパイルしようとすると以下のエラーに遭遇します。"

#. type: Fenced code block (text)
#: text/chapter10.md:981
#, no-wrap
msgid ""
"  No type class instance was found for\n"
"    Data.Argonaut.Encode.Class.EncodeJson PhoneType\n"
msgstr ""
"  No type class instance was found for\n"
"    Data.Argonaut.Encode.Class.EncodeJson PhoneType\n"

#. type: Plain text
#: text/chapter10.md:987
msgid ""
"This is because `PhoneType` in the `Person` record needs an `EncodeJson` "
"instance. We'll just derive a generic encode instance, and a decode instance "
"too while we're at it. More information how this works is available in the "
"argonaut docs:"
msgstr ""
"これはなぜかというと`Person`レコード中の`PhoneType`が`EncodeJson`インスタンス"
"を必要としているからです。\n"
"単純に汎用符号化インスタンスと復号化インスタンスを導出すれば完了です。\n"
"この仕組みについて、より詳しくはargonautのドキュメントで見られます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:988
#, no-wrap
msgid ""
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:import}}\n"
"\n"
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:PhoneType_generic}}\n"
msgstr ""
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:import}}\n"
"\n"
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:PhoneType_generic}}\n"

#. type: Plain text
#: text/chapter10.md:995
msgid ""
"Now we can save our `person` to local storage, but this isn't very useful "
"unless we can retrieve the data. We'll tackle that next."
msgstr ""
"これで`person`をローカルストレージに保存できます。\n"
"しかしデータを取得できない限りあまり便利ではありません。\n"
"次はそれに取り掛かりましょう。"

#. type: Plain text
#: text/chapter10.md:997
msgid "We'll start with retrieving the \"person\" string from local storage:"
msgstr "ローカルストレージから「person」文字列で取得することから始めましょう。"

#. type: Fenced code block (hs)
#: text/chapter10.md:998
#, no-wrap
msgid "item <- getItem \"person\"\n"
msgstr "item <- getItem \"person\"\n"

#. type: Plain text
#: text/chapter10.md:1003
msgid ""
"Then we'll create a helper function to handle converting the string from "
"local storage to our `Person` record. Note that this string in storage may "
"be `null`, so we represent it as a foreign `Json` until it is successfully "
"decoded as a `String`. There are a number of other conversion steps along "
"the way - each of which return an `Either` value, so it makes sense to "
"organize these together in a `do` block."
msgstr ""
"そうしてローカルストレージから、文字列から`Person`レコードへの変換を扱う補助"
"関数をつくります。なおこのストレージ中の文字列は`null`かもしれないので、うま"
"く`String`として復号化されるまでは外部の`Json`として表現します。道中には他に"
"も多くの変換工程があり、それぞれで`Either`の値を返します。そのためこれらを"
"`do`ブロックの中に纏めるのは理に適っています。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1004
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- decodeJson item\n"
"  j          <- jsonParser jsonString\n"
"  decodeJson j\n"
msgstr ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- decodeJson item\n"
"  j          <- jsonParser jsonString\n"
"  decodeJson j\n"

#. type: Plain text
#: text/chapter10.md:1013
msgid ""
"Then we inspect this result to see if it succeeded. If it failed, we'll log "
"the errors and use our default `examplePerson`, otherwise we'll use the "
"person retrieved from local storage."
msgstr ""
"そうしてこの結果が成功しているかどうか調べます。\n"
"もし失敗していればエラーをログ出力し、既定の`examplePerson`を使います。\n"
"そうでなければローカルストレージから取得した人物を使います。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1014
#, no-wrap
msgid ""
"initialPerson <- case processItem item of\n"
"  Left  err -> do\n"
"    log $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
"    pure examplePerson\n"
"  Right p   -> pure p\n"
msgstr ""
"initialPerson <- case processItem item of\n"
"  Left  err -> do\n"
"    log $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
"    pure examplePerson\n"
"  Right p   -> pure p\n"

#. type: Plain text
#: text/chapter10.md:1023
msgid ""
"Finally, we'll pass this `initialPerson` to our component via the `props` "
"record:"
msgstr ""
"最後にこの`initialPerson`を`props`レコードを介してコンポーネントに渡します。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1024
#, no-wrap
msgid ""
"-- Create JSX node from react component.\n"
"app = element addressBookApp { initialPerson }\n"
msgstr ""
"-- Create JSX node from react component.\n"
"app = element addressBookApp { initialPerson }\n"

#. type: Plain text
#: text/chapter10.md:1030
msgid "And pick it up on the other side to use in our state hook:"
msgstr "そして状態フックで使うために別の箇所で拾い上げます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1031
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })\n"
"mkAddressBookApp =\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState props.initialPerson\n"
msgstr ""
"mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })\n"
"mkAddressBookApp =\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState props.initialPerson\n"

#. type: Plain text
#: text/chapter10.md:1039
msgid ""
"As a finishing touch, we'll improve the quality of our error messages by "
"appending to the `String` of each `Left` value with `lmap`."
msgstr ""
"仕上げとして、それぞれの`Left`値の`String`に`lmap`を使って前置し、エラー文言"
"の質を向上させます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1040
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- lmap (\"No string in local storage: \" <> _) $ decodeJson item\n"
"  j          <- lmap (\"Cannot parse JSON string: \"   <> _) $ jsonParser jsonString\n"
"  lmap               (\"Cannot decode Person: \"       <> _) $ decodeJson j\n"
msgstr ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- lmap (\"No string in local storage: \" <> _) $ decodeJson item\n"
"  j          <- lmap (\"Cannot parse JSON string: \"   <> _) $ jsonParser jsonString\n"
"  lmap               (\"Cannot decode Person: \"       <> _) $ decodeJson j\n"

#. type: Plain text
#: text/chapter10.md:1049
msgid ""
"Only the first error should ever occur during normal operation of this app. "
"You can trigger the other errors by opening your web browser's dev tools, "
"editing the saved \"person\" string in local storage, and refreshing the "
"page. How you modify the JSON string determines which error is triggered. "
"See if you can trigger each of them."
msgstr ""
"最初のエラーのみがこのアプリの通常の操作内で起こります。\n"
"他のエラーはWebブラウザの開発ツールを開いてローカルストレージ中に保存された"
"「person」文字列を編集し、そのページを参照することで引き起こせます。\n"
"どのようにJSON文字列を変更したかが、どのエラーの引き金になるかを決定しま"
"す。\n"
"それぞれのエラーを引き起こせるかどうかやってみてください。"

#. type: Plain text
#: text/chapter10.md:1051
msgid ""
"That covers local storage. Next we'll implement the `alert` action, which is "
"very similar to the `log` action from the `Effect.Console` module. The only "
"difference is that the `alert` action uses the `window.alert` method, "
"whereas the `log` action uses the `console.log` method. As such, `alert` can "
"only be used in environments where `window.alert` is defined, such as a web "
"browser."
msgstr ""
"これでローカルストレージについては押さえました。\n"
"次に`alert`アクションを実装していきます。\n"
"このアクションは`Effect.Console`モジュールの`log`アクションによく似ていま"
"す。\n"
"唯一の相違点は`alert`アクションが`window.alert`メソッドを使うことで、対して"
"`log`アクションは`console.log`メソッドを使っています。\n"
"そういうわけで`alert`は`window.alert`が定義された環境でのみ使うことができま"
"す。\n"
"例えばWebブラウザなどです。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1052
#, no-wrap
msgid "foreign import alert :: String -> Effect Unit\n"
msgstr "foreign import alert :: String -> Effect Unit\n"

#. type: Fenced code block (js)
#: text/chapter10.md:1056
#, no-wrap
msgid ""
"export const alert = msg => () =>\n"
"  window.alert(msg);\n"
msgstr ""
"export const alert = msg => () =>\n"
"  window.alert(msg);\n"

#. type: Plain text
#: text/chapter10.md:1062
msgid "We want this alert to appear when either:"
msgstr "この警告が次の何れかの場合に現れるようにしたいです。"

#. type: Bullet: '- '
#: text/chapter10.md:1065
msgid "A user attempts to save a form with validation errors."
msgstr "利用者が検証エラーを含むフォームを保存しようと試みている。"

#. type: Bullet: '- '
#: text/chapter10.md:1065
msgid "The state cannot be retrieved from local storage."
msgstr "状態がローカルストレージから取得できない。"

#. type: Plain text
#: text/chapter10.md:1067
msgid ""
"That is accomplished by simply replacing `log` with `alert` on these lines:"
msgstr "以上は単に以下の行で`log`を`alert`に置き換えるだけで達成できます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1068
#, no-wrap
msgid ""
"Left errs -> alert $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"\n"
"alert $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
msgstr ""
"Left errs -> alert $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"\n"
"alert $ \"Error: \" <> err <> \". Loading examplePerson\"\n"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1080
msgid ""
"(Easy) Write a wrapper for the `removeItem` method on the `localStorage` "
"object, and add your foreign function to the `Effect.Storage` module."
msgstr ""
"（普通）`localStorage`オブジェクトの `removeItem`メソッドの梱包を書き、 "
"`Effect.Storage`モジュールに外部関数を追加してください"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1080
msgid ""
"(Medium) Add a \"Reset\" button that, when clicked, calls the newly-created "
"`removeItem` function to delete the \"person\" entry from local storage."
msgstr ""
"（普通）「リセット」ボタンを追加してください。\n"
"このボタンをクリックすると新しく作った`removeItem`関数を呼び出してローカルス"
"トレージから「人物」の項目を削除します。"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1080
msgid ""
"(Easy) Write a wrapper for the `confirm` method on the JavaScript `Window` "
"object, and add your foreign function to the `Effect.Alert` module."
msgstr ""
"（簡単）JavaScriptの `Window`オブジェクトの `confirm`メソッドの梱包を書き、 "
"`Effect.Alert`モジュールにその外部関数を追加してください。"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1080
msgid ""
"(Medium) Call this `confirm` function when a users clicks the \"Reset\" "
"button to ask if they're sure they want to reset their address book."
msgstr ""
"（普通）利用者が「リセット」ボタンをクリックしたときにこの`confirm`関数を呼び"
"出し、本当にアドレス帳を白紙にしたいか尋ねるようにしてください。"

#. type: Title ##
#: text/chapter10.md:1081 text/chapter11.md:964 text/chapter12.md:594
#: text/chapter13.md:401 text/chapter14.md:721 text/chapter2.md:121
#: text/chapter3.md:722 text/chapter4.md:631 text/chapter5.md:529
#: text/chapter6.md:756 text/chapter7.md:691 text/chapter8.md:1000
#: text/chapter9.md:235
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: text/chapter10.md:1084
msgid ""
"In this chapter, we've learned how to work with foreign JavaScript code from "
"PureScript and we've seen the issues involved with writing trustworthy code "
"using the FFI:"
msgstr ""
"この章では、PureScriptから外部のJavaScriptコードを扱う方法を学びました。ま"
"た、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。"

#. type: Bullet: '- '
#: text/chapter10.md:1088
msgid ""
"We've seen the importance of ensuring that foreign functions have correct "
"representations."
msgstr "外部関数が正しい表現を持っていることを確かめる重要性を見てきました。"

#. type: Bullet: '- '
#: text/chapter10.md:1088
msgid ""
"We learned how to deal with corner cases like null values and other types of "
"JavaScript data, by using foreign types, or the `Json` data type."
msgstr ""
"外部型や`Json`データ型を使用することによって、null値やJavaScriptの他の型の"
"データのような特殊な場合に対処する方法を学びました。"

#. type: Bullet: '- '
#: text/chapter10.md:1088
msgid "We saw how to safely serialize and deserialize JSON data."
msgstr "安全にJSONデータを直列化・直列化復元する方法を見ました。"

#. type: Plain text
#: text/chapter10.md:1090
msgid ""
"For more examples, the `purescript`, `purescript-contrib` and `purescript-"
"node` GitHub organizations provide plenty of examples of libraries which use "
"the FFI. In the remaining chapters, we will see some of these libraries put "
"to use to solve real-world problems in a type-safe way."
msgstr ""
"より多くの例については、Githubの `purescript`組織、`purescript-contrib`組織お"
"よび `purescript-node`組織が、FFIを使用するライブラリの例を多数提供していま"
"す。残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリ"
"を幾つか見ていきます。"

#. type: Title ##
#: text/chapter10.md:1091
#, no-wrap
msgid "Addendum"
msgstr "補遺"

#. type: Title ###
#: text/chapter10.md:1093
#, no-wrap
msgid "Calling PureScript from JavaScript"
msgstr "JavaScriptからPureScriptを呼び出す"

#. type: Plain text
#: text/chapter10.md:1096
msgid ""
"Calling a PureScript function from JavaScript is very simple, at least for "
"functions with simple types."
msgstr ""
"少なくとも単純な型を持つ関数については、JavaScriptからPureScript関数を呼び出"
"すのはとても簡単です。"

#. type: Plain text
#: text/chapter10.md:1098
msgid "Let's take the following simple module as an example:"
msgstr "例として以下のような簡単なモジュールを見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1099
#, no-wrap
msgid ""
"module Test where\n"
"\n"
"gcd :: Int -> Int -> Int\n"
"gcd 0 m = m\n"
"gcd n 0 = n\n"
"gcd n m\n"
"  | n > m     = gcd (n - m) m\n"
"  | otherwise = gcd (m - n) n\n"
msgstr ""
"module Test where\n"
"\n"
"gcd :: Int -> Int -> Int\n"
"gcd 0 m = m\n"
"gcd n 0 = n\n"
"gcd n m\n"
"  | n > m     = gcd (n - m) m\n"
"  | otherwise = gcd (m - n) n\n"

#. type: Plain text
#: text/chapter10.md:1111
msgid ""
"This function finds the greatest common divisor of two numbers by repeated "
"subtraction. It is a nice example of a case where you might like to use "
"PureScript to define the function, but have a requirement to call it from "
"JavaScript: it is simple to define this function in PureScript using pattern "
"matching and recursion, and the implementor can benefit from the use of the "
"type checker."
msgstr ""
"この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。\n"
"PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装す"
"る開発者は型検証器の恩恵を受けることができます。\n"
"そういうわけで関数を定義するのにPureScriptを使いたくなるかもしれない良い例と"
"なっていますが、JavaScriptからそれを呼び出すためには条件があります。"

#. type: Plain text
#: text/chapter10.md:1113
msgid ""
"To understand how this function can be called from JavaScript, it is "
"important to realize that PureScript functions always get turned into "
"JavaScript functions of a single argument, so we need to apply its arguments "
"one-by-one:"
msgstr ""
"この関数をJavaScriptから呼び出す方法を理解する上で重要なのは、PureScriptの関"
"数は常に引数が1つのJavaScript関数へと変換され、引数へは次のように1つずつ適用"
"していかなければならないということです。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1114
#, no-wrap
msgid ""
"import Test from 'Test.js';\n"
"Test.gcd(15)(20);\n"
msgstr ""
"import Test from 'Test.js';\n"
"Test.gcd(15)(20);\n"

#. type: Plain text
#: text/chapter10.md:1120
msgid ""
"Here, I am assuming that the code was compiled with `spago build`, which "
"compiles PureScript modules to ES modules. For that reason, I was able to "
"reference the `gcd` function on the `Test` object, after importing the "
"`Test` module using `import`."
msgstr ""
"ここでは、コードがPureScriptモジュールをESモジュールにコンパイルする `spago "
"build`でコンパイルされていると仮定しています。そのため、 `import`を使って "
"`Test`モジュールをインポートした後、 `Test`オブジェクトの `gcd`関数を参照でき"
"ました。"

#. type: Plain text
#: text/chapter10.md:1122
msgid ""
"You might also like to bundle JavaScript code for the browser, using `spago "
"bundle-app --to file.js`. In that case, you would access the `Test` module "
"from the global PureScript namespace, which defaults to `PS`:"
msgstr ""
"`pulp build -O --to file.js`を使用して、ブラウザ用のJavaScriptコードもバンド"
"ルできます。\n"
"その場合、大域的なPureScript名前空間から `Test`モジュールにアクセスします。\n"
"既定では`PS`です。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1123
#, no-wrap
msgid ""
"var Test = PS.Test;\n"
"Test.gcd(15)(20);\n"
msgstr ""
"var Test = PS.Test;\n"
"Test.gcd(15)(20);\n"

#. type: Title ###
#: text/chapter10.md:1128
#, no-wrap
msgid "Understanding Name Generation"
msgstr "名前の生成を理解する"

#. type: Plain text
#: text/chapter10.md:1131
msgid ""
"PureScript aims to preserve names during code generation as much as "
"possible. In particular, most identifiers which are neither PureScript nor "
"JavaScript keywords can be expected to be preserved, at least for names of "
"top-level declarations."
msgstr ""
"PureScriptはコード生成時にできるだけ名前を保存することを目的としています。具"
"体的には、少なくともトップレベルで宣言される名前については、PureScriptや"
"JavaScriptのキーワードでなければほとんどの識別子が保存されます。"

#. type: Plain text
#: text/chapter10.md:1133
msgid ""
"If you decide to use a JavaScript keyword as an identifier, the name will be "
"escaped with a double dollar symbol. For example,"
msgstr ""
"識別子としてJavaScriptのキーワードを使う場合は、名前は2重のドル記号でエスケー"
"プされます。\n"
"例えば次のPureScriptコードを考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1134
#, no-wrap
msgid "null = []\n"
msgstr "null = []\n"

#. type: Plain text
#: text/chapter10.md:1139 text/chapter10.md:1151
msgid "generates the following JavaScript:"
msgstr "これは以下のJavaScriptを生成します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1140
#, no-wrap
msgid "var $$null = [];\n"
msgstr "var $$null = [];\n"

#. type: Plain text
#: text/chapter10.md:1145
msgid ""
"In addition, if you would like to use special characters in your identifier "
"names, they will be escaped using a single dollar symbol. For example,"
msgstr ""
"また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープ"
"されます。\n"
"例えばこのPureScriptコードを考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1146
#, no-wrap
msgid "example' = 100\n"
msgstr "example' = 100\n"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1152
#, no-wrap
msgid "var example$prime = 100;\n"
msgstr "var example$prime = 100;\n"

#. type: Plain text
#: text/chapter10.md:1157
msgid ""
"Where compiled PureScript code is intended to be called from JavaScript, it "
"is recommended that identifiers only use alphanumeric characters, and avoid "
"JavaScript keywords. If user-defined operators are provided for use in "
"PureScript code, it is good practice to provide an alternative function with "
"an alphanumeric name for use in JavaScript."
msgstr ""
"コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図してい"
"る場合、識別子は英数字のみを使用し、JavaScriptの予約語を避けることをお勧めし"
"ます。\n"
"ユーザ定義演算子がPureScriptコードでの使用のために提供される場合でも、"
"JavaScriptから使うための英数字の名前を持つ代替関数を提供しておくことをお勧め"
"します。"

#. type: Title ###
#: text/chapter10.md:1158
#, no-wrap
msgid "Runtime Data Representation"
msgstr "実行時のデータ表現"

#. type: Plain text
#: text/chapter10.md:1161
msgid ""
"Types allow us to reason at compile-time that our programs are \"correct\" "
"in some sense - that is, they will not break at runtime. But what does that "
"mean? In PureScript, it means that the type of an expression should be "
"compatible with its representation at runtime."
msgstr ""
"型はプログラムがある意味で「正しい」ことをコンパイル時に判断できるようにしま"
"す。\n"
"つまり、その点については壊れることがありません。\n"
"しかし、これは何を意味するのでしょうか。\n"
"PureScriptでは式の型は実行時の表現と互換性がなければならないことを意味しま"
"す。"

#. type: Plain text
#: text/chapter10.md:1163
msgid ""
"For that reason, it is important to understand the representation of data at "
"runtime to be able to use PureScript and JavaScript code together "
"effectively. This means that for any given PureScript expression, we should "
"be able to understand the behavior of the value it will evaluate to at "
"runtime."
msgstr ""
"そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行"
"時のデータ表現について理解することが重要です。\n"
"これはつまり、与えられた任意のPureScriptの式について、その値が実行時にどのよ"
"うに評価されるかという挙動を理解できるべきだということです。"

#. type: Plain text
#: text/chapter10.md:1165
msgid ""
"The good news is that PureScript expressions have particularly simple "
"representations at runtime. It should always be possible to understand the "
"runtime data representation of an expression by considering its type."
msgstr ""
"幸いにもPureScriptの式はとりわけ実行時に単純な表現を持っています。\n"
"型を考慮すれば式の実行時のデータ表現を把握することが常に可能です。"

#. type: Plain text
#: text/chapter10.md:1167
msgid ""
"For simple types, the correspondence is almost trivial. For example, if an "
"expression has the type `Boolean`, then its value `v` at runtime should "
"satisfy `typeof v === 'boolean'`. That is, expressions of type `Boolean` "
"evaluate to one of the (JavaScript) values `true` or `false`. In particular, "
"there is no PureScript expression of type `Boolean` which evaluates to "
"`null` or `undefined`."
msgstr ""
"単純な型については、対応関係はほとんど自明です。\n"
"例えば式が型 `Boolean`を持っていれば、実行時のその値 `v`は `typeof v === "
"'boolean'`を満たします。\n"
"つまり、型 `Boolean`の式は `true`もしくは `false`のどちらか一方の（JavaScript"
"の）値へと評価されます。\n"
"特に`null`や `undefined`に評価される型`Boolean`なPureScriptの式はありません。"

#. type: Plain text
#: text/chapter10.md:1169
msgid ""
"A similar law holds for expressions of type `Int`, `Number`, and `String` - "
"expressions of type `Int` or `Number` evaluate to non-null JavaScript "
"numbers, and expressions of type `String` evaluate to non-null JavaScript "
"strings. Expressions of type `Int` will evaluate to integers at runtime, "
"even though they cannot be distinguished from values of type `Number` by "
"using `typeof`."
msgstr ""
"`Int`や`Number`や`String`の型の式についても同様のことが成り立ちます。\n"
"`Int`や`Number`型の式は `null`でないJavaScriptの数へと評価されますし、 "
"`String`型の式は `null`でないJavaScriptの文字列へと評価されます。\n"
"`typeof`を使った場合に型`Number`の値と見分けがつかなくなるにせよ、型`Int`の式"
"は実行時に整数に評価されます。"

#. type: Plain text
#: text/chapter10.md:1171
msgid ""
"What about `Unit`? Well, since `Unit` has only one inhabitant (`unit`) and "
"its value is not observable, it doesn't actually matter what it's "
"represented with at runtime. Old code tends to represent it using `{}`. "
"Newer code, however, tends to use `undefined`. So, although it doesn't "
"really matter what you use to represent `Unit`, it is recommended to use "
"`undefined` (not returning anything from a function also returns "
"`undefined`)."
msgstr ""
"`Unit`についてはどうでしょうか。\n"
"`Unit`には現住 (`unit`) が1つのみで値が観測できないため、実のところ実行時に何"
"で表現されるかは重要ではありません。\n"
"古いコードは`{}`を使って表現する傾向がありました。\n"
"しかし比較的新しいコードでは`undefined`を使う傾向にあります。\n"
"なので、`Unit`を表現するのに使うものは本当に何でも問題にならないのですが、"
"`undefined`を使うことが推奨されます（関数から何も返さないときも`undefined`を"
"返します）。"

#. type: Plain text
#: text/chapter10.md:1173
msgid "What about some more complex types?"
msgstr "もっと複雑な型についてはどうでしょうか。"

#. type: Plain text
#: text/chapter10.md:1175
#, no-wrap
msgid "As we have already seen, PureScript functions correspond to JavaScript functions of a single argument. More precisely, if an expression `f` has type `a -> b` for some types `a` and `b`, and an expression `x` evaluates to a value with the correct runtime representation for type `a`, then `f` evaluates to a JavaScript function, which when applied to the result of evaluating `x`, has the correct runtime representation for type `b`. As a simple example, an expression of type `String -> String` evaluates to a function which takes non-null JavaScript strings to non-null JavaScript strings.\n"
msgstr ""
"既に見てきたように、PureScriptの関数は引数が1つのJavaScriptの関数に対応しています。\n"
"厳密に言えばこうなります。\n"
"任意の型`a`と`b`について、式`f`の型が`a -> b`で、式`x`が型`a`についての適切な実行時表現の値へと評価されるとします。\n"
"このとき`f`はJavaScriptの関数へと評価され、`x`を評価した結果に`f`を適用すると型`b`の適切な実行時表現を持ちます。\n"
"簡単な例としては、 `String -> String`型の式は、 `null`でないJavaScript文字列から `null`でないJavaScript文字列への関数へと評価されます。\n"

#. type: Plain text
#: text/chapter10.md:1177
msgid ""
"As you might expect, PureScript's arrays correspond to JavaScript arrays. "
"But remember - PureScript arrays are homogeneous, so every element has the "
"same type. Concretely, if a PureScript expression `e` has type `Array a` for "
"some type `a`, then `e` evaluates to a (non-null) JavaScript array, all of "
"whose elements have the correct runtime representation for type `a`."
msgstr ""
"ご想像の通り、PureScriptの配列はJavaScriptの配列に対応しています。\n"
"しかし、PureScriptの配列は均質である、つまり全ての要素が同じ型を持っているこ"
"とは覚えておいてください。\n"
"具体的には、もしPureScriptの式 `e`が何らかの型 `a`について型 `Array a`を持つ"
"なら、 `e`は全ての要素が（`null`でない）型 `a`の適切な実行時表現を持った"
"JavaScript配列へと評価されます。"

#. type: Plain text
#: text/chapter10.md:1179
msgid ""
"We've already seen that PureScript's records evaluate to JavaScript objects. "
"Just as for functions and arrays, we can reason about the runtime "
"representation of data in a record's fields by considering the types "
"associated with its labels. Of course, the fields of a record are not "
"required to be of the same type."
msgstr ""
"PureScriptのレコードがJavaScriptのオブジェクトへと評価されることは既に見てき"
"ました。\n"
"ちょうど関数や配列の場合のように、そのラベルに関連付けられている型を考慮すれ"
"ば、レコードのフィールドのデータの実行時の表現についても推論できます。\n"
"もちろん、レコードのそれぞれのフィールドは、同じ型である必要はありません。"

#. type: Title ###
#: text/chapter10.md:1180
#, no-wrap
msgid "Representing ADTs"
msgstr "ADTの表現"

#. type: Plain text
#: text/chapter10.md:1183
msgid ""
"For every constructor of an algebraic data type, the PureScript compiler "
"creates a new JavaScript object type by defining a function. Its "
"constructors correspond to functions which create new JavaScript objects "
"based on those prototypes."
msgstr ""
"PureScriptコンパイラは、代数的データ型の全ての構築子についてそれぞれを関数と"
"して定義し、新たなJavaScriptオブジェクト型を作成します。\n"
"これらの構築子は雛形に基づいて新しいJavaScriptオブジェクトを作成する関数に対"
"応しています。"

#. type: Plain text
#: text/chapter10.md:1185
msgid "For example, consider the following simple ADT:"
msgstr "例えば次のような単純なADTを考えてみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1186
#, no-wrap
msgid "data ZeroOrOne a = Zero | One a\n"
msgstr "data ZeroOrOne a = Zero | One a\n"

#. type: Plain text
#: text/chapter10.md:1191
msgid "The PureScript compiler generates the following code:"
msgstr "PureScriptコンパイラは、次のようなコードを生成します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1192
#, no-wrap
msgid ""
"function One(value0) {\n"
"    this.value0 = value0;\n"
"};\n"
"\n"
"One.create = function (value0) {\n"
"    return new One(value0);\n"
"};\n"
"\n"
"function Zero() {\n"
"};\n"
"\n"
"Zero.value = new Zero();\n"
msgstr ""
"function One(value0) {\n"
"    this.value0 = value0;\n"
"};\n"
"\n"
"One.create = function (value0) {\n"
"    return new One(value0);\n"
"};\n"
"\n"
"function Zero() {\n"
"};\n"
"\n"
"Zero.value = new Zero();\n"

#. type: Plain text
#: text/chapter10.md:1208
msgid ""
"Here, we see two JavaScript object types: `Zero` and `One`. It is possible "
"to create values of each type by using JavaScript's `new` keyword. For "
"constructors with arguments, the compiler stores the associated data in "
"fields called `value0`, `value1`, etc."
msgstr ""
"ここで2つのJavaScriptオブジェクト型 `Zero`と `One`を見てください。\n"
"JavaScriptのキーワード`new`を使用すると、それぞれの型の値を作成できます。\n"
"引数を持つ構築子については、コンパイラは `value0`、 `value1`などという名前の"
"フィールドに、対応するデータを格納します。"

#. type: Plain text
#: text/chapter10.md:1210
msgid ""
"The PureScript compiler also generates helper functions. For constructors "
"with no arguments, the compiler generates a `value` property, which can be "
"reused instead of using the `new` operator repeatedly. For constructors with "
"one or more arguments, the compiler generates a `create` function, which "
"takes arguments with the appropriate representation and applies the "
"appropriate constructor."
msgstr ""
"PureScriptコンパイラは補助関数も生成します。\n"
"引数のない構築子については、コンパイラは構築子が使われるたびに `new`演算子を"
"使うのではなく、データを再利用できるように `value`プロパティを生成します。\n"
"1つ以上の引数を持つ構築子では、コンパイラは適切な表現を持つ引数を取り適切な構"
"築子を適用する `create`関数を生成します。"

#. type: Plain text
#: text/chapter10.md:1212
msgid ""
"What about constructors with more than one argument? In that case, the "
"PureScript compiler also creates a new object type, and a helper function. "
"This time, however, the helper function is curried function of two "
"arguments. For example, this algebraic data type:"
msgstr ""
"2引数以上の構築子についてはどうでしょうか。\n"
"その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成しま"
"す。\n"
"ここでは補助関数は2引数のカリー化された関数なのです。\n"
"例えば次のような代数的データ型を考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1213
#, no-wrap
msgid "data Two a b = Two a b\n"
msgstr "data Two a b = Two a b\n"

#. type: Plain text
#: text/chapter10.md:1218
msgid "generates this JavaScript code:"
msgstr "このコードからは、次のようなJavaScriptコードが生成されます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1219
#, no-wrap
msgid ""
"function Two(value0, value1) {\n"
"    this.value0 = value0;\n"
"    this.value1 = value1;\n"
"};\n"
"\n"
"Two.create = function (value0) {\n"
"    return function (value1) {\n"
"        return new Two(value0, value1);\n"
"    };\n"
"};\n"
msgstr ""
"function Two(value0, value1) {\n"
"    this.value0 = value0;\n"
"    this.value1 = value1;\n"
"};\n"
"\n"
"Two.create = function (value0) {\n"
"    return function (value1) {\n"
"        return new Two(value0, value1);\n"
"    };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1233
msgid ""
"Here, values of the object type `Two` can be created using the `new` "
"keyword, or by using the `Two.create` function."
msgstr ""
"ここで、オブジェクト型 `Two`の値はキーワード`new`または `Two.create`関数を使"
"用すると作成できます。"

#. type: Plain text
#: text/chapter10.md:1235
msgid ""
"The case of newtypes is slightly different. Recall that a newtype is like an "
"algebraic data type, restricted to having a single constructor taking a "
"single argument. In this case, the runtime representation of the newtype is "
"actually the same as the type of its argument."
msgstr ""
"newtypeの場合はまた少し異なります。\n"
"newtypeは単一の引数を取る単一の構築子を持つよう制限された代数的データ型である"
"ことを思い出してください。\n"
"この場合、実際のnewtypeの実行時表現は、その引数の型と同じになります。"

#. type: Plain text
#: text/chapter10.md:1237
msgid "For example, this newtype representing telephone numbers:"
msgstr "例えば、電話番号を表す次のようなnewtypeを考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1238
#, no-wrap
msgid "newtype PhoneNumber = PhoneNumber String\n"
msgstr "newtype PhoneNumber = PhoneNumber String\n"

#. type: Plain text
#: text/chapter10.md:1243
msgid ""
"is actually represented as a JavaScript string at runtime. This is useful "
"for designing libraries, since newtypes provide an additional layer of type "
"safety, but without the runtime overhead of another function call."
msgstr ""
"これは実行時にJavaScriptの文字列として表されます。\n"
"newtypeは更なる型安全性のための層を提供しますが、実行時の関数呼び出しのオー"
"バーヘッドがないので、ライブラリを設計するのに役に立ちます。"

#. type: Title ###
#: text/chapter10.md:1244
#, no-wrap
msgid "Representing Quantified Types"
msgstr "量化された型の表現"

#. type: Plain text
#: text/chapter10.md:1247
msgid ""
"Expressions with quantified (polymorphic) types have restrictive "
"representations at runtime. In practice, this means that there are "
"relatively few expressions with a given quantified type, but that we can "
"reason about them quite effectively."
msgstr ""
"量化された型（多相型）の式は、実行時は制限された表現になっています。\n"
"つまり実際には、所与の量化された型を持つ式が比較的少ないということですが、と"
"ても効率的にそれらの式を調べることができるということでもあるのです。"

#. type: Plain text
#: text/chapter10.md:1249
msgid "Consider this polymorphic type, for example:"
msgstr "例えば、次の多相型を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1250
#, no-wrap
msgid "forall a. a -> a\n"
msgstr "forall a. a -> a\n"

#. type: Plain text
#: text/chapter10.md:1255
msgid ""
"What sort of functions have this type? Well, there is certainly one function "
"with this type - namely, the `identity` function, defined in the `Prelude`:"
msgstr ""
"この型を持っている関数にはどんなものがあるでしょうか。\n"
"少なくとも1つはこの型を持つ関数が存在します。\n"
"すなわち、 `Prelude`で定義されている恒等関数 `id`です。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1256
#, no-wrap
msgid ""
"id :: forall a. a -> a\n"
"id a = a\n"
msgstr ""
"id :: forall a. a -> a\n"
"id a = a\n"

#. type: Plain text
#: text/chapter10.md:1262
msgid ""
"In fact, the `identity` function is the _only_ (total) function with this "
"type! This certainly seems to be the case (try writing an expression with "
"this type which is not observably equivalent to `identity`), but how can we "
"be sure? We can be sure by considering the runtime representation of the "
"type."
msgstr ""
"実のところ、`id`関数はこの型の*唯一の*（全）関数です。\n"
"これは確かに間違いなさそうに思えますが（この型を持った `id`とは明らかに異なる"
"式を書こうとしてみてください）、確かめるにはどうしたらいいでしょうか。\n"
"型の実行時表現を考えることによって確かめられます。"

#. type: Plain text
#: text/chapter10.md:1264
#, no-wrap
msgid "What is the runtime representation of a quantified type `forall a. t`? Well, any expression with the runtime representation for this type must have the correct runtime representation for the type `t` for any choice of type `a`. In our example above, a function of type `forall a. a -> a` must have the correct runtime representation for the types `String -> String`, `Number -> Number`, `Array Boolean -> Array Boolean`, and so on. It must take strings to strings, numbers to numbers, etc.\n"
msgstr "量化された型 `forall a. t`の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 `a`をどのように選んでも型 `t`の適切な実行時表現を持っていなければなりません。上の例では、型 `forall a. a -> a`の関数は、 `String -> String`、 `Number -> Number`、 `Array Boolean -> Array Boolean`などといった型について、適切な実行時表現を持っていなければなりません。 これらは、文字列から文字列、数から数の関数でなくてはなりません。\n"

#. type: Plain text
#: text/chapter10.md:1266
msgid ""
"But that is not enough - the runtime representation of a quantified type is "
"more strict than this. We require any expression to be _parametrically "
"polymorphic_ - that is, it cannot use any information about the type of its "
"argument in its implementation. This additional condition prevents "
"problematic implementations such as the following JavaScript function from "
"inhabiting a polymorphic type:"
msgstr ""
"しかし、それだけでは充分ではありません。\n"
"量化された型の実行時表現は、これよりも更に厳しくなります。\n"
"任意の式が*パラメトリック多相的*でなければなりません。\n"
"つまり、その実装において、引数の型についてのどんな情報も使うことができないの"
"です。\n"
"この追加の条件は、考えられる多相型のうち、以下のJavaScriptの関数のような問題"
"のある実装を防止します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1267
#, no-wrap
msgid ""
"function invalid(a) {\n"
"    if (typeof a === 'string') {\n"
"        return \"Argument was a string.\";\n"
"    } else {\n"
"        return a;\n"
"    }\n"
"}\n"
msgstr ""
"function invalid(a) {\n"
"    if (typeof a === 'string') {\n"
"        return \"Argument was a string.\";\n"
"    } else {\n"
"        return a;\n"
"    }\n"
"}\n"

#. type: Plain text
#: text/chapter10.md:1278
#, no-wrap
msgid "Certainly, this function takes strings to strings, numbers to numbers, etc. but it does not meet the additional condition, since it inspects the (runtime) type of its argument, so this function would not be a valid inhabitant of the type `forall a. a -> a`.\n"
msgstr ""
"確かにこの関数は文字列から文字列、数から数へというような関数ではありますが、追加条件を満たしていません。\n"
"引数の実行時の型を調べており、したがって、この関数は型 `forall a. a -> a`の正しい実装だとはいえないのです。\n"

#. type: Plain text
#: text/chapter10.md:1280
#, no-wrap
msgid "Without being able to inspect the runtime type of our function argument, our only option is to return the argument unchanged, and so `identity` is indeed the only inhabitant of the type `forall a. a -> a`.\n"
msgstr "関数の引数の実行時の型を検査できなければ、唯一の選択肢は引数をそのまま返すことだけであり、したがって `id`はたしかに `forall a. a -> a`の唯一の実装なのです。\n"

#. type: Plain text
#: text/chapter10.md:1282
msgid ""
"A full discussion of _parametric polymorphism_ and _parametricity_ is beyond "
"the scope of this book. Note however, that since PureScript's types are "
"_erased_ at runtime, a polymorphic function in PureScript _cannot_ inspect "
"the runtime representation of its arguments (without using the FFI), and so "
"this representation of polymorphic data is appropriate."
msgstr ""
"*パラメトリック多相*と*パラメトリック性*についての詳しい議論は本書の範囲を超"
"えています。\n"
"ただ、PureScriptの型は実行時に*消去*されており、PureScriptの多相関数は（FFIを"
"使わない限り）引数の実行時表現を検査*できない*ため、この多相的なデータの表現"
"が適切になっているという点にはご留意ください。"

#. type: Title ###
#: text/chapter10.md:1283
#, no-wrap
msgid "Representing Constrained Types"
msgstr "制約のある型の表現"

#. type: Plain text
#: text/chapter10.md:1286
msgid ""
"Functions with a type class constraint have an interesting representation at "
"runtime. Because the behavior of the function might depend on the type class "
"instance chosen by the compiler, the function is given an additional "
"argument, called a _type class dictionary_, which contains the "
"implementation of the type class functions provided by the chosen instance."
msgstr ""
"型クラス制約を持つ関数は、実行時に面白い表現を持っています。\n"
"関数の挙動はコンパイラによって選ばれた型クラスのインスタンスに依存する可能性"
"があるため、関数には*型クラス辞書*と呼ばれる追加の引数が与えられます。\n"
"この辞書には選ばれたインスタンスから提供される型クラスの関数の実装が含まれま"
"す。"

#. type: Plain text
#: text/chapter10.md:1288
msgid ""
"For example, here is a simple PureScript function with a constrained type "
"which uses the `Show` type class:"
msgstr ""
"例えば、 `Show`型クラスを使った制約のある型を持つ、次のような単純なPureScript"
"関数について考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1289
#, no-wrap
msgid ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"
msgstr ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"

#. type: Plain text
#: text/chapter10.md:1295
msgid "The generated JavaScript looks like this:"
msgstr "生成されるJavaScriptは次のようになります。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1296
#, no-wrap
msgid ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"
msgstr ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1305
msgid ""
"Notice that `shout` is compiled to a (curried) function of two arguments, "
"not one. The first argument `dict` is the type class dictionary for the "
"`Show` constraint. `dict` contains the implementation of the `show` function "
"for the type `a`."
msgstr ""
"`shout`は1引数ではなく、2引数の（カリー化された）関数にコンパイルされているこ"
"とに注意してください。最初の引数 `dict`は `Show`制約の型クラス辞書です。 "
"`dict`には型 `a`の `show`関数の実装が含まれています。"

#. type: Plain text
#: text/chapter10.md:1307
msgid ""
"We can call this function from JavaScript by passing an explicit type class "
"dictionary from `Data.Show` as the first parameter:"
msgstr ""
"最初の引数として明示的に`Data.Show`の型クラス辞書を渡すと、JavaScriptからこの"
"関数を呼び出すことができます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1308
#, no-wrap
msgid ""
"import { showNumber } from 'Data.Show'\n"
"\n"
"shout(showNumber)(42);\n"
msgstr ""
"import { showNumber } from 'Data.Show'\n"
"\n"
"shout(showNumber)(42);\n"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1317
msgid "(Easy) What are the runtime representations of these types?"
msgstr "（簡単）これらの型の実行時の表現は何でしょうか。"

#. type: Plain text
#: text/chapter10.md:1323
#, no-wrap
msgid ""
"     ```haskell\n"
"     forall a. a\n"
"     forall a. a -> a -> a\n"
"     forall a. Ord a => Array a -> Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     forall a. a\n"
"     forall a. a -> a -> a\n"
"     forall a. Ord a => Array a -> Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter10.md:1326
#, no-wrap
msgid ""
"     What can you say about the expressions which have these types?\n"
" 1. (Medium) Try using the functions defined in the `arrays` package, calling them from JavaScript, by compiling the library using `spago build` and importing modules using the `import` function in NodeJS. _Hint_: you may need to configure the output path so that the generated ES modules are available on the NodeJS module path.\n"
msgstr ""
"     これらの型を持つ式についてわかることは何でしょうか。\n"
"1. （普通）`spago build`を使ってコンパイルし、NodeJSの `import`機能を使ってモジュールをインポートすることで、JavaScriptから `arrays`ライブラリの関数を使ってみてください。\n"
"   *手掛かり*：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。\n"

#. type: Title ###
#: text/chapter10.md:1327
#, no-wrap
msgid "Representing Side Effects"
msgstr "副作用の表現"

#. type: Plain text
#: text/chapter10.md:1330
msgid ""
"The `Effect` monad is also defined as a foreign type. Its runtime "
"representation is quite simple - an expression of type `Effect a` should "
"evaluate to a JavaScript function of **no arguments**, which performs any "
"side-effects and returns a value with the correct runtime representation for "
"type `a`."
msgstr ""
"`Effect`モナドも外部型として定義されています。\n"
"その実行時表現はとても簡単です。\n"
"型 `Effect a`の式は**引数なしの**JavaScript関数へと評価されます。\n"
"この関数はあらゆる副作用を実行し型 `a`の適切な実行時表現で値を返します。"

#. type: Plain text
#: text/chapter10.md:1332
msgid ""
"The definition of the `Effect` type constructor is given in the `Effect` "
"module as follows:"
msgstr ""
"`Effect`型構築子の定義は、 `Effect`モジュールで次のように与えられています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1333
#, no-wrap
msgid "foreign import data Effect :: Type -> Type\n"
msgstr "foreign import data Effect :: Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:1338
msgid ""
"As a simple example, consider the `random` function defined in the `random` "
"package. Recall that its type was:"
msgstr ""
"簡単な例として、 `random`パッケージで定義される `random`関数を考えてみてくだ"
"さい。その型は次のようなものでした。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1339
#, no-wrap
msgid "foreign import random :: Effect Number\n"
msgstr "foreign import random :: Effect Number\n"

#. type: Plain text
#: text/chapter10.md:1344
msgid "The definition of the `random` function is given here:"
msgstr "`random`関数の定義は次のように与えられます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1345
#, no-wrap
msgid "export const random = Math.random;\n"
msgstr "export const random = Math.random;\n"

#. type: Plain text
#: text/chapter10.md:1350
msgid ""
"Notice that the `random` function is represented at runtime as a function of "
"no arguments. It performs the side effect of generating a random number, and "
"returns it, and the return value matches the runtime representation of the "
"`Number` type: it is a non-null JavaScript number."
msgstr ""
"`random`関数は実行時には引数なしの関数として表現されていることに注目してくだ"
"さい。\n"
"この関数は乱数生成という副作用を実行して返しますが、返り値は `Number`型の実行"
"時表現と一致します。\n"
"`Number`型は`null`でないJavaScriptの数です。"

#. type: Plain text
#: text/chapter10.md:1352
msgid ""
"As a slightly more interesting example, consider the `log` function defined "
"by the `Effect.Console` module in the `console` package. The `log` function "
"has the following type:"
msgstr ""
"もう少し興味深い例として、`console`パッケージ中の`Effect.Console`モジュールで"
"定義された `log`関数を考えてみましょう。 `log`関数は次の型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1353
#, no-wrap
msgid "foreign import log :: String -> Effect Unit\n"
msgstr "foreign import log :: String -> Effect Unit\n"

#. type: Plain text
#: text/chapter10.md:1358
msgid "And here is its definition:"
msgstr "この定義は次のようになっています。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1359
#, no-wrap
msgid ""
"export const log = function (s) {\n"
"  return function () {\n"
"    console.log(s);\n"
"  };\n"
"};\n"
msgstr ""
"export const log = function (s) {\n"
"  return function () {\n"
"    console.log(s);\n"
"  };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1368
msgid ""
"The representation of `log` at runtime is a JavaScript function of a single "
"argument, returning a function of no arguments. The inner function performs "
"the side-effect of writing a message to the console."
msgstr ""
"実行時の `log`の表現は、単一の引数のJavaScript関数で、引数なしの関数を返しま"
"す。内側の関数はコンソールにメッセージを書き込むという副作用を実行します。"

#. type: Plain text
#: text/chapter10.md:1370
msgid ""
"Expressions of type `Effect a` can be invoked from JavaScript like regular "
"JavaScript methods. For example, since the `main` function is required to "
"have type `Effect a` for some type `a`, it can be invoked as follows:"
msgstr ""
"`Effect a`型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出す"
"ことができます。例えば、この `main`関数は何らかの型`a`について`Effect a`とい"
"う型でなければならないので、次のように実行できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1371
#, no-wrap
msgid ""
"import { main } from 'Main'\n"
"\n"
"main();\n"
msgstr ""
"import { main } from 'Main'\n"
"\n"
"main();\n"

#. type: Plain text
#: text/chapter10.md:1377
msgid ""
"When using `spago bundle-app --to` or `spago run`, this call to `main` is "
"generated automatically, whenever the `Main` module is defined."
msgstr ""
"`spago bundle-app --to`または `spago run`を使用するときは、`Main`モジュールが"
"定義されている場合は常に、この `main`の呼び出しを自動的に生成できます。"

#. type: Title #
#: text/chapter11.md:1
#, no-wrap
msgid "Monadic Adventures"
msgstr "モナドな冒険"

#. type: Plain text
#: text/chapter11.md:6
msgid ""
"The goal of this chapter will be to learn about _monad transformers_, which "
"provide a way to combine side-effects provided by different monads. The "
"motivating example will be a text adventure game which can be played on the "
"console in NodeJS. The various side-effects of the game (logging, state, and "
"configuration) will all be provided by a monad transformer stack."
msgstr ""
"この章の目標は*モナド変換子*について学ぶことです。\n"
"モナド変換子は異なるモナドから提供された副作用を合成する方法を提供します。\n"
"NodeJSのコンソール上で遊ぶことができるテキストアドベンチャーゲームを題材とし"
"て扱います。\n"
"ゲームの様々な副作用（ロギング、状態、及び設定）が全てモナド変換子スタックに"
"よって提供されます。"

#. type: Plain text
#: text/chapter11.md:10 text/chapter12.md:10
msgid "This module's project introduces the following new dependencies:"
msgstr "このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`ordered-collections`, which provides data types for immutable maps and sets"
msgstr "`ordered-collections` は不変のマップと集合のためのデータ型を提供します"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`transformers`, which provides implementations of standard monad transformers"
msgstr "`transformers` は標準的なモナド変換子の実装を提供します"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`node-readline`, which provides FFI bindings to the [`readline`](https://"
"nodejs.org/api/readline.html) interface provided by NodeJS"
msgstr ""
"`node-readline`はNodeJSが提供する[`readline`](http://nodejs.org/api/readline."
"html)インターフェイスへのFFIバインディングを提供します"

#. type: Bullet: '- '
#: text/chapter11.md:15
msgid ""
"`optparse`, which provides applicative parsers for processing command line "
"arguments"
msgstr ""
"`optparse` はコマンドライン引数を処理するアプリカティブ構文解析器を提供します"

#. type: Title ##
#: text/chapter11.md:16
#, no-wrap
msgid "How To Play The Game"
msgstr "ゲームの遊びかた"

#. type: Plain text
#: text/chapter11.md:19
msgid "To run the project, use `spago run`"
msgstr "プロジェクトを走らせるには`spago run`を使います。"

#. type: Plain text
#: text/chapter11.md:21
msgid "By default you will see a usage message:"
msgstr "既定では使い方が表示されます。"

#. type: Fenced code block (text)
#: text/chapter11.md:22
#, no-wrap
msgid ""
"Monadic Adventures! A game to learn monad transformers\n"
"\n"
"Usage: run.js (-p|--player <player name>) [-d|--debug]\n"
"  Play the game as <player name>\n"
"\n"
"Available options:\n"
"  -p,--player <player name>\n"
"                           The player's name <String>\n"
"  -d,--debug               Use debug mode\n"
"  -h,--help                Show this help text\n"
msgstr ""
"Monadic Adventures! A game to learn monad transformers\n"
"\n"
"Usage: run.js (-p|--player <player name>) [-d|--debug]\n"
"  Play the game as <player name>\n"
"\n"
"Available options:\n"
"  -p,--player <player name>\n"
"                           The player's name <String>\n"
"  -d,--debug               Use debug mode\n"
"  -h,--help                Show this help text\n"

#. type: Plain text
#: text/chapter11.md:35
#, no-wrap
msgid "To provide command line arguments, you can either call `spago run` with the `-a` option to pass additional arguments directly to your application, or you can call `spago bundle-app`, which will create an index.js file that can be run directly with `node`.  \n"
msgstr ""
"コマンドライン引数を与えるためには、追加の引数を直接アプリケーションに渡す`-a`オプション付きで`spago run`を呼び出すか、`spago bundle-app`とすればよいです。\n"
"2つ目の方法では`node`で直接走らせられるindex.jsファイルが作られます。\n"

#. type: Plain text
#: text/chapter11.md:37
msgid "For example, to provide the player name using the `-p` option:"
msgstr "例えば`-p`オプションを使ってプレイヤー名を与えるには次のようにします。"

#. type: Fenced code block (text)
#: text/chapter11.md:38
#, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
">\n"
msgstr ""
"$ spago run -a \"-p Phil\"\n"
">\n"

#. type: Fenced code block (text)
#: text/chapter11.md:43
#, no-wrap
msgid ""
"$ spago bundle-app \n"
"$ node index.js -p Phil\n"
">\n"
msgstr ""
"$ spago bundle-app \n"
"$ node index.js -p Phil\n"
">\n"

#. type: Plain text
#: text/chapter11.md:50
msgid ""
"From the prompt, you can enter commands like `look`, `inventory`, `take`, "
"`use`, `north`, `south`, `east`, and `west`. There is also a `debug` "
"command, which can be used to print the game state when the `--debug` "
"command line option is provided."
msgstr ""
"プロンプトからは、 `look`、 `inventory`、 `take`、 `use`、 `north`、"
"`south`、 `east`、 `west`などのコマンドを入力できます。\n"
"`debug`コマンドもあり、`--debug`コマンドラインオプションを与えられていた場合"
"に、ゲームの状態を出力するのに使えます。"

#. type: Plain text
#: text/chapter11.md:52
msgid ""
"The game is played on a two-dimensional grid, and the player moves by "
"issuing commands `north`, `south`, `east`, and `west`. The game contains a "
"collection of items which can either be in the player's possession (in the "
"user's _inventory_), or on the game grid at some location. Items can be "
"picked up by the player, using the `take` command."
msgstr ""
"ゲームは2次元の碁盤の目の上が舞台で、コマンド `north`、 `south`、`east`、 "
"`west`を発行することによってプレイヤーが移動します。\n"
"ゲームにはアイテムの集まりがあり、プレイヤーの所持アイテム一覧を表したり、"
"ゲーム盤上のその位置にあるアイテムの一覧を表すのに使われます。\n"
"`take`コマンドを使うと、プレイヤーの位置にあるアイテムを拾い上げることができ"
"ます。"

#. type: Plain text
#: text/chapter11.md:54
msgid "For reference, here is a complete walkthrough of the game:"
msgstr "参考までに、このゲームのひと通りの流れは次のようになります。"

#. type: Fenced code block (text)
#: text/chapter11.md:55
#, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
"\n"
"> look\n"
"You are at (0, 0)\n"
"You are in a dark forest. You see a path to the north.\n"
"You can see the Matches.\n"
"\n"
"> take Matches\n"
"You now have the Matches\n"
"\n"
"> north\n"
"> look\n"
"You are at (0, 1)\n"
"You are in a clearing.\n"
"You can see the Candle.\n"
"\n"
"> take Candle\n"
"You now have the Candle\n"
"\n"
"> inventory\n"
"You have the Candle.\n"
"You have the Matches.\n"
"\n"
"> use Matches\n"
"You light the candle.\n"
"Congratulations, Phil!\n"
"You win!\n"
msgstr ""
"$ spago run -a \"-p Phil\"\n"
"\n"
"> look\n"
"You are at (0, 0)\n"
"You are in a dark forest. You see a path to the north.\n"
"You can see the Matches.\n"
"\n"
"> take Matches\n"
"You now have the Matches\n"
"\n"
"> north\n"
"> look\n"
"You are at (0, 1)\n"
"You are in a clearing.\n"
"You can see the Candle.\n"
"\n"
"> take Candle\n"
"You now have the Candle\n"
"\n"
"> inventory\n"
"You have the Candle.\n"
"You have the Matches.\n"
"\n"
"> use Matches\n"
"You light the candle.\n"
"Congratulations, Phil!\n"
"You win!\n"

#. type: Plain text
#: text/chapter11.md:86
msgid ""
"The game is very simple, but the aim of the chapter is to use the "
"`transformers` package to build a library which will enable rapid "
"development of this type of game."
msgstr ""
"このゲームはとても単純ですが、この章の目的は `transformers`パッケージを使用し"
"てこのようなゲームを素早く開発できるようにするライブラリを構築することです。"

#. type: Title ##
#: text/chapter11.md:87
#, no-wrap
msgid "The State Monad"
msgstr "Stateモナド"

#. type: Plain text
#: text/chapter11.md:90
msgid ""
"We will start by looking at some of the monads provided by the "
"`transformers` package."
msgstr ""
"`transformers`パッケージで提供されている幾つかのモナドを眺めることから始めま"
"しょう。"

#. type: Plain text
#: text/chapter11.md:92
msgid ""
"The first example is the `State` monad, which provides a way to model "
"_mutable state_ in pure code. We have already seen an approach to mutable "
"state provided by the `Effect` monad. `State` provides an alternative."
msgstr ""
"最初の例は`State`モナドです。\n"
"これは純粋なコードで*変更可能状態*をモデル化する手段を提供します。\n"
"既に`Effect`モナドによって提供される変更可能状態の手法について見てきまし"
"た。\n"
"`State`はその代替を提供します。"

#. type: Plain text
#: text/chapter11.md:94
msgid ""
"The `State` type constructor takes two type parameters: the type `s` of the "
"state, and the return type `a`. Even though we speak of the \"`State` monad"
"\", the instance of the `Monad` type class is actually provided for the "
"`State s` type constructor, for any type `s`."
msgstr ""
"`State`型構築子は、状態の型 `s`、及び返り値の型 `a`という2種類の引数を取りま"
"す。\n"
"「`State`モナド」というように説明はしていますが、実際には`Monad`型クラスのイ"
"ンスタンスが任意の型`s`についての `State s`型構築子に対して提供されています。"

#. type: Plain text
#: text/chapter11.md:96
msgid "The `Control.Monad.State` module provides the following API:"
msgstr "`Control.Monad.State`モジュールは以下のAPIを提供しています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:97
#, no-wrap
msgid ""
"get     :: forall s.             State s s\n"
"gets    :: forall s. (s -> a) -> State s a\n"
"put     :: forall s. s        -> State s Unit\n"
"modify  :: forall s. (s -> s) -> State s s\n"
"modify_ :: forall s. (s -> s) -> State s Unit\n"
msgstr ""
"get     :: forall s.             State s s\n"
"gets    :: forall s. (s -> a) -> State s a\n"
"put     :: forall s. s        -> State s Unit\n"
"modify  :: forall s. (s -> s) -> State s s\n"
"modify_ :: forall s. (s -> s) -> State s Unit\n"

#. type: Plain text
#: text/chapter11.md:106
msgid ""
"Note that these API signatures are presented in a simplified form using the "
"`State` type constructor for now. The actual API involves `MonadState` which "
"we'll cover in the later \"Type Classes\" section of this chapter, so don't "
"worry if you see different signatures in your IDE tooltips or on Pursuit."
msgstr ""
"なおここではこれらのAPIシグネチャは`State`型構築子を使った、単純化された形式"
"で表されています。\n"
"実際のAPIは本章の後にある「型クラス」節で押さえる`MonadState`が関わってきま"
"す。\n"
"ですからIDEのツールチップやPursuitで違うシグネチャを見たとしても心配しないで"
"ください。"

#. type: Plain text
#: text/chapter11.md:108
msgid ""
"Let's see an example. One use of the `State` monad might be to add the "
"values in an array of integers to the current state. We could do that by "
"choosing `Int` as the state type `s`, and using `traverse_` to traverse the "
"array, with a call to `modify` for each array element:"
msgstr ""
"例を見てみましょう。\n"
"`State`モナドの使いかたの1つとしては、整数の配列中の値を現在の状態に加えるも"
"のが考えられます。\n"
"状態の型`s`として`Int`を選択し、配列の走査に `traverse_`を使って、配列の要素"
"それぞれについて `modify`を呼び出すと、これを実現できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:109
#, no-wrap
msgid ""
"import Data.Foldable (traverse_)\n"
"import Control.Monad.State\n"
"import Control.Monad.State.Class\n"
"\n"
"sumArray :: Array Int -> State Int Unit\n"
"sumArray = traverse_ \\n -> modify \\sum -> sum + n\n"
msgstr ""
"import Data.Foldable (traverse_)\n"
"import Control.Monad.State\n"
"import Control.Monad.State.Class\n"
"\n"
"sumArray :: Array Int -> State Int Unit\n"
"sumArray = traverse_ \\n -> modify \\sum -> sum + n\n"

#. type: Plain text
#: text/chapter11.md:119
msgid ""
"The `Control.Monad.State` module provides three functions for running a "
"computation in the `State` monad:"
msgstr ""
"`Control.Monad.State`モジュールは、`State`モナドで計算するための次の3つの関数"
"を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:120
#, no-wrap
msgid ""
"evalState :: forall s a. State s a -> s -> a\n"
"execState :: forall s a. State s a -> s -> s\n"
"runState  :: forall s a. State s a -> s -> Tuple a s\n"
msgstr ""
"evalState :: forall s a. State s a -> s -> a\n"
"execState :: forall s a. State s a -> s -> s\n"
"runState  :: forall s a. State s a -> s -> Tuple a s\n"

#. type: Plain text
#: text/chapter11.md:127
msgid ""
"Each of these functions takes an initial state of type `s` and a computation "
"of type `State s a`. `evalState` only returns the return value, `execState` "
"only returns the final state, and `runState` returns both, expressed as a "
"value of type `Tuple a s`."
msgstr ""
"3つの関数はそれぞれ型`s`の初期状態と型`State s a`の計算を引数にとります。\n"
"`evalState`は返り値だけを返し、 `execState`は最終的な状態だけを返し、 "
"`runState`は `Tuple a s`型の値として表現された両方を返します。"

#. type: Plain text
#: text/chapter11.md:129
msgid ""
"Given the `sumArray` function above, we could use `execState` in PSCi to sum "
"the numbers in several arrays as follows:"
msgstr ""
"先ほどの `sumArray`関数が与えられているとき、PSCiで `execState`を使うと次のよ"
"うに複数の配列内の数字を合計できます。"

#. type: Fenced code block (text)
#: text/chapter11.md:130
#, no-wrap
msgid ""
"> :paste\n"
"… execState (do\n"
"…   sumArray [1, 2, 3]\n"
"…   sumArray [4, 5]\n"
"…   sumArray [6]) 0\n"
"… ^D\n"
"21\n"
msgstr ""
"> :paste\n"
"… execState (do\n"
"…   sumArray [1, 2, 3]\n"
"…   sumArray [4, 5]\n"
"…   sumArray [6]) 0\n"
"… ^D\n"
"21\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:145
msgid ""
"(Easy) What is the result of replacing `execState` with `runState` or "
"`evalState` in our example above?"
msgstr ""
"（簡単）上の例で、`execState`を`runState`や`evalState`で置き換えると結果はど"
"うなるでしょうか。"

#. type: Plain text
#: text/chapter11.md:145
#, no-wrap
msgid ""
" 1. (Medium) A string of parentheses is _balanced_ if it is obtained by either concatenating zero-or-more shorter balanced\n"
"     strings, or by wrapping a shorter balanced string in a pair of parentheses.\n"
msgstr ""
"1. （普通）括弧からなる文字列について、次の何れかであれば*平衡している*とします。\n"
"   1つは0個以上のより短い平衡した文字列を連結したもので、もう1つはより短い平衡した文字列を一対の括弧で囲んだものです。\n"

#. type: Plain text
#: text/chapter11.md:147
#, no-wrap
msgid "     Use the `State` monad and the `traverse_` function to write a function\n"
msgstr "    `State`モナドと `traverse_`関数を使用して、次のような関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:151
#, no-wrap
msgid ""
"     ```haskell\n"
"     testParens :: String -> Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     testParens :: String -> Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:154
#, no-wrap
msgid ""
"     which tests whether or not a `String` of parentheses is balanced, by keeping track of the number of opening parentheses\n"
"     which have not been closed. Your function should work as follows:\n"
msgstr ""
"     これは `String`が括弧の対応が正しく付けられているかどうかを調べる関数です。\n"
"     調べるにはまだ閉じられていない開括弧の数を把握しておきます。\n"
"     この関数は次のように動作しなくてはなりません。\n"

#. type: Plain text
#: text/chapter11.md:158
#, no-wrap
msgid ""
"     ```text\n"
"     > testParens \"\"\n"
"     true\n"
msgstr ""
"     ```text\n"
"     > testParens \"\"\n"
"     true\n"

#. type: Plain text
#: text/chapter11.md:161
#, no-wrap
msgid ""
"     > testParens \"(()(())())\"\n"
"     true\n"
msgstr ""
"     > testParens \"(()(())())\"\n"
"     true\n"

#. type: Plain text
#: text/chapter11.md:164
#, no-wrap
msgid ""
"     > testParens \")\"\n"
"     false\n"
msgstr ""
"     > testParens \")\"\n"
"     false\n"

#. type: Plain text
#: text/chapter11.md:168
#, no-wrap
msgid ""
"     > testParens \"(()()\"\n"
"     false\n"
"     ```\n"
msgstr ""
"     > testParens \"(()()\"\n"
"     false\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:170
#, no-wrap
msgid "     _Hint_: you may like to use the `toCharArray` function from the `Data.String.CodeUnits` module to turn the input string into an array of characters.\n"
msgstr "     *手掛かり*：入力の文字列を文字の配列に変換するのに、`Data.String.CodeUnits`モジュールの `toCharArray`関数を使うと良いでしょう。\n"

#. type: Title ##
#: text/chapter11.md:171
#, no-wrap
msgid "The Reader Monad"
msgstr "Readerモナド"

#. type: Plain text
#: text/chapter11.md:174
msgid ""
"Another monad provided by the `transformers` package is the `Reader` monad. "
"This monad provides the ability to read from a global configuration. Whereas "
"the `State` monad provides the ability to read and write a single piece of "
"mutable state, the `Reader` monad only provides the ability to read a single "
"piece of data."
msgstr ""
"`transformers`パッケージでは `Reader`というモナドも提供されています。\n"
"このモナドは大域的な設定を読み取る機能を提供します。\n"
"`State`モナドが1つの可変状態を読み書きする機能を提供するのに対し、 `Reader`モ"
"ナドは1つのデータの読み取り機能だけを提供します。"

#. type: Plain text
#: text/chapter11.md:176
msgid ""
"The `Reader` type constructor takes two type arguments: a type `r` which "
"represents the configuration type, and the return type `a`."
msgstr ""
"`Reader`型構築子は、設定の型を表す型 `r`、及び戻り値の型 `a`の2つの型引数を取"
"ります。"

#. type: Plain text
#: text/chapter11.md:178
msgid "The `Control.Monad.Reader` module provides the following API:"
msgstr "`Control.Monad.Reader`モジュールは以下のAPIを提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:179
#, no-wrap
msgid ""
"ask   :: forall r. Reader r r\n"
"local :: forall r a. (r -> r) -> Reader r a -> Reader r a\n"
msgstr ""
"ask   :: forall r. Reader r r\n"
"local :: forall r a. (r -> r) -> Reader r a -> Reader r a\n"

#. type: Plain text
#: text/chapter11.md:185
msgid ""
"The `ask` action can be used to read the current configuration, and the "
"`local` action can be used to run a computation with a modified "
"configuration."
msgstr ""
"`ask`アクションは現在の設定を読み取るために使い、 `local`アクションは変更され"
"た設定で計算するために使います。"

#. type: Plain text
#: text/chapter11.md:187
msgid ""
"For example, suppose we were developing an application controlled by "
"permissions, and we wanted to use the `Reader` monad to hold the current "
"user's permissions object. We might choose the type `r` to be some type "
"`Permissions` with the following API:"
msgstr ""
"例えば、権限で制御するアプリケーションを開発しており、現在の利用者の権限オブ"
"ジェクトを保持するのに `Reader`モナドを使いたいとしましょう。\n"
"型 `r`を次のようなAPIを備えた型 `Permission`として選択できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:188
#, no-wrap
msgid ""
"hasPermission :: String -> Permissions -> Boolean\n"
"addPermission :: String -> Permissions -> Permissions\n"
msgstr ""
"hasPermission :: String -> Permissions -> Boolean\n"
"addPermission :: String -> Permissions -> Permissions\n"

#. type: Plain text
#: text/chapter11.md:194
msgid ""
"Whenever we wanted to check if the user had a particular permission, we "
"could use `ask` to retrieve the current permissions object. For example, "
"only administrators might be allowed to create new users:"
msgstr ""
"利用者が特定の権限を持っているかどうかを確認したいときは、 `ask`を使って現在"
"の権限オブジェクトを取得すればいつでも調べることができます。\n"
"例えば管理者だけが新しい利用者の作成を許可されているとしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:195
#, no-wrap
msgid ""
"createUser :: Reader Permissions (Maybe User)\n"
"createUser = do\n"
"  permissions <- ask\n"
"  if hasPermission \"admin\" permissions\n"
"    then map Just newUser\n"
"    else pure Nothing\n"
msgstr ""
"createUser :: Reader Permissions (Maybe User)\n"
"createUser = do\n"
"  permissions <- ask\n"
"  if hasPermission \"admin\" permissions\n"
"    then map Just newUser\n"
"    else pure Nothing\n"

#. type: Plain text
#: text/chapter11.md:205
msgid ""
"To elevate the user's permissions, we might use the `local` action to modify "
"the `Permissions` object during the execution of some computation:"
msgstr ""
"`local`アクションを使うと、計算の実行中に `Permissions`オブジェクトを変更し、"
"ユーザーの権限を昇格させることもできます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:206
#, no-wrap
msgid ""
"runAsAdmin :: forall a. Reader Permissions a -> Reader Permissions a\n"
"runAsAdmin = local (addPermission \"admin\")\n"
msgstr ""
"runAsAdmin :: forall a. Reader Permissions a -> Reader Permissions a\n"
"runAsAdmin = local (addPermission \"admin\")\n"

#. type: Plain text
#: text/chapter11.md:212
msgid ""
"Then we could write a function to create a new user, even if the user did "
"not have the `admin` permission:"
msgstr ""
"こうすると、利用者が `admin`権限を持っていなかった場合であっても新しい利用者"
"を作成できるような関数を書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:213
#, no-wrap
msgid ""
"createUserAsAdmin :: Reader Permissions (Maybe User)\n"
"createUserAsAdmin = runAsAdmin createUser\n"
msgstr ""
"createUserAsAdmin :: Reader Permissions (Maybe User)\n"
"createUserAsAdmin = runAsAdmin createUser\n"

#. type: Plain text
#: text/chapter11.md:219
msgid ""
"To run a computation in the `Reader` monad, the `runReader` function can be "
"used to provide the global configuration:"
msgstr ""
"`Reader`モナドを計算するには、大域的な設定を与える`runReader`関数を使います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:220
#, no-wrap
msgid "runReader :: forall r a. Reader r a -> r -> a\n"
msgstr "runReader :: forall r a. Reader r a -> r -> a\n"

#. type: Plain text
#: text/chapter11.md:227
#, no-wrap
msgid " In these exercises, we will use the `Reader` monad to build a small library for rendering documents with indentation. The \"global configuration\" will be a number indicating the current indentation level:\n"
msgstr ""
"以下の演習では、 `Reader`モナドを使って、字下げのついた文書を出力するための小さなライブラリを作っていきます。\n"
"「大域的な設定」は、現在の字下げの深さを示す数になります。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:228
#, no-wrap
msgid ""
"type Level = Int\n"
"\n"
"type Doc = Reader Level String\n"
msgstr ""
"type Level = Int\n"
"\n"
"type Doc = Reader Level String\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:235
msgid ""
"(Easy) Write a function `line` which renders a function at the current "
"indentation level. Your function should have the following type:"
msgstr ""
"（簡単）現在の字下げの深さで文字列を出力する関数 `line`を書いてください。\n"
"関数は以下の型を持つ必要があります。"

#. type: Plain text
#: text/chapter11.md:239
#, no-wrap
msgid ""
"     ```haskell\n"
"     line :: String -> Doc\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     line :: String -> Doc\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:242
#, no-wrap
msgid ""
"     _Hint_: use the `ask` function to read the current indentation level. The `power` function from `Data.Monoid` may be helpful too.\n"
" 1. (Easy) Use the `local` function to write a function\n"
msgstr ""
"     *手掛かり*：現在の字下げの深さを読み取るためには `ask`関数を使用します。\n"
"     `Data.Monoid`の`power`関数も役に立つかもしれません。\n"
"1. （普通）`local`関数を使用して次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:246
#, no-wrap
msgid ""
"     ```haskell\n"
"     indent :: Doc -> Doc\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     indent :: Doc -> Doc\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:249
#, no-wrap
msgid ""
"     which increases the indentation level for a block of code.\n"
" 1. (Medium) Use the `sequence` function defined in `Data.Traversable` to write a function\n"
msgstr ""
"     この関数はコードブロックの字下げを深くします。\n"
"1. （普通）`Data.Traversable`で定義された `sequence`関数を使用して、次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:253
#, no-wrap
msgid ""
"     ```haskell\n"
"     cat :: Array Doc -> Doc\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     cat :: Array Doc -> Doc\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:256
#, no-wrap
msgid ""
"     which concatenates a collection of documents, separating them with new lines.\n"
" 1. (Medium) Use the `runReader` function to write a function\n"
msgstr ""
"     この関数は文書の集まりを改行で区切って連結します。\n"
"1. （普通）`runReader`関数を使用して次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:260
#, no-wrap
msgid ""
"     ```haskell\n"
"     render :: Doc -> String\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     render :: Doc -> String\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:262
#, no-wrap
msgid "     which renders a document as a String.\n"
msgstr "     この関数は文書を文字列として出力します。\n"

#. type: Plain text
#: text/chapter11.md:264
#, no-wrap
msgid " You should now be able to use your library to write simple documents, as follows:\n"
msgstr " これで、このライブラリを次のように使うと、簡単な文書を書くことができるでしょう。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:265
#, no-wrap
msgid ""
" render $ cat\n"
"   [ line \"Here is some indented text:\"\n"
"   , indent $ cat\n"
"       [ line \"I am indented\"\n"
"       , line \"So am I\"\n"
"       , indent $ line \"I am even more indented\"\n"
"       ]\n"
"   ]\n"
msgstr ""
" render $ cat\n"
"   [ line \"Here is some indented text:\"\n"
"   , indent $ cat\n"
"       [ line \"I am indented\"\n"
"       , line \"So am I\"\n"
"       , indent $ line \"I am even more indented\"\n"
"       ]\n"
"   ]\n"

#. type: Title ##
#: text/chapter11.md:276
#, no-wrap
msgid "The Writer Monad"
msgstr "Writerモナド"

#. type: Plain text
#: text/chapter11.md:279
msgid ""
"The `Writer` monad provides the ability to accumulate a secondary value in "
"addition to the return value of a computation."
msgstr ""
"`Writer`モナドは、計算の返り値に加えて、もう1つの値を累積していく機能を提供し"
"ます。"

#. type: Plain text
#: text/chapter11.md:281
msgid ""
"A common use case is to accumulate a log of type `String` or `Array String`, "
"but the `Writer` monad is more general than this. It can actually be used to "
"accumulate a value in any monoid, so it might be used to keep track of an "
"integer total using the `Additive Int` monoid, or to track whether any of "
"several intermediate `Boolean` values were true, using the `Disj Boolean` "
"monoid."
msgstr ""
"よくある使い方としては型 `String`もしくは `Array String`でログを累積していく"
"というものなどがありますが、 `Writer`モナドはこれよりもっと一般的なもので"
"す。\n"
"累積するのに任意のモノイドの値を使うことができ、`Additive Int`モノイドを使っ"
"て、合計を追跡し続けるのに使ったり、 `Disj Boolean`モノイドを使って途中の "
"`Boolean`値の何れかが真であるかどうかを追跡するのに使うことができます。"

#. type: Plain text
#: text/chapter11.md:283
msgid ""
"The `Writer` type constructor takes two type arguments: a type `w` which "
"should be an instance of the `Monoid` type class, and the return type `a`."
msgstr ""
"`Writer`型の構築子は、 `Monoid`型クラスのインスタンスである型 `w`、および返り"
"値の型 `a`という2つの型引数を取ります。"

#. type: Plain text
#: text/chapter11.md:285
msgid "The key element of the `Writer` API is the `tell` function:"
msgstr "`Writer`のAPIで重要なのは `tell`関数です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:286
#, no-wrap
msgid "tell :: forall w a. Monoid w => w -> Writer w Unit\n"
msgstr "tell :: forall w a. Monoid w => w -> Writer w Unit\n"

#. type: Plain text
#: text/chapter11.md:291
msgid ""
"The `tell` action appends the provided value to the current accumulated "
"result."
msgstr "`tell`アクションは、与えられた値を現在の累積結果に付け加えます。"

#. type: Plain text
#: text/chapter11.md:293
msgid ""
"As an example, let's add a log to an existing function by using the `Array "
"String` monoid. Consider our previous implementation of the _greatest common "
"divisor_ function:"
msgstr ""
"例として、 `Array String`モノイドを使用して、既存の関数にログ機能を追加してみ"
"ましょう。 _最大公約数_ 関数の以前の実装を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:294
#, no-wrap
msgid ""
"gcd :: Int -> Int -> Int\n"
"gcd n 0 = n\n"
"gcd 0 m = m\n"
"gcd n m = if n > m\n"
"            then gcd (n - m) m\n"
"            else gcd n (m - n)\n"
msgstr ""
"gcd :: Int -> Int -> Int\n"
"gcd n 0 = n\n"
"gcd 0 m = m\n"
"gcd n m = if n > m\n"
"            then gcd (n - m) m\n"
"            else gcd n (m - n)\n"

#. type: Plain text
#: text/chapter11.md:304
msgid ""
"We could add a log to this function by changing the return type to `Writer "
"(Array String) Int`:"
msgstr ""
"`Writer (Array String) Int`へと返り値の型を変更することで、この関数にログ機能"
"を追加できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:305
#, no-wrap
msgid ""
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"\n"
"gcdLog :: Int -> Int -> Writer (Array String) Int\n"
msgstr ""
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"\n"
"gcdLog :: Int -> Int -> Writer (Array String) Int\n"

#. type: Plain text
#: text/chapter11.md:313
msgid ""
"We only have to change our function slightly to log the two inputs at each "
"step:"
msgstr ""
"各手順での2つの入力を記録するためには、少し関数を変更する必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:314
#, no-wrap
msgid ""
"    gcdLog n 0 = pure n\n"
"    gcdLog 0 m = pure m\n"
"    gcdLog n m = do\n"
"      tell [\"gcdLog \" <> show n <> \" \" <> show m]\n"
"      if n > m\n"
"        then gcdLog (n - m) m\n"
"        else gcdLog n (m - n)\n"
msgstr ""
"    gcdLog n 0 = pure n\n"
"    gcdLog 0 m = pure m\n"
"    gcdLog n m = do\n"
"      tell [\"gcdLog \" <> show n <> \" \" <> show m]\n"
"      if n > m\n"
"        then gcdLog (n - m) m\n"
"        else gcdLog n (m - n)\n"

#. type: Plain text
#: text/chapter11.md:325
msgid ""
"We can run a computation in the `Writer` monad by using either of the "
"`execWriter` or `runWriter` functions:"
msgstr ""
"`Writer`モナドを計算するには、`execWriter`関数または`runWriter`関数の何れかを"
"使います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:326
#, no-wrap
msgid ""
"execWriter :: forall w a. Writer w a -> w\n"
"runWriter  :: forall w a. Writer w a -> Tuple a w\n"
msgstr ""
"execWriter :: forall w a. Writer w a -> w\n"
"runWriter  :: forall w a. Writer w a -> Tuple a w\n"

#. type: Plain text
#: text/chapter11.md:332
msgid ""
"Just like in the case of the `State` monad, `execWriter` only returns the "
"accumulated log, whereas `runWriter` returns both the log and the result."
msgstr ""
"ちょうど `State`モナドの場合と同じように、 `execWriter`が累積されたログだけを"
"返すのに対して、 `runWriter`は累積されたログと結果の両方を返します。"

#. type: Plain text
#: text/chapter11.md:334
msgid "We can test our modified function in PSCi:"
msgstr "PSCiで改変した関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:335
#, no-wrap
msgid ""
"> import Control.Monad.Writer\n"
"> import Control.Monad.Writer.Class\n"
"\n"
"> runWriter (gcdLog 21 15)\n"
"Tuple 3 [\"gcdLog 21 15\",\"gcdLog 6 15\",\"gcdLog 6 9\",\"gcdLog 6 3\",\"gcdLog 3 3\"]\n"
msgstr ""
"> import Control.Monad.Writer\n"
"> import Control.Monad.Writer.Class\n"
"\n"
"> runWriter (gcdLog 21 15)\n"
"Tuple 3 [\"gcdLog 21 15\",\"gcdLog 6 15\",\"gcdLog 6 9\",\"gcdLog 6 3\",\"gcdLog 3 3\"]\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:347
msgid ""
"(Medium) Rewrite the `sumArray` function above using the `Writer` monad and "
"the `Additive Int` monoid from the `monoid` package."
msgstr ""
"（普通）`Writer`モナドと `monoid`パッケージの `Additive Int`モノイドを使うよ"
"うに、上の `sumArray`関数を書き換えてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:347
msgid ""
"(Medium) The _Collatz_ function is defined on natural numbers `n` as `n / 2` "
"when `n` is even, and `3 * n + 1` when `n` is odd. For example, the iterated "
"Collatz sequence starting at `10` is as follows:"
msgstr ""
"（普通）*コラッツ関数*は、自然数 `n`が偶数なら `n / 2`、 `n`が奇数なら `3 * "
"n + 1`であると定義されています。\n"
"例えば`10`で始まるコラッツ数列は次のようになります。"

#. type: Plain text
#: text/chapter11.md:351
#, no-wrap
msgid ""
"     ```text\n"
"     10, 5, 16, 8, 4, 2, 1, ...\n"
"     ```\n"
msgstr ""
"     ```text\n"
"     10, 5, 16, 8, 4, 2, 1, ...\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:353
#, no-wrap
msgid "     It is conjectured that the iterated Collatz sequence always reaches `1` after some finite number of applications of the Collatz function.\n"
msgstr "     コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的に `1`になるということが予想されています。\n"

#. type: Plain text
#: text/chapter11.md:355
#, no-wrap
msgid "     Write a function which uses recursion to calculate how many iterations of the Collatz function are required before the sequence reaches `1`.\n"
msgstr "     数列が `1`に到達するまでに何回のコラッツ関数の適用が必要かを計算する再帰的な関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:357
#, no-wrap
msgid "     Modify your function to use the `Writer` monad to log each application of the Collatz function.\n"
msgstr "     `Writer`モナドを使用してコラッツ関数のそれぞれの適用の経過を記録するように、関数を変更してください。\n"

#. type: Title ##
#: text/chapter11.md:358
#, no-wrap
msgid "Monad Transformers"
msgstr "モナド変換子"

#. type: Plain text
#: text/chapter11.md:361
msgid ""
"Each of the three monads above: `State`, `Reader` and `Writer`, are also "
"examples of so-called _monad transformers_. The equivalent monad "
"transformers are called `StateT`, `ReaderT`, and `WriterT` respectively."
msgstr ""
"上の3つのモナド、`State`、`Reader`、`Writer`は、何れもいわゆる*モナド変換子*"
"の例となっています。\n"
"対応するモナド変換子はそれぞれ `StateT`、 `ReaderT`、 `WriterT`と呼ばれていま"
"す。"

#. type: Plain text
#: text/chapter11.md:363
msgid ""
"What is a monad transformer? Well, as we have seen, a monad augments "
"PureScript code with some type of side effect, which can be interpreted in "
"PureScript by using the appropriate handler (`runState`, `runReader`, "
"`runWriter`, etc.) This is fine if we only need to use _one_ side-effect. "
"However, it is often useful to use more than one side-effect at once. For "
"example, we might want to use `Reader` together with `Maybe` to express "
"_optional results_ in the context of some global configuration. Or we might "
"want the mutable state provided by the `State` monad together with the pure "
"error tracking capability of the `Either` monad. This is the problem solved "
"by _monad transformers_."
msgstr ""
"モナド変換子とは何でしょうか。\n"
"さて、これまで見てきたように、モナドはPureScriptのコードを何らかの種類の副作"
"用で拡張するものでした。\n"
"このモナドはPureScriptで適切な制御子（`runState`、 `runReader`、`runWriter`な"
"ど）を使って解釈できます。\n"
"使用する必要がある副作用が*1つだけ*なら、これで問題ありません。\n"
"しかし、同時に複数の副作用を使用できると便利なことがよくあります。\n"
"例えば、 `Maybe`と`Reader`を一緒に使用すると、ある大域的な設定の文脈で*省略可"
"能な結果*を表現できます。\n"
"もしくは、 `Either`モナドの純粋なエラー追跡機能と、 `State`モナドが提供する変"
"更可能な状態が同時に欲しくなるかもしれません。\n"
"この問題を解決するのが*モナド変換子*です。"

#. type: Plain text
#: text/chapter11.md:365
msgid ""
"Note that we have already seen that the `Effect` monad provides a partial "
"solution to this problem. Monad transformers provide another solution, and "
"each approach has its own benefits and limitations."
msgstr ""
"ただし`Effect`モナドがこの問題に対する部分的な解決策を提供していたことは既に"
"見てきました。\n"
"モナド変換子はまた違った解決策を提供しますが、これらの手法にはそれぞれ利点と"
"制約があります。"

#. type: Plain text
#: text/chapter11.md:367
msgid ""
"A monad transformer is a type constructor which is parameterized not only by "
"a type, but by another type constructor. It takes one monad and turns it "
"into another monad, adding its own variety of side-effects."
msgstr ""
"モナド変換子は型だけでなく別の型構築子もパラメータに取る型構築子です。モナド"
"変換子はモナドを1つ取り、独自のいろいろな副作用を追加した別のモナドへと変換し"
"ます。"

#. type: Plain text
#: text/chapter11.md:369
msgid ""
"Let's see an example. The monad transformer version of the `State` monad is "
"`StateT`, defined in the `Control.Monad.State.Trans` module. We can find the "
"kind of `StateT` using PSCi:"
msgstr ""
"例を見てみましょう。`State`のモナド変換子版は`Control.Monad.State.Trans`モ"
"ジュールで定義されている`StateT`です。\n"
"PSCiを使って `StateT`の種を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:370
#, no-wrap
msgid ""
"> import Control.Monad.State.Trans\n"
"> :kind StateT\n"
"Type -> (Type -> Type) -> Type -> Type\n"
msgstr ""
"> import Control.Monad.State.Trans\n"
"> :kind StateT\n"
"Type -> (Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:377
msgid ""
"This looks quite confusing, but we can apply `StateT` one argument at a time "
"to understand how to use it."
msgstr ""
"とても読みにくそうに見えるかもしれませんが、使い方を理解するために、`StateT`"
"に1つ引数を与えてみましょう。"

#. type: Plain text
#: text/chapter11.md:379
msgid ""
"The first type argument is the type of the state we wish to use, as was the "
"case for `State`. Let's use a state of type `String`:"
msgstr ""
"`State`の場合、最初の型引数は使いたい状態の型です。\n"
"それでは型`String`を与えてみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:380
#, no-wrap
msgid ""
"> :kind StateT String\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""
"> :kind StateT String\n"
"(Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:386
#, no-wrap
msgid "The next argument is a type constructor of kind `Type -> Type`. It represents the underlying monad, which we want to add the effects of `StateT` to. For the sake of an example, let's choose the `Either String` monad:\n"
msgstr ""
"次の引数は種 `Type -> Type`の型構築子です。\n"
"これは `StateT`の機能を追加したい元のモナドを表します。\n"
"例として、 `Either String`モナドを選んでみます。\n"

#. type: Fenced code block (text)
#: text/chapter11.md:387
#, no-wrap
msgid ""
"> :kind StateT String (Either String)\n"
"Type -> Type\n"
msgstr ""
"> :kind StateT String (Either String)\n"
"Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:393
msgid ""
"We are left with a type constructor. The final argument represents the "
"return type, and we might instantiate it to `Number` for example:"
msgstr ""
"型構築子が残りました。\n"
"最後の引数は戻り値の型を表しており、例えばそれを`Number`にできます。"

#. type: Fenced code block (text)
#: text/chapter11.md:394
#, no-wrap
msgid ""
"> :kind StateT String (Either String) Number\n"
"Type\n"
msgstr ""
"> :kind StateT String (Either String) Number\n"
"Type\n"

#. type: Plain text
#: text/chapter11.md:400
msgid ""
"Finally we are left with something of kind `Type`, which means we can try to "
"find values of this type."
msgstr ""
"最後に、種 `Type`の何かが残りましたが、これはつまりこの型の値を探してみること"
"ができるということです。"

#. type: Plain text
#: text/chapter11.md:402
msgid ""
"The monad we have constructed - `StateT String (Either String)` - represents "
"computations which can fail with an error, and which can use mutable state."
msgstr ""
"構築したモナド `StateT String (Either String)`は、エラーで失敗する可能性があ"
"り、変更可能な状態を使える計算を表しています。"

#. type: Plain text
#: text/chapter11.md:404
msgid ""
"We can use the actions of the outer `StateT String` monad (`get`, `put`, and "
"`modify`) directly, but in order to use the effects of the wrapped monad "
"(`Either String`), we need to \"lift\" them over the monad transformer. The "
"`Control.Monad.Trans` module defines the `MonadTrans` type class, which "
"captures those type constructors which are monad transformers, as follows:"
msgstr ""
"外側の `StateT String (Either String)`モナドのアクション（`get`、`put`、"
"`modify`）は直接使うことができますが、梱包されている内側のモナド (`Either "
"String`) の作用を使うためには、これらの関数をモナド変換子まで「持ち上げ」なく"
"てはいけません。\n"
"`Control.MonadTrans`モジュールでは、モナド変換子であるような型構築子を捉える"
"`MonadTrans`型クラスを次のように定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:405
#, no-wrap
msgid ""
"class MonadTrans t where\n"
"  lift :: forall m a. Monad m => m a -> t m a\n"
msgstr ""
"class MonadTrans t where\n"
"  lift :: forall m a. Monad m => m a -> t m a\n"

#. type: Plain text
#: text/chapter11.md:411
msgid ""
"This class contains a single member, `lift`, which takes computations in any "
"underlying monad `m` and lifts them into the wrapped monad `t m`. In our "
"case, the type constructor `t` is `StateT String`, and `m` is the `Either "
"String` monad, so `lift` provides a way to lift computations of type `Either "
"String a` to computations of type `StateT String (Either String) a`. This "
"means that we can use the effects of `StateT String` and `Either String` "
"side-by-side, as long as we use `lift` every time we use a computation of "
"type `Either String a`."
msgstr ""
"このクラスは、基礎となる任意のモナド `m`の計算をとり、それを梱包されたモナド "
"`t m`へと持ち上げる、 `lift`という1つの関数だけを持っています。\n"
"今回の場合、型構築子 `t`は `StateT String`で、 `m`は `Either String`モナドと"
"なり、 `lift`は型 `Either String a`の計算を、型 `State String (Either "
"String) a`の計算へと持ち上げる方法を提供することになります。\n"
"これは、型 `Either String a`の計算を使うときは、 `lift`を使えばいつでも作用 "
"`StateT String`と `Either String`を一緒に使うことができることを意味します。"

#. type: Plain text
#: text/chapter11.md:413
msgid ""
"For example, the following computation reads the underlying state, and then "
"throws an error if the state is the empty string:"
msgstr ""
"例えば、次の計算は `StateT`モナド変換子で導入されている状態を読み込み、状態が"
"空の文字列である場合はエラーを投げます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:414
#, no-wrap
msgid ""
"import Data.String (drop, take)\n"
"\n"
"split :: StateT String (Either String) String\n"
"split = do\n"
"  s <- get\n"
"  case s of\n"
"    \"\" -> lift $ Left \"Empty string\"\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""
"import Data.String (drop, take)\n"
"\n"
"split :: StateT String (Either String) String\n"
"split = do\n"
"  s <- get\n"
"  case s of\n"
"    \"\" -> lift $ Left \"Empty string\"\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"

#. type: Plain text
#: text/chapter11.md:428
msgid ""
"If the state is not empty, the computation uses `put` to update the state to "
"`drop 1 s` (that is, `s` with the first character removed), and returns "
"`take 1 s` (that is, the first character of `s`)."
msgstr ""
"状態が空でなければ、この計算は `put`を使って状態を `drop 1 s`（最初の文字を取"
"り除いた `s`）へと更新し、 `take 1 s`（`s`の最初の文字）を返します。"

#. type: Plain text
#: text/chapter11.md:430
msgid "Let's try this in PSCi:"
msgstr "それではPSCiでこれを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:431
#, no-wrap
msgid ""
"> runStateT split \"test\"\n"
"Right (Tuple \"t\" \"est\")\n"
"\n"
"> runStateT split \"\"\n"
"Left \"Empty string\"\n"
msgstr ""
"> runStateT split \"test\"\n"
"Right (Tuple \"t\" \"est\")\n"
"\n"
"> runStateT split \"\"\n"
"Left \"Empty string\"\n"

#. type: Plain text
#: text/chapter11.md:440
msgid ""
"This is not very remarkable, since we could have implemented this without "
"`StateT`. However, since we are working in a monad, we can use do notation "
"or applicative combinators to build larger computations from smaller ones. "
"For example, we can apply `split` twice to read the first two characters "
"from a string:"
msgstr ""
"これは `StateT`を使わなくても実装できるので、さほど驚くようなことはありませ"
"ん。\n"
"しかし、モナドとして扱っているので、do記法やアプリカティブコンビネータを使っ"
"て、小さな計算から大きな計算を構築していくことができます。\n"
"例えば、2回 `split`を適用すると、文字列から最初の2文字を読むことができます。"

#. type: Fenced code block (text)
#: text/chapter11.md:441
#, no-wrap
msgid ""
"> runStateT ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple \"te\" \"st\"))\n"
msgstr ""
"> runStateT ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple \"te\" \"st\"))\n"

#. type: Plain text
#: text/chapter11.md:447
msgid ""
"We can use the `split` function with a handful of other actions to build a "
"basic parsing library. In fact, this is the approach taken by the `parsing` "
"library. This is the power of monad transformers - we can create custom-"
"built monads for a variety of problems, choosing the side-effects that we "
"need, and keeping the expressiveness of do notation and applicative "
"combinators."
msgstr ""
"他にもアクションを沢山用意すれば、 `split`関数を使って、基本的な構文解析ライ"
"ブラリを構築できます。これは実際に `parsing`ライブラリで採用されている手法で"
"す。これがモナド変換子の力なのです。必要な副作用を選択して、do記法とアプリカ"
"ティブコンビネータで表現力を維持しながら、様々な問題のための特注のモナドを作"
"成できるのです。"

#. type: Title ##
#: text/chapter11.md:448
#, no-wrap
msgid "The ExceptT Monad Transformer"
msgstr "ExceptTモナド変換子"

#. type: Plain text
#: text/chapter11.md:451
msgid ""
"The `transformers` package also defines the `ExceptT e` monad transformer, "
"which is the transformer corresponding to the `Either e` monad. It provides "
"the following API:"
msgstr ""
"`transformers`パッケージでは、 `Either e`モナドに対応する変換子である"
"`ExceptT e`モナド変換子も定義されています。\n"
"これは次のAPIを提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:452
#, no-wrap
msgid ""
"class MonadError e m where\n"
"  throwError :: forall a. e -> m a\n"
"  catchError :: forall a. m a -> (e -> m a) -> m a\n"
"\n"
"instance monadErrorExceptT :: Monad m => MonadError e (ExceptT e m)\n"
"\n"
"runExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\n"
msgstr ""
"class MonadError e m where\n"
"  throwError :: forall a. e -> m a\n"
"  catchError :: forall a. m a -> (e -> m a) -> m a\n"
"\n"
"instance monadErrorExceptT :: Monad m => MonadError e (ExceptT e m)\n"
"\n"
"runExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\n"

#. type: Plain text
#: text/chapter11.md:463
msgid ""
"The `MonadError` class captures those monads which support throwing and "
"catching of errors of some type `e`, and an instance is provided for the "
"`ExceptT e` monad transformer. The `throwError` action can be used to "
"indicate failure, just like `Left` in the `Either e` monad. The `catchError` "
"action allows us to continue after an error is thrown using `throwError`."
msgstr ""
"`MonadError`クラスは `e`型のエラーを投げたりキャッチに対応したりするモナドを"
"取得し、 `ExceptT e`モナド変換子のインスタンスが提供されます。\n"
"`Either e`モナドの `Left`と同じように、 `throwError`アクションは失敗を示すた"
"めに使われます。\n"
"`catchError`アクションを使うと、 `throwError`でエラーが投げられたあとでも処理"
"を継続できるようになります。"

#. type: Plain text
#: text/chapter11.md:465
msgid ""
"The `runExceptT` handler is used to run a computation of type `ExceptT e m "
"a`."
msgstr "`runExceptT`制御子を使うと、型 `ExceptT e m a`を計算できます。"

#. type: Plain text
#: text/chapter11.md:467
msgid ""
"This API is similar to that provided by the `exceptions` package and the "
"`Exception` effect. However, there are some important differences:"
msgstr ""
"このAPIは `exceptions`パッケージの `Exception`作用によって提供されているもの"
"と似ています。\n"
"しかし、幾つかの重要な違いがあります。"

#. type: Bullet: '- '
#: text/chapter11.md:470
msgid ""
"`Exception` uses actual JavaScript exceptions, whereas `ExceptT` models "
"errors as a pure data structure."
msgstr ""
"`Exception`が実際のJavaScriptの例外を使っているのに対して`ExceptT`モデルは代"
"数的データ型を使っています。"

#. type: Bullet: '- '
#: text/chapter11.md:470
msgid ""
"The `Exception` effect only supports exceptions of one type, namely "
"JavaScript's `Error` type, whereas `ExceptT` supports errors of any type. In "
"particular, we are free to define new error types."
msgstr ""
"`Exception`作用がJavaScriptの`Error`型という1つの例外の型だけを扱うのに対し"
"て、`ExceptT`は`Error`型クラスのどんな型のエラーでも扱います。つまり、 "
"`ExceptT`では新たなエラー型を自由に定義できます。"

#. type: Plain text
#: text/chapter11.md:472
msgid ""
"Let's try out `ExceptT` by using it to wrap the `Writer` monad. Again, we "
"are free to use actions from the monad transformer `ExceptT e` directly, but "
"computations in the `Writer` monad should be lifted using `lift`:"
msgstr ""
"試しに `ExceptT`を使って `Writer`モナドを包んでみましょう。\n"
"ここでもモナド変換子 `ExceptT e`のアクションを直接使うことも自由にできます"
"が、`Writer`モナドの計算は `lift`を使って持ちあげるべきです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:473
#, no-wrap
msgid ""
"import Control.Monad.Except\n"
"import Control.Monad.Writer\n"
"\n"
"writerAndExceptT :: ExceptT String (Writer (Array String)) String\n"
"writerAndExceptT = do\n"
"  lift $ tell [\"Before the error\"]\n"
"  _ <- throwError \"Error!\"\n"
"  lift $ tell [\"After the error\"]\n"
"  pure \"Return value\"\n"
msgstr ""
"import Control.Monad.Except\n"
"import Control.Monad.Writer\n"
"\n"
"writerAndExceptT :: ExceptT String (Writer (Array String)) String\n"
"writerAndExceptT = do\n"
"  lift $ tell [\"Before the error\"]\n"
"  _ <- throwError \"Error!\"\n"
"  lift $ tell [\"After the error\"]\n"
"  pure \"Return value\"\n"

#. type: Plain text
#: text/chapter11.md:486
msgid ""
"If we test this function in PSCi, we can see how the two effects of "
"accumulating a log and throwing an error interact. First, we can run the "
"outer `ExceptT` computation of type by using `runExceptT`, leaving a result "
"of type `Writer (Array String) (Either String String)`. We can then use "
"`runWriter` to run the inner `Writer` computation:"
msgstr ""
"PSCiでこの関数を試すと、ログの蓄積とエラーの送出という2つの作用がどのように相"
"互作用しているのかを見ることができます。\n"
"まず、 `runExceptT`を使って外側の`ExceptT`を計算し、型 `Writer (Array "
"String) (Either String String)`の結果を残します。\n"
"それから、 `runWriter`で内側の`Writer`を計算します。"

#. type: Fenced code block (text)
#: text/chapter11.md:487
#, no-wrap
msgid ""
"> runWriter $ runExceptT writerAndExceptT\n"
"Tuple (Left \"Error!\") [\"Before the error\"]\n"
msgstr ""
"> runWriter $ runExceptT writerAndExceptT\n"
"Tuple (Left \"Error!\") [\"Before the error\"]\n"

#. type: Plain text
#: text/chapter11.md:493
msgid ""
"Note that only those log messages which were written before the error was "
"thrown actually get appended to the log."
msgstr ""
"実際に追加されるログは、エラーが投げられる前に書かれたログメッセージだけであ"
"ることにも注目してください。"

#. type: Title ##
#: text/chapter11.md:494
#, no-wrap
msgid "Monad Transformer Stacks"
msgstr "モナド変換子スタック"

#. type: Plain text
#: text/chapter11.md:497
msgid ""
"As we have seen, monad transformers can be used to build new monads on top "
"of existing monads. For some monad transformer `t1` and some monad `m`, the "
"application `t1 m` is also a monad. That means that we can apply a _second_ "
"monad transformer `t2` to the result `t1 m` to construct a third monad `t2 "
"(t1 m)`. In this way, we can construct a _stack_ of monad transformers, "
"which combine the side-effects provided by their constituent monads."
msgstr ""
"これまで見てきたように、モナド変換子を使うと既存のモナドを土台に新しいモナド"
"を構築できます。\n"
"任意のモナド変換子 `t1`と任意のモナド`m`について、その適用 `t1 m`もまたモナド"
"になります。\n"
"これは*2つめの*モナド変換子 `t2`を先ほどの結果 `t1 m`に適用すると、3つ目のモ"
"ナド `t2 (t1 m)`を作れることを意味しています。\n"
"このように、構成するモナドによって提供された副作用を組み合わせる、モナド変換"
"子の*スタック*を構築できます。"

#. type: Plain text
#: text/chapter11.md:499
msgid ""
"In practice, the underlying monad `m` is either the `Effect` monad, if "
"native side-effects are required, or the `Identity` monad, defined in the "
"`Data.Identity` module. The `Identity` monad adds no new side-effects, so "
"transforming the `Identity` monad only provides the effects of the monad "
"transformer. In fact, the `State`, `Reader` and `Writer` monads are "
"implemented by transforming the `Identity` monad with `StateT`, `ReaderT` "
"and `WriterT` respectively."
msgstr ""
"実際には、基本となるモナド`m`は、ネイティブの副作用が必要なら`Effect`モナド、"
"さもなくば `Data.Identity`モジュールで定義されている`Identity`モナドになりま"
"す。\n"
"`Identity`モナドは何の新しい副作用も追加しませんから、`Identity`モナドの変換"
"はモナド変換子の作用だけを提供します。\n"
"実際に、`State`モナドと`Reader`モナドと`Writer`モナドは、`Identity`モナドをそ"
"れぞれ`StateT`と`ReaderT`と`WriterT`で変換することによって実装されています。"

#. type: Plain text
#: text/chapter11.md:501
msgid ""
"Let's see an example in which three side effects are combined. We will use "
"the `StateT`, `WriterT` and `ExceptT` effects, with the `Identity` monad on "
"the bottom of the stack. This monad transformer stack will provide the side "
"effects of mutable state, accumulating a log, and pure errors."
msgstr ""
"それでは3つの副作用が組み合わされている例を見てみましょう。\n"
"`Identity`モナドをスタックの底にして、 `StateT`作用、 `WriterT`作用、"
"`ExceptT`作用を使います。\n"
"このモナド変換子スタックは、可変状態、ログの蓄積、そして純粋なエラーの副作用"
"を提供します。"

#. type: Plain text
#: text/chapter11.md:503
msgid ""
"We can use this monad transformer stack to reproduce our `split` action with "
"the added feature of logging."
msgstr ""
"このモナド変換子スタックを使うと、ロギングの機能が追加された `split`アクショ"
"ンに作り変えられます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:504
#, no-wrap
msgid ""
"type Errors = Array String\n"
"\n"
"type Log = Array String\n"
"\n"
"type Parser = StateT String (WriterT Log (ExceptT Errors Identity))\n"
"\n"
"split :: Parser String\n"
"split = do\n"
"  s <- get\n"
"  lift $ tell [\"The state is \" <> s]\n"
"  case s of\n"
"    \"\" -> lift $ lift $ throwError [\"Empty string\"]\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""
"type Errors = Array String\n"
"\n"
"type Log = Array String\n"
"\n"
"type Parser = StateT String (WriterT Log (ExceptT Errors Identity))\n"
"\n"
"split :: Parser String\n"
"split = do\n"
"  s <- get\n"
"  lift $ tell [\"The state is \" <> s]\n"
"  case s of\n"
"    \"\" -> lift $ lift $ throwError [\"Empty string\"]\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"

#. type: Plain text
#: text/chapter11.md:523
msgid ""
"If we test this computation in PSCi, we see that the state is appended to "
"the log for every invocation of `split`."
msgstr ""
"この計算をPSCiで試してみると、 `split`が実行されるたびに状態がログに追加され"
"ることがわかります。"

#. type: Plain text
#: text/chapter11.md:525
msgid ""
"Note that we have to remove the side-effects in the order in which they "
"appear in the monad transformer stack: first we use `runStateT` to remove "
"the `StateT` type constructor, then `runWriterT`, then `runExceptT`. "
"Finally, we run the computation in the `Identity` monad by using `unwrap`."
msgstr ""
"モナド変換子スタックに現れる順序に従って、副作用を取り除いていかなければなら"
"ないことに注意してください。\n"
"最初に `StateT`型構築子を取り除くために `runStateT`を使い、それから "
"`runtWriteT`を使い、その後`runExceptT`を使います。\n"
"最後に `unwrap`を使用して `Identity`モナドを演算します。"

#. type: Fenced code block (text)
#: text/chapter11.md:526
#, no-wrap
msgid ""
"> runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s\n"
"\n"
"> runParser split \"test\"\n"
"(Right (Tuple (Tuple \"t\" \"est\") [\"The state is test\"]))\n"
"\n"
"> runParser ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple (Tuple \"te\" \"st\") [\"The state is test\", \"The state is est\"]))\n"
msgstr ""
"> runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s\n"
"\n"
"> runParser split \"test\"\n"
"(Right (Tuple (Tuple \"t\" \"est\") [\"The state is test\"]))\n"
"\n"
"> runParser ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple (Tuple \"te\" \"st\") [\"The state is test\", \"The state is est\"]))\n"

#. type: Plain text
#: text/chapter11.md:537
msgid ""
"However, if the parse is unsuccessful because the state is empty, then no "
"log is printed at all:"
msgstr ""
"しかし、状態が空であることが理由で解析が失敗した場合、ログは全く出力されませ"
"ん。"

#. type: Fenced code block (text)
#: text/chapter11.md:538
#, no-wrap
msgid ""
"> runParser split \"\"\n"
"(Left [\"Empty string\"])\n"
msgstr ""
"> runParser split \"\"\n"
"(Left [\"Empty string\"])\n"

#. type: Plain text
#: text/chapter11.md:544
msgid ""
"This is because of the way in which the side-effects provided by the "
"`ExceptT` monad transformer interact with the side-effects provided by the "
"`WriterT` monad transformer. We can address this by changing the order in "
"which the monad transformer stack is composed. If we move the `ExceptT` "
"transformer to the top of the stack, then the log will contain all messages "
"written up until the first error, as we saw earlier when we transformed "
"`Writer` with `ExceptT`."
msgstr ""
"これは、 `ExceptT`モナド変換子が提供する副作用が、 `WriterT`モナド変換子が提"
"供する副作用と干渉するためです。\n"
"これはモナド変換子スタックが構成されている順序を変更することで解決できま"
"す。\n"
"スタックの最上部に `ExceptT`変換子を移動すると、先ほど `Writer`を `ExceptT`に"
"変換したときと同じように、最初のエラーまでに書かれた全てのメッセージが含まれ"
"るようになります。"

#. type: Plain text
#: text/chapter11.md:546
msgid ""
"One problem with this code is that we have to use the `lift` function "
"multiple times to lift computations over multiple monad transformers: for "
"example, the call to `throwError` has to be lifted twice, once over "
"`WriterT` and a second time over `StateT`. This is fine for small monad "
"transformer stacks, but quickly becomes inconvenient."
msgstr ""
"このコードの問題の1つは、複数のモナド変換子の上まで計算を持ち上げるために、 "
"`lift`関数を複数回使わなければならないということです。\n"
"例えば`throwError`の呼び出しは、1回目は `WriteT`へ、2回目は `StateT`へと、2回"
"持ちあげなければなりません。\n"
"小さなモナド変換子スタックならなんとかなりますが、そのうち不便だと感じるよう"
"になるでしょう。"

#. type: Plain text
#: text/chapter11.md:548
msgid ""
"Fortunately, as we will see, we can use the automatic code generation "
"provided by type class inference to do most of this \"heavy lifting\" for us."
msgstr ""
"幸いなことに、これから見るような型クラス推論によって提供されるコードの自動生"
"成を使うと、ほとんどの「重労働」を任せられます。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:553
msgid ""
"(Easy) Use the `ExceptT` monad transformer over the `Identity` functor to "
"write a function `safeDivide` which divides two numbers, throwing an error "
"(as the String \"Divide by zero!\") if the denominator is zero."
msgstr ""
"（簡単）`Identity`関手を土台とする`ExceptT`モナド変換子を使って、2つの数の商"
"を求める関数 `safeDivide`を書いてください。\n"
"この関数は分母がゼロの場合に（文字列「Divide by zero!」の）エラーを投げます。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:553
msgid "(Medium) Write a parser"
msgstr "（普通）次のような構文解析関数を書いてください。"

#. type: Plain text
#: text/chapter11.md:557
#, no-wrap
msgid ""
"     ```haskell\n"
"     string :: String -> Parser String\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     string :: String -> Parser String\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:559
#, no-wrap
msgid "     which matches a string as a prefix of the current state, or fails with an error message.\n"
msgstr "     これは現在の状態が接頭辞に適合するか、もしくはエラーメッセージとともに失敗します。\n"

#. type: Plain text
#: text/chapter11.md:561
#, no-wrap
msgid "     Your parser should work as follows:\n"
msgstr "     この構文解析器は次のように動作します。\n"

#. type: Plain text
#: text/chapter11.md:566
#, no-wrap
msgid ""
"     ```text\n"
"     > runParser (string \"abc\") \"abcdef\"\n"
"     (Right (Tuple (Tuple \"abc\" \"def\") [\"The state is abcdef\"]))\n"
"     ```\n"
msgstr ""
"     ```text\n"
"     > runParser (string \"abc\") \"abcdef\"\n"
"     (Right (Tuple (Tuple \"abc\" \"def\") [\"The state is abcdef\"]))\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:569
#, no-wrap
msgid ""
"     _Hint_: you can use the implementation of `split` as a starting point. You might find the `stripPrefix` function useful.\n"
" 1. (Difficult) Use the `ReaderT` and `WriterT` monad transformers to reimplement the document printing library which we wrote earlier using the `Reader` monad.\n"
msgstr ""
"     *手掛かり*：出発点として`split`の実装を使うといいでしょう。\n"
"     `stripPrefix`関数も役に立ちます。\n"
"1. （難しい）以前 `Reader`モナドを使用して書いた文書表示ライブラリを、`ReaderT`と `WriterT`モナド変換子を使用して再実装してください。\n"

#. type: Plain text
#: text/chapter11.md:571
#, no-wrap
msgid "     Instead of using `line` to emit strings and `cat` to concatenate strings, use the `Array String` monoid with the `WriterT` monad transformer, and `tell` to append a line to the result. Use the same names as in the original implementation but ending with an apostrophe (`'`).\n"
msgstr ""
"     文字列を出力する `line`や文字列を連結する `cat`を使うのではなく、`WriteT`モナド変換子と一緒に `Array String`モノイドを使い、結果へ行を追加するのに `tell`を使ってください。\n"
"     アポストロフィ (`'`) を付ける以外は元の実装と同じ名前を使ってください。\n"

# もしかして：アカリがやってきたぞっ
#. type: Title ##
#: text/chapter11.md:572
#, no-wrap
msgid "Type Classes to the Rescue!"
msgstr "型クラスが助けに来たぞっ"

#. type: Plain text
#: text/chapter11.md:575
msgid ""
"When we looked at the `State` monad at the start of this chapter, I gave the "
"following types for the actions of the `State` monad:"
msgstr ""
"本章の最初で扱った `State`モナドを見てみると、 `State`モナドのアクションには"
"次のような型が与えられていました。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:576
#, no-wrap
msgid ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"
msgstr ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"

#. type: Plain text
#: text/chapter11.md:583
msgid ""
"In reality, the types given in the `Control.Monad.State.Class` module are "
"more general than this:"
msgstr ""
"`Control.Monad.State.Class`モジュールで与えられている型は、実際にはこれより"
"もっと一般的です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:584
#, no-wrap
msgid ""
"get    :: forall m s. MonadState s m =>             m s\n"
"put    :: forall m s. MonadState s m => s        -> m Unit\n"
"modify :: forall m s. MonadState s m => (s -> s) -> m Unit\n"
msgstr ""
"get    :: forall m s. MonadState s m =>             m s\n"
"put    :: forall m s. MonadState s m => s        -> m Unit\n"
"modify :: forall m s. MonadState s m => (s -> s) -> m Unit\n"

#. type: Plain text
#: text/chapter11.md:591
msgid ""
"The `Control.Monad.State.Class` module defines the `MonadState` (multi-"
"parameter) type class, which allows us to abstract over \"monads which "
"support pure mutable state\". As one would expect, the `State s` type "
"constructor is an instance of the `MonadState s` type class, but there are "
"many more interesting instances of this class."
msgstr ""
"`Control.Monad.State.Class`モジュールには`MonadState`（多変数）型クラスが定義"
"されています。\n"
"この型クラスは「変更可能な状態を提供する純粋なモナド」への抽象化を可能にしま"
"す。\n"
"予想できると思いますが、 `State s`型構築子は `MonadState s`型クラスのインスタ"
"ンスになっており、このクラスには他にも興味深いインスタンスが数多くあります。"

#. type: Plain text
#: text/chapter11.md:593
msgid ""
"In particular, there are instances of `MonadState` for the `WriterT`, "
"`ReaderT` and `ExceptT` monad transformers, provided in the `transformers` "
"package. Each of these monad transformers has an instance for `MonadState` "
"whenever the underlying `Monad` does. In practice, this means that as long "
"as `StateT` appears _somewhere_ in the monad transformer stack, and "
"everything above `StateT` is an instance of `MonadState`, then we are free "
"to use `get`, `put` and `modify` directly, without the need to use `lift`."
msgstr ""
"特に、 `transformers`パッケージではモナド変換子 `WriterT`、 `ReaderT`、"
"`ExceptT`についての `MonadState`のインスタンスが提供されています。\n"
"通底する`Monad`が`MonadState`インスタンスを持っていれば常に、これらのモナド変"
"換子にもインスタンスがあります。\n"
"実践的には、 `StateT`がモナド変換子スタックの*どこか*に現れ、 `StateT`より上"
"の全てが `MonadState`のインスタンスであれば、 `get`、 `put`、 `modify`を直接"
"自由に使用できます。"

#. type: Plain text
#: text/chapter11.md:595
msgid ""
"Indeed, the same is true of the actions we covered for the `ReaderT`, "
"`WriterT`, and `ExceptT` transformers. `transformers` defines a type class "
"for each of the major transformers, allowing us to abstract over monads "
"which support their operations."
msgstr ""
"当然ですが、これまで扱ってきた `ReaderT`、 `WriterT`、 `ExceptT`変換子につい"
"ても、同じことが成り立っています。`transformers`では主な変換子それぞれについ"
"ての型クラスが定義されています。これによりそれらの操作に対応するモナドの上に"
"抽象化できるのです。"

#. type: Plain text
#: text/chapter11.md:597
msgid ""
"In the case of the `split` function above, the monad stack we constructed is "
"an instance of each of the `MonadState`, `MonadWriter` and `MonadError` type "
"classes. This means that we don't need to call `lift` at all! We can just "
"use the actions `get`, `put`, `tell` and `throwError` as if they were "
"defined on the monad stack itself:"
msgstr ""
"上の `split`関数の場合、構築されたこのモナドスタックは型クラス`MonadState`、 "
"`MonadWriter`、 `MonadError`それぞれのインスタンスです。\n"
"これはつまり、`lift`は全く呼び出す必要がないのです。\n"
"まるでモナドスタック自体に定義されていたかのように、アクション `get`、"
"`put`、 `tell`、 `throwError`をそのまま使用できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:598
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:split}}\n"
msgstr "{{#include ../exercises/chapter11/src/Split.purs:split}}\n"

#. type: Plain text
#: text/chapter11.md:603
msgid ""
"This computation really looks like we have extended our programming language "
"to support the three new side-effects of mutable state, logging and error "
"handling. However, everything is still implemented using pure functions and "
"immutable data under the hood."
msgstr ""
"この計算はまるで、可変状態、ロギング、エラー処理という3つの副作用に対応した、"
"独自のプログラミング言語を拡張したかのようにみえます。\n"
"しかし、内部的には全てはあくまで純粋な関数と普通のデータを使って実装されてい"
"るのです。"

#. type: Title ##
#: text/chapter11.md:604
#, no-wrap
msgid "Alternatives"
msgstr "代替"

#. type: Plain text
#: text/chapter11.md:607
msgid ""
"The `control` package defines a number of abstractions for working with "
"computations which can fail. One of these is the `Alternative` type class:"
msgstr ""
"`control`パッケージでは失敗しうる計算を制御するための抽象化が幾つか定義されて"
"います。\n"
"その1つは `Alternative`型クラスです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:608
#, no-wrap
msgid ""
"class Functor f <= Alt f where\n"
"  alt :: forall a. f a -> f a -> f a\n"
"\n"
"class Alt f <= Plus f where\n"
"  empty :: forall a. f a\n"
"\n"
"class (Applicative f, Plus f) <= Alternative f\n"
msgstr ""
"class Functor f <= Alt f where\n"
"  alt :: forall a. f a -> f a -> f a\n"
"\n"
"class Alt f <= Plus f where\n"
"  empty :: forall a. f a\n"
"\n"
"class (Applicative f, Plus f) <= Alternative f\n"

#. type: Plain text
#: text/chapter11.md:619
#, no-wrap
msgid "`Alternative` provides two new combinators: the `empty` value, which provides a prototype for a failing computation, and the `alt` function (and its alias, `<|>`) which provides the ability to fall back to an _alternative_ computation in the case of an error.\n"
msgstr ""
"`Alternative`は2つの新しいコンビネータを提供しています。\n"
"1つは失敗しうる計算の雛形を提供する`empty`値で、もう1つはエラーが起きたときに*代替の*計算へ戻ってやり直す機能を提供する`alt`関数（そしてその別名`<|>`）です。\n"

#. type: Plain text
#: text/chapter11.md:621
msgid ""
"The `Data.Array` module provides two useful functions for working with type "
"constructors in the `Alternative` type class:"
msgstr ""
"`Data.Array`モジュールでは `Alternative`型クラスで型構築子を操作する2\n"
"つの便利な関数を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:622
#, no-wrap
msgid ""
"many :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
"some :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
msgstr ""
"many :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
"some :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"

#. type: Plain text
#: text/chapter11.md:628
msgid "There is also an equivalent `many` and `some` for `Data.List`"
msgstr "`Data.List`にも等価な`many`と`some`があります。"

#. type: Plain text
#: text/chapter11.md:630
msgid ""
"The `many` combinator uses the `Alternative` type class to repeatedly run a "
"computation _zero-or-more_ times. The `some` combinator is similar, but "
"requires at least the first computation to succeed."
msgstr ""
"`many`コンビネータは計算を _ゼロ回以上_ 繰り返し実行するために`Alternative`型"
"クラスを使用しています。 `some`コンビネータも似ていますが、成功するために少な"
"くとも1回の計算を必要とします。"

#. type: Plain text
#: text/chapter11.md:632
msgid ""
"In the case of our `Parser` monad transformer stack, there is an instance of "
"`Alternative` induced by the `ExceptT` component, which supports failure by "
"composing errors in different branches using a `Monoid` instance (this is "
"why we chose `Array String` for our `Errors` type). This means that we can "
"use the `many` and `some` functions to run a parser multiple times:"
msgstr ""
"`Parser`モナド変換子スタックの場合は、`ExceptT`コンポーネントによる"
"`Alternative`のインスタンスがあります。\n"
"このコンポーネントでは異なる分枝のエラーに`Monoid`インスタンスを使って組み合"
"わせることによって対応しています（だから`Errors`型に`Array String`を選ぶ必要"
"があったんですね）。\n"
"これは、構文解析器を複数回実行するのに`many`関数と`some`関数を使うことができ"
"ることを意味します。"

#. type: Fenced code block (text)
#: text/chapter11.md:633
#, no-wrap
msgid ""
"> import Data.Array (many)\n"
"\n"
"> runParser (many split) \"test\"\n"
"(Right (Tuple (Tuple [\"t\", \"e\", \"s\", \"t\"] \"\")\n"
"              [ \"The state is \\\"test\\\"\"\n"
"              , \"The state is \\\"est\\\"\"\n"
"              , \"The state is \\\"st\\\"\"\n"
"              , \"The state is \\\"t\\\"\"\n"
"              ]))\n"
msgstr ""
"> import Data.Array (many)\n"
"\n"
"> runParser (many split) \"test\"\n"
"(Right (Tuple (Tuple [\"t\", \"e\", \"s\", \"t\"] \"\")\n"
"              [ \"The state is \\\"test\\\"\"\n"
"              , \"The state is \\\"est\\\"\"\n"
"              , \"The state is \\\"st\\\"\"\n"
"              , \"The state is \\\"t\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:646
msgid ""
"Here, the input string `\"test\"` has been repeatedly split to return an "
"array of four single-character strings, the leftover state is empty, and the "
"log shows that we applied the `split` combinator four times."
msgstr ""
"ここでは入力文字列 `\"test\"`は、1文字からなる文字列4つの配列を返すように繰り"
"返し分割されています。\n"
"残った状態は空で、ログは `split`コンビネータが4回適用されたことを示していま"
"す。"

#. type: Title ##
#: text/chapter11.md:647
#, no-wrap
msgid "Monad Comprehensions"
msgstr "モナド内包表記"

#. type: Plain text
#: text/chapter11.md:650
msgid ""
"The `Control.MonadPlus` module defines a subclass of the `Alternative` type "
"class, called `MonadPlus`. `MonadPlus` captures those type constructors "
"which are both monads and instances of `Alternative`:"
msgstr ""
"`Control.MonadPlus`モジュールには `MonadPlus`と呼ばれる`Alternative`型クラス"
"の副クラスが定義されています。\n"
"`MonadPlus`はモナドと`Alternative`両方のインスタンスである型構築子を取りま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:651
#, no-wrap
msgid "class (Monad m, Alternative m) <= MonadPlus m\n"
msgstr "class (Monad m, Alternative m) <= MonadPlus m\n"

#. type: Plain text
#: text/chapter11.md:656
msgid "In particular, our `Parser` monad is an instance of `MonadPlus`."
msgstr "実際、`Parser`モナドは `MonadPlus`のインスタンスです。"

#. type: Plain text
#: text/chapter11.md:658
msgid ""
"When we covered array comprehensions earlier in the book, we introduced the "
"`guard` function, which could be used to filter out unwanted results. In "
"fact, the `guard` function is more general, and can be used for any monad "
"which is an instance of `MonadPlus`:"
msgstr ""
"以前本書中で配列内包表記を扱ったとき、不要な結果を除いて絞り込むために使われ"
"る`guard`関数を導入しました。\n"
"実際には`guard`関数はもっと一般的で、 `MonadPlus`のインスタンスである全てのモ"
"ナドに対して使うことができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:659
#, no-wrap
msgid "guard :: forall m. Alternative m => Boolean -> m Unit\n"
msgstr "guard :: forall m. Alternative m => Boolean -> m Unit\n"

#. type: Plain text
#: text/chapter11.md:664
#, no-wrap
msgid "The `<|>` operator allows us to backtrack in case of failure. To see how this is useful, let's define a variant of the `split` combinator which only matches upper case characters:\n"
msgstr ""
"`<|>`演算子は失敗時にバックトラッキングできるようにします。\n"
"これがどのように役立つかを見るために、大文字だけに適合する `split`コンビネータの亜種を定義してみましょう。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:665
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:upper}}\n"
msgstr "{{#include ../exercises/chapter11/src/Split.purs:upper}}\n"

#. type: Plain text
#: text/chapter11.md:670
msgid ""
"Here, we use a `guard` to fail if the string is not upper case. Note that "
"this code looks very similar to the array comprehensions we saw earlier - "
"using `MonadPlus` in this way, we sometimes refer to constructing _monad "
"comprehensions_."
msgstr ""
"ここで、文字列が大文字でない場合に失敗するよう `guard`を使用しています。この"
"コードは前に見た配列内包表記とよく似ていることに注目してください。このように"
"`MonadPlus`を使うことは、 _モナド内包表記_ (monad comprehensions) の構築と呼"
"ばれることがあります。"

#. type: Title ##
#: text/chapter11.md:671
#, no-wrap
msgid "Backtracking"
msgstr "バックトラッキング"

#. type: Plain text
#: text/chapter11.md:674
#, no-wrap
msgid "We can use the `<|>` operator to backtrack to another alternative in case of failure. To demonstrate this, let's define one more parser, which matches lower case characters:\n"
msgstr ""
"`<|>`演算子を使うと、失敗したときに別の代替計算へとバックトラックできます。\n"
"これを確かめるために、小文字に一致するもう1つの構文解析器を定義してみましょう。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:675
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:lower}}\n"
msgstr "{{#include ../exercises/chapter11/src/Split.purs:lower}}\n"

#. type: Plain text
#: text/chapter11.md:680
msgid ""
"With this, we can define a parser which eagerly matches many upper case "
"characters if the first character is upper case, or many lower case "
"character if the first character is lower case:"
msgstr ""
"これにより、まずもし最初の文字が大文字なら複数の大文字に適合し、さもなくばも"
"し最初の文字が小文字なら複数の小文字に適合する、という構文解析器を定義できま"
"す。"

#. type: Fenced code block (text)
#: text/chapter11.md:681
#, no-wrap
msgid "> upperOrLower = some upper <|> some lower\n"
msgstr "> upperOrLower = some upper <|> some lower\n"

#. type: Plain text
#: text/chapter11.md:686
msgid "This parser will match characters until the case changes:"
msgstr ""
"この構文解析器は、大文字と小文字が切り替わるまで、文字に適合し続けます。"

#. type: Fenced code block (text)
#: text/chapter11.md:687
#, no-wrap
msgid ""
"> runParser upperOrLower \"abcDEF\"\n"
"(Right (Tuple (Tuple [\"a\",\"b\",\"c\"] (\"DEF\"))\n"
"              [ \"The state is \\\"abcDEF\\\"\"\n"
"              , \"The state is \\\"bcDEF\\\"\"\n"
"              , \"The state is \\\"cDEF\\\"\"\n"
"              ]))\n"
msgstr ""
"> runParser upperOrLower \"abcDEF\"\n"
"(Right (Tuple (Tuple [\"a\",\"b\",\"c\"] (\"DEF\"))\n"
"              [ \"The state is \\\"abcDEF\\\"\"\n"
"              , \"The state is \\\"bcDEF\\\"\"\n"
"              , \"The state is \\\"cDEF\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:697
msgid ""
"We can even use `many` to fully split a string into its lower and upper case "
"components:"
msgstr "また、`many`を使うと文字列を小文字と大文字の要素に完全に分割できます。"

#. type: Fenced code block (text)
#: text/chapter11.md:698
#, no-wrap
msgid ""
"> components = many upperOrLower\n"
"\n"
"> runParser components \"abCDeFgh\"\n"
"(Right (Tuple (Tuple [[\"a\",\"b\"],[\"C\",\"D\"],[\"e\"],[\"F\"],[\"g\",\"h\"]] \"\")\n"
"              [ \"The state is \\\"abCDeFgh\\\"\"\n"
"              , \"The state is \\\"bCDeFgh\\\"\"\n"
"              , \"The state is \\\"CDeFgh\\\"\"\n"
"              , \"The state is \\\"DeFgh\\\"\"\n"
"              , \"The state is \\\"eFgh\\\"\"\n"
"              , \"The state is \\\"Fgh\\\"\"\n"
"              , \"The state is \\\"gh\\\"\"\n"
"              , \"The state is \\\"h\\\"\"\n"
"              ]))\n"
msgstr ""
"> components = many upperOrLower\n"
"\n"
"> runParser components \"abCDeFgh\"\n"
"(Right (Tuple (Tuple [[\"a\",\"b\"],[\"C\",\"D\"],[\"e\"],[\"F\"],[\"g\",\"h\"]] \"\")\n"
"              [ \"The state is \\\"abCDeFgh\\\"\"\n"
"              , \"The state is \\\"bCDeFgh\\\"\"\n"
"              , \"The state is \\\"CDeFgh\\\"\"\n"
"              , \"The state is \\\"DeFgh\\\"\"\n"
"              , \"The state is \\\"eFgh\\\"\"\n"
"              , \"The state is \\\"Fgh\\\"\"\n"
"              , \"The state is \\\"gh\\\"\"\n"
"              , \"The state is \\\"h\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:715
msgid ""
"Again, this illustrates the power of reusability that monad transformers "
"bring - we were able to write a backtracking parser in a declarative style "
"with only a few lines of code, by reusing standard abstractions!"
msgstr ""
"繰り返しになりますが、これはモナド変換子がもたらす再利用性の威力を示していま"
"す。\n"
"標準的な抽象化を再利用することで、宣言型スタイルのバックトラック構文解析器"
"を、ほんの数行のコードで書くことができました。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:722
msgid ""
"(Easy) Remove the calls to the `lift` function from your implementation of "
"the `string` parser. Verify that the new implementation type checks, and "
"convince yourself that it should."
msgstr ""
"（簡単）`string`構文解析器の実装から `lift`関数の呼び出しを取り除いてくださ"
"い。\n"
"新しい実装の型が整合していることを確認し、なぜそのようになるのかをよく納得し"
"ておきましょう。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:722
msgid ""
"(Medium) Use your `string` parser with the `some` combinator to write a "
"parser `asFollowedByBs` which recognizes strings consisting of several "
"copies of the string `\"a\"` followed by several copies of the string `\"b"
"\"`."
msgstr ""
"（普通）`string`構文解析器と `many`コンビネータを使って、文字列`\"a\"`の連続"
"と、それに続く文字列 `\"b\"`の連続からなる文字列を認識する構文解析器"
"`asFollowedByBs`を書いてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:722
msgid ""
"(Medium) Use the `<|>` operator to write a parser `asOrBs` which recognizes "
"strings of the letters `a` or `b` in any order."
msgstr ""
"（普通）`<|>`演算子を使って、文字 `a`と文字 `b`が任意の順序で現れるような文字"
"列を認識する構文解析器`asOrBs`を書いてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:722
msgid "(Difficult) The `Parser` monad might also be defined as follows:"
msgstr "（難しい）`Parser`モナドを次のようにも定義できます。"

#. type: Plain text
#: text/chapter11.md:726
#, no-wrap
msgid ""
"     ```haskell\n"
"     type Parser = ExceptT Errors (StateT String (WriterT Log Identity))\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     type Parser = ExceptT Errors (StateT String (WriterT Log Identity))\n"
"     ```\n"

#. type: Plain text
#: text/chapter11.md:728
#, no-wrap
msgid "     What effect does this change have on our parsing functions?\n"
msgstr "     このように変更すると、構文解析関数にどのような影響を与えるでしょうか。\n"

#. type: Title ##
#: text/chapter11.md:729
#, no-wrap
msgid "The RWS Monad"
msgstr "RWSモナド"

#. type: Plain text
#: text/chapter11.md:732
msgid ""
"One particular combination of monad transformers is so common that it is "
"provided as a single monad transformer in the `transformers` package. The "
"`Reader`, `Writer` and `State` monads are combined into the _reader-writer-"
"state_ monad, or more simply the `RWS` monad. This monad has a corresponding "
"monad transformer called the `RWST` monad transformer."
msgstr ""
"モナド変換子のとある特定の組み合わせは頻出なので、`transformers`パッケージ内"
"の単一のモナド変換子として提供されています。\n"
"`Reader`、 `Writer`、`State`のモナドは、*Reader-Writer-State*モナドに組み合わ"
"さり、より単純に`RWS`モナドともされます。\n"
"このモナドは `RWST`モナド変換子と呼ばれる、対応するモナド変換子を持っていま"
"す。"

#. type: Plain text
#: text/chapter11.md:734
msgid ""
"We will use the `RWS` monad to model the game logic for our text adventure "
"game."
msgstr ""
"ここでは `RWS`モナドを使ってテキストアドベンチャーゲームの処理を設計していき"
"ます。"

#. type: Plain text
#: text/chapter11.md:736
msgid ""
"The `RWS` monad is defined in terms of three type parameters (in addition to "
"its return type):"
msgstr ""
"`RWS`モナドは（戻り値の型に加えて）3つの型変数を使って定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:737
#, no-wrap
msgid "type RWS r w s = RWST r w s Identity\n"
msgstr "type RWS r w s = RWST r w s Identity\n"

#. type: Plain text
#: text/chapter11.md:742
msgid ""
"Notice that the `RWS` monad is defined in terms of its own monad "
"transformer, by setting the base monad to `Identity` which provides no side-"
"effects."
msgstr ""
"ここで、副作用を提供しない`Identity`を基底のモナドに設定することで、 `RWS`モ"
"ナドが独自のモナド変換子を用いて定義されています。"

#. type: Plain text
#: text/chapter11.md:744
msgid ""
"The first type parameter, `r`, represents the global configuration type. The "
"second, `w`, represents the monoid which we will use to accumulate a log, "
"and the third, `s` is the type of our mutable state."
msgstr ""
"第1型引数 `r`は大域的な設定の型を表します。\n"
"第2型引数 `w`はログを蓄積するために使用するモノイド、第3型引数 `s`は可変状態"
"の型を表しています。"

#. type: Plain text
#: text/chapter11.md:746
msgid ""
"In the case of our game, our global configuration is defined in a type "
"called `GameEnvironment` in the `Data.GameEnvironment` module:"
msgstr ""
"このゲームの場合には、大域的な設定は `Data.GameEnvironment`モジュールの"
"`GameEnvironment`という名前の型で定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:747
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameEnvironment.purs:env}}\n"
msgstr "{{#include ../exercises/chapter11/src/Data/GameEnvironment.purs:env}}\n"

#. type: Plain text
#: text/chapter11.md:752
msgid ""
"It defines the player name, and a flag which indicates whether or not the "
"game is running in debug mode. These options will be set from the command "
"line when we come to run our monad transformer."
msgstr ""
"プレイヤー名と、ゲームがデバッグモードで動作しているか否かを示すフラグが定義"
"されています。\n"
"これらのオプションは、モナド変換子を実行するときにコマンドラインから設定され"
"ます。"

#. type: Plain text
#: text/chapter11.md:754
msgid ""
"The mutable state is defined in a type called `GameState` in the `Data."
"GameState` module:"
msgstr ""
"可変状態は `Data.GameState`モジュールの `GameState`と呼ばれる型で定義されてい"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:755
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Data/GameState.purs:imports}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Data/GameState.purs:GameState}}\n"
msgstr ""
"{{#include ../exercises/chapter11/src/Data/GameState.purs:imports}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Data/GameState.purs:GameState}}\n"

#. type: Plain text
#: text/chapter11.md:762
msgid ""
"The `Coords` data type represents points on a two-dimensional grid, and the "
"`GameItem` data type is an enumeration of the items in the game:"
msgstr ""
"`Coords`データ型は2次元平面の点を表し、 `GameItem`データ型はゲーム内のアイテ"
"ムの列挙です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:763
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameItem.purs:GameItem}}\n"
msgstr "{{#include ../exercises/chapter11/src/Data/GameItem.purs:GameItem}}\n"

#. type: Plain text
#: text/chapter11.md:768
msgid ""
"The `GameState` type uses two new data structures: `Map` and `Set`, which "
"represent sorted maps and sorted sets respectively. The `items` property is "
"a mapping from coordinates of the game grid to sets of game items at that "
"location. The `player` property stores the current coordinates of the "
"player, and the `inventory` property stores a set of game items currently "
"held by the player."
msgstr ""
"`GameState`型は2つの新しいデータ構造を使っています。\n"
"`Map`と`Set`はそれぞれ整列されたマップと整列された集合を表します。\n"
"`items`属性は、そのゲーム平面上の座標からゲームアイテムの集合への対応付けに"
"なっています。\n"
"`player`属性はプレイヤーの現在の座標を格納しており、 `inventory`属性は現在プ"
"レイヤーが保有するゲームアイテムの集合です。"

#. type: Plain text
#: text/chapter11.md:770
msgid ""
"The `Map` and `Set` data structures are sorted by their keys, can be used "
"with any key type in the `Ord` type class. This means that the keys in our "
"data structures should be totally ordered."
msgstr ""
"`Map`と `Set`のデータ構造はキーによって整列され、 `Ord`型クラスの任意の型を"
"キーとして使用できます。これは今回のデータ構造のキーが完全に順序付けできるこ"
"とを意味します。"

#. type: Plain text
#: text/chapter11.md:772
msgid ""
"We will see how the `Map` and `Set` structures are used as we write the "
"actions for our game."
msgstr ""
"ゲームのアクションを書く上で`Map`と `Set`構造をどのように使っていくのかを見て"
"いきます。"

#. type: Plain text
#: text/chapter11.md:774
msgid ""
"For our log, we will use the `List String` monoid. We can define a type "
"synonym for our `Game` monad, implemented using `RWS`:"
msgstr ""
"ログとしては `List String`モノイドを使います。\n"
"`Game`モナド用の型同義語を定義し、`RWS`を使って実装できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:775
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:Game}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:Game}}\n"

#. type: Title ##
#: text/chapter11.md:779
#, no-wrap
msgid "Implementing Game Logic"
msgstr "ゲームロジックの実装"

#. type: Plain text
#: text/chapter11.md:782
msgid ""
"Our game is going to be built from simple actions defined in the `Game` "
"monad, by reusing the actions from the `Reader`, `Writer` and `State` "
"monads. At the top level of our application, we will run the pure "
"computations in the `Game` monad, and use the `Effect` monad to turn the "
"results into observable side-effects, such as printing text to the console."
msgstr ""
"今回は`Reader`モナドと`Writer`モナドと`State`モナドのアクションを再利用し、"
"`Game`モナドで定義されている単純なアクションを組み合わせてゲームを構築してい"
"きます。\n"
"このアプリケーションの最上位では`Game`モナドで純粋に計算しており、`Effect`モ"
"ナドはコンソールにテキストを出力するような観測可能な副作用へと結果を変換する"
"ために使っています。"

#. type: Plain text
#: text/chapter11.md:784
msgid ""
"One of the simplest actions in our game is the `has` action. This action "
"tests whether the player's inventory contains a particular game item. It is "
"defined as follows:"
msgstr ""
"このゲームで最も簡単なアクションの1つは `has`アクションです。このアクションは"
"プレイヤーの持ち物に特定のゲームアイテムが含まれているかどうかを調べます。こ"
"れは次のように定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:785
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:has}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:has}}\n"

#. type: Plain text
#: text/chapter11.md:790
msgid ""
"This function uses the `get` action defined in the `MonadState` type class "
"to read the current game state, and then uses the `member` function defined "
"in `Data.Set` to test whether the specified `GameItem` appears in the `Set` "
"of inventory items."
msgstr ""
"この関数は、現在のゲームの状態を読み取るために `MonadState`型クラスで定義され"
"ている `get`アクションを使っています。\n"
"またそれから指定した`GameItem`が持ち物アイテムの`Set`に出現するかどうかを調べ"
"るために`Data.Set`で定義されている `member`関数を使っています。"

#. type: Plain text
#: text/chapter11.md:792
msgid ""
"Another action is the `pickUp` action. It adds a game item to the player's "
"inventory if it appears in the current room. It uses actions from the "
"`MonadWriter` and `MonadState` type classes. First of all, it reads the "
"current game state:"
msgstr ""
"他にも `pickUp`アクションがあります。\n"
"現在の位置にゲームアイテムがある場合、プレイヤーの持ち物にそのアイテムを追加"
"します。\n"
"これには`MonadWriter`と `MonadState`型クラスのアクションを使っています。\n"
"一番最初に現在のゲームの状態を読み取ります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:793
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_start}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_start}}\n"

#. type: Plain text
#: text/chapter11.md:798
msgid ""
"Next, `pickUp` looks up the set of items in the current room. It does this "
"by using the `lookup` function defined in `Data.Map`:"
msgstr ""
"次に `pickUp`は現在の位置にあるアイテムの集合を検索します。\n"
"これは`Data.Map`で定義された `lookup`関数を使って行います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:799
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_case}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_case}}\n"

#. type: Plain text
#: text/chapter11.md:804
msgid ""
"The `lookup` function returns an optional result indicated by the `Maybe` "
"type constructor. If the key does not appear in the map, the `lookup` "
"function returns `Nothing`, otherwise it returns the corresponding value in "
"the `Just` constructor."
msgstr ""
"`lookup`関数は `Maybe`型構築子で示されたオプショナルな結果を返します。\n"
"`lookup`関数は、キーがマップにない場合は `Nothing`を返し、それ以外の場合は "
"`Just`構築子で対応する値を返します。"

#. type: Plain text
#: text/chapter11.md:806
msgid ""
"We are interested in the case where the corresponding item set contains the "
"specified game item. Again we can test this using the `member` function:"
msgstr ""
"関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含まれてい"
"る場合です。\n"
"ここでも`member`関数を使うとこれを調べることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:807
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_Just}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_Just}}\n"

#. type: Plain text
#: text/chapter11.md:812
msgid ""
"In this case, we can use `put` to update the game state, and `tell` to add a "
"message to the log:"
msgstr ""
"この場合、 `put`を使ってゲームの状態を更新し、 `tell`を使ってログにメッセージ"
"を追加できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:813
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_body}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_body}}\n"

#. type: Plain text
#: text/chapter11.md:818
msgid ""
"Note that there is no need to `lift` either of the two computations here, "
"because there are appropriate instances for both `MonadState` and "
"`MonadWriter` for our `Game` monad transformer stack."
msgstr ""
"ここで2つの計算のどちらも`lift`が必要ないことに注意してください。\n"
"なぜなら`MonadState`と `MonadWriter`の両方について `Game`モナド変換子スタック"
"用の適切なインスタンスが存在するからです。"

#. type: Plain text
#: text/chapter11.md:820
msgid ""
"The argument to `put` uses a record update to modify the game state's "
"`items` and `inventory` fields. We use the `update` function from `Data.Map` "
"which modifies a value at a particular key. In this case, we modify the set "
"of items at the player's current location, using the `delete` function to "
"remove the specified item from the set. `inventory` is also updated, using "
"`insert` to add the new item to the player's inventory set."
msgstr ""
"`put`への引数では、レコード更新を使ってゲームの状態の `items`と`inventory`"
"フィールドを変更しています。\n"
"また、特定のキーの値を変更する`Data.Map`の `update`関数を使っています。\n"
"このとき、プレイヤーの現在の位置にあるアイテムの集合を変更するのに、`delete`"
"関数を使って指定したアイテムを集合から取り除いています。\n"
"`insert`を使って新しいアイテムをプレイヤーの持ち物集合に加えるときにも、"
"`inventory`は更新されます。"

#. type: Plain text
#: text/chapter11.md:822
msgid ""
"Finally, the `pickUp` function handles the remaining cases, by notifying the "
"user using `tell`:"
msgstr ""
"最後に、`pickUp`関数は `tell`を使ってユーザに次のように通知することにより、残"
"りの場合を処理します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:823
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_err}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:pickup_err}}\n"

#. type: Plain text
#: text/chapter11.md:828
msgid ""
"As an example of using the `Reader` monad, we can look at the code for the "
"`debug` command. This command allows the user to inspect the game state at "
"runtime if the game is running in debug mode:"
msgstr ""
"`Reader`モナドを使う例として、 `debug`コマンドのコードを見てみましょう。\n"
"ゲームがデバッグモードで実行されている場合、このコマンドを使うとユーザは実行"
"時にゲームの状態を調べることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:829
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:debug}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:debug}}\n"

#. type: Plain text
#: text/chapter11.md:834
msgid ""
"Here, we use the `ask` action to read the game configuration. Again, note "
"that we don't need to `lift` any computation, and we can use actions defined "
"in the `MonadState`, `MonadReader` and `MonadWriter` type classes in the "
"same do notation block."
msgstr ""
"ここでは、ゲームの設定を読み込むために `ask`アクションを使用しています。\n"
"繰り返しますが、どの計算でも`lift`は必要がなく、同じdo記法ブロック内で"
"`MonadState`、 `MonadReader`、 `MonadWriter`型クラスで定義されているアクショ"
"ンを使うことができることに注意してください。"

#. type: Plain text
#: text/chapter11.md:836
msgid ""
"If the `debugMode` flag is set, then the `tell` action is used to write the "
"state to the log. Otherwise, an error message is added."
msgstr ""
"`debugMode`フラグが設定されている場合、 `tell`アクションを使うとログに状態が"
"追加されます。\n"
"そうでなければ、エラーメッセージが追加されます。"

#. type: Plain text
#: text/chapter11.md:838
msgid ""
"The remainder of the `Game` module defines a set of similar actions, each "
"using only the actions defined by the `MonadState`, `MonadReader` and "
"`MonadWriter` type classes."
msgstr ""
"`Game.purs`モジュールの残りの部分では、`MonadState`型クラスと`MonadReader`型"
"クラスと`MonadWriter`型クラスでそれぞれ定義されたアクションだけを使い、同様の"
"アクションが定義されています。"

#. type: Title ##
#: text/chapter11.md:839
#, no-wrap
msgid "Running the Computation"
msgstr "計算の実行"

#. type: Plain text
#: text/chapter11.md:842
msgid ""
"Since our game logic runs in the `RWS` monad, it is necessary to run the "
"computation in order to respond to the user's commands."
msgstr ""
"このゲームロジックは `RWS`モナドで動くため、ユーザのコマンドに応答するために"
"は計算する必要があります。"

#. type: Plain text
#: text/chapter11.md:844
msgid ""
"The front-end of our game is built using two packages: `optparse`, which "
"provides applicative command line parsing, and `node-readline`, which wraps "
"NodeJS' `readline` module, allowing us to write interactive console-based "
"applications."
msgstr ""
"このゲームのフロントエンドは2つのパッケージで構成されています。\n"
"アプリカティブなコマンドライン構文解析を提供する`optparse`と、対話的なコン"
"ソールベースのアプリケーションを書くことを可能にする、NodeJSの `readline`モ"
"ジュールを梱包する `node-readline`パッケージです。"

#. type: Plain text
#: text/chapter11.md:846
msgid ""
"The interface to our game logic is provided by the function `game` in the "
"`Game` module:"
msgstr "このゲームロジックへのインターフェースは `Game`モジュール内の関数`game`によって提供されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:847
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:game_sig}}\n"
msgstr "{{#include ../exercises/chapter11/src/Game.purs:game_sig}}\n"

#. type: Plain text
#: text/chapter11.md:852
msgid ""
"To run this computation, we pass a list of words entered by the user as an "
"array of strings, and run the resulting `RWS` computation using `runRWS`:"
msgstr ""
"これを計算するには、ユーザが入力した単語のリストを文字列の配列として渡してか"
"ら、 `runRWS`を使って `RWS`の計算結果を実行します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:853
#, no-wrap
msgid ""
"data RWSResult state result writer = RWSResult state result writer\n"
"\n"
"runRWS :: forall r w s a. RWS r w s a -> r -> s -> RWSResult s a w\n"
msgstr ""
"data RWSResult state result writer = RWSResult state result writer\n"
"\n"
"runRWS :: forall r w s a. RWS r w s a -> r -> s -> RWSResult s a w\n"

#. type: Plain text
#: text/chapter11.md:860
msgid ""
"`runRWS` looks like a combination of `runReader`, `runWriter` and "
"`runState`. It takes a global configuration and an initial state as an "
"argument, and returns a data structure containing the log, the result and "
"the final state."
msgstr ""
"`runRWS`は `runReader`、 `runWriter`、 `runState`を組み合わせたように見えま"
"す。\n"
"これは、引数として大域的な設定及び初期状態をとり、ログ、結果、最的な終状態を"
"含むデータ構造を返します。"

#. type: Plain text
#: text/chapter11.md:862
msgid ""
"The front-end of our application is defined by a function `runGame`, with "
"the following type signature:"
msgstr ""
"このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数`runGame`に"
"よって定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:863
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_sig}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_sig}}\n"

#. type: Plain text
#: text/chapter11.md:868
msgid ""
"This function interacts with the user via the console (using the `node-"
"readline` and `console` packages). `runGame` takes the game configuration as "
"a function argument."
msgstr ""
"この関数は（`node-readline`と`console`パッケージを使って）コンソールを介して"
"ユーザとやり取りします。\n"
"`runGame`は関数の引数としてのゲームの設定を取ります。"

#. type: Plain text
#: text/chapter11.md:870
msgid ""
"The `node-readline` package provides the `LineHandler` type, which "
"represents actions in the `Effect` monad which handle user input from the "
"terminal. Here is the corresponding API:"
msgstr ""
"`node-readline`パッケージでは`LineHandler`型が提供されています。\n"
"これは端末からのユーザ入力を扱う `Effect`モナドのアクションを表します。\n"
"対応するAPIは次の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:871
#, no-wrap
msgid ""
"type LineHandler a = String -> Effect a\n"
"\n"
"foreign import setLineHandler\n"
"  :: forall a\n"
"   . Interface\n"
"  -> LineHandler a\n"
"  -> Effect Unit\n"
msgstr ""
"type LineHandler a = String -> Effect a\n"
"\n"
"foreign import setLineHandler\n"
"  :: forall a\n"
"   . Interface\n"
"  -> LineHandler a\n"
"  -> Effect Unit\n"

#. type: Plain text
#: text/chapter11.md:882
msgid ""
"The `Interface` type represents a handle for the console, and is passed as "
"an argument to the functions which interact with it. An `Interface` can be "
"created using the `createConsoleInterface` function:"
msgstr ""
"`Interface`型はコンソールの制御対象を表しており、コンソールとやり取りする関数"
"への引数として渡されます。\n"
"`createConsoleInterface`関数を使用すると `Interface`を作成できます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:883
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:import_RL}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:runGame_interface}}\n"
msgstr ""
"{{#include ../exercises/chapter11/src/Main.purs:import_RL}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:runGame_interface}}\n"

#. type: Plain text
#: text/chapter11.md:890
msgid ""
"The first step is to set the prompt at the console. We pass the `interface` "
"handle, and provide the prompt string and indentation level:"
msgstr ""
"最初の工程はコンソールにプロンプトを設定することです。\n"
"`interface`制御対象を渡し、プロンプト文字列と字下げレベルを与えます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:891
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_prompt}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_prompt}}\n"

#. type: Plain text
#: text/chapter11.md:896
msgid ""
"In our case, we are interested in implementing the line handler function. "
"Our line handler is defined using a helper function in a `let` declaration, "
"as follows:"
msgstr ""
"今回は行制御関数を実装することに関心があります。\n"
"ここでの行制御は`let`宣言内の補助関数を使って次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:897
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_lineHandler}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_lineHandler}}\n"

#. type: Plain text
#: text/chapter11.md:902
msgid ""
"The `let` binding is closed over both the game configuration, named `env`, "
"and the console handle, named `interface`."
msgstr ""
"`let`束縛が`env`という名前のゲーム構成や`interface`という名前のコンソール制御"
"対象を包み込んでいます。"

#. type: Plain text
#: text/chapter11.md:904
msgid ""
"Our handler takes an additional first argument, the game state. This is "
"required since we need to pass the game state to `runRWS` to run the game's "
"logic."
msgstr ""
"この制御子は追加の最初の引数としてゲームの状態を取ります。\n"
"ゲームのロジックを実行するために`runRWS`にゲームの状態を渡さなければならない"
"ので、これは必要となっています。"

#. type: Plain text
#: text/chapter11.md:906
msgid ""
"The first thing this action does is to break the user input into words using "
"the `split` function from the `Data.String` module. It then uses `runRWS` to "
"run the `game` action (in the `RWS` monad), passing the game environment and "
"current game state."
msgstr ""
"このアクションが最初に行うことは、 `Data.String`モジュールの `split`関数を使"
"用して、ユーザーの入力を単語に分割することです。\n"
"それから、ゲームの環境と現在のゲームの状態を渡し、 `runRWS`を使用して（`RWS`"
"モナドで）`game`アクションを実行しています。"

#. type: Plain text
#: text/chapter11.md:908
msgid ""
"Having run the game logic, which is a pure computation, we need to print any "
"log messages to the screen and show the user a prompt for the next command. "
"The `for_` action is used to traverse the log (of type `List String`) and "
"print its entries to the console. Finally, `setLineHandler` is used to "
"update the line handler function to use the updated game state, and the "
"prompt is displayed again using the `prompt` action."
msgstr ""
"純粋な計算であるゲームロジックを実行するには、画面に全てのログメッセージを出"
"力して、ユーザに次のコマンドのためのプロンプトを表示する必要があります。\n"
"`for_`アクションが（`List String`型の）ログを走査し、コンソールにその内容を出"
"力するために使われています。\n"
"最後に`setLineHandler`を使って行制御関数を更新することでゲームの状態を更新"
"し、`prompt`アクションを使ってプロンプトを再び表示しています。"

#. type: Plain text
#: text/chapter11.md:910
msgid ""
"The `runGame` function finally attaches the initial line handler to the "
"console interface, and displays the initial prompt:"
msgstr ""
"`runGame`関数は最終的にコンソールインターフェイスに最初の行制御子を取り付け"
"て、最初のプロンプトを表示します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:911
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_attach_handler}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:runGame_attach_handler}}\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:919
msgid ""
"(Medium) Implement a new command `cheat`, which moves all game items from "
"the game grid into the user's inventory. Create a function `cheat :: Game "
"Unit` in the `Game` module, and use this function from `game`."
msgstr ""
"（普通）ゲームの格子上にある全てのゲームアイテムをユーザの持ちものに移動する"
"新しいコマンド `cheat`を実装してください。\n"
"関数`cheat :: Game Unit`を`Game`モジュールに作り、この関数を`game`から使って"
"ください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:919
msgid ""
"(Difficult) The `Writer` component of the `RWS` monad is currently used for "
"two types of messages: error messages and informational messages. Because of "
"this, several parts of the code use case statements to handle error cases."
msgstr ""
"（難しい）`RWS`モナドの ` Writer`コンポーネントは、エラーメッセージと情報メッ"
"セージの2つの種類のメッセージのために使われています。\n"
"このため、コードの幾つかの箇所では、エラーの場合を扱うためにcase式を使用して"
"います。"

#. type: Plain text
#: text/chapter11.md:921
#, no-wrap
msgid "     Refactor the code to use the `ExceptT` monad transformer to handle the error messages, and `RWS` to handle informational messages. _Note:_ There are no tests for this exercise.\n"
msgstr ""
"     エラーメッセージを扱うのに `ExceptT`モナド変換子を使うようにし、情報メッセージを扱うのに`RWS`を使うようにするよう、コードをリファクタリングしてください。\n"
"     *補足*：この演習にはテストはありません。\n"

#. type: Title ##
#: text/chapter11.md:922
#, no-wrap
msgid "Handling Command Line Options"
msgstr "コマンドラインオプションの扱い"

#. type: Plain text
#: text/chapter11.md:925
msgid ""
"The final piece of the application is responsible for parsing command line "
"options and creating the `GameEnvironment` configuration record. For this, "
"we use the `optparse` package."
msgstr ""
"このアプリケーションの最後の部品には、コマンドラインオプションの解析と"
"`GameEnvironment`設定レコードを作成する役目があります。\n"
"このためには`optparse`パッケージを使用します。"

#. type: Plain text
#: text/chapter11.md:927
msgid ""
"`optparse` is an example of _applicative command line option parsing_. "
"Recall that an applicative functor allows us to lift functions of arbitrary "
"arity over a type constructor representing some type of side-effect. In the "
"case of the `optparse` package, the functor we are interested in is the "
"`Parser` functor (imported from the optparse module `Options.Applicative`, "
"not to be confused with our `Parser` that we defined in the `Split` module), "
"which adds the side-effect of reading from command line options. It provides "
"the following handler:"
msgstr ""
"`optparse`は*アプリカティブなコマンドラインオプション構文解析器*の一例で"
"す。\n"
"アプリカティブ関手を使うと、いろいろな副作用の型を表す型構築子まで任意個数の"
"引数の関数を持ち上げられることを思い出してください。\n"
"`optparse`パッケージの場合には、コマンドラインオプションからの読み取りの副作"
"用を追加する`Parser`関手（optparseのモジュール`Options.Applicative`からイン"
"ポートされたもの。`Split`モジュールで定義した`Parser`と混同しないように）が興"
"味深い関手になっています。\n"
"これは次のような制御子を提供しています。"

# TODO: 原文でもUnicodeの矢印になっています。
#. type: Fenced code block (haskell)
#: text/chapter11.md:928
#, no-wrap
msgid "customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a\n"
msgstr "customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a\n"

#. type: Plain text
#: text/chapter11.md:933
msgid ""
"This is best illustrated by example. The application's `main` function is "
"defined using `customExecParser` as follows:"
msgstr ""
"実例を見るのが一番です。\n"
"このアプリケーションの `main`関数は`customExecParser`を使って次のように定義さ"
"れています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:934
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:main}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:main}}\n"

#. type: Plain text
#: text/chapter11.md:939
msgid ""
"The first argument is used to configure the `optparse` library. In our case, "
"we simply configure it to show the help message when the application is run "
"without any arguments (instead of showing a \"missing argument\" error) by "
"using `OP.prefs OP.showHelpOnEmpty`, but the `Options.Applicative.Builder` "
"module provides several other options."
msgstr ""
"最初の引数は`optparse`ライブラリを設定するために使用されます。\n"
"今回の場合、アプリケーションが引数なしで走らされたときは、（「missing "
"argument」エラーを表示する代わりに）`OP.prefs OP.showHelpOnEmpty`を使って使用"
"方法のメッセージを表示するように設定していますが、`Options.Applicative."
"Builder`モジュールには他にも幾つかの選択肢を提供しています。"

#. type: Plain text
#: text/chapter11.md:941
msgid "The second argument is the complete description of our parser program:"
msgstr "2つ目の引数は解析プログラムの完全な説明です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:942
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:argParser}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:parserOptions}}\n"
msgstr ""
"{{#include ../exercises/chapter11/src/Main.purs:argParser}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:parserOptions}}\n"

#. type: Plain text
#: text/chapter11.md:949
#, no-wrap
msgid "Here `OP.info` combines a `Parser` with a set of options for how the help message is formatted. `env <**> OP.helper` takes any command line argument `Parser` named `env` and adds a `--help` option to it automatically. Options for the help message are of type `InfoMod`, which is a monoid, so we can use the `fold` function to add several options together.\n"
msgstr ""
"ここで`OP.info`は使用方法のメッセージの書式方法のオプションの集合と共に`Parser`を結合します。\n"
"`env <**> OP.helper`は`env`と名付けられた任意のコマンドライン引数`Parser`を取り、自動的に`--help`オプションを加えます。\n"
"使用方法のメッセージ用のオプションは型が`InfoMod`であり、これはモノイドなので`fold`関数を使って複数のオプションを一緒に追加できます。\n"

#. type: Plain text
#: text/chapter11.md:951
msgid ""
"The interesting part of our parser is constructing the `GameEnvironment`:"
msgstr "解析器の面白い部分は`GameEnvironment`の構築にあります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:952
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:env}}\n"
msgstr "{{#include ../exercises/chapter11/src/Main.purs:env}}\n"

#. type: Plain text
#: text/chapter11.md:957
#, no-wrap
msgid "`player` and `debug` are both `Parser`s, so we can use our applicative operators `<$>` and `<*>` to lift our `gameEnvironment` function, which has the type `PlayerName -> Boolean -> GameEnvironment` over `Parser`. `OP.strOption` constructs a command line option that expects a string value, and is configured via a collection of `Mod`s folded together. `OP.flag` works similarly, but doesn't expect an associated value. `optparse` offers extensive [documentation](https://pursuit.purescript.org/packages/purescript-optparse) on different modifiers available to build various command line parsers.\n"
msgstr ""
"`player`と`debug`は両方とも`Parser`なので、アプリカティブ演算子`<$>`と`<*>`を使って`gameEnvironment`関数を持ち上げることができます。\n"
"この関数は`Parser`上で型`PlayerName -> Boolean -> GameEnvironment`を持ちます。\n"
"`OP.strOption`は文字列値を期待するコマンドラインオプションを構築し、一緒に畳み込まれた`Mod`の集まりを介して設定されています。\n"
"`OP.flag`は似たような動作をしますが、関連付けられた値は期待しません。\n"
"`optparse`は多種多様なコマンドライン解析器を構築するために使える様々な修飾子について、大部の[ドキュメント](https://pursuit.purescript.org/packages/purescript-optparse)を提供しています。\n"

#. type: Plain text
#: text/chapter11.md:959
#, no-wrap
msgid "Notice how we were able to use the notation afforded by the applicative operators to give a compact, declarative specification of our command line interface. In addition, it is simple to add new command line arguments, simply by adding a new function argument to `runGame`, and then using `<*>` to lift `runGame` over an additional argument in the definition of `env`.\n"
msgstr ""
"アプリカティブ演算子による記法を使うことで、コマンドラインインターフェイスに対して簡潔で宣言的な仕様を与えることが可能になったことに注目です。\n"
"また、`runGame`に新しい関数引数を追加し、`env`の定義中で`<*>`を使って追加の引数まで `runGame`を持ち上げるだけで、簡単に新しいコマンドライン引数を追加できます。\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:963
msgid ""
"(Medium) Add a new Boolean-valued property `cheatMode` to the "
"`GameEnvironment` record. Add a new command line flag `-c` to the `optparse` "
"configuration which enables cheat mode. The `cheat` command from the "
"previous exercise should be disallowed if cheat mode is not enabled."
msgstr ""
"（普通）`GameEnvironment`レコードに新しい真偽値のプロパティ`cheatMode`を追加"
"してください。\n"
"また、 `optparse`設定に、チートモードを有効にする新しいコマンドラインフラグ "
"`-c`を追加してください。\n"
"チートモードが有効になっていない場合、 `cheat`コマンドは禁止されなければなり"
"ません。"

#. type: Plain text
#: text/chapter11.md:967
msgid ""
"This chapter was a practical demonstration of the techniques we've learned "
"so far, using monad transformers to build a pure specification of our game, "
"and the `Effect` monad to build a front-end using the console."
msgstr ""
"この章ではこれまで学んできた技術を実践的に実演しました。\n"
"モナド変換子を使用したゲームの純粋な仕様の構築、コンソールを使用したフロント"
"エンドを構築するための `Effect`モナドがそれです。"

#. type: Plain text
#: text/chapter11.md:969
msgid ""
"Because we separated our implementation from the user interface, it would be "
"possible to create other front-ends for our game. For example, we could use "
"the `Effect` monad to render the game in the browser using the Canvas API or "
"the DOM."
msgstr ""
"ユーザインターフェイスからの実装を分離したので、ゲームの別のフロントエンドも"
"作成できるでしょう。\n"
"例えば、`Effect`モナドでCanvas APIやDOMを使用して、ブラウザでゲームを描画する"
"ようなことができるでしょう。"

#. type: Plain text
#: text/chapter11.md:971
msgid ""
"We have seen how monad transformers allow us to write safe code in an "
"imperative style, where effects are tracked by the type system. In addition, "
"type classes provide a powerful way to abstract over the actions provided by "
"a monad, enabling code reuse. We were able to use standard abstractions like "
"`Alternative` and `MonadPlus` to build useful monads by combining standard "
"monad transformers."
msgstr ""
"モナド変換子によって命令型のスタイルで安全なコードを書くことができることを見てきました。\n"
"このスタイルでは型システムによって作用が追跡されています。\n"
"また、型クラスはモナドが提供するアクションへと抽象化する強力な方法を提供します。\n"
"このモナドのお陰でコードの再利用が可能になりました。\n"
"標準的なモナド変換子を組み合わせることにより、`Alternative`や`MonadPlus`のような標準的な抽象化を使用して、役に立つモナドを構築できました。"

#. type: Plain text
#: text/chapter11.md:972
msgid ""
"Monad transformers are an excellent demonstration of the sort of expressive "
"code that can be written by relying on advanced type system features such as "
"higher-kinded polymorphism and multi-parameter type classes."
msgstr ""
"モナド変換子は、高階多相や多変数型クラスなどの高度な型システムの機能を利用す"
"ることによって記述でき、表現力の高いコードの優れた実演となっています。"

#. type: Title #
#: text/chapter12.md:1
#, no-wrap
msgid "Canvas Graphics"
msgstr "Canvasグラフィックス"

#. type: Plain text
#: text/chapter12.md:6
msgid ""
"This chapter will be an extended example focussing on the `canvas` package, "
"which provides a way to generate 2D graphics from PureScript using the HTML5 "
"Canvas API."
msgstr ""
"この章は`canvas`パッケージに焦点を当てる発展的な例となります。\n"
"このパッケージはPureScriptでHTML5のCanvas APIを使用して2Dグラフィックスを生成"
"する手段を提供します。"

#. type: Bullet: '- '
#: text/chapter12.md:13
msgid "`canvas`, which gives types to methods from the HTML5 Canvas API"
msgstr "`canvas`はHTML5のCanvas APIメソッドの型を与えます。"

#. type: Bullet: '- '
#: text/chapter12.md:13
msgid ""
"`refs`, which provides a side-effect for using _global mutable references_"
msgstr ""
"`refs`は _大域的な変更可能領域への参照_ を使うための副作用を提供します。"

#. type: Plain text
#: text/chapter12.md:15
msgid ""
"The source code for the chapter is broken up into a set of modules, each of "
"which defines a `main` method. Different sections of this chapter are "
"implemented in different files, and the `Main` module can be changed by "
"modifying the Spago build command to run the appropriate file's `main` "
"method at each point."
msgstr ""
"この章のソースコードは、それぞれに `main`メソッドが定義されているモジュールの"
"集合へと分割されています。\n"
"この章のそれぞれの節の内容は個別のファイルで実装されており、それぞれの時点で"
"の適切なファイルの`main`メソッドを実行できるように、Spagoビルドコマンドを変更"
"することで`Main`モジュールを合わせられるようになっています。"

#. type: Plain text
#: text/chapter12.md:17
msgid ""
"The HTML file `html/index.html` contains a single `canvas` element which "
"will be used in each example, and a `script` element to load the compiled "
"PureScript code. To test the code for each section, open the HTML file in "
"your browser. Because most exercises target the browser, there are no unit "
"tests for this chapter."
msgstr ""
"HTMLファイル `html/index.html`には、各例で使用される単一の `canvas`要素、及び"
"コンパイルされたPureScriptコードを読み込む `script`要素が含まれています。\n"
"ほとんどの演習はブラウザを対象にしているので、この章には単体試験はありませ"
"ん。"

#. type: Title ##
#: text/chapter12.md:18
#, no-wrap
msgid "Simple Shapes"
msgstr "単純な図形"

#. type: Plain text
#: text/chapter12.md:21
msgid ""
"The `Example/Rectangle.purs` file contains a simple introductory example, "
"which draws a single blue rectangle at the center of the canvas. The module "
"imports the `Effect` type from the `Effect` module, and also the `Graphics."
"Canvas` module, which contains actions in the `Effect` monad for working "
"with the Canvas API."
msgstr ""
"`Example/Rectangle.purs`ファイルには簡単な導入例が含まれています。\n"
"この例ではcanvasの中心に青い四角形を1つ描画します。\n"
"このモジュールへは、`Effect`モジュールからの`Effect`型と、Canvas APIを扱うた"
"めの`Effect`モナドのアクションを含む`Graphics.Canvas`モジュールをインポートし"
"ます。"

#. type: Plain text
#: text/chapter12.md:23
msgid ""
"The `main` action starts, like in the other modules, by using the "
"`getCanvasElementById` action to get a reference to the canvas object, and "
"the `getContext2D` action to access the 2D rendering context for the canvas:"
msgstr ""
"他のモジュールでも同様ですが、 `main`アクションは最初に`getCanvasElementById`"
"アクションを使ってcanvasオブジェクトへの参照を取得します。\n"
"また、 `getContext2D`アクションを使ってキャンバスの2D描画コンテキストを参照し"
"ます。"

#. type: Plain text
#: text/chapter12.md:25
msgid ""
"The `void` function takes a functor and replaces its value with `Unit`. In "
"the example it is used to make `main` conform with its signature."
msgstr ""
"`void`関数は関手を取り値を`Unit`で置き換えます。\n"
"例では`main`がシグネチャに沿うようにするために使われています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:26
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:main}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:main}}\n"

#. type: Plain text
#: text/chapter12.md:31
msgid ""
"_Note_: the call to `unsafePartial` here is necessary since the pattern "
"match on the result of `getCanvasElementById` is partial, matching only the "
"`Just` constructor. For our purposes, this is fine, but in production code, "
"we would probably want to match the `Nothing` constructor and provide an "
"appropriate error message."
msgstr ""
"*補足*：この`unsafePartial`の呼び出しは必須です。\n"
"これは`getCanvasElementById`の結果のパターン照合部分で、`Just`値構築子のみと"
"照合するためです。\n"
"ここではこれで問題ありませんが、恐らく実際の製品のコードでは`Nothing`値構築子"
"と照合させ、適切なエラーメッセージを提供したほうがよいでしょう。"

#. type: Plain text
#: text/chapter12.md:33
msgid ""
"The types of these actions can be found using PSCi or by looking at the "
"documentation:"
msgstr "これらのアクションの型はPSCiを使うかドキュメントを見ると確認できます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:34
#, no-wrap
msgid ""
"getCanvasElementById :: String -> Effect (Maybe CanvasElement)\n"
"\n"
"getContext2D :: CanvasElement -> Effect Context2D\n"
msgstr ""
"getCanvasElementById :: String -> Effect (Maybe CanvasElement)\n"
"\n"
"getContext2D :: CanvasElement -> Effect Context2D\n"

#. type: Plain text
#: text/chapter12.md:41
msgid ""
"`CanvasElement` and `Context2D` are types defined in the `Graphics.Canvas` "
"module. The same module also defines the `Canvas` effect, which is used by "
"all of the actions in the module."
msgstr ""
"`CanvasElement`と `Context2D`は `Graphics.Canvas`モジュールで定義されている型"
"です。\n"
"このモジュールでは`Canvas`作用も定義されており、モジュール内の全てのアクショ"
"ンで使用されています。"

#. type: Plain text
#: text/chapter12.md:43
msgid ""
"The graphics context `ctx` manages the state of the canvas, and provides "
"methods to render primitive shapes, set styles and colors, and apply "
"transformations."
msgstr ""
"グラフィックスコンテキスト`ctx`はcanvasの状態を管理し、原始的な図形を描画した"
"り、スタイルや色を設定したり、座標変換を適用するためのメソッドを提供します。"

#. type: Plain text
#: text/chapter12.md:45
msgid ""
"We continue by setting the fill style to solid blue using the `setFillStyle` "
"action. The longer hex notation of `#0000FF` may also be used for blue, but "
"shorthand notation is easier for simple colors:"
msgstr ""
"話を進めると、`setFillStyle`アクションを使うことで塗り潰しスタイルを濃い青に"
"設定できます。\n"
"より長い16進数記法の`#0000FF`も青には使えますが、単純な色については略記法がよ"
"り簡単です。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:46
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:setFillStyle}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:setFillStyle}}\n"

#. type: Plain text
#: text/chapter12.md:51
msgid ""
"Note that the `setFillStyle` action takes the graphics context as an "
"argument. This is a common pattern in the `Graphics.Canvas` module."
msgstr ""
"`setFillStyle`アクションがグラフィックスコンテキストを引数として取っているこ"
"とに注意してください。\n"
"これは `Graphics.Canvas`ではよくあるパターンです。"

#. type: Plain text
#: text/chapter12.md:53
msgid ""
"Finally, we use the `fillPath` action to fill the rectangle. `fillPath` has "
"the following type:"
msgstr ""
"最後に、 `fillPath`アクションを使用して矩形を塗り潰しています。\n"
"`fillPath`は次のような型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:54
#, no-wrap
msgid "fillPath :: forall a. Context2D -> Effect a -> Effect a\n"
msgstr "fillPath :: forall a. Context2D -> Effect a -> Effect a\n"

#. type: Plain text
#: text/chapter12.md:59
msgid ""
"`fillPath` takes a graphics context and another action which builds the path "
"to render. To build a path, we can use the `rect` action. `rect` takes a "
"graphics context, and a record which provides the position and size of the "
"rectangle:"
msgstr ""
"`fillPath`はグラフィックスコンテキストと描画するパスを構築する別のアクション"
"を引数にとります。\n"
"`rect`アクションを使うとパスを構築できます。\n"
"`rect`はグラフィックスコンテキストと矩形の位置及びサイズを格納するレコードを"
"引数にとります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:60
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:fillPath}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:fillPath}}\n"

#. type: Plain text
#: text/chapter12.md:65
msgid ""
"Build the rectangle example, providing `Example.Rectangle` as the name of "
"the main module:"
msgstr ""
"mainモジュールの名前として`Example.Rectangle`を与えてこの長方形のコード例をビ"
"ルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:66
#, no-wrap
msgid "$ spago bundle-app --main Example.Rectangle --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Rectangle --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:71
msgid ""
"Now, open the `html/index.html` file and verify that this code renders a "
"blue rectangle in the center of the canvas."
msgstr ""
"それでは `html/index.html`ファイルを開き、このコードによってcanvasの中央に青"
"い四角形が描画されていることを確認してみましょう。"

#. type: Title ##
#: text/chapter12.md:72
#, no-wrap
msgid "Putting Row Polymorphism to Work"
msgstr "行多相を利用する"

#. type: Plain text
#: text/chapter12.md:75
msgid ""
"There are other ways to render paths. The `arc` function renders an arc "
"segment, and the `moveTo`, `lineTo` and `closePath` functions can be used to "
"render piecewise-linear paths."
msgstr ""
"パスを描画する方法は他にもあります。 `arc`関数は円弧を描画します。\n"
"`moveTo`関数、 `lineTo`関数、 `closePath`関数は断片的な線分のパスを描画するの"
"に使えます。"

#. type: Plain text
#: text/chapter12.md:77
msgid ""
"The `Shapes.purs` file renders three shapes: a rectangle, an arc segment and "
"a triangle."
msgstr ""
"`Shapes.purs`ファイルでは長方形と円弧と三角形の、3つの図形を描画しています。"

#. type: Plain text
#: text/chapter12.md:79
msgid ""
"We have seen that the `rect` function takes a record as its argument. In "
"fact, the properties of the rectangle are defined in a type synonym:"
msgstr ""
"`rect`関数は引数としてレコードをとることを見てきました。\n"
"実際には、長方形のプロパティは型同義語で定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:80
#, no-wrap
msgid ""
"type Rectangle =\n"
"  { x :: Number\n"
"  , y :: Number\n"
"  , width :: Number\n"
"  , height :: Number\n"
"  }\n"
msgstr ""
"type Rectangle =\n"
"  { x :: Number\n"
"  , y :: Number\n"
"  , width :: Number\n"
"  , height :: Number\n"
"  }\n"

# FIXME: w, hとなっていますが、上のコードではwidthとheightになっています。
#. type: Plain text
#: text/chapter12.md:90
msgid ""
"The `x` and `y` properties represent the location of the top-left corner, "
"while the `w` and `h` properties represent the width and height respectively."
msgstr ""
"`x`と `y`プロパティは左上隅の位置を表しており、 `w`と `h`のプロパティはそれぞ"
"れ幅と高さを表しています。"

#. type: Plain text
#: text/chapter12.md:92
msgid ""
"To render an arc segment, we can use the `arc` function, passing a record "
"with the following type:"
msgstr ""
"`arc`関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画できま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:93
#, no-wrap
msgid ""
"type Arc =\n"
"  { x      :: Number\n"
"  , y      :: Number\n"
"  , radius :: Number\n"
"  , start  :: Number\n"
"  , end    :: Number\n"
"  }\n"
msgstr ""
"type Arc =\n"
"  { x      :: Number\n"
"  , y      :: Number\n"
"  , radius :: Number\n"
"  , start  :: Number\n"
"  , end    :: Number\n"
"  }\n"

# FIXME: これも半径がrとradiusで違います。
#. type: Plain text
#: text/chapter12.md:104
msgid ""
"Here, the `x` and `y` properties represent the center point, `r` is the "
"radius, and `start` and `end` represent the endpoints of the arc in radians."
msgstr ""
"ここで、 `x`と `y`プロパティは弧の中心、 `r`は半径、 `start`と `end`は弧の両"
"端の角度を弧度法で表しています。"

#. type: Plain text
#: text/chapter12.md:106
msgid ""
"For example, this code fills an arc segment centered at `(300, 300)` with "
"radius `50`. The arc completes 2/3rds of a rotation. Note that the unit "
"circle is flipped vertically, since the y-axis increases towards the bottom "
"of the canvas:"
msgstr ""
"例えばこのコードは中心が`(300, 300)`に中心があり半径`50`の円弧を塗り潰しま"
"す。\n"
"弧は1回転のうち2/3ラジアン分あります。\n"
"単位円が上下逆様になっている点に注意してください。\n"
"これはy軸がcanvasの下向きに伸びるためです。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:107
#, no-wrap
msgid ""
"  fillPath ctx $ arc ctx\n"
"    { x      : 300.0\n"
"    , y      : 300.0\n"
"    , radius : 50.0\n"
"    , start  : 0.0\n"
"    , end    : Math.tau * 2.0 / 3.0\n"
"    }\n"
msgstr ""
"  fillPath ctx $ arc ctx\n"
"    { x      : 300.0\n"
"    , y      : 300.0\n"
"    , radius : 50.0\n"
"    , start  : 0.0\n"
"    , end    : Math.tau * 2.0 / 3.0\n"
"    }\n"

#. type: Plain text
#: text/chapter12.md:118
msgid ""
"Notice that both the `Rectangle` and `Arc` record types contain `x` and `y` "
"properties of type `Number`. In both cases, this pair represents a point. "
"This means that we can write row-polymorphic functions which can act on "
"either type of record."
msgstr ""
"`Number`型の `x`と `y`というプロパティが `Rectangle`レコード型と`Arc`レコード"
"型の両方に含まれていますね。\n"
"どちらの場合でもこの組は点を表しています。\n"
"これは、何れのレコード型にも適用できる、行多相な関数を書くことができることを"
"意味します。"

#. type: Plain text
#: text/chapter12.md:120
msgid ""
"For example, the `Shapes` module defines a `translate` function which "
"translates a shape by modifying its `x` and `y` properties:"
msgstr ""
"例えば`Shapes`モジュールでは `x`と `y`のプロパティを変更し図形を並行移動する "
"`translate`関数を定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:121
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:translate}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Shapes.purs:translate}}\n"

#. type: Plain text
#: text/chapter12.md:126
msgid ""
"Notice the row-polymorphic type. It says that `translate` accepts any record "
"with `x` and `y` properties _and any other properties_, and returns the same "
"type of record. The `x` and `y` fields are updated, but the rest of the "
"fields remain unchanged."
msgstr ""
"この行多相型に注目してください。\n"
"`translate`が `x`と `y`というプロパティと、*それに加えて他の任意のプロパティ*"
"を持つどんなレコードでも受け入れ、同じ型のレコードを返すと書かれています。\n"
"`x`フィールドと `y`フィールドは更新されますが、残りのフィールドは変更されませ"
"ん。"

#. type: Plain text
#: text/chapter12.md:128
msgid ""
"This is an example of _record update syntax_. The expression `shape { ... }` "
"creates a new record based on the `shape` record, with the fields inside the "
"braces updated to the specified values. Note that the expressions inside the "
"braces are separated from their labels by equals symbols, not colons like in "
"record literals."
msgstr ""
"これは*レコード更新構文*の例です。\n"
"`shape { ... }`という式は、`shape`を元にして、括弧の中で指定された値で更新さ"
"れたフィールドを持つ新たなレコードを作ります。\n"
"なお、波括弧の中の式はレコード直値のようなコロンではなく、等号でラベルと式を"
"区切って書きます。"

#. type: Plain text
#: text/chapter12.md:130
msgid ""
"The `translate` function can be used with both the `Rectangle` and `Arc` "
"records, as can be seen in the `Shapes` example."
msgstr ""
"`Shapes`の例からわかるように、 `translate`関数は `Rectangle`レコードと`Arc`レ"
"コード双方に対して使うことができます。"

#. type: Plain text
#: text/chapter12.md:132
msgid ""
"The third type of path rendered in the `Shapes` example is a piecewise-"
"linear path. Here is the corresponding code:"
msgstr ""
"`Shape`の例で描画される3つ目の型は線分の断片からなるパスです。\n"
"対応するコードは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:133
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:path}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Shapes.purs:path}}\n"

#. type: Plain text
#: text/chapter12.md:138
msgid "There are three functions in use here:"
msgstr "ここでは3つの関数が使われています。"

#. type: Bullet: '- '
#: text/chapter12.md:142
msgid ""
"`moveTo` moves the current location of the path to the specified coordinates,"
msgstr "`moveTo`はパスの現在地を指定された座標に移動します。"

#. type: Bullet: '- '
#: text/chapter12.md:142
msgid ""
"`lineTo` renders a line segment between the current location and the "
"specified coordinates, and updates the current location,"
msgstr ""
"`lineTo`は現在地と指定された座標の間の線分を描画し、現在地を更新します。"

#. type: Bullet: '- '
#: text/chapter12.md:142
msgid ""
"`closePath` completes the path by rendering a line segment joining the "
"current location to the start position."
msgstr "`closePath`は現在地と開始地点とを結ぶ線分を描画してパスを完結します。"

#. type: Plain text
#: text/chapter12.md:144
msgid "The result of this code snippet is to fill an isosceles triangle."
msgstr "このコード片の結果は二等辺三角形の塗り潰しになります。"

#. type: Plain text
#: text/chapter12.md:146
msgid "Build the example by specifying `Example.Shapes` as the main module:"
msgstr ""
"mainモジュールとして`Example.Shapes`を指定して、この例をビルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:147
#, no-wrap
msgid "$ spago bundle-app --main Example.Shapes --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Shapes --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:152
msgid ""
"and open `html/index.html` again to see the result. You should see the three "
"different types of shapes rendered to the canvas."
msgstr ""
"そしてもう一度 `html/index.html`を開き、結果を確認してください。canvas\n"
"に3つの異なる図形が描画されるはずです。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
msgid ""
"(Easy) Experiment with the `strokePath` and `setStrokeStyle` functions in "
"each of the examples so far."
msgstr ""
"（簡単）これまでの例のそれぞれについて、 `strokePath`関数や`setStrokeStyle`関"
"数を使ってみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
msgid ""
"(Easy) The `fillPath` and `strokePath` functions can be used to render "
"complex paths with a common style by using a do notation block inside the "
"function argument. Try changing the `Rectangle` example to render two "
"rectangles side-by-side using the same call to `fillPath`. Try rendering a "
"sector of a circle by using a combination of a piecewise-linear path and an "
"arc segment."
msgstr ""
"（簡単）関数の引数の内部のdo記法ブロックにより、`fillPath`関数と`strokePath`"
"関数を使って共通のスタイルを持つ複雑なパスを描画できます。\n"
"同じ `fillPath`呼び出しで隣り合った2つの矩形を描画するように、`Rectangle`の"
"コード例を変更してみてください。\n"
"線分と円弧を組み合わせて、扇形を描画してみてください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
msgid "(Medium) Given the following record type:"
msgstr "（普通）次のような2次元の点を表すレコードが与えられたとします。"

#. type: Plain text
#: text/chapter12.md:162
#, no-wrap
msgid ""
"     ```haskell\n"
"     type Point = { x :: Number, y :: Number }\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     type Point = { x :: Number, y :: Number }\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:164
#, no-wrap
msgid "     which represents a 2D point, write a function `renderPath` which strokes a closed path constructed from a number of points:\n"
msgstr ""
"     これは2次元の点を表現しています。\n"
"     多数の点からなる閉じたパスを線描きする関数 `renderPath`を書いてください。\n"

#. type: Plain text
#: text/chapter12.md:171
#, no-wrap
msgid ""
"     ```haskell\n"
"     renderPath\n"
"       :: Context2D\n"
"       -> Array Point\n"
"       -> Effect Unit\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     renderPath\n"
"       :: Context2D\n"
"       -> Array Point\n"
"       -> Effect Unit\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:173
#, no-wrap
msgid "     Given a function\n"
msgstr "     次のような関数を考えます。\n"

#. type: Plain text
#: text/chapter12.md:177
#, no-wrap
msgid ""
"     ```haskell\n"
"     f :: Number -> Point\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     f :: Number -> Point\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:179
#, no-wrap
msgid "     which takes a `Number` between `0` and `1` as its argument and returns a `Point`, write an action which plots `f` by using your `renderPath` function. Your action should approximate the path by sampling `f` at a finite set of points.\n"
msgstr ""
"    この関数は引数として `1`から `0`の間の `Number`をとり、 `Point`を返します。\n"
"    `renderPath`関数を利用して関数 `f`のグラフを描くアクションを書いてください。\n"
"    そのアクションでは有限個の点を `f`からサンプリングすることによって近似しなければなりません。\n"

#. type: Plain text
#: text/chapter12.md:181
#, no-wrap
msgid "     Experiment by rendering different paths by varying the function `f`.\n"
msgstr "     関数 `f`を変更し、様々なパスが描画されることを確かめてください。\n"

#. type: Title ##
#: text/chapter12.md:182
#, no-wrap
msgid "Drawing Random Circles"
msgstr "無作為に円を描く"

#. type: Plain text
#: text/chapter12.md:185
msgid ""
"The `Example/Random.purs` file contains an example which uses the `Effect` "
"monad to interleave two different types of side-effect: random number "
"generation, and canvas manipulation. The example renders one hundred "
"randomly generated circles onto the canvas."
msgstr ""
"`Example/Random.purs`ファイルには2種類の異なる副作用が混在した`Effect`モナド"
"を使う例が含まれています。\n"
"1つは乱数生成で、もう1つはcanvasの操作です。\n"
"この例では無作為に生成された円をキャンバスに100個描画します。"

#. type: Plain text
#: text/chapter12.md:187
msgid ""
"The `main` action obtains a reference to the graphics context as before, and "
"then sets the stroke and fill styles:"
msgstr ""
"`main`アクションではこれまでのようにグラフィックスコンテキストへの参照を取得"
"し、ストロークと塗り潰しスタイルを設定します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:188
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:style}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:style}}\n"

#. type: Plain text
#: text/chapter12.md:193
msgid ""
"Next, the code uses the `for_` function to loop over the integers between "
"`0` and `100`:"
msgstr ""
"次のコードでは `for_`アクションを使って `0`から `100`までの整数について反復し"
"ています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:194
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:for}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:for}}\n"

#. type: Plain text
#: text/chapter12.md:199
msgid ""
"On each iteration, the do notation block starts by generating three random "
"numbers distributed between `0` and `1`. These numbers represent the `x` and "
"`y` coordinates, and the radius of a circle:"
msgstr ""
"それぞれの繰り返しでのdo記法ブロックは、`0`と`1`の間に分布する3つの乱数を生成"
"することから始まります。\n"
"これらの数は `0`から `1`の間に無作為に分布しており、それぞれ `x`座標、 `y`座"
"標、半径 `r`を表しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:random}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:random}}\n"

#. type: Plain text
#: text/chapter12.md:205
msgid ""
"Next, for each circle, the code creates an `Arc` based on these parameters "
"and finally fills and strokes the arc with the current styles:"
msgstr ""
"次のコードではそれぞれの円について、これらの変数に基づいて `Arc`を作成し、最"
"後に現在のスタイルに従って円弧を塗り潰し線描きします。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:path}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Random.purs:path}}\n"

#. type: Plain text
#: text/chapter12.md:211
msgid ""
"Build this example by specifying the `Example.Random` module as the main "
"module:"
msgstr ""
"mainモジュールとして`Example.Random`を指定して、この例をビルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:212
#, no-wrap
msgid "$ spago bundle-app --main Example.Random --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Random --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:217
msgid "and view the result by opening `html/index.html`."
msgstr "`html/index.html`を開いて、結果を確認してみましょう。"

#. type: Title ##
#: text/chapter12.md:218
#, no-wrap
msgid "Transformations"
msgstr "座標変換"

#. type: Plain text
#: text/chapter12.md:221
msgid ""
"There is more to the canvas than just rendering simple shapes. Every canvas "
"maintains a transformation which is used to transform shapes before "
"rendering. Shapes can be translated, rotated, scaled, and skewed."
msgstr ""
"キャンバスは簡単な図形を描画するだけのものではありません。\n"
"キャンバスは変換行列を扱うことができ、描画の前に形状を変形してから図形を描画"
"できます。\n"
"図形は平行移動、回転、拡大縮小、及び斜めに変形できます。"

#. type: Plain text
#: text/chapter12.md:223
msgid ""
"The `canvas` library supports these transformations using the following "
"functions:"
msgstr "`canvas`ライブラリではこれらの変換を以下の関数で提供しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:224
#, no-wrap
msgid ""
"translate :: Context2D\n"
"          -> TranslateTransform\n"
"          -> Effect Context2D\n"
"\n"
"rotate    :: Context2D\n"
"          -> Number\n"
"          -> Effect Context2D\n"
"\n"
"scale     :: Context2D\n"
"          -> ScaleTransform\n"
"          -> Effect Context2D\n"
"\n"
"transform :: Context2D\n"
"          -> Transform\n"
"          -> Effect Context2D\n"
msgstr ""
"translate :: Context2D\n"
"          -> TranslateTransform\n"
"          -> Effect Context2D\n"
"\n"
"rotate    :: Context2D\n"
"          -> Number\n"
"          -> Effect Context2D\n"
"\n"
"scale     :: Context2D\n"
"          -> ScaleTransform\n"
"          -> Effect Context2D\n"
"\n"
"transform :: Context2D\n"
"          -> Transform\n"
"          -> Effect Context2D\n"

#. type: Plain text
#: text/chapter12.md:243
msgid ""
"The `translate` action performs a translation whose components are specified "
"by the properties of the `TranslateTransform` record."
msgstr ""
"`translate`アクションは`TranslateTransform`レコードのプロパティで指定した大き"
"さだけ平行移動します。"

#. type: Plain text
#: text/chapter12.md:245
msgid ""
"The `rotate` action performs a rotation around the origin, through some "
"number of radians specified by the first argument."
msgstr ""
"`rotate`アクションは最初の引数で指定されたラジアンの値に応じて、原点を中心と"
"して回転します。"

#. type: Plain text
#: text/chapter12.md:247
msgid ""
"The `scale` action performs a scaling, with the origin as the center. The "
"`ScaleTransform` record specifies the scale factors along the `x` and `y` "
"axes."
msgstr ""
"`scale`アクションは原点を中心として拡大縮小します。\n"
"`ScaleTransform`レコードは `X`軸と `y`軸に沿った拡大率を指定するのに使いま"
"す。"

#. type: Plain text
#: text/chapter12.md:249
msgid ""
"Finally, `transform` is the most general action of the four here. It "
"performs an affine transformation specified by a matrix."
msgstr ""
"最後の `transform`はこの4つのうちで最も一般化されたアクションです。\n"
"このアクションでは行列に従ってアフィン変換します。"

#. type: Plain text
#: text/chapter12.md:251
msgid ""
"Any shapes rendered after these actions have been invoked will automatically "
"have the appropriate transformation applied."
msgstr ""
"これらのアクションが呼び出された後に描画される図形は、自動的に適切な座標変換"
"が適用されます。"

#. type: Plain text
#: text/chapter12.md:253
msgid ""
"In fact, the effect of each of these functions is to _post-multiply_ the "
"transformation with the context's current transformation. The result is that "
"if multiple transformations applied after one another, then their effects "
"are actually applied in reverse:"
msgstr ""
"実際には、これらの関数のそれぞれの作用は、コンテキストの現在の変換行列に対し"
"て変換行列を*右から乗算*していきます。\n"
"つまり、もしある作用の変換をしていくと、その作用は実際には逆順に適用されてい"
"きます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:254
#, no-wrap
msgid ""
"transformations ctx = do\n"
"  translate ctx { translateX: 10.0, translateY: 10.0 }\n"
"  scale ctx { scaleX: 2.0, scaleY: 2.0 }\n"
"  rotate ctx (Math.tau / 4.0)\n"
"\n"
"  renderScene\n"
msgstr ""
"transformations ctx = do\n"
"  translate ctx { translateX: 10.0, translateY: 10.0 }\n"
"  scale ctx { scaleX: 2.0, scaleY: 2.0 }\n"
"  rotate ctx (Math.tau / 4.0)\n"
"\n"
"  renderScene\n"

#. type: Plain text
#: text/chapter12.md:264
msgid ""
"The effect of this sequence of actions is that the scene is rotated, then "
"scaled, and finally translated."
msgstr ""
"この一連のアクションの作用では、まずシーンが回転され、それから拡大縮小され、"
"最後に平行移動されます。"

#. type: Title ##
#: text/chapter12.md:265
#, no-wrap
msgid "Preserving the Context"
msgstr "コンテキストの保存"

#. type: Plain text
#: text/chapter12.md:268
msgid ""
"A common use case is to render some subset of the scene using a "
"transformation, and then to reset the transformation afterwards."
msgstr ""
"変換を適用してシーンの一部を描画し、それからその変換を元に戻す、という使い方"
"はよくあります。"

#. type: Plain text
#: text/chapter12.md:270
msgid ""
"The Canvas API provides the `save` and `restore` methods, which manipulate a "
"_stack_ of states associated with the canvas. `canvas` wraps this "
"functionality into the following functions:"
msgstr ""
"Canvas APIにはキャンバスの状態の*スタック*を操作する`save`と`restore`メソッド"
"が備わっています。\n"
"`canvas`ではこの機能を次のような関数で梱包しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:271
#, no-wrap
msgid ""
"save\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
"\n"
"restore\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
msgstr ""
"save\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
"\n"
"restore\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"

#. type: Plain text
#: text/chapter12.md:282
msgid ""
"The `save` action pushes the current state of the context (including the "
"current transformation and any styles) onto the stack, and the `restore` "
"action pops the top state from the stack and restores it."
msgstr ""
"`save`アクションは現在のコンテキストの状態（現在の変換行列や描画スタイル）を"
"スタックにプッシュし、 `restore`アクションはスタックの一番上の状態をポップ"
"し、コンテキストの状態を復元します。"

#. type: Plain text
#: text/chapter12.md:284
msgid ""
"This allows us to save the current state, apply some styles and "
"transformations, render some primitives, and finally restore the original "
"transformation and state. For example, the following function performs some "
"canvas action, but applies a rotation before doing so, and restores the "
"transformation afterwards:"
msgstr ""
"これらのアクションにより、現在の状態を保存し、いろいろなスタイルや変換を適用"
"してから原始的な図形を描画し、最後に元の変換と状態を復元できます。\n"
"例えば、次の関数は回転を適用してから幾つかのキャンバスアクションを実行し、そ"
"のあとに変換を復元します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:285
#, no-wrap
msgid ""
"rotated ctx render = do\n"
"  save ctx\n"
"  rotate (Math.tau / 3.0) ctx\n"
"  render\n"
"  restore ctx\n"
msgstr ""
"rotated ctx render = do\n"
"  save ctx\n"
"  rotate (Math.tau / 3.0) ctx\n"
"  render\n"
"  restore ctx\n"

#. type: Plain text
#: text/chapter12.md:294
msgid ""
"In the interest of abstracting over common use cases using higher-order "
"functions, the `canvas` library provides the `withContext` function, which "
"performs some canvas action while preserving the original context state:"
msgstr ""
"こういったよくある高階関数の使われ方の抽象化として、`canvas`ライブラリでは元"
"のコンテキスト状態を保存しつつ幾つかのキャンバスアクションを実行する "
"`withContext`関数が提供されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:295
#, no-wrap
msgid ""
"withContext\n"
"  :: Context2D\n"
"  -> Effect a\n"
"  -> Effect a\n"
msgstr ""
"withContext\n"
"  :: Context2D\n"
"  -> Effect a\n"
"  -> Effect a\n"

#. type: Plain text
#: text/chapter12.md:303
msgid ""
"We could rewrite the `rotated` function above using `withContext` as follows:"
msgstr ""
"`withContext`を使うと、先ほどの `rotated`関数を次のように書き換えることができ"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:304
#, no-wrap
msgid ""
"rotated ctx render =\n"
"  withContext ctx do\n"
"    rotate (Math.tau / 3.0) ctx\n"
"    render\n"
msgstr ""
"rotated ctx render =\n"
"  withContext ctx do\n"
"    rotate (Math.tau / 3.0) ctx\n"
"    render\n"

#. type: Title ##
#: text/chapter12.md:311
#, no-wrap
msgid "Global Mutable State"
msgstr "大域的な変更可能状態"

#. type: Plain text
#: text/chapter12.md:314
msgid ""
"In this section, we'll use the `refs` package to demonstrate another effect "
"in the `Effect` monad."
msgstr ""
"この節では `refs`パッケージを使って `Effect`モナドの別の作用について実演して"
"みます。"

#. type: Plain text
#: text/chapter12.md:316
msgid ""
"The `Effect.Ref` module provides a type constructor for global mutable "
"references, and an associated effect:"
msgstr ""
"`Effect.Ref`モジュールでは、大域的に変更可能な参照のための型構築子、及び関連"
"する作用を提供します。"

#. type: Fenced code block (text)
#: text/chapter12.md:317
#, no-wrap
msgid ""
"> import Effect.Ref\n"
"\n"
"> :kind Ref\n"
"Type -> Type\n"
msgstr ""
"> import Effect.Ref\n"
"\n"
"> :kind Ref\n"
"Type -> Type\n"

#. type: Plain text
#: text/chapter12.md:325
msgid ""
"A value of type `Ref a` is a mutable reference cell containing a value of "
"type `a`, used to track global mutation. As such, it should be used "
"sparingly."
msgstr ""
"型`Ref a`の値は型`a`の値を含む可変参照セルであり、大域的な変更を追跡するのに"
"使われます。\n"
"そういったわけでこれは少しだけ使う分に留めておくべきです。"

#. type: Plain text
#: text/chapter12.md:327
msgid ""
"The `Example/Refs.purs` file contains an example which uses a `Ref` to track "
"mouse clicks on the `canvas` element."
msgstr ""
"`Example/Refs.purs`ファイルには `canvas`要素上のマウスクリックを追跡するのに "
"`Ref`作用を使用する例が含まれています。"

#. type: Plain text
#: text/chapter12.md:329
msgid ""
"The code starts by creating a new reference containing the value `0`, by "
"using the `new` action:"
msgstr ""
"このコードでは最初に`new`アクションを使って値`0`を含む新しい参照を作成してい"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:330
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:clickCount}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Refs.purs:clickCount}}\n"

#. type: Plain text
#: text/chapter12.md:335
msgid ""
"Inside the click event handler, the `modify` action is used to update the "
"click count, and the updated value is returned."
msgstr ""
"クリックイベント制御子の内部では、 `modify`アクションを使用してクリック数を更"
"新し、更新された値が返されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:336
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:count}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Refs.purs:count}}\n"

#. type: Plain text
#: text/chapter12.md:341
msgid ""
"In the `render` function, the click count is used to determine the "
"transformation applied to a rectangle:"
msgstr "`render`関数ではクリック数に応じた変換を矩形に適用しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:342
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:withContext}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/Refs.purs:withContext}}\n"

#. type: Plain text
#: text/chapter12.md:347
msgid ""
"This action uses `withContext` to preserve the original transformation, and "
"then applies the following sequence of transformations (remember that "
"transformations are applied bottom-to-top):"
msgstr ""
"このアクションでは元の変換を保存するために `withContext`を使用しており、それ"
"から一連の変換を適用しています（変換が下から上に適用されることを思い出してく"
"ださい）。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid ""
"The rectangle is translated through `(-100, -100)` so that its center lies "
"at the origin."
msgstr "矩形が`(-100, -100)`だけ平行移動し、中心が原点に来ます。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid "The rectangle is scaled around the origin."
msgstr "矩形が原点を中心に拡大されます。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid ""
"The rectangle is rotated through some multiple of `10` degrees around the "
"origin."
msgstr "矩形が原点を中心に`10`の倍数分の角度で回転します。"

#. type: Bullet: '- '
#: text/chapter12.md:352
msgid ""
"The rectangle is translated through `(300, 300)` so that it center lies at "
"the center of the canvas."
msgstr "矩形が`(300, 300)`だけ平行移動し、中心がcanvasの中心に来ます。"

#. type: Plain text
#: text/chapter12.md:354
msgid "Build the example:"
msgstr "このコード例をビルドしてみましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:355
#, no-wrap
msgid "$ spago bundle-app --main Example.Refs --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.Refs --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:360
msgid ""
"and open the `html/index.html` file. If you click the canvas repeatedly, you "
"should see a green rectangle rotating around the center of the canvas."
msgstr ""
"`html/index.html`ファイルを開いてみましょう。\n"
"緑の四角形が表示され、何度かキャンバスをクリックするとキャンバスの中心の周り"
"で回転するはずです。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
msgid ""
"(Easy) Write a higher-order function which strokes and fills a path "
"simultaneously. Rewrite the `Random.purs` example using your function."
msgstr ""
"（簡単）パスの線描と塗り潰しを同時に行う高階関数を書いてください。\n"
"その関数を使用して `Random.purs`例を書き直してください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
msgid ""
"(Medium) Use `Random` and `Dom` to create an application which renders a "
"circle with random position, color and radius to the canvas when the mouse "
"is clicked."
msgstr ""
"（普通）`Random`作用と `Dom`作用を使用して、マウスがクリックされたときに、"
"キャンバスに無作為な位置、色、半径の円を描画するアプリケーションを作成してく"
"ださい。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
msgid ""
"(Medium) Write a function which transforms the scene by rotating it around a "
"point with specified coordinates. _Hint_: use a translation to first "
"translate the scene to the origin."
msgstr ""
"（普通）指定された座標を中心としてシーンを回転させる関数を書いてください。\n"
"*手掛かり*：最初にシーンを原点まで平行移動しましょう。"

#. type: Title ##
#: text/chapter12.md:367
#, no-wrap
msgid "L-Systems"
msgstr "L-System"

#. type: Plain text
#: text/chapter12.md:370
msgid ""
"In this final example, we will use the `canvas` package to write a function "
"for rendering _L-systems_ (or _Lindenmayer systems_)."
msgstr ""
"この章の最後の例として、 `canvas`パッケージを使用して*L-system*（またの名を"
"*Lindenmayer system*）を描画する関数を記述します。"

#. type: Plain text
#: text/chapter12.md:372
msgid ""
"An L-system is defined by an _alphabet_, an initial sequence of letters from "
"the alphabet, and a set of _production rules_. Each production rule takes a "
"letter of the alphabet and returns a sequence of replacement letters. This "
"process is iterated some number of times starting with the initial sequence "
"of letters."
msgstr ""
"L-Systemは*アルファベット*、つまり初期状態となるアルファベットの文字列と、*生"
"成規則*の集合で定義されています。\n"
"各生成規則は、アルファベットの文字をとり、それを置き換える文字の配列を返しま"
"す。\n"
"この処理は文字の初期配列から始まり、複数回繰り返されます。"

#. type: Plain text
#: text/chapter12.md:374
msgid ""
"If each letter of the alphabet is associated with some instruction to "
"perform on the canvas, the L-system can be rendered by following the "
"instructions in order."
msgstr ""
"もしアルファベットの各文字がcanvas上で実行される命令と対応付けられていれば、"
"その指示に順番に従うことでL-Systemを描画できます。"

#. type: Plain text
#: text/chapter12.md:376
msgid ""
"For example, suppose the alphabet consists of the letters `L` (turn left), "
"`R` (turn right) and `F` (move forward). We might define the following "
"production rules:"
msgstr ""
"例えばアルファベットが文字 `L`（左回転）、 `R`（右回転）、 `F`（前進）で構成"
"されているとします。\n"
"また、次のような生成規則を定義します。"

#. type: Fenced code block (text)
#: text/chapter12.md:377
#, no-wrap
msgid ""
"L -> L\n"
"R -> R\n"
"F -> FLFRRFLF\n"
msgstr ""
"L -> L\n"
"R -> R\n"
"F -> FLFRRFLF\n"

#. type: Plain text
#: text/chapter12.md:384
msgid ""
"If we start with the initial sequence \"FRRFRRFRR\" and iterate, we obtain "
"the following sequence:"
msgstr ""
"配列 \"FRRFRRFRR\" から始めて処理を繰り返すと、次のような経過を辿ります。"

#. type: Fenced code block (text)
#: text/chapter12.md:385
#, no-wrap
msgid ""
"FRRFRRFRR\n"
"FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR\n"
"FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...\n"
msgstr ""
"FRRFRRFRR\n"
"FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR\n"
"FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...\n"

#. type: Plain text
#: text/chapter12.md:392
msgid ""
"and so on. Plotting a piecewise-linear path corresponding to this set of "
"instruction approximates a curve called the _Koch curve_. Increasing the "
"number of iterations increases the resolution of the curve."
msgstr ""
"この命令群に対応する線分パスをプロットすると、*コッホ曲線*と呼ばれる曲線に近"
"似されます。\n"
"反復回数を増やすと、曲線の解像度が増していきます。"

#. type: Plain text
#: text/chapter12.md:394
msgid "Let's translate this into the language of types and functions."
msgstr "それでは型と関数のある言語へとこれを翻訳してみましょう。"

#. type: Plain text
#: text/chapter12.md:396
msgid "We can represent our alphabet of letters with the following ADT:"
msgstr "アルファベットの文字は以下のADTで表現できます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:397
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:letter}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:letter}}\n"

#. type: Plain text
#: text/chapter12.md:402
msgid ""
"This data type defines one data constructor for each letter in our alphabet."
msgstr ""
"このデータ型では、アルファベットの文字ごとに1つずつデータ構築子が定義されてい"
"ます。"

#. type: Plain text
#: text/chapter12.md:404
msgid ""
"How can we represent the initial sequence of letters? Well, that's just an "
"array of letters from our alphabet, which we will call a `Sentence`:"
msgstr ""
"文字の初期配列はどのように表したらいいでしょうか。\n"
"単なるアルファベットの配列でいいでしょう。\n"
"これを `Sentence`と呼ぶことにします。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:405
#, no-wrap
msgid ""
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:sentence}}\n"
"\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:initial}}\n"
msgstr ""
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:sentence}}\n"
"\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:initial}}\n"

#. type: Plain text
#: text/chapter12.md:412
msgid ""
"Our production rules can be represented as a function from `Letter` to "
"`Sentence` as follows:"
msgstr ""
"生成規則は以下のように`Letter`から `Sentence`への関数として表すことができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:413
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:productions}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:productions}}\n"

#. type: Plain text
#: text/chapter12.md:418
msgid "This is just copied straight from the specification above."
msgstr "これはまさに上記の仕様をそのまま書き写したものです。"

#. type: Plain text
#: text/chapter12.md:420
msgid ""
"Now we can implement a function `lsystem` which will take a specification in "
"this form, and render it to the canvas. What type should `lsystem` have? "
"Well, it needs to take values like `initial` and `productions` as arguments, "
"as well as a function which can render a letter of the alphabet to the "
"canvas."
msgstr ""
"これで、この形式の仕様を受け取りcanvasに描画する関数 `lsystem`を実装できま"
"す。\n"
"`lsystem`はどのような型を持っているべきでしょうか。\n"
"この関数は初期状態 `initial`や生成規則 `productions`のような値だけでなく、ア"
"ルファベットの文字をcanvasに描画する関数を引数に取る必要があります。"

#. type: Plain text
#: text/chapter12.md:422
msgid "Here is a first approximation to the type of `lsystem`:"
msgstr "`lsystem`の型の最初の大まかな設計は以下です。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:423
#, no-wrap
msgid ""
"Sentence\n"
"-> (Letter -> Sentence)\n"
"-> (Letter -> Effect Unit)\n"
"-> Int\n"
"-> Effect Unit\n"
msgstr ""
"Sentence\n"
"-> (Letter -> Sentence)\n"
"-> (Letter -> Effect Unit)\n"
"-> Int\n"
"-> Effect Unit\n"

#. type: Plain text
#: text/chapter12.md:432
msgid ""
"The first two argument types correspond to the values `initial` and "
"`productions`."
msgstr "最初の2つの引数の型は、値 `initial`と `productions`に対応しています。"

#. type: Plain text
#: text/chapter12.md:434
msgid ""
"The third argument represents a function which takes a letter of the "
"alphabet and _interprets_ it by performing some actions on the canvas. In "
"our example, this would mean turning left in the case of the letter `L`, "
"turning right in the case of the letter `R`, and moving forward in the case "
"of a letter `F`."
msgstr ""
"3番目の引数は、アルファベットの文字を取り、canvas上の幾つかのアクションを実行"
"することによって*解釈*する関数を表します。\n"
"この例では、文字`L`は左回転、文字 `R`で右回転、文字 `F`は前進を意味します。"

#. type: Plain text
#: text/chapter12.md:436
msgid ""
"The final argument is a number representing the number of iterations of the "
"production rules we would like to perform."
msgstr "最後の引数は、実行したい生成規則の繰り返し回数を表す数です。"

#. type: Plain text
#: text/chapter12.md:438
msgid ""
"The first observation is that the `lsystem` function should work for only "
"one type of `Letter`, but for any type, so we should generalize our type "
"accordingly. Let's replace `Letter` and `Sentence` with `a` and `Array a` "
"for some quantified type variable `a`:"
msgstr ""
"最初に気付くことは、この`lsystem`関数は1つの型`Letter`に対してのみ動作するの"
"ですが、どんなアルファベットについても機能すべきですから、この型はもっと一般"
"化されるべきです。\n"
"それでは、量子化された型変数 `a`について、`Letter`と `Sentence`を `a`と "
"`Array a`で置き換えましょう。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:439
#, no-wrap
msgid ""
"forall a. Array a\n"
"          -> (a -> Array a)\n"
"          -> (a -> Effect Unit)\n"
"          -> Int\n"
"          -> Effect Unit\n"
msgstr ""
"forall a. Array a\n"
"          -> (a -> Array a)\n"
"          -> (a -> Effect Unit)\n"
"          -> Int\n"
"          -> Effect Unit\n"

#. type: Plain text
#: text/chapter12.md:448
msgid ""
"The second observation is that, in order to implement instructions like "
"\"turn left\" and \"turn right\", we will need to maintain some state, "
"namely the direction in which the path is moving at any time. We need to "
"modify our function to pass the state through the computation. Again, the "
"`lsystem` function should work for any type of state, so we will represent "
"it using the type variable `s`."
msgstr ""
"次に気付くこととしては、「左回転」と「右回転」のような命令を実装するために"
"は、幾つかの状態を管理する必要があります。\n"
"具体的に言えば、その時点でパスが向いている方向を状態として持たなければなりま"
"せん。\n"
"計算を通じて状態を関数に渡すように変更する必要があります。\n"
"ここでも `lsystem`関数は状態がどんな型でも動作したほうがよいので、型変数 `s`"
"を使用してそれを表しています。"

#. type: Plain text
#: text/chapter12.md:450
msgid "We need to add the type `s` in three places:"
msgstr "型 `s`を追加する必要があるのは3箇所で、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:451
#, no-wrap
msgid ""
"forall a s. Array a\n"
"            -> (a -> Array a)\n"
"            -> (s -> a -> Effect s)\n"
"            -> Int\n"
"            -> s\n"
"            -> Effect s\n"
msgstr ""
"forall a s. Array a\n"
"            -> (a -> Array a)\n"
"            -> (s -> a -> Effect s)\n"
"            -> Int\n"
"            -> s\n"
"            -> Effect s\n"

#. type: Plain text
#: text/chapter12.md:461
msgid ""
"Firstly, the type `s` was added as the type of an additional argument to "
"`lsystem`. This argument will represent the initial state of the L-system."
msgstr ""
"まず追加の引数の型として `lsystem`に型 `s`が追加されています。\n"
"この引数はL-Systemの初期状態を表しています。"

#. type: Plain text
#: text/chapter12.md:463
msgid ""
"The type `s` also appears as an argument to, and as the return type of the "
"interpretation function (the third argument to `lsystem`). The "
"interpretation function will now receive the current state of the L-system "
"as an argument, and will return a new, updated state as its return value."
msgstr ""
"型 `s`は引数にも現れますが、解釈関数（`lsystem`の第3引数）の返り値の型として"
"も現れます。解釈関数は今のところ、引数としてL-Systemの現在の状態を受け取り、"
"返り値として更新された新しい状態を返します。"

#. type: Plain text
#: text/chapter12.md:465
msgid ""
"In the case of our example, we can define use following type to represent "
"the state:"
msgstr "この例の場合では、次のような型を使って状態を表す型を定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:466
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:state}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:state}}\n"

#. type: Plain text
#: text/chapter12.md:471
msgid ""
"The properties `x` and `y` represent the current position of the path, and "
"the `theta` property represents the current direction of the path, specified "
"as the angle between the path direction and the horizontal axis, in radians."
msgstr ""
"プロパティ `x`と `y`はパスの現在の位置を表しています。\n"
"プロパティ`theta`はパスの現在の向きを表しており、ラジアンで表された水平線に対"
"するパスの角度として指定されています。"

#. type: Plain text
#: text/chapter12.md:473
msgid "The initial state of the system might be specified as follows:"
msgstr "システムの初期状態は次のように指定されます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:474
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:initialState}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:initialState}}\n"

#. type: Plain text
#: text/chapter12.md:479
msgid ""
"Now let's try to implement the `lsystem` function. We will find that its "
"definition is remarkably simple."
msgstr ""
"それでは、 `lsystem`関数を実装してみます。定義はとても単純であることがわかる"
"でしょう。"

#. type: Plain text
#: text/chapter12.md:481
msgid ""
"It seems reasonable that `lsystem` should recurse on its fourth argument (of "
"type `Int`). On each step of the recursion, the current sentence will "
"change, having been updated by using the production rules. With that in "
"mind, let's begin by introducing names for the function arguments, and "
"delegating to a helper function:"
msgstr ""
"`lsystem`は第4引数の値（型は`Int`）に応じて再帰するのが良さそうです。\n"
"再帰の各ステップでは、生成規則に従って状態が更新され、現在の文が変化していき"
"ます。\n"
"このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を"
"移譲することから始めましょう。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:482
#, no-wrap
msgid ""
"lsystem :: forall a s\n"
"         . Array a\n"
"        -> (a -> Array a)\n"
"        -> (s -> a -> Effect s)\n"
"        -> Int\n"
"        -> s\n"
"        -> Effect s\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_impl}}\n"
msgstr ""
"lsystem :: forall a s\n"
"         . Array a\n"
"        -> (a -> Array a)\n"
"        -> (s -> a -> Effect s)\n"
"        -> Int\n"
"        -> s\n"
"        -> Effect s\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_impl}}\n"

#. type: Plain text
#: text/chapter12.md:494
msgid ""
"The `go` function works by recursion on its second argument. There are two "
"cases: when `n` is zero, and when `n` is non-zero."
msgstr ""
"`go`関数は第2引数に応じて再帰することで動作します。\n"
"場合分けは2つであり、`n`がゼロであるときと `n`がゼロでないときです。"

#. type: Plain text
#: text/chapter12.md:496
#, no-wrap
msgid "In the first case, the recursion is complete, and we simply need to interpret the current sentence according to the interpretation function. We have a sentence of type `Array a`, a state of type `s`, and a function of type `s -> a -> Effect s`. This sounds like a job for the `foldM` function which we defined earlier, and which is available from the `control` package:\n"
msgstr ""
"1つ目の場合は再帰は完了し、解釈関数に応じて現在の文を解釈します。\n"
"型`Array a`の文、型 `s`の状態、型 `s -> a -> Effect s`の関数があります。\n"
"以前定義した `foldM`でやったことみたいです。\n"
"この関数は`control`パッケージで手に入ります。\n"

#. type: Fenced code block (haskell)
#: text/chapter12.md:497
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_0}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_0}}\n"

#. type: Plain text
#: text/chapter12.md:502
msgid ""
"What about in the non-zero case? In that case, we can simply apply the "
"production rules to each letter of the current sentence, concatenate the "
"results, and repeat by calling `go` recursively:"
msgstr ""
"ゼロでない場合ではどうでしょうか。\n"
"その場合は、単に生成規則を現在の文のそれぞれの文字に適用して、その結果を連結"
"し、そして再帰的に`go`を呼び出すことによって繰り返します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:503
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_i}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_i}}\n"

#. type: Plain text
#: text/chapter12.md:508
msgid ""
"That's it! Note how the use of higher order functions like `foldM` and "
"`concatMap` allowed us to communicate our ideas concisely."
msgstr ""
"これだけです。\n"
"`foldM`や `concatMap`のような高階関数を使うと、このようにアイデアを簡潔に表現"
"できるのです。"

#. type: Plain text
#: text/chapter12.md:510
msgid ""
"However, we're not quite done. The type we have given is actually still too "
"specific. Note that we don't use any canvas operations anywhere in our "
"implementation. Nor do we make use of the structure of the `Effect` monad at "
"all. In fact, our function works for _any_ monad `m`!"
msgstr ""
"しかし、話はこれで終わりではありません。\n"
"ここで与えた型は、実際はまだ特殊化されすぎています。\n"
"この定義ではcanvasの操作が実装のどこにも使われていないことに注目してくださ"
"い。\n"
"それに、全く`Effecta`モナドの構造を利用していません。\n"
"実際には、この関数は*どんな*モナド`m`についても動作します。"

#. type: Plain text
#: text/chapter12.md:512
msgid ""
"Here is the more general type of `lsystem`, as specified in the accompanying "
"source code for this chapter:"
msgstr ""
"この章に添付されたソースコードで指定されている`lsystem`の型はもっと一般的に"
"なっています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:513
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_anno}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_anno}}\n"

#. type: Plain text
#: text/chapter12.md:518
msgid ""
"We can understand this type as saying that our interpretation function is "
"free to have any side-effects at all, captured by the monad `m`. It might "
"render to the canvas, or print information to the console, or support "
"failure or multiple return values. The reader is encouraged to try writing L-"
"systems which use these various types of side-effect."
msgstr ""
"この型で書かれていることは、この解釈関数はモナド `m`が持つ任意の副作用を完全"
"に自由に持つことができる、ということだと理解できます。\n"
"キャンバスに描画したり、またはコンソールに情報を出力したりするかもしれません"
"し、失敗や複数の戻り値に対応しているかもしれません。\n"
"こういった様々な型の副作用を使ったL-Systemを記述してみることを読者にお勧めし"
"ます。"

#. type: Plain text
#: text/chapter12.md:520
msgid ""
"This function is a good example of the power of separating data from "
"implementation. The advantage of this approach is that we gain the freedom "
"to interpret our data in multiple different ways. We might even factor "
"`lsystem` into two smaller functions: the first would build the sentence "
"using repeated application of `concatMap`, and the second would interpret "
"the sentence using `foldM`. This is also left as an exercise for the reader."
msgstr ""
"この関数は実装からデータを分離することの威力を示す良い例となっています。\n"
"この手法の利点は、複数の異なる方法でデータを解釈する自由が得られることで"
"す。\n"
"`lsystem`は2つの小さな関数へと分解さえできるかもしれません。\n"
"1つ目は `concatMap`の適用の繰り返しを使って文を構築するもので、2つ目は "
"`foldM`を使って文を解釈するものです。\n"
"これは読者の演習として残しておきます。"

#. type: Plain text
#: text/chapter12.md:522
#, no-wrap
msgid "Let's complete our example by implementing its interpretation function. The type of `lsystem` tells us that its type signature must be `s -> a -> m s` for some types `a` and `s` and a type constructor `m`. We know that we want `a` to be `Letter` and `s` to be `State`, and for the monad `m` we can choose `Effect`. This gives us the following type:\n"
msgstr ""
"それでは解釈関数を実装して、この章の例を完成させましょう。\n"
"`lsystem`の型が教えてくれているのは、型シグネチャが、何らかの型 `a`と `s`、型構築子 `m`について、 `s -> a -> m s`でなければならないということです。\n"
"`a`を `Letter`、 `s`を `State`、モナド `m`を `Effect`というように選びたいということがわかっています。\n"
"これにより次のような型になります。\n"

#. type: Fenced code block (haskell)
#: text/chapter12.md:523
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpret_anno}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpret_anno}}\n"

#. type: Plain text
#: text/chapter12.md:528
msgid ""
"To implement this function, we need to handle the three data constructors of "
"the `Letter` type. To interpret the letters `L` (move left) and `R` (move "
"right), we simply have to update the state to change the angle `theta` "
"appropriately:"
msgstr ""
"この関数を実装するには、 `Letter`型の3つのデータ構築子それぞれについて処理す"
"る必要があります。文字 `L`（左回転）と `R`（右回転）の解釈では、`theta`を適切"
"な角度へ変更するように状態を更新するだけです。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:529
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretLR}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretLR}}\n"

#. type: Plain text
#: text/chapter12.md:534
msgid ""
"To interpret the letter `F` (move forward), we can calculate the new "
"position of the path, render a line segment, and update the state, as "
"follows:"
msgstr ""
"文字 `F`（前進）を解釈するには、パスの新しい位置を計算し、線分を描画し、状態"
"を次のように更新します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:535
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretF}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretF}}\n"

#. type: Plain text
#: text/chapter12.md:540
msgid ""
"Note that in the source code for this chapter, the `interpret` function is "
"defined using a `let` binding inside the `main` function, so that the name "
"`ctx` is in scope. It would also be possible to move the context into the "
"`State` type, but this would be inappropriate because it is not a changing "
"part of the state of the system."
msgstr ""
"なおこの章のソースコードでは、名前 `ctx`がスコープに入るように、`interpret`関"
"数は `main`関数内で `let`束縛を使用して定義されています。\n"
"`State`型がコンテキストを持つように変更できるでしょうが、それはこのシステムの"
"状態の変化する部分ではないので不適切でしょう。"

#. type: Plain text
#: text/chapter12.md:542
msgid "To render this L-system, we can simply use the `strokePath` action:"
msgstr ""
"このL-Systemを描画するには、次のような `strokePath`アクションを使用するだけで"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:543
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:strokePath}}\n"
msgstr "{{#include ../exercises/chapter12/src/Example/LSystem.purs:strokePath}}\n"

#. type: Plain text
#: text/chapter12.md:548
msgid "Compile the L-system example using"
msgstr "次のコマンドを使ってL-Systemをコンパイルします。"

#. type: Fenced code block (text)
#: text/chapter12.md:549
#, no-wrap
msgid "$ spago bundle-app --main Example.LSystem --to dist/Main.js\n"
msgstr "$ spago bundle-app --main Example.LSystem --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:554
msgid ""
"and open `html/index.html`. You should see the Koch curve rendered to the "
"canvas."
msgstr ""
"`html/index.html`を開いてみましょう。\n"
"キャンバスにコッホ曲線が描画されるのがわかると思います。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Easy) Modify the L-system example above to use `fillPath` instead of "
"`strokePath`. _Hint_: you will need to include a call to `closePath`, and "
"move the call to `moveTo` outside of the `interpret` function."
msgstr ""
"（簡単）`strokePath`の代わりに `fillPath`を使用するように、上のL-Systemの例を"
"変更してください。\n"
"*手掛かり*：`closePath`の呼び出しを含め、 `moveTo`の呼び出しを `interpret`関"
"数の外側に移動する必要があります。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Easy) Try changing the various numerical constants in the code, to "
"understand their effect on the rendered system."
msgstr ""
"（簡単）描画システムへの影響を理解するために、コード中の様々な数値の定数を変"
"更してみてください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Medium) Break the `lsystem` function into two smaller functions. The first "
"should build the final sentence using repeated application of `concatMap`, "
"and the second should use `foldM` to interpret the result."
msgstr ""
"（普通）`lsystem`関数を2つの小さな関数に分割してください。\n"
"1つ目は`concatMap`の適用の繰り返しを使用して最終的な文を構築するもので、2つ目"
"は `foldM`を使用して結果を解釈するものでなくてはなりません。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Medium) Add a drop shadow to the filled shape, by using the "
"`setShadowOffsetX`, `setShadowOffsetY`, `setShadowBlur` and `setShadowColor` "
"actions. _Hint_: use PSCi to find the types of these functions."
msgstr ""
"（普通）`setShadowOffsetX`アクション、 `setShadowOffsetY`アクション、"
"`setShadowBlur`アクション、 `setShadowColor`アクションを使い、塗りつぶされた"
"図形にドロップシャドウを追加してください。\n"
"*手掛かり*：PSCiを使って、これらの関数の型を調べてみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
msgid ""
"(Medium) The angle of the corners is currently a constant (`tau/6`). "
"Instead, it can be moved into the `Letter` data type, which allows it to be "
"changed by the production rules:"
msgstr ""
"（普通）向きを変えるときの角度の大きさは今のところ一定 (`tau/6`) です。\n"
"これに代えて、`Letter`データ型の中に角度を移動させ、生成規則によって変更でき"
"るようにしてください。"

#. type: Plain text
#: text/chapter12.md:565
#, no-wrap
msgid ""
"     ```haskell\n"
"     type Angle = Number\n"
msgstr ""
"     ```haskell\n"
"     type Angle = Number\n"

#. type: Plain text
#: text/chapter12.md:568
#, no-wrap
msgid ""
"     data Letter = L Angle | R Angle | F\n"
"     ```\n"
msgstr ""
"     data Letter = L Angle | R Angle | F\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:571
#, no-wrap
msgid ""
"     How can this new information be used in the production rules to create interesting shapes?\n"
" 1. (Difficult) An L-system is given by an alphabet with four letters: `L` (turn left through 60 degrees), `R` (turn right through 60 degrees), `F` (move forward) and `M` (also move forward).\n"
msgstr ""
"     生成規則でこの新しい情報を使うと、どんな面白い図形を作ることができるでしょうか。\n"
"1. （難しい）`L`（60度左回転）、 `R`（60度右回転）、`F`（前進）、 `M`（これも前進）という4つの文字からなるアルファベットでL-Systemが与えられたとします。\n"

#. type: Plain text
#: text/chapter12.md:573
#, no-wrap
msgid "     The initial sentence of the system is the single letter `M`.\n"
msgstr "     このシステムの文の初期状態は、単一の文字 `M`です。\n"

#. type: Plain text
#: text/chapter12.md:575
#, no-wrap
msgid "     The production rules are specified as follows:\n"
msgstr "     このシステムの生成規則は次のように指定されています。\n"

#. type: Plain text
#: text/chapter12.md:582
#, no-wrap
msgid ""
"     ```text\n"
"     L -> L\n"
"     R -> R\n"
"     F -> FLMLFRMRFRMRFLMLF\n"
"     M -> MRFRMLFLMLFLMRFRM\n"
"     ```\n"
msgstr ""
"     ```text\n"
"     L -> L\n"
"     R -> R\n"
"     F -> FLMLFRMRFRMRFLMLF\n"
"     M -> MRFRMLFLMLFLMRFRM\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:584
#, no-wrap
msgid "     Render this L-system. _Note_: you will need to decrease the number of iterations of the production rules, since the size of the final sentence grows exponentially with the number of iterations.\n"
msgstr ""
"     このL-Systemを描画してください。\n"
"     *補足*：最後の文のサイズは反復回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を削減する必要があります。\n"

#. type: Plain text
#: text/chapter12.md:586
#, no-wrap
msgid "     Now, notice the symmetry between `L` and `M` in the production rules. The two \"move forward\" instructions can be differentiated using a `Boolean` value using the following alphabet type:\n"
msgstr "     ここで、生成規則における `L`と `M`の間の対称性に注目してください。2つの「前進」命令は、次のようなアルファベット型を使用すると、`Boolean`値を使って区別できます。\n"

#. type: Plain text
#: text/chapter12.md:590
#, no-wrap
msgid ""
"     ```haskell\n"
"     data Letter = L | R | F Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data Letter = L | R | F Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter12.md:593
#, no-wrap
msgid ""
"     Implement this L-system again using this representation of the alphabet.\n"
" 1. (Difficult) Use a different monad `m` in the interpretation function. You might try using `Effect.Console` to write the L-system onto the console, or using `Effect.Random` to apply random \"mutations\" to the state type.\n"
msgstr ""
"    このアルファベットの表現を使用して、もう一度このL-Systemを実装してください。\n"
"1. （難しい）解釈関数で別のモナド `m`を使ってみましょう。`Effect.Console`作用を利用してコンソール上にL-Systemを出力したり、`Random`作用を利用して状態の型に無作為の「突然変異」を適用したりしてみてください。\n"

#. type: Plain text
#: text/chapter12.md:597
msgid ""
"In this chapter, we learned how to use the HTML5 Canvas API from PureScript "
"by using the `canvas` library. We also saw a practical demonstration of many "
"of the techniques we have learned already: maps and folds, records and row "
"polymorphism, and the `Effect` monad for handling side-effects."
msgstr ""
"この章では、 `canvas`ライブラリを使用することにより、PureScriptからHTML5 "
"Canvas APIを使う方法について学びました。\n"
"また、これまで学んできた手法の多くを利用した実用的な例について見ました。\n"
"マップや畳み込み、レコードと行多相、副作用を扱うための `Effect`モナドなどで"
"す。"

#. type: Plain text
#: text/chapter12.md:599
msgid ""
"The examples also demonstrated the power of higher-order functions and "
"_separating data from implementation_. It would be possible to extend these "
"ideas to completely separate the representation of a scene from its "
"rendering function, using an algebraic data type, for example:"
msgstr ""
"この章の例では、高階関数の威力を示すとともに、 _実装からのデータの分離_ も実"
"演してみせました。これは例えば、代数データ型を使用してこれらの概念を次のよう"
"に拡張し、描画関数からシーンの表現を完全に分離できるようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:600
#, no-wrap
msgid ""
"data Scene\n"
"  = Rect Rectangle\n"
"  | Arc Arc\n"
"  | PiecewiseLinear (Array Point)\n"
"  | Transformed Transform Scene\n"
"  | Clipped Rectangle Scene\n"
"  | ...\n"
msgstr ""
"data Scene\n"
"  = Rect Rectangle\n"
"  | Arc Arc\n"
"  | PiecewiseLinear (Array Point)\n"
"  | Transformed Transform Scene\n"
"  | Clipped Rectangle Scene\n"
"  | ...\n"

#. type: Plain text
#: text/chapter12.md:611
msgid ""
"This approach is taken in the `drawing` package, and it brings the "
"flexibility of being able to manipulate the scene as data in various ways "
"before rendering."
msgstr ""
"この手法は `drawing`パッケージでも採用されており、描画前にさまざまな方法で"
"データとしてシーンを操作できる柔軟性をもたらしています。"

#. type: Plain text
#: text/chapter12.md:612
msgid ""
"For examples of games rendered to the canvas, see the \"Behavior\" and "
"\"Signal\" recipes in the [cookbook](https://github.com/JordanMartinez/"
"purescript-cookbook/blob/master/README.md#recipes)."
msgstr ""
"canvasに描画されるゲームの例については[cookbook](https://github.com/"
"JordanMartinez/purescript-cookbook/blob/master/README.md#recipes)の"
"「Behavior」と「Signal」のレシピを見てください。"

#. type: Title #
#: text/chapter13.md:1
#, no-wrap
msgid "Generative Testing"
msgstr "テストの自動生成"

#. type: Plain text
#: text/chapter13.md:6
msgid ""
"In this chapter, we will see a particularly elegant application of type "
"classes to the problem of testing. Instead of testing our code by telling "
"the compiler _how_ to test, we simply assert _what_ properties our code "
"should have. Test cases can be generated randomly from this specification, "
"using type classes to hide the boilerplate code of random data generation. "
"This is called _generative testing_ (or _property-based testing_), a "
"technique made popular by the [QuickCheck](https://wiki.haskell.org/"
"Introduction_to_QuickCheck1) library in Haskell."
msgstr ""
"この章では、テスティングの問題に対する、型クラスの特に洗練された応用について"
"示します。\n"
"*どのように*テストするのかをコンパイラに教えるのではなく、コードが*どのような"
"*性質を持っているべきかを教えることでテストします。\n"
"型クラスを使って無作為データ生成のための紋切り型なコードを書かずして、テスト"
"項目を仕様から無作為に生成できます。\n"
"これは*生成的テスティング*（generative testing、または*property-based "
"testing*）と呼ばれ、Haskellの[QuickCheck](http://wiki.haskell.org/"
"Introduction_to_QuickCheck1)ライブラリによって普及した手法です。"

#. type: Plain text
#: text/chapter13.md:8
msgid ""
"The `quickcheck` package is a port of Haskell's QuickCheck library to "
"PureScript, and for the most part, it preserves the types and syntax of the "
"original library. We will see how to use `quickcheck` to test a simple "
"library, using Spago to integrate our test suite into our development "
"process."
msgstr ""
"`quickcheck`パッケージはHaskellのQuickCheckライブラリをPureScriptにポーティン"
"グしたもので、型や構文はもとのライブラリとほとんど同じようになっています。 "
"`quickcheck`を使って簡単なライブラリをテストし、Spagoでテストスイートを自動化"
"されたビルドに統合する方法を見ていきます。"

#. type: Plain text
#: text/chapter13.md:12
msgid "This chapter's project adds `quickcheck` as a dependency."
msgstr "この章のプロジェクトには依存関係として `quickcheck`が追加されます。"

#. type: Plain text
#: text/chapter13.md:14
msgid ""
"In a Spago project, test sources should be placed in the `test` directory, "
"and the main module for the test suite should be named `Test.Main`. The test "
"suite can be run using the `spago test` command."
msgstr ""
"Spagoプロジェクトでは、テストソースは `test`ディレクトリに置かれ、テストス"
"イートのメインモジュールは `Test.Main`と名づけられます。 テストスイートは、 "
"`spago test`コマンドを使用して実行できます。"

#. type: Title ##
#: text/chapter13.md:15
#, no-wrap
msgid "Writing Properties"
msgstr "性質を書く"

#. type: Plain text
#: text/chapter13.md:18
msgid ""
"The `Merge` module implements a simple function `merge`, which we will use "
"to demonstrate the features of the `quickcheck` library."
msgstr ""
"`Merge`モジュールでは簡単な関数 `merge`が実装されています。\n"
"これを`quickcheck`ライブラリの機能を実演するために使っていきます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:19
#, no-wrap
msgid "merge :: Array Int -> Array Int -> Array Int\n"
msgstr "merge :: Array Int -> Array Int -> Array Int\n"

#. type: Plain text
#: text/chapter13.md:24
msgid ""
"`merge` takes two sorted arrays of integers, and merges their elements so "
"that the result is also sorted. For example:"
msgstr ""
"`merge`は2つの整列された整数の配列を取って、結果が整列されるように要素を統合"
"します。\n"
"例えば次のようになります。"

#. type: Fenced code block (text)
#: text/chapter13.md:25
#, no-wrap
msgid ""
"> import Merge\n"
"> merge [1, 3, 5] [2, 4, 5]\n"
"\n"
"[1, 2, 3, 4, 5, 5]\n"
msgstr ""
"> import Merge\n"
"> merge [1, 3, 5] [2, 4, 5]\n"
"\n"
"[1, 2, 3, 4, 5, 5]\n"

#. type: Plain text
#: text/chapter13.md:33
msgid ""
"In a typical test suite, we might test `merge` by generating a few small "
"test cases like this by hand, and asserting that the results were equal to "
"the appropriate values. However, everything we need to know about the "
"`merge` function can be summarized by this property:"
msgstr ""
"典型的なテストスイートでは、手作業でこのような小さなテスト項目を幾つも作成"
"し、結果が正しい値と等しいことを確認することでテストを実施します。\n"
"しかし、 `merge`関数について知る必要があるものは全て、この性質に要約できま"
"す。"

#. type: Bullet: '- '
#: text/chapter13.md:35
msgid ""
"If `xs` and `ys` are sorted, then `merge xs ys` is the sorted result of both "
"arrays appended together."
msgstr ""
"`xs`と`ys`が整列済みなら、`merge xs ys`は両方の配列が一緒に結合されて整列され"
"た結果になります。"

#. type: Plain text
#: text/chapter13.md:37
msgid ""
"`quickcheck` allows us to test this property directly, by generating random "
"test cases. We simply state the properties that we want our code to have, as "
"functions. In this case, we have a single property:"
msgstr ""
"`quickcheck`では、無作為なテスト項目を生成することで、直接この性質をテストで"
"きます。\n"
"コードが持つべき性質を関数として述べるだけです。\n"
"この場合は1つの性質があります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:38
#, no-wrap
msgid ""
"main = do\n"
"  quickCheck \\xs ys ->\n"
"    eq (merge (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"main = do\n"
"  quickCheck \\xs ys ->\n"
"    eq (merge (sort xs) (sort ys)) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:45
msgid ""
"When we run this code, `quickcheck` will attempt to disprove the properties "
"we claimed, by generating random inputs `xs` and `ys`, and passing them to "
"our functions. If our function returns `false` for any inputs, the property "
"will be incorrect, and the library will raise an error. Fortunately, the "
"library is unable to disprove our properties after generating 100 random "
"test cases:"
msgstr ""
"このコードを実行すると、 `quickcheck`は無作為な入力 `xs`と `ys`を生成してこの"
"関数に渡すことで、主張しようとしている性質を反証しようとします。\n"
"何らかの入力に対して関数が `false`を返した場合、性質は正しくないことが示さ"
"れ、ライブラリはエラーを発生させます。\n"
"幸いなことに、次のように100個の無作為なテスト項目を生成しても、ライブラリはこ"
"の性質を反証できません。"

#. type: Fenced code block (text)
#: text/chapter13.md:46
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Installation complete.\n"
"Build succeeded.\n"
"100/100 test(s) passed.\n"
"...\n"
"Tests succeeded.\n"
msgstr ""
"$ spago test\n"
"\n"
"Installation complete.\n"
"Build succeeded.\n"
"100/100 test(s) passed.\n"
"...\n"
"Tests succeeded.\n"

#. type: Plain text
#: text/chapter13.md:57
msgid ""
"If we deliberately introduce a bug into the `merge` function (for example, "
"by changing the less-than check for a greater-than check), then an exception "
"is thrown at runtime after the first failed test case:"
msgstr ""
"もし `merge`関数に意図的にバグを混入した場合（例えば、大なりのチェックを小な"
"りのチェックへと変更するなど）、最初に失敗したテスト項目の後で例外が実行時に"
"投げられます。"

#. type: Fenced code block (text)
#: text/chapter13.md:58
#, no-wrap
msgid ""
"Error: Test 1 failed:\n"
"Test returned false\n"
msgstr ""
"Error: Test 1 failed:\n"
"Test returned false\n"

#. type: Plain text
#: text/chapter13.md:64
msgid ""
"As we can see, this error message is not very helpful, but it can be "
"improved with a little work."
msgstr ""
"見ての通りこのエラーメッセージではあまり役に立ちませんが、少し工夫するだけで"
"改良できます。"

#. type: Title ##
#: text/chapter13.md:65
#, no-wrap
msgid "Improving Error Messages"
msgstr "エラーメッセージの改善"

#. type: Plain text
#: text/chapter13.md:68
#, no-wrap
msgid "To provide error messages along with our failed test cases, `quickcheck` provides the `<?>` operator. Simply separate the property definition from the error message using `<?>`, as follows:\n"
msgstr ""
"テスト項目が失敗した時に同時にエラーメッセージを提供する上で、`quickcheck`は`<?>`演算子を提供しています。\n"
"次のように性質の定義とエラー文言を`<?>`で区切って書くだけです。\n"

#. type: Fenced code block (haskell)
#: text/chapter13.md:69
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  let\n"
"    result = merge (sort xs) (sort ys)\n"
"    expected = sort $ xs <> ys\n"
"  in\n"
"    eq result expected <?> \"Result:\\n\" <> show result <> \"\\nnot equal to expected:\\n\" <> show expected\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  let\n"
"    result = merge (sort xs) (sort ys)\n"
"    expected = sort $ xs <> ys\n"
"  in\n"
"    eq result expected <?> \"Result:\\n\" <> show result <> \"\\nnot equal to expected:\\n\" <> show expected\n"

#. type: Plain text
#: text/chapter13.md:79
msgid ""
"This time, if we modify the code to introduce a bug, we see our improved "
"error message after the first failed test case:"
msgstr ""
"このとき、もしバグを混入するようにコードを変更すると、最初のテスト項目が失敗"
"したときに改良されたエラーメッセージが表示されます。"

#. type: Fenced code block (text)
#: text/chapter13.md:80
#, no-wrap
msgid ""
"Error: Test 1 (seed 534161891) failed:\n"
"Result:\n"
"[-822215,-196136,-116841,618343,887447,-888285]\n"
"not equal to expected:\n"
"[-888285,-822215,-196136,-116841,618343,887447]\n"
msgstr ""
"Error: Test 1 (seed 534161891) failed:\n"
"Result:\n"
"[-822215,-196136,-116841,618343,887447,-888285]\n"
"not equal to expected:\n"
"[-888285,-822215,-196136,-116841,618343,887447]\n"

#. type: Plain text
#: text/chapter13.md:89
msgid ""
"Notice how the input `xs` and `ys` were generated as arrays of randomly-"
"selected integers."
msgstr ""
"入力 `xs`が無作為に選ばれた数の配列として生成されていることに注目してくださ"
"い。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:94
msgid ""
"(Easy) Write a property which asserts that merging an array with the empty "
"array does not modify the original array. _Note_: This new property is "
"redundant, since this situation is already covered by our existing property. "
"We're just trying to give you readers a simple way to practice using "
"quickCheck."
msgstr ""
"（簡単）配列に空の配列を統合しても元の配列は変更されないことを確かめる性質を"
"書いてください。\n"
"*補足*：この新しい性質は冗長です。\n"
"というのもこの状況は既に既存の性質で押さえられているからです。\n"
"ここでは読者がQuickCheckを使う練習のための簡単なやり方を示そうとしているだけ"
"です。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:94
msgid ""
"(Easy) Add an appropriate error message to the remaining property for "
"`merge`."
msgstr ""
"（簡単）`merge`の残りの性質に対して、適切なエラーメッセージを追加してくださ"
"い。"

#. type: Title ##
#: text/chapter13.md:95
#, no-wrap
msgid "Testing Polymorphic Code"
msgstr "多相的なコードのテスト"

#. type: Plain text
#: text/chapter13.md:98
msgid ""
"The `Merge` module defines a generalization of the `merge` function, called "
"`mergePoly`, which works not only with arrays of numbers, but also arrays of "
"any type belonging to the `Ord` type class:"
msgstr ""
"`Merge`モジュールでは、数の配列だけでなく、 `Ord`型クラスに属するどんな型の配"
"列に対しても動作する、 `merge`関数を一般化した `mergePoly`という関数が定義さ"
"れています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:99
#, no-wrap
msgid "mergePoly :: forall a. Ord a => Array a -> Array a -> Array a\n"
msgstr "mergePoly :: forall a. Ord a => Array a -> Array a -> Array a\n"

#. type: Plain text
#: text/chapter13.md:104
msgid ""
"If we modify our original test to use `mergePoly` in place of `merge`, we "
"see the following error message:"
msgstr ""
"`merge`の代わりに `mergePoly`を使うように元のテストを変更すると、次のようなエ"
"ラーメッセージが表示されます。"

#. type: Fenced code block (text)
#: text/chapter13.md:105
#, no-wrap
msgid ""
"No type class instance was found for\n"
"\n"
"  Test.QuickCheck.Arbitrary.Arbitrary t0\n"
"\n"
"The instance head contains unknown type variables.\n"
"Consider adding a type annotation.\n"
msgstr ""
"No type class instance was found for\n"
"\n"
"  Test.QuickCheck.Arbitrary.Arbitrary t0\n"
"\n"
"The instance head contains unknown type variables.\n"
"Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter13.md:115
msgid ""
"This error message indicates that the compiler could not generate random "
"test cases, because it did not know what type of elements we wanted our "
"arrays to have. In these sorts of cases, we can use type annotations to "
"force the compiler to infer a particular type, such as `Array Int`:"
msgstr ""
"このエラーメッセージは、配列に持たせたい要素の型が何なのかわからないので、コ"
"ンパイラが無作為なテスト項目を生成できなかったということを示しています。\n"
"このような場合、型註釈を使ってコンパイラが特定の型を推論するように強制できま"
"す。\n"
"例えば`Array Int`などです。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:116
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:122
msgid ""
"We can alternatively use a helper function to specify type, which may result "
"in cleaner code. For example, if we define a function `ints` as a synonym "
"for the identity function:"
msgstr ""
"代替案として型を指定する補助関数を使うこともできます。\n"
"こうするとより見通しのよいコードになることがあります。\n"
"例えば同値関数の同義な関数`ints`を定義したとしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:123
#, no-wrap
msgid ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"
msgstr ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"

#. type: Plain text
#: text/chapter13.md:129
msgid ""
"then we can modify our test so that the compiler infers the type `Array Int` "
"for our two array arguments:"
msgstr ""
"それから、コンパイラが引数の2つの配列の型 `Array Int`を推論するように、テスト"
"を変更します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:130
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:136
msgid ""
"Here, `xs` and `ys` both have type `Array Int`, since the `ints` function "
"has been used to disambiguate the unknown type."
msgstr ""
"ここで、 `ints`関数が不明な型を解消するために使われているため、 `xs`と `ys`は"
"どちらも型 `Array Int`を持っています。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:141
msgid ""
"(Easy) Write a function `bools` which forces the types of `xs` and `ys` to "
"be `Array Boolean`, and add additional properties which test `mergePoly` at "
"that type."
msgstr ""
"（簡単）`xs`と `ys`の型を `Array Boolean`に強制する関数 `bools`を書き、 "
"`mergePoly`をその型でテストする性質を追加してください。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:141
msgid ""
"(Medium) Choose a pure function from the core libraries (for example, from "
"the `arrays` package), and write a QuickCheck property for it, including an "
"appropriate error message. Your property should use a helper function to fix "
"any polymorphic type arguments to either `Int` or `Boolean`."
msgstr ""
"（普通）標準関数から（例えば`arrays`パッケージから）1つ関数を選び、適切なエ"
"ラーメッセージを含めてQuickCheckの性質を書いてください。\n"
"その性質は、補助関数を使って多相型引数を `Int`か `Boolean`のどちらかに固定し"
"なければいけません。"

#. type: Title ##
#: text/chapter13.md:142
#, no-wrap
msgid "Generating Arbitrary Data"
msgstr "任意のデータの生成"

#. type: Plain text
#: text/chapter13.md:145
msgid ""
"Now we will see how the `quickcheck` library is able to randomly generate "
"test cases for our properties."
msgstr ""
"`quickcheck`ライブラリを使って性質に対するテスト項目を無作為に生成する方法に"
"ついて説明します。"

#. type: Plain text
#: text/chapter13.md:147
msgid ""
"Those types whose values can be randomly generated are captured by the "
"`Arbitrary` type class:"
msgstr ""
"無作為に値を生成できるような型は、次のような型クラス `Arbitary`のインスタンス"
"を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:148
#, no-wrap
msgid ""
"class Arbitrary t where\n"
"  arbitrary :: Gen t\n"
msgstr ""
"class Arbitrary t where\n"
"  arbitrary :: Gen t\n"

#. type: Plain text
#: text/chapter13.md:154
msgid ""
"The `Gen` type constructor represents the side-effects of _deterministic "
"random data generation_. It uses a pseudo-random number generator to "
"generate deterministic random function arguments from a seed value. The "
"`Test.QuickCheck.Gen` module defines several useful combinators for building "
"generators."
msgstr ""
"`Gen`型構築子は*決定的無作為データ生成*の副作用を表しています。\n"
"決定的無作為データ生成は、擬似乱数生成器を使って、シード値から決定的無作為関"
"数の引数を生成します。\n"
"`Test.QuickCheck.Gen`モジュールは、生成器を構築するための幾つかの有用なコンビ"
"ネータを定義しています。"

#. type: Plain text
#: text/chapter13.md:156
msgid ""
"`Gen` is also a monad and an applicative functor, so we have the usual "
"collection of combinators at our disposal for creating new instances of the "
"`Arbitrary` type class."
msgstr ""
"`Gen`はモナドでもアプリカティブ関手でもあるので、 `Arbitary`型クラスの新しい"
"インスタンスを作成するのに、いつも使っているようなコンビネータを自由に使うこ"
"とができます。"

#. type: Plain text
#: text/chapter13.md:158
msgid ""
"For example, we can use the `Arbitrary` instance for the `Int` type, "
"provided in the `quickcheck` library, to create a distribution on the 256 "
"byte values, using the `Functor` instance for `Gen` to map a function from "
"integers to bytes over arbitrary integer values:"
msgstr ""
"例えば、 `quickcheck`ライブラリで提供されている `Int`型用の `Arbitrary`インス"
"タンスを使い、256個のバイト値上の分布を作ることができます。\n"
"これには`Gen`用に`Functor`インスタンスを使って整数から任意の整数値のバイトま"
"でマップします。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:159
#, no-wrap
msgid ""
"newtype Byte = Byte Int\n"
"\n"
"instance arbitraryByte :: Arbitrary Byte where\n"
"  arbitrary = map intToByte arbitrary\n"
"    where\n"
"    intToByte n | n >= 0 = Byte (n `mod` 256)\n"
"                | otherwise = intToByte (-n)\n"
msgstr ""
"newtype Byte = Byte Int\n"
"\n"
"instance arbitraryByte :: Arbitrary Byte where\n"
"  arbitrary = map intToByte arbitrary\n"
"    where\n"
"    intToByte n | n >= 0 = Byte (n `mod` 256)\n"
"                | otherwise = intToByte (-n)\n"

#. type: Plain text
#: text/chapter13.md:170
msgid ""
"Here, we define a type `Byte` of integral values between 0 and 255. The "
"`Arbitrary` instance uses the `map` function to lift the `intToByte` "
"function over the `arbitrary` action. The type of the inner `arbitrary` "
"action is inferred as `Gen Int`."
msgstr ""
"ここでは、0から255までの間の整数値であるような型 `Byte`を定義しています。\n"
"`Arbitrary`インスタンスは `map`演算子を使って、 `intToByte`関数を `arbitrary`"
"アクションまで持ち上げています。\n"
"`arbitrary`アクション内部の型は `Gen Int`と推論されます。"

#. type: Plain text
#: text/chapter13.md:172
msgid "We can also use this idea to improve our test for `merge`:"
msgstr "この考え方を `merge`用のテストに使うこともできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:173
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"

#. type: Plain text
#: text/chapter13.md:179
msgid ""
"In this test, we generated arbitrary arrays `xs` and `ys`, but had to sort "
"them, since `merge` expects sorted input. On the other hand, we could create "
"a newtype representing sorted arrays, and write an `Arbitrary` instance "
"which generates sorted data:"
msgstr ""
"このテストでは、任意の配列 `xs`と `ys`を生成しますが、 `merge`は整列済みの入"
"力を期待しているので、 `xs`と `ys`を整列しておかなければなりません。\n"
"一方で、整列された配列を表すnewtypeを作成し、整列されたデータを生成する "
"`Arbitrary`インスタンスを書くこともできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:180
#, no-wrap
msgid ""
"newtype Sorted a = Sorted (Array a)\n"
"\n"
"sorted :: forall a. Sorted a -> Array a\n"
"sorted (Sorted xs) = xs\n"
"\n"
"instance arbSorted :: (Arbitrary a, Ord a) => Arbitrary (Sorted a) where\n"
"  arbitrary = map (Sorted <<< sort) arbitrary\n"
msgstr ""
"newtype Sorted a = Sorted (Array a)\n"
"\n"
"sorted :: forall a. Sorted a -> Array a\n"
"sorted (Sorted xs) = xs\n"
"\n"
"instance arbSorted :: (Arbitrary a, Ord a) => Arbitrary (Sorted a) where\n"
"  arbitrary = map (Sorted <<< sort) arbitrary\n"

#. type: Plain text
#: text/chapter13.md:191
msgid "With this type constructor, we can modify our test as follows:"
msgstr "この型構築子を使うと、テストを次のように変更できます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:192
#, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs <> sorted ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs <> sorted ys)\n"

#. type: Plain text
#: text/chapter13.md:198
msgid ""
"This may look like a small change, but the types of `xs` and `ys` have "
"changed to `Sorted Int`, instead of just `Array Int`. This communicates our "
"_intent_ in a clearer way - the `mergePoly` function takes sorted input. "
"Ideally, the type of the `mergePoly` function itself would be updated to use "
"the `Sorted` type constructor."
msgstr ""
"これは些細な変更に見えるかもしれませんが、 `xs`と `ys`の型はただの `Array "
"Int`から `Sorted Int`へと変更されています。\n"
"これにより、 `mergePoly`関数は整列済みの入力を取る、という*意図*を、わかりや"
"すく示すことができます。\n"
"理想的には、 `mergePoly`関数自体の型が `Sorted`型構築子を使うようにするといい"
"でしょう。"

#. type: Plain text
#: text/chapter13.md:200
msgid ""
"As a more interesting example, the `Tree` module defines a type of sorted "
"binary trees with values at the branches:"
msgstr ""
"より興味深い例として、 `Tree`モジュールでは枝の値で整列された二分木の型が定義"
"されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:201
#, no-wrap
msgid ""
"data Tree a\n"
"  = Leaf\n"
"  | Branch (Tree a) a (Tree a)\n"
msgstr ""
"data Tree a\n"
"  = Leaf\n"
"  | Branch (Tree a) a (Tree a)\n"

#. type: Plain text
#: text/chapter13.md:208
msgid "The `Tree` module defines the following API:"
msgstr "`Tree`モジュールでは次のAPIが定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:209
#, no-wrap
msgid ""
"insert    :: forall a. Ord a => a -> Tree a -> Tree a\n"
"member    :: forall a. Ord a => a -> Tree a -> Boolean\n"
"fromArray :: forall a. Ord a => Array a -> Tree a\n"
"toArray   :: forall a. Tree a -> Array a\n"
msgstr ""
"insert    :: forall a. Ord a => a -> Tree a -> Tree a\n"
"member    :: forall a. Ord a => a -> Tree a -> Boolean\n"
"fromArray :: forall a. Ord a => Array a -> Tree a\n"
"toArray   :: forall a. Tree a -> Array a\n"

#. type: Plain text
#: text/chapter13.md:217
msgid ""
"The `insert` function is used to insert a new element into a sorted tree, "
"and the `member` function can be used to query a tree for a particular "
"value. For example:"
msgstr ""
"`insert`関数は新しい要素を整列済みの二分木に挿入するのに使われ、 `member`関数"
"は特定の値の有無を木に問い合わせるのに使われます。\n"
"例えば次のようになります。"

#. type: Fenced code block (text)
#: text/chapter13.md:218
#, no-wrap
msgid ""
"> import Tree\n"
"\n"
"> member 2 $ insert 1 $ insert 2 Leaf\n"
"true\n"
"\n"
"> member 1 Leaf\n"
"false\n"
msgstr ""
"> import Tree\n"
"\n"
"> member 2 $ insert 1 $ insert 2 Leaf\n"
"true\n"
"\n"
"> member 1 Leaf\n"
"false\n"

#. type: Plain text
#: text/chapter13.md:229
msgid ""
"The `toArray` and `fromArray` functions can be used to convert sorted trees "
"to and from arrays. We can use `fromArray` to write an `Arbitrary` instance "
"for trees:"
msgstr ""
"`toArray`関数と `fromArray`関数は、整列された木と整列された配列を相互に変換す"
"るために使われます。\n"
"`fromArray`を使うと、木についての `Arbitrary`インスタンスを書くことができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:230
#, no-wrap
msgid ""
"instance arbTree :: (Arbitrary a, Ord a) => Arbitrary (Tree a) where\n"
"  arbitrary = map fromArray arbitrary\n"
msgstr ""
"instance arbTree :: (Arbitrary a, Ord a) => Arbitrary (Tree a) where\n"
"  arbitrary = map fromArray arbitrary\n"

#. type: Plain text
#: text/chapter13.md:236
msgid ""
"We can now use `Tree a` as the type of an argument to our test properties, "
"whenever there is an `Arbitrary` instance available for the type `a`. For "
"example, we can test that the `member` test always returns `true` after "
"inserting a value:"
msgstr ""
"型 `a`についての`Arbitary`インスタンスが使えるなら、テストする性質の引数の型"
"として `Tree a`を使うことができます。例えば、 `member`テストは値を挿入した後"
"は常に `true`を返すことをテストできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:237
#, no-wrap
msgid ""
"quickCheck \\t a ->\n"
"  member a $ insert a $ treeOfInt t\n"
msgstr ""
"quickCheck \\t a ->\n"
"  member a $ insert a $ treeOfInt t\n"

#. type: Plain text
#: text/chapter13.md:243
msgid ""
"Here, the argument `t` is a randomly-generated tree of type `Tree Int`, "
"where the type argument disambiguated by the identity function `treeOfInt`."
msgstr ""
"ここでは、引数 `t`は `Tree Number`型の無作為に生成された木です。\n"
"型引数は、同値関数 `treeOfInt`によって明確にされています。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:248
msgid ""
"(Medium) Create a newtype for `String` with an associated `Arbitrary` "
"instance which generates collections of randomly-selected characters in the "
"range `a-z`. _Hint_: use the `elements` and `arrayOf` functions from the "
"`Test.QuickCheck.Gen` module."
msgstr ""
"（普通）`a-z`の範囲から無作為に選ばれた文字の集まりを生成する `Arbitrary`イン"
"スタンスを持つ、`String`のnewtypeを作ってください。\n"
"*手掛かり*：`Test.QuickCheck.Gen`モジュールから `elements`と `arrayOf`関数を"
"使います。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:248
msgid ""
"(Difficult) Write a property which asserts that a value inserted into a tree "
"is still a member of that tree after arbitrarily many more insertions."
msgstr ""
"（難しい）木に挿入された値は、どれだけ挿入があった後でも、その木の構成要素で"
"あることを主張する性質を書いてください。"

#. type: Title ##
#: text/chapter13.md:249
#, no-wrap
msgid "Testing Higher-Order Functions"
msgstr "高階関数のテスト"

#. type: Plain text
#: text/chapter13.md:252
msgid ""
"The `Merge` module defines another generalization of the `merge` function - "
"the `mergeWith` function takes an additional function as an argument which "
"is used to determine the order in which elements should be merged. That is, "
"`mergeWith` is a higher-order function."
msgstr ""
"`Merge`モジュールは `merge`関数の別の一般化も定義しています。\n"
"`mergeWith`関数は追加の関数を引数として取り、統合される要素の順序を決定するの"
"に使われます。\n"
"つまり `mergeWith`は高階関数です。"

#. type: Plain text
#: text/chapter13.md:254
msgid ""
"For example, we can pass the `length` function as the first argument, to "
"merge two arrays which are already in length-increasing order. The result "
"should also be in length-increasing order:"
msgstr ""
"例えば`length`関数を最初の引数として渡し、既に長さの昇順になっている2つの配列"
"を統合できます。\n"
"このとき、結果も長さの昇順になっていなければなりません。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:255
#, no-wrap
msgid ""
"> import Data.String\n"
"\n"
"> mergeWith length\n"
"    [\"\", \"ab\", \"abcd\"]\n"
"    [\"x\", \"xyz\"]\n"
"\n"
"[\"\",\"x\",\"ab\",\"xyz\",\"abcd\"]\n"
msgstr ""
"> import Data.String\n"
"\n"
"> mergeWith length\n"
"    [\"\", \"ab\", \"abcd\"]\n"
"    [\"x\", \"xyz\"]\n"
"\n"
"[\"\",\"x\",\"ab\",\"xyz\",\"abcd\"]\n"

#. type: Plain text
#: text/chapter13.md:266
msgid ""
"How might we test such a function? Ideally, we would like to generate values "
"for all three arguments, including the first argument which is a function."
msgstr ""
"このような関数をテストするにはどうしたらいいでしょうか。\n"
"理想的には、関数である最初の引数を含めた、3つの引数全てについて、値を生成した"
"いと思うでしょう。"

#. type: Plain text
#: text/chapter13.md:268
msgid ""
"There is a second type class which allows us to create randomly-generated "
"functions. It is called `Coarbitrary`, and it is defined as follows:"
msgstr ""
"関数を無作為に生成できるようにする、もう1つの型クラスがあります。\n"
"この型クラスは `Coarbitrary`と呼ばれており、次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:269
#, no-wrap
msgid ""
"class Coarbitrary t where\n"
"  coarbitrary :: forall r. t -> Gen r -> Gen r\n"
msgstr ""
"class Coarbitrary t where\n"
"  coarbitrary :: forall r. t -> Gen r -> Gen r\n"

#. type: Plain text
#: text/chapter13.md:275
msgid ""
"The `coarbitrary` function takes a function argument of type `t`, and a "
"random generator for a function result of type `r`, and uses the function "
"argument to _perturb_ the random generator. That is, it uses the function "
"argument to modify the random output of the random generator for the result."
msgstr ""
"`coarbitrary`関数は、型 `t`と、関数の結果の型 `r`についての乱数生成器を関数の"
"引数としてとり、乱数生成器を _かき乱す_ のにこの引数を使います。つまり関数の"
"引数を使って、乱数生成器の無作為な出力を変更しているのです。"

#. type: Plain text
#: text/chapter13.md:277
msgid ""
"In addition, there is a type class instance which gives us `Arbitrary` "
"functions if the function domain is `Coarbitrary` and the function codomain "
"is `Arbitrary`:"
msgstr ""
"また、もし関数の定義域が `Coarbitrary`で、値域が `Arbitrary`なら、`Arbitrary`"
"の関数を与える型クラスインスタンスが存在します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:278
#, no-wrap
msgid "instance arbFunction :: (Coarbitrary a, Arbitrary b) => Arbitrary (a -> b)\n"
msgstr "instance arbFunction :: (Coarbitrary a, Arbitrary b) => Arbitrary (a -> b)\n"

#. type: Plain text
#: text/chapter13.md:283
msgid ""
"In practice, this means that we can write properties which take functions as "
"arguments. In the case of the `mergeWith` function, we can generate the "
"first argument randomly, modifying our tests to take account of the new "
"argument."
msgstr ""
"実は、これが意味しているのは、引数として関数を取るような性質を記述できるとい"
"うことです。 `mergeWith`関数の場合では、新しい引数を考慮するようにテストを修"
"正すると、最初の引数を無作為に生成できます。"

#. type: Plain text
#: text/chapter13.md:285
msgid ""
"We cannot guarantee that the result will be sorted - we do not even "
"necessarily have an `Ord` instance - but we can expect that the result be "
"sorted with respect to the function `f` that we pass in as an argument. In "
"addition, we need the two input arrays to be sorted with respect to `f`, so "
"we use the `sortBy` function to sort `xs` and `ys` based on comparison after "
"the function `f` has been applied:"
msgstr ""
"結果が整列されていることは保証できません。\n"
"必ずしも`Ord`インスタンスを持っているとさえ限らないのです。\n"
"しかし、引数として渡す関数 `f`に従って結果が整列されていることは期待されま"
"す。\n"
"更に、2つの入力配列が `f`に従って整列されている必要がありますので、`sortBy`関"
"数を使って関数 `f`が適用されたあとの比較に基づいて `xs`と`ys`を整列します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:286
#, no-wrap
msgid ""
"quickCheck \\xs ys f ->\n"
"  let\n"
"    result =\n"
"      map f $\n"
"        mergeWith (intToBool f)\n"
"                  (sortBy (compare `on` f) xs)\n"
"                  (sortBy (compare `on` f) ys)\n"
"    expected =\n"
"      map f $\n"
"        sortBy (compare `on` f) $ xs <> ys\n"
"  in\n"
"    eq result expected\n"
msgstr ""
"quickCheck \\xs ys f ->\n"
"  let\n"
"    result =\n"
"      map f $\n"
"        mergeWith (intToBool f)\n"
"                  (sortBy (compare `on` f) xs)\n"
"                  (sortBy (compare `on` f) ys)\n"
"    expected =\n"
"      map f $\n"
"        sortBy (compare `on` f) $ xs <> ys\n"
"  in\n"
"    eq result expected\n"

#. type: Plain text
#: text/chapter13.md:302
msgid ""
"Here, we use a function `intToBool` to disambiguate the type of the function "
"`f`:"
msgstr ""
"ここでは、関数 `f`の型を明確にするために、関数 `intToBool`を使用しています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:303
#, no-wrap
msgid ""
"intToBool :: (Int -> Boolean) -> Int -> Boolean\n"
"intToBool = id\n"
msgstr ""
"intToBool :: (Int -> Boolean) -> Int -> Boolean\n"
"intToBool = id\n"

#. type: Plain text
#: text/chapter13.md:309
msgid "In addition to being `Arbitrary`, functions are also `Coarbitrary`:"
msgstr "関数は `Arbitrary`であるだけでなく `Coarbitrary`でもあります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:310
#, no-wrap
msgid "instance coarbFunction :: (Arbitrary a, Coarbitrary b) => Coarbitrary (a -> b)\n"
msgstr "instance coarbFunction :: (Arbitrary a, Coarbitrary b) => Coarbitrary (a -> b)\n"

#. type: Plain text
#: text/chapter13.md:315
msgid ""
"This means that we are not limited to just values and functions - we can "
"also randomly generate _higher-order functions_, or functions whose "
"arguments are higher-order functions, and so on."
msgstr ""
"これは値の生成が単純な関数だけに限定されるものではないことを意味していま"
"す。\n"
"つまり*高階関数*や、引数が高階関数であるような関数もまた、無作為に生成できる"
"のです。"

#. type: Title ##
#: text/chapter13.md:316
#, no-wrap
msgid "Writing Coarbitrary Instances"
msgstr "Coarbitraryのインスタンスを書く"

#. type: Plain text
#: text/chapter13.md:319
msgid ""
"Just as we can write `Arbitrary` instances for our data types by using the "
"`Monad` and `Applicative` instances of `Gen`, we can write our own "
"`Coarbitrary` instances as well. This allows us to use our own data types as "
"the domain of randomly-generated functions."
msgstr ""
"`Gen`の `Monad`や `Applicative`インスタンスを使って独自のデータ型に対して "
"`Arbitrary`インスタンスを書くことができるのとちょうど同じように、独自の "
"`Coarbitrary`インスタンスを書くこともできます。\n"
"これにより、無作為に生成される関数の定義域として、独自のデータ型を使うことが"
"できるようになります。"

#. type: Plain text
#: text/chapter13.md:321
msgid ""
"Let's write a `Coarbitrary` instance for our `Tree` type. We will need a "
"`Coarbitrary` instance for the type of the elements stored in the branches:"
msgstr ""
"`Tree`型の `Coarbitrary`インスタンスを書いてみましょう。\n"
"枝に格納されている要素の型に `Coarbitrary`インスタンスが必要になります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:322
#, no-wrap
msgid "instance coarbTree :: Coarbitrary a => Coarbitrary (Tree a) where\n"
msgstr "instance coarbTree :: Coarbitrary a => Coarbitrary (Tree a) where\n"

#. type: Plain text
#: text/chapter13.md:327
msgid ""
"We have to write a function which perturbs a random generator given a value "
"of type `Tree a`. If the input value is a `Leaf`, then we will just return "
"the generator unchanged:"
msgstr ""
"型 `Tree a`の値が与えられたときに、乱数発生器をかき乱す関数を記述する必要があ"
"ります。\n"
"入力値が `Leaf`であれば、そのままにしておく生成器を返します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:328
#, no-wrap
msgid "  coarbitrary Leaf = id\n"
msgstr "  coarbitrary Leaf = id\n"

#. type: Plain text
#: text/chapter13.md:333
msgid ""
"If the tree is a `Branch`, then we will perturb the generator using the left "
"subtree, the value, and the right subtree. We use function composition to "
"create our perturbing function:"
msgstr ""
"もし木が `Branch`なら、左の部分木、値、右の部分木を使って生成器をかき乱しま"
"す。\n"
"関数合成を使って独自のかき乱し関数を作ります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:334
#, no-wrap
msgid ""
"  coarbitrary (Branch l a r) =\n"
"    coarbitrary l <<<\n"
"    coarbitrary a <<<\n"
"    coarbitrary r\n"
msgstr ""
"  coarbitrary (Branch l a r) =\n"
"    coarbitrary l <<<\n"
"    coarbitrary a <<<\n"
"    coarbitrary r\n"

#. type: Plain text
#: text/chapter13.md:342
msgid ""
"Now we are free to write properties whose arguments include functions taking "
"trees as arguments. For example, the `Tree` module defines a function "
"`anywhere`, which tests if a predicate holds on any subtree of its argument:"
msgstr ""
"これで、木を引数にとるような関数を引数に含む性質を自由に書くことができるよう"
"になりました。\n"
"例えば`Tree`モジュールでは`anywhere`が定義されており、これは述語が引数のどん"
"な部分木についても成り立っているかを調べる関数です。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:343
#, no-wrap
msgid "anywhere :: forall a. (Tree a -> Boolean) -> Tree a -> Boolean\n"
msgstr "anywhere :: forall a. (Tree a -> Boolean) -> Tree a -> Boolean\n"

#. type: Plain text
#: text/chapter13.md:348
msgid ""
"Now we are able to generate the predicate function randomly. For example, we "
"expect the `anywhere` function to _respect disjunction_:"
msgstr ""
"これで、この述語関数`anywhere`を無作為に生成できるようになりました。\n"
"例えば、 `anywhere`関数は*ある命題のもとで不変*であることが期待されます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:349
#, no-wrap
msgid ""
"quickCheck \\f g t ->\n"
"  anywhere (\\s -> f s || g s) t ==\n"
"    anywhere f (treeOfInt t) || anywhere g t\n"
msgstr ""
"quickCheck \\f g t ->\n"
"  anywhere (\\s -> f s || g s) t ==\n"
"    anywhere f (treeOfInt t) || anywhere g t\n"

#. type: Plain text
#: text/chapter13.md:356
msgid ""
"Here, the `treeOfInt` function is used to fix the type of values contained "
"in the tree to the type `Int`:"
msgstr ""
"ここで、 `treeOfInt`関数は木に含まれる値の型を型 `Int`に固定するために使われ"
"ています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:357
#, no-wrap
msgid ""
"treeOfInt :: Tree Int -> Tree Int\n"
"treeOfInt = id\n"
msgstr ""
"treeOfInt :: Tree Int -> Tree Int\n"
"treeOfInt = id\n"

#. type: Title ##
#: text/chapter13.md:362
#, no-wrap
msgid "Testing Without Side-Effects"
msgstr "副作用のないテスト"

#. type: Plain text
#: text/chapter13.md:365
msgid ""
"For the purposes of testing, we usually include calls to the `quickCheck` "
"function in the `main` action of our test suite. However, there is a variant "
"of the `quickCheck` function, called `quickCheckPure` which does not use "
"side-effects. Instead, it is a pure function which takes a random seed as an "
"input, and returns an array of test results."
msgstr ""
"通常、テストの目的ではテストスイートの `main`アクションに`quickCheck`関数の呼"
"び出しが含まれています。\n"
"しかし、副作用を使わない`quickCheckPure`と呼ばれる `quickCheck`関数の亜種もあ"
"ります。\n"
"`quickCheckPure`は、入力として乱数の種をとり、テスト結果の配列を返す純粋な関"
"数です。"

#. type: Plain text
#: text/chapter13.md:367
msgid ""
"We can test `quickCheckPure` using PSCi. Here, we test that the `merge` "
"operation is associative:"
msgstr ""
"PSCiを使用して `quickCheckPure`を試せます。\n"
"ここでは `merge`操作が結合法則を満たすことをテストします。"

#. type: Fenced code block (text)
#: text/chapter13.md:368
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Merge\n"
"> import Test.QuickCheck\n"
"> import Test.QuickCheck.LCG (mkSeed)\n"
"\n"
"> :paste\n"
"… quickCheckPure (mkSeed 12345) 10 \\xs ys zs ->\n"
"…   ((xs `merge` ys) `merge` zs) ==\n"
"…     (xs `merge` (ys `merge` zs))\n"
"… ^D\n"
"\n"
"Success : Success : ...\n"
msgstr ""
"> import Prelude\n"
"> import Merge\n"
"> import Test.QuickCheck\n"
"> import Test.QuickCheck.LCG (mkSeed)\n"
"\n"
"> :paste\n"
"… quickCheckPure (mkSeed 12345) 10 \\xs ys zs ->\n"
"…   ((xs `merge` ys) `merge` zs) ==\n"
"…     (xs `merge` (ys `merge` zs))\n"
"… ^D\n"
"\n"
"Success : Success : ...\n"

#. type: Plain text
#: text/chapter13.md:384
msgid ""
"`quickCheckPure` takes three arguments: the random seed, the number of test "
"cases to generate, and the property to test. If all tests pass, you should "
"see an array of `Success` data constructors printed to the console."
msgstr ""
"`quickCheckPure`は乱数の種、生成するテスト項目数、テストする性質の3つの引数を"
"とります。\n"
"もし全てのテスト項目が成功したら、`Success`データ構築子の配列がコンソールに出"
"力されます。"

#. type: Plain text
#: text/chapter13.md:386
msgid ""
"`quickCheckPure` might be useful in other situations, such as generating "
"random input data for performance benchmarks, or generating sample form data "
"for web applications."
msgstr ""
"`quickCheckPure`は、性能ベンチマークの入力データ生成や、webアプリケーションの"
"フォームデータ例を無作為に生成するというような状況で便利かもしれません。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
msgid ""
"(Easy) Write `Coarbitrary` instances for the `Byte` and `Sorted` type "
"constructors."
msgstr ""
"（簡単）`Byte`と `Sorted`型構築子についての `Coarbitrary`インスタンスを書いて"
"ください。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
msgid ""
"(Medium) Write a (higher-order) property which asserts associativity of the "
"`mergeWith f` function for any function `f`. Test your property in PSCi "
"using `quickCheckPure`."
msgstr ""
"（普通）任意の関数 `f`について、 `mergeWith f`関数の結合性を主張する（高階）"
"性質を書いてください。 `quickCheckPure`を使ってPSCiでその性質をテストしてくだ"
"さい。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
msgid ""
"(Medium) Write `Arbitrary` and `Coarbitrary` instances for the following "
"data type:"
msgstr ""
"（普通）次のデータ型の`Arbitrary`と`Coarbitrary`インスタンスを書いてくださ"
"い。"

#. type: Plain text
#: text/chapter13.md:396
#, no-wrap
msgid ""
"     ```haskell\n"
"     data OneTwoThree a = One a | Two a a | Three a a a\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data OneTwoThree a = One a | Two a a | Three a a a\n"
"     ```\n"

#. type: Plain text
#: text/chapter13.md:400
#, no-wrap
msgid ""
"     _Hint_: Use the `oneOf` function defined in `Test.QuickCheck.Gen` to define your `Arbitrary` instance.\n"
" 1. (Medium) Use `all` to simplify the result of the `quickCheckPure` function - your new function should have type `List Result -> Boolean` and should return `true` if every test passes and `false` otherwise.\n"
" 1. (Medium) As another approach to simplifying the result of `quickCheckPure`, try writing a function `squashResults :: List Result -> Result`. Consider using the `First` monoid from `Data.Maybe.First` with the `foldMap` function to preserve the first error in case of failure.\n"
msgstr ""
"     *手掛かり*：`Test.QuickCheck.Gen`で定義された `oneOf`関数を使って `Arbitrary`インスタンスを定義してください。\n"
" 1. （普通）`all`を使って `quickCheckPure`関数の結果を単純化してください。\n"
"    この新しい関数は型`List Result -> Boolean`を持ち、全てのテストが通れば`true`を、そうでなければ`false`を返します。\n"
" 2. （普通）`quickCheckPure`の結果を単純にする別の手法として、関数`squashResults :: List Result -> Result`を書いてみてください。\n"
"    `Data.Maybe.First`の`First`モノイドと共に`foldMap`関数を使うことで、失敗した場合の最初のエラーを保存することを検討してください。\n"

#. type: Plain text
#: text/chapter13.md:404
msgid ""
"In this chapter, we met the `quickcheck` package, which can be used to write "
"tests in a declarative way using the paradigm of _generative testing_. In "
"particular:"
msgstr ""
"この章では`quickcheck`パッケージに出会いました。\n"
"これを使うと*生成的テスティング*のパラダイムを使って、宣言的な方法でテストを"
"書くことができました。具体的には以下です。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid "We saw how to automate QuickCheck tests using `spago test`."
msgstr "`spago test`を使ってQuickCheckのテストを自動化する方法を見ました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid ""
"We saw how to write properties as functions, and how to use the `<?>` "
"operator to improve error messages."
msgstr ""
"性質を関数として書く方法とエラーメッセージを改良する `<?>`演算子の使い方を説"
"明しました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid ""
"We saw how the `Arbitrary` and `Coarbitrary` type classes enable generation "
"of boilerplate testing code, and how they allow us to test higher-order "
"properties."
msgstr ""
"`Arbitrary`と `Coarbitrary`型クラスによって、如何にして定型的なテストコードの"
"自動生成を可能にし、またどうすれば高階な性質関数が可能になるかを見てきまし"
"た。"

#. type: Bullet: '- '
#: text/chapter13.md:408
msgid ""
"We saw how to implement custom `Arbitrary` and `Coarbitrary` instances for "
"our own data types."
msgstr ""
"独自のデータ型に対して `Arbitrary`と `Coarbitrary`インスタンスを実装する方法"
"を見ました。"

#. type: Title #
#: text/chapter14.md:1
#, no-wrap
msgid "Domain-Specific Languages"
msgstr "領域特化言語"

#. type: Plain text
#: text/chapter14.md:6
msgid ""
"In this chapter, we will explore the implementation of _domain-specific "
"languages_ (or _DSLs_) in PureScript, using a number of standard techniques."
msgstr ""
"この章では多数の標準的な手法を使い、PureScriptにおける*領域特化言語*（または"
"*DSL*）の実装について探求していきます。"

#. type: Plain text
#: text/chapter14.md:8
msgid ""
"A domain-specific language is a language which is well-suited to development "
"in a particular problem domain. Its syntax and functions are chosen to "
"maximize readability of code used to express ideas in that domain. We have "
"already seen a number of examples of domain-specific languages in this book:"
msgstr ""
"領域特化言語とは、特定の問題領域での開発に適した言語のことです。\n"
"領域特化言語の構文及び機能は、その領域内の考え方を表現するコードの読みやすさ"
"を最大限に発揮すべく選択されます。\n"
"本書の中では、既に領域特化言語の例を幾つか見てきています。"

#. type: Bullet: '- '
#: text/chapter14.md:11
msgid ""
"The `Game` monad and its associated actions, developed in chapter 11, "
"constitute a domain-specific language for the domain of _text adventure game "
"development_."
msgstr ""
"第11章で開発された `Game`モナドと関連するアクションは、 _テキストアドベン"
"チャーゲーム開発_ という領域に対しての領域特化言語を構成しています。"

#. type: Bullet: '- '
#: text/chapter14.md:11
msgid ""
"The `quickcheck` package, covered in chapter 13, is a domain-specific "
"language for the domain of _generative testing_. Its combinators enable a "
"particularly expressive notation for test properties."
msgstr ""
"第13章で扱った `quickcheck`パッケージは、 _生成的テスティング_ の領域の領域特"
"化言語です。このコンビネータはテストの性質に対して特に表現力の高い記法を可能"
"にします。"

#. type: Plain text
#: text/chapter14.md:13
msgid ""
"This chapter will take a more structured approach to some of standard "
"techniques in the implementation of domain-specific languages. It is by no "
"means a complete exposition of the subject, but should provide you with "
"enough knowledge to build some practical DSLs for your own tasks."
msgstr ""
"この章では、領域特化言語の実装において、幾つかの標準的な技法による構造的な手"
"法に迫ります。\n"
"これがこの話題の完全な説明だということでは決してありませんが、自分の目的に合"
"う具体的なDSLを構築するのには充分な知識をもたらすことでしょう。"

#. type: Plain text
#: text/chapter14.md:15
msgid ""
"Our running example will be a domain-specific language for creating HTML "
"documents. Our aim will be to develop a type-safe language for describing "
"correct HTML documents, and we will work by improving a naive implementation "
"in small steps."
msgstr ""
"この章で実行している例は、HTML文書を作成するための領域特化言語です。\n"
"正しいHTML文書を記述するための型安全な言語を開発することが目的で、素朴な実装"
"を徐々に改善しつつ進めていきます。"

#. type: Plain text
#: text/chapter14.md:19
msgid ""
"The project accompanying this chapter adds one new dependency - the `free` "
"library, which defines the _free monad_, one of the tools which we will be "
"using."
msgstr ""
"この章で使うプロジェクトには新しい依存性が1つ追加されます。これから使う道具の"
"1つである*Freeモナド*が定義されている `free`ライブラリです。"

#. type: Plain text
#: text/chapter14.md:21
msgid "We will test this chapter's project in PSCi."
msgstr "このプロジェクトをPSCiを使って試していきます。"

#. type: Title ##
#: text/chapter14.md:22
#, no-wrap
msgid "A HTML Data Type"
msgstr "HTMLデータ型"

#. type: Plain text
#: text/chapter14.md:25
msgid ""
"The most basic version of our HTML library is defined in the `Data.DOM."
"Simple` module. The module contains the following type definitions:"
msgstr ""
"このHTMLライブラリの最も基本的なバージョンは `Data.DOM.Simple`モジュールで定"
"義されています。このモジュールには次の型定義が含まれています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:26
#, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Array Content)\n"
"  }\n"
"\n"
"data Content\n"
"  = TextContent String\n"
"  | ElementContent Element\n"
"\n"
"newtype Attribute = Attribute\n"
"  { key          :: String\n"
"  , value        :: String\n"
"  }\n"
msgstr ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Array Content)\n"
"  }\n"
"\n"
"data Content\n"
"  = TextContent String\n"
"  | ElementContent Element\n"
"\n"
"newtype Attribute = Attribute\n"
"  { key          :: String\n"
"  , value        :: String\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:44
msgid ""
"The `Element` type represents HTML elements. Each element consists of an "
"element name, an array of attribute pairs and some content. The content "
"property uses the `Maybe` type to indicate that an element might be open "
"(containing other elements and text) or closed."
msgstr ""
"`Element`型はHTMLの要素を表しています。\n"
"各要素は要素名、属性の対の配列と、要素の内容で構成されています。\n"
"contentプロパティは、`Maybe`タイプを適切に使って、要素が開いている（他の要素"
"やテキストを含む）か閉じているかを示しています。"

#. type: Plain text
#: text/chapter14.md:46
msgid "The key function of our library is a function"
msgstr "このライブラリの鍵となる機能は次の関数です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:47
#, no-wrap
msgid "render :: Element -> String\n"
msgstr "render :: Element -> String\n"

#. type: Plain text
#: text/chapter14.md:52
msgid ""
"which renders HTML elements as HTML strings. We can try out this version of "
"the library by constructing values of the appropriate types explicitly in "
"PSCi:"
msgstr ""
"この関数はHTML要素をHTML文字列として出力します。\n"
"PSCiで明示的に適当な型の値を構築し、ライブラリのこのバージョンを試してみま"
"しょう。"

#. type: Fenced code block (text)
#: text/chapter14.md:53
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Simple\n"
"> import Data.Maybe\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ Element\n"
"…   { name: \"p\"\n"
"…   , attribs: [\n"
"…       Attribute\n"
"…         { key: \"class\"\n"
"…         , value: \"main\"\n"
"…         }\n"
"…     ]\n"
"…   , content: Just [\n"
"…       TextContent \"Hello World!\"\n"
"…     ]\n"
"…   }\n"
"… ^D\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Simple\n"
"> import Data.Maybe\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ Element\n"
"…   { name: \"p\"\n"
"…   , attribs: [\n"
"…       Attribute\n"
"…         { key: \"class\"\n"
"…         , value: \"main\"\n"
"…         }\n"
"…     ]\n"
"…   , content: Just [\n"
"…       TextContent \"Hello World!\"\n"
"…     ]\n"
"…   }\n"
"… ^D\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:81
msgid "As it stands, there are several problems with this library:"
msgstr "現状のライブラリには幾つもの問題があります。"

#. type: Bullet: '- '
#: text/chapter14.md:87
msgid ""
"Creating HTML documents is difficult - every new element requires at least "
"one record and one data constructor."
msgstr ""
"HTML文書の作成に手がかかります。\n"
"全ての新しい要素に少なくとも1つのレコードと1つのデータ構築子が必要です。"

#. type: Bullet: '- '
#: text/chapter14.md:87
msgid "It is possible to represent invalid documents:"
msgstr "無効な文書を表現できてしまいます。"

#. type: Bullet: '  - '
#: text/chapter14.md:87
msgid "The developer might mistype the element name"
msgstr "開発者が要素名の入力を間違えるかもしれません"

#. type: Bullet: '  - '
#: text/chapter14.md:87
msgid "The developer can associate an attribute with the wrong type of element"
msgstr "開発者が属性を間違った要素に関連付けることができてしまいます"

#. type: Bullet: '  - '
#: text/chapter14.md:87
msgid "The developer can use a closed element when an open element is correct"
msgstr "開いた要素が正しい場合に開発者が閉じた要素を使えてしまいます"

#. type: Plain text
#: text/chapter14.md:89
msgid ""
"In the remainder of the chapter, we will apply certain techniques to solve "
"these problems and turn our library into a usable domain-specific language "
"for creating HTML documents."
msgstr ""
"残りの章ではとある手法を用いてこれらの問題を解決し、このライブラリーをHTML文"
"書を作成するために使える領域特化言語にしていきます。"

#. type: Title ##
#: text/chapter14.md:90
#, no-wrap
msgid "Smart Constructors"
msgstr "スマート構築子"

#. type: Plain text
#: text/chapter14.md:93
msgid ""
"The first technique we will apply is simple but can be very effective. "
"Instead of exposing the representation of the data to the module's users, we "
"can use the module exports list to hide the `Element`, `Content` and "
"`Attribute` data constructors, and only export so-called _smart "
"constructors_, which construct data which is known to be correct."
msgstr ""
"最初に導入する手法は方法こそ単純なものですが、とても効果的です。\n"
"モジュールの使用者にデータの表現を露出する代わりに、モジュールエクスポートリ"
"ストを使ってデータ構築子 `Element`、 `Content`、 `Attribute`を隠蔽し、正しい"
"ことが明らかなデータだけ構築する、いわゆる*スマート構築子*だけをエクスポート"
"します。"

#. type: Plain text
#: text/chapter14.md:95
msgid ""
"Here is an example. First, we provide a convenience function for creating "
"HTML elements:"
msgstr ""
"例を示しましょう。まず、HTML要素を作成するための便利な関数を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:96
#, no-wrap
msgid ""
"element :: String -> Array Attribute -> Maybe (Array Content) -> Element\n"
"element name attribs content = Element\n"
"  { name:      name\n"
"  , attribs:   attribs\n"
"  , content:   content\n"
"  }\n"
msgstr ""
"element :: String -> Array Attribute -> Maybe (Array Content) -> Element\n"
"element name attribs content = Element\n"
"  { name:      name\n"
"  , attribs:   attribs\n"
"  , content:   content\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:106
msgid ""
"Next, we create smart constructors for those HTML elements we want our users "
"to be able to create, by applying the `element` function:"
msgstr ""
"次に、欲しいHTML要素を利用者が作れるように、スマート構築子を作成します。\n"
"これには`element`関数を適用します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:107
#, no-wrap
msgid ""
"a :: Array Attribute -> Array Content -> Element\n"
"a attribs content = element \"a\" attribs (Just content)\n"
"\n"
"p :: Array Attribute -> Array Content -> Element\n"
"p attribs content = element \"p\" attribs (Just content)\n"
"\n"
"img :: Array Attribute -> Element\n"
"img attribs = element \"img\" attribs Nothing\n"
msgstr ""
"a :: Array Attribute -> Array Content -> Element\n"
"a attribs content = element \"a\" attribs (Just content)\n"
"\n"
"p :: Array Attribute -> Array Content -> Element\n"
"p attribs content = element \"p\" attribs (Just content)\n"
"\n"
"img :: Array Attribute -> Element\n"
"img attribs = element \"img\" attribs Nothing\n"

#. type: Plain text
#: text/chapter14.md:119
msgid ""
"Finally, we update the module exports list to only export those functions "
"which are known to construct correct data structures:"
msgstr ""
"最後に、正しいデータ構造だけが構築されることがわかっているこれらの関数をエク"
"スポートするように、モジュールエクスポートリストを更新します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:120
#, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute(..)\n"
"  , Content(..)\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute(..)\n"
"  , Content(..)\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , render\n"
"  ) where\n"

#. type: Plain text
#: text/chapter14.md:135
msgid ""
"The module exports list is provided immediately after the module name inside "
"parentheses. Each module export can be one of three types:"
msgstr ""
"モジュールエクスポートリストはモジュール名の直後の括弧内に書きます。\n"
"各モジュールのエクスポートは次の3種類の何れかになります。"

#. type: Bullet: '- '
#: text/chapter14.md:139
msgid "A value (or function), indicated by the name of the value,"
msgstr "値（ないし関数）。その値の名前により指定されます。"

#. type: Bullet: '- '
#: text/chapter14.md:139
msgid "A type class, indicated by the name of the class,"
msgstr "型クラス。クラス名により指定されます。"

#. type: Bullet: '- '
#: text/chapter14.md:139
msgid ""
"A type constructor and any associated data constructors, indicated by the "
"name of the type followed by a parenthesized list of exported data "
"constructors."
msgstr ""
"型構築子と関連するデータ構築子。型名とそれに続くエクスポートされるデータ構築"
"子の括弧で囲まれたリストで指定されます。"

#. type: Plain text
#: text/chapter14.md:141
msgid ""
"Here, we export the `Element` _type_, but we do not export its data "
"constructors. If we did, the user would be able to construct invalid HTML "
"elements."
msgstr ""
"ここでは、 `Element`の*型*をエクスポートしていますが、データ構築子はエクス"
"ポートしていません。\n"
"もしデータ構築子をエクスポートすると、モジュールの使用者が不正なHTML要素を構"
"築できてしまいます。"

#. type: Plain text
#: text/chapter14.md:143
msgid ""
"In the case of the `Attribute` and `Content` types, we still export all of "
"the data constructors (indicated by the symbol `..` in the exports list). We "
"will apply the technique of smart constructors to these types shortly."
msgstr ""
"`Attribute`と `Content`型についてはデータ構築子を全てエクスポートしています"
"（エクスポートリストの記号 `..`で示されています）。\n"
"すぐ後で、これらの型にもスマート構築子の手法を適用していきます。"

#. type: Plain text
#: text/chapter14.md:145
msgid "Notice that we have already made some big improvements to our library:"
msgstr "既にライブラリに幾つもの大きな改良が加わっていることに注目です。"

#. type: Bullet: '- '
#: text/chapter14.md:148
msgid ""
"It is impossible to represent HTML elements with invalid names (of course, "
"we are restricted to the set of element names provided by the library)."
msgstr ""
"不正な名前を持つHTML要素は表現できません（もちろん、ライブラリが提供する要素"
"名に制限されています）。"

#. type: Bullet: '- '
#: text/chapter14.md:148
msgid "Closed elements cannot contain content by construction."
msgstr "閉じた要素は構築するときに内容を含められません。"

#. type: Plain text
#: text/chapter14.md:150
msgid ""
"We can apply this technique to the `Content` type very easily. We simply "
"remove the data constructors for the `Content` type from the exports list, "
"and provide the following smart constructors:"
msgstr ""
"`Content`型にとても簡単にこの手法を適用できます。\n"
"単にエクスポートリストから `Content`型のデータ構築子を取り除き、次のスマート"
"構築子を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:151
#, no-wrap
msgid ""
"text :: String -> Content\n"
"text = TextContent\n"
"\n"
"elem :: Element -> Content\n"
"elem = ElementContent\n"
msgstr ""
"text :: String -> Content\n"
"text = TextContent\n"
"\n"
"elem :: Element -> Content\n"
"elem = ElementContent\n"

#. type: Plain text
#: text/chapter14.md:160
msgid ""
"Let's apply the same technique to the `Attribute` type. First, we provide a "
"general-purpose smart constructor for attributes. Here is a first attempt:"
msgstr ""
"`Attribute`型にも同じ手法を適用してみましょう。\n"
"まず、属性のための汎用のスマート構築子を用意します。\n"
"以下は最初の試行です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:161
#, no-wrap
msgid ""
"attribute :: String -> String -> Attribute\n"
"attribute key value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
"\n"
"infix 4 attribute as :=\n"
msgstr ""
"attribute :: String -> String -> Attribute\n"
"attribute key value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
"\n"
"infix 4 attribute as :=\n"

#. type: Plain text
#: text/chapter14.md:172
msgid ""
"This representation suffers from the same problem as the original `Element` "
"type - it is possible to represent attributes which do not exist or whose "
"names were entered incorrectly. To solve this problem, we can create a "
"newtype which represents attribute names:"
msgstr ""
"この定義では元の `Element`型と同じ問題に直面しています。\n"
"存在しなかったり、名前が間違っているような属性を表現できます。\n"
"この問題を解決するために、属性名を表すnewtypeを作成します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:173
#, no-wrap
msgid "newtype AttributeKey = AttributeKey String\n"
msgstr "newtype AttributeKey = AttributeKey String\n"

#. type: Plain text
#: text/chapter14.md:178
msgid "With that, we can modify our operator as follows:"
msgstr "これを使えば演算子を次のように変更できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:179
#, no-wrap
msgid ""
"attribute :: AttributeKey -> String -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
msgstr ""
"attribute :: AttributeKey -> String -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:188
msgid ""
"If we do not export the `AttributeKey` data constructor, then the user has "
"no way to construct values of type `AttributeKey` other than by using "
"functions we explicitly export. Here are some examples:"
msgstr ""
"`AttributeKey`データ構築子をエクスポートしなければ、明示的にエクスポートされ"
"た次のような関数を使う以外に、使用者が型 `AttributeKey`の値を構築する方法はあ"
"りません。\n"
"以下に幾つかの例を示します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:189
#, no-wrap
msgid ""
"href :: AttributeKey\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey\n"
"height = AttributeKey \"height\"\n"
msgstr ""
"href :: AttributeKey\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey\n"
"height = AttributeKey \"height\"\n"

#. type: Plain text
#: text/chapter14.md:207
msgid ""
"Here is the final exports list for our new module. Note that we no longer "
"export any data constructors directly:"
msgstr ""
"新しいモジュールの最終的なエクスポートリストは次のようになります。\n"
"最早どのデータ構築子も直接エクスポートしていない点に注目です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:208
#, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute\n"
"  , Content\n"
"  , AttributeKey\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , href\n"
"  , _class\n"
"  , src\n"
"  , width\n"
"  , height\n"
"\n"
"  , attribute, (:=)\n"
"  , text\n"
"  , elem\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute\n"
"  , Content\n"
"  , AttributeKey\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , href\n"
"  , _class\n"
"  , src\n"
"  , width\n"
"  , height\n"
"\n"
"  , attribute, (:=)\n"
"  , text\n"
"  , elem\n"
"\n"
"  , render\n"
"  ) where\n"

#. type: Plain text
#: text/chapter14.md:234
msgid ""
"If we try this new module in PSCi, we can already see massive improvements "
"in the conciseness of the user code:"
msgstr ""
"PSCiでこの新しいモジュールを試してみると、既にコードの簡潔さにおいて大幅な向"
"上が見て取れます。"

#. type: Fenced code block (text)
#: text/chapter14.md:235
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Smart\n"
"> import Effect.Console\n"
"> log $ render $ p [ _class := \"main\" ] [ text \"Hello World!\" ]\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Smart\n"
"> import Effect.Console\n"
"> log $ render $ p [ _class := \"main\" ] [ text \"Hello World!\" ]\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:248
msgid ""
"Note, however, that no changes had to be made to the `render` function, "
"because the underlying data representation never changed. This is one of the "
"benefits of the smart constructors approach - it allows us to separate the "
"internal data representation for a module from the representation which is "
"perceived by users of its external API."
msgstr ""
"しかし、基盤をなすデータ表現は変更されなかったので、 `render`関数を変更する必"
"要はなかったことにも注目してください。\n"
"これはスマート構築子による手法の利点のひとつです。\n"
"外部APIの使用者によって認識される表現からモジュールの内部データ表現を分離でき"
"るのです。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:253
msgid ""
"(Easy) Use the `Data.DOM.Smart` module to experiment by creating new HTML "
"documents using `render`."
msgstr ""
"（簡単）`Data.DOM.Smart`モジュールで `render`を使った新しいHTML文書の作成を試"
"してみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:253
msgid ""
"(Medium) Some HTML attributes such as `checked` and `disabled` do not "
"require values, and may be rendered as _empty attributes_:"
msgstr ""
"（普通）`checked`と `disabled`など、値を要求しないHTML属性がありますが、これ"
"らは次のような _空の属性_ として表示されるかもしれません。"

#. type: Plain text
#: text/chapter14.md:257
#, no-wrap
msgid ""
"     ```html\n"
"     <input disabled>\n"
"     ```\n"
msgstr ""
"     ```html\n"
"     <input disabled>\n"
"     ```\n"

#. type: Plain text
#: text/chapter14.md:259
#, no-wrap
msgid "     Modify the representation of an `Attribute` to take empty attributes into account. Write a function which can be used in place of `attribute` or `:=` to add an empty attribute to an element.\n"
msgstr ""
"     空の属性を扱えるように `Attribute`の表現を変更してください。\n"
"     要素に空の属性を追加するための`attribute`または`:=`の代わりに使える関数を記述してください。\n"

#. type: Title ##
#: text/chapter14.md:260
#, no-wrap
msgid "Phantom Types"
msgstr "幻影型"

#. type: Plain text
#: text/chapter14.md:263
msgid "To motivate the next technique, consider the following code:"
msgstr "次の手法の動機付けとして、以下のコードを考えます。"

#. type: Fenced code block (text)
#: text/chapter14.md:264
#, no-wrap
msgid ""
"> log $ render $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := \"foo\"\n"
"    , height := \"bar\"\n"
"    ]\n"
"\n"
"<img src=\"cat.jpg\" width=\"foo\" height=\"bar\" />\n"
"unit\n"
msgstr ""
"> log $ render $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := \"foo\"\n"
"    , height := \"bar\"\n"
"    ]\n"
"\n"
"<img src=\"cat.jpg\" width=\"foo\" height=\"bar\" />\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:276
msgid ""
"The problem here is that we have provided string values for the `width` and "
"`height` attributes, where we should only be allowed to provide numeric "
"values in units of pixels or percentage points."
msgstr ""
"ここでの問題は、 `width`属性と`height`属性に文字列値を提供しているということ"
"です。\n"
"ここで与えることができるのはピクセル単位ないしパーセントの数値だけであるべき"
"です。"

#. type: Plain text
#: text/chapter14.md:278
msgid ""
"To solve this problem, we can introduce a so-called _phantom type_ argument "
"to our `AttributeKey` type:"
msgstr ""
"`AttributeKey`型にいわゆる _幻影型_ (phantom type) 引数を導入すると、この問題"
"を解決できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:279
#, no-wrap
msgid "newtype AttributeKey a = AttributeKey String\n"
msgstr "newtype AttributeKey a = AttributeKey String\n"

#. type: Plain text
#: text/chapter14.md:284
msgid ""
"The type variable `a` is called a _phantom type_ because there are no values "
"of type `a` involved in the right-hand side of the definition. The type `a` "
"only exists to provide more information at compile-time. Any value of type "
"`AttributeKey a` is simply a string at runtime, but at compile-time, the "
"type of the value tells us the desired type of the values associated with "
"this key."
msgstr ""
"定義の右辺に対応する型 `a`の値が存在しないので、この型変数 `a`は*幻影型*と呼"
"ばれています。\n"
"この型 `a`はコンパイル時に追加の情報を提供するためだけに存在しています。\n"
"型`AttributeKey a`の任意の値は実行時には単なる文字列ですが、コンパイル時はそ"
"の値の型により、このキーに関連する値で求められる型がわかります。"

#. type: Plain text
#: text/chapter14.md:286
msgid ""
"We can modify the type of our `attribute` function to take the new form of "
"`AttributeKey` into account:"
msgstr ""
"`attribute`関数の型を次のように変更すれば、`AttributeKey`の新しい形式を考慮す"
"るようにできます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:287
#, no-wrap
msgid ""
"attribute :: forall a. IsValue a => AttributeKey a -> a -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: toValue value\n"
"  }\n"
msgstr ""
"attribute :: forall a. IsValue a => AttributeKey a -> a -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: toValue value\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:296
msgid ""
"Here, the phantom type argument `a` is used to ensure that the attribute key "
"and attribute value have compatible types. Since the user cannot create "
"values of type `AttributeKey a` directly (only via the constants we provide "
"in the library), every attribute will be correct by construction."
msgstr ""
"ここで、幻影型の引数 `a`は、属性キーと属性値が照応する型を持っていることを確"
"認するために使われます。\n"
"使用者は `AttributeKey a`の型の値を直接作成できないので（ライブラリで提供され"
"ている定数を介してのみ得られます）、全ての属性が構築により正しくなります。"

#. type: Plain text
#: text/chapter14.md:298
msgid ""
"Note that the `IsValue` constraint ensures that whatever value type we "
"associate to a key, its values can be converted to strings and displayed in "
"the generated HTML. The `IsValue` type class is defined as follows:"
msgstr ""
"なお、`IsValue`制約はキーに関連付けられた値の型が何であれその値を文字列に変換"
"し、生成したHTML内に出力できることを保証します。\n"
"`IsValue`型クラスは次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:299
#, no-wrap
msgid ""
"class IsValue a where\n"
"  toValue :: a -> String\n"
msgstr ""
"class IsValue a where\n"
"  toValue :: a -> String\n"

#. type: Plain text
#: text/chapter14.md:305
msgid "We also provide type class instances for the `String` and `Int` types:"
msgstr "`String`と `Int`型についての型クラスインスタンスも提供しておきます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:306
#, no-wrap
msgid ""
"instance stringIsValue :: IsValue String where\n"
"  toValue = id\n"
"\n"
"instance intIsValue :: IsValue Int where\n"
"  toValue = show\n"
msgstr ""
"instance stringIsValue :: IsValue String where\n"
"  toValue = id\n"
"\n"
"instance intIsValue :: IsValue Int where\n"
"  toValue = show\n"

#. type: Plain text
#: text/chapter14.md:315
msgid ""
"We also have to update our `AttributeKey` constants so that their types "
"reflect the new type parameter:"
msgstr ""
"また、これらの型が新しい型変数を反映するように、 `AttributeKey`定数を更新しな"
"ければいけません。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:316
#, no-wrap
msgid ""
"href :: AttributeKey String\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey String\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey String\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey Int\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey Int\n"
"height = AttributeKey \"height\"\n"
msgstr ""
"href :: AttributeKey String\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey String\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey String\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey Int\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey Int\n"
"height = AttributeKey \"height\"\n"

#. type: Plain text
#: text/chapter14.md:334
msgid ""
"Now we find it is impossible to represent these invalid HTML documents, and "
"we are forced to use numbers to represent the `width` and `height` "
"attributes instead:"
msgstr ""
"これで、不正なHTML文書を表現することが不可能になっていることがわかります。\n"
"また、`width`と `height`属性を表現するのに文字列ではなく数を使うことが強制さ"
"れていることがわかります。"

#. type: Fenced code block (text)
#: text/chapter14.md:335
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Phantom\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ img\n"
"…   [ src    := \"cat.jpg\"\n"
"…   , width  := 100\n"
"…   , height := 200\n"
"…   ]\n"
"… ^D\n"
"\n"
"<img src=\"cat.jpg\" width=\"100\" height=\"200\" />\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Phantom\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ img\n"
"…   [ src    := \"cat.jpg\"\n"
"…   , width  := 100\n"
"…   , height := 200\n"
"…   ]\n"
"… ^D\n"
"\n"
"<img src=\"cat.jpg\" width=\"100\" height=\"200\" />\n"
"unit\n"

#. type: Bullet: ' 1. '
#: text/chapter14.md:356
msgid ""
"(Easy) Create a data type which represents either pixel or percentage "
"lengths. Write an instance of `IsValue` for your type. Modify the `width` "
"and `height` attributes to use your new type."
msgstr ""
"（簡単）ピクセルまたはパーセントの長さの何れかを表すデータ型を作成してくださ"
"い。\n"
"その型について `IsValue`のインスタンスを書いてください。\n"
"この型を使うように `width`と `height`属性を変更してください。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:356
msgid ""
"(Difficult) By defining type-level representatives for the Boolean values "
"`true` and `false`, we can use a phantom type to encode whether an "
"`AttributeKey` represents an _empty attribute_ such as `disabled` or "
"`checked`."
msgstr ""
"（難しい）幻影型を使って真偽値 `true`、 `false`用の最上位の表現を定義すること"
"で、 `AttributeKey`が `disabled`や `checked`のような*空の属性*を表現している"
"かどうかを符号化できます。"

#. type: Plain text
#: text/chapter14.md:361
#, no-wrap
msgid ""
"     ```haskell\n"
"     data True\n"
"     data False\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data True\n"
"     data False\n"
"     ```\n"

#. type: Plain text
#: text/chapter14.md:363
#, no-wrap
msgid "     Modify your solution to the previous exercise to use a phantom type to prevent the user from using the `attribute` operator with an empty attribute.\n"
msgstr "     幻影型を使って、使用者が `attribute`演算子を空の属性に対して使うことを防ぐように、前の演習の解答を変更してください。\n"

#. type: Title ##
#: text/chapter14.md:364
#, no-wrap
msgid "The Free Monad"
msgstr "Freeモナド"

#. type: Plain text
#: text/chapter14.md:367
msgid ""
"In our final set of modifications to our API, we will use a construction "
"called the _free monad_ to turn our `Content` type into a monad, enabling do "
"notation. This will allow us to structure our HTML documents in a form in "
"which the nesting of elements becomes clearer - instead of this:"
msgstr ""
"APIに施す最後の変更は、 `Content`型をモナドにしてdo記法を使えるようにするため"
"に、 _Freeモナド_ と呼ばれる構造を使うことです。これによって入れ子になった要"
"素がわかりやすくなるようにHTML文書を構造化できます。以下の代わりに……"

#. type: Fenced code block (haskell)
#: text/chapter14.md:368
#, no-wrap
msgid ""
"p [ _class := \"main\" ]\n"
"  [ elem $ img\n"
"      [ src    := \"cat.jpg\"\n"
"      , width  := 100\n"
"      , height := 200\n"
"      ]\n"
"  , text \"A cat\"\n"
"  ]\n"
msgstr ""
"p [ _class := \"main\" ]\n"
"  [ elem $ img\n"
"      [ src    := \"cat.jpg\"\n"
"      , width  := 100\n"
"      , height := 200\n"
"      ]\n"
"  , text \"A cat\"\n"
"  ]\n"

#. type: Plain text
#: text/chapter14.md:380
msgid "we will be able to write this:"
msgstr "このように書くことができるようになります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:381
#, no-wrap
msgid ""
"p [ _class := \"main\" ] $ do\n"
"  elem $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := 100\n"
"    , height := 200\n"
"    ]\n"
"  text \"A cat\"\n"
msgstr ""
"p [ _class := \"main\" ] $ do\n"
"  elem $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := 100\n"
"    , height := 200\n"
"    ]\n"
"  text \"A cat\"\n"

#. type: Plain text
#: text/chapter14.md:392
msgid ""
"However, do notation is not the only benefit of a free monad. The free monad "
"allows us to separate the _representation_ of our monadic actions from their "
"_interpretation_, and even support _multiple interpretations_ of the same "
"actions."
msgstr ""
"しかし、do記法だけがFreeモナドの恩恵だというわけではありません。Freeモナドが"
"あれば、モナドのアクションの _表現_ をその _解釈_ から分離し、同じアクション"
"に _複数の解釈_ を持たせることさえできます。"

#. type: Plain text
#: text/chapter14.md:394
msgid ""
"The `Free` monad is defined in the `free` library, in the `Control.Monad."
"Free` module. We can find out some basic information about it using PSCi, as "
"follows:"
msgstr ""
"`Free`モナドは `free`ライブラリの `Control.Monad.Free`モジュールで定義されて"
"います。\n"
"PSCiを使うと、次のようにFreeモナドについての基本的な情報を見ることができま"
"す。"

#. type: Fenced code block (text)
#: text/chapter14.md:395
#, no-wrap
msgid ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter14.md:403
msgid ""
"The kind of `Free` indicates that it takes a type constructor as an "
"argument, and returns another type constructor. In fact, the `Free` monad "
"can be used to turn any `Functor` into a `Monad`!"
msgstr ""
"`Free`の種は、引数として型構築子を取り、別の型構築子を返すことを示していま"
"す。\n"
"実は、`Free`モナドを使えば任意の`Functor`を`Monad`にできます。"

#. type: Plain text
#: text/chapter14.md:405
msgid ""
"We begin by defining the _representation_ of our monadic actions. To do "
"this, we need to create a `Functor` with one data constructor for each "
"monadic action we wish to support. In our case, our two monadic actions will "
"be `elem` and `text`. In fact, we can simply modify our `Content` type as "
"follows:"
msgstr ""
"モナドのアクションの*表現*の定義から始めます。\n"
"こうするには、対応する各モナドアクションそれぞれについて、1つのデータ構築子を"
"持つ `Functor`を作成する必要があります。\n"
"今回の場合、2つのモナドのアクションは `elem`と `text`になります。\n"
"実際には、 `Content`型を次のように変更するだけです。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:406
#, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"\n"
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
msgstr ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"\n"
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"

#. type: Plain text
#: text/chapter14.md:417
msgid ""
"Here, the `ContentF` type constructor looks just like our old `Content` data "
"type - however, it now takes a type argument `a`, and each data constructor "
"has been modified to take a value of type `a` as an additional argument. The "
"`Functor` instance simply applies the function `f` to the value of type `a` "
"in each data constructor."
msgstr ""
"ここで、この `ContentF`型構築子は以前の `Content`データ型とよく似ています。\n"
"しかし、ここでは型引数`a`を取り、それぞれのデータ構築子は型`a`の値を追加の引"
"数として取るように変更されています。\n"
"`Functor`インスタンスでは、単に各データ構築子で型 `a`の構成要素に関数 `f`を適"
"用します。"

#. type: Plain text
#: text/chapter14.md:419
msgid ""
"With that, we can define our new `Content` monad as a type synonym for the "
"`Free` monad, which we construct by using our `ContentF` type constructor as "
"the first type argument:"
msgstr ""
"これにより、新しい`Content`モナドを`Free`モナド用の型シノニムとして定義できま"
"す。\n"
"これは最初の型引数として `ContentF`型構築子を使うことで構築されます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:420
#, no-wrap
msgid "type Content = Free ContentF\n"
msgstr "type Content = Free ContentF\n"

#. type: Plain text
#: text/chapter14.md:425
msgid ""
"Instead of a type synonym, we might use a `newtype` to avoid exposing the "
"internal representation of our library to our users - by hiding the "
"`Content` data constructor, we restrict our users to only using the monadic "
"actions we provide."
msgstr ""
"型シノニムの代わりにnewtypeを使用して、使用者に対してライブラリの内部表現を露"
"出することを避けられます。\n"
"`Content`データ構築子を隠すことで、提供しているモナドのアクションだけを使うこ"
"とを使用者に制限しています。"

#. type: Plain text
#: text/chapter14.md:427
msgid ""
"Because `ContentF` is a `Functor`, we automatically get a `Monad` instance "
"for `Free ContentF`."
msgstr ""
"`ContentF`は `Functor`なので、 `Free ContentF`用の`Monad`インスタンスが自動的"
"に手に入ります。"

#. type: Plain text
#: text/chapter14.md:429
msgid ""
"We have to modify our `Element` data type slightly to take account of the "
"new type argument on `Content`. We will simply require that the return type "
"of our monadic computations be `Unit`:"
msgstr ""
"`Content`の新しい型引数を考慮するように`Element`データ型を僅かに変更する必要"
"があります。\n"
"モナドの計算の戻り値の型が `Unit`であることだけが必要です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:430
#, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Content Unit)\n"
"  }\n"
msgstr ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Content Unit)\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:439
msgid ""
"In addition, we have to modify our `elem` and `text` functions, which become "
"our new monadic actions for the `Content` monad. To do this, we can use the "
"`liftF` function, provided by the `Control.Monad.Free` module. Here is its "
"type:"
msgstr ""
"また、 `Content`モナドについての新しいモナドのアクションになる `elem`と "
"`text`関数を変更する必要があります。\n"
"これには`Control.Monad.Free`モジュールで提供されている `liftF`関数が使えま"
"す。\n"
"この関数の型は次のようになっています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:440
#, no-wrap
msgid "liftF :: forall f a. f a -> Free f a\n"
msgstr "liftF :: forall f a. f a -> Free f a\n"

#. type: Plain text
#: text/chapter14.md:445
msgid ""
"`liftF` allows us to construct an action in our free monad from a value of "
"type `f a` for some type `a`. In our case, we can simply use the data "
"constructors of our `ContentF` type constructor directly:"
msgstr ""
"`liftF`により、何らかの型 `a`について、型 `f a`の値からFreeモナドのアクション"
"を構築できるようになります。\n"
"今回の場合、 `ContentF`型構築子のデータ構築子をそのまま使うだけです。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:446
#, no-wrap
msgid ""
"text :: String -> Content Unit\n"
"text s = liftF $ TextContent s unit\n"
"\n"
"elem :: Element -> Content Unit\n"
"elem e = liftF $ ElementContent e unit\n"
msgstr ""
"text :: String -> Content Unit\n"
"text s = liftF $ TextContent s unit\n"
"\n"
"elem :: Element -> Content Unit\n"
"elem e = liftF $ ElementContent e unit\n"

#. type: Plain text
#: text/chapter14.md:455
msgid ""
"Some other routine modifications have to be made, but the interesting "
"changes are in the `render` function, where we have to _interpret_ our free "
"monad."
msgstr ""
"他にも同じようなコードの変更はありますが、興味深い変更は `render`関数にありま"
"す。ここでは、このFreeモナドを _解釈_ しなければいけません。"

#. type: Title ##
#: text/chapter14.md:456
#, no-wrap
msgid "Interpreting the Monad"
msgstr "モナドの解釈"

#. type: Plain text
#: text/chapter14.md:459
msgid ""
"The `Control.Monad.Free` module provides a number of functions for "
"interpreting a computation in a free monad:"
msgstr ""
"`Control.Monad.Free`モジュールでは、Freeモナドで計算を解釈するための多数の関"
"数が提供されています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:460
#, no-wrap
msgid ""
"runFree\n"
"  :: forall f a\n"
"   . Functor f\n"
"  => (f (Free f a) -> Free f a)\n"
"  -> Free f a\n"
"  -> a\n"
"\n"
"runFreeM\n"
"  :: forall f m a\n"
"   . (Functor f, MonadRec m)\n"
"  => (f (Free f a) -> m (Free f a))\n"
"  -> Free f a\n"
"  -> m a\n"
msgstr ""
"runFree\n"
"  :: forall f a\n"
"   . Functor f\n"
"  => (f (Free f a) -> Free f a)\n"
"  -> Free f a\n"
"  -> a\n"
"\n"
"runFreeM\n"
"  :: forall f m a\n"
"   . (Functor f, MonadRec m)\n"
"  => (f (Free f a) -> m (Free f a))\n"
"  -> Free f a\n"
"  -> m a\n"

#. type: Plain text
#: text/chapter14.md:477
msgid ""
"The `runFree` function is used to compute a _pure_ result. The `runFreeM` "
"function allows us to use a monad to interpret the actions of our free monad."
msgstr ""
"`runFree`関数は、 _純粋な_ 結果を計算するために使用されます。 `runFreeM`関数"
"があればFreeモナドのアクションを解釈するためにモナドが使えます。"

#. type: Plain text
#: text/chapter14.md:479
msgid ""
"_Note_: Technically, we are restricted to using monads `m` which satisfy the "
"stronger `MonadRec` constraint. In practice, this means that we don't need "
"to worry about stack overflow, since `m` supports safe _monadic tail "
"recursion_."
msgstr ""
"*補足*：厳密には、より強い`MonadRec`制約を満たすモナド `m`を使用するよう制限"
"されています。\n"
"実際には、これはスタックオーバーフローを心配する必要がないことを意味しま"
"す。\n"
"なぜなら `m`は安全な*末尾再帰モナド*に対応しているからです。"

#. type: Plain text
#: text/chapter14.md:481
msgid ""
"First, we have to choose a monad in which we can interpret our actions. We "
"will use the `Writer String` monad to accumulate a HTML string as our result."
msgstr ""
"まず、アクションを解釈できるモナドを選ばなければなりません。\n"
"`Writer String`モナドを使って、結果のHTML文字列を累積することにします。"

#. type: Plain text
#: text/chapter14.md:483
msgid ""
"Our new `render` method starts by delegating to a helper function, "
"`renderElement`, and using `execWriter` to run our computation in the "
"`Writer` monad:"
msgstr ""
"新しい`render`メソッドが開始すると、補助関数 `renderElement`に移譲し、"
"`execWriter`を使って`Writer`モナドで計算を走らせます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:484
#, no-wrap
msgid ""
"render :: Element -> String\n"
"render = execWriter <<< renderElement\n"
msgstr ""
"render :: Element -> String\n"
"render = execWriter <<< renderElement\n"

#. type: Plain text
#: text/chapter14.md:490
msgid "`renderElement` is defined in a where block:"
msgstr "`renderElement`はwhereブロックで定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:491
#, no-wrap
msgid ""
"  where\n"
"    renderElement :: Element -> Writer String Unit\n"
"    renderElement (Element e) = do\n"
msgstr ""
"  where\n"
"    renderElement :: Element -> Writer String Unit\n"
"    renderElement (Element e) = do\n"

#. type: Plain text
#: text/chapter14.md:498
msgid ""
"The definition of `renderElement` is straightforward, using the `tell` "
"action from the `Writer` monad to accumulate several small strings:"
msgstr ""
"`renderElement`の定義は直感的で、複数の小さな文字列を累積するために `Writer`"
"モナドの `tell`アクションを使っています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:499
#, no-wrap
msgid ""
"      tell \"<\"\n"
"      tell e.name\n"
"      for_ e.attribs $ \\x -> do\n"
"        tell \" \"\n"
"        renderAttribute x\n"
"      renderContent e.content\n"
msgstr ""
"      tell \"<\"\n"
"      tell e.name\n"
"      for_ e.attribs $ \\x -> do\n"
"        tell \" \"\n"
"        renderAttribute x\n"
"      renderContent e.content\n"

#. type: Plain text
#: text/chapter14.md:509
msgid ""
"Next, we define the `renderAttribute` function, which is equally simple:"
msgstr ""
"次に、`renderAttribute`関数を定義します。\n"
"こちらも同じくらい単純です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:510
#, no-wrap
msgid ""
"    where\n"
"      renderAttribute :: Attribute -> Writer String Unit\n"
"      renderAttribute (Attribute x) = do\n"
"        tell x.key\n"
"        tell \"=\\\"\"\n"
"        tell x.value\n"
"        tell \"\\\"\"\n"
msgstr ""
"    where\n"
"      renderAttribute :: Attribute -> Writer String Unit\n"
"      renderAttribute (Attribute x) = do\n"
"        tell x.key\n"
"        tell \"=\\\"\"\n"
"        tell x.value\n"
"        tell \"\\\"\"\n"

#. type: Plain text
#: text/chapter14.md:521
msgid ""
"The `renderContent` function is more interesting. Here, we use the "
"`runFreeM` function to interpret the computation inside the free monad, "
"delegating to a helper function, `renderContentItem`:"
msgstr ""
"`renderContent`関数は、もっと興味深いものです。\n"
"ここでは`runFreeM`関数を使い、Freeモナドの内部で計算を解釈しています。\n"
"計算は補助関数 `renderContentItem`に移譲しています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:522
#, no-wrap
msgid ""
"      renderContent :: Maybe (Content Unit) -> Writer String Unit\n"
"      renderContent Nothing = tell \" />\"\n"
"      renderContent (Just content) = do\n"
"        tell \">\"\n"
"        runFreeM renderContentItem content\n"
"        tell \"</\"\n"
"        tell e.name\n"
"        tell \">\"\n"
msgstr ""
"      renderContent :: Maybe (Content Unit) -> Writer String Unit\n"
"      renderContent Nothing = tell \" />\"\n"
"      renderContent (Just content) = do\n"
"        tell \">\"\n"
"        runFreeM renderContentItem content\n"
"        tell \"</\"\n"
"        tell e.name\n"
"        tell \">\"\n"

#. type: Plain text
#: text/chapter14.md:534
msgid ""
"The type of `renderContentItem` can be deduced from the type signature of "
"`runFreeM`. The functor `f` is our type constructor `ContentF`, and the "
"monad `m` is the monad in which we are interpreting the computation, namely "
"`Writer String`. This gives the following type signature for "
"`renderContentItem`:"
msgstr ""
"`renderContentItem`の型は `runFreeM`の型シグネチャから推測できます。\n"
"関手 `f`は型構築子 `ContentF`で、モナド `m`は解釈している計算のモナド、つま"
"り `Writer String`です。\n"
"これにより `renderContentItem`は次の型シグネチャだとわかります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:535
#, no-wrap
msgid "      renderContentItem :: ContentF (Content Unit) -> Writer String (Content Unit)\n"
msgstr "      renderContentItem :: ContentF (Content Unit) -> Writer String (Content Unit)\n"

#. type: Plain text
#: text/chapter14.md:540
msgid ""
"We can implement this function by simply pattern matching on the two data "
"constructors of `ContentF`:"
msgstr ""
"`ContentF`の2つのデータ構築子でパターン照合するだけでこの関数を実装できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:541
#, no-wrap
msgid ""
"      renderContentItem (TextContent s rest) = do\n"
"        tell s\n"
"        pure rest\n"
"      renderContentItem (ElementContent e rest) = do\n"
"        renderElement e\n"
"        pure rest\n"
msgstr ""
"      renderContentItem (TextContent s rest) = do\n"
"        tell s\n"
"        pure rest\n"
"      renderContentItem (ElementContent e rest) = do\n"
"        renderElement e\n"
"        pure rest\n"

#. type: Plain text
#: text/chapter14.md:551
msgid ""
"In each case, the expression `rest` has the type `Content Unit`, and "
"represents the remainder of the interpreted computation. We can complete "
"each case by returning the `rest` action."
msgstr ""
"それぞれの場合において、式 `rest`は型 `Content Unit`を持っており、解釈計算の"
"残りを表しています。\n"
"`rest`アクションを呼び出すことによってそれぞれの場合を完了できます。"

#. type: Plain text
#: text/chapter14.md:553
msgid "That's it! We can test our new monadic API in PSCi, as follows:"
msgstr ""
"できました。\n"
"PSCiで、次のようにすれば新しいモナドのAPIを試すことができます。"

#. type: Fenced code block (text)
#: text/chapter14.md:554
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Free\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ p [] $ do\n"
"…   elem $ img [ src := \"cat.jpg\" ]\n"
"…   text \"A cat\"\n"
"… ^D\n"
"\n"
"<p><img src=\"cat.jpg\" />A cat</p>\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Free\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… log $ render $ p [] $ do\n"
"…   elem $ img [ src := \"cat.jpg\" ]\n"
"…   text \"A cat\"\n"
"… ^D\n"
"\n"
"<p><img src=\"cat.jpg\" />A cat</p>\n"
"unit\n"

#. type: Bullet: ' 1. '
#: text/chapter14.md:572
msgid ""
"(Medium) Add a new data constructor to the `ContentF` type to support a new "
"action `comment`, which renders a comment in the generated HTML. Implement "
"the new action using `liftF`. Update the interpretation `renderContentItem` "
"to interpret your new constructor appropriately."
msgstr ""
"（普通）`ContentF`型に新しいデータ構築子を追加して、生成されたHTMLにコメント"
"を出力する新しいアクション `comment`に対応してください。\n"
"`liftF`を使ってこの新しいアクションを実装してください。\n"
"新しい構築子を適切に解釈するように、解釈 `renderContentItem`を更新してくださ"
"い。"

#. type: Title ##
#: text/chapter14.md:573
#, no-wrap
msgid "Extending the Language"
msgstr "言語の拡張"

#. type: Plain text
#: text/chapter14.md:576
msgid ""
"A monad in which every action returns something of type `Unit` is not "
"particularly interesting. In fact, aside from an arguably nicer syntax, our "
"monad adds no extra functionality over a `Monoid`."
msgstr ""
"全てのアクションが型 `Unit`の何かを返すようなモナドは、さほど興味深いものでは"
"ありません。\n"
"実際のところ、概ね良くなったと思われる構文は別として、このモナドは `Monoid`以"
"上の機能を何ら追加していません。"

#. type: Plain text
#: text/chapter14.md:578
msgid ""
"Let's illustrate the power of the free monad construction by extending our "
"language with a new monadic action which returns a non-trivial result."
msgstr ""
"非自明な結果を返す新しいモナドアクションでこの言語を拡張することで、Freeモナ"
"ド構造の威力をお見せしましょう。"

#. type: Plain text
#: text/chapter14.md:580
msgid ""
"Suppose we want to generate HTML documents which contain hyperlinks to "
"different sections of the document using _anchors_. We can accomplish this "
"already, by generating anchor names by hand and including them at least "
"twice in the document: once at the definition of the anchor itself, and once "
"in each hyperlink. However, this approach has some basic issues:"
msgstr ""
"*アンカー*を使用して文書のさまざまな節へのハイパーリンクが含まれているHTML文"
"書を生成するとします。\n"
"これは既に達成できています。\n"
"手作業でアンカーの名前を生成して文書中で少なくとも2回それらを含めればよいので"
"す。\n"
"1つはアンカーの定義自身に、もう1つはそれぞれのハイパーリンクにあります。\n"
"しかし、この方法には根本的な問題が幾つかあります。"

#. type: Bullet: '- '
#: text/chapter14.md:583
msgid "The developer might fail to generate unique anchor names."
msgstr "開発者が一意なアンカー名の生成をし損なうかもしれません。"

#. type: Bullet: '- '
#: text/chapter14.md:583
msgid "The developer might mistype one or more instances of the anchor name."
msgstr "開発者がアンカー名を1つ以上の箇所で打ち間違うかもしれません。"

#. type: Plain text
#: text/chapter14.md:585
msgid ""
"In the interest of protecting the developer from their own mistakes, we can "
"introduce a new type which represents anchor names, and provide a monadic "
"action for generating new unique names."
msgstr ""
"開発者が誤ちを犯すことを防ぐために、アンカー名を表す新しい型を導入し、新しい"
"一意な名前を生成するためのモナドアクションを提供できます。"

#. type: Plain text
#: text/chapter14.md:587
msgid "The first step is to add a new type for names:"
msgstr "最初の工程は名前の型を新しく追加することです。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:588
#, no-wrap
msgid ""
"newtype Name = Name String\n"
"\n"
"runName :: Name -> String\n"
"runName (Name n) = n\n"
msgstr ""
"newtype Name = Name String\n"
"\n"
"runName :: Name -> String\n"
"runName (Name n) = n\n"

#. type: Plain text
#: text/chapter14.md:596
msgid ""
"Again, we define this as a newtype around `String`, but we must be careful "
"not to export the data constructor in the module's export lists."
msgstr ""
"繰り返しになりますが、`Name`は `String`のnewtypeとして定義しているものの、モ"
"ジュールのエクスポートリスト内でデータ構築子をエクスポートしないように注意す"
"る必要があります。"

#. type: Plain text
#: text/chapter14.md:598
msgid ""
"Next, we define an instance for the `IsValue` type class for our new type, "
"so that we are able to use names in attribute values:"
msgstr ""
"次に、属性値として `Name`を使うことができるように、新しい型に`IsValue`型クラ"
"スのインスタンスを定義します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:599
#, no-wrap
msgid ""
"instance nameIsValue :: IsValue Name where\n"
"  toValue (Name n) = n\n"
msgstr ""
"instance nameIsValue :: IsValue Name where\n"
"  toValue (Name n) = n\n"

#. type: Plain text
#: text/chapter14.md:605
msgid ""
"We also define a new data type for hyperlinks which can appear in `a` "
"elements, as follows:"
msgstr ""
"また、次のように `a`要素に現れるハイパーリンク用の新しいデータ型を定義しま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:606
#, no-wrap
msgid ""
"data Href\n"
"  = URLHref String\n"
"  | AnchorHref Name\n"
"\n"
"instance hrefIsValue :: IsValue Href where\n"
"  toValue (URLHref url) = url\n"
"  toValue (AnchorHref (Name nm)) = \"#\" <> nm\n"
msgstr ""
"data Href\n"
"  = URLHref String\n"
"  | AnchorHref Name\n"
"\n"
"instance hrefIsValue :: IsValue Href where\n"
"  toValue (URLHref url) = url\n"
"  toValue (AnchorHref (Name nm)) = \"#\" <> nm\n"

#. type: Plain text
#: text/chapter14.md:617
msgid ""
"With this new type, we can modify the value type of the `href` attribute, "
"forcing our users to use our new `Href` type. We can also create a new "
"`name` attribute, which can be used to turn an element into an anchor:"
msgstr ""
"この新しい型により、`href`属性の型の値を変更して、利用者にこの新しい `Href`型"
"の使用を強制できます。\n"
"また、新しい`name`属性も作成でき、要素をアンカーに変換するのに使えます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:618
#, no-wrap
msgid ""
"href :: AttributeKey Href\n"
"href = AttributeKey \"href\"\n"
"\n"
"name :: AttributeKey Name\n"
"name = AttributeKey \"name\"\n"
msgstr ""
"href :: AttributeKey Href\n"
"href = AttributeKey \"href\"\n"
"\n"
"name :: AttributeKey Name\n"
"name = AttributeKey \"name\"\n"

#. type: Plain text
#: text/chapter14.md:627
msgid ""
"The remaining problem is that our users currently have no way to generate "
"new names. We can provide this functionality in our `Content` monad. First, "
"we need to add a new data constructor to our `ContentF` type constructor:"
msgstr ""
"残っている問題は、現在モジュールの使用者が新しい名前を生成する方法がないとい"
"うことです。\n"
"`Content`モナドでこの機能を提供できます。まず、 `ContentF`型構築子に新しい"
"データ構築子を追加する必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:628
#, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"  | NewName (Name -> a)\n"
msgstr ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"  | NewName (Name -> a)\n"

#. type: Plain text
#: text/chapter14.md:636
#, no-wrap
msgid "The `NewName` data constructor corresponds to an action which returns a value of type `Name`. Notice that instead of requiring a `Name` as a data constructor argument, we require the user to provide a _function_ of type `Name -> a`. Remembering that the type `a` represents the _rest of the computation_, we can see that this function provides a way to continue computation after a value of type `Name` has been returned.\n"
msgstr "`NewName`データ構築子は型 `Name`の値を返すアクションに対応しています。データ構築子の引数として `Name`を要求するのではなく、型 `Name -> a`の _関数_ を提供するように使用者に要求していることに注意してください。型 `a`は _計算の残り_ を表していることを思い出すと、この関数は、型 `Name`の値が返されたあとで、計算を継続する方法を提供しているのだとわかります。\n"

#. type: Plain text
#: text/chapter14.md:638
msgid ""
"We also need to update the `Functor` instance for `ContentF`, taking into "
"account the new data constructor, as follows:"
msgstr ""
"新しいデータ構築子を考慮するよう、次のように`ContentF`用の`Functor`インスタン"
"スを更新する必要もあります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:639
#, no-wrap
msgid ""
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
"  map f (NewName k) = NewName (f <<< k)\n"
msgstr ""
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
"  map f (NewName k) = NewName (f <<< k)\n"

#. type: Plain text
#: text/chapter14.md:647
msgid ""
"Now we can build our new action by using the `liftF` function, as before:"
msgstr ""
"これで、以前と同じように`liftF`関数を使って新しいアクションを構築できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:648
#, no-wrap
msgid ""
"newName :: Content Name\n"
"newName = liftF $ NewName id\n"
msgstr ""
"newName :: Content Name\n"
"newName = liftF $ NewName id\n"

#. type: Plain text
#: text/chapter14.md:654
msgid ""
"Notice that we provide the `id` function as our continuation, meaning that "
"we return the result of type `Name` unchanged."
msgstr ""
"`id`関数を継続として提供していることに注意してください。\n"
"これは型 `Name`の結果を変更せずに返すということを意味しています。"

#. type: Plain text
#: text/chapter14.md:656
msgid ""
"Finally, we need to update our interpretation function, to interpret the new "
"action. We previously used the `Writer String` monad to interpret our "
"computations, but that monad does not have the ability to generate new "
"names, so we must switch to something else. The `WriterT` monad transformer "
"can be used with the `State` monad to combine the effects we need. We can "
"define our interpretation monad as a type synonym to keep our type "
"signatures short:"
msgstr ""
"最後に、新しいアクションを解釈するために解釈関数を更新する必要があります。\n"
"以前は計算を解釈するために `Writer String`モナドを使っていましたが、このモナ"
"ドは新しい名前を生成する能力を持っていないので、何か他のものに切り替えなけれ"
"ばなりません。\n"
"`WriterT`モナド変換子を`State`モナドと一緒に使うと、必要な作用を組み合わせる"
"ことができます。\n"
"型注釈を短く保てるように、この解釈モナドを型同義語として定義しておきます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:657
#, no-wrap
msgid "type Interp = WriterT String (State Int)\n"
msgstr "type Interp = WriterT String (State Int)\n"

#. type: Plain text
#: text/chapter14.md:662
msgid ""
"Here, the state of type `Int` will act as an incrementing counter, used to "
"generate unique names."
msgstr ""
"ここで、`Int`型の状態は増加していくカウンタとして振舞い、一意な名前を生成する"
"のに使われます。"

#. type: Plain text
#: text/chapter14.md:664
msgid ""
"Because the `Writer` and `WriterT` monads use the same type class members to "
"abstract their actions, we do not need to change any actions - we only need "
"to replace every reference to `Writer String` with `Interp`. We do, however, "
"need to modify the handler used to run our computation. Instead of just "
"`execWriter`, we now need to use `evalState` as well:"
msgstr ""
"`Writer`と `WriterT`モナドはそれらのアクションを抽象化するのに同じ型クラスメ"
"ンバを使うので、どのアクションも変更する必要がありません。\n"
"必要なのは、 `Writer String`への参照全てを `Interp`で置き換えることだけで"
"す。\n"
"しかし、これを計算するために使われる制御子を変更しなければいけません。\n"
"こうなると単なる`execWriter`の代わりに、ここでも`evalState`を使う必要がありま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:665
#, no-wrap
msgid ""
"render :: Element -> String\n"
"render e = evalState (execWriterT (renderElement e)) 0\n"
msgstr ""
"render :: Element -> String\n"
"render e = evalState (execWriterT (renderElement e)) 0\n"

#. type: Plain text
#: text/chapter14.md:671
msgid ""
"We also need to add a new case to `renderContentItem`, to interpret the new "
"`NewName` data constructor:"
msgstr ""
"また、新しい `NewName`データ構築子を解釈するために、 `renderContentItem`に新"
"しい場合を追加しなければいけません。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:672
#, no-wrap
msgid ""
"renderContentItem (NewName k) = do\n"
"  n <- get\n"
"  let fresh = Name $ \"name\" <> show n\n"
"  put $ n + 1\n"
"  pure (k fresh)\n"
msgstr ""
"renderContentItem (NewName k) = do\n"
"  n <- get\n"
"  let fresh = Name $ \"name\" <> show n\n"
"  put $ n + 1\n"
"  pure (k fresh)\n"

#. type: Plain text
#: text/chapter14.md:681
#, no-wrap
msgid "Here, we are given a continuation `k` of type `Name -> Content a`, and we need to construct an interpretation of type `Content a`. Our interpretation is simple: we use `get` to read the state, use that state to generate a unique name, then use `put` to increment the state. Finally, we pass our new name to the continuation to complete the computation.\n"
msgstr ""
"ここで、型 `Name -> Content a`の継続 `k`が与えられているので、型 `Content a`の解釈を構築しなければいけません。\n"
"この解釈は単純です。\n"
"`get`を使って状態を読み、その状態を使って一意な名前を生成し、それから `put`で状態に1だけ足すのです。\n"
"最後に、継続にこの新しい名前を渡して、計算を完了します。\n"

#. type: Plain text
#: text/chapter14.md:683
msgid ""
"With that, we can try out our new functionality in PSCi, by generating a "
"unique name inside the `Content` monad, and using it as both the name of an "
"element and the target of a hyperlink:"
msgstr ""
"以上をもって、この新しい機能をPSCiで試すことができます。\n"
"これには`Content`モナドの内部で一意な名前を生成し、要素の名前とハイパーリンク"
"のリンク先の両方として使います。"

#. type: Fenced code block (text)
#: text/chapter14.md:684
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Name\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… render $ p [ ] $ do\n"
"…   top <- newName\n"
"…   elem $ a [ name := top ] $\n"
"…     text \"Top\"\n"
"…   elem $ a [ href := AnchorHref top ] $\n"
"…     text \"Back to top\"\n"
"… ^D\n"
"\n"
"<p><a name=\"name0\">Top</a><a href=\"#name0\">Back to top</a></p>\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Name\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"… render $ p [ ] $ do\n"
"…   top <- newName\n"
"…   elem $ a [ name := top ] $\n"
"…     text \"Top\"\n"
"…   elem $ a [ href := AnchorHref top ] $\n"
"…     text \"Back to top\"\n"
"… ^D\n"
"\n"
"<p><a name=\"name0\">Top</a><a href=\"#name0\">Back to top</a></p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:703
msgid ""
"You can verify that multiple calls to `newName` do in fact result in unique "
"names."
msgstr ""
"複数回の `newName`の呼び出しの結果が、実際に一意な名前になっていることも確か"
"められます。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:712
msgid ""
"(Medium) We can simplify the API further by hiding the `Element` type from "
"its users. Make these changes in the following steps:"
msgstr ""
"（普通）使用者から `Element`型を隠蔽すると、更にAPIを簡素にできます。\n"
"次の手順に従って、これらの変更を加えてください。"

#. type: Bullet: '     - '
#: text/chapter14.md:712
msgid ""
"Combine functions like `p` and `img` (with return type `Element`) with the "
"`elem` action to create new actions with return type `Content Unit`."
msgstr ""
"`p`や `img`のような（返る型が `Element`の）関数を `elem`アクションと結合し"
"て、型 `Content Unit`を返す新しいアクションを作ってください。"

#. type: Bullet: '     - '
#: text/chapter14.md:712
msgid ""
"Change the `render` function to accept an argument of type `Content Unit` "
"instead of `Element`."
msgstr ""
"`Element`の代わりに型`Content Unit`の引数を受け付けるように`render`関数を変更"
"してください。"

#. type: Plain text
#: text/chapter14.md:712
#, no-wrap
msgid ""
" 1. (Medium) Hide the implementation of the `Content` monad by using a `newtype` instead of a type synonym. You should not export the data\n"
"     constructor for your `newtype`.\n"
" 1. (Difficult) Modify the `ContentF` type to support a new action\n"
msgstr ""
" 1. （普通）型同義語の代わりに`newtype`を使うことによって`Content`モナドの実装を隠してください。\n"
"    `newtype`用のデータ構築子はエクスポートすべきではありません。\n"
" 1. （難しい）`ContentF`型を変更して以下の新しいアクションに対応してください。\n"

#. type: Plain text
#: text/chapter14.md:716
#, no-wrap
msgid ""
"     ```haskell\n"
"     isMobile :: Content Boolean\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     isMobile :: Content Boolean\n"
"     ```\n"

#. type: Plain text
#: text/chapter14.md:718
#, no-wrap
msgid "     which returns a boolean value indicating whether or not the document is being rendered for display on a mobile device.\n"
msgstr "     このアクションは、この文書がモバイルデバイス上での表示のためにレンダリングされているかどうかを示す真偽値を返します。\n"

#. type: Plain text
#: text/chapter14.md:720
#, no-wrap
msgid "     _Hint_: use the `ask` action and the `ReaderT` monad transformer to interpret this action. Alternatively, you might prefer to use the `RWS` monad.\n"
msgstr ""
"     *手掛かり*：`ask`アクションと`ReaderT`モナド変換子を使って、このアクションを解釈してください。\n"
"     あるいは、`RWS`モナドを使うほうが好みの人もいるかもしれません。\n"

#. type: Plain text
#: text/chapter14.md:724
msgid ""
"In this chapter, we developed a domain-specific language for creating HTML "
"documents, by incrementally improving a naive implementation using some "
"standard techniques:"
msgstr ""
"この章では、幾つかの標準的な技術を使って、素朴な実装を段階的に改善することに"
"より、HTML文書を作成するための領域特化言語を開発しました。"

#. type: Bullet: '- '
#: text/chapter14.md:729
msgid ""
"We used _smart constructors_ to hide the details of our data representation, "
"only permitting the user to create documents which were _correct-by-"
"construction_."
msgstr ""
"_スマート構築子_ を使ってデータ表現の詳細を隠し、利用者には _構築により正しい"
"_ 文書だけを作ることを許しました。"

#. type: Bullet: '- '
#: text/chapter14.md:729
msgid ""
"We used an _user-defined infix binary operator_ to improve the syntax of the "
"language."
msgstr "*独自に定義された中置2引数演算子*を使い、言語の構文を改善しました。"

#. type: Bullet: '- '
#: text/chapter14.md:729
msgid ""
"We used _phantom types_ to encode additional information in the types of our "
"data, preventing the user from providing attribute values of the wrong type."
msgstr ""
"_幻影型_ を使ってデータの型の中に追加の情報を折り込みました。これにより利用者"
"が誤った型の属性値を与えることを防いでいます。"

#. type: Bullet: '- '
#: text/chapter14.md:729
msgid ""
"We used the _free monad_ to turn our array representation of a collection of "
"content into a monadic representation supporting do notation. We then "
"extended this representation to support a new monadic action, and "
"interpreted the monadic computations using standard monad transformers."
msgstr ""
"_Freeモナド_ を使って内容の集まりの配列表現をdo記法に対応したモナドな表現に変"
"えました。それからこの表現を新しいモナドアクションに対応するよう拡張し、標準"
"モナド変換子を使ってモナドの計算を解釈しました。"

#. type: Plain text
#: text/chapter14.md:731
msgid ""
"These techniques all leverage PureScript's module and type systems, either "
"to prevent the user from making mistakes or to improve the syntax of the "
"domain-specific language."
msgstr ""
"これらの手法は全て、使用者が間違いを犯すのを防いだり領域特化言語の構文を改良"
"したりするために、PureScriptのモジュールと型システムを活用しています。"

#. type: Plain text
#: text/chapter14.md:732
msgid ""
"The implementation of domain-specific languages in functional programming "
"languages is an area of active research, but hopefully this provides a "
"useful introduction some simple techniques, and illustrates the power of "
"working in a language with expressive types."
msgstr ""
"関数型プログラミング言語による領域特化言語の実装は活発に研究されている分野で"
"すが、幾つかの簡単な技法に対して役に立つ導入を提供し、表現力豊かな型を持つ言"
"語で作業することの威力を示すことができていれば幸いです。"

#. type: Title #
#: text/chapter2.md:1
#, no-wrap
msgid "Getting Started"
msgstr "はじめよう"

#. type: Plain text
#: text/chapter2.md:6
msgid ""
"In this chapter, we'll set up a working PureScript development environment, "
"solve some exercises, and use the tests provided with this book to check our "
"answers. You may also find a [video walkthrough of this chapter](https://www."
"youtube.com/watch?v=GPjPwb6d-70) helpful if that better suits your learning "
"style."
msgstr ""
"この章では実際のPureScriptの開発環境を立ち上げ、幾つかの演習を解き、この本で"
"提供されているテストを使って答えを確認します。\n"
"もし映像を見る学習の仕方が合っているようでしたら、[この章を通しで進めるビデ"
"オ](https://www.youtube.com/watch?v=GPjPwb6d-70)が役に立つでしょう。"

#. type: Title ##
#: text/chapter2.md:7
#, no-wrap
msgid "Environment Setup"
msgstr "環境構築"

#. type: Plain text
#: text/chapter2.md:10
msgid ""
"First, work through this [Getting Started Guide](https://github.com/"
"purescript/documentation/blob/master/guides/Getting-Started.md) in the "
"Documentation Repo to setup your environment and learn a few basics about "
"the language. Don't worry if the code in the example solution to the "
"[Project Euler](http://projecteuler.net/problem=1) problem is confusing or "
"contains unfamiliar syntax. We'll cover all of this in great detail in the "
"upcoming chapters."
msgstr ""
"最初にドキュメンテーションリポジトリにあるこの[はじめの手引き](https://"
"github.com/purescript/documentation/blob/master/guides/Getting-Started.md)を"
"通しで進め、環境の構築と言語の基礎を学んでください。[Project Euler](http://"
"projecteuler.net/problem=1)の解答例にあるコードがわかりにくかったり見慣れない"
"構文を含んでいたとしても心配要りません。来たる章でこの全ての内容をとても丁寧"
"に押さえていきます。"

#. type: Title ##
#: text/chapter2.md:11
#, no-wrap
msgid "Solving Exercises"
msgstr "演習を解く"

#. type: Plain text
#: text/chapter2.md:14
msgid ""
"Now that you've installed the necessary development tools, clone this book's "
"repo."
msgstr ""
"ここまでで必要な開発ツールをインストールできているので、この本のリポジトリを"
"クローンしてください。"

#. type: Fenced code block (sh)
#: text/chapter2.md:15
#, no-wrap
msgid "git clone https://github.com/purescript-contrib/purescript-book.git\n"
msgstr "git clone https://github.com/purescript-contrib/purescript-book.git\n"

#. type: Plain text
#: text/chapter2.md:20
msgid ""
"The book repo contains PureScript example code and unit tests for the "
"exercises that accompany each chapter. There's some initial setup required "
"to reset the exercise solutions so they are ready to be solved by you. Use "
"the `resetSolutions.sh` script to simplify this process. While you're at it, "
"you should also strip out all the anchor comments with the `removeAnchors."
"sh` script (these anchors are used for copying code snippets into the book's "
"rendered markdown, and you probably don't need this clutter in your local "
"repo):"
msgstr ""
"本のリポジトリにはPureScriptのコード例とそれぞれの章に付属する演習のための単"
"体テストが含まれます。演習の解法を白紙に戻すために必要な初期設定があり、この"
"設定をすることで解く準備ができます。この工程は`resetSolutions.sh`スクリプトを"
"使えば簡単にできます。また`removeAnchors.sh`スクリプトで全てのアンカーコメン"
"トを取り除いておくのもよいでしょう（これらのアンカーはコードスニペットを本の"
"変換後のMarkdownにコピーするために使われており、自分のローカルリポジトリでは"
"このアンカーで散らかっていないほうがよいでしょう）。"

#. type: Fenced code block (sh)
#: text/chapter2.md:21
#, no-wrap
msgid ""
"cd purescript-book\n"
"./scripts/resetSolutions.sh\n"
"./scripts/removeAnchors.sh\n"
"git add .\n"
"git commit --all --message \"Exercises ready to be solved\"\n"
msgstr ""
"cd purescript-book\n"
"./scripts/resetSolutions.sh\n"
"./scripts/removeAnchors.sh\n"
"git add .\n"
"git commit --all --message \"Exercises ready to be solved\"\n"

#. type: Plain text
#: text/chapter2.md:30
msgid "Now run the tests for this chapter:"
msgstr "それではこの章のテストを走らせましょう。"

#. type: Fenced code block (sh)
#: text/chapter2.md:31
#, no-wrap
msgid ""
"cd exercises/chapter2\n"
"spago test\n"
msgstr ""
"cd exercises/chapter2\n"
"spago test\n"

#. type: Plain text
#: text/chapter2.md:37
msgid "You should see the following successful test output:"
msgstr "以下の成功した旨のテスト出力が出るでしょう。"

#. type: Fenced code block (sh)
#: text/chapter2.md:38
#, no-wrap
msgid ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"\n"
"All 2 tests passed! 🎉\n"
msgstr ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"\n"
"All 2 tests passed! 🎉\n"

#. type: Plain text
#: text/chapter2.md:47
msgid ""
"Note that the `answer` function (found in `src/Euler.purs`) has been "
"modified to find the multiples of 3 and 5 below any integer. The test suite "
"(found in `test/Main.purs`) for this `answer` function is more comprehensive "
"than the test in the earlier getting-started guide. Don't worry about "
"understanding how this test framework code works while reading these early "
"chapters."
msgstr ""
"なお、`answer`関数（`src/Euler.purs`にあります）は、任意の整数以下の3と5の倍"
"数を見付けるように変更されています。\n"
"この`answer`関数のためのテストスート（`test/Main.purs`にあります）ははじめの"
"手引きの冒頭にあるテストよりも網羅的です。\n"
"はじめの章を読んでいる間はこのテストフレームワークの仕組みを理解しようと思い"
"詰めなくて大丈夫です。"

#. type: Plain text
#: text/chapter2.md:49
msgid ""
"The remainder of the book contains lots of exercises. If you write your "
"solutions in the `Test.MySolutions` module (`test/MySolutions.purs`), you "
"can check your work against the provided test suite."
msgstr ""
"本の残りの部分には多くの演習が含まれます。\n"
"`Test.MySolutions`モジュール (`test/MySolutions.purs`) に自分の解法を書けば、"
"提供されているテストスートを使って確認できます。"

#. type: Plain text
#: text/chapter2.md:51
msgid ""
"Let's work through this next exercise together in test-driven-development "
"style."
msgstr "テスト駆動開発のスタイルでこの次の演習を一緒に進めてみましょう。"

#. type: Title ##
#: text/chapter2.md:52
#, no-wrap
msgid "Exercise"
msgstr "演習"

#. type: Bullet: '1. '
#: text/chapter2.md:55
msgid ""
"(Medium) Write a `diagonal` function to compute the length of the diagonal "
"(or hypotenuse) of a right-angled triangle when given the lengths of the two "
"other sides."
msgstr ""
"（普通）直角三角形の対角線（あるいは斜辺）の長さを他の2つの辺の長さを使って計"
"算する`diagonal`関数を書いてください。"

#. type: Title ##
#: text/chapter2.md:56
#, no-wrap
msgid "Solution"
msgstr "解法"

#. type: Plain text
#: text/chapter2.md:59
msgid ""
"We'll start by enabling the tests for this exercise. Move the start of the "
"block-comment down a few lines as shown below. Block comments start with `{-"
"` and end with `-}`:"
msgstr ""
"この演習のテストを有効にするところから始めます。\n"
"以下に示すようにブロックコメントの開始を数行下に下げてください。\n"
"ブロックコメントは`{-`から始まり`-}`で終わります。"

#. type: Fenced code block (hs)
#: text/chapter2.md:60
#, no-wrap
msgid ""
"{{#include ../exercises/chapter2/test/Main.purs:diagonalTests}}\n"
"    {-  Move this block comment starting point to enable more tests\n"
msgstr ""
"{{#include ../exercises/chapter2/test/Main.purs:diagonalTests}}\n"
"    {-  Move this block comment starting point to enable more tests\n"

#. type: Plain text
#: text/chapter2.md:66
msgid ""
"If we attempt to run the test now, we'll encounter a compilation error "
"because we have not yet implemented our `diagonal` function."
msgstr ""
"ここでテストを走らせようとすると、コンパイルエラーに直面します。\n"
"なぜなら`diagonal`関数をまだ実装していないからです。"

#. type: Fenced code block (sh)
#: text/chapter2.md:67
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Error found:\n"
"in module Test.Main\n"
"at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)\n"
"\n"
"  Unknown value diagonal\n"
msgstr ""
"$ spago test\n"
"\n"
"Error found:\n"
"in module Test.Main\n"
"at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)\n"
"\n"
"  Unknown value diagonal\n"

#. type: Plain text
#: text/chapter2.md:78
msgid ""
"Let's first take a look at what happens with a faulty version of this "
"function. Add the following code to `test/MySolutions.purs`:"
msgstr ""
"まずは、この関数が欠陥のあるバージョンになっているときに何が起こるのか見てみ"
"ましょう。以下のコードを`test/MySolutions.purs`に追加してください。"

#. type: Fenced code block (hs)
#: text/chapter2.md:79
#, no-wrap
msgid ""
"import Data.Number (sqrt)\n"
"\n"
"diagonal w h = sqrt (w * w + h)\n"
msgstr ""
"import Data.Number (sqrt)\n"
"\n"
"diagonal w h = sqrt (w * w + h)\n"

#. type: Plain text
#: text/chapter2.md:86
msgid "And check our work by running `spago test`:"
msgstr "そして`spago test`を走らせて確認してください。"

#. type: Fenced code block (hs)
#: text/chapter2.md:87
#, no-wrap
msgid ""
"→ Suite: diagonal\n"
"  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989\n"
"  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219\n"
"\n"
"2 tests failed:\n"
msgstr ""
"→ Suite: diagonal\n"
"  ☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989\n"
"  ☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219\n"
"\n"
"2 tests failed:\n"

#. type: Plain text
#: text/chapter2.md:96
msgid ""
"Uh-oh, that's not quite right. Let's fix this with the correct application "
"of the Pythagorean formula by changing the function to:"
msgstr ""
"あーあ、全然正しくありませんでした。\n"
"ピタゴラスの定理を正しく適用して修正しましょう。\n"
"関数を以下のように変えます。"

#. type: Fenced code block (hs)
#: text/chapter2.md:97
#, no-wrap
msgid "{{#include ../exercises/chapter2/test/no-peeking/Solutions.purs:diagonal}}\n"
msgstr "{{#include ../exercises/chapter2/test/no-peeking/Solutions.purs:diagonal}}\n"

#. type: Plain text
#: text/chapter2.md:102
msgid "Trying `spago test` again now shows all tests are passing:"
msgstr "ここでもう一度`spago test`としてみると全てのテストが通っています。"

#. type: Fenced code block (hs)
#: text/chapter2.md:103
#, no-wrap
msgid ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"→ Suite: diagonal\n"
"  ✓ Passed: 3 4 5\n"
"  ✓ Passed: 5 12 13\n"
"\n"
"All 4 tests passed! 🎉\n"
msgstr ""
"→ Suite: Euler - Sum of Multiples\n"
"  ✓ Passed: below 10\n"
"  ✓ Passed: below 1000\n"
"→ Suite: diagonal\n"
"  ✓ Passed: 3 4 5\n"
"  ✓ Passed: 5 12 13\n"
"\n"
"All 4 tests passed! 🎉\n"

#. type: Plain text
#: text/chapter2.md:115
msgid "Success! Now you're ready to try these next exercises on your own."
msgstr ""
"成功です。\n"
"これで次の演習を自力で解くための準備ができました。"

#. type: Bullet: ' 1. '
#: text/chapter2.md:120
msgid ""
"(Easy) Write a function `circleArea` which computes the area of a circle "
"with a given radius. Use the `pi` constant, which is defined in the "
"`Numbers` module. _Hint_: don't forget to import `pi` by modifying the "
"`import Data.Number` statement."
msgstr ""
"（簡単）指定された半径の円の面積を計算する関数`circleArea`を書いてみましょ"
"う。\n"
"`Numbers`モジュールで定義されている `pi`定数を使用してください。\n"
"*手掛かり*： `import Data.Number`文を修正して、 `pi`をインポートすることを忘"
"れないようにしましょう。"

#. type: Bullet: ' 1. '
#: text/chapter2.md:120
msgid ""
"(Medium) Write a function `leftoverCents` which takes an `Int` and returns "
"what's leftover after dividing by `100`. Use the `rem` function. Search "
"[Pursuit](https://pursuit.purescript.org/) for this function to learn about "
"usage and which module to import it from. _Note:_ Your IDE may support auto-"
"importing of this function if you accept the auto-completion suggestion."
msgstr ""
"（普通）`Int`を取って`100`で割ったあとの余りを返す関数`leftoverCents`を書いて"
"みましょう。`rem`関数を使ってください。[Pursuit](https://pursuit.purescript."
"org/)でこの関数を検索して、使用法とどのモジュールからインポートしてくるか調べ"
"ましょう。*補足*：自動補完の提案を有効にしていたら、IDE側でこの関数の自動的な"
"インポートに対応しているかもしれません。"

#. type: Plain text
#: text/chapter2.md:124
msgid ""
"In this chapter, we installed the PureScript compiler and the Spago tool. We "
"also learned how to write solutions to exercises and check these for "
"correctness."
msgstr ""
"この章ではPureScriptコンパイラとSpagoツールをインストールしました。\n"
"演習の解答の書き方と正しさの確認方法も学びました。"

#. type: Plain text
#: text/chapter2.md:126
msgid ""
"There will be many more exercises in the chapters ahead, and working through "
"those really helps with learning the material. If you're stumped by any of "
"the exercises, please reach out to any of the community resources listed in "
"the [Getting Help](https://book.purescript.org/chapter1.html#getting-help) "
"section of this book, or even file an issue in this [book's repo](https://"
"github.com/purescript-contrib/purescript-book/issues). This reader feedback "
"on which exercises could be made more approachable helps us improve the book."
msgstr ""
"この先の章にはもっと沢山の演習があり、それらに取り組むうちに学習の助けになっ"
"ているでしょう。\n"
"演習のどこかでお手上げになったら、この本の[困ったときは](chapter1.ja."
"md#getting-help)の節に挙げられているコミュニティの資料のどれかを見てみたり、"
"この[本のリポジトリ](https://github.com/purescript-contrib/purescript-book/"
"issues)にイシューを報告したりできます。\n"
"こうした演習の敷居を下げることに繋がる読者のフィードバックが、本の向上の助け"
"になっています。"

#. type: Plain text
#: text/chapter2.md:128
msgid ""
"Once you solve all the exercises in a chapter, you may compare your answers "
"against those in the `no-peeking/Solutions.purs`. No peeking please without "
"putting in an honest effort to solve these yourself though. And even if you "
"are stuck, try asking a community member for help first, as we would prefer "
"to give you a small hint rather than spoil the exercise. If you found a more "
"elegant solution (that still only requires knowledge of covered content), "
"please send us a PR."
msgstr ""
"章の全ての演習を解いたら、`no-peeking/Solutions.purs`にあるものと解答とを比べ"
"られます。\n"
"ただしカンニングしてはだめで、これらの演習を誠実に自力で解く労力を払わないこ"
"とがないようにしてください。\n"
"そしてたとえ行き詰まったにしても、まずはコミュニティメンバーに尋ねてみるよう"
"にしてください。\n"
"演習のネタバレをするよりも、小さな手掛かりをあげたいからです。\n"
"もっとエレガントな解法（とはいえ本の内容で押さえられている知識のみを必要とす"
"るもの）を見つけたときはPRを送ってください。"

#. type: Plain text
#: text/chapter2.md:129
msgid ""
"The repo is continuously being revised, so be sure to check for updates "
"before starting each new chapter."
msgstr ""
"リポジトリは継続して改訂されているため、それぞれの新しい章を始める前に更新を"
"確認するようにしてください。"

#. type: Title #
#: text/chapter3.md:1
#, no-wrap
msgid "Functions and Records"
msgstr "関数とレコード"

#. type: Plain text
#: text/chapter3.md:6
msgid ""
"This chapter will introduce two building blocks of PureScript programs: "
"functions and records. In addition, we'll see how to structure PureScript "
"programs, and how to use types as an aid to program development."
msgstr ""
"この章では、関数及びレコードというPureScriptプログラムの2つの構成要素を導入し"
"ます。更に、どのようにPureScriptプログラムを構造化するのか、どのように型をプ"
"ログラム開発に役立てるかを見ていきます。"

#. type: Plain text
#: text/chapter3.md:8
msgid ""
"We will build a simple address book application to manage a list of "
"contacts. This code will introduce some new ideas from the syntax of "
"PureScript."
msgstr ""
"連絡先のリストを管理する簡単な住所録アプリケーションを作成していきます。\n"
"このコード例により、PureScriptの構文から幾つかの新しい概念を導入します。"

#. type: Plain text
#: text/chapter3.md:10
msgid ""
"The front-end of our application will be the interactive mode PSCi, but it "
"would be possible to build on this code to write a front-end in JavaScript. "
"In fact, we will do exactly that in later chapters, adding form validation "
"and save/restore functionality."
msgstr ""
"このアプリケーションのフロントエンドは対話式モードであるPSCiを使うようにして"
"いますが、このコードを土台にJavaScriptでフロントエンドを書くこともできるで"
"しょう。\n"
"実際に後の章で、フォームの検証と保存及び復元の機能を追加します。"

#. type: Plain text
#: text/chapter3.md:14
msgid ""
"The source code for this chapter is contained in the file `src/Data/"
"AddressBook.purs`. This file starts with a module declaration and its import "
"list:"
msgstr ""
"この章のソースコードは `src/Data/AddressBook.purs`というファイルに含まれてい"
"ます。\n"
"このファイルは次のようなモジュール宣言とインポート一覧から始まります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:15
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:imports}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:imports}}\n"

#. type: Plain text
#: text/chapter3.md:20
msgid "Here, we import several modules:"
msgstr "ここでは、幾つかのモジュールをインポートします。"

#. type: Bullet: '- '
#: text/chapter3.md:24
msgid "The `Control.Plus` module, which defines the `empty` value."
msgstr "`Control.Plus`モジュールには`empty`値が定義されています。"

#. type: Bullet: '- '
#: text/chapter3.md:24
msgid ""
"The `Data.List` module, which is provided by the `lists` package which can "
"be installed using Spago. It contains a few functions which we will need for "
"working with linked lists."
msgstr ""
"`Data.List`モジュールは`lists`パッケージで提供されておりSpagoを使ってインス"
"トールできます。\n"
"連結リストを使うために必要な幾つかの関数が含まれています。"

#. type: Bullet: '- '
#: text/chapter3.md:24
msgid ""
"The `Data.Maybe` module, which defines data types and functions for working "
"with optional values."
msgstr ""
"`Data.Maybe`モジュールは、オプショナルな値を扱うためのデータ型と関数を定義し"
"ています。"

#. type: Plain text
#: text/chapter3.md:26
msgid ""
"Notice that the imports for these modules are listed explicitly in "
"parentheses. This is generally a good practice, as it helps to avoid "
"conflicting imports."
msgstr ""
"このモジュールのインポート内容が括弧内で明示的に列挙されていることに注目して"
"ください。明示的な列挙はインポート内容の衝突を避けるのに役に立つので、一般に"
"良い習慣です。"

#. type: Plain text
#: text/chapter3.md:28
msgid ""
"Assuming you have cloned the book's source code repository, the project for "
"this chapter can be built using Spago, with the following commands:"
msgstr ""
"ソースコードリポジトリをクローンしたと仮定すると、この章のプロジェクトは次の"
"コマンドでSpagoを使用して構築できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:29
#, no-wrap
msgid ""
"$ cd chapter3\n"
"$ spago build\n"
msgstr ""
"$ cd chapter3\n"
"$ spago build\n"

#. type: Title ##
#: text/chapter3.md:34
#, no-wrap
msgid "Simple Types"
msgstr "単純な型"

#. type: Plain text
#: text/chapter3.md:37
msgid ""
"PureScript defines three built-in types which correspond to JavaScript's "
"primitive types: numbers, strings and booleans. These are defined in the "
"`Prim` module, which is implicitly imported by every module. They are called "
"`Number`, `String`, and `Boolean`, respectively, and you can see them in "
"PSCi by using the `:type` command to print the types of some simple values:"
msgstr ""
"JavaScriptのプリミティブ型に対応する組み込みデータ型として、PureScriptでは数"
"値型と文字列型、真偽型の3つが定義されています。\n"
"これらは`Prim`モジュールで定義されており、全てのモジュールに暗黙にインポート"
"されます。\n"
"これらはそれぞれ `Number`、 `String`、 `Boolean`と呼ばれており、PSCiで`:type`"
"コマンドを使うと簡単な値の型を表示させて確認できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:38
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :type 1.0\n"
"Number\n"
"\n"
"> :type \"test\"\n"
"String\n"
"\n"
"> :type true\n"
"Boolean\n"
msgstr ""
"$ spago repl\n"
"\n"
"> :type 1.0\n"
"Number\n"
"\n"
"> :type \"test\"\n"
"String\n"
"\n"
"> :type true\n"
"Boolean\n"

#. type: Plain text
#: text/chapter3.md:52
msgid ""
"PureScript defines some other built-in types: integers, characters, arrays, "
"records, and functions."
msgstr ""
"PureScriptには他にも、整数、文字、配列、レコード、関数といった組み込み型が定"
"義されています。"

#. type: Plain text
#: text/chapter3.md:54
msgid ""
"Integers are differentiated from floating point values of type `Number` by "
"the lack of a decimal point:"
msgstr ""
"小数点以下を省くと整数になり、型 `Number`の浮動小数点数の値と区別されます。"

#. type: Fenced code block (text)
#: text/chapter3.md:55
#, no-wrap
msgid ""
"> :type 1\n"
"Int\n"
msgstr ""
"> :type 1\n"
"Int\n"

#. type: Plain text
#: text/chapter3.md:61
msgid ""
"Character literals are wrapped in single quotes, unlike string literals "
"which use double quotes:"
msgstr ""
"二重引用符を使用する文字列直値とは異なり、文字直値は一重引用符で囲みます。"

#. type: Fenced code block (text)
#: text/chapter3.md:62
#, no-wrap
msgid ""
"> :type 'a'\n"
"Char\n"
msgstr ""
"> :type 'a'\n"
"Char\n"

#. type: Plain text
#: text/chapter3.md:68
msgid ""
"Arrays correspond to JavaScript arrays, but unlike in JavaScript, all "
"elements of a PureScript array must have the same type:"
msgstr ""
"配列はJavaScriptの配列に対応していますが、JavaScriptの配列とは異なり、"
"PureScriptの配列の全ての要素は同じ型を持つ必要があります。"

#. type: Fenced code block (text)
#: text/chapter3.md:69
#, no-wrap
msgid ""
"> :type [1, 2, 3]\n"
"Array Int\n"
"\n"
"> :type [true, false]\n"
"Array Boolean\n"
"\n"
"> :type [1, false]\n"
"Could not match type Int with type Boolean.\n"
msgstr ""
"> :type [1, 2, 3]\n"
"Array Int\n"
"\n"
"> :type [true, false]\n"
"Array Boolean\n"
"\n"
"> :type [1, false]\n"
"Could not match type Int with type Boolean.\n"

#. type: Plain text
#: text/chapter3.md:81
msgid ""
"The error in the last example is an error from the type checker, which "
"unsuccessfully attempted to _unify_ (i.e. make equal) the types of the two "
"elements."
msgstr ""
"最後の例で起きているエラーは型検証器によって報告されたもので、配列の2つの要素"
"の型を*単一化*（Unification、等価にする意）しようとして失敗したことを示してい"
"ます。"

#. type: Plain text
#: text/chapter3.md:83
msgid ""
"Records correspond to JavaScript's objects, and record literals have the "
"same syntax as JavaScript's object literals:"
msgstr ""
"レコードはJavaScriptのオブジェクトに対応しており、レコード直値はJavaScriptの"
"オブジェクト直値と同じ構文になっています。"

#. type: Fenced code block (text)
#: text/chapter3.md:84
#, no-wrap
msgid ""
"> author = { name: \"Phil\", interests: [\"Functional Programming\", \"JavaScript\"] }\n"
"\n"
"> :type author\n"
"{ name :: String\n"
", interests :: Array String\n"
"}\n"
msgstr ""
"> author = { name: \"Phil\", interests: [\"Functional Programming\", \"JavaScript\"] }\n"
"\n"
"> :type author\n"
"{ name :: String\n"
", interests :: Array String\n"
"}\n"

#. type: Plain text
#: text/chapter3.md:94
msgid ""
"This type indicates that the specified object has two _fields_, a `name` "
"field which has type `String`, and an `interests` field, which has type "
"`Array String`, i.e. an array of `String`s."
msgstr ""
"この型が示しているのは、指定されたオブジェクトは、 `String`型のフィールド "
"`name` と `Array String`つまり `String`の配列の型のフィールド `interests` と"
"いう2つの _フィールド_ (field) を持っているということです。"

#. type: Plain text
#: text/chapter3.md:96
msgid ""
"Fields of records can be accessed using a dot, followed by the label of the "
"field to access:"
msgstr ""
"ドットに続けて参照したいフィールドのラベルを書くとレコードのフィールドを参照"
"できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:97
#, no-wrap
msgid ""
"> author.name\n"
"\"Phil\"\n"
"\n"
"> author.interests\n"
"[\"Functional Programming\",\"JavaScript\"]\n"
msgstr ""
"> author.name\n"
"\"Phil\"\n"
"\n"
"> author.interests\n"
"[\"Functional Programming\",\"JavaScript\"]\n"

#. type: Plain text
#: text/chapter3.md:106
msgid ""
"PureScript's functions correspond to JavaScript's functions. The PureScript "
"standard libraries provide plenty of examples of functions, and we will see "
"more in this chapter:"
msgstr ""
"PureScriptの関数はJavaScriptの関数に対応しています。PureScriptの標準ライブラ"
"リは多くの関数の例を提供しており、この章ではそれらをもう少し詳しく見ていきま"
"す。"

#. type: Fenced code block (text)
#: text/chapter3.md:107
#, no-wrap
msgid ""
"> import Prelude\n"
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"
"\n"
"> :type const\n"
"forall a b. a -> b -> a\n"
msgstr ""
"> import Prelude\n"
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"
"\n"
"> :type const\n"
"forall a b. a -> b -> a\n"

#. type: Plain text
#: text/chapter3.md:117
msgid ""
"Functions can be defined at the top-level of a file by specifying arguments "
"before the equals sign:"
msgstr ""
"ファイルのトップレベルでは、等号の直前に引数を指定することで関数を定義できま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:118
#, no-wrap
msgid ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"
msgstr ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"

#. type: Plain text
#: text/chapter3.md:124
msgid ""
"Alternatively, functions can be defined inline, by using a backslash "
"character followed by a space-delimited list of argument names. To enter a "
"multi-line declaration in PSCi, we can enter \"paste mode\" by using the `:"
"paste` command. In this mode, declarations are terminated using the _Control-"
"D_ key sequence:"
msgstr ""
"バックスラッシュに続けて空白文字で区切られた引数名のリストを書くことで、関数"
"をインラインでも定義できます。\n"
"PSCiで複数行の宣言を入力するには、 `:paste`コマンドを使用して「貼り付けモー"
"ド」に入ります。\n"
"このモードでは、*Control-D*キーシーケンスを使用して宣言を終了します。"

#. type: Fenced code block (text)
#: text/chapter3.md:125
#, no-wrap
msgid ""
"> :paste\n"
"… add :: Int -> Int -> Int\n"
"… add = \\x y -> x + y\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… add :: Int -> Int -> Int\n"
"… add = \\x y -> x + y\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:133
msgid ""
"Having defined this function in PSCi, we can _apply_ it to its arguments by "
"separating the two arguments from the function name by whitespace:"
msgstr ""
"PSCiでこの関数が定義されていると、次のように関数の隣に2つの引数を空白で区切っ"
"て書くことで、関数をこれらの引数に*適用* (apply) できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:134
#, no-wrap
msgid ""
"> add 10 20\n"
"30\n"
msgstr ""
"> add 10 20\n"
"30\n"

#. type: Title ##
#: text/chapter3.md:139
#, no-wrap
msgid "Quantified Types"
msgstr "量化された型"

#. type: Plain text
#: text/chapter3.md:142
msgid ""
"In the previous section, we saw the types of some functions defined in the "
"Prelude. For example, the `flip` function had the following type:"
msgstr ""
"前の節ではPreludeで定義された関数の型を幾つか見てきました。\n"
"例えば`flip`関数は次のような型を持っていました。"

#. type: Fenced code block (text)
#: text/chapter3.md:143
#, no-wrap
msgid ""
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"
msgstr ""
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"

#. type: Plain text
#: text/chapter3.md:149
msgid ""
"The keyword `forall` here indicates that `flip` has a _universally "
"quantified type_. It means that we can substitute any types for `a`, `b` and "
"`c`, and `flip` will work with those types."
msgstr ""
"この `forall`キーワードは、 `flip`が _全称量化された型_ (universally "
"quantified type) を持っていることを示しています。これは、 `a`や `b`、 `c`をど"
"の型に置き換えても、 `flip`はその型でうまく動作するという意味です。"

#. type: Plain text
#: text/chapter3.md:151
msgid ""
"For example, we might choose the type `a` to be `Int`, `b` to be `String` "
"and `c` to be `String`. In that case we could _specialize_ the type of "
"`flip` to"
msgstr ""
"例えば、 `a`を `Int`、 `b`を `String`、 `c`を `String`というように選んでみた"
"とします。この場合、 `flip`の型を次のように*特殊化* (specialize) できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:152
#, no-wrap
msgid "(Int -> String -> String) -> String -> Int -> String\n"
msgstr "(Int -> String -> String) -> String -> Int -> String\n"

#. type: Plain text
#: text/chapter3.md:157
msgid ""
"We don't have to indicate in code that we want to specialize a quantified "
"type - it happens automatically. For example, we can just use `flip` as if "
"it had this type already:"
msgstr ""
"量化された型を特殊化したいということをコードで示す必要はありません。\n"
"特殊化は自動的に行われます。\n"
"例えば次のように単に`flip`を使用できます。\n"
"あたかも既にその型の`flip`を持っていたかのようです。"

#. type: Fenced code block (text)
#: text/chapter3.md:158
#, no-wrap
msgid ""
"> flip (\\n s -> show n <> s) \"Ten\" 10\n"
"\n"
"\"10Ten\"\n"
msgstr ""
"> flip (\\n s -> show n <> s) \"Ten\" 10\n"
"\n"
"\"10Ten\"\n"

#. type: Plain text
#: text/chapter3.md:165
msgid ""
"While we can choose any types for `a`, `b` and `c`, we have to be "
"consistent. The type of the function we passed to `flip` had to be "
"consistent with the types of the other arguments. That is why we passed the "
"string `\"Ten\"` as the second argument, and the number `10` as the third. "
"It would not work if the arguments were reversed:"
msgstr ""
"`a`、 `b`、 `c`の型はどんな型でも選ぶことができるといっても、型の不整合は生じ"
"ないようにしなければなりません。\n"
"`flip`に渡す関数の型は、他の引数の型と整合性がなくてはなりません。\n"
"第2引数として文字列 `\"Ten\"`、第3引数として数 `10`を渡したのはそれが理由で"
"す。\n"
"もし引数が逆になっているとうまくいかないでしょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:166
#, no-wrap
msgid ""
"> flip (\\n s -> show n <> s) 10 \"Ten\"\n"
"\n"
"Could not match type Int with type String\n"
msgstr ""
"> flip (\\n s -> show n <> s) 10 \"Ten\"\n"
"\n"
"Could not match type Int with type String\n"

#. type: Title ##
#: text/chapter3.md:172
#, no-wrap
msgid "Notes On Indentation"
msgstr "字下げについての注意"

#. type: Plain text
#: text/chapter3.md:175
msgid ""
"PureScript code is _indentation-sensitive_, just like Haskell, but unlike "
"JavaScript. This means that the whitespace in your code is not meaningless, "
"but rather is used to group regions of code, just like curly braces in C-"
"like languages."
msgstr ""
"PureScriptのコードは字下げの大きさに意味があります。ちょうどHaskellと同じで、"
"JavaScriptとは異なります。コード内の空白の多寡は無意味ではなく、Cのような言語"
"で中括弧によってコードのまとまりを示しているように、PureScriptでは空白がコー"
"ドのまとまりを示すために使われているということです。"

#. type: Plain text
#: text/chapter3.md:177
msgid ""
"If a declaration spans multiple lines, then any lines except the first must "
"be indented past the indentation level of the first line."
msgstr ""
"宣言が複数行にわたる場合は、最初の行以外は最初の行の字下げより深くしなければ"
"なりません。"

#. type: Plain text
#: text/chapter3.md:179
msgid "Therefore, the following is valid PureScript code:"
msgstr "したがって、次は正しいPureScriptコードです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:180
#, no-wrap
msgid ""
"add x y z = x +\n"
"  y + z\n"
msgstr ""
"add x y z = x +\n"
"  y + z\n"

#. type: Plain text
#: text/chapter3.md:186
msgid "But this is not valid code:"
msgstr "しかし、次は正しいコードではありません。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:187
#, no-wrap
msgid ""
"add x y z = x +\n"
"y + z\n"
msgstr ""
"add x y z = x +\n"
"y + z\n"

#. type: Plain text
#: text/chapter3.md:193
msgid ""
"In the second case, the PureScript compiler will try to parse _two_ "
"declarations, one for each line."
msgstr ""
"後者では、PureScriptコンパイラはそれぞれの行ごとに1つ、つまり*2つ*の宣言であ"
"ると構文解析します。"

#. type: Plain text
#: text/chapter3.md:195
msgid ""
"Generally, any declarations defined in the same block should be indented at "
"the same level. For example, in PSCi, declarations in a let statement must "
"be indented equally. This is valid:"
msgstr ""
"一般に、同じブロック内で定義された宣言は同じ深さで字下げする必要がありま"
"す。\n"
"例えばPSCiでlet文の宣言は同じ深さで字下げしなければなりません。\n"
"次は正しいコードです。"

#. type: Fenced code block (text)
#: text/chapter3.md:196
#, no-wrap
msgid ""
"> :paste\n"
"… x = 1\n"
"… y = 2\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… x = 1\n"
"… y = 2\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:204
msgid "but this is not:"
msgstr "しかし、これは正しくありません。"

#. type: Fenced code block (text)
#: text/chapter3.md:205
#, no-wrap
msgid ""
"> :paste\n"
"… x = 1\n"
"…  y = 2\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… x = 1\n"
"…  y = 2\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:213
msgid ""
"Certain PureScript keywords (such as `where`, `of` and `let`) introduce a "
"new block of code, in which declarations must be further-indented:"
msgstr ""
"PureScriptの幾つかの予約語（例えば `where`や `of`、 `let`）は新たなコードのま"
"とまりを導入しますが、そのコードのまとまり内の宣言はそれより深く字下げされて"
"いる必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:214
#, no-wrap
msgid ""
"example x y z = foo + bar\n"
"  where\n"
"    foo = x * y\n"
"    bar = y * z\n"
msgstr ""
"example x y z = foo + bar\n"
"  where\n"
"    foo = x * y\n"
"    bar = y * z\n"

#. type: Plain text
#: text/chapter3.md:222
msgid ""
"Note how the declarations for `foo` and `bar` are indented past the "
"declaration of `example`."
msgstr ""
"ここで `foo`や `bar`の宣言は `example`の宣言より深く字下げされていることに注"
"意してください。"

#. type: Plain text
#: text/chapter3.md:224
msgid ""
"The only exception to this rule is the `where` keyword in the initial "
"`module` declaration at the top of a source file."
msgstr ""
"ただし、ソースファイルの先頭、最初の `module`宣言における予約語 `where`だけ"
"は、この規則の唯一の例外になっています。"

#. type: Title ##
#: text/chapter3.md:225
#, no-wrap
msgid "Defining Our Types"
msgstr "独自の型の定義"

#. type: Plain text
#: text/chapter3.md:228
msgid ""
"A good first step when tackling a new problem in PureScript is to write out "
"type definitions for any values you will be working with. First, let's "
"define a type for records in our address book:"
msgstr ""
"PureScriptで新たな問題に取り組むときは、まずはこれから扱おうとする値の型の定"
"義を書くことから始めるのがよいでしょう。最初に、住所録に含まれるレコードの型"
"を定義してみます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:229
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Entry}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Entry}}\n"

#. type: Plain text
#: text/chapter3.md:234
msgid ""
"This defines a _type synonym_ called `Entry` - the type `Entry` is "
"equivalent to the type on the right of the equals symbol: a record type with "
"three fields - `firstName`, `lastName` and `address`. The two name fields "
"will have type `String`, and the `address` field will have type `Address`, "
"defined as follows:"
msgstr ""
"これは `Entry`という*型同義語*（type synonym、型シノニム）を定義していま"
"す。\n"
"型 `Entry`は等号の右辺と同じ型ということです。\n"
"レコードの型は何れも文字列である `firstName`、 `lastName`、 `phone`という3つ"
"のフィールドからなります。\n"
"前者の2つのフィールドは型 `String`を持ち、 `address`は以下のように定義された"
"型 `Address`を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:235
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Address}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Address}}\n"

#. type: Plain text
#: text/chapter3.md:240
msgid "Note that records can contain other records."
msgstr "なお、レコードには他のレコードを含めることができます。"

#. type: Plain text
#: text/chapter3.md:242
msgid ""
"Now let's define a third type synonym, for our address book data structure, "
"which will be represented simply as a linked list of entries:"
msgstr ""
"それでは、3つめの型同義語も定義してみましょう。住所録のデータ構造としては、単"
"に項目の連結リストとして格納することにします。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:243
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:AddressBook}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:AddressBook}}\n"

#. type: Plain text
#: text/chapter3.md:248
msgid ""
"Note that `List Entry` is not the same as `Array Entry`, which represents an "
"_array_ of entries."
msgstr ""
"`List Entry`は `Array Entry`とは同じではないということに注意してください。 "
"`Array Entry`は住所録の項目の _配列_ を意味しています。"

#. type: Title ##
#: text/chapter3.md:249
#, no-wrap
msgid "Type Constructors and Kinds"
msgstr "型構築子と種"

#. type: Plain text
#: text/chapter3.md:252
msgid ""
"`List` is an example of a _type constructor_. Values do not have the type "
"`List` directly, but rather `List a` for some type `a`. That is, `List` "
"takes a _type argument_ `a` and _constructs_ a new type `List a`."
msgstr ""
"`List`は*型構築子*（type constructor、型コンストラクタ）の一例になっていま"
"す。`List`そのものは型ではなく、何らかの型 `a`があるとき `List a`が型になって"
"います。つまり、 `List`は _型引数_ (type argument) `a`をとり、新たな型 `List "
"a`を _構築_ するのです。"

#. type: Plain text
#: text/chapter3.md:254
msgid ""
"Note that just like function application, type constructors are applied to "
"other types simply by juxtaposition: the type `List Entry` is in fact the "
"type constructor `List` _applied_ to the type `Entry` - it represents a list "
"of entries."
msgstr ""
"ちょうど関数適用と同じように、型構築子は他の型に並べることで適用されることに"
"注意してください。型 `List Entry`は実は型構築子 `List`が型 `Entry`に _適用_ "
"されたものです。これは住所録項目のリストを表しています。"

#. type: Plain text
#: text/chapter3.md:256
msgid ""
"If we try to incorrectly define a value of type `List` (by using the type "
"annotation operator `::`), we will see a new type of error:"
msgstr ""
"もし間違って（型注釈演算子 `::`を使って）型 `List`の値を定義しようとすると、"
"今まで見たことのない種類のエラーが表示されるでしょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:257
#, no-wrap
msgid ""
"> import Data.List\n"
"> Nil :: List\n"
"In a type-annotated expression x :: t, the type t must have kind Type\n"
msgstr ""
"> import Data.List\n"
"> Nil :: List\n"
"In a type-annotated expression x :: t, the type t must have kind Type\n"

#. type: Plain text
#: text/chapter3.md:264
msgid ""
"This is a _kind error_. Just like values are distinguished by their _types_, "
"types are distinguished by their _kinds_, and just like ill-typed values "
"result in _type errors_, _ill-kinded_ types result in _kind errors_."
msgstr ""
"これは*種エラー*です。値がその*型*で区別されるのと同じように、型はその*種*に"
"よって区別されます。間違った型の値が*型エラー*になるように、*間違った種*の型"
"は*種エラー*を引き起こします。"

#. type: Plain text
#: text/chapter3.md:266
msgid ""
"There is a special kind called `Type` which represents the kind of all types "
"which have values, like `Number` and `String`."
msgstr ""
"`Number`や `String`のような、値を持つ全ての型の種を表す `Type`と呼ばれる特別"
"な種があります。"

#. type: Plain text
#: text/chapter3.md:268
#, no-wrap
msgid "There are also kinds for type constructors. For example, the kind `Type -> Type` represents a function from types to types, just like `List`. So the error here occurred because values are expected to have types with kind `Type`, but `List` has kind `Type -> Type`.\n"
msgstr ""
"型構築子にも種があります。\n"
"例えば種 `Type -> Type`はちょうど `List`のような型から型への関数を表しています。\n"
"ここでエラーが発生したのは、値が種 `Type`であるような型を持つと期待されていたのに、 `List`は種 `Type -> Type`を持っているためです。\n"

#. type: Plain text
#: text/chapter3.md:270
msgid ""
"To find out the kind of a type, use the `:kind` command in PSCi. For example:"
msgstr ""
"PSCiで型の種を調べるには、 `:kind`命令を使用します。例えば次のようになりま"
"す。"

#. type: Fenced code block (text)
#: text/chapter3.md:271
#, no-wrap
msgid ""
"> :kind Number\n"
"Type\n"
"\n"
"> import Data.List\n"
"> :kind List\n"
"Type -> Type\n"
"\n"
"> :kind List String\n"
"Type\n"
msgstr ""
"> :kind Number\n"
"Type\n"
"\n"
"> import Data.List\n"
"> :kind List\n"
"Type -> Type\n"
"\n"
"> :kind List String\n"
"Type\n"

#. type: Plain text
#: text/chapter3.md:284
msgid ""
"PureScript's _kind system_ supports other interesting kinds, which we will "
"see later in the book."
msgstr ""
"PureScriptの _種システム_ は他にも面白い種に対応していますが、それらについて"
"は本書の他の部分で見ていくことになるでしょう。"

#. type: Title ##
#: text/chapter3.md:285
#, no-wrap
msgid "Displaying Address Book Entries"
msgstr "住所録の項目の表示"

#. type: Plain text
#: text/chapter3.md:288
msgid ""
"Let's write our first function, which will render an address book entry as a "
"string. We start by giving the function a type. This is optional, but good "
"practice, since it acts as a form of documentation. In fact, the PureScript "
"compiler will give a warning if a top-level declaration does not contain a "
"type annotation. A type declaration separates the name of a function from "
"its type with the `::` symbol:"
msgstr ""
"それでは最初に、文字列で住所録の項目を表現する関数を書いてみましょう。\n"
"まずは関数に型を与えることから始めます。\n"
"型の定義は省略できますが、ドキュメントとしても役立つので型を書いておくように"
"すると良いでしょう。\n"
"実際、トップレベルの宣言に型註釈が含まれていないと、PureScriptコンパイラが警"
"告を出します。\n"
"型宣言は関数の名前とその型を `::`記号で区切るようにして書きます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:289
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:294
msgid ""
"This type signature says that `showEntry` is a function, which takes an "
"`Entry` as an argument and returns a `String`. Here is the code for "
"`showEntry`:"
msgstr ""
"`showEntry`は引数として `Entry`を取り `String`を返す関数であるということを、"
"この型シグネチャは言っています。\n"
"`showEntry`のコードは次の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:295
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_implementation}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_implementation}}\n"

#. type: Plain text
#: text/chapter3.md:300
msgid ""
"This function concatenates the three fields of the `Entry` record into a "
"single string, using the `showAddress` function to turn the record inside "
"the `address` field into a `String`. `showAddress` is defined similarly:"
msgstr ""
"この関数は`Entry`レコードの3つのフィールドを連結し、単一の文字列にします。\n"
"ここで使用される`showAddress`関数は`address`フィールド中のレコードを文字列に"
"変えます。\n"
"`showAddress`の定義は次の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:301
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showAddress}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showAddress}}\n"

#. type: Plain text
#: text/chapter3.md:306
#, no-wrap
msgid "A function definition begins with the name of the function, followed by a list of argument names. The result of the function is specified after the equals sign. Fields are accessed with a dot, followed by the field name. In PureScript, string concatenation uses the diamond operator (`<>`), instead of the plus operator like in JavaScript.\n"
msgstr "関数定義は関数の名前で始まり、引数名のリストが続きます。関数の結果は等号の後ろに定義します。フィールドはドットに続けてフィールド名を書くことで参照できます。PureScriptでは、文字列連結はJavaScriptのような単一のプラス記号ではなく、ダイアモンド演算子（`<>`）を使用します。\n"

#. type: Title ##
#: text/chapter3.md:307
#, no-wrap
msgid "Test Early, Test Often"
msgstr "はやめにテスト、たびたびテスト"

#. type: Plain text
#: text/chapter3.md:310
msgid ""
"The PSCi interactive mode allows for rapid prototyping with immediate "
"feedback, so let's use it to verify that our first few functions behave as "
"expected."
msgstr ""
"PSCi対話式モードでは反応を即座に得られるので、素早い試作開発に向いていま"
"す。\n"
"それではこの最初の関数が正しく動作するかをPSCiを使用して確認してみましょう。"

#. type: Plain text
#: text/chapter3.md:312
msgid "First, build the code you've written:"
msgstr "まず、これまでに書いたコードをビルドします。"

#. type: Plain text
#: text/chapter3.md:318
msgid ""
"Next, load PSCi, and use the `import` command to import your new module:"
msgstr ""
"次に、PSCiを起動し、この新しいモジュールをインポートするために `import`命令を"
"使います。"

#. type: Fenced code block (text)
#: text/chapter3.md:319
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.AddressBook\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.AddressBook\n"

#. type: Plain text
#: text/chapter3.md:326
msgid ""
"We can create an entry by using a record literal, which looks just like an "
"anonymous object in JavaScript."
msgstr ""
"レコード直値を使うと、住所録の項目を作成できます。レコード直値はJavaScriptの"
"無名オブジェクトと同じような構文で名前に束縛します。"

#. type: Fenced code block (text)
#: text/chapter3.md:327
#, no-wrap
msgid "> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
msgstr "> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"

#. type: Plain text
#: text/chapter3.md:332
msgid "Now, try applying our function to the example:"
msgstr "それでは、この例に関数を適用してみてください。"

#. type: Fenced code block (text)
#: text/chapter3.md:333
#, no-wrap
msgid ""
"> showAddress address\n"
"\n"
"\"123 Fake St., Faketown, CA\"\n"
msgstr ""
"> showAddress address\n"
"\n"
"\"123 Fake St., Faketown, CA\"\n"

#. type: Plain text
#: text/chapter3.md:340
msgid ""
"Let's also test `showEntry` by creating an address book entry record "
"containing our example address:"
msgstr "`showEntry`も、住所の例を含む住所録項目レコードを作って試しましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:341
#, no-wrap
msgid ""
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> showEntry entry\n"
"\n"
"\"Smith, John: 123 Fake St., Faketown, CA\"\n"
msgstr ""
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> showEntry entry\n"
"\n"
"\"Smith, John: 123 Fake St., Faketown, CA\"\n"

#. type: Title ##
#: text/chapter3.md:348
#, no-wrap
msgid "Creating Address Books"
msgstr "住所録の作成"

#. type: Plain text
#: text/chapter3.md:351
msgid ""
"Now let's write some utility functions for working with address books. We "
"will need a value which represents an empty address book: an empty list."
msgstr ""
"今度は住所録の操作を支援する関数を幾つか書いてみましょう。\n"
"空の住所録を表す値が必要ですが、これには空のリストを使います。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:352
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:emptyBook}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:emptyBook}}\n"

#. type: Plain text
#: text/chapter3.md:357
msgid ""
"We will also need a function for inserting a value into an existing address "
"book. We will call this function `insertEntry`. Start by giving its type:"
msgstr ""
"既存の住所録に値を挿入する関数も必要でしょう。この関数を `insertEntry`と呼ぶ"
"ことにします。関数の型を与えることから始めましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:358
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:363
msgid ""
"This type signature says that `insertEntry` takes an `Entry` as its first "
"argument, and an `AddressBook` as a second argument, and returns a new "
"`AddressBook`."
msgstr ""
"この型シグネチャに書かれているのは、最初の引数として `Entry`、第二引数として "
"`AddressBook`を取り、新しい `AddressBook`を返すということです。"

#. type: Plain text
#: text/chapter3.md:365
msgid ""
"We don't modify the existing `AddressBook` directly. Instead, we return a "
"new `AddressBook` which contains the same data. As such, `AddressBook` is an "
"example of an _immutable data structure_. This is an important idea in "
"PureScript - mutation is a side-effect of code, and inhibits our ability to "
"reason effectively about its behavior, so we prefer pure functions and "
"immutable data where possible."
msgstr ""
"既存の `AddressBook`を直接変更することはしません。\n"
"その代わりに、同じデータが含まれている新しい `AddressBook`を返すようにしま"
"す。\n"
"このように、 `AddressBook`は*不変データ構造*の一例となっています。\n"
"これはPureScriptにおける重要な考え方です。\n"
"変更はコードの副作用であり、効率の良いコードの挙動を考えるときの妨げになりま"
"す。\n"
"そのため、可能な限り純粋な関数や不変のデータにする方が好ましいのです。"

#. type: Plain text
#: text/chapter3.md:367
msgid ""
"To implement `insertEntry`, we can use the `Cons` function from `Data.List`. "
"To see its type, open PSCi and use the `:type` command:"
msgstr ""
"`insertEntry`を実装するのに`Data.List`の`Cons`関数が使えます。\n"
"この関数の型を見るには、PSCiを起動し `:type`コマンドを使います。"

#. type: Fenced code block (text)
#: text/chapter3.md:368
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type Cons\n"
"\n"
"forall a. a -> List a -> List a\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type Cons\n"
"\n"
"forall a. a -> List a -> List a\n"

#. type: Plain text
#: text/chapter3.md:378
msgid ""
"This type signature says that `Cons` takes a value of some type `a`, and a "
"list of elements of type `a`, and returns a new list with entries of the "
"same type. Let's specialize this with `a` as our `Entry` type:"
msgstr ""
"この型シグネチャで書かれているのは、`Cons`が何らかの型`a`の値と型`a`を要素に"
"持つリストを引数に取り、同じ型の要素を持つ新しいリストを返すということで"
"す。\n"
"`a`を`Entry`型として特殊化してみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:379
#, no-wrap
msgid "Entry -> List Entry -> List Entry\n"
msgstr "Entry -> List Entry -> List Entry\n"

#. type: Plain text
#: text/chapter3.md:384
msgid "But `List Entry` is the same as `AddressBook`, so this is equivalent to"
msgstr ""
"しかし、 `List Entry`はまさに `AddressBook`ですから、次と同じになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:385
#, no-wrap
msgid "Entry -> AddressBook -> AddressBook\n"
msgstr "Entry -> AddressBook -> AddressBook\n"

#. type: Plain text
#: text/chapter3.md:390
msgid ""
"In our case, we already have the appropriate inputs: an `Entry`, and an "
"`AddressBook`, so can apply `Cons` and get a new `AddressBook`, which is "
"exactly what we wanted!"
msgstr ""
"今回の場合、既に適切な入力があります。\n"
"`Entry`と `AddressBook`に `Cons`を適用すると、新しい `AddressBook`を得ること"
"ができます。\n"
"これこそがまさに求めていた関数です。"

#. type: Plain text
#: text/chapter3.md:392
msgid "Here is our implementation of `insertEntry`:"
msgstr "`insertEntry`の実装は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:393
#, no-wrap
msgid "insertEntry entry book = Cons entry book\n"
msgstr "insertEntry entry book = Cons entry book\n"

#. type: Plain text
#: text/chapter3.md:398
msgid ""
"This brings the two arguments `entry` and `book` into scope, on the left "
"hand side of the equals symbol, and then applies the `Cons` function to "
"create the result."
msgstr ""
"等号の左側にある2つの引数`entry`と`book`がスコープに導入されますから、これら"
"に `Cons`関数を適用して結果の値を作成しています。"

#. type: Title ##
#: text/chapter3.md:399
#, no-wrap
msgid "Curried Functions"
msgstr "カリー化された関数"

#. type: Plain text
#: text/chapter3.md:402
msgid ""
"Functions in PureScript take exactly one argument. While it looks like the "
"`insertEntry` function takes two arguments, it is in fact an example of a "
"_curried function_."
msgstr ""
"PureScriptでは、関数は常に1つの引数だけを取ります。`insertEntry`関数は2つの引"
"数を取るように見えますが、これは実際には*カリー化された関数*の一例となってい"
"ます。"

#. type: Plain text
#: text/chapter3.md:404
#, no-wrap
msgid "The `->` operator in the type of `insertEntry` associates to the right, which means that the compiler parses the type as\n"
msgstr "`insertEntry`の型に含まれる `->`は右結合の演算子であり、つまりこの型はコンパイラによって次のように解釈されます。\n"

#. type: Fenced code block (haskell)
#: text/chapter3.md:405
#, no-wrap
msgid "Entry -> (AddressBook -> AddressBook)\n"
msgstr "Entry -> (AddressBook -> AddressBook)\n"

#. type: Plain text
#: text/chapter3.md:410
msgid ""
"That is, `insertEntry` is a function which returns a function! It takes a "
"single argument, an `Entry`, and returns a new function, which in turn takes "
"a single `AddressBook` argument and returns a new `AddressBook`."
msgstr ""
"すなわち、 `insertEntry`は関数を返す関数である、ということです。\n"
"この関数は単一の引数 `Entry`を取り、それから単一の引数 `AddressBook`を取り新"
"しい `AddressBook`を返す新しい関数を返すのです。"

#. type: Plain text
#: text/chapter3.md:412
msgid ""
"This means that we can _partially apply_ `insertEntry` by specifying only "
"its first argument, for example. In PSCi, we can see the result type:"
msgstr ""
"これは例えば、最初の引数だけを与えると `insertEntry`を _部分適用_ (partial "
"application) できることを意味します。PSCiでこの結果の型を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:413
#, no-wrap
msgid ""
"> :type insertEntry entry\n"
"\n"
"AddressBook -> AddressBook\n"
msgstr ""
"> :type insertEntry entry\n"
"\n"
"AddressBook -> AddressBook\n"

#. type: Plain text
#: text/chapter3.md:420
msgid ""
"As expected, the return type was a function. We can apply the resulting "
"function to a second argument:"
msgstr ""
"期待した通り、戻り値の型は関数になっていました。\n"
"この結果の関数に2つ目の引数も適用できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:421
#, no-wrap
msgid ""
"> :type (insertEntry entry) emptyBook\n"
"AddressBook\n"
msgstr ""
"> :type (insertEntry entry) emptyBook\n"
"AddressBook\n"

#. type: Plain text
#: text/chapter3.md:427
msgid ""
"Note though that the parentheses here are unnecessary - the following is "
"equivalent:"
msgstr "ここで括弧は不要であることにも注意してください。次の式は同等です。"

#. type: Fenced code block (text)
#: text/chapter3.md:428
#, no-wrap
msgid ""
"> :type insertEntry entry emptyBook\n"
"AddressBook\n"
msgstr ""
"> :type insertEntry entry emptyBook\n"
"AddressBook\n"

#. type: Plain text
#: text/chapter3.md:434
msgid ""
"This is because function application associates to the left, and this "
"explains why we can just specify function arguments one after the other, "
"separated by whitespace."
msgstr ""
"これは関数適用が左結合であるためで、なぜ空白で区切った引数を関数に指定するだ"
"けでいいのかの説明にもなっています。"

#. type: Plain text
#: text/chapter3.md:436
#, no-wrap
msgid "The `->` operator in function types is a _type constructor_ for functions. It takes two type arguments, the function's argument type and the return type. The left and right operands respectively.\n"
msgstr ""
"関数の型の`->`演算子は関数の*型構築子*です。\n"
"この演算子は2つの型引数を取ります。\n"
"左右の被演算子はそれぞれ関数の引数の型と返り値の型です。\n"

#. type: Plain text
#: text/chapter3.md:438
msgid ""
"Note that in the rest of the book, I will talk about things like \"functions "
"of two arguments\". However, it is to be understood that this means a "
"curried function, taking a first argument and returning a function that "
"takes the second."
msgstr ""
"本書では今後、「2引数の関数」というように表現することがあることに注意してくだ"
"さい。\n"
"しかしそれはカリー化された関数を意味していると考えるべきで、その関数は最初の"
"引数を取り2つ目の引数を取る別の関数を返すのです。"

#. type: Plain text
#: text/chapter3.md:440
msgid "Now consider the definition of `insertEntry`:"
msgstr "今度は `insertEntry`の定義について考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:441
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry book = Cons entry book\n"
msgstr ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry book = Cons entry book\n"

#. type: Plain text
#: text/chapter3.md:447
msgid ""
"If we explicitly parenthesize the right-hand side, we get `(Cons entry) "
"book`. That is, `insertEntry entry` is a function whose argument is just "
"passed along to the `(Cons entry)` function. But if two functions have the "
"same result for every input, then they are the same function! So we can "
"remove the argument `book` from both sides:"
msgstr ""
"もし式の右辺に明示的に括弧をつけるなら、 `(Cons entry) book`となります。\n"
"`insertEntry entry`はその引数が単に関数 `(Cons entry)`に渡されるような関数だ"
"ということです。\n"
"でもこの2つの関数はどんな入力についても同じ結果を返しますから、つまりこれらは"
"同じ関数です。\n"
"よって、両辺から引数 `book`を削除できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:448
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry = Cons entry\n"
msgstr ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry = Cons entry\n"

#. type: Plain text
#: text/chapter3.md:454
msgid "But now, by the same argument, we can remove `entry` from both sides:"
msgstr "しかし今や同様の議論により、両辺から `entry`も削除できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:455
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry}}\n"

#. type: Plain text
#: text/chapter3.md:460
msgid ""
"This process is called _eta conversion_, and can be used (along with some "
"other techniques) to rewrite functions in _point-free form_, which means "
"functions defined without reference to their arguments."
msgstr ""
"この処理は _イータ変換_ (eta conversion) と呼ばれ、（その他の技法を併用して）"
"引数を参照することなく関数を定義する _ポイントフリー形式_ (point-free form) "
"へと関数を書き換えるのに使うことができます。"

#. type: Plain text
#: text/chapter3.md:462
msgid ""
"In the case of `insertEntry`, _eta conversion_ has resulted in a very clear "
"definition of our function - \"`insertEntry` is just cons on lists\". "
"However, it is arguable whether point-free form is better in general."
msgstr ""
"`insertEntry`の場合には、イータ変換によって「`insertEntry`は単にリストに対す"
"るconsだ」となり、関数の定義はとても明確になりました。しかし、一般的にポイン"
"トフリー形式のほうがいいのかどうかには議論の余地があります。"

#. type: Title ##
#: text/chapter3.md:463
#, no-wrap
msgid "Property Accessors"
msgstr "プロパティ取得子"

#. type: Plain text
#: text/chapter3.md:466
msgid ""
"One common pattern is to use a function to access individual fields (or "
"\"properties\") of a record. An inline function to extract an `Address` from "
"an `Entry` could be written as:"
msgstr ""
"よくあるパターンの1つとして、レコード中の個別のフィールド（または「プロパ"
"ティ」）を取得することがあります。\n"
"`Entry`から`Address`を取り出すインライン関数は次のように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:467
#, no-wrap
msgid "\\entry -> entry.address\n"
msgstr "\\entry -> entry.address\n"

#. type: Plain text
#: text/chapter3.md:472
msgid ""
"PureScript also allows [_property accessor_](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#property-accessors) shorthand, "
"where an underscore acts as the anonymous function argument, so the inline "
"function above is equivalent to:"
msgstr ""
"PureScriptでは[_プロパティ取得子_](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#property-accessors)という略記が"
"使えます。この略記では下線文字は無名関数の引数として振舞うため、上記のインラ"
"イン関数は次と等価です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:473
#, no-wrap
msgid "_.address\n"
msgstr "_.address\n"

#. type: Plain text
#: text/chapter3.md:478
msgid ""
"This works with any number of levels or properties, so a function to extract "
"the city associated with an `Entry` could be written as:"
msgstr ""
"これは何段階のプロパティでも動くため、`Entry`に関連する街を取り出す関数は次の"
"ように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:479
#, no-wrap
msgid "_.address.city\n"
msgstr "_.address.city\n"

#. type: Plain text
#: text/chapter3.md:484 text/chapter5.md:247
msgid "For example:"
msgstr "以下は一例です。"

#. type: Fenced code block (text)
#: text/chapter3.md:485
#, no-wrap
msgid ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> _.lastName entry\n"
"\"Smith\"\n"
"\n"
"> _.address.city entry\n"
"\"Faketown\"\n"
msgstr ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> _.lastName entry\n"
"\"Smith\"\n"
"\n"
"> _.address.city entry\n"
"\"Faketown\"\n"

#. type: Title ##
#: text/chapter3.md:495
#, no-wrap
msgid "Querying the Address Book"
msgstr "住所録に問い合わせる"

#. type: Plain text
#: text/chapter3.md:498
msgid ""
"The last function we need to implement for our minimal address book "
"application will look up a person by name and return the correct `Entry`. "
"This will be a nice application of building programs by composing small "
"functions - a key idea from functional programming."
msgstr ""
"最小限の住所録アプリケーションの実装で必要になる最後の関数は、名前で人を検索"
"し適切な `Entry`を返すものです。これは小さな関数を組み合わせることでプログラ"
"ムを構築するという、関数型プログラミングで鍵となる考え方のよい応用例になるで"
"しょう。"

#. type: Plain text
#: text/chapter3.md:500
msgid ""
"We can first filter the address book, keeping only those entries with the "
"correct first and last names. Then we can simply return the head (i.e. "
"first) element of the resulting list."
msgstr ""
"まずは住所録を絞り込み、該当する姓名を持つ項目だけを保持するようにするのがい"
"いでしょう。それから、結果のリストの先頭の (head) 要素を返すだけです。"

#. type: Plain text
#: text/chapter3.md:502
msgid ""
"With this high-level specification of our approach, we can calculate the "
"type of our function. First open PSCi, and find the types of the `filter` "
"and `head` functions:"
msgstr ""
"この大まかな仕様に従って、この関数の型を計算できます。まずPSCiを起動し、 "
"`filter`関数と `head`関数の型を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:503
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type filter\n"
"\n"
"forall a. (a -> Boolean) -> List a -> List a\n"
"\n"
"> :type head\n"
"\n"
"forall a. List a -> Maybe a\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type filter\n"
"\n"
"forall a. (a -> Boolean) -> List a -> List a\n"
"\n"
"> :type head\n"
"\n"
"forall a. List a -> Maybe a\n"

#. type: Plain text
#: text/chapter3.md:517
msgid "Let's pick apart these two types to understand their meaning."
msgstr ""
"型の意味を理解するために、これらの2つの型の一部を取り出してみましょう。"

#. type: Plain text
#: text/chapter3.md:519
msgid ""
"`filter` is a curried function of two arguments. Its first argument is a "
"function, which takes an element of the list and returns a `Boolean` value "
"as a result. Its second argument is a list of elements, and the return value "
"is another list."
msgstr ""
"`filter`はカリー化された2引数の関数です。\n"
"最初の引数は、リストの要素を取り `Boolean`値を結果として返す関数です。\n"
"第2引数は要素のリストで、返り値は別のリストです。"

#. type: Plain text
#: text/chapter3.md:521
msgid ""
"`head` takes a list as its argument, and returns a type we haven't seen "
"before: `Maybe a`. `Maybe a` represents an optional value of type `a`, and "
"provides a type-safe alternative to using `null` to indicate a missing value "
"in languages like JavaScript. We will see it again in more detail in later "
"chapters."
msgstr ""
"`head`は引数としてリストを取り、 `Maybe a`という今まで見たことがないような型"
"を返します。\n"
"`Maybe a`は型 `a`のオプショナルな値、つまり `a`の値を持つか持たないかのどちら"
"かの値を示しており、JavaScriptのような言語で値がないことを示すために使われる "
"`null`の型安全な代替手段を提供します。\n"
"これについては後の章で詳しく扱います。"

#. type: Plain text
#: text/chapter3.md:523
msgid ""
"The universally quantified types of `filter` and `head` can be _specialized_ "
"by the PureScript compiler, to the following types:"
msgstr ""
"`filter`と `head`の全称量化された型は、PureScriptコンパイラによって次のよう"
"に _特殊化_ (specialized) されます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:524
#, no-wrap
msgid ""
"filter :: (Entry -> Boolean) -> AddressBook -> AddressBook\n"
"\n"
"head :: AddressBook -> Maybe Entry\n"
msgstr ""
"filter :: (Entry -> Boolean) -> AddressBook -> AddressBook\n"
"\n"
"head :: AddressBook -> Maybe Entry\n"

#. type: Plain text
#: text/chapter3.md:531
msgid ""
"We know that we will need to pass the first and last names that we want to "
"search for, as arguments to our function."
msgstr "検索する関数の引数として姓と名前を渡す必要があるのもわかっています。"

#. type: Plain text
#: text/chapter3.md:533
#, no-wrap
msgid "We also know that we will need a function to pass to `filter`. Let's call this function `filterEntry`. `filterEntry` will have type `Entry -> Boolean`. The application `filter filterEntry` will then have type `AddressBook -> AddressBook`. If we pass the result of this function to the `head` function, we get our result of type `Maybe Entry`.\n"
msgstr "`filter`に渡す関数も必要になることもわかります。この関数を `filterEntry`と呼ぶことにしましょう。 `filterEntry`は `Entry -> Boolean`という型を持っています。 `filter filterEntry`という関数適用の式は、 `AddressBook -> AddressBook`という型を持つでしょう。もしこの関数の結果を `head`関数に渡すと、型 `Maybe Entry`の結果を得ることになります。\n"

#. type: Plain text
#: text/chapter3.md:535
msgid ""
"Putting these facts together, a reasonable type signature for our function, "
"which we will call `findEntry`, is:"
msgstr ""
"これまでのことを纏めると、関数の妥当な型シグネチャは次のようになります。"
"`findEntry`と呼ぶことにしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:536
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:541
msgid ""
"This type signature says that `findEntry` takes two strings, the first and "
"last names, and a `AddressBook`, and returns an optional `Entry`. The "
"optional result will contain a value only if the name is found in the "
"address book."
msgstr ""
"この型シグネチャで書かれているのは、`findEntry`が姓と名前の2つの文字列及び"
"`AddressBook`を引数に取り、`Entry`のオプション型の値を結果として返すというこ"
"とです。\n"
"オプショナルな結果は名前が住所録で発見された場合にのみ値を持ちます。"

#. type: Plain text
#: text/chapter3.md:543
msgid "And here is the definition of `findEntry`:"
msgstr "そして、 `findEntry`の定義は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:544
#, no-wrap
msgid ""
"findEntry firstName lastName book = head (filter filterEntry book)\n"
"  where\n"
"    filterEntry :: Entry -> Boolean\n"
"    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName\n"
msgstr ""
"findEntry firstName lastName book = head (filter filterEntry book)\n"
"  where\n"
"    filterEntry :: Entry -> Boolean\n"
"    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName\n"

#. type: Plain text
#: text/chapter3.md:552
msgid "Let's go over this code step by step."
msgstr "一歩ずつこのコードを調べてみましょう。"

#. type: Plain text
#: text/chapter3.md:554
msgid ""
"`findEntry` brings three names into scope: `firstName` and `lastName`, both "
"representing strings, and `book`, an `AddressBook`."
msgstr ""
"`findEntry`は、どちらも文字列型である `firstName`と `lastName`、`AddressBook`"
"型の `book`という3つの名前をスコープに導入します。"

#. type: Plain text
#: text/chapter3.md:556
msgid ""
"The right hand side of the definition combines the `filter` and `head` "
"functions: first, the list of entries is filtered, and the `head` function "
"is applied to the result."
msgstr ""
"定義の右辺では `filter`関数と `head`関数が組み合わされています。\n"
"まず項目のリストを絞り込み、その結果に `head`関数を適用しています。"

#. type: Plain text
#: text/chapter3.md:558
msgid ""
"The predicate function `filterEntry` is defined as an auxiliary declaration "
"inside a `where` clause. This way, the `filterEntry` function is available "
"inside the definition of our function, but not outside it. Also, it can "
"depend on the arguments to the enclosing function, which is essential here "
"because `filterEntry` uses the `firstName` and `lastName` arguments to "
"filter the specified `Entry`."
msgstr ""
"真偽型を返す関数 `filterEntry`は `where`節の内部で補助的な関数として定義され"
"ています。\n"
"このため、 `filterEntry`関数はこの定義の内部では使用できますが、外部では使用"
"できません。\n"
"また、`filterEntry`はそれを包む関数の引数に依存でき、 `filterEntry`は指定され"
"た `Entry`を絞り込むために引数 `firstName`と `lastName`を使用しているので、 "
"`filterEntry`が `findEntry`の内部にあることは必須になっています。"

#. type: Plain text
#: text/chapter3.md:560
msgid ""
"Note that, just like for top-level declarations, it was not necessary to "
"specify a type signature for `filterEntry`. However, doing so is recommended "
"as a form of documentation."
msgstr ""
"最上位での宣言と同じように、必ずしも `filterEntry`の型シグネチャを指定しなく"
"てもよいことに注意してください。ただし、ドキュメントとしても役に立つので型シ"
"グネチャを書くことは推奨されています。"

#. type: Title ##
#: text/chapter3.md:561
#, no-wrap
msgid "Infix Function Application"
msgstr "中置の関数適用"

#. type: Plain text
#: text/chapter3.md:564
msgid ""
"Most of the functions discussed so far used _prefix_ function application, "
"where the function name was put _before_ the arguments. For example, when "
"using the `insertEntry` function to add an `Entry` (`john`) to an empty "
"`AddressBook`, we might write:"
msgstr ""
"これまでお話しした関数のほとんどは _前置_ 関数適用でした。関数名が引数の _前"
"_ に置かれていたということです。例えば`insertEntry`関数を使って`Entry` "
"(`john`) を空の`AddressBook`に追加する場合、以下のように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:565
#, no-wrap
msgid "> book1 = insertEntry john emptyBook\n"
msgstr "> book1 = insertEntry john emptyBook\n"

#. type: Plain text
#: text/chapter3.md:570
msgid ""
"However, this chapter has also included examples of _infix_ [binary "
"operators](https://github.com/purescript/documentation/blob/master/language/"
"Syntax.md#binary-operators), such as the `==` operator in the definition of "
"`filterEntry`, where the operator is put _between_ the two arguments. These "
"infix operators are actually defined in the PureScript source as infix "
"aliases for their underlying _prefix_ implementations. For example, `==` is "
"defined as an infix alias for the prefix `eq` function with the line:"
msgstr ""
"しかしこの章には _中置_ [2引数演算子](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#binary-operators)の例も含まれて"
"います。例えば`filterEntry`の定義中の`==`演算子で、演算子が2つの引数の _間_ "
"に置かれています。実はこうした中置演算子はPureScriptのソースコードで、背後に"
"ある _前置_ 版の実装への中置別称として定義されています。例えば`==`は以下の行"
"により前置の`eq`関数の中置別称として定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:571
#, no-wrap
msgid "infix 4 eq as ==\n"
msgstr "infix 4 eq as ==\n"

#. type: Plain text
#: text/chapter3.md:576
msgid ""
"and therefore `entry.firstName == firstName` in `filterEntry` could be "
"replaced with the `eq entry.firstName firstName`. We'll cover a few more "
"examples of defining infix operators later in this section."
msgstr ""
"したがって`filterEntry`中の`entry.firstName == firstName`は`eq entry."
"firstName firstName`で置き換えられます。この節の後のほうで中置演算子を定義す"
"る例にもう少し触れます。"

#. type: Plain text
#: text/chapter3.md:578
msgid ""
"There are situations where putting a prefix function in an infix position as "
"an operator leads to more readable code. One example is the `mod` function:"
msgstr ""
"前置関数を演算子としての中置の位置に置くとより読みやすいコードになる場面があ"
"ります。\n"
"その一例が`mod`関数です。"

#. type: Fenced code block (text)
#: text/chapter3.md:579
#, no-wrap
msgid ""
"> mod 8 3\n"
"2\n"
msgstr ""
"> mod 8 3\n"
"2\n"

#. type: Plain text
#: text/chapter3.md:585
msgid ""
"The above usage works fine, but is awkward to read. A more familiar phrasing "
"is \"eight mod three\", which you can achieve by wrapping a prefix function "
"in backticks (\\`):"
msgstr ""
"上の用例は正しく動きますが、読みづらいです。\n"
"より馴染みのある表現の仕方は「8 mod 3」ですが、バックスラッシュ (\\`) の中に"
"前置関数を包めばこのように書けます。"

#. type: Fenced code block (text)
#: text/chapter3.md:586
#, no-wrap
msgid ""
"> 8 `mod` 3\n"
"2\n"
msgstr ""
"> 8 `mod` 3\n"
"2\n"

#. type: Plain text
#: text/chapter3.md:592
msgid ""
"In the same way, wrapping `insertEntry` in backticks turns it into an infix "
"operator, such that `book1` and `book2` below are equivalent:"
msgstr ""
"同様に、`insertEntry`をバックスラッシュで包むと中置演算子に変わります。\n"
"例えば以下の`book1`と`book2`は等価です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:593
#, no-wrap
msgid ""
"book1 = insertEntry john emptyBook\n"
"book2 = john `insertEntry` emptyBook\n"
msgstr ""
"book1 = insertEntry john emptyBook\n"
"book2 = john `insertEntry` emptyBook\n"

#. type: Plain text
#: text/chapter3.md:599
msgid ""
"We can make an `AddressBook` with multiple entries by using multiple "
"applications of `insertEntry` as a prefix function (`book3`) or as an infix "
"operator (`book4`) as shown below:"
msgstr ""
"複数回`insertEntry`を適用することで複数の項目がある`AddressBook`を作ることが"
"できますが、以下のように前置関数 (`book3`) として適用するか中置演算子 "
"(`book4`) として適用するかの2択があります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:600
#, no-wrap
msgid ""
"book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))\n"
"book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))\n"
msgstr ""
"book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))\n"
"book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))\n"

#. type: Plain text
#: text/chapter3.md:606
msgid ""
"We can also define an infix operator alias (or synonym) for `insertEntry.` "
"We'll arbitrarily choose `++` for this operator, give it a [precedence]"
"(https://github.com/purescript/documentation/blob/master/language/Syntax."
"md#precedence) of `5`, and make it right [associative](https://github.com/"
"purescript/documentation/blob/master/language/Syntax.md#associativity) using "
"`infixr`:"
msgstr ""
"`insertEntry`には中置演算子別称（または同義語）も定義できます。\n"
"この演算子の名前に適当に`++`を選び、[優先度](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#precedence)を`5`にし、そして"
"`infixr`を使って右[結合](https://github.com/purescript/documentation/blob/"
"master/language/Syntax.md#associativity)とします。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:607
#, no-wrap
msgid "infixr 5 insertEntry as ++\n"
msgstr "infixr 5 insertEntry as ++\n"

#. type: Plain text
#: text/chapter3.md:612
msgid "This new operator lets us rewrite the above `book4` example as:"
msgstr "この新しい演算子で上の`book4`の例を次のように書き直せます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:613
#, no-wrap
msgid "book5 = john ++ (peggy ++ (ned ++ emptyBook))\n"
msgstr "book5 = john ++ (peggy ++ (ned ++ emptyBook))\n"

#. type: Plain text
#: text/chapter3.md:618
msgid ""
"and the right associativity of our new `++` operator lets us get rid of the "
"parentheses without changing the meaning:"
msgstr "そして新しい`++`演算子が右結合なので意味を変えずに括弧を除去できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:619
#, no-wrap
msgid "book6 = john ++ peggy ++ ned ++ emptyBook\n"
msgstr "book6 = john ++ peggy ++ ned ++ emptyBook\n"

#. type: Plain text
#: text/chapter3.md:624
msgid ""
"Another common technique for eliminating parens is to use `apply`'s infix "
"operator `$`, along with your standard prefix functions."
msgstr ""
"括弧を消去する他のよくある技法は、いつもの前置関数と一緒に`apply`の中置演算子"
"`$`を使うというものです。"

#. type: Plain text
#: text/chapter3.md:626
msgid "For example, the earlier `book3` example could be rewritten as:"
msgstr "例えば前の`book3`の例は以下のように書き直せます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:627
#, no-wrap
msgid "book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook\n"
msgstr "book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook\n"

#. type: Plain text
#: text/chapter3.md:632
msgid ""
"Substituting `$` for parens is usually easier to type and (arguably) easier "
"to read. A mnemonic to remember the meaning of this symbol is to think of "
"the dollar sign as being drawn from two parens that are also being crossed-"
"out, suggesting the parens are now unnecessary."
msgstr ""
"括弧を`$`で置き換えるのは大抵入力しやすくなりますし（議論の余地がありますが）"
"読みやすくなります。\n"
"この記号の意味を覚えるための記憶術として、ドル記号を2つの括弧に打ち消し線が引"
"かれたものと見ることで、これで括弧が不必要になったのだと推測できるという方法"
"があります。"

#. type: Plain text
#: text/chapter3.md:634
msgid ""
"Note that `$` isn't special syntax that's hardcoded into the language. It's "
"simply the infix operator for a regular function called `apply`, which is "
"defined in `Data.Function` as follows:"
msgstr ""
"なお、`($)`は言語にハードコードされた特別な構文ではありません。\n"
"単に`apply`という名前の通常の関数のための中置演算子であって、`Data.Function`"
"で以下のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:635
#, no-wrap
msgid ""
"apply :: forall a b. (a -> b) -> a -> b\n"
"apply f x = f x\n"
"\n"
"infixr 0 apply as $\n"
msgstr ""
"apply :: forall a b. (a -> b) -> a -> b\n"
"apply f x = f x\n"
"\n"
"infixr 0 apply as $\n"

#. type: Plain text
#: text/chapter3.md:643
#, no-wrap
msgid "The `apply` function takes another function (of type `(a -> b)`) as its first argument and a value (of type `a`) as its second argument, then calls that function with that value. If it seems like this function doesn't contribute anything meaningful, you are absolutely correct! Your program is logically identical without it (see [referential transparency](https://en.wikipedia.org/wiki/Referential_transparency)). The syntactic utility of this function comes from the special properties assigned to its infix operator. `$` is a right-associative (`infixr`), low precedence (`0`) operator, which lets us remove sets of parentheses for deeply-nested applications.\n"
msgstr ""
"`apply`関数は、他の関数（型は`(a -> b)`）を最初の引数に、値（型は`a`）を2つ目の引数に取って、その値に対して関数を呼びます。\n"
"この関数が何ら意味のあることをしていないようだと思ったら、全くもって正しいです。\n"
"この関数がなくてもプログラムは論理的に同一です（[参照透過性](https://en.wikipedia.org/wiki/Referential_transparency)も見てください）。\n"
"この関数の構文的な利便性はその中置演算子に割り当てられた特別な性質からきています。\n"
"`$`は右結合 (`infixr`) で低い優先度 (`0`) の演算子ですが、これにより深い入れ子になった適用から括弧の束を削除できるのです。\n"

#. type: Plain text
#: text/chapter3.md:645
msgid ""
"Another parens-busting opportunity for the `$` operator is in our earlier "
"`findEntry` function:"
msgstr ""
"さらなる`$`演算子を使った括弧退治のチャンスは以前の`findEntry`関数にありま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:646
#, no-wrap
msgid "findEntry firstName lastName book = head $ filter filterEntry book\n"
msgstr "findEntry firstName lastName book = head $ filter filterEntry book\n"

#. type: Plain text
#: text/chapter3.md:651
msgid ""
"We'll see an even more elegant way to rewrite this line with \"function "
"composition\" in the next section."
msgstr "この行をより簡潔に書き換える方法を次節の「関数合成」で見ていきます。"

#. type: Plain text
#: text/chapter3.md:653
msgid ""
"If you'd like to use a concise infix operator alias as a prefix function, "
"you can surround it in parentheses:"
msgstr ""
"名前の短い中置演算子を前置関数として使いたければ括弧で囲むことができます。"

#. type: Fenced code block (text)
#: text/chapter3.md:654
#, no-wrap
msgid ""
"> 8 + 3\n"
"11\n"
"\n"
"> (+) 8 3\n"
"11\n"
msgstr ""
"> 8 + 3\n"
"11\n"
"\n"
"> (+) 8 3\n"
"11\n"

#. type: Plain text
#: text/chapter3.md:663
msgid ""
"Alternatively, operators can be partially applied by surrounding the "
"expression with parentheses and using `_` as an operand in an [operator "
"section](https://github.com/purescript/documentation/blob/master/language/"
"Syntax.md#operator-sections). You can think of this as a more convenient way "
"to create simple anonymous functions (although in the below example, we're "
"then binding that anonymous function to a name, so it's not so anonymous "
"anymore):"
msgstr ""
"その代わりの手段として演算子は部分適用でき、これには式を括弧で囲んで[演算子"
"節](https://github.com/purescript/documentation/blob/master/language/Syntax."
"md#operator-sections)中の引数として`_`を使います。これは簡単な無名関数を作る"
"より便利な方法として考えることができます（以下の例ではそこから無名関数を名前"
"に束縛しているので、もはや別に無名とも言えなくなっていますが）。"

#. type: Fenced code block (text)
#: text/chapter3.md:664
#, no-wrap
msgid ""
"> add3 = (3 + _)\n"
"> add3 2\n"
"5\n"
msgstr ""
"> add3 = (3 + _)\n"
"> add3 2\n"
"5\n"

#. type: Plain text
#: text/chapter3.md:671
msgid ""
"To summarize, the following are equivalent definitions of a function that "
"adds `5` to its argument:"
msgstr "纏めると、以下は引数に`5`を加える関数の等価な定義です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:672
#, no-wrap
msgid ""
"add5 x = 5 + x\n"
"add5 x = add 5 x\n"
"add5 x = (+) 5 x\n"
"add5 x = 5 `add` x\n"
"add5   = add 5\n"
"add5   = \\x -> 5 + x\n"
"add5   = (5 + _)\n"
"add5 x = 5 `(+)` x  -- Yo Dawg, I herd you like infix, so we put infix in your infix!\n"
msgstr ""
"add5 x = 5 + x\n"
"add5 x = add 5 x\n"
"add5 x = (+) 5 x\n"
"add5 x = 5 `add` x\n"
"add5   = add 5\n"
"add5   = \\x -> 5 + x\n"
"add5   = (5 + _)\n"
"add5 x = 5 `(+)` x  -- よおポチ、中置に目がないっていうから、中置の中に中置を入れといたぜ\n"

#. type: Title ##
#: text/chapter3.md:683
#, no-wrap
msgid "Function Composition"
msgstr "関数合成"

#. type: Plain text
#: text/chapter3.md:686
msgid ""
"Just like we were able to simplify the `insertEntry` function by using eta "
"conversion, we can simplify the definition of `findEntry` by reasoning about "
"its arguments."
msgstr ""
"イータ変換を使うと `insertEntry`関数を簡略化できたのと同じように、引数をよく"
"考察すると `findEntry`の定義を簡略化できます。"

#. type: Plain text
#: text/chapter3.md:688
msgid ""
"Note that the `book` argument is passed to the `filter filterEntry` "
"function, and the result of this application is passed to `head`. In other "
"words, `book` is passed to the _composition_ of the functions `filter "
"filterEntry` and `head`."
msgstr ""
"なお、引数 `book`は関数 `filter filterEntry`に渡され、この適用の結果が `head`"
"に渡されます。これは言いかたを変えれば、 `filter filterEntry`と `head`の _合"
"成_ (composition) に `book`が渡されるということです。"

#. type: Plain text
#: text/chapter3.md:690
#, no-wrap
msgid "In PureScript, the function composition operators are `<<<` and `>>>`. The first is \"backwards composition\", and the second is \"forwards composition\".\n"
msgstr "PureScriptの関数合成演算子は `<<<`と `>>>`です。前者は「逆方向の合成」であり、後者は「順方向の合成」です。\n"

#. type: Plain text
#: text/chapter3.md:692
msgid ""
"We can rewrite the right-hand side of `findEntry` using either operator. "
"Using backwards-composition, the right-hand side would be"
msgstr ""
"何れかの演算子を使用して `findEntry`の右辺を書き換えることができます。\n"
"逆順の合成を使用すると、右辺は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:693
#, no-wrap
msgid "(head <<< filter filterEntry) book\n"
msgstr "(head <<< filter filterEntry) book\n"

#. type: Plain text
#: text/chapter3.md:698
msgid ""
"In this form, we can apply the eta conversion trick from earlier, to arrive "
"at the final form of `findEntry`:"
msgstr ""
"この形式なら最初の定義にイータ変換の技を適用でき、 `findEntry`は最終的に次の"
"ような形式に到達します。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:699
#, no-wrap
msgid ""
"{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_implementation}}\n"
"    ...\n"
msgstr ""
"{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_implementation}}\n"
"    ...\n"

#. type: Plain text
#: text/chapter3.md:705
msgid "An equally valid right-hand side would be:"
msgstr "右辺を次のようにしても同じく妥当です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:706
#, no-wrap
msgid "filter filterEntry >>> head\n"
msgstr "filter filterEntry >>> head\n"

#. type: Plain text
#: text/chapter3.md:711
msgid ""
"Either way, this gives a clear definition of the `findEntry` function: "
"\"`findEntry` is the composition of a filtering function and the `head` "
"function\"."
msgstr ""
"どちらにしても、これは「`findEntry`は絞り込み関数と`head`関数の合成である」と"
"いう `findEntry`関数のわかりやすい定義を与えます。"

#. type: Plain text
#: text/chapter3.md:713
msgid ""
"I will let you make your own decision which definition is easier to "
"understand, but it is often useful to think of functions as building blocks "
"in this way - each function executing a single task, and solutions assembled "
"using function composition."
msgstr ""
"どちらの定義のほうがわかりやすいかの判断はお任せしますが、このように関数を部"
"品として捉えると有用なことがよくあります。関数は1つの役目だけをこなし、機能を"
"関数合成で組み立てるというように。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:721
msgid ""
"(Easy) Test your understanding of the `findEntry` function by writing down "
"the types of each of its major subexpressions. For example, the type of the "
"`head` function as used is specialized to `AddressBook -> Maybe Entry`. "
"_Note_: There is no test for this exercise."
msgstr ""
"（簡単）`findEntry`関数の定義の主な部分式の型を書き下し、 `findEntry`関数につ"
"いてよく理解しているか試してみましょう。\n"
"例えば`findEntry`の定義の中にある `head`関数の型は `AddressBook -> Maybe "
"Entry`と特殊化されています。\n"
"*補足*：この問題にはテストがありません。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:721
msgid ""
"(Medium) Write a function `findEntryByStreet :: String -> AddressBook -> "
"Maybe Entry` which looks up an `Entry` given a street address. _Hint_ "
"reusing the existing code in `findEntry`. Test your function in PSCi and by "
"running `spago test`."
msgstr ""
"（普通）関数`findEntryByStreet :: String -> AddressBook -> Maybe Entry`を書い"
"てください。\n"
"この関数は与えられた通りの住所から`Entry`を見付け出します。\n"
"*手掛かり*：`findEntry`にある既存のコードを再利用してください。\n"
"実装した関数をPSCiと`spago test`を走らせてテストしてください。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:721
msgid ""
"(Medium) Rewrite `findEntryByStreet` to replace `filterEntry` with the "
"composition (using `<<<` or `>>>`) of: a property accessor (using the `_.` "
"notation); and a function that tests whether its given string argument is "
"equal to the given street address."
msgstr ""
"（普通）`filterEntry`を（`<<<`や`>>>`を使った）合成で置き換えて、"
"`findEntryByStreet`を書き直してください。\n"
"合成の対象は、プロパティ取得子（`_.`記法を使います）と、与えられた文字列引数"
"が与えられた通りの住所に等しいかを判定する関数です。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:721
msgid ""
"(Medium) Write a function `isInBook` which tests whether a name appears in a "
"`AddressBook`, returning a Boolean value. _Hint_: Use PSCi to find the type "
"of the `Data.List.null` function, which tests whether a list is empty or not."
msgstr ""
"（普通）指定された名前が `AddressBook`に存在するかどうかを調べて真偽値で返す"
"関数`isInBook`を書いてみましょう。\n"
"*手掛かり*：リストが空かどうかを調べる `Data.List.null`関数の型をPSCiで調べて"
"みてみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:721
msgid ""
"(Difficult) Write a function `removeDuplicates` which removes \"duplicate\" "
"address book entries. We'll consider entries duplicated if they share the "
"same first and last names, while ignoring `address` fields. _Hint_: Use PSCi "
"to find the type of the `Data.List.nubByEq` function, which removes "
"duplicate elements from a list based on an equality predicate. Note that the "
"first element in each set of duplicates (closest to list head) is the one "
"that is kept."
msgstr ""
"（難しい）「重複」している項目を住所録から削除する関数 `removeDuplicates`を書"
"いてみましょう。\n"
"項目が同じ姓名を共有していれば`address`フィールドに関係なく、項目が重複してい"
"ると考えます。\n"
"*手掛かり*：関数 `Data.List.nubBy`の型を、PSCiを使用して調べてみましょう。\n"
"この関数は値同士の等価性を定義する述語関数に基づいてリストから重複要素を削除"
"します。\n"
"なお、それぞれの重複する項目の集合における最初の要素（リストの先頭に最も近"
"い）が保持する項目です。"

#. type: Plain text
#: text/chapter3.md:725
msgid ""
"In this chapter, we covered several new functional programming concepts:"
msgstr "この章では、関数型プログラミングの新しい概念を幾つも導入しました。"

#. type: Bullet: '- '
#: text/chapter3.md:733
msgid ""
"How to use the interactive mode PSCi to experiment with functions and test "
"ideas."
msgstr ""
"対話的モードのPSCiを使用して、関数を調べるなどの思いついたことを試す方法"

#. type: Bullet: '- '
#: text/chapter3.md:733
msgid ""
"The role of types as both a correctness tool, and an implementation tool."
msgstr "検証や実装の道具としての型の役割"

#. type: Bullet: '- '
#: text/chapter3.md:733
msgid ""
"The use of curried functions to represent functions of multiple arguments."
msgstr "多引数関数を表現する、カリー化された関数の使用"

#. type: Bullet: '- '
#: text/chapter3.md:733
msgid "Creating programs from smaller components by composition."
msgstr "関数合成で小さな部品を組み合わせてのプログラムの構築"

#. type: Bullet: '- '
#: text/chapter3.md:733
msgid "Structuring code neatly using `where` expressions."
msgstr "`where`節を利用したコードの構造化"

#. type: Bullet: '- '
#: text/chapter3.md:733
msgid "How to avoid null values by using the `Maybe` type."
msgstr "`Maybe`型を使用してnull値を回避する方法"

#. type: Bullet: '- '
#: text/chapter3.md:733
msgid ""
"Using techniques like eta conversion and function composition to refactor "
"code into a clear specification."
msgstr ""
"イータ変換や関数合成のような手法を利用した、よりわかりやすいコードへの再構成"

#. type: Plain text
#: text/chapter3.md:734
msgid "In the following chapters, we'll build on these ideas."
msgstr "次の章からは、これらの考えかたに基づいて進めていきます。"

#. type: Title #
#: text/chapter4.md:1
#, no-wrap
msgid "Recursion, Maps And Folds"
msgstr "再帰、マップ、畳み込み"

#. type: Plain text
#: text/chapter4.md:6
msgid ""
"In this chapter, we will look at how recursive functions can be used to "
"structure algorithms. Recursion is a basic technique used in functional "
"programming, which we will use throughout this book."
msgstr ""
"この章では、アルゴリズムを構造化するときに再帰関数をどのように使うかについて"
"見ていきましょう。再帰は関数型プログラミングの基本的な手法であり、この本の全"
"体に亙って使われます。"

#. type: Plain text
#: text/chapter4.md:8
msgid ""
"We will also cover some standard functions from PureScript's standard "
"libraries. We will see the `map` and `fold` functions, as well as some "
"useful special cases, like `filter` and `concatMap`."
msgstr ""
"また、PureScriptの標準ライブラリから標準的な関数を幾つか取り扱います。\n"
"`map`や`fold`といった関数だけでなく、`filter`や`concatMap`といった特別な場合"
"において便利なものについても見ていきます。"

#. type: Plain text
#: text/chapter4.md:10
msgid ""
"The motivating example for this chapter is a library of functions for "
"working with a virtual filesystem. We will apply the techniques learned in "
"this chapter to write functions which compute properties of the files "
"represented by a model of a filesystem."
msgstr ""
"この章では、仮想的なファイルシステムを操作する関数のライブラリを動機付けに用"
"います。この章で学ぶ手法を応用して、擬似的なファイルシステムによって表される"
"ファイルのプロパティを計算する関数を記述します。"

#. type: Plain text
#: text/chapter4.md:14
msgid ""
"The source code for this chapter is contained in `src/Data/Path.purs` and "
"`test/Examples.purs`. The `Data.Path` module contains a model of a virtual "
"filesystem. You do not need to modify the contents of this module. Implement "
"your solutions to the exercises in the `Test.MySolutions` module. Enable "
"accompanying tests in the `Test.Main` module as you complete each exercise "
"and check your work by running `spago test`."
msgstr ""
"この章のソースコードは`src/Data/Path.purs`と`test/Examples.purs`に含まれてい"
"ます。\n"
"`Data.Path`モジュールは仮想ファイルシステムのモデルを含みます。\n"
"このモジュールの内容を変更する必要はありません。\n"
"演習への解答は`Test.MySolutions`モジュールに実装してください。\n"
"それぞれの演習を完了させつつ都度`Test.Main`モジュールにある対応するテストを有"
"効にし、`spago test`を走らせることで解答を確認してください。"

#. type: Plain text
#: text/chapter4.md:16 text/chapter6.md:18
msgid "The project has the following dependencies:"
msgstr "このプロジェクトには以下の依存関係があります。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`maybe`, which defines the `Maybe` type constructor"
msgstr "`maybe`: `Maybe`型構築子が定義されています。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`arrays`, which defines functions for working with arrays"
msgstr "`arrays`: 配列を扱うための関数が定義されています。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`strings`, which defines functions for working with JavaScript strings"
msgstr "`strings`: JavaScriptの文字列を扱うための関数が定義されています。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid ""
"`foldable-traversable`, which defines functions for folding arrays and other "
"data structures"
msgstr ""
"`foldable-traversable`: 配列やその他のデータ構造を畳み込む関数が定義されてい"
"ます。"

#. type: Bullet: '- '
#: text/chapter4.md:22
msgid "`console`, which defines functions for printing to the console"
msgstr "`console`: コンソールへの出力を扱うための関数が定義されています。"

#. type: Plain text
#: text/chapter4.md:26
msgid ""
"Recursion is an important technique in programming in general, but "
"particularly common in pure functional programming, because, as we will see "
"in this chapter, recursion helps to reduce the mutable state in our programs."
msgstr ""
"再帰は一般のプログラミングでも重要な手法ですが、特に純粋関数型プログラミング"
"では当たり前のように用いられます。この章で見ていくように、再帰はプログラムの"
"変更可能な状態を減らすために役立つからです。"

#. type: Plain text
#: text/chapter4.md:28
msgid ""
"Recursion is closely linked to the _divide and conquer_ strategy: to solve a "
"problem on certain inputs, we can break down the inputs into smaller parts, "
"solve the problem on those parts, and then assemble a solution from the "
"partial solutions."
msgstr ""
"再帰は*分割統治*戦略と密接な関係があります。\n"
"分割統治とはすなわち、何らかの入力としての問題を解くにあたり、入力を小さな部"
"分に分割してそれぞれの部分について問題を解き、部分ごとの答えから最終的な答え"
"を組み立てるということです。"

#. type: Plain text
#: text/chapter4.md:30
msgid "Let's see some simple examples of recursion in PureScript."
msgstr "それでは、PureScriptにおける再帰の簡単な例を幾つか見てみましょう。"

#. type: Plain text
#: text/chapter4.md:32
msgid "Here is the usual _factorial function_ example:"
msgstr "次に示すのは*階乗関数*のありふれた例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:33
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorial}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorial}}\n"

#. type: Plain text
#: text/chapter4.md:38
msgid ""
"Here, we can see how the factorial function is computed by reducing the "
"problem to a subproblem - that of computing the factorial of a smaller "
"integer. When we reach zero, the answer is immediate."
msgstr ""
"部分問題へ問題を分割することによって階乗関数がどのように計算されるかがわかり"
"ます。より小さい数へと階乗を計算していくということです。ゼロに到達すると、答"
"えは直ちに求まります。"

#. type: Plain text
#: text/chapter4.md:40
msgid ""
"Here is another common example, which computes the _Fibonacci function_:"
msgstr ""
"次は、 _フィボナッチ関数_ (Fibonacci function) を計算するという、これまたよく"
"ある例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:41
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:fib}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:fib}}\n"

#. type: Plain text
#: text/chapter4.md:46
msgid ""
"Again, this problem is solved by considering the solutions to subproblems. "
"In this case, there are two subproblems, corresponding to the expressions "
"`fib (n - 1)` and `fib (n - 2)`. When these two subproblems are solved, we "
"assemble the result by adding the partial results."
msgstr ""
"やはり、部分問題の解決策を考えることで全体を解決していることがわかります。\n"
"このとき、`fib (n - 1)`と`fib (n - 2)`という式に対応した、2つの部分問題があり"
"ます。\n"
"これらの2つの部分問題が解決されていれば、この部分的な答えを加算することで、全"
"体の答えを組み立てることができます。"

#. type: Plain text
#: text/chapter4.md:48
msgid ""
"Note that, while the above examples of `factorial` and `fib` work as "
"intended, a more idiomatic implementation would use pattern matching instead "
"of `if`/`then`/`else`. Pattern matching techniques are discussed in a later "
"chapter."
msgstr ""
"なお上の`factorial`と`fib`の例は意図通りに動きますが、よりPureScriptらしい実"
"装では`if`や`then`や`else`を使う代わりにパターン照合を使うものでしょう。パ"
"ターン照合の技法は後の章でお話しします。"

#. type: Title ##
#: text/chapter4.md:49
#, no-wrap
msgid "Recursion on Arrays"
msgstr "配列上での再帰"

#. type: Plain text
#: text/chapter4.md:52
msgid ""
"We are not limited to defining recursive functions over the `Int` type! We "
"will see recursive functions defined over a wide array of data types when we "
"cover _pattern matching_ later in the book, but for now, we will restrict "
"ourselves to numbers and arrays."
msgstr ""
"再帰関数の定義は`Int`型だけに限定されるものではありません。\n"
"本書の後半で*パターン照合*を扱うときに、いろいろなデータ型の上での再帰関数に"
"ついて見ていきますが、ここでは数と配列に限っておきます。"

#. type: Plain text
#: text/chapter4.md:54
msgid ""
"Just as we branch based on whether the input is non-zero, in the array case, "
"we will branch based on whether the input is non-empty. Consider this "
"function, which computes the length of an array using recursion:"
msgstr ""
"入力がゼロでないかどうかについて分岐するのと同じように、配列の場合も、配列が"
"空でないかどうかについて分岐していきます。再帰を使用して配列の長さを計算する"
"次の関数を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:55
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Data.Array (null, tail)\n"
"import Data.Maybe (fromMaybe)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:length}}\n"
msgstr ""
"import Prelude\n"
"\n"
"import Data.Array (null, tail)\n"
"import Data.Maybe (fromMaybe)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:length}}\n"

#. type: Plain text
#: text/chapter4.md:65
msgid ""
"In this function, we use an `if .. then .. else` expression to branch based "
"on the emptiness of the array. The `null` function returns `true` on an "
"empty array. Empty arrays have length zero, and a non-empty array has a "
"length that is one more than the length of its tail."
msgstr ""
"この関数では配列が空かどうかで分岐するために`if ... then ... else`式を使って"
"います。\n"
"この`null`関数は配列が空のときに`true`を返します。\n"
"空の配列の長さはゼロであり、空でない配列の長さは配列の先頭を取り除いた残りの"
"部分の長さより1大きいというわけです。"

#. type: Plain text
#: text/chapter4.md:67
msgid ""
"The `tail` function returns a `Maybe` wrapping the given array without its "
"first element. If the array is empty (i.e. it doesn't have a tail) `Nothing` "
"is returned. The `fromMaybe` function takes a default value and a `Maybe` "
"value. If the latter is `Nothing` it returns the default, in the other case "
"it returns the value wrapped by `Just`."
msgstr ""
"`tail`関数は与えられた配列から最初の要素を除いたものを`Maybe`に包んで返しま"
"す。配列が空であれば（つまり尾鰭がなければ）`Nothing`が返ります。`fromMaybe`"
"関数は既定値と`Maybe`値を取ります。後者が`Nothing`であれば既定値を返し、そう"
"でなければ`Just`に包まれた値を返します。"

#. type: Plain text
#: text/chapter4.md:69
msgid ""
"This example is obviously a very impractical way to find the length of an "
"array in JavaScript, but should provide enough help to allow you to complete "
"the following exercises:"
msgstr ""
"JavaScriptで配列の長さを調べるのには、この例はどう見ても実用的な方法とはいえ"
"ませんが、次の演習を完遂するための手がかりとしては充分でしょう。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:74
msgid ""
"(Easy) Write a recursive function `isEven` which returns `true` if and only "
"if its input is an even integer."
msgstr ""
"（簡単）入力が偶数であるとき、かつそのときに限り`true`に返すような再帰関数を"
"書いてみましょう。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:74
msgid ""
"(Medium) Write a recursive function `countEven` which counts the number of "
"even integers in an array. _Hint_: the function `head` (also available in "
"`Data.Array`) can be used to find the first element in a non-empty array."
msgstr ""
"（少し難しい）配列内の偶数の数を数える再帰関数`countEven`を書いてみましょ"
"う。\n"
"*手掛かり*：`Data.Array`モジュールの`head`関数を使うと、空でない配列の最初の"
"要素を見つけることができます。"

#. type: Title ##
#: text/chapter4.md:75
#, no-wrap
msgid "Maps"
msgstr "マップ"

#. type: Plain text
#: text/chapter4.md:78
msgid ""
"The `map` function is an example of a recursive function on arrays. It is "
"used to transform the elements of an array by applying a function to each "
"element in turn. Therefore, it changes the _contents_ of the array, but "
"preserves its _shape_ (i.e. its length)."
msgstr ""
"`map`関数は配列に対する再帰関数の1つです。この関数を使うと、配列の各要素に順"
"番に関数を適用することで、配列の要素を変換できます。そのため、配列の*内容*は"
"変更されますが、その*形状*（ここでは「長さ」）は保存されます。"

#. type: Plain text
#: text/chapter4.md:80
msgid ""
"When we cover _type classes_ later in the book we will see that the `map` "
"function is an example of a more general pattern of shape-preserving "
"functions which transform a class of type constructors called _functors_."
msgstr ""
"本書の後半で _型クラス_ (type class) の内容を押さえるとき、`map`関数が形状保"
"存関数のより一般的な様式の一例であることを見ていきます。これは _関手_ "
"(functor) と呼ばれる型構築子のクラスを変換するものです。"

#. type: Plain text
#: text/chapter4.md:82
msgid "Let's try out the `map` function in PSCi:"
msgstr "それでは、PSCiで`map`関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:83
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> map (\\n -> n + 1) [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> map (\\n -> n + 1) [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:92
msgid ""
"Notice how `map` is used - we provide a function which should be \"mapped "
"over\" the array in the first argument, and the array itself in its second."
msgstr ""
"`map`がどのように使われているかに注目してください。\n"
"最初の引数には配列上で「写す」関数、第2引数には配列そのものを渡します。"

#. type: Title ##
#: text/chapter4.md:93
#, no-wrap
msgid "Infix Operators"
msgstr "中置演算子"

#. type: Plain text
#: text/chapter4.md:96
msgid ""
"The `map` function can also be written between the mapping function and the "
"array, by wrapping the function name in backticks:"
msgstr ""
"バッククォートで関数名を囲むと、写す関数と配列の間に、`map`関数を書くことがで"
"きます。"

#. type: Fenced code block (text)
#: text/chapter4.md:97
#, no-wrap
msgid ""
"> (\\n -> n + 1) `map` [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"> (\\n -> n + 1) `map` [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:103
msgid ""
"This syntax is called _infix function application_, and any function can be "
"made infix in this way. It is usually most appropriate for functions with "
"two arguments."
msgstr ""
"この構文は _中置関数適用_ と呼ばれ、どんな関数でもこのように中置できます。普"
"通は2引数の関数に対して使うのが最適でしょう。"

#. type: Plain text
#: text/chapter4.md:105
#, no-wrap
msgid "There is an operator which is equivalent to the `map` function when used with arrays, called `<$>`. This operator can be used infix like any other binary operator:\n"
msgstr "配列を扱うときは、`map`関数と等価な`<$>`という演算子が存在します。この演算子は他の二項演算子と同じように中置で使用できます。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:106
#, no-wrap
msgid ""
"> (\\n -> n + 1) <$> [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"> (\\n -> n + 1) <$> [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:112
msgid "Let's look at the type of `map`:"
msgstr "それでは`map`の型を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:113
#, no-wrap
msgid ""
"> :type map\n"
"forall a b f. Functor f => (a -> b) -> f a -> f b\n"
msgstr ""
"> :type map\n"
"forall a b f. Functor f => (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter4.md:119
msgid ""
"The type of `map` is actually more general than we need in this chapter. For "
"our purposes, we can treat `map` as if it had the following less general "
"type:"
msgstr ""
"実は`map`の型は、この章で必要とされているものよりも一般的な型になっています。"
"今回の目的では、`map`は次のようなもっと具体的な型であるかのように考えるとよい"
"でしょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:120
#, no-wrap
msgid "forall a b. (a -> b) -> Array a -> Array b\n"
msgstr "forall a b. (a -> b) -> Array a -> Array b\n"

#. type: Plain text
#: text/chapter4.md:125
#, no-wrap
msgid "This type says that we can choose any two types, `a` and `b`, with which to apply the `map` function. `a` is the type of elements in the source array, and `b` is the type of elements in the target array. In particular, there is no reason why `map` has to preserve the type of the array elements. We can use `map` or `<$>` to transform integers to strings, for example:\n"
msgstr ""
"この型では、`map`関数に適用するときには`a`と`b`という2つの型を自由に選ぶことができる、ということも示されています。\n"
"`a`は元の配列の要素の型で、`b`は目的の配列の要素の型です。\n"
"もっと言えば、`map`が配列の要素の型を保存する必要があるわけではありません。\n"
"例えば`map`を使用すると数値を文字列に変換できます。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:126
#, no-wrap
msgid ""
"> show <$> [1, 2, 3, 4, 5]\n"
"\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> show <$> [1, 2, 3, 4, 5]\n"
"\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:133
#, no-wrap
msgid "Even though the infix operator `<$>` looks like special syntax, it is in fact just an alias for a regular PureScript function. The function is simply _applied_ using infix syntax. In fact, the function can be used like a regular function by enclosing its name in parentheses. This means that we can used the parenthesized name `(<$>)` in place of `map` on arrays:\n"
msgstr ""
"中置演算子`<$>`は特別な構文のように見えるかもしれませんが、実はPureScriptの普通の関数の別称です。\n"
"中置構文を使用した単なる*適用*にすぎません。\n"
"実際、括弧でその名前を囲むと、この関数を通常の関数のように使用できます。\n"
"これは、`map`代わりに、括弧で囲まれた`(<$>)`という名前を使って配列に関数を適用できるということです。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:134
#, no-wrap
msgid ""
"> (<$>) show [1, 2, 3, 4, 5]\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> (<$>) show [1, 2, 3, 4, 5]\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:140
msgid ""
"Infix function names are defined as _aliases_ for existing function names. "
"For example, the `Data.Array` module defines an infix operator `(..)` as a "
"synonym for the `range` function, as follows:"
msgstr ""
"中置関数は既存の関数名の別称として定義されます。\n"
"例えば`Data.Array`モジュールでは次のように`range`関数の同義語として中置演算子"
"`(..)`を定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:141
#, no-wrap
msgid "infix 8 range as ..\n"
msgstr "infix 8 range as ..\n"

#. type: Plain text
#: text/chapter4.md:146
msgid "We can use this operator as follows:"
msgstr "この演算子は次のように使うことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:147
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> 1 .. 5\n"
"[1, 2, 3, 4, 5]\n"
"\n"
"> show <$> (1 .. 5)\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> 1 .. 5\n"
"[1, 2, 3, 4, 5]\n"
"\n"
"> show <$> (1 .. 5)\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:158
msgid ""
"_Note_: Infix operators can be a great tool for defining domain-specific "
"languages with a natural syntax. However, used excessively, they can render "
"code unreadable to beginners, so it is wise to exercise caution when "
"defining any new operators."
msgstr ""
"*補足*：独自の中置演算子は、自然な構文を備える領域特化言語を定義する上で優れ"
"た手段になりえます。ただし、乱用すると初心者が読めないコードになることがあり"
"ますから、新たな演算子の定義には慎重になるのが賢明です。"

#. type: Plain text
#: text/chapter4.md:160
#, no-wrap
msgid "In the example above, we parenthesized the expression `1 .. 5`, but this was actually not necessary, because the `Data.Array` module assigns a higher precedence level to the `..` operator than that assigned to the `<$>` operator. In the example above, the precedence of the `..` operator was defined as `8`, the number after the `infix` keyword. This is higher than the precedence level of `<$>`, meaning that we do not need to add parentheses:\n"
msgstr ""
"上記の例では、`1 .. 5`という式は括弧で囲まれていましたが、実際にはこれは必要ありません。\n"
"なぜなら、`Data.Array`モジュールは、`<$>`に割り当てられた優先順位より高い優先順位を`..`演算子に割り当てているからです。\n"
"上の例では、`..`の優先順位は、予約語`infix`のあとに書かれた数の`8` と定義されていました。\n"
"ここでは`<$>`の優先順位よりも高い優先順位を`..`に割り当てており、このため括弧を付け加える必要がないということです。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:161
#, no-wrap
msgid ""
"> show <$> 1 .. 5\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> show <$> 1 .. 5\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:167
msgid ""
"If we wanted to assign an _associativity_ (left or right) to an infix "
"operator, we could do so with the `infixl` and `infixr` keywords instead.  "
"Using `infix` assigns no associativity, meaning that you must parenthesize "
"any expression using the same operator multiple times or using multiple "
"operators of the same precedence."
msgstr ""
"中置演算子に（左または右の）*結合性*を与えたい場合は、代わりに予約語`infixl`"
"と`infixr`を使います。`infix`を使うと何ら結合性は割り当てられず、同じ演算子を"
"複数回使ったり複数の同じ優先度の演算子を使ったりするときに、式を括弧で囲まな"
"ければいけなくなります。"

#. type: Title ##
#: text/chapter4.md:168
#, no-wrap
msgid "Filtering Arrays"
msgstr "配列の絞り込み"

#. type: Plain text
#: text/chapter4.md:171
msgid ""
"The `Data.Array` module provides another function `filter`, which is "
"commonly used together with `map`. It provides the ability to create a new "
"array from an existing array, keeping only those elements which match a "
"predicate function."
msgstr ""
"`Data.Array`モジュールでは他にも、よく`map`と一緒に使われる関数`filter`も提供"
"しています。\n"
"この関数は、述語関数に適合する要素のみを残し、既存の配列から新しい配列を作成"
"する機能を提供します。"

#. type: Plain text
#: text/chapter4.md:173
msgid ""
"For example, suppose we wanted to compute an array of all numbers between 1 "
"and 10 which were even. We could do so as follows:"
msgstr ""
"例えば1から10までの数で、偶数であるような数の配列を計算したいとします。\n"
"これは次のようにできます。"

#. type: Fenced code block (text)
#: text/chapter4.md:174
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> filter (\\n -> n `mod` 2 == 0) (1 .. 10)\n"
"[2,4,6,8,10]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> filter (\\n -> n `mod` 2 == 0) (1 .. 10)\n"
"[2,4,6,8,10]\n"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid ""
"(Easy) Write a function `squared` which calculates the squares of an array "
"of numbers. _Hint_: Use the `map` or `<$>` function."
msgstr ""
"（簡単）`map`関数や`<$>`関数を使用して、 配列に格納された数のそれぞれの平方を"
"計算する関数`squared`を書いてみましょう。\n"
"*手掛かり*：`map`や`<$>`といった関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid ""
"(Easy) Write a function `keepNonNegative` which removes the negative numbers "
"from an array of numbers. _Hint_: Use the `filter` function."
msgstr ""
"（簡単）`filter`関数を使用して、数の配列から負の数を取り除く関数"
"`keepNonNegative`を書いてみましょう。\n"
"*手掛かり*：`filter`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid "(Medium)"
msgstr "（普通）"

#. type: Bullet: '    - '
#: text/chapter4.md:189
msgid ""
"Define an infix synonym `<$?>` for `filter`. _Note_: Infix synonyms may not "
"be defined in the REPL, but you can define it in a file."
msgstr ""
"`filter`の中置同義語`<$?>`を定義してください。\n"
"*補足*：中置同義語はREPLでは定義できないかもしれませんが、ファイルでは定義で"
"きます。"

#. type: Bullet: '    - '
#: text/chapter4.md:189
msgid ""
"Write a `keepNonNegativeRewrite` function, which is the same as "
"`keepNonNegative`, but replaces `filter` with your new infix operator `<$?>`."
msgstr ""
"関数`keepNonNegativeRewrite`を書いてください。この関数は`filter`を独自の新し"
"い中置演算子`<$?>`で置き換えたところ以外、`keepNonNegative`と同じです。"

#. type: Bullet: '    - '
#: text/chapter4.md:189
msgid ""
"Experiment with the precedence level and associativity of your operator in "
"PSCi. _Note_: There are no unit tests for this step."
msgstr ""
"PSCiで独自の演算子の優先度合いと結合性を試してください。\n"
"*補足*：この問題のための単体試験はありません。"

#. type: Title ##
#: text/chapter4.md:190
#, no-wrap
msgid "Flattening Arrays"
msgstr "配列の平坦化"

#. type: Plain text
#: text/chapter4.md:193
msgid ""
"Another standard function on arrays is the `concat` function, defined in "
"`Data.Array`. `concat` flattens an array of arrays into a single array:"
msgstr ""
"配列に関する標準的な関数として`Data.Array`で定義されているものには、`concat`"
"関数もあります。`concat`は配列の配列を1つの配列へと平坦化します。"

#. type: Fenced code block (text)
#: text/chapter4.md:194
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> :type concat\n"
"forall a. Array (Array a) -> Array a\n"
"\n"
"> concat [[1, 2, 3], [4, 5], [6]]\n"
"[1, 2, 3, 4, 5, 6]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> :type concat\n"
"forall a. Array (Array a) -> Array a\n"
"\n"
"> concat [[1, 2, 3], [4, 5], [6]]\n"
"[1, 2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:205
msgid ""
"There is a related function called `concatMap` which is like a combination "
"of the `concat` and `map` functions. Where `map` takes a function from "
"values to values (possibly of a different type), `concatMap` takes a "
"function from values to arrays of values."
msgstr ""
"関連する関数として、`concat`と`map`を組み合わせたような`concatMap`と呼ばれる"
"関数もあります。`map`は（相異なる型の可能性がある）値からの値への関数を引数に"
"取りますが、それに対して`concatMap`は値から値の配列への関数を取ります。"

#. type: Plain text
#: text/chapter4.md:207
msgid "Let's see it in action:"
msgstr "実際に動かして見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:208
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> :type concatMap\n"
"forall a b. (a -> Array b) -> Array a -> Array b\n"
"\n"
"> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
"[1,1,2,4,3,9,4,16,5,25]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> :type concatMap\n"
"forall a b. (a -> Array b) -> Array a -> Array b\n"
"\n"
"> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
"[1,1,2,4,3,9,4,16,5,25]\n"

#. type: Plain text
#: text/chapter4.md:219
#, no-wrap
msgid "Here, we call `concatMap` with the function `\\n -> [n, n * n]` which sends an integer to the array of two elements consisting of that integer and its square. The result is an array of ten integers: the integers from 1 to 5 along with their squares.\n"
msgstr ""
"ここでは、数をその数とその数の平方の2つの要素からなる配列に写す関数`\\n -> [n, n * n]`を引数に`concatMap`を呼び出しています。\n"
"結果は10個の整数の配列です。\n"
"配列は1から5の数とそのそれぞれの数の平方からなります。\n"

#. type: Plain text
#: text/chapter4.md:221
msgid ""
"Note how `concatMap` concatenates its results. It calls the provided "
"function once for each element of the original array, generating an array "
"for each. Finally, it collapses all of those arrays into a single array, "
"which is its result."
msgstr ""
"`concatMap`がどのように結果を連結しているのかに注目してください。渡された関数"
"を元の配列のそれぞれの要素について一度ずつ呼び出し、その関数はそれぞれ配列を"
"生成します。最後にそれらの配列を単一の配列に押し潰したものが結果となります。"

#. type: Plain text
#: text/chapter4.md:223
msgid ""
"`map`, `filter` and `concatMap` form the basis for a whole range of "
"functions over arrays called \"array comprehensions\"."
msgstr ""
"`map`と`filter`、`concatMap`は、「配列内包表記」(array comprehensions) と呼ば"
"れる、配列に関するあらゆる関数の基盤を形成します。"

#. type: Title ##
#: text/chapter4.md:224
#, no-wrap
msgid "Array Comprehensions"
msgstr "配列内包表記"

#. type: Plain text
#: text/chapter4.md:227
msgid ""
"Suppose we wanted to find the factors of a number `n`. One simple way to do "
"this would be by brute force: we could generate all pairs of numbers between "
"1 and `n`, and try multiplying them together. If the product was `n`, we "
"would have found a pair of factors of `n`."
msgstr ""
"数`n`の2つの因数を見つけたいとしましょう。\n"
"こうするための簡単な方法としては、総当りで調べる方法があります。\n"
"つまり、`1`から`n`の数の全ての組み合わせを生成し、それを乗算してみるわけで"
"す。\n"
"もしその積が`n`なら、`n`の因数の組み合わせを見つけたということになります。"

#. type: Plain text
#: text/chapter4.md:229
msgid ""
"We can perform this computation using an array comprehension. We will do so "
"in steps, using PSCi as our interactive development environment."
msgstr ""
"配列内包表記を使用するとこれを計算できます。\n"
"PSCiを対話式の開発環境として使用し、1つずつこの手順を進めていきましょう。"

#. type: Plain text
#: text/chapter4.md:231
msgid ""
"The first step is to generate an array of pairs of numbers below `n`, which "
"we can do using `concatMap`."
msgstr ""
"最初の工程では`n`以下の数の組み合わせの配列を生成しますが、これには"
"`concatMap`を使えばよいです。"

#. type: Plain text
#: text/chapter4.md:233
msgid "Let's start by mapping each number to the array `1 .. n`:"
msgstr ""
"`1 .. n`のそれぞれの数を配列`1 .. n`へとマッピングすることから始めましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:234
#, no-wrap
msgid "> pairs n = concatMap (\\i -> 1 .. n) (1 .. n)\n"
msgstr "> pairs n = concatMap (\\i -> 1 .. n) (1 .. n)\n"

#. type: Plain text
#: text/chapter4.md:239
msgid "We can test our function"
msgstr "この関数をテストしてみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:240
#, no-wrap
msgid ""
"> pairs 3\n"
"[1,2,3,1,2,3,1,2,3]\n"
msgstr ""
"> pairs 3\n"
"[1,2,3,1,2,3,1,2,3]\n"

#. type: Plain text
#: text/chapter4.md:246
msgid ""
"This is not quite what we want. Instead of just returning the second element "
"of each pair, we need to map a function over the inner copy of `1 .. n` "
"which will allow us to keep the entire pair:"
msgstr ""
"これは求めているものとは全然違います。\n"
"単にそれぞれの組み合わせの2つ目の要素を返すのではなく、対全体を保持できるよう"
"に、内側の`1 .. n`の複製について関数を対応付ける必要があります。"

#. type: Fenced code block (text)
#: text/chapter4.md:247
#, no-wrap
msgid ""
"> :paste\n"
"… pairs' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (1 .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"\n"
"> pairs' 3\n"
"[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\n"
msgstr ""
"> :paste\n"
"… pairs' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (1 .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"\n"
"> pairs' 3\n"
"[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\n"

#. type: Plain text
#: text/chapter4.md:260
msgid ""
"This is looking better. However, we are generating too many pairs: we keep "
"both [1, 2] and [2, 1] for example. We can exclude the second case by making "
"sure that `j` only ranges from `i` to `n`:"
msgstr ""
"いい感じになってきました。\n"
"しかし、`[1, 2]`と`[2, 1]`の両方があるように、重複した組み合わせが生成されて"
"います。\n"
"`j`を`i`から`n`の範囲に限定することで、2つ目の場合を取り除くことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:261
#, no-wrap
msgid ""
"> :paste\n"
"… pairs'' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (i .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"> pairs'' 3\n"
"[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n"
msgstr ""
"> :paste\n"
"… pairs'' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (i .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"> pairs'' 3\n"
"[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n"

#. type: Plain text
#: text/chapter4.md:273
msgid ""
"Great! Now that we have all of the pairs of potential factors, we can use "
"`filter` to choose the pairs which multiply to give `n`:"
msgstr ""
"すばらしいです。\n"
"因数の候補の全ての組み合わせを手に入れたので、`filter`を使えば、その積が`n`で"
"あるような組み合わせを選び出すことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:274
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> factors n = filter (\\pair -> product pair == n) (pairs'' n)\n"
"\n"
"> factors 10\n"
"[[1,10],[2,5]]\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> factors n = filter (\\pair -> product pair == n) (pairs'' n)\n"
"\n"
"> factors 10\n"
"[[1,10],[2,5]]\n"

#. type: Plain text
#: text/chapter4.md:284
msgid ""
"This code uses the `product` function from the `Data.Foldable` module in the "
"`foldable-traversable` library."
msgstr ""
"このコードでは、`foldable-traversable`ライブラリの`Data.Foldable`モジュールに"
"ある`product`関数を使っています。"

#. type: Plain text
#: text/chapter4.md:286
msgid ""
"Excellent! We've managed to find the correct set of factor pairs without "
"duplicates."
msgstr ""
"うまくいきました。\n"
"因数の組み合わせの正しい集合を重複なく見つけることができました。"

#. type: Title ##
#: text/chapter4.md:287
#, no-wrap
msgid "Do Notation"
msgstr "do記法"

#. type: Plain text
#: text/chapter4.md:290
msgid ""
"However, we can improve the readability of our code considerably. `map` and "
"`concatMap` are so fundamental, that they (or rather, their generalizations "
"`map` and `bind`) form the basis of a special syntax called _do notation_."
msgstr ""
"しかし、このコードの可読性は大幅に向上できます。`map`や`concatMap`は基本的な"
"関数であり、 _do記法_ (do notation) と呼ばれる特別な構文の基礎になっています"
"（もっと厳密にいえば、それらの一般化である`map`と`bind`が基礎をなしていま"
"す）。"

#. type: Plain text
#: text/chapter4.md:292
msgid ""
"_Note_: Just like `map` and `concatMap` allowed us to write _array "
"comprehensions_, the more general operators `map` and `bind` allow us to "
"write so-called _monad comprehensions_. We'll see plenty more examples of "
"_monads_ later in the book, but in this chapter, we will only consider "
"arrays."
msgstr ""
"*補足*：`map`と`concatMap`が _配列内包表記_ を書けるようにしているように、"
"もっと一般的な演算子である`map`と`bind`は _モナド内包表記_ (monad "
"comprehensions) と呼ばれているものを書けるようにします。本書の後半では _モナ"
"ド_ (monad) の例をたっぷり見ていくことになりますが、この章では配列のみを考え"
"ます。"

#. type: Plain text
#: text/chapter4.md:294
msgid "We can rewrite our `factors` function using do notation as follows:"
msgstr ""
"do記法を使うと、先ほどの`factors`関数を次のように書き直すことができます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:295
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factors}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factors}}\n"

#. type: Plain text
#: text/chapter4.md:300
msgid ""
"The keyword `do` introduces a block of code which uses do notation. The "
"block consists of expressions of a few types:"
msgstr ""
"キーワード`do`はdo記法を使うコードのブロックを導入します。このブロックは幾つ"
"かの種類の式で構成されています。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid ""
"Expressions which bind elements of an array to a name. These are indicated "
"with the backwards-facing arrow `<-`, with a name on the left, and an "
"expression on the right whose type is an array."
msgstr ""
"配列の要素を名前に束縛する式。\n"
"これは後ろ向きの矢印`<-`で示されていて、その左側は名前、右側は配列の型を持つ"
"式です。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid ""
"Expressions which do not bind elements of the array to names. The `do` "
"_result_ is an example of this kind of expression and is illustrated in the "
"last line, `pure [i, j]`."
msgstr ""
"名前に配列の要素を束縛しない式。\n"
"`do`の _結果_ はこの種類の式の一例であり、最後の行の`pure [i, j]`に示されてい"
"ます。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid "Expressions which give names to expressions, using the `let` keyword."
msgstr "`let`キーワードを使用し、式に名前を与える式。"

#. type: Plain text
#: text/chapter4.md:306
#, no-wrap
msgid "This new notation hopefully makes the structure of the algorithm clearer. If you mentally replace the arrow `<-` with the word \"choose\", you might read it as follows: \"choose an element `i` between 1 and n, then choose an element `j` between `i` and `n`, and return `[i, j]`\".\n"
msgstr ""
"この新しい記法を使うと、アルゴリズムの構造がわかりやすくなることがあります。\n"
"頭の中で`<-`を「選ぶ」という単語に置き換えるとすると、「1からnの間の要素`i`を選び、それからiからnの間の要素`j`を選び、`[i, j]`を返す」というように読むことができるでしょう。\n"

#. type: Plain text
#: text/chapter4.md:308
msgid ""
"In the last line, we use the `pure` function. This function can be evaluated "
"in PSCi, but we have to provide a type:"
msgstr ""
"最後の行では、`pure`関数を使っています。この関数はPSCiで評価できますが、型を"
"明示する必要があります。"

#. type: Fenced code block (text)
#: text/chapter4.md:309
#, no-wrap
msgid ""
"> pure [1, 2] :: Array (Array Int)\n"
"[[1, 2]]\n"
msgstr ""
"> pure [1, 2] :: Array (Array Int)\n"
"[[1, 2]]\n"

#. type: Plain text
#: text/chapter4.md:315
msgid ""
"In the case of arrays, `pure` simply constructs a singleton array. In fact, "
"we could modify our `factors` function to use this form, instead of using "
"`pure`:"
msgstr ""
"配列の場合、`pure`は単に1要素の配列を作成します。\n"
"実際、`factors`関数を変更して、`pure`の代わりにこの形式も使うようにできます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:316
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorsV2}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorsV2}}\n"

#. type: Plain text
#: text/chapter4.md:321
msgid "and the result would be the same."
msgstr "そして、結果は同じになります。"

#. type: Title ##
#: text/chapter4.md:322 text/chapter5.md:77
#, no-wrap
msgid "Guards"
msgstr "ガード"

#. type: Plain text
#: text/chapter4.md:325
msgid ""
"One further change we can make to the `factors` function is to move the "
"filter inside the array comprehension. This is possible using the `guard` "
"function from the `Control.Alternative` module (from the `control` package):"
msgstr ""
"`factors`関数を更に改良する方法としては、このフィルタを配列内包表記の内側に移"
"動するというものがあります。\n"
"これは`control`ライブラリにある`Control.Alternative`モジュールの`guard`関数を"
"使用することで可能になります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:326
#, no-wrap
msgid ""
"import Control.Alternative (guard)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:factorsV3}}\n"
msgstr ""
"import Control.Alternative (guard)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:factorsV3}}\n"

#. type: Plain text
#: text/chapter4.md:333
msgid ""
"Just like `pure`, we can apply the `guard` function in PSCi to understand "
"how it works. The type of the `guard` function is more general than we need "
"here:"
msgstr ""
"`pure`と同じように、どのように動作するかを理解するために、PSCiで`guard`関数を"
"適用して調べてみましょう。\n"
"`guard`関数の型は、ここで必要とされるものよりもっと一般的な型になっています。"

#. type: Fenced code block (text)
#: text/chapter4.md:334
#, no-wrap
msgid ""
"> import Control.Alternative\n"
"\n"
"> :type guard\n"
"forall m. Alternative m => Boolean -> m Unit\n"
msgstr ""
"> import Control.Alternative\n"
"\n"
"> :type guard\n"
"forall m. Alternative m => Boolean -> m Unit\n"

#. type: Plain text
#: text/chapter4.md:342
msgid "In our case, we can assume that PSCi reported the following type:"
msgstr "今回の場合は、PSCiは次の型を報告するものと考えてください。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:343
#, no-wrap
msgid "Boolean -> Array Unit\n"
msgstr "Boolean -> Array Unit\n"

#. type: Plain text
#: text/chapter4.md:348
msgid ""
"For our purposes, the following calculations tell us everything we need to "
"know about the `guard` function on arrays:"
msgstr ""
"目的からすると、次の計算の結果から配列における`guard`関数について今知りたいこ"
"とは全てわかります。"

#. type: Fenced code block (text)
#: text/chapter4.md:349
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> length $ guard true\n"
"1\n"
"\n"
"> length $ guard false\n"
"0\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> length $ guard true\n"
"1\n"
"\n"
"> length $ guard false\n"
"0\n"

#. type: Plain text
#: text/chapter4.md:360
msgid ""
"That is, if `guard` is passed an expression which evaluates to `true`, then "
"it returns an array with a single element. If the expression evaluates to "
"`false`, then its result is empty."
msgstr ""
"つまり、`guard`が`true`に評価される式を渡された場合、単一の要素を持つ配列を返"
"すのです。もし式が`false`と評価された場合は、その結果は空です。"

#. type: Plain text
#: text/chapter4.md:362
msgid ""
"This means that if the guard fails, then the current branch of the array "
"comprehension will terminate early with no results. This means that a call "
"to `guard` is equivalent to using `filter` on the intermediate array. "
"Depending on the application, you might prefer to use `guard` instead of a "
"`filter`. Try the two definitions of `factors` to verify that they give the "
"same results."
msgstr ""
"ガードが失敗した場合、配列内包表記の現在の分岐は、結果なしで早めに終了される"
"ことを意味します。\n"
"これは、`guard`の呼び出しが、途中の配列に対して`filter`を使用するのと同じだと"
"いうことです。\n"
"実践の場面にもよりますが、`filter`の代わりに`guard`を使いたいことは多いでしょ"
"う。\n"
"これらが同じ結果になることを確認するために、`factors`の2つの定義を試してみて"
"ください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Easy) Write a function `isPrime` which tests if its integer argument is "
"prime or not. _Hint_: Use the `factors` function."
msgstr ""
"（簡単）整数の引数が素数であるかどうかを調べる関数`isPrime`を定義してみましょ"
"う。\n"
"*手掛かり*：`factors`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Medium) Write a function `cartesianProduct` which uses do notation to find "
"the _cartesian product_ of two arrays, i.e. the set of all pairs of elements "
"`a`, `b`, where `a` is an element of the first array, and `b` is an element "
"of the second."
msgstr ""
"（普通）do記法を使い、2つの配列の*直積集合*を見つけるための関数"
"`cartesianProduct`を書いてみましょう。\n"
"直積集合とは、要素`a`、`b`の全ての組み合わせの集合のことです。\n"
"ここで`a`は最初の配列の要素、`b`は2つ目の配列の要素です。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Medium) Write a function `triples :: Int -> Array (Array Int)` which takes "
"a number `n` and returns all Pythagorean triples whose components (the `a`, "
"`b` and `c` values) are each less than or equal to `n`. A _Pythagorean "
"triple_ is an array of numbers `[a, b, c]` such that `a² + b² = c²`. _Hint_: "
"Use the `guard` function in an array comprehension."
msgstr ""
"（普通）数値`n`を取って構成要素（値`a`, `b`, `c`）がそれぞれ`n`以下であるよう"
"な全てのピタゴラスの3つ組 (pythagorean triples) を返す関数`triples :: Int -> "
"Array (Array Int)`を書いてください。\n"
"*ピタゴラスの3つ組*は数値の配列`[a, b, c]`で `a² + b² = c²` です。\n"
"*手掛かり*：配列内包表記で`guard`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Difficult) Write a function `primeFactors` which produces the [prime "
"factorization](https://www.mathsisfun.com/prime-factorization.html) of `n`, "
"i.e. the array of prime integers whose product is `n`. _Hint_: for an "
"integer greater than 1, break the problem down into two subproblems: finding "
"the first factor, and finding the remaining factors."
msgstr ""
"（難しい）`factors`関数を使用して、数`n`の[素因数分解](https://www."
"mathsisfun.com/prime-factorization.html)を求める関数`primeFactors`を定義して"
"みましょう。\n"
"数`n`の素因数分解とは、素数の積が`n`であるような整数の配列のことです。\n"
"*手掛かり*：1より大きい整数について、問題を2つの部分問題に分解してくださ"
"い。\n"
"最初の因数を探し、それから残りの因数を探すのです。"

#. type: Title ##
#: text/chapter4.md:370
#, no-wrap
msgid "Folds"
msgstr "畳み込み"

#. type: Plain text
#: text/chapter4.md:373
msgid ""
"Left and right folds over arrays provide another class of interesting "
"functions which can be implemented using recursion."
msgstr ""
"配列における左右の畳み込みは、再帰を用いて実装される別の興味深い一揃いの関数"
"を提供します。"

#. type: Plain text
#: text/chapter4.md:375
msgid ""
"Start by importing the `Data.Foldable` module, and inspecting the types of "
"the `foldl` and `foldr` functions using PSCi:"
msgstr ""
"PSCiを使って、`Data.Foldable`モジュールをインポートし、`foldl`と`foldr`関数の"
"型を調べることから始めましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:376
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> :type foldl\n"
"forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b\n"
"\n"
"> :type foldr\n"
"forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> :type foldl\n"
"forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b\n"
"\n"
"> :type foldr\n"
"forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b\n"

#. type: Plain text
#: text/chapter4.md:387
msgid ""
"These types are actually more general than we are interested in right now. "
"For the purposes of this chapter, we can assume that PSCi had given the "
"following (more specific) answer:"
msgstr ""
"これらの型は、現在興味があるものよりも一般化されています。\n"
"この章の目的に対して、PSCiは以下の（より具体的な）答えをくれていると考えてお"
"きましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:388
#, no-wrap
msgid ""
"> :type foldl\n"
"forall a b. (b -> a -> b) -> b -> Array a -> b\n"
"\n"
"> :type foldr\n"
"forall a b. (a -> b -> b) -> b -> Array a -> b\n"
msgstr ""
"> :type foldl\n"
"forall a b. (b -> a -> b) -> b -> Array a -> b\n"
"\n"
"> :type foldr\n"
"forall a b. (a -> b -> b) -> b -> Array a -> b\n"

#. type: Plain text
#: text/chapter4.md:397
msgid ""
"In both of these cases, the type `a` corresponds to the type of elements of "
"our array. The type `b` can be thought of as the type of an \"accumulator\", "
"which will accumulate a result as we traverse the array."
msgstr ""
"どちらの型でも、`a`は配列の要素の型に対応しています。\n"
"型`b`は、配列を走査 (traverse) したときの結果を累積する「累積器」"
"(accumulator) の型だと考えることができます。"

#. type: Plain text
#: text/chapter4.md:399
msgid ""
"The difference between the `foldl` and `foldr` functions is the direction of "
"the traversal. `foldl` folds the array \"from the left\", whereas `foldr` "
"folds the array \"from the right\"."
msgstr ""
"`foldl`関数と`foldr`関数の違いは走査の方向です。\n"
"`foldr`が「右から」配列を畳み込むのに対して、`foldl`は「左から」配列を畳み込"
"みます。"

#. type: Plain text
#: text/chapter4.md:401
#, no-wrap
msgid "Let's see these functions in action. Let's use `foldl` to sum an array of integers. The type `a` will be `Int`, and we can also choose the result type `b` to be `Int`. We need to provide three arguments: a function `Int -> Int -> Int`, which will add the next element to the accumulator, an initial value for the accumulator of type `Int`, and an array of `Int`s to add. For the first argument, we can just use the addition operator, and the initial value of the accumulator will be zero:\n"
msgstr "実際にこれらの関数の動きを見てみましょう。`foldl`を使用して数の配列の和を求めてみます。型`a`は`Int`になり、結果の型`b`も`Int`として選択できます。ここでは、次の要素を累積器に加算する`Int -> Int -> Int`という型の関数、`Int`型の累積器の初期値、和を求めたい`Int`の配列という、3つの引数を提供する必要があります。最初の引数としては、加算演算子を使用できますし、累積器の初期値はゼロになります。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:402
#, no-wrap
msgid ""
"> foldl (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""
"> foldl (+) 0 (1 .. 5)\n"
"15\n"

#. type: Plain text
#: text/chapter4.md:408
msgid ""
"In this case, it didn't matter whether we used `foldl` or `foldr`, because "
"the result is the same, no matter what order the additions happen in:"
msgstr ""
"この場合では、引数が逆になっていても`(+)`関数は同じ結果を返すので、`foldl`と"
"`foldr`のどちらでも問題ありません。"

#. type: Fenced code block (text)
#: text/chapter4.md:409
#, no-wrap
msgid ""
"> foldr (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""
"> foldr (+) 0 (1 .. 5)\n"
"15\n"

#. type: Plain text
#: text/chapter4.md:415
msgid ""
"Let's write an example where the choice of folding function does matter, in "
"order to illustrate the difference. Instead of the addition function, let's "
"use string concatenation to build a string:"
msgstr ""
"`foldl`と`foldr`の違いを説明するために、畳み込み関数の選択が影響する例も書い"
"てみましょう。\n"
"加算関数の代わりに、文字列連結を使用して文字列を作ってみます。"

#. type: Fenced code block (text)
#: text/chapter4.md:416
#, no-wrap
msgid ""
"> foldl (\\acc n -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"12345\"\n"
"\n"
"> foldr (\\n acc -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"54321\"\n"
msgstr ""
"> foldl (\\acc n -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"12345\"\n"
"\n"
"> foldr (\\n acc -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"54321\"\n"

#. type: Plain text
#: text/chapter4.md:425
msgid ""
"This illustrates the difference between the two functions. The left fold "
"expression is equivalent to the following application:"
msgstr ""
"これは、2つの関数の違いを示しています。左畳み込み式は、以下の関数適用と同等で"
"す。"

#. type: Fenced code block (text)
#: text/chapter4.md:426
#, no-wrap
msgid "(((((\"\" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)\n"
msgstr "(((((\"\" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)\n"

#. type: Plain text
#: text/chapter4.md:431
msgid "whereas the right fold is equivalent to this:"
msgstr "それに対し、右畳み込みは以下に相当します。"

#. type: Fenced code block (text)
#: text/chapter4.md:432
#, no-wrap
msgid "(((((\"\" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)\n"
msgstr "(((((\"\" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)\n"

#. type: Title ##
#: text/chapter4.md:436
#, no-wrap
msgid "Tail Recursion"
msgstr "末尾再帰"

#. type: Plain text
#: text/chapter4.md:439
msgid ""
"Recursion is a powerful technique for specifying algorithms, but comes with "
"a problem: evaluating recursive functions in JavaScript can lead to stack "
"overflow errors if our inputs are too large."
msgstr ""
"再帰はアルゴリズムを定義するための強力な手法ですが、問題も抱えています。\n"
"JavaScriptで再帰関数を評価するとき、入力が大きすぎるとスタックオーバーフロー"
"でエラーを起こす可能性があるのです。"

#. type: Plain text
#: text/chapter4.md:441
msgid "It is easy to verify this problem, with the following code in PSCi:"
msgstr "PSCiで次のコードを入力すると、この問題を簡単に検証できます。"

#. type: Fenced code block (text)
#: text/chapter4.md:442
#, no-wrap
msgid ""
"> :paste\n"
"… f n =\n"
"…   if n == 0\n"
"…     then 0\n"
"…     else 1 + f (n - 1)\n"
"… ^D\n"
"\n"
"> f 10\n"
"10\n"
"\n"
"> f 100000\n"
"RangeError: Maximum call stack size exceeded\n"
msgstr ""
"> :paste\n"
"… f n =\n"
"…   if n == 0\n"
"…     then 0\n"
"…     else 1 + f (n - 1)\n"
"… ^D\n"
"\n"
"> f 10\n"
"10\n"
"\n"
"> f 100000\n"
"RangeError: Maximum call stack size exceeded\n"

#. type: Plain text
#: text/chapter4.md:458
msgid ""
"This is a problem. If we are going to adopt recursion as a standard "
"technique from functional programming, then we need a way to deal with "
"possibly unbounded recursion."
msgstr ""
"これは問題です。関数型プログラミングの基本的な手法として再帰を採用しようとす"
"るなら、境界がない可能性がある再帰でも扱える方法が必要です。"

#. type: Plain text
#: text/chapter4.md:460
msgid ""
"PureScript provides a partial solution to this problem in the form of _tail "
"recursion optimization_."
msgstr ""
"PureScriptは _末尾再帰最適化_ (tail recursion optimization) の形でこの問題に"
"対する部分的な解決策を提供しています。"

#. type: Plain text
#: text/chapter4.md:462
msgid ""
"_Note_: more complete solutions to the problem can be implemented in "
"libraries using so-called _trampolining_, but that is beyond the scope of "
"this chapter. The interested reader can consult the documentation for the "
"[`free`](https://pursuit.purescript.org/packages/purescript-free) and "
"[`tailrec`](https://pursuit.purescript.org/packages/purescript-tailrec) "
"packages."
msgstr ""
"*補足*：この問題へのより完全な解決策としては、いわゆる*トランポリン*を使用し"
"たライブラリで実装する方法がありますが、それはこの章で扱う範囲を超えていま"
"す。\n"
"この内容に興味のある読者は[`free`](https://pursuit.purescript.org/packages/"
"purescript-free)や[`tailrec`](https://pursuit.purescript.org/packages/"
"purescript-tailrec)パッケージのドキュメントを参照してみてください。"

#. type: Plain text
#: text/chapter4.md:464
msgid ""
"The key observation which enables tail recursion optimization is the "
"following: a recursive call in _tail position_ to a function can be replaced "
"with a _jump_, which does not allocate a stack frame. A call is in _tail "
"position_ when it is the last call made before a function returns. This is "
"the reason why we observed a stack overflow in the example - the recursive "
"call to `f` was _not_ in tail position."
msgstr ""
"末尾再帰最適化を可能にする上で鍵となる観点は以下となります。 _末尾位置_ "
"(tail position) にある関数の再帰的な呼び出しは、スタックフレームが確保されな"
"い _ジャンプ_ に置き換えることができます。関数が戻るより前の最後の呼び出しで"
"あるとき、呼び出しが _末尾位置_ にあるといいます。なぜこの例でスタックオー"
"バーフローが見られたのかはこれが理由です。この`f`の再帰呼び出しは、末尾位置 _"
"ではない_ からです。"

#. type: Plain text
#: text/chapter4.md:466
msgid ""
"In practice, the PureScript compiler does not replace the recursive call "
"with a jump, but rather replaces the entire recursive function with a _while "
"loop_."
msgstr ""
"実際には、PureScriptコンパイラは再帰呼び出しをジャンプに置き換えるのではな"
"く、再帰的な関数全体を _whileループ_ に置き換えます。"

#. type: Plain text
#: text/chapter4.md:468
msgid ""
"Here is an example of a recursive function with all recursive calls in tail "
"position:"
msgstr "以下は全ての再帰呼び出しが末尾位置にある再帰関数の例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:469
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorialTailRec}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorialTailRec}}\n"

#. type: Plain text
#: text/chapter4.md:474
msgid ""
"Notice that the recursive call to `factorialTailRec` is the last thing that "
"happens in this function - it is in tail position."
msgstr ""
"`fact`への再帰呼び出しは、この関数の中で起こる最後のものである、つまり末尾位"
"置にあることに注意してください。"

#. type: Title ##
#: text/chapter4.md:475
#, no-wrap
msgid "Accumulators"
msgstr "累積器"

#. type: Plain text
#: text/chapter4.md:478
msgid ""
"One common way to turn a function which is not tail recursive into a tail "
"recursive function is to use an _accumulator parameter_. An accumulator "
"parameter is an additional parameter which is added to a function which "
"_accumulates_ a return value, as opposed to using the return value to "
"accumulate the result."
msgstr ""
"末尾再帰ではない関数を末尾再帰関数に変える一般的な方法としては、 _累積器引数"
"_ (accumulator parameter) を使用する方法があります。累積器引数は関数に追加さ"
"れる余剰の引数で返り値を _累積_ するものです。これは結果を累積するために返り"
"値を使うのとは対称的です。"

#. type: Plain text
#: text/chapter4.md:480
msgid ""
"For example, consider again the `length` function presented in the beginning "
"of the chapter:"
msgstr "例えば章の初めに示した`length`関数を再考しましょう。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:481
#, no-wrap
msgid ""
"length :: forall a. Array a -> Int\n"
"length arr =\n"
"  if null arr\n"
"    then 0\n"
"    else 1 + (length $ fromMaybe [] $ tail arr)\n"
msgstr ""
"length :: forall a. Array a -> Int\n"
"length arr =\n"
"  if null arr\n"
"    then 0\n"
"    else 1 + (length $ fromMaybe [] $ tail arr)\n"

#. type: Plain text
#: text/chapter4.md:490
msgid ""
"This implementation is not tail recursive, so the generated JavaScript will "
"cause a stack overflow when executed on a large input array. However, we can "
"make it tail recursive, by introducing a second function argument to "
"accumulate the result instead:"
msgstr ""
"この実装は末尾再帰ではないので、大きな入力配列に対して実行されると、生成され"
"たJavaScriptはスタックオーバーフローを発生させるでしょう。\n"
"しかし代わりに、結果を蓄積するための2つ目の引数を関数に導入することで、これを"
"末尾再帰に変えることができます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:491
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:lengthTailRec}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:lengthTailRec}}\n"

#. type: Plain text
#: text/chapter4.md:496
msgid ""
"In this case, we delegate to the helper function `length'`, which is tail "
"recursive - its only recursive call is in the last case, and is in tail "
"position. This means that the generated code will be a _while loop_, and "
"will not blow the stack for large inputs."
msgstr ""
"ここでは、配列を逆転させる作業を補助関数`length'`に委譲しています。`length'`"
"は末尾再帰です。その唯一の再帰呼び出しは、最後の場合の末尾位置にあります。こ"
"れは、生成されたコードが _whileループ_ となり、大きな入力でもスタックが溢れな"
"いことを意味します。"

#. type: Plain text
#: text/chapter4.md:498
msgid ""
"To understand the implementation of `lengthTailRec`, note that the helper "
"function `length'` essentially uses the accumulator parameter to maintain an "
"additional piece of state - the partial result. It starts out at 0, and "
"grows by adding 1 for every element in the input array."
msgstr ""
"`lengthTailRec`の実装を理解するために補助関数`length'`に着目しましょう。この"
"関数は必然的に累積器引数を使って追加の状態……これは部分的な結果です……を保持し"
"ています。0から始まり、入力の配列中の全ての要素それぞれについて1ずつ足されて"
"大きくなっていきます。"

#. type: Plain text
#: text/chapter4.md:500
msgid ""
"Note also that while we might think of the accumulator as \"state\", there "
"is no direct mutation going on."
msgstr ""
"累積器を「状態」と考えることもできますが、直接には変更されているわけではない"
"ことにも注意してください。"

#. type: Title ##
#: text/chapter4.md:501
#, no-wrap
msgid "Prefer Folds to Explicit Recursion"
msgstr "明示的な再帰より畳み込みを選ぼう"

#. type: Plain text
#: text/chapter4.md:504
msgid ""
"If we can write our recursive functions using tail recursion, then we can "
"benefit from tail recursion optimization, so it becomes tempting to try to "
"write all of our functions in this form. However, it is often easy to forget "
"that many functions can be written directly as a fold over an array or "
"similar data structure. Writing algorithms directly in terms of combinators "
"such as `map` and `fold` has the added advantage of code simplicity - these "
"combinators are well-understood, and as such, communicate the _intent_ of "
"the algorithm much better than explicit recursion."
msgstr ""
"末尾再帰を使用して再帰関数を記述できれば末尾再帰最適化の恩恵を受けることがで"
"きるので、全ての関数をこの形で書こうとする誘惑にかられます。\n"
"しかし、多くの関数は配列やそれに似たデータ構造に対する折り畳みとして直接書く"
"ことができることを忘れがちです。\n"
"`map`や`fold`のような組み合わせの部品を使って直接アルゴリズムを書くことには、"
"コードの単純さという利点があります。\n"
"これらの部品はよく知られており、明示的な再帰よりもアルゴリズムの*意図*をより"
"はっきりとさせるのです。"

#. type: Plain text
#: text/chapter4.md:506
msgid "For example, we can reverse an array using `foldr`:"
msgstr "例えば`foldr`を使って配列を反転できます。"

#. type: Fenced code block (text)
#: text/chapter4.md:507
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> :paste\n"
"… reverse :: forall a. Array a -> Array a\n"
"… reverse = foldr (\\x xs -> xs <> [x]) []\n"
"… ^D\n"
"\n"
"> reverse [1, 2, 3]\n"
"[3,2,1]\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> :paste\n"
"… reverse :: forall a. Array a -> Array a\n"
"… reverse = foldr (\\x xs -> xs <> [x]) []\n"
"… ^D\n"
"\n"
"> reverse [1, 2, 3]\n"
"[3,2,1]\n"

#. type: Plain text
#: text/chapter4.md:520
msgid ""
"Writing `reverse` in terms of `foldl` will be left as an exercise for the "
"reader."
msgstr ""
"`foldl`を使って`reverse`を書くことは、読者への課題として残しておきます。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:527
msgid ""
"(Easy) Write a function `allTrue` which uses `foldl` to test whether an "
"array of boolean values are all true."
msgstr ""
"（簡単）`foldl`を使って真偽値配列の値が全て真か検査する関数`allTrue`を書いて"
"ください。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:527
msgid ""
"(Medium - No Test) Characterize those arrays `xs` for which the function "
"`foldl (==) false xs` returns `true`. In other words, complete the sentence: "
"\"The function returns `true` when `xs` contains ...\""
msgstr ""
"（普通。テストなし）関数`foldl (==) false xs`が真を返すような配列`xs`とはどの"
"ようなものか説明してください。\n"
"言い換えると、「関数は`xs`が……を含むときに`true`を返す」という文を完成させる"
"ことになります。"

#. type: Bullet: ' 3. '
#: text/chapter4.md:527
msgid ""
"(Medium) Write a function `fibTailRec` which is the same as `fib` but in "
"tail recursive form. _Hint_: Use an accumulator parameter."
msgstr ""
"（普通）末尾再帰の形式を取っていること以外は`fib`と同じような関数`fibTailRec`"
"を書いてください。\n"
"*手掛かり*：累積器引数を使ってください。"

#. type: Bullet: ' 4. '
#: text/chapter4.md:527
msgid "(Medium) Write `reverse` in terms of `foldl`."
msgstr "（普通）`foldl`を使って`reverse`を書いてみましょう。"

#. type: Title ##
#: text/chapter4.md:528
#, no-wrap
msgid "A Virtual Filesystem"
msgstr "仮想ファイルシステム"

#. type: Plain text
#: text/chapter4.md:531
msgid ""
"In this section, we're going to apply what we've learned, writing functions "
"which will work with a model of a filesystem. We will use maps, folds and "
"filters to work with a predefined API."
msgstr ""
"この節では、これまで学んだことを応用して、模擬的なファイルシステムで動作する"
"関数を書いていきます。\n"
"事前に定義されたAPIで動作するように、マップ、畳み込み、及びフィルタを使用しま"
"す。"

#. type: Plain text
#: text/chapter4.md:533
msgid ""
"The `Data.Path` module defines an API for a virtual filesystem, as follows:"
msgstr ""
"`Data.Path`モジュールでは、次のように仮想ファイルシステムのAPIが定義されてい"
"ます。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "There is a type `Path` which represents a path in the filesystem."
msgstr "ファイルシステム内のパスを表す型`Path`があります。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "There is a path `root` which represents the root directory."
msgstr "ルートディレクトリを表すパス`root`があります。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "The `ls` function enumerates the files in a directory."
msgstr "`ls`関数はディレクトリ内のファイルを列挙します。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid "The `filename` function returns the file name for a `Path`."
msgstr "`filename`関数は`Path`のファイル名を返します。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid ""
"The `size` function returns the file size for a `Path` which represents a "
"file."
msgstr "`size`関数は`Path`が示すファイルの大きさを返します。"

#. type: Bullet: '- '
#: text/chapter4.md:540
msgid ""
"The `isDirectory` function tests whether a `Path` is a file or a directory."
msgstr "`isDirectory`関数はファイルかディレクトリかを調べます。"

#. type: Plain text
#: text/chapter4.md:542
msgid "In terms of types, we have the following type definitions:"
msgstr "型について言うと、次のような型定義があります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:543
#, no-wrap
msgid ""
"root :: Path\n"
"\n"
"ls :: Path -> Array Path\n"
"\n"
"filename :: Path -> String\n"
"\n"
"size :: Path -> Maybe Int\n"
"\n"
"isDirectory :: Path -> Boolean\n"
msgstr ""
"root :: Path\n"
"\n"
"ls :: Path -> Array Path\n"
"\n"
"filename :: Path -> String\n"
"\n"
"size :: Path -> Maybe Int\n"
"\n"
"isDirectory :: Path -> Boolean\n"

#. type: Plain text
#: text/chapter4.md:556
msgid "We can try out the API in PSCi:"
msgstr "PSCiでこのAPIを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:557
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Path\n"
"\n"
"> root\n"
"/\n"
"\n"
"> isDirectory root\n"
"true\n"
"\n"
"> ls root\n"
"[/bin/,/etc/,/home/]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.Path\n"
"\n"
"> root\n"
"/\n"
"\n"
"> isDirectory root\n"
"true\n"
"\n"
"> ls root\n"
"[/bin/,/etc/,/home/]\n"

#. type: Plain text
#: text/chapter4.md:573
msgid ""
"The `Test.Examples` module defines functions which use the `Data.Path` API. "
"You do not need to modify the `Data.Path` module, or understand its "
"implementation. We will work entirely in the `Test.Examples` module."
msgstr ""
"`Test.Examples`モジュールでは`Data.Path`APIを使用する関数を定義しています。\n"
"`Data.Path`モジュールを変更したり定義を理解したりする必要はありません。\n"
"全て`Test.Examples`モジュールだけで作業します。"

#. type: Title ##
#: text/chapter4.md:574
#, no-wrap
msgid "Listing All Files"
msgstr "全てのファイルの一覧"

#. type: Plain text
#: text/chapter4.md:577
msgid ""
"Let's write a function which performs a deep enumeration of all files inside "
"a directory. This function will have the following type:"
msgstr ""
"それでは、ディレクトリの中身を含めた全てのファイルを列挙する関数を書いてみま"
"しょう。この関数は以下のような型を持つでしょう。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:578
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_signature}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_signature}}\n"

#. type: Plain text
#: text/chapter4.md:583
msgid ""
"We can define this function by recursion. First, we can use `ls` to "
"enumerate the immediate children of the directory. For each child, we can "
"recursively apply `allFiles`, which will return an array of paths. "
"`concatMap` will allow us to apply `allFiles` and flatten the results at the "
"same time."
msgstr ""
"再帰を使ってこの関数を定義できます。まずは`ls`を使用してディレクトリの直接の"
"子を列挙します。それぞれの子について再帰的に`allFiles`を適用すると、それぞれ"
"パスの配列が返ってくるでしょう。同時に`concatMap`を適用すると、この結果を平坦"
"にできます。"

#. type: Plain text
#: text/chapter4.md:585
msgid "Finally, we use the cons operator `:` to include the current file:"
msgstr "最後に、cons演算子`:`を使って現在のファイルも含めます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:586
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_implementation}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_implementation}}\n"

#. type: Plain text
#: text/chapter4.md:591
msgid ""
"_Note_: the cons operator `:` actually has poor performance on immutable "
"arrays, so it is not recommended in general. Performance can be improved by "
"using other data structures, such as linked lists and sequences."
msgstr ""
"*補足*：実はcons演算子`:`は、不変な配列に対して効率性が悪いので、一般的には推"
"奨されません。\n"
"連結リストやシーケンスなどの他のデータ構造を使用すると、効率性を向上させるこ"
"とができます。"

#. type: Plain text
#: text/chapter4.md:593
msgid "Let's try this function in PSCi:"
msgstr "それではPSCiでこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:594
#, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.Path\n"
"\n"
"> allFiles root\n"
"\n"
"[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]\n"
msgstr ""
"> import Test.Examples\n"
"> import Data.Path\n"
"\n"
"> allFiles root\n"
"\n"
"[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]\n"

#. type: Plain text
#: text/chapter4.md:604
msgid ""
"Great! Now let's see if we can write this function using an array "
"comprehension using do notation."
msgstr ""
"すばらしいです。\n"
"do記法で配列内包表記を使ってもこの関数を書くことができるので見ていきましょ"
"う。"

#. type: Plain text
#: text/chapter4.md:606
msgid ""
"Recall that a backwards arrow corresponds to choosing an element from an "
"array. The first step is to choose an element from the immediate children of "
"the argument. Then we simply call the function recursively for that file. "
"Since we are using do notation, there is an implicit call to `concatMap` "
"which concatenates all of the recursive results."
msgstr ""
"逆向きの矢印は配列から要素を選択するのに相当することを思い出してください。\n"
"最初の工程は引数の直接の子から要素を選択することです。\n"
"それから、単にそのファイルに対してこの再帰関数を呼びします。\n"
"do記法を使用しているので、再帰的な結果を全て連結する`concatMap`が暗黙に呼び出"
"されています。"

#. type: Plain text
#: text/chapter4.md:608
msgid "Here is the new version:"
msgstr "新しいバージョンは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:609
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_2}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_2}}\n"

#. type: Plain text
#: text/chapter4.md:614
msgid ""
"Try out the new version in PSCi - you should get the same result. I'll let "
"you decide which version you find clearer."
msgstr ""
"PSCiで新しいコードを試してみてください。同じ結果が返ってくるはずです。どちら"
"のほうがわかりやすいかの選定はお任せします。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:619
msgid ""
"(Easy) Write a function `onlyFiles` which returns all _files_ (not "
"directories) in all subdirectories of a directory."
msgstr ""
"（簡単）ディレクトリの全てのサブディレクトリの中にある（ディレクトリを除く）"
"全てのファイルを返すような関数`onlyFiles`を書いてみてください。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:619
msgid ""
"(Medium) Write a function `whereIs` to search for a file by name. The "
"function should return a value of type `Maybe Path`, indicating the "
"directory containing the file, if it exists. It should behave as follows:"
msgstr ""
"（普通）ファイルを名前で検索する関数`whereIs`を書いてください。\n"
"この関数は型`Maybe Path`の値を返すものとします。\n"
"この値が存在するなら、そのファイルがそのディレクトリに含まれているということ"
"を表します。\n"
"この関数は次のように振る舞う必要があります。"

#. type: Plain text
#: text/chapter4.md:623
#, no-wrap
msgid ""
"     ```text\n"
"     > whereIs root \"ls\"\n"
"     Just (/bin/)\n"
msgstr ""
"     ```text\n"
"     > whereIs root \"ls\"\n"
"     Just (/bin/)\n"

#. type: Plain text
#: text/chapter4.md:627
#, no-wrap
msgid ""
"     > whereIs root \"cat\"\n"
"     Nothing\n"
"     ```\n"
msgstr ""
"     > whereIs root \"cat\"\n"
"     Nothing\n"
"     ```\n"

#. type: Plain text
#: text/chapter4.md:630
#, no-wrap
msgid ""
"     _Hint_: Try to write this function as an array comprehension using do notation.\n"
" 3. (Difficult) Write a function `largestSmallest` which takes a `Path` and returns an array containing the single largest and single smallest files in the `Path`. _Note_: consider the cases where there are zero or one files in the `Path` by returning an empty array or a one-element array respectively.\n"
msgstr ""
"     *手掛かり*：この関数をdo記法を使った配列内包表記で書いてみましょう。\n"
" 3. （難しい）`Path`を取って`Path`に最大のファイルと最小のファイルを1つずつ含む配列を返す関数`largestSmallest`を書いてください。\n"
"    *補足*：空配列や1要素の配列を返すことで、`Path`にゼロか1個のファイルがある場合についても考慮してください。\n"

#. type: Plain text
#: text/chapter4.md:633
msgid ""
"In this chapter, we covered the basics of recursion in PureScript, as a "
"means of expressing algorithms concisely. We also introduced user-defined "
"infix operators, standard functions on arrays such as maps, filters and "
"folds, and array comprehensions which combine these ideas. Finally, we "
"showed the importance of using tail recursion in order to avoid stack "
"overflow errors, and how to use accumulator parameters to convert functions "
"to tail recursive form."
msgstr ""
"この章では、アルゴリズムを簡潔に表現する手段として、PureScriptでの再帰の基本"
"を説明しました。\n"
"また、独自の中置演算子や、マップ、絞り込みや畳み込みなどの配列に対する標準関"
"数、及びこれらの概念を組み合わせた配列内包表記を導入しました。\n"
"最後に、スタックオーバーフローエラーを回避するために末尾再帰を使用することの"
"重要性、累積器引数を使用して末尾再帰形に関数を変換する方法を示しました。"

#. type: Title #
#: text/chapter5.md:1
#, no-wrap
msgid "Pattern Matching"
msgstr "パターン照合"

#. type: Plain text
#: text/chapter5.md:6
msgid ""
"This chapter will introduce two new concepts: algebraic data types, and "
"pattern matching. We will also briefly cover an interesting feature of the "
"PureScript type system: row polymorphism."
msgstr ""
"この章では、代数的データ型とパターン照合という、2つの新しい概念を導入します。"
"また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱"
"います。"

#. type: Plain text
#: text/chapter5.md:8
msgid ""
"Pattern matching is a common technique in functional programming and allows "
"the developer to write compact functions which express potentially complex "
"ideas, by breaking their implementation down into multiple cases."
msgstr ""
"パターン照合は関数型プログラミングにおける一般的な手法で、複数の場合に実装を"
"分解することにより、開発者は水面下では複雑な動作をする関数を簡潔に書くことが"
"できます。"

#. type: Plain text
#: text/chapter5.md:10
msgid ""
"Algebraic data types are a feature of the PureScript type system which "
"enable a similar level of expressiveness in the language of types - they are "
"closely related to pattern matching."
msgstr ""
"代数的データ型はPureScriptの型システムの機能であり、型のある言語において同等"
"の水準の表現力を可能にしています。パターン照合とも密接に関連しています。"

#. type: Plain text
#: text/chapter5.md:12
msgid ""
"The goal of the chapter will be to write a library to describe and "
"manipulate simple vector graphics using algebraic types and pattern matching."
msgstr ""
"この章の目的は、代数的データ型やパターン照合を使用して、単純なベクターグラ"
"フィックスを描画し操作するためのライブラリを書くことです。"

#. type: Plain text
#: text/chapter5.md:16
msgid ""
"The source code for this chapter is defined in the file `src/Data/Picture."
"purs`."
msgstr ""
"この章のソースコードはファイル `src/Data/Picture.purs`で定義されています。"

#. type: Plain text
#: text/chapter5.md:18
msgid ""
"The `Data.Picture` module defines a data type `Shape` for simple shapes, and "
"a type `Picture` for collections of shapes, along with functions for working "
"with those types."
msgstr ""
"`Data.Picture`モジュールは、簡単な図形を表すデータ型 `Shape`や、図形の集合で"
"ある型 `Picture`、及びこれらの型を扱うための関数を定義しています。"

#. type: Plain text
#: text/chapter5.md:20
msgid ""
"The module imports the `Data.Foldable` module, which provides functions for "
"folding data structures:"
msgstr ""
"このモジュールでは、データ構造の畳込みを行う関数を提供する `Data.Foldable`モ"
"ジュールもインポートします。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:21
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:module_picture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:module_picture}}\n"

#. type: Plain text
#: text/chapter5.md:26
msgid ""
"The `Data.Picture` module also imports the `Number` module, but this time "
"using the `as` keyword:"
msgstr ""
"`Data.Picture`モジュールは`Number`モジュールもインポートしますが、こちらは"
"`as`キーワードを使います。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:27
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:picture_import_as}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:picture_import_as}}\n"

#. type: Plain text
#: text/chapter5.md:32
msgid ""
"This makes the types and functions in that module available for use, but "
"only by using the _qualified name_, like `Number.max`. This can be useful to "
"avoid overlapping imports, or just to make it clearer which modules certain "
"things are imported from."
msgstr ""
"こうすると型や関数をモジュール内で使用できるようになりますが、`Number.max`の"
"ように*修飾名*を使ったときに限定されます。重複したインポートを避けたり、どの"
"モジュールからインポートされたのかを明らかにするのに役立ちます。"

#. type: Plain text
#: text/chapter5.md:34
msgid ""
"_Note_: it is not necessary to use the same module name as the original "
"module for a qualified import. Shorter qualified names like `import Data."
"Number as N` are possible, and quite common."
msgstr ""
"*補足*：元のモジュールと同じモジュール名を修飾名に使用する必要はありませ"
"ん。\n"
"`import Math as M`などのより短い名前にできますし、かなりよく見掛けます。"

#. type: Title ##
#: text/chapter5.md:35
#, no-wrap
msgid "Simple Pattern Matching"
msgstr "単純なパターン照合"

#. type: Plain text
#: text/chapter5.md:38
msgid ""
"Let's begin by looking at an example. Here is a function which computes the "
"greatest common divisor of two integers using pattern matching:"
msgstr ""
"それではコード例を見ることから始めましょう。\n"
"パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになりま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:39
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcd}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcd}}\n"

#. type: Plain text
#: text/chapter5.md:44
msgid ""
"This algorithm is called the Euclidean Algorithm. If you search for its "
"definition online, you will likely find a set of mathematical equations "
"which look a lot like the code above. This is one benefit of pattern "
"matching: it allows you to define code by cases, writing simple, declarative "
"code which looks like a specification of a mathematical function."
msgstr ""
"このアルゴリズムはユークリッドの互除法と呼ばれています。\n"
"その定義をオンラインで検索すると、恐らく上記のコードによく似た数学の方程式が"
"見つかるでしょう。\n"
"パターン照合の利点の1つは、上記のようにコードを場合分けして定義でき、数学関数"
"の定義と似たような簡潔で宣言型なコードを書くことができることです。"

#. type: Plain text
#: text/chapter5.md:46
msgid ""
"A function written using pattern matching works by pairing sets of "
"conditions with their results. Each line is called an _alternative_ or a "
"_case_. The expressions on the left of the equals sign are called "
"_patterns_, and each case consists of one or more patterns, separated by "
"spaces. Cases describe which conditions the arguments must satisfy before "
"the expression on the right of the equals sign should be evaluated and "
"returned. Each case is tried in order, and the first case whose patterns "
"match their inputs determines the return value."
msgstr ""
"パターン照合を使用して書かれた関数は、条件と結果の組み合わせによって動作しま"
"す。\n"
"この定義の各行は*選択肢*や*場合*と呼ばれています。\n"
"等号の左辺の式は*パターン*と呼ばれており、それぞれの場合は空白で区切られた1つ"
"以上のパターンで構成されています。\n"
"場合の集まりは、等号の右側の式が評価され値が返される前に、引数が満たさなけれ"
"ばならない条件を表現しています。\n"
"それぞれの場合は上からこの順番に試されていき、最初に入力に適合した場合が返り"
"値を決定します。"

#. type: Plain text
#: text/chapter5.md:48
msgid "For example, the `gcd` function is evaluated using the following steps:"
msgstr "例えば`gcd`関数は次の手順で評価されます。"

#. type: Bullet: '- '
#: text/chapter5.md:52
msgid ""
"The first case is tried: if the second argument is zero, the function "
"returns `n` (the first argument)."
msgstr ""
"まず最初の場合が試されます。\n"
"第2引数がゼロの場合、関数は `n`（最初の引数）を返します。"

#. type: Bullet: '- '
#: text/chapter5.md:52
msgid ""
"If not, the second case is tried: if the first argument is zero, the "
"function returns `m` (the second argument)."
msgstr ""
"そうでなければ、2番目の場合が試されます。\n"
"最初の引数がゼロの場合、関数は `m`（第2引数）を返します。"

#. type: Bullet: '- '
#: text/chapter5.md:52
msgid ""
"Otherwise, the function evaluates and returns the expression in the last "
"line."
msgstr "それ以外の場合、関数は最後の行の式を評価して返します。"

#. type: Plain text
#: text/chapter5.md:54
msgid ""
"Note that patterns can bind values to names - each line in the example binds "
"one or both of the names `n` and `m` to the input values. As we learn about "
"different kinds of patterns, we will see that different types of patterns "
"correspond to different ways to choose names from the input arguments."
msgstr ""
"なお、パターンでは値を名前に束縛できます。\n"
"この例の各行では `n`や`m`という名前の何れかまたは両方に入力された値を束縛して"
"います。\n"
"さまざまな種類のパターンについて学んでいくうちに、それぞれの種類のパターンが"
"入力の引数から名前を選ぶさまざまな方法に対応することがわかるでしょう。"

#. type: Title ##
#: text/chapter5.md:55
#, no-wrap
msgid "Simple Patterns"
msgstr "単純なパターン"

#. type: Plain text
#: text/chapter5.md:58
msgid "The example code above demonstrates two types of patterns:"
msgstr "上記のコード例では、2種類のパターンを示しました。"

#. type: Bullet: '- '
#: text/chapter5.md:61
msgid ""
"Integer literals patterns, which match something of type `Int`, only if the "
"value matches exactly."
msgstr "`Int`型の値が正確に一致する場合にのみ適合する、整数直値パターン"

#. type: Bullet: '- '
#: text/chapter5.md:61
msgid "Variable patterns, which bind their argument to a name"
msgstr "引数を名前に束縛する、変数パターン"

#. type: Plain text
#: text/chapter5.md:63
msgid "There are other types of simple patterns:"
msgstr "単純なパターンには他にも種類があります。"

#. type: Bullet: '- '
#: text/chapter5.md:66
msgid "`Number`, `String`, `Char` and `Boolean` literals"
msgstr "`Number`、`String`、`Char`、そして`Boolean`といった直値"

#. type: Bullet: '- '
#: text/chapter5.md:66
msgid ""
"Wildcard patterns, indicated with an underscore (`_`), which match any "
"argument, and which do not bind any names."
msgstr ""
"どんな引数とも適合するが名前に束縛はしない、アンダースコア (`_`) で表されるワ"
"イルドカードパターン"

#. type: Plain text
#: text/chapter5.md:68
msgid ""
"Here are two more examples which demonstrate using these simple patterns:"
msgstr "ここではこれらの単純なパターンを使用して、もう2つ例を示します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:69
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:fromString}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:toString}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:fromString}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:toString}}\n"

#. type: Plain text
#: text/chapter5.md:76
msgid "Try these functions in PSCi."
msgstr "PSCiでこれらの関数を試してみてください。"

#. type: Plain text
#: text/chapter5.md:80
#, no-wrap
msgid "In the Euclidean algorithm example, we used an `if .. then .. else` expression to switch between the two alternatives when `m > n` and `m <= n`. Another option in this case would be to use a _guard_.\n"
msgstr "ユークリッドの互除法の例では、`m > n`のときと `m <= n`のときの2つに分岐するために `if .. then .. else`式を使っていました。こういうときには他に _ガード_ (guard) を使うという選択肢もあります。\n"

#. type: Plain text
#: text/chapter5.md:82
msgid ""
"A guard is a boolean-valued expression which must be satisfied in addition "
"to the constraints imposed by the patterns. Here is the Euclidean algorithm "
"rewritten to use a guard:"
msgstr ""
"ガードはパターンによる制約に加えて満たされなくてはいけない真偽値の式です。\n"
"ガードを使用してユークリッドの互除法を書き直すと、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:83
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcdV2}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcdV2}}\n"

#. type: Plain text
#: text/chapter5.md:88
msgid ""
"In this case, the third line uses a guard to impose the extra condition that "
"the first argument is strictly larger than the second. The guard in the "
"final line uses the expression `otherwise`, which might seem like a keyword, "
"but is in fact just a regular binding in `Prelude`:"
msgstr ""
"この場合、3行目ではガードを使用して、最初の引数が第2引数よりも厳密に大きいと"
"いう条件を付け加えています。最後の行でのガードは式`otherwise`を使っており、"
"キーワードのようにも見えますが、実際はただの`Prelude`にある通常の束縛です。"

#. type: Fenced code block (text)
#: text/chapter5.md:89
#, no-wrap
msgid ""
"> :type otherwise\n"
"Boolean\n"
"\n"
"> otherwise\n"
"true\n"
msgstr ""
"> :type otherwise\n"
"Boolean\n"
"\n"
"> otherwise\n"
"true\n"

#. type: Plain text
#: text/chapter5.md:98
msgid ""
"As this example demonstrates, guards appear on the left of the equals "
"symbol, separated from the list of patterns by a pipe character (`|`)."
msgstr ""
"この例が示すように、ガードは等号の左側に現れ、パイプ文字 (`|`) でパターンのリ"
"ストと区切られています。"

#. type: Bullet: '1. '
#: text/chapter5.md:104
msgid ""
"(Easy) Write the `factorial` function using pattern matching. _Hint_: "
"Consider the two corner cases of zero and non-zero inputs. _Note_: This is a "
"repeat of an example from the previous chapter, but see if you can rewrite "
"it here on your own."
msgstr ""
"（簡単）パターン照合を使用して、階乗関数`factorial`を書いてみましょう。\n"
"*手掛かり*：入力がゼロのときとゼロでないときの、2つの特殊な場合を考えてみてく"
"ださい。\n"
"*補足*：これは前の章の例の反復ですが、ここでは自力で書き直せるかやってみてく"
"ださい。"

#. type: Bullet: '1. '
#: text/chapter5.md:104
msgid ""
"(Medium) Write a function `binomial` which finds the coefficient of the "
"x^`k`th term in the polynomial expansion of (1 + x)^`n`. This is the same as "
"the number of ways to choose a subset of `k` elements from a set of `n` "
"elements. Use the formula `n! / k! (n - k)!`, where `!` is the factorial "
"function written earlier. _Hint_: Use pattern matching to handle corner "
"cases. If it takes a long time to complete or crashes with an error about "
"the call stack, try adding more corner cases."
msgstr ""
"（普通）\\\\( (1 + x) ^ n \\\\)を多項式展開した式にある\\\\( x ^ k \\\\)の項"
"の係数を求める関数`binomial`を書いてください。\n"
"これは`n`要素の集合から`k`要素の部分集合を選ぶ方法の数と同じです。\n"
"数式\\\\( n! / k! (n - k)! \\\\)を使ってください。\n"
"ここで \\\\( ! \\\\) は前に書いた階乗関数です。\n"
"*手掛かり*：パターン照合を使って特殊な場合を取り扱ってください。\n"
"長い時間が掛かったりコールスタックのエラーでクラッシュしたりしたら、もっと使"
"用例を追加してみてください。"

#. type: Bullet: '1. '
#: text/chapter5.md:104
msgid ""
"(Medium) Write a function `pascal` which uses [_Pascal`s Rule_](https://en."
"wikipedia.org/wiki/Pascal%27s_rule) for computing the same binomial "
"coefficients as the previous exercise."
msgstr ""
"（普通）[_パスカルの法則_](https://en.wikipedia.org/wiki/Pascal%27s_rule)を"
"使って前の演習と同じ2項係数を計算する関数`pascal`を書いてください。"

#. type: Title ##
#: text/chapter5.md:105
#, no-wrap
msgid "Array Patterns"
msgstr "配列パターン"

#. type: Plain text
#: text/chapter5.md:108
msgid ""
"_Array literal patterns_ provide a way to match arrays of a fixed length. "
"For example, suppose we want to write a function `isEmpty` which identifies "
"empty arrays. We could do this by using an empty array pattern (`[]`) in the "
"first alternative:"
msgstr ""
"*配列直値パターン*は、固定長の配列に対して照合する方法を提供します。\n"
"例えば空の配列であるか判定する関数`isEmpty`を書きたいとします。\n"
"最初の選択肢に空の配列パターン (`[]`) を用いるとこれを実現できます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:109
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:isEmpty}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:isEmpty}}\n"

#. type: Plain text
#: text/chapter5.md:114
msgid ""
"Here is another function which matches arrays of length five, binding each "
"of its five elements in a different way:"
msgstr ""
"次の関数では、長さ5の配列と適合し、配列の5つの要素をそれぞれ違った方法で束縛"
"しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:115
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:takeFive}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:takeFive}}\n"

#. type: Plain text
#: text/chapter5.md:120
msgid ""
"The first pattern only matches arrays with five elements, whose first and "
"second elements are 0 and 1 respectively. In that case, the function returns "
"the product of the third and fourth elements. In every other case, the "
"function returns zero. For example, in PSCi:"
msgstr ""
"最初のパターンは、第1要素と第2要素がそれぞれ0と1であるような、5要素の配列にの"
"み適合します。\n"
"その場合、関数は第3要素と第4要素の積を返します。\n"
"それ以外の場合は、関数は0を返します。\n"
"例えばPSCiで試してみると次のようになります。"

#. type: Fenced code block (text)
#: text/chapter5.md:121
#, no-wrap
msgid ""
"> :paste\n"
"… takeFive [0, 1, a, b, _] = a * b\n"
"… takeFive _ = 0\n"
"… ^D\n"
"\n"
"> takeFive [0, 1, 2, 3, 4]\n"
"6\n"
"\n"
"> takeFive [1, 2, 3, 4, 5]\n"
"0\n"
"\n"
"> takeFive []\n"
"0\n"
msgstr ""
"> :paste\n"
"… takeFive [0, 1, a, b, _] = a * b\n"
"… takeFive _ = 0\n"
"… ^D\n"
"\n"
"> takeFive [0, 1, 2, 3, 4]\n"
"6\n"
"\n"
"> takeFive [1, 2, 3, 4, 5]\n"
"0\n"
"\n"
"> takeFive []\n"
"0\n"

#. type: Plain text
#: text/chapter5.md:138
msgid ""
"Array literal patterns allow us to match arrays of a fixed length, but "
"PureScript does _not_ provide any means of matching arrays of an unspecified "
"length, since destructuring immutable arrays in these sorts of ways can lead "
"to poor performance. If you need a data structure which supports this sort "
"of matching, the recommended approach is to use `Data.List`. Other data "
"structures exist which provide improved asymptotic performance for different "
"operations."
msgstr ""
"配列の直値パターンでは、固定長の配列と一致させることはできますが、PureScript"
"は不特定の長さの配列を照合させる手段を提供していません。\n"
"そのような方法で不変な配列を分解すると、実行速度が低下する可能性があるためで"
"す。\n"
"このように照合できるデータ構造が必要な場合は、`Data.List`を使うことをお勧めし"
"ます。\n"
"その他の操作について、より優れた漸近性能を提供するデータ構造も存在します。"

#. type: Title ##
#: text/chapter5.md:139
#, no-wrap
msgid "Record Patterns and Row Polymorphism"
msgstr "レコードパターンと行多相"

#. type: Plain text
#: text/chapter5.md:142
msgid "_Record patterns_ are used to match - you guessed it - records."
msgstr "*レコードパターン*は（ご想像の通り）レコードに照合します。"

#. type: Plain text
#: text/chapter5.md:144
msgid ""
"Record patterns look just like record literals, but instead of values on the "
"right of the colon, we specify a binder for each field."
msgstr ""
"レコードパターンはレコード直値にほぼ見た目が似ていますが、コロンの右に値を置"
"くのではなく、それぞれのフィールドで束縛子を指定します。"

#. type: Plain text
#: text/chapter5.md:146
msgid ""
"For example: this pattern matches any record which contains fields called "
"`first` and `last`, and binds their values to the names `x` and `y` "
"respectively:"
msgstr ""
"例えば次のパターンは`first`と`last`という名前のフィールドが含まれた任意のレ"
"コードに照合し、これらのフィールドの値はそれぞれ `x`と `y`という名前に束縛さ"
"れます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:147
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPerson}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPerson}}\n"

#. type: Plain text
#: text/chapter5.md:152
msgid ""
"Record patterns provide a good example of an interesting feature of the "
"PureScript type system: _row polymorphism_. Suppose we had defined "
"`showPerson` without a type signature above. What would its inferred type "
"have been? Interestingly, it is not the same as the type we gave:"
msgstr ""
"レコードパターンはPureScriptの型システムの興味深い機能である*行多相*の良い例"
"となっています。\n"
"もし上の`showPerson`を型シグネチャなしで定義していたとすると、この型はどのよ"
"うに推論されるのでしょうか。\n"
"面白いことに、推論される型は上で与えた型とは同じではありません。"

#. type: Fenced code block (text)
#: text/chapter5.md:153
#, no-wrap
msgid ""
"> showPerson { first: x, last: y } = y <> \", \" <> x\n"
"\n"
"> :type showPerson\n"
"forall r. { first :: String, last :: String | r } -> String\n"
msgstr ""
"> showPerson { first: x, last: y } = y <> \", \" <> x\n"
"\n"
"> :type showPerson\n"
"forall r. { first :: String, last :: String | r } -> String\n"

#. type: Plain text
#: text/chapter5.md:161
msgid ""
"What is the type variable `r` here? Well, if we try `showPerson` in PSCi, we "
"see something interesting:"
msgstr ""
"この型変数 `r`は何でしょうか。\n"
"PSCiで`showPerson`を使ってみると、面白いことがわかります。"

#. type: Fenced code block (text)
#: text/chapter5.md:162
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\", last: \"Freeman\" }\n"
"\"Freeman, Phil\"\n"
"\n"
"> showPerson { first: \"Phil\", last: \"Freeman\", location: \"Los Angeles\" }\n"
"\"Freeman, Phil\"\n"
msgstr ""
"> showPerson { first: \"Phil\", last: \"Freeman\" }\n"
"\"Freeman, Phil\"\n"
"\n"
"> showPerson { first: \"Phil\", last: \"Freeman\", location: \"Los Angeles\" }\n"
"\"Freeman, Phil\"\n"

#. type: Plain text
#: text/chapter5.md:171
msgid ""
"We are able to append additional fields to the record, and the `showPerson` "
"function will still work. As long as the record contains the `first` and "
"`last` fields of type `String`, the function application is well-typed. "
"However, it is _not_ valid to call `showPerson` with too _few_ fields:"
msgstr ""
"レコードにそれ以外のフィールドが追加されていても、`showPerson`関数はそのまま"
"動作するのです。レコードに少なくとも型が`String`であるようなフィールド "
"`first`と `last`が含まれていれば、関数適用は正しく型付けされます。しかし、"
"フィールドが _不足_ していると、 `showPerson`の呼び出しは _不正_ となります。"

#. type: Fenced code block (text)
#: text/chapter5.md:172
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\" }\n"
"\n"
"Type of expression lacks required label \"last\"\n"
msgstr ""
"> showPerson { first: \"Phil\" }\n"
"\n"
"Type of expression lacks required label \"last\"\n"

#. type: Plain text
#: text/chapter5.md:179
msgid ""
"We can read the new type signature of `showPerson` as \"takes any record "
"with `first` and `last` fields which are `Strings` _and any other fields_, "
"and returns a `String`\". This function is polymorphic in the _row_ `r` of "
"record fields, hence the name _row polymorphism_.  Note that this behavior "
"is different than that of the original `showPerson`. Without the row "
"variable `r`, `showPerson` only accepts records with _exactly_ a `first` and "
"`last` field and no others."
msgstr ""
"`showPerson`の新しい型シグネチャを読むと、「`String`な`first`と`last`フィール"
"ド _と他のフィールドを何でも_ 持つあらゆるレコードを取り、`String`を返す」と"
"なります。なお、この挙動は元の`showPerson`のものとは異なります。行変数`r`がな"
"ければ`showPerson`は _厳密に_ `first`と`last`フィールドしかないレコードのみを"
"受け付けます。"

#. type: Plain text
#: text/chapter5.md:181
msgid "Note that we could have also written"
msgstr "なお、次のように書くこともできます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:182
#, no-wrap
msgid "> showPerson p = p.last <> \", \" <> p.first\n"
msgstr "> showPerson p = p.last <> \", \" <> p.first\n"

#. type: Plain text
#: text/chapter5.md:187
msgid "and PSCi would have inferred the same type."
msgstr "この場合も、 PSCiは先ほどと同じ型を推論するでしょう。"

#. type: Title ##
#: text/chapter5.md:188
#, no-wrap
msgid "Record Puns"
msgstr "レコード同名利用"

#. type: Plain text
#: text/chapter5.md:191
msgid ""
"Recall that the `showPerson` function matches a record inside its argument, "
"binding the `first` and `last` fields to values named `x` and `y`. We could "
"alternatively just reuse the field names themselves, and simplify this sort "
"of pattern match as follows:"
msgstr ""
"`showPerson`関数は引数内のレコードと照合し、`first`と`last`フィールドを`x`と "
"`y`という名前の値に束縛していたのでした。別の方法として、フィールド名自体を再"
"利用するだけで、このようなパターン照合を次のように単純化できます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:192
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPersonV2}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPersonV2}}\n"

#. type: Plain text
#: text/chapter5.md:197
msgid ""
"Here, we only specify the names of the fields, and we do not need to specify "
"the names of the values we want to introduce. This is called a _record pun_."
msgstr ""
"ここでは、プロパティの名前のみを指定し、名前に導入したい値を指定する必要はあ"
"りません。これは _レコード同名利用_ (record pun) と呼ばれます。"

#. type: Plain text
#: text/chapter5.md:199
msgid ""
"It is also possible to use record puns to _construct_ records. For example, "
"if we have values named `first` and `last` in scope, we can construct a "
"person record using `{ first, last }`:"
msgstr ""
"レコード同名利用はレコードの*構築*にも使用できます。\n"
"例えば、スコープに `first`と `last`という名前の値があれば、`{ first, last }`"
"を使って人物レコードを作ることができます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:unknownPerson}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:unknownPerson}}\n"

#. type: Plain text
#: text/chapter5.md:205
msgid "This may improve readability of code in some circumstances."
msgstr "こうすると、状況によってはコードの可読性向上に役立ちます。"

#. type: Title ##
#: text/chapter5.md:206
#, no-wrap
msgid "Nested Patterns"
msgstr "入れ子になったパターン"

#. type: Plain text
#: text/chapter5.md:209
msgid ""
"Array patterns and record patterns both combine smaller patterns to build "
"larger patterns. For the most part, the examples above have only used simple "
"patterns inside array patterns and record patterns, but it is important to "
"note that patterns can be arbitrarily _nested_, which allows functions to be "
"defined using conditions on potentially complex data types."
msgstr ""
"配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大"
"きなパターンを構成しています。これまでの例ではほとんどの場合で配列パターンと"
"レコードパターンの内部に単純なパターンを使用していましたが、パターンを自由に*"
"入れ子*にできることも知っておくのが大切です。入れ子になったパターンを使うと、"
"潜在的に複雑なデータ型に対して条件分岐を用いて関数を定義できるようになりま"
"す。"

#. type: Plain text
#: text/chapter5.md:211
msgid "For example, this code combines two record patterns:"
msgstr "例えばこのコードは2つのレコードパターンを組み合わせています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:212
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:livesInLA}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:livesInLA}}\n"

#. type: Title ##
#: text/chapter5.md:216
#, no-wrap
msgid "Named Patterns"
msgstr "名前付きパターン"

#. type: Plain text
#: text/chapter5.md:219
msgid ""
"Patterns can be _named_ to bring additional names into scope when using "
"nested patterns. Any pattern can be named by using the `@` symbol."
msgstr ""
"入れ子のパターンを使う場合、パターンには*名前を付け*てスコープに名前を追加で"
"持ち込むことができます。\n"
"任意のパターンに名前を付けるには、 `@`記号を使います。"

#. type: Plain text
#: text/chapter5.md:221
msgid ""
"For example, this function sorts two-element arrays, naming the two "
"elements, but also naming the array itself:"
msgstr ""
"例えば次の関数は2要素配列を整列するもので、2つの要素に名前を付けていますが、"
"配列自身にも名前を付けています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:222
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:sortPair}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:sortPair}}\n"

#. type: Plain text
#: text/chapter5.md:227
msgid ""
"This way, we save ourselves from allocating a new array if the pair is "
"already sorted. Note that if the input array does not contain _exactly_ two "
"elements, then this function simply returns it unchanged, even if it's "
"unsorted."
msgstr ""
"このようにすれば対が既に整列されているときに新しい配列を割り当てなくて済みま"
"す。なおもし入力の配列が _厳密に_ 2つの要素を含んでいなければ、たとえ整列され"
"ていなかったとしても、この関数は単に元のまま変えずに返しています。"

#. type: Bullet: '1. '
#: text/chapter5.md:233
msgid ""
"(Easy) Write a function `sameCity` which uses record patterns to test "
"whether two `Person` records belong to the same city."
msgstr ""
"（簡単）レコードパターンを使って、2つの `Person`レコードが同じ都市にいるか調"
"べる関数 `sameCity`を定義してみましょう。"

#. type: Bullet: '1. '
#: text/chapter5.md:233
msgid ""
"(Medium) What is the most general type of the `sameCity` function, taking "
"into account row polymorphism? What about the `livesInLA` function defined "
"above? _Note_: There is no test for this exercise."
msgstr ""
"（普通）行多相を考慮すると、 `sameCity`関数の最も一般的な型は何でしょうか。\n"
"先ほど定義した`livesInLA`関数についてはどうでしょうか。\n"
"*補足*：この演習にテストはありません。"

#. type: Bullet: '1. '
#: text/chapter5.md:233
msgid ""
"(Medium) Write a function `fromSingleton` which uses an array literal "
"pattern to extract the sole member of a singleton array. If the array is not "
"a singleton, your function should return a provided default value. Your "
"function should have type `forall a. a -> Array a -> a`"
msgstr ""
"（普通）配列直値パターンを使って、1要素の配列の唯一のメンバーを抽出する関数"
"`fromSingleton`を書いてみましょう。1要素だけを持つ配列でない場合、関数は指定"
"された既定値を返します。この関数は `forall a. a -> Array a -> a`という型を"
"持っています。"

#. type: Title ##
#: text/chapter5.md:234
#, no-wrap
msgid "Case Expressions"
msgstr "Case式"

#. type: Plain text
#: text/chapter5.md:237
msgid ""
"Patterns do not only appear in top-level function declarations. It is "
"possible to use patterns to match on an intermediate value in a computation, "
"using a `case` expression. Case expressions provide a similar type of "
"utility to anonymous functions: it is not always desirable to give a name to "
"a function, and a `case` expression allows us to avoid naming a function "
"just because we want to use a pattern."
msgstr ""
"パターンは最上位にある関数宣言だけに現れるわけではありません。`case`式を使っ"
"て計算の途中の値に対してパターン照合を使うことができます。case式には無名関数"
"に似たような便利さがあります。関数に名前を与えることがいつも望ましいわけでは"
"ないように、パターン照合を使いたいためだけに関数に名前をつけるようなことを避"
"けられるようになります。"

#. type: Plain text
#: text/chapter5.md:239
msgid ""
"Here is an example. This function computes \"longest zero suffix\" of an "
"array (the longest suffix which sums to zero):"
msgstr ""
"例を示しましょう。\n"
"次の関数は、配列の「最長ゼロ末尾」（和がゼロであるような、最も長い配列の末"
"尾）を計算します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:240
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzsImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzs}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzsImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzs}}\n"

#. type: Fenced code block (text)
#: text/chapter5.md:248
#, no-wrap
msgid ""
"> lzs [1, 2, 3, 4]\n"
"[]\n"
"\n"
"> lzs [1, -1, -2, 3]\n"
"[-1, -2, 3]\n"
msgstr ""
"> lzs [1, 2, 3, 4]\n"
"[]\n"
"\n"
"> lzs [1, -1, -2, 3]\n"
"[-1, -2, 3]\n"

#. type: Plain text
#: text/chapter5.md:257
msgid ""
"This function works by case analysis. If the array is empty, our only option "
"is to return an empty array. If the array is non-empty, we first use a "
"`case` expression to split into two cases. If the sum of the array is zero, "
"we return the whole array. If not, we recurse on the tail of the array."
msgstr ""
"この関数は場合ごとの分析によって動作します。もし配列が空なら、唯一の選択肢は"
"空の配列を返すことです。配列が空でない場合は、更に2つの場合に分けるためにま"
"ず `case`式を使用します。配列の合計がゼロであれば、配列全体を返します。そうで"
"なければ、配列の残りに対して再帰します。"

#. type: Title ##
#: text/chapter5.md:258
#, no-wrap
msgid "Pattern Match Failures and Partial Functions"
msgstr "パターン照合の失敗と部分関数"

#. type: Plain text
#: text/chapter5.md:261
msgid ""
"If patterns in a case expression are tried in order, then what happens in "
"the case when none of the patterns in a case alternatives match their "
"inputs? In this case, the case expression will fail at runtime with a "
"_pattern match failure_."
msgstr ""
"case式のパターンを順番に照合していって、もし選択肢の何れの場合も入力が適合し"
"なかった時は何が起こるのでしょうか。\n"
"この場合、*パターン照合失敗*によって、case式は実行時に失敗します。"

#. type: Plain text
#: text/chapter5.md:263
msgid "We can see this behavior with a simple example:"
msgstr "簡単な例でこの動作を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:264
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:unsafePartialImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:partialFunction}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:unsafePartialImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:partialFunction}}\n"

#. type: Plain text
#: text/chapter5.md:271
msgid ""
"This function contains only a single case, which only matches a single "
"input, `true`. If we compile this file, and test in PSCi with any other "
"argument, we will see an error at runtime:"
msgstr ""
"この関数は単一の場合しか含んでおらず、単一の入力である`true`にのみ照合しま"
"す。このファイルをコンパイルしてPSCiでそれ以外の値を与えてテストすると、実行"
"時エラーが発生します。"

#. type: Fenced code block (text)
#: text/chapter5.md:272
#, no-wrap
msgid ""
"> partialFunction false\n"
"\n"
"Failed pattern match\n"
msgstr ""
"> partialFunction false\n"
"\n"
"Failed pattern match\n"

#. type: Plain text
#: text/chapter5.md:279
msgid ""
"Functions which return a value for any combination of inputs are called "
"_total_ functions, and functions which do not are called _partial_."
msgstr ""
"どんな入力の組み合わせに対しても値を返すような関数は _全関数_ (total "
"function) と呼ばれ、そうでない関数は _部分的_ (partial) であると呼ばれます。"

#. type: Plain text
#: text/chapter5.md:281
msgid ""
"It is generally considered better to define total functions where possible. "
"If it is known that a function does not return a result for some valid set "
"of inputs, it is usually better to return a value capable of indicating "
"failure, such as type `Maybe a` for some `a`, using `Nothing` when it cannot "
"return a valid result. This way, the presence or absence of a value can be "
"indicated in a type-safe way."
msgstr ""
"一般的には、可能な限り全関数として定義したほうが良いと考えられています。\n"
"もし関数が何らかの妥当な入力の集合について結果を返さないことがわかっているな"
"ら、大抵は失敗であることを示すことができる値を返すほうがよいでしょう。\n"
"例えば何らかの`a`についての型`Maybe a`で、妥当な結果を返せないときは`Nothing`"
"を使います。\n"
"この方法なら、型安全な方法で値の有無を示すことができます。"

#. type: Plain text
#: text/chapter5.md:283
msgid ""
"The PureScript compiler will generate an error if it can detect that your "
"function is not total due to an incomplete pattern match. The "
"`unsafePartial` function can be used to silence these errors (if you are "
"sure that your partial function is safe!) If we removed the call to the "
"`unsafePartial` function above, then the compiler would generate the "
"following error:"
msgstr ""
"PureScriptコンパイラは、パターンマッチが不完全で関数が全関数ではないことを検"
"出するとエラーを生成します。\n"
"部分関数が安全である場合、`unsafePartial`関数を使ってこれらのエラーを抑制でき"
"ます（その部分関数が安全だと言い切れるなら）。\n"
"もし上記の `unsafePartial`関数の呼び出しを取り除くと、コンパイラは次のエラー"
"を生成します。"

#. type: Fenced code block (text)
#: text/chapter5.md:284
#, no-wrap
msgid ""
"A case expression could not be determined to cover all inputs.\n"
"The following additional cases are required to cover all inputs:\n"
"\n"
"  false\n"
msgstr ""
"A case expression could not be determined to cover all inputs.\n"
"The following additional cases are required to cover all inputs:\n"
"\n"
"  false\n"

#. type: Plain text
#: text/chapter5.md:292
msgid ""
"This tells us that the value `false` is not matched by any pattern. In "
"general, these warnings might include multiple unmatched cases."
msgstr ""
"これは値`false`が、定義されたどのパターンとも一致しないことを示しています。\n"
"一般にこれらの警告には、複数の不一致な場合が含まれることがあります。"

#. type: Plain text
#: text/chapter5.md:294
msgid "If we also omit the type signature above:"
msgstr "上記の型シグネチャも省略した場合は、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:295
#, no-wrap
msgid "partialFunction true = true\n"
msgstr "partialFunction true = true\n"

#. type: Plain text
#: text/chapter5.md:300
msgid "then PSCi infers a curious type:"
msgstr "このとき、PSCiは興味深い型を推論します。"

#. type: Fenced code block (text)
#: text/chapter5.md:301
#, no-wrap
msgid ""
"> :type partialFunction\n"
"\n"
"Partial => Boolean -> Boolean\n"
msgstr ""
"> :type partialFunction\n"
"\n"
"Partial => Boolean -> Boolean\n"

#. type: Plain text
#: text/chapter5.md:308
#, no-wrap
msgid "We will see more types which involve the `=>` symbol later on in the book (they are related to _type classes_), but for now, it suffices to observe that PureScript keeps track of partial functions using the type system, and that we must explicitly tell the type checker when they are safe.\n"
msgstr "本書ではのちに`=>`記号を含むいろいろな型を見ることになります（これらは*型クラス*に関連しています）。しかし、今のところは、PureScriptは型システムを使って部分関数を把握していることと、安全な場合に型検証器に明示する必要があることを確認すれば充分です。\n"

#. type: Plain text
#: text/chapter5.md:310
msgid ""
"The compiler will also generate a warning in certain cases when it can "
"detect that cases are _redundant_ (that is, a case only matches values which "
"would have been matched by a prior case):"
msgstr ""
"コンパイラは、定義されたパターンが _冗長_ であることを検出した場合（前の方に"
"定義されたパターンのみに一致する場合）でも警告を生成します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:311
#, no-wrap
msgid ""
"redundantCase :: Boolean -> Boolean\n"
"redundantCase true = true\n"
"redundantCase false = false\n"
"redundantCase false = false\n"
msgstr ""
"redundantCase :: Boolean -> Boolean\n"
"redundantCase true = true\n"
"redundantCase false = false\n"
"redundantCase false = false\n"

#. type: Plain text
#: text/chapter5.md:319
msgid "In this case, the last case is correctly identified as redundant:"
msgstr "このとき、最後の場合は冗長であると正しく検出されます。"

#. type: Fenced code block (text)
#: text/chapter5.md:320
#, no-wrap
msgid ""
"A case expression contains unreachable cases:\n"
"\n"
"  false\n"
msgstr ""
"A case expression contains unreachable cases:\n"
"\n"
"  false\n"

#. type: Plain text
#: text/chapter5.md:327
msgid ""
"_Note_: PSCi does not show warnings, so to reproduce this example, you will "
"need to save this function as a file and compile it using `spago build`."
msgstr ""
"*補足*：PSCiは警告を表示しないので、この例を再現するには、この関数をファイル"
"として保存し、 `pulp build`を使ってコンパイルします。"

#. type: Title ##
#: text/chapter5.md:328
#, no-wrap
msgid "Algebraic Data Types"
msgstr "代数的データ型"

#. type: Plain text
#: text/chapter5.md:331
msgid ""
"This section will introduce a feature of the PureScript type system called "
"_Algebraic Data Types_ (or _ADTs_), which are fundamentally related to "
"pattern matching."
msgstr ""
"この節では _代数的データ型_ (algebraic data type, _ADT_) と呼ばれる、"
"PureScriptの型システムの機能を導入します。この機能はパターン照合と地続きの関"
"係があります。"

#. type: Plain text
#: text/chapter5.md:333
msgid ""
"However, we'll first consider a motivating example, which will provide the "
"basis of a solution to this chapter's problem of implementing a simple "
"vector graphics library."
msgstr ""
"しかしまずは切り口となる例について考えていきます。この例では単純なベクターグ"
"ラフィックスライブラリの実装というこの章の課題を解決する基礎を与えます。"

#. type: Plain text
#: text/chapter5.md:335
msgid ""
"Suppose we wanted to define a type to represent some simple shapes: lines, "
"rectangles, circles, text, etc. In an object oriented language, we would "
"probably define an interface or abstract class `Shape`, and one concrete "
"subclass for each type of shape that we wanted to be able to work with."
msgstr ""
"直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとします。\n"
"オブジェクト指向言語では、恐らくインターフェースもしくは抽象クラス `Shape`を定義し、使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。"

#. type: Plain text
#: text/chapter5.md:337
msgid ""
"However, this approach has one major drawback: to work with `Shape`s "
"abstractly, it is necessary to identify all of the operations one might wish "
"to perform, and to define them on the `Shape` interface. It becomes "
"difficult to add new operations without breaking modularity."
msgstr ""
"しかし、この方針は大きな欠点を1つ抱えています。\n"
"`Shape`を抽象的に扱うためには、実行したいと思う可能性のある全ての操作を事前に把握し、`Shape`インターフェースに定義する必要があるのです。\n"
"このため、モジュール性を壊さずに新しい操作を追加することが難しくなります。"

#. type: Plain text
#: text/chapter5.md:339
msgid ""
"Algebraic data types provide a type-safe way to solve this sort of problem, "
"if the set of shapes is known in advance. It is possible to define new "
"operations on `Shape` in a modular way, and still maintain type-safety."
msgstr ""
"もし図形の種類が事前にわかっているなら、代数的データ型はこうした問題を解決す"
"る型安全な方法を提供します。モジュール性のある方法で `Shape`に新たな操作を定"
"義し、型安全性を維持できます。"

#. type: Plain text
#: text/chapter5.md:341
msgid "Here is how `Shape` might be represented as an algebraic data type:"
msgstr "代数的データ型としてどのように`Shape`が表現されるかを次に示します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:342
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Shape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Point}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Shape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Point}}\n"

#. type: Plain text
#: text/chapter5.md:349
msgid ""
"This declaration defines `Shape` as a sum of different constructors, and for "
"each constructor identifies the data that is included. A `Shape` is either a "
"`Circle` which contains a center `Point` and a radius (a number), or a "
"`Rectangle`, or a `Line`, or `Text`. There are no other ways to construct a "
"value of type `Shape`."
msgstr ""
"この宣言では`Shape`をそれぞれの構築子の直和として定義しており、各構築子では含"
"まれるデータを指定します。\n"
"`Shape`は、中央 `Point`と半径（数値）を持つ `Circle`か、`Rectangle`、 "
"`Line`、 `Text`の何れかです。\n"
"他に`Shape`型の値を構築する方法はありません。"

#. type: Plain text
#: text/chapter5.md:351
msgid ""
"An algebraic data type is introduced using the `data` keyword, followed by "
"the name of the new type and any type arguments. The type's constructors (i."
"e. its _data constructors_) are defined after the equals symbol, and are "
"separated by pipe characters (`|`). The data carried by an ADT's "
"constructors doesn't have to be restricted to primitive types: constructors "
"can include records, arrays, or even other ADTs."
msgstr ""
"代数的データ型の定義はキーワード `data`から始まり、それに新しい型の名前と任意"
"個の型引数が続きます。その型の構築子（あるいは _データ構築子_ (data "
"constructor)）は等号の後に定義され、パイプ文字 (`|`) で区切られます。ADTの構"
"築子が持つデータは原始型に限りません。構築子にはレコード、配列、また他のADTさ"
"えも含むことができます。"

#. type: Plain text
#: text/chapter5.md:353
msgid ""
"Let's see another example from PureScript's standard libraries. We saw the "
"`Maybe` type, which is used to define optional values, earlier in the book. "
"Here is its definition from the `maybe` package:"
msgstr ""
"それではPureScriptの標準ライブラリから別の例を見てみましょう。\n"
"オプショナルな値を定義するのに使われる `Maybe`型を本書の冒頭で扱いました。\n"
"`maybe`パッケージでは `Maybe`を次のように定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:354
#, no-wrap
msgid "data Maybe a = Nothing | Just a\n"
msgstr "data Maybe a = Nothing | Just a\n"

#. type: Plain text
#: text/chapter5.md:359
msgid ""
"This example demonstrates the use of a type parameter `a`. Reading the pipe "
"character as the word \"or\", its definition almost reads like English: \"a "
"value of type `Maybe a` is either `Nothing`, or `Just` a value of type `a`\"."
msgstr ""
"この例では型引数 `a`の使用方法を示しています。パイプ文字を「または」と読むこ"
"とにすると、この定義は「`Maybe a`型の値は、無い (`Nothing`) か、ただの "
"(`Just`) 型 `a`の値だ」とほぼ英語のように読むことができます。"

#. type: Plain text
#: text/chapter5.md:361
msgid ""
"Note that we don't use the syntax `forall a.` anywhere in our data "
"definition. `forall` syntax is necessary for functions, but is not used when "
"defining ADTs with `data` or type aliases with `type`."
msgstr ""
"なおデータ定義のどこにも構文`forall a`を使っていません。\n"
"`forall`構文は関数には必須ですが、`data`によるADTや`type`での型別称を定義する"
"ときは使われません。"

#. type: Plain text
#: text/chapter5.md:363
msgid ""
"Data constructors can also be used to define recursive data structures. Here "
"is one more example, defining a data type of singly-linked lists of elements "
"of type `a`:"
msgstr ""
"データ構築子は再帰的なデータ構造を定義するためにも使用できます。更に例を挙げ"
"ると、要素が型 `a`の単方向連結リストのデータ型の定義はこのようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:364
#, no-wrap
msgid "data List a = Nil | Cons a (List a)\n"
msgstr "data List a = Nil | Cons a (List a)\n"

#. type: Plain text
#: text/chapter5.md:369
msgid ""
"This example is taken from the `lists` package. Here, the `Nil` constructor "
"represents an empty list, and `Cons` is used to create non-empty lists from "
"a head element and a tail. Notice how the tail is defined using the data "
"type `List a`, making this a recursive data type."
msgstr ""
"この例は `lists`パッケージから持ってきました。\n"
"ここで `Nil`構築子は空のリストを表しており、`Cons`は先頭となる要素と尾鰭から"
"空でないリストを作成するために使われます。\n"
"`Cons`の2つ目のフィールドでデータ型 `List a`を使用しており、再帰的なデータ型"
"になっていることに注目してください。"

#. type: Title ##
#: text/chapter5.md:370
#, no-wrap
msgid "Using ADTs"
msgstr "ADTの使用"

#. type: Plain text
#: text/chapter5.md:373
msgid ""
"It is simple enough to use the constructors of an algebraic data type to "
"construct a value: simply apply them like functions, providing arguments "
"corresponding to the data included with the appropriate constructor."
msgstr ""
"代数的データ型の構築子を使用して値を構築するのはとても簡単です。\n"
"対応する構築子に含まれるデータに応じた引数を用意し、その構築子を単に関数のよ"
"うに適用するだけです。"

#. type: Plain text
#: text/chapter5.md:375
msgid ""
"For example, the `Line` constructor defined above required two `Point`s, so "
"to construct a `Shape` using the `Line` constructor, we have to provide two "
"arguments of type `Point`:"
msgstr ""
"例えば、上で定義した `Line`構築子は2つの `Point`を必要としていますので、"
"`Line`構築子を使って `Shape`を構築するには、型 `Point`の2つの引数を与えなけれ"
"ばなりません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:376
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:exampleLine}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:exampleLine}}\n"

#. type: Plain text
#: text/chapter5.md:381
msgid ""
"So, constructing values of algebraic data types is simple, but how do we use "
"them? This is where the important connection with pattern matching appears: "
"the only way to consume a value of an algebraic data type is to use a "
"pattern to match its constructor."
msgstr ""
"さて、代数的データ型で値を構築することは簡単ですが、これをどうやって使ったら"
"よいのでしょうか。\n"
"ここで代数的データ型とパターン照合との重要な接点が見えてきます。\n"
"代数的データ型の値を消費する唯一の方法は構築子に照合するパターンを使うことで"
"す。"

#. type: Plain text
#: text/chapter5.md:383
msgid ""
"Let's see an example. Suppose we want to convert a `Shape` into a `String`. "
"We have to use pattern matching to discover which constructor was used to "
"construct the `Shape`. We can do this as follows:"
msgstr ""
"例を見てみましょう。\n"
"`Shape`を `String`に変換したいとします。\n"
"`Shape`を構築するのにどの構築子が使用されたかを調べるには、パターン照合を使用"
"しなければなりません。\n"
"これには次のようにします。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:384
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showShape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showPoint}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showShape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showPoint}}\n"

#. type: Plain text
#: text/chapter5.md:391
msgid ""
"Each constructor can be used as a pattern, and the arguments to the "
"constructor can themselves be bound using patterns of their own. Consider "
"the first case of `showShape`: if the `Shape` matches the `Circle` "
"constructor, then we bring the arguments of `Circle` (center and radius) "
"into scope using two variable patterns, `c` and `r`. The other cases are "
"similar."
msgstr ""
"各構築子はパターンとして使用でき、構築子への引数はそのパターンで束縛できま"
"す。\n"
"`showShape`の最初の場合を考えてみましょう。\n"
"もし `Shape`が `Circle`構築子に適合した場合、2つの変数パターン `c`と `r`を"
"使って`Circle`の引数（中心と半径）がスコープに導入されます。その他の場合も同"
"様です。"

#. type: Bullet: '1. '
#: text/chapter5.md:397
msgid ""
"(Easy) Write a function `circleAtOrigin` which constructs a `Circle` (of "
"type `Shape`) centered at the origin with radius `10.0`."
msgstr ""
"（簡単）`Circle`（型は`Shape`）を構築する関数`circleAtOrigin`を書いてくださ"
"い。\n"
"中心は原点にあり、半径は`10.0`です。"

#. type: Bullet: '1. '
#: text/chapter5.md:397
msgid ""
"(Medium) Write a function `doubleScaleAndCenter` which scales the size of a "
"`Shape` by a factor of `2.0` and centers it at the origin."
msgstr ""
"（普通）`Shape`を原点を中心として`2.0`倍に拡大する関数`doubleScaleAndCenter`"
"を書いてみましょう。"

#. type: Bullet: '1. '
#: text/chapter5.md:397
msgid ""
"(Medium) Write a function `shapeText` which extracts the text from a "
"`Shape`. It should return `Maybe String`, and use the `Nothing` constructor "
"if the input is not constructed using `Text`."
msgstr ""
"（普通）`Shape`からテキストを抽出する関数`shapeText`を書いてください。\n"
"この関数は`Maybe String`を返しますが、もし入力が`Text`を使用して構築されたの"
"でなければ、返り値には`Nothing`構築子を使ってください。"

#. type: Title ##
#: text/chapter5.md:398
#, no-wrap
msgid "Newtypes"
msgstr "Newtype"

#. type: Plain text
#: text/chapter5.md:401
msgid ""
"There is a special case of algebraic data types, called _newtypes_. Newtypes "
"are introduced using the `newtype` keyword instead of the `data` keyword."
msgstr ""
"代数的データ型の特殊な場合として、 _newtype_ と呼ばれるものがあります。"
"newtypeはキーワード `data`の代わりにキーワード `newtype`を使用して導入しま"
"す。"

#. type: Plain text
#: text/chapter5.md:403
msgid ""
"Newtypes must define _exactly one_ constructor, and that constructor must "
"take _exactly one_ argument. That is, a newtype gives a new name to an "
"existing type. In fact, the values of a newtype have the same runtime "
"representation as the underlying type, so there is no runtime performance "
"overhead. They are, however, distinct from the point of view of the type "
"system. This gives an extra layer of type safety."
msgstr ""
"newtype宣言では*過不足なく1つだけの*構築子を定義しなければならず、その構築子"
"は*過不足なく1つだけの*引数を取る必要があります。\n"
"つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。\n"
"実際、newtypeの値は、元の型と同じ実行時表現を持ってるので、実行時性能のオー"
"バーヘッドがありません。\n"
"しかし、これらは型システムの観点から区別されます。\n"
"型安全性に追加の層を与えるのです。"

#. type: Plain text
#: text/chapter5.md:405
msgid ""
"As an example, we might want to define newtypes as type-level aliases for "
"`Number`, to ascribe units like volts, amps, and ohms:"
msgstr ""
"例として、ボルト、アンペア、オームのような単位を表現するために、`Number`の型"
"レベルの別名を定義したくなる場合があるかもしれません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:406
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:electricalUnits}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:electricalUnits}}\n"

#. type: Plain text
#: text/chapter5.md:411
msgid "Then we define functions and values using these types:"
msgstr "それからこれらの型を使う関数と値を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:412
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:calculateCurrent}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:calculateCurrent}}\n"

#. type: Plain text
#: text/chapter5.md:417
msgid ""
"This prevents us from making silly mistakes, such as attempting to calculate "
"the current produced by _two_ lightbulbs _without_ a voltage source."
msgstr ""
"これによりつまらないミスを防ぐことができます。例えば電源 _なし_ に _2つ_ の電"
"球により生み出される電流を計算しようとするなどです。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:418
#, no-wrap
msgid ""
"current :: Amp\n"
"current = calculateCurrent lightbulb lightbulb\n"
"{-\n"
"TypesDoNotUnify:\n"
"  current = calculateCurrent lightbulb lightbulb\n"
"                             ^^^^^^^^^\n"
"  Could not match type\n"
"    Ohm\n"
"  with type\n"
"    Volt\n"
"-}\n"
msgstr ""
"current :: Amp\n"
"current = calculateCurrent lightbulb lightbulb\n"
"{-\n"
"TypesDoNotUnify:\n"
"  current = calculateCurrent lightbulb lightbulb\n"
"                             ^^^^^^^^^\n"
"  Could not match type\n"
"    Ohm\n"
"  with type\n"
"    Volt\n"
"-}\n"

#. type: Plain text
#: text/chapter5.md:433
msgid ""
"If we instead just used `Number` without `newtype`, then the compiler can't "
"help us catch this mistake:"
msgstr ""
"もし`newtype`なしに単なる`Number`を使っていたら、コンパイラはこのミスを捕捉で"
"きません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:434
#, no-wrap
msgid ""
"-- This also compiles, but is not as type safe.\n"
"calculateCurrent :: Number -> Number -> Number\n"
"calculateCurrent v r = v / r\n"
"\n"
"battery :: Number\n"
"battery = 1.5\n"
"\n"
"lightbulb :: Number\n"
"lightbulb = 500.0\n"
"\n"
"current :: Number\n"
"current = calculateCurrent lightbulb lightbulb -- uncaught mistake\n"
msgstr ""
"-- これもコンパイルできますが、型安全ではありません。\n"
"calculateCurrent :: Number -> Number -> Number\n"
"calculateCurrent v r = v / r\n"
"\n"
"battery :: Number\n"
"battery = 1.5\n"
"\n"
"lightbulb :: Number\n"
"lightbulb = 500.0\n"
"\n"
"current :: Number\n"
"current = calculateCurrent lightbulb lightbulb -- 捕捉されないミス\n"

#. type: Plain text
#: text/chapter5.md:450
msgid ""
"Note that while a newtype can only have a single constructor, and the "
"constructor must be of a single value, a newtype _can_ take any number of "
"type variables. For example, the following newtype would be a valid "
"definition (`err` and `a` are the type variables, and the `CouldError` "
"constructor expects a _single_ value of type `Either err a`):"
msgstr ""
"なお、newtypeは単一の構築子しかとれず、構築子は単一の値でなくてはなりません"
"が、newtypeは任意の数の型変数を取ることが*できます*。\n"
"例えば以下のnewtypeは妥当な定義です（`err`と`a`は型変数で、`CouldError`構築子"
"は型`Either err a`の*単一*の値を期待します）。"

#. type: Fenced code block (Haskell)
#: text/chapter5.md:451
#, no-wrap
msgid "newtype CouldError err a = CouldError (Either err a)\n"
msgstr "newtype CouldError err a = CouldError (Either err a)\n"

#. type: Plain text
#: text/chapter5.md:456
msgid ""
"Also note that the constructor of a newtype often has the same name as the "
"newtype itself, but this is not a requirement. For example, unique names are "
"also valid:"
msgstr ""
"また、newtypeの構築子はよくnewtype自身と同じ名前を持つことがあります。ただこ"
"れは必須ではありません。例えば別個の名前であっても妥当です。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:457
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:Coulomb}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:Coulomb}}\n"

#. type: Plain text
#: text/chapter5.md:462
msgid ""
"In this case, `Coulomb` is the _type constructor_ (of zero arguments) and "
"`MakeCoulomb` is the _data constructor_. These constructors live in "
"different namespaces, even when the names are identical, such as with the "
"`Volt` example. This is true for all ADTs. Note that although the type "
"constructor and data constructor can have different names, in practice it is "
"idiomatic for them to share the same name. This is the case with `Amp` and "
"`Volt` types above."
msgstr ""
"この場合`Coulomb`は*型構築子*（引数はゼロ）で`MakeCoulomb`は _データ構築子_ "
"です。これらの構築子は異なる名前空間に属しており、`Volt`の例でそうだったよう"
"に、名前に一意性があります。これは全てのADTについて言えることです。なお、型構"
"築子とデータ構築子は異なる名前を持つことができますが、実際には同じ名前を共有"
"するのが普通です。前述の`Amp`と`Volt`の場合がこれです。"

#. type: Plain text
#: text/chapter5.md:464
msgid ""
"Another application of newtypes is to attach different _behavior_ to an "
"existing type without changing its representation at runtime. We cover that "
"use case in the next chapter when we discuss _type classes_."
msgstr ""
"newtypeの別の応用は、実行時表現を変えることなく、既存の型に異なる _挙動_ を加"
"えることです。その利用例については次章で _型クラス_ をお話しするときに押さえ"
"ます。"

#. type: Bullet: '1. '
#: text/chapter5.md:468
msgid ""
"(Easy) Define `Watt` as a `newtype` of `Number`. Then define a "
"`calculateWattage` function using this new `Watt` type and the above "
"definitions `Amp` and `Volt`:"
msgstr ""
"（簡単）`Watt`を`Number`の`newtype`として定義してください。それからこの新しい"
"`Watt`型と前述の`Amp`と`Volt`の定義を使って`calculateWattage`関数を定義してく"
"ださい。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:469
#, no-wrap
msgid "calculateWattage :: Amp -> Volt -> Watt\n"
msgstr "calculateWattage :: Amp -> Volt -> Watt\n"

#. type: Plain text
#: text/chapter5.md:474
msgid ""
"A wattage in `Watt`s can be calculated as the product of a given current in "
"`Amp`s and a given voltage in `Volt`s."
msgstr ""
"`Watt`中のワット数は与えられた`Amp`中の電流と与えられた`Volt`の電圧の積で計算"
"できます。"

#. type: Title ##
#: text/chapter5.md:475
#, no-wrap
msgid "A Library for Vector Graphics"
msgstr "ベクターグラフィックスライブラリ"

#. type: Plain text
#: text/chapter5.md:478
msgid ""
"Let's use the data types we have defined above to create a simple library "
"for using vector graphics."
msgstr ""
"これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライ"
"ブラリを作成していきましょう。"

#. type: Plain text
#: text/chapter5.md:480
msgid "Define a type synonym for a `Picture` - just an array of `Shape`s:"
msgstr ""
"ただの `Shape`の配列であるような、 `Picture`という型同義語を定義しておきま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:481
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:Picture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:Picture}}\n"

#. type: Plain text
#: text/chapter5.md:486
msgid ""
"For debugging purposes, we'll want to be able to turn a `Picture` into "
"something readable. The `showPicture` function lets us do that:"
msgstr ""
"デバッグしていると `Picture`を `String`として表示できるようにしたくなることも"
"あるでしょう。これはパターン照合を使用して定義された `showPicture`関数ででき"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:487
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:showPicture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:showPicture}}\n"

#. type: Plain text
#: text/chapter5.md:492
msgid ""
"Let's try it out. Compile your module with `spago build` and open PSCi with "
"`spago repl`:"
msgstr ""
"試してみましょう。\n"
"モジュールを `spago build`でコンパイルし、 `spago repl`でPSCiを開きます。"

#. type: Fenced code block (text)
#: text/chapter5.md:493
#, no-wrap
msgid ""
"$ spago build\n"
"$ spago repl\n"
"\n"
"> import Data.Picture\n"
"\n"
"> showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]\n"
"\n"
"[\"Line [start: (0.0, 0.0), end: (1.0, 1.0)]\"]\n"
msgstr ""
"$ spago build\n"
"$ spago repl\n"
"\n"
"> import Data.Picture\n"
"\n"
"> showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]\n"
"\n"
"[\"Line [start: (0.0, 0.0), end: (1.0, 1.0)]\"]\n"

#. type: Title ##
#: text/chapter5.md:504
#, no-wrap
msgid "Computing Bounding Rectangles"
msgstr "外接矩形の算出"

#. type: Plain text
#: text/chapter5.md:507
msgid ""
"The example code for this module contains a function `bounds` which computes "
"the smallest bounding rectangle for a `Picture`."
msgstr ""
"このモジュールのコード例には、 `Picture`の最小外接矩形を計算する関数 `bounds`"
"が含まれています。"

#. type: Plain text
#: text/chapter5.md:509
msgid "The `Bounds` type defines a bounding rectangle."
msgstr "`Bounds`型は外接矩形を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:510
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:Bounds}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:Bounds}}\n"

#. type: Plain text
#: text/chapter5.md:515
msgid ""
"`bounds` uses the `foldl` function from `Data.Foldable` to traverse the "
"array of `Shapes` in a `Picture`, and accumulate the smallest bounding "
"rectangle:"
msgstr ""
"`Picture`内の `Shape`の配列を走査し、最小の外接矩形を累積するため、`bounds`に"
"は `Data.Foldable`の `foldl`関数を使用しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:516
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:bounds}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:bounds}}\n"

#. type: Plain text
#: text/chapter5.md:521
msgid ""
"In the base case, we need to find the smallest bounding rectangle of an "
"empty `Picture`, and the empty bounding rectangle defined by `emptyBounds` "
"suffices."
msgstr ""
"基底の場合では、空の `Picture`の最小外接矩形を求める必要がありますが、"
"`emptyBounds`で定義される空の外接矩形がその条件を満たしています。"

#. type: Plain text
#: text/chapter5.md:523
msgid ""
"The accumulating function `combine` is defined in a `where` block. `combine` "
"takes a bounding rectangle computed from `foldl`'s recursive call, and the "
"next `Shape` in the array, and uses the `union` function to compute the "
"union of the two bounding rectangles. The `shapeBounds` function computes "
"the bounds of a single shape using pattern matching."
msgstr ""
"累積関数 `combine`は `where`ブロックで定義されています。`combine`は `foldl`の"
"再帰呼び出しで計算された外接矩形と、配列内の次の `Shape`を引数にとり、ユーザ"
"定義の演算子 `union`を使って2つの外接矩形の和を計算しています。`shapeBounds`"
"関数は、パターン照合を使用して、単一の図形の外接矩形を計算します。"

#. type: Bullet: '1. '
#: text/chapter5.md:528
msgid ""
"(Medium) Extend the vector graphics library with a new operation `area` "
"which computes the area of a `Shape`. For the purpose of this exercise, the "
"area of a line or a piece of text is assumed to be zero."
msgstr ""
"（普通）ベクターグラフィックライブラリを拡張し、`Shape`の面積を計算する新しい"
"操作 `area`を追加してください。この演習ではテキストの面積は0であるものとして"
"ください。"

#. type: Bullet: '1. '
#: text/chapter5.md:528
msgid ""
"(Difficult) Extend the `Shape` type with a new data constructor `Clipped`, "
"which clips another `Picture` to a rectangle. Extend the `shapeBounds` "
"function to compute the bounds of a clipped picture. Note that this makes "
"`Shape` into a recursive data type."
msgstr ""
"（難しい）`Shape`を拡張し、新しいデータ構築子 `Clipped`を追加してください。\n"
"`Clipped`は他の `Picture`を矩形に切り抜きます。\n"
"切り抜いてきた`Picture`の境界を計算できるよう、`shapeBounds`関数を拡張してく"
"ださい。\n"
"なお、これにより`Shape`は再帰的なデータ型になります。"

#. type: Plain text
#: text/chapter5.md:532
msgid ""
"In this chapter, we covered pattern matching, a basic but powerful technique "
"from functional programming. We saw how to use simple patterns as well as "
"array and record patterns to match parts of deep data structures."
msgstr ""
"この章では、関数型プログラミングから基本的ながら強力なテクニックであるパター"
"ン照合を扱いました。複雑なデータ構造の一部分と照合するために、簡単なパターン"
"の使い方だけではなく、配列パターンやレコードパターンを使った深さのあるデータ"
"構造の一部分との照合方法を見てきました。"

#. type: Plain text
#: text/chapter5.md:534
msgid ""
"This chapter also introduced algebraic data types, which are closely related "
"to pattern matching. We saw how algebraic data types allow concise "
"descriptions of data structures, and provide a modular way to extend data "
"types with new operations."
msgstr ""
"また、この章ではパターン照合に密接に関連する代数的データ型を紹介しました。代"
"数的データ型のおかげでデータ構造を簡潔に記述でき、新たな操作でデータ型を拡張"
"する上でモジュール性のある方法がもたらされることを見てきました。"

#. type: Plain text
#: text/chapter5.md:536
msgid ""
"Finally, we covered _row polymorphism_, a powerful type of abstraction which "
"allows many idiomatic JavaScript functions to be given a type."
msgstr ""
"最後に強力な抽象化である _行多相_ を扱いました。これにより多くの既存の"
"JavaScript関数に型を与えられます。"

#. type: Plain text
#: text/chapter5.md:537
msgid ""
"In the rest of the book, we will use ADTs and pattern matching extensively, "
"so it will pay dividends to become familiar with them now. Try creating your "
"own algebraic data types and writing functions to consume them using pattern "
"matching."
msgstr ""
"本書では今後も代数的データ型とパターン照合をいろんなところで使用するので、今"
"のうちにこれらに習熟しておくと後で実を結ぶことでしょう。これ以外にも独自の代"
"数的データ型を作成し、パターン照合を使用してそれらの型を使う関数を書いてみて"
"ください。"

#. type: Title #
#: text/chapter6.md:1
#, no-wrap
msgid "Type Classes"
msgstr "型クラス"

#. type: Plain text
#: text/chapter6.md:6
msgid ""
"This chapter will introduce a powerful form of abstraction which is enabled "
"by PureScript's type system - type classes."
msgstr ""
"この章では、PureScriptの型システムによって可能になる強力な抽象化の手法であ"
"る、型クラスを導入します。"

#. type: Plain text
#: text/chapter6.md:8
msgid ""
"This motivating example for this chapter will be a library for hashing data "
"structures. We will see how the machinery of type classes allow us to hash "
"complex data structures without having to think directly about the structure "
"of the data itself."
msgstr ""
"この章ではデータ構造をハッシュ化するためのライブラリを題材に説明していきま"
"す。データ自身の構造について直接考えることなく複雑な構造のデータのハッシュ値"
"を求める上で、型クラスの仕組みがどのようにして働くのかを見ていきます。"

#. type: Plain text
#: text/chapter6.md:10
msgid ""
"We will also see a collection of standard type classes from PureScript's "
"Prelude and standard libraries. PureScript code leans heavily on the power "
"of type classes to express ideas concisely, so it will be beneficial to "
"familiarize yourself with these classes."
msgstr ""
"また、PureScriptのPreludeや標準ライブラリに含まれる、標準的な型クラスも見てい"
"きます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大き"
"く依存しているので、これらのクラスに慣れておくと役に立つでしょう。"

#. type: Plain text
#: text/chapter6.md:12
msgid ""
"If you come from an Object Oriented background, please note that the word "
"\"class\" means something _very_ different in this context than what you're "
"used to. A type class serves a purpose more similar to an OO interface."
msgstr ""
"オブジェクト指向の方面から入って来た方は、「クラス」という単語がそれまで馴染"
"みのあるものとこの文脈とでは _かなり_ 異なるものを意味していることに注意して"
"ください。"

#. type: Plain text
#: text/chapter6.md:16
msgid ""
"The source code for this chapter is defined in the file `src/Data/Hashable."
"purs`."
msgstr ""
"この章のソースコードは、ファイル `src/data/Hashable.purs`で定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`maybe`, which defines the `Maybe` data type, which represents optional "
"values."
msgstr "`maybe`: オプショナルな値を表す `Maybe`データ型が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`tuples`, which defines the `Tuple` data type, which represents pairs of "
"values."
msgstr "`tuples`: 値の組を表す `Tuple`データ型が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`either`, which defines the `Either` data type, which represents disjoint "
"unions."
msgstr "`either`: 非交和を表す `Either`データ型が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid "`strings`, which defines functions which operate on strings."
msgstr "`strings`: 文字列を操作する関数が定義されています。"

#. type: Bullet: '- '
#: text/chapter6.md:24
msgid ""
"`functions`, which defines some helper functions for defining PureScript "
"functions."
msgstr ""
"`functions`: PureScriptの関数を定義するための補助関数が定義されています。"

#. type: Plain text
#: text/chapter6.md:26
msgid ""
"The module `Data.Hashable` imports several modules provided by these "
"packages."
msgstr ""
"モジュール `Data.Hashable`では、これらのパッケージによって提供されるモジュー"
"ルの幾つかをインポートしています。"

#. type: Title ##
#: text/chapter6.md:27
#, no-wrap
msgid "Show Me!"
msgstr "見せて！"

#. type: Plain text
#: text/chapter6.md:30
msgid ""
"Our first simple example of a type class is provided by a function we've "
"seen several times already: the `show` function, which takes a value and "
"displays it as a string."
msgstr ""
"型クラスの最初の簡単な例は、既に何回か見たことがある関数で提供されていま"
"す。\n"
"`show`は何らかの値を取り、文字列として表示する関数です。"

#. type: Plain text
#: text/chapter6.md:32
msgid ""
"`show` is defined by a type class in the `Prelude` module called `Show`, "
"which is defined as follows:"
msgstr ""
"`show`は `Prelude`モジュールの `Show`と呼ばれる型クラスで次のように定義されて"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:33
#, no-wrap
msgid ""
"class Show a where\n"
"  show :: a -> String\n"
msgstr ""
"class Show a where\n"
"  show :: a -> String\n"

#. type: Plain text
#: text/chapter6.md:39
msgid ""
"This code declares a new _type class_ called `Show`, which is parameterized "
"by the type variable `a`."
msgstr ""
"このコードでは、型変数 `a`でパラメータ化された、`Show`という新しい _型クラス"
"_ (type class) を宣言しています。"

#. type: Plain text
#: text/chapter6.md:41
msgid ""
"A type class _instance_ contains implementations of the functions defined in "
"a type class, specialized to a particular type."
msgstr ""
"型クラス _インスタンス_ には、型クラスで定義された関数の、その型に特殊化され"
"た実装が含まれています。"

#. type: Plain text
#: text/chapter6.md:43
msgid ""
"For example, here is the definition of the `Show` type class instance for "
"`Boolean` values, taken from the Prelude:"
msgstr ""
"例えば、Preludeにある `Boolean`値に対する `Show`型クラスインスタンスの定義は"
"次の通りです。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:44
#, no-wrap
msgid ""
"instance showBoolean :: Show Boolean where\n"
"  show true = \"true\"\n"
"  show false = \"false\"\n"
msgstr ""
"instance showBoolean :: Show Boolean where\n"
"  show true = \"true\"\n"
"  show false = \"false\"\n"

#. type: Plain text
#: text/chapter6.md:51
msgid ""
"This code declares a type class instance called `showBoolean` - in "
"PureScript, type class instances can be named to aid the readability of the "
"generated JavaScript. We say that the `Boolean` type _belongs to the `Show` "
"type class_."
msgstr ""
"このコードは `showBool​​ean`という名前の型クラスのインスタンスを宣言します。 "
"PureScriptでは、生成されたJavaScriptの可読性を良くするために、型クラスインス"
"タンスに名前をつけます。このとき、 _`Boolean`型は `Show`型クラスに属している"
"_ といいます。"

#. type: Plain text
#: text/chapter6.md:53
msgid ""
"We can try out the `Show` type class in PSCi, by showing a few values with "
"different types:"
msgstr "PSCiで、いろいろな型の値を`Show`型クラスを使って表示してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:54
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> show true\n"
"\"true\"\n"
"\n"
"> show 1.0\n"
"\"1.0\"\n"
"\n"
"> show \"Hello World\"\n"
"\"\\\"Hello World\\\"\"\n"
msgstr ""
"> import Prelude\n"
"\n"
"> show true\n"
"\"true\"\n"
"\n"
"> show 1.0\n"
"\"1.0\"\n"
"\n"
"> show \"Hello World\"\n"
"\"\\\"Hello World\\\"\"\n"

#. type: Plain text
#: text/chapter6.md:68
msgid ""
"These examples demonstrate how to `show` values of various primitive types, "
"but we can also `show` values with more complicated types:"
msgstr ""
"この例ではさまざまなプリミティブ型の値を `show`しましたが、もっと複雑な型を持"
"つ値も`show`できます。"

#. type: Fenced code block (text)
#: text/chapter6.md:69
#, no-wrap
msgid ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"
msgstr ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"

#. type: Plain text
#: text/chapter6.md:82
msgid ""
"The output of `show` should be a string that you can paste back into the "
"repl (or `.purs` file) to recreate the item being shown. Here we'll use "
"`logShow`, which just calls `show` then `log`, to render the string without "
"quotes. Ignore the `unit` print - that will covered in Chapter 8 when we "
"examine `Effect`s, like `log`."
msgstr ""
"`show`の出力は、REPLに（あるいは`.purs`ファイルに）もう一度貼り付ければ、表示"
"されたものを再作成できるような文字列であるべきです。以下では`logShow`を使って"
"いますが、これは単に`show`と`log`を順に呼び出して、引用符なしに文字列を表示す"
"るものです。`unit`の表示は無視してください。第8章で`Effect`を調べるときに押さ"
"えます。`Effect`を持つものには`log`などがあります。"

#. type: Fenced code block (text)
#: text/chapter6.md:83
#, no-wrap
msgid ""
"> import Effect.Console\n"
"\n"
"> logShow (Tuple 1 true)\n"
"(Tuple 1 true)\n"
"unit\n"
"\n"
"> logShow (Just \"testing\")\n"
"(Just \"testing\")\n"
"unit\n"
msgstr ""
"> import Effect.Console\n"
"\n"
"> logShow (Tuple 1 true)\n"
"(Tuple 1 true)\n"
"unit\n"
"\n"
"> logShow (Just \"testing\")\n"
"(Just \"testing\")\n"
"unit\n"

#. type: Plain text
#: text/chapter6.md:96
msgid ""
"If we try to show a value of type `Data.Either`, we get an interesting error "
"message:"
msgstr ""
"型 `Data.Either`の値を表示しようとすると、興味深いエラーメッセージが表示され"
"ます。"

#. type: Fenced code block (text)
#: text/chapter6.md:97
#, no-wrap
msgid ""
"> import Data.Either\n"
"> show (Left 10)\n"
"\n"
"The inferred type\n"
"\n"
"    forall a. Show a => String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"> import Data.Either\n"
"> show (Left 10)\n"
"\n"
"The inferred type\n"
"\n"
"    forall a. Show a => String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:109
msgid ""
"The problem here is not that there is no `Show` instance for the type we "
"intended to `show`, but rather that PSCi was unable to infer the type. This "
"is indicated by the _unknown type_ `a` in the inferred type."
msgstr ""
"ここでの問題は `show`しようとしている型に対する `Show`インスタンスが存在しな"
"いということではなく、PSCiがこの型を推論できなかったということです。このエ"
"ラーメッセージで _未知の型_ `a`と表示されているのがそれです。"

#. type: Plain text
#: text/chapter6.md:111
msgid ""
"We can annotate the expression with a type, using the `::` operator, so that "
"PSCi can choose the correct type class instance:"
msgstr ""
"`::`演算子を使って式に対して型注釈を加えると、PSCiが正しい型クラスインスタン"
"スを選ぶことができるようになります。"

#. type: Fenced code block (text)
#: text/chapter6.md:112
#, no-wrap
msgid ""
"> show (Left 10 :: Either Int String)\n"
"\"(Left 10)\"\n"
msgstr ""
"> show (Left 10 :: Either Int String)\n"
"\"(Left 10)\"\n"

#. type: Plain text
#: text/chapter6.md:118
#, no-wrap
msgid "Some types do not have a `Show` instance defined at all. One example of this is the function type `->`. If we try to `show` a function from `Int` to `Int`, we get an appropriate error message from the type checker:\n"
msgstr ""
"`Show`インスタンスを全く持っていない型もあります。\n"
"関数の型 `->`がその一例です。\n"
"`Int`から `Int`への関数を `show`しようとすると、型検証器によってその旨のエラーメッセージが表示されます。\n"

#. type: Fenced code block (text)
#: text/chapter6.md:119
#, no-wrap
msgid ""
"> import Prelude\n"
"> show $ \\n -> n + 1\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Data.Show.Show (Int -> Int)\n"
msgstr ""
"> import Prelude\n"
"> show $ \\n -> n + 1\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Data.Show.Show (Int -> Int)\n"

#. type: Plain text
#: text/chapter6.md:129
msgid ""
"Type class instances can be defined in one of two places: in the same module "
"that the type class is defined, or in the same module that the type "
"\"belonging to\" the type class is defined. An instance defined in any other "
"spot is called an [\"orphan instance\"](https://github.com/purescript/"
"documentation/blob/master/language/Type-Classes.md#orphan-instances) and is "
"not allowed by the PureScript compiler. Some of the exercises in this "
"chapter will require you to copy the definition of a type into your "
"MySolutions module so that you can define type class instances for that type."
msgstr ""
"型クラスインスタンスは次の2つのうち何れかの形で定義されます。\n"
"型クラスが定義されている同じモジュールで定義するか、型クラスに「属して」いる"
"型と同じモジュールで定義するかです。\n"
"これらとは別の場所で定義されるインスタンスは[「孤立インスタンス」](https://"
"github.com/purescript/documentation/blob/master/language/Type-Classes."
"md#orphan-instances)と呼ばれ、PureScriptコンパイラでは許されていません。\n"
"この章の演習の幾つかでは、その型の型クラスインスタンスを定義できるように、型"
"の定義を自分の`MySolutions`モジュールに複製する必要があります。"

#. type: Bullet: '1. '
#: text/chapter6.md:133
msgid ""
"(Easy) Define a `Show` instance for `Point`. Match the same output as the "
"`showPoint` function from the previous chapter. _Note:_ Point is now a "
"`newtype` (instead of a `type` synonym), which allows us to customize how to "
"`show` it. Otherwise, we'd be stuck with the default `Show` instance for "
"records."
msgstr ""
"（簡単）`Show`インスタンスを`Point`に定義してください。\n"
"前の章の`showPoint`関数と同じ出力に一致するようにしてください。\n"
"*補足*：`Point`はここでは（`type`同義語ではなく）`newtype`です。\n"
"そのため`show`の仕方を変えられます。\n"
"こうでもしないとレコードへの既定の`Show`インスタンスから逃れられません。"

#. type: Plain text
#: text/chapter6.md:137
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Point}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Point}}\n"
"    ```\n"

#. type: Title ##
#: text/chapter6.md:138
#, no-wrap
msgid "Common Type Classes"
msgstr "よく見かける型クラス"

#. type: Plain text
#: text/chapter6.md:141
msgid ""
"In this section, we'll look at some standard type classes defined in the "
"Prelude and standard libraries. These type classes form the basis of many "
"common patterns of abstraction in idiomatic PureScript code, so a basic "
"understanding of their functions is highly recommended."
msgstr ""
"この節では、Preludeや標準ライブラリで定義されている標準的な型クラスを幾つか見"
"ていきましょう。\n"
"これらの型クラスはPureScript特有の抽象化をする上で多くのよくあるパターンの基"
"礎を形成しています。\n"
"そのため、これらの関数の基本についてよく理解しておくことを強くお勧めします。"

#. type: Title ###
#: text/chapter6.md:142
#, no-wrap
msgid "Eq"
msgstr "Eq"

#. type: Plain text
#: text/chapter6.md:145
msgid ""
"The `Eq` type class defines the `eq` function, which tests two values for "
"equality. The `==` operator is actually just an alias for `eq`."
msgstr ""
"`Eq`型クラスは、2つの値が等しいかどうかを調べる`eq`関数を定義しています。\n"
"等値演算子 (`==`) は`eq`の別名にすぎません。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:146
#, no-wrap
msgid ""
"class Eq a where\n"
"  eq :: a -> a -> Boolean\n"
msgstr ""
"class Eq a where\n"
"  eq :: a -> a -> Boolean\n"

#. type: Plain text
#: text/chapter6.md:152
msgid ""
"Note that in either case, the two arguments must have the same type: it does "
"not make sense to compare two values of different types for equality."
msgstr ""
"なお、異なる型の2つの値を比較しても意味がありませんから、等しいにせよ等しくな"
"いにせよ2つの引数は同じ型を持つ必要があります。"

#. type: Plain text
#: text/chapter6.md:154
msgid "Try out the `Eq` type class in PSCi:"
msgstr "PSCiで `Eq`型クラスを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:155
#, no-wrap
msgid ""
"> 1 == 2\n"
"false\n"
"\n"
"> \"Test\" == \"Test\"\n"
"true\n"
msgstr ""
"> 1 == 2\n"
"false\n"
"\n"
"> \"Test\" == \"Test\"\n"
"true\n"

#. type: Title ###
#: text/chapter6.md:163
#, no-wrap
msgid "Ord"
msgstr "Ord"

#. type: Plain text
#: text/chapter6.md:166
#, no-wrap
msgid "The `Ord` type class defines the `compare` function, which can be used to compare two values, for types which support ordering. The comparison operators `<` and `>` along with their non-strict companions `<=` and `>=`, can be defined in terms of `compare`.\n"
msgstr "`Ord`型クラスは順序付け可能な型に対して2つの値を比較する `compare`関数を定義します。比較演算子 `<`、 `>`と、その仲間の厳密な大小比較ではない`<=`、 `>=`も、`compare`を使って定義されます。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:167
#, no-wrap
msgid ""
"data Ordering = LT | EQ | GT\n"
"\n"
"class Eq a <= Ord a where\n"
"  compare :: a -> a -> Ordering\n"
msgstr ""
"data Ordering = LT | EQ | GT\n"
"\n"
"class Eq a <= Ord a where\n"
"  compare :: a -> a -> Ordering\n"

#. type: Plain text
#: text/chapter6.md:175
msgid ""
"The `compare` function compares two values, and returns an `Ordering`, which "
"has three alternatives:"
msgstr ""
"`compare`関数は2つの値を比較して `Ordering`の3つの値のうち何れかを返します。"

#. type: Bullet: '- '
#: text/chapter6.md:179
msgid "`LT` - if the first argument is less than the second."
msgstr "`LT`- 最初の引数が2番目の値より小さいとき"

#. type: Bullet: '- '
#: text/chapter6.md:179
msgid "`EQ` - if the first argument is equal to the second."
msgstr "`EQ`- 最初の引数が2番目の値と等しい（または比較できない）とき"

#. type: Bullet: '- '
#: text/chapter6.md:179
msgid "`GT` - if the first argument is greater than the second."
msgstr "`GT`- 最初の引数が2番目の値より大きいとき"

#. type: Plain text
#: text/chapter6.md:181
msgid "Again, we can try out the `compare` function in PSCi:"
msgstr "ここでも`compare`関数についてPSCiで試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:182
#, no-wrap
msgid ""
"> compare 1 2\n"
"LT\n"
"\n"
"> compare \"A\" \"Z\"\n"
"LT\n"
msgstr ""
"> compare 1 2\n"
"LT\n"
"\n"
"> compare \"A\" \"Z\"\n"
"LT\n"

#. type: Title ###
#: text/chapter6.md:190
#, no-wrap
msgid "Field"
msgstr "Field"

#. type: Plain text
#: text/chapter6.md:193
msgid ""
"The `Field` type class identifies those types which support numeric "
"operators such as addition, subtraction, multiplication and division. It is "
"provided to abstract over those operators, so that they can be reused where "
"appropriate."
msgstr ""
"`Field`型クラスは加算、減算、乗算、除算などの数値演算子が使える型を示します。"
"必要に応じて再利用できるように、これらの演算子を抽象化するわけです。"

#. type: Plain text
#: text/chapter6.md:195
msgid ""
"_Note_: Just like the `Eq` and `Ord` type classes, the `Field` type class "
"has special support in the PureScript compiler, so that simple expressions "
"such as `1 + 2 * 3` get translated into simple JavaScript, as opposed to "
"function calls which dispatch based on a type class implementation."
msgstr ""
"*補足*：型クラス `Eq`や `Ord`のクラスとちょうど同じように、`Field`型のクラス"
"はPureScriptコンパイラで特別に扱われ、`1 + 2 * 3`のような単純な式は単純な"
"JavaScriptへと変換されます。\n"
"型クラスの実装に基いて呼び出される関数呼び出しとは対照的です。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:196
#, no-wrap
msgid "class EuclideanRing a <= Field a\n"
msgstr "class EuclideanRing a <= Field a\n"

#. type: Plain text
#: text/chapter6.md:201
msgid ""
"The `Field` type class is composed from several more general _superclasses_. "
"This allows us to talk abstractly about types which support some but not all "
"of the `Field` operations. For example, a type of natural numbers would be "
"closed under addition and multiplication, but not necessarily under "
"subtraction, so that type might have an instance of the `Semiring` class "
"(which is a superclass of `Num`), but not an instance of `Ring` or `Field`."
msgstr ""
"`Field`型クラスは、幾つかのより抽象的な*上位クラス* (Super Class) が組み合わ"
"さってできています。\n"
"これは、その型は`Field`型クラスの操作の全てを提供しているわけではないが、その"
"一部を提供する、というように抽象的に説明できます。\n"
"例えば、自然数の型は加算及び乗算については閉じていますが、減算については閉じ"
"ていません。\n"
"そのため、この型は`Semiring`クラス（これは`Num`の上位クラスです）のインスタン"
"スですが、`Ring`や`Field`のインスタンスではありません。"

#. type: Plain text
#: text/chapter6.md:203
msgid ""
"Superclasses will be explained later in this chapter, but the full [numeric "
"type class hierarchy](https://a-guide-to-the-purescript-numeric-hierarchy."
"readthedocs.io/en/latest/introduction.html) ([cheatsheet](https://harry."
"garrood.me/numeric-hierarchy-overview/)) is beyond the scope of this "
"chapter. The interested reader is encouraged to read the documentation for "
"the superclasses of `Field` in `prelude`."
msgstr ""
"上位クラスについては、この章の後半で詳しく説明します。\n"
"しかし、全ての[数値型クラスの階層](https://a-guide-to-the-purescript-numeric-"
"hierarchy.readthedocs.io/en/latest/introduction.html)（[チートシート]"
"(https://harry.garrood.me/numeric-hierarchy-overview/)）について述べるのはこ"
"の章の目的から外れています。\n"
"この内容に興味のある読者は`prelude`内の `Field`に関するドキュメントを参照して"
"ください。"

#. type: Title ###
#: text/chapter6.md:204
#, no-wrap
msgid "Semigroups and Monoids"
msgstr "半群とモノイド"

#. type: Plain text
#: text/chapter6.md:207
msgid ""
"The `Semigroup` type class identifies those types which support an `append` "
"operation to combine two values:"
msgstr ""
"`Semigroup`（半群）型クラスは、2つの値を連結する演算子 `append`を提供する型を"
"示します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:208
#, no-wrap
msgid ""
"class Semigroup a where\n"
"  append :: a -> a -> a\n"
msgstr ""
"class Semigroup a where\n"
"  append :: a -> a -> a\n"

#. type: Plain text
#: text/chapter6.md:214
msgid ""
"Strings form a semigroup under regular string concatenation, and so do "
"arrays. Several other standard instances are provided by the `prelude` "
"package."
msgstr ""
"文字列は普通の文字列連結について半群をなし、同様に配列も半群をなします。その"
"他の標準的なインスタンスの幾つかは、 `prelude`パッケージで提供されています。"

#. type: Plain text
#: text/chapter6.md:216
#, no-wrap
msgid "The `<>` concatenation operator, which we have already seen, is provided as an alias for `append`.\n"
msgstr "以前に見た `<>`連結演算子は、 `append`の別名として提供されています。\n"

#. type: Plain text
#: text/chapter6.md:218
msgid ""
"The `Monoid` type class (provided by the `prelude` package) extends the "
"`Semigroup` type class with the concept of an empty value, called `mempty`:"
msgstr ""
"（`prelude`パッケージで提供されている）`Monoid`型クラスには`mempty`という名前"
"の空の値の概念があり、`Semigroup`型クラスを拡張します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:219
#, no-wrap
msgid ""
"class Semigroup m <= Monoid m where\n"
"  mempty :: m\n"
msgstr ""
"class Semigroup m <= Monoid m where\n"
"  mempty :: m\n"

#. type: Plain text
#: text/chapter6.md:225
msgid "Again, strings and arrays are simple examples of monoids."
msgstr "ここでも文字列や配列はモノイドの簡単な例になっています。"

#. type: Plain text
#: text/chapter6.md:227
msgid ""
"A `Monoid` type class instance for a type describes how to _accumulate_ a "
"result with that type, by starting with an \"empty\" value, and combining "
"new results. For example, we can write a function which concatenates an "
"array of values in some monoid by using a fold. In PSCi:"
msgstr ""
"`Monoid`型クラスインスタンスでは、「空」の値から始めて新たな値を合成してい"
"き、その型で*累積*した結果を返すにはどうするかを記述する型クラスです。\n"
"例えば、畳み込みを使って幾つかのモノイドの値の配列を連結する関数を書くことが"
"できます。\n"
"PSCiで試すと次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:228
#, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.Monoid\n"
"> import Data.Foldable\n"
"\n"
"> foldl append mempty [\"Hello\", \" \", \"World\"]\n"
"\"Hello World\"\n"
"\n"
"> foldl append mempty [[1, 2, 3], [4, 5], [6]]\n"
"[1,2,3,4,5,6]\n"
msgstr ""
"> import Prelude\n"
"> import Data.Monoid\n"
"> import Data.Foldable\n"
"\n"
"> foldl append mempty [\"Hello\", \" \", \"World\"]\n"
"\"Hello World\"\n"
"\n"
"> foldl append mempty [[1, 2, 3], [4, 5], [6]]\n"
"[1,2,3,4,5,6]\n"

#. type: Plain text
#: text/chapter6.md:241
msgid ""
"The `prelude` package provides many examples of monoids and semigroups, "
"which we will use in the rest of the book."
msgstr ""
"`prelude`パッケージにはモノイドと半群の多くの例を提供しており、以降もこれらを"
"本書で扱っていきます。"

#. type: Title ###
#: text/chapter6.md:242
#, no-wrap
msgid "Foldable"
msgstr "Foldable"

#. type: Plain text
#: text/chapter6.md:245
msgid ""
"If the `Monoid` type class identifies those types which act as the result of "
"a fold, then the `Foldable` type class identifies those type constructors "
"which can be used as the source of a fold."
msgstr ""
"`Monoid`型クラスが畳み込みの結果になるような型を示す一方、`Foldable`型クラス"
"は畳み込みの元のデータとして使えるような型構築子を示しています。"

#. type: Plain text
#: text/chapter6.md:247
msgid ""
"The `Foldable` type class is provided in the `foldable-traversable` package, "
"which also contains instances for some standard containers such as arrays "
"and `Maybe`."
msgstr ""
"また、 `Foldable`型クラスは配列や `Maybe`などの幾つかの標準的なコンテナのイン"
"スタンスを含む`foldable-traversable`パッケージで提供されています。"

#. type: Plain text
#: text/chapter6.md:249
msgid ""
"The type signatures for the functions belonging to the `Foldable` class are "
"a little more complicated than the ones we've seen so far:"
msgstr ""
"`Foldable`クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し"
"複雑です。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:250
#, no-wrap
msgid ""
"class Foldable f where\n"
"  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n"
"  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n"
"  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n"
msgstr ""
"class Foldable f where\n"
"  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n"
"  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n"
"  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n"

#. type: Plain text
#: text/chapter6.md:258
msgid ""
"It is instructive to specialize to the case where `f` is the array type "
"constructor. In this case, we can replace `f a` with `Array a` for any a, "
"and we notice that the types of `foldl` and `foldr` become the types that we "
"saw when we first encountered folds over arrays."
msgstr ""
"この定義は `f`を配列の型構築子として特殊化して考えてみるとわかりやすくなりま"
"す。\n"
"この場合、全ての `a`について `f a`を `Array a`に置き換える事ができますが、"
"`foldl`と `foldr`の型が、最初に見た配列に対する畳み込みの型になるとわかりま"
"す。"

#. type: Plain text
#: text/chapter6.md:260
#, no-wrap
msgid "What about `foldMap`? Well, that becomes `forall a m. Monoid m => (a -> m) -> Array a -> m`. This type signature says that we can choose any type `m` for our result type, as long as that type is an instance of the `Monoid` type class. If we can provide a function which turns our array elements into values in that monoid, then we can accumulate over our array using the structure of the monoid, and return a single value.\n"
msgstr ""
"`foldMap`についてはどうでしょうか。\n"
"これは `forall a m. Monoid m => (a -> m) -> Array a -> m`になります。\n"
"この型シグネチャは、型 `m`が `Monoid`型クラスのインスタンスであればどんな型でも返り値の型として選ぶことができると言っています。\n"
"配列の要素をそのモノイドの値へと変換する関数を与えれば、そのモノイドの構造を利用して配列を畳み込み、1つの値にして返すことができます。\n"

#. type: Plain text
#: text/chapter6.md:262
msgid "Let's try out `foldMap` in PSCi:"
msgstr "それではPSCiで `foldMap`を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:263
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> foldMap show [1, 2, 3, 4, 5]\n"
"\"12345\"\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> foldMap show [1, 2, 3, 4, 5]\n"
"\"12345\"\n"

#. type: Plain text
#: text/chapter6.md:271
msgid ""
"Here, we choose the monoid for strings, which concatenates strings together, "
"and the `show` function which renders an `Int` as a `String`. Then, passing "
"in an array of integers, we see that the results of `show`ing each integer "
"have been concatenated into a single `String`."
msgstr ""
"ここでは繋ぎ合わせるためのモノイドとして文字列を、そして`Int`を文字列として表"
"示する `show`関数を選びました。そうして数の配列を渡すと、それぞれの数を "
"`show`して1つの文字列へと連結した結果が出力されました。"

#. type: Plain text
#: text/chapter6.md:273
msgid ""
"But arrays are not the only types which are foldable. `foldable-traversable` "
"also defines `Foldable` instances for types like `Maybe` and `Tuple`, and "
"other libraries like `lists` define `Foldable` instances for their own data "
"types. `Foldable` captures the notion of an _ordered container_."
msgstr ""
"しかし畳み込み可能な型は配列だけではありません。`foldable-traversable`では "
"`Maybe`や `Tuple`のような型の `Foldable`インスタンスが定義されており、`lists`"
"のような他のライブラリでは、そのライブラリのそれぞれのデータ型に対して "
"`Foldable`インスタンスが定義されています。`Foldable`は _順序付きコンテナ_ "
"(ordered container) の概念を見据えたものなのです。"

#. type: Title ###
#: text/chapter6.md:274
#, no-wrap
msgid "Functor, and Type Class Laws"
msgstr "関手と型クラス則"

#. type: Plain text
#: text/chapter6.md:277
msgid ""
"The Prelude also defines a collection of type classes which enable a "
"functional style of programming with side-effects in PureScript: `Functor`, "
"`Applicative` and `Monad`. We will cover these abstractions later in the "
"book, but for now, let's look at the definition of the `Functor` type class, "
"which we have seen already in the form of the `map` function:"
msgstr ""
"PureScriptで副作用を伴う関数型プログラミングのスタイルを可能にするための"
"`Functor`と `Applicative`、 `Monad`といった型クラスがPreludeでは定義されてい"
"ます。これらの抽象化については後ほど本書で扱いますが、まずは`map`関数の形で既"
"に見てきた`Functor`型クラスの定義を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:278
#, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
msgstr ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter6.md:284
#, no-wrap
msgid "The `map` function (and its alias `<$>`) allows a function to be \"lifted\" over a data structure. The precise definition of the word \"lifted\" here depends on the data structure in question, but we have already seen its behavior for some simple types:\n"
msgstr ""
"`map`関数（別名`<$>`）は関数をそのデータ構造まで「持ち上げる」(lift) ことができます。\n"
"ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、既に幾つかの単純な型についてその動作を見てきました。\n"

#. type: Fenced code block (text)
#: text/chapter6.md:285
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> map (\\n -> n < 3) [1, 2, 3, 4, 5]\n"
"[true, true, false, false, false]\n"
"\n"
"> import Data.Maybe\n"
"> import Data.String (length)\n"
"\n"
"> map length (Just \"testing\")\n"
"(Just 7)\n"
msgstr ""
"> import Prelude\n"
"\n"
"> map (\\n -> n < 3) [1, 2, 3, 4, 5]\n"
"[true, true, false, false, false]\n"
"\n"
"> import Data.Maybe\n"
"> import Data.String (length)\n"
"\n"
"> map length (Just \"testing\")\n"
"(Just 7)\n"

#. type: Plain text
#: text/chapter6.md:299
msgid ""
"How can we understand the meaning of the `map` function, when it acts on "
"many different structures, each in a different way?"
msgstr ""
"`map`演算子は様々な構造の上でそれぞれ異なる挙動をしますが、 `map`演算子の意味"
"はどのように理解すればいいのでしょうか。"

#. type: Plain text
#: text/chapter6.md:301
msgid ""
"Well, we can build an intuition that the `map` function applies the function "
"it is given to each element of a container, and builds a new container from "
"the results, with the same shape as the original. But how do we make this "
"concept precise?"
msgstr ""
"直感的には、 `map`演算子はコンテナのそれぞれの要素へ関数を適用し、その結果か"
"ら元のデータと同じ形状を持った新しいコンテナを構築するものとできます。\n"
"しかし、この着想を精密にするにはどうしたらいいでしょうか。"

#. type: Plain text
#: text/chapter6.md:303
msgid ""
"Type class instances for `Functor` are expected to adhere to a set of "
"_laws_, called the _functor laws_:"
msgstr ""
"`Functor`の型クラスのインスタンスは、*関手則*と呼ばれる法則を順守するものと期"
"待されています。"

#. type: Bullet: '- '
#: text/chapter6.md:306
msgid "`map identity xs = xs`"
msgstr "`map identity xs = xs`"

#. type: Bullet: '- '
#: text/chapter6.md:306
msgid "`map g (map f xs) = map (g <<< f) xs`"
msgstr "`map g (map f xs) = map (g <<< f) xs`"

#. type: Plain text
#: text/chapter6.md:308
msgid ""
"The first law is the _identity law_. It states that lifting the identity "
"function (the function which returns its argument unchanged) over a "
"structure just returns the original structure. This makes sense since the "
"identity function does not modify its input."
msgstr ""
"最初の法則は _恒等射律_ (identity law) です。これは、恒等関数（引数を変えずに"
"返す関数）をその構造まで持ち上げると、元の構造をそのまま返すという意味です。"
"恒等関数は入力を変更しませんから、これは理にかなっています。"

#. type: Plain text
#: text/chapter6.md:310
msgid ""
"The second law is the _composition law_. It states that mapping one function "
"over a structure, and then mapping a second, is the same thing as mapping "
"the composition of the two functions over the structure."
msgstr ""
"第二の法則は _合成律_ (composition law) です。構造を1つの関数で写してから2つ"
"めの関数で写すのは、2つの関数の合成で構造を写すのと同じだ、と言っています。"

#. type: Plain text
#: text/chapter6.md:312
msgid ""
"Whatever \"lifting\" means in the general sense, it should be true that any "
"reasonable definition of lifting a function over a data structure should "
"obey these rules."
msgstr ""
"「持ち上げ」の一般的な意味が何であれ、データ構造に対する持ち上げ関数の正しい"
"定義はこれらの法則に従っていなければなりません。"

#. type: Plain text
#: text/chapter6.md:314
msgid ""
"Many standard type classes come with their own set of similar laws. The laws "
"given to a type class give structure to the functions of that type class and "
"allow us to study its instances in generality. The interested reader can "
"research the laws ascribed to the standard type classes that we have seen "
"already."
msgstr ""
"標準の型クラスの多くには、このような法則が付随しています。\n"
"一般に、型クラスに与えられた法則は、型クラスの関数に構造を与え、普遍的にイン"
"スタンスについて調べられるようにします。\n"
"興味のある読者は、既に見てきた標準の型クラスに属する法則について調べてみても"
"よいでしょう。"

#. type: Title ###
#: text/chapter6.md:315
#, no-wrap
msgid "Deriving Instances"
msgstr "インスタンスの導出"

#. type: Plain text
#: text/chapter6.md:318
msgid ""
"Rather than writing instances manually, you can let the compiler do most of "
"the work for you. Take a look at this [Type Class Deriving guide](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md). That information will help you solve the following exercises."
msgstr ""
"インスタンスを手作業で描く代わりに、ほとんどの作業をコンパイラにさせることが"
"できます。\n"
"この[型クラス導出手引き](https://github.com/purescript/documentation/blob/"
"master/guides/Type-Class-Deriving.md)を見てください。\n"
"そちらの情報が以下の演習を解く手助けになることでしょう。"

#. type: Plain text
#: text/chapter6.md:322
msgid "The following newtype represents a complex number:"
msgstr "（簡単）次のnewtypeは複素数を表します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:323
#, no-wrap
msgid "{{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Complex}}\n"
msgstr "{{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Complex}}\n"

#. type: Bullet: '1. '
#: text/chapter6.md:328
msgid ""
"(Easy) Define a `Show` instance for `Complex`. Match the output format "
"expected by the tests (e.g. `1.2+3.4i`, `5.6-7.8i`, etc.)."
msgstr ""
"（簡単）`Complex`に`Show`インスタンスを定義してください。\n"
"出力の形式はテストで期待される形式と一致させてください（例：`1.2+3.4i`、"
"`5.6-7.7i`など）。"

#. type: Bullet: '2. '
#: text/chapter6.md:330
msgid ""
"(Easy) Derive an `Eq` instance for `Complex`. _Note_: You may instead write "
"this instance manually, but why do more work if you don't have to?"
msgstr ""
"（簡単）`Eq`インスタンスを`Complex`に導出してください。\n"
"*補足*：代わりにこのインスタンスを手作業で書いてもよいですが、しなくていいの"
"になぜすることがありましょう。"

#. type: Bullet: '3. '
#: text/chapter6.md:332
msgid ""
"(Medium) Define a `Semiring` instance for `Complex`. _Note_: You can use "
"`wrap` and `over2` from [`Data.Newtype`](https://pursuit.purescript.org/"
"packages/purescript-newtype/docs/Data.Newtype) to create a more concise "
"solution. If you do so, you will also need to import `class Newtype` from "
"`Data.Newtype` and derive a `Newtype` instance for `Complex`."
msgstr ""
"（普通）`Semiring`インタンスを`Complex`に定義してください。*補足*：[`Data."
"Newtype`](https://pursuit.purescript.org/packages/purescript-newtype/docs/"
"Data.Newtype)の`wrap`と`over2`を使ってより簡潔な解答をつくることができます。"
"もしそうするのでしたら、`Data.Newtype`から`class Newtype`をインポートしたり、"
"`Newtype`インスタンスを`Complex`に導出したりする必要も出てくるでしょう。"

#. type: Bullet: '4. '
#: text/chapter6.md:334
msgid ""
"(Easy) Derive (via `newtype`) a `Ring` instance for `Complex`. _Note_: You "
"may instead write this instance manually, but that's not as convenient."
msgstr ""
"（簡単）（`newtype`を介して）`Ring`インスタンスを`Complex`に導出してくださ"
"い。\n"
"*補足*：代わりにこのインスタンスを手作業で書くこともできますが、そう手軽には"
"できません。"

#. type: Plain text
#: text/chapter6.md:336
#, no-wrap
msgid "    Here's the `Shape` ADT from the previous chapter:\n"
msgstr "    以下は前章からの`Shape`のADTです。\n"

#. type: Plain text
#: text/chapter6.md:340
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Shape}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Shape}}\n"
"    ```\n"

#. type: Bullet: '5. '
#: text/chapter6.md:342
msgid ""
"(Medium) Derive (via `Generic`) a `Show` instance for `Shape`. How does the "
"amount of code written and `String` output compare to `showShape` from the "
"previous chapter? _Hint_: See the [Deriving from `Generic`](https://github."
"com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md#deriving-from-generic) section of the [Type Class Deriving](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md) guide."
msgstr ""
"（普通）（`Generic`を介して）`Show`インスタンスを`Shape`に導出してくださ"
"い。\n"
"コードの量はどのくらいになりましたか。\n"
"また、前の章の`showShape`と比較して`String`の出力はどうなりましたか。\n"
"*手掛かり*：[型クラス導出](https://github.com/purescript/documentation/blob/"
"master/guides/Type-Class-Deriving.md)手引きの[`Generic`から導出する](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md#deriving-from-generic)節を見てください。"

#. type: Title ##
#: text/chapter6.md:343
#, no-wrap
msgid "Type Class Constraints"
msgstr "型クラス制約"

#. type: Plain text
#: text/chapter6.md:346
msgid ""
"Types of functions can be constrained by using type classes. Here is an "
"example: suppose we want to write a function which tests if three values are "
"equal, by using equality defined using an `Eq` type class instance."
msgstr ""
"型クラスを使うと、関数の型に制約を加えることができます。\n"
"例を示しましょう。\n"
"`Eq`型クラスのインスタンスで定義された等値性を使って、3つの値が等しいかどうか"
"を調べる関数を書きたいとします。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:347
#, no-wrap
msgid ""
"threeAreEqual :: forall a. Eq a => a -> a -> a -> Boolean\n"
"threeAreEqual a1 a2 a3 = a1 == a2 && a2 == a3\n"
msgstr ""
"threeAreEqual :: forall a. Eq a => a -> a -> a -> Boolean\n"
"threeAreEqual a1 a2 a3 = a1 == a2 && a2 == a3\n"

#. type: Plain text
#: text/chapter6.md:353
#, no-wrap
msgid "The type declaration looks like an ordinary polymorphic type defined using `forall`. However, there is a type class constraint `Eq a`, separated from the rest of the type by a double arrow `=>`.\n"
msgstr ""
"この型宣言は `forall`を使って定義された通常の多相型のようにも見えます。\n"
"しかし、二重線矢印 `=>`で型の残りの部分から区切られた、型クラス制約 (type class constraint) `Eq a`があります。\n"

#. type: Plain text
#: text/chapter6.md:355
msgid ""
"This type says that we can call `threeAreEqual` with any choice of type `a`, "
"as long as there is an `Eq` instance available for `a` in one of the "
"imported modules."
msgstr ""
"インポートされたモジュールのどれかに `a`に対する `Eq`インスタンスが存在するな"
"ら、どんな型 `a`を選んでも `threeAsEqual`を呼び出すことができる、とこの型は"
"言っています。"

#. type: Plain text
#: text/chapter6.md:357
msgid ""
"Constrained types can contain several type class instances, and the types of "
"the instances are not restricted to simple type variables. Here is another "
"example which uses `Ord` and `Show` instances to compare two values:"
msgstr ""
"制約された型には複数の型クラスインスタンスを含めることができますし、インスタ"
"ンスの型は単純な型変数に限定されません。 `Ord`と `Show`のインスタンスを使って"
"2つの値を比較する例を次に示します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:358
#, no-wrap
msgid ""
"showCompare :: forall a. Ord a => Show a => a -> a -> String\n"
"showCompare a1 a2 | a1 < a2 =\n"
"  show a1 <> \" is less than \" <> show a2\n"
"showCompare a1 a2 | a1 > a2 =\n"
"  show a1 <> \" is greater than \" <> show a2\n"
"showCompare a1 a2 =\n"
"  show a1 <> \" is equal to \" <> show a2\n"
msgstr ""
"showCompare :: forall a. Ord a => Show a => a -> a -> String\n"
"showCompare a1 a2 | a1 < a2 =\n"
"  show a1 <> \" is less than \" <> show a2\n"
"showCompare a1 a2 | a1 > a2 =\n"
"  show a1 <> \" is greater than \" <> show a2\n"
"showCompare a1 a2 =\n"
"  show a1 <> \" is equal to \" <> show a2\n"

#. type: Plain text
#: text/chapter6.md:370
#, no-wrap
msgid ""
"Note that multiple constraints can be specified by using the `=>` symbol multiple times, just like we specify curried functions\n"
"of multiple arguments. But remember not to confuse the two symbols:\n"
msgstr ""
"`=>`シンボルを複数回使って複数の制約を指定できることに注意してください。\n"
"複数の引数のカリー化された関数を定義するのと同様です。\n"
"しかし、2つの記号を混同しないように注意してください。\n"

# whereasは次の項目に移します
#. type: Bullet: '- '
#: text/chapter6.md:373
msgid ""
"`a -> b` denotes the type of functions from _type_ `a` to _type_ `b`, whereas"
msgstr "`a -> b`は _型_ `a`から _型_ `b`への関数の型を表します。"

# 「一方で」は前の項目から来ています
#. type: Bullet: '- '
#: text/chapter6.md:373
msgid "`a => b` applies the _constraint_ `a` to the type `b`."
msgstr "一方で、`a => b`は _制約_ `a`を型`b`に適用します。"

#. type: Plain text
#: text/chapter6.md:375
msgid ""
"The PureScript compiler will try to infer constrained types when a type "
"annotation is not provided. This can be useful if we want to use the most "
"general type possible for a function."
msgstr ""
"PureScriptコンパイラは、型の注釈が提供されていない場合、制約付きの型を推論し"
"ようとします。これは、関数に対してできる限り最も一般的な型を使用したい場合に"
"便利です。"

#. type: Plain text
#: text/chapter6.md:377
msgid ""
"To see this, try using one of the standard type classes like `Semiring` in "
"PSCi:"
msgstr ""
"PSCiで `Semiring`のような標準の型クラスの何れかを使って、このことを試してみま"
"しょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:378
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> :type \\x -> x + x\n"
"forall a. Semiring a => a -> a\n"
msgstr ""
"> import Prelude\n"
"\n"
"> :type \\x -> x + x\n"
"forall a. Semiring a => a -> a\n"

#. type: Plain text
#: text/chapter6.md:386
#, no-wrap
msgid "Here, we might have annotated this function as `Int -> Int`, or `Number -> Number`, but PSCi shows us that the most general type works for any `Semiring`, allowing us to use our function with both `Int`s and `Number`s.\n"
msgstr "ここで、この関数には`Int -> Int`または`Number -> Number`と注釈を付けることが考えられますが、最も一般的な型が`Semiring`で動作するため、PSCiでは`Int`と `Number`の両方で関数を実行させることができます。\n"

#. type: Title ##
#: text/chapter6.md:387
#, no-wrap
msgid "Instance Dependencies"
msgstr "インスタンスの依存関係"

#. type: Plain text
#: text/chapter6.md:390
msgid ""
"Just as the implementation of functions can depend on type class instances "
"using constrained types, so can the implementation of type class instances "
"depend on other type class instances. This provides a powerful form of "
"program inference, in which the implementation of a program can be inferred "
"using its types."
msgstr ""
"制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、型ク"
"ラスインスタンスの実装は他の型クラスインスタンスに依存できます。これにより、"
"型を使ってプログラムの実装を推論するという、プログラム推論の強力な形式を提供"
"します。"

#. type: Plain text
#: text/chapter6.md:392
msgid ""
"For example, consider the `Show` type class. We can write a type class "
"instance to `show` arrays of elements, as long as we have a way to `show` "
"the elements themselves:"
msgstr ""
"`Show`型クラスを例に考えてみましょう。\n"
"それぞれの要素を `show`する方法がある限り、その要素の配列を `show`する型クラ"
"スインスタンスを書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:393
#, no-wrap
msgid ""
"instance showArray :: Show a => Show (Array a) where\n"
"  ...\n"
msgstr ""
"instance showArray :: Show a => Show (Array a) where\n"
"  ...\n"

#. type: Plain text
#: text/chapter6.md:400
#, no-wrap
msgid ""
"If a type class instance depends on multiple other instances, those instances should be grouped in parentheses and separated by\n"
"commas on the left hand side of the `=>` symbol:\n"
msgstr "型クラスインスタンスが複数の他のインスタンスに依存する場合、括弧で囲んでそれらのインスタンスをコンマで区切り、それを`=>`シンボルの左側に置く必要があります。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:401
#, no-wrap
msgid ""
"instance showEither :: (Show a, Show b) => Show (Either a b) where\n"
"  ...\n"
msgstr ""
"instance showEither :: (Show a, Show b) => Show (Either a b) where\n"
"  ...\n"

#. type: Plain text
#: text/chapter6.md:407
msgid "These two type class instances are provided in the `prelude` library."
msgstr "これらの2つの型クラスインスタンスは `prelude`ライブラリにあります。"

#. type: Plain text
#: text/chapter6.md:409
msgid ""
"When the program is compiled, the correct type class instance for `Show` is "
"chosen based on the inferred type of the argument to `show`. The selected "
"instance might depend on many such instance relationships, but this "
"complexity is not exposed to the developer."
msgstr ""
"プログラムがコンパイルされると、`Show`の正しい型クラスのインスタンスは `show`"
"の引数の推論された型に基づいて選ばれます。\n"
"選択されたインスタンスが沢山のそうしたインスタンスの関係に依存しているかもし"
"れませんが、このあたりの複雑さに開発者が関与することはありません。"

#. type: Bullet: '1. '
#: text/chapter6.md:413
msgid ""
"(Easy) The following declaration defines a type of non-empty arrays of "
"elements of type `a`:"
msgstr "（簡単）以下の宣言では型 `a`の要素の空でない配列の型を定義しています。"

#. type: Plain text
#: text/chapter6.md:417
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:NonEmpty}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:NonEmpty}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:419
#, no-wrap
msgid "    Write an `Eq` instance for the type `NonEmpty a` which reuses the instances for `Eq a` and `Eq (Array a)`. _Note:_ you may instead derive the `Eq` instance.\n"
msgstr ""
"    `Eq a`と`Eq (Array a)`のインスタンスを再利用し、型`NonEmpty`に`Eq`インスタンスを書いてください。\n"
"    *補足*：代わりに`Eq`インスタンスも導出できます。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:421
msgid ""
"(Medium) Write a `Semigroup` instance for `NonEmpty a` by reusing the "
"`Semigroup` instance for `Array`."
msgstr ""
"（普通）`Array`の`Semigroup`インスタンスを再利用して、`NonEmpty`への"
"`Semigroup`インスタンスを書いてください。"

#. type: Bullet: '1. '
#: text/chapter6.md:423
msgid "(Medium) Write a `Functor` instance for `NonEmpty`."
msgstr "（普通）`NonEmpty`に`Functor`インスタンスを書いてください。"

#. type: Bullet: '1. '
#: text/chapter6.md:425
msgid ""
"(Medium) Given any type `a` with an instance of `Ord`, we can add a new "
"\"infinite\" value which is greater than any other value:"
msgstr ""
"（普通）`Ord`のインスタンス付きの任意の型`a`が与えられているとすると、新しく"
"それ以外のどんな値よりも大きい「無限の」値を付け加えられます。"

#. type: Plain text
#: text/chapter6.md:429
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Extended}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Extended}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:431
#, no-wrap
msgid "    Write an `Ord` instance for `Extended a` which reuses the `Ord` instance for `a`.\n"
msgstr "    `a`への`Ord`インスタンスを再利用して、`Extended a`に`Ord`インスタンスを書いてください。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:433
msgid ""
"(Difficult) Write a `Foldable` instance for `NonEmpty`. _Hint_: reuse the "
"`Foldable` instance for arrays."
msgstr ""
"（難しい）`NonEmpty`に`Foldable`インスタンスを書いてください。\n"
"*手掛かり*：配列への`Foldable`インスタンスを再利用してください。"

#. type: Bullet: '1. '
#: text/chapter6.md:435
msgid ""
"(Difficult) Given a type constructor `f` which defines an ordered container "
"(and so has a `Foldable` instance), we can create a new container type which "
"includes an extra element at the front:"
msgstr ""
"（難しい）順序付きコンテナを定義する（そして `Foldable`のインスタンスを持って"
"いる）ような型構築子 `f`が与えられたとき、追加の要素を先頭に含めるような新た"
"なコンテナ型を作ることができます。"

#. type: Plain text
#: text/chapter6.md:439
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:441
#, no-wrap
msgid "    The container `OneMore f` also has an ordering, where the new element comes before any element of `f`. Write a `Foldable` instance for `OneMore f`:\n"
msgstr ""
"   このコンテナ `OneMore f`もまた順序を持っています。\n"
"   ここで、新しい要素は任意の `f`の要素よりも前にきます。\n"
"   この `OneMore f`の `Foldable`インスタンスを書いてみましょう。\n"

#. type: Plain text
#: text/chapter6.md:446
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore_Foldable}}\n"
"      ...\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore_Foldable}}\n"
"      ...\n"
"    ```\n"

#. type: Bullet: '1. '
#: text/chapter6.md:448
msgid ""
"(Medium) Write a `dedupShapes :: Array Shape -> Array Shape` function which "
"removes duplicate `Shape`s from an array using the `nubEq` function."
msgstr ""
"（普通）`nubEq`関数を使い、配列から重複する`Shape`を削除する`dedupShapes :: "
"Array Shape -> Array Shape`関数を書いてください。"

#. type: Bullet: '1. '
#: text/chapter6.md:450
msgid ""
"(Medium) Write a `dedupShapesFast` function which is the same as "
"`dedupShapes`, but uses the more efficient `nub` function."
msgstr ""
"（普通）`dedupShapesFast`関数を書いてください。\n"
"`dedupShapes`とほぼ同じですが、より効率の良い`nub`関数を使います。"

#. type: Title ##
#: text/chapter6.md:451
#, no-wrap
msgid "Multi Parameter Type Classes"
msgstr "多変数型クラス"

#. type: Plain text
#: text/chapter6.md:454
msgid ""
"It's not the case that a type class can only take a single type as an "
"argument. This is the most common case, but in fact, a type class can be "
"parameterized by _zero or more_ type arguments."
msgstr ""
"型クラスは必ずしも1つの型だけを型変数としてとるわけではありません。型変数が1"
"つだけなのが最も一般的ですが、実際には型クラスは*ゼロ個以上の*型変数を持つこ"
"とができます。"

#. type: Plain text
#: text/chapter6.md:456
msgid "Let's see an example of a type class with two type arguments."
msgstr "それでは2つの型引数を持つ型クラスの例を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:457
#, no-wrap
msgid ""
"module Stream where\n"
"\n"
"import Data.Array as Array\n"
"import Data.Maybe (Maybe)\n"
"import Data.String.CodeUnits as String\n"
"\n"
"class Stream stream element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
"\n"
"instance streamArray :: Stream (Array a) a where\n"
"  uncons = Array.uncons\n"
"\n"
"instance streamString :: Stream String Char where\n"
"  uncons = String.uncons\n"
msgstr ""
"module Stream where\n"
"\n"
"import Data.Array as Array\n"
"import Data.Maybe (Maybe)\n"
"import Data.String.CodeUnits as String\n"
"\n"
"class Stream stream element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
"\n"
"instance streamArray :: Stream (Array a) a where\n"
"  uncons = Array.uncons\n"
"\n"
"instance streamString :: Stream String Char where\n"
"  uncons = String.uncons\n"

#. type: Plain text
#: text/chapter6.md:475
msgid ""
"The `Stream` module defines a class `Stream` which identifies types which "
"look like streams of elements, where elements can be pulled from the front "
"of the stream using the `uncons` function."
msgstr ""
"この `Stream`モジュールでは、要素のストリームのような型を示すクラス `Stream`"
"が定義されています。\n"
"`uncons`関数を使ってストリームの先頭から要素を取り出すことができます。"

#. type: Plain text
#: text/chapter6.md:477
msgid ""
"Note that the `Stream` type class is parameterized not only by the type of "
"the stream itself, but also by its elements. This allows us to define type "
"class instances for the same stream type but different element types."
msgstr ""
"`Stream`型クラスは、ストリーム自身の型だけでなくその要素の型も型変数として"
"持っていることに注意してください。これによって、ストリームの型が同じでも要素"
"の型について異なる型クラスインスタンスを定義できます。"

#. type: Plain text
#: text/chapter6.md:479
msgid ""
"The module defines two type class instances: an instance for arrays, where "
"`uncons` removes the head element of the array using pattern matching, and "
"an instance for String, which removes the first character from a String."
msgstr ""
"このモジュールでは2つの型クラスインスタンスが定義されています。\n"
"`uncons`がパターン照合で配列の先頭の要素を取り除くような配列のインスタンス"
"と、文字列から最初の文字を取り除くような文字列のインスタンスです。"

#. type: Plain text
#: text/chapter6.md:481
msgid ""
"We can write functions which work over arbitrary streams. For example, here "
"is a function which accumulates a result in some `Monoid` based on the "
"elements of a stream:"
msgstr ""
"任意のストリーム上で動作する関数を記述できます。例えば、ストリームの要素に基"
"づいて `Monoid`に結果を累積する関数は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:482
#, no-wrap
msgid ""
"import Prelude\n"
"import Data.Monoid (class Monoid, mempty)\n"
"\n"
"foldStream :: forall l e m. Stream l e => Monoid m => (e -> m) -> l -> m\n"
"foldStream f list =\n"
"  case uncons list of\n"
"    Nothing -> mempty\n"
"    Just cons -> f cons.head <> foldStream f cons.tail\n"
msgstr ""
"import Prelude\n"
"import Data.Monoid (class Monoid, mempty)\n"
"\n"
"foldStream :: forall l e m. Stream l e => Monoid m => (e -> m) -> l -> m\n"
"foldStream f list =\n"
"  case uncons list of\n"
"    Nothing -> mempty\n"
"    Just cons -> f cons.head <> foldStream f cons.tail\n"

#. type: Plain text
#: text/chapter6.md:494
msgid ""
"Try using `foldStream` in PSCi for different types of `Stream` and different "
"types of `Monoid`."
msgstr ""
"PSCiで使って、異なる `Stream`の型や異なる `Monoid`の型について `foldStream`を"
"呼び出してみましょう。"

#. type: Title ##
#: text/chapter6.md:495
#, no-wrap
msgid "Functional Dependencies"
msgstr "関数従属性"

#. type: Plain text
#: text/chapter6.md:498
msgid ""
"Multi-parameter type classes can be very useful, but can easily lead to "
"confusing types and even issues with type inference. As a simple example, "
"consider writing a generic `tail` function on streams using the `Stream` "
"class given above:"
msgstr ""
"多変数型クラスは非常に便利ですが、混乱しやすい型や型推論の問題にも繋がりま"
"す。\n"
"簡単な例として、上記の `Stream`クラスを使って汎用的な`tail`関数をストリームに"
"書くことを考えてみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:499
#, no-wrap
msgid "genericTail xs = map _.tail (uncons xs)\n"
msgstr "genericTail xs = map _.tail (uncons xs)\n"

#. type: Plain text
#: text/chapter6.md:504
msgid "This gives a somewhat confusing error message:"
msgstr "これはやや複雑なエラーメッセージを出力します。"

#. type: Fenced code block (text)
#: text/chapter6.md:505
#, no-wrap
msgid ""
"The inferred type\n"
"\n"
"  forall stream a. Stream stream a => stream -> Maybe stream\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"The inferred type\n"
"\n"
"  forall stream a. Stream stream a => stream -> Maybe stream\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:514
msgid ""
"The problem is that the `genericTail` function does not use the `element` "
"type mentioned in the definition of the `Stream` type class, so that type is "
"left unsolved."
msgstr ""
"エラーは、 `genericTail`関数が `Stream`型クラスの定義で言及された `element`型"
"を使用しないので、その型は未解決のままであることを指しています。"

#. type: Plain text
#: text/chapter6.md:516
msgid ""
"Worse still, we cannot even use `genericTail` by applying it to a specific "
"type of stream:"
msgstr ""
"更に残念なことに、特定の型のストリームに`genericTail`を適用できません。"

#. type: Fenced code block (text)
#: text/chapter6.md:517
#, no-wrap
msgid ""
"> map _.tail (uncons \"testing\")\n"
"\n"
"The inferred type\n"
"\n"
"  forall a. Stream String a => Maybe String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"> map _.tail (uncons \"testing\")\n"
"\n"
"The inferred type\n"
"\n"
"  forall a. Stream String a => Maybe String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:528
msgid ""
"Here, we might expect the compiler to choose the `streamString` instance. "
"After all, a `String` is a stream of `Char`s, and cannot be a stream of any "
"other type of elements."
msgstr ""
"ここでは、コンパイラが `streamString`インスタンスを選択することを期待していま"
"す。\n"
"結局のところ、 `String`は `Char`のストリームであり、他の型のストリームであっ"
"てはなりません。"

#. type: Plain text
#: text/chapter6.md:530
msgid ""
"The compiler is unable to make that deduction automatically, and cannot "
"commit to the `streamString` instance. However, we can help the compiler by "
"adding a hint to the type class definition:"
msgstr ""
"コンパイラは自動的にそう推論できず、`streamString`インスタンスを割り当てるこ"
"とができません。\n"
"しかし、型クラス定義に手掛かりを追加すると、コンパイラを助けることができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:531
#, no-wrap
msgid ""
"class Stream stream element | stream -> element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
msgstr ""
"class Stream stream element | stream -> element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"

#. type: Plain text
#: text/chapter6.md:537
#, no-wrap
msgid "Here, `stream -> element` is called a _functional dependency_. A functional dependency asserts a functional relationship between the type arguments of a multi-parameter type class. This functional dependency tells the compiler that there is a function from stream types to (unique) element types, so if the compiler knows the stream type, then it can commit to the element type.\n"
msgstr "ここで、 `stream -> element`は _関数従属性_ (functional dependency) と呼ばれます。関数従属性は、多変数型クラスの型引数間の関数関係を宣言します。この関数の依存関係は、ストリーム型から（一意の）要素型への関数があることをコンパイラに伝えるので、コンパイラがストリーム型を知っていれば要素の型を割り当てられます。\n"

#. type: Plain text
#: text/chapter6.md:539
msgid ""
"This hint is enough for the compiler to infer the correct type for our "
"generic tail function above:"
msgstr ""
"この手掛かりがあれば、コンパイラが上記の汎用的な尾鰭関数の正しい型を推論する"
"のに充分です。"

#. type: Fenced code block (text)
#: text/chapter6.md:540
#, no-wrap
msgid ""
"> :type genericTail\n"
"forall stream element. Stream stream element => stream -> Maybe stream\n"
"\n"
"> genericTail \"testing\"\n"
"(Just \"esting\")\n"
msgstr ""
"> :type genericTail\n"
"forall stream element. Stream stream element => stream -> Maybe stream\n"
"\n"
"> genericTail \"testing\"\n"
"(Just \"esting\")\n"

#. type: Plain text
#: text/chapter6.md:549
msgid ""
"Functional dependencies can be quite useful when using multi-parameter type "
"classes to design certain APIs."
msgstr ""
"多種の型のクラスを使用して何らかのAPIを設計する場合、関数従属性は非常に有用で"
"す。"

#. type: Title ##
#: text/chapter6.md:550
#, no-wrap
msgid "Nullary Type Classes"
msgstr "型変数のない型クラス"

#. type: Plain text
#: text/chapter6.md:553
msgid ""
"We can even define type classes with zero type arguments! These correspond "
"to compile-time assertions about our functions, allowing us to track global "
"properties of our code in the type system."
msgstr ""
"ゼロ個の型変数を持つ型クラスさえも定義できます。\n"
"これらは関数に対するコンパイル時のアサーションに対応しており、型システム内の"
"コードの大域的な性質を把握できます。"

#. type: Plain text
#: text/chapter6.md:555
msgid ""
"An important example is the `Partial` class which we saw earlier when "
"discussing partial functions. Take for example the functions `head` and "
"`tail` defined in `Data.Array.Partial` that allow us to get the head or tail "
"of an array without wrapping them in a `Maybe`, so they can fail if the "
"array is empty:"
msgstr ""
"重要な一例として、前に部分関数についてお話しした際に見た`Partial`クラスがあり"
"ます。`Data.Array.Partial`に定義されている関数`head`と`tail`を例に取りましょ"
"う。この関数は配列の先頭と尾鰭を`Maybe`に包むことなく取得できます。なので配列"
"が空のときに失敗する可能性があります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:556
#, no-wrap
msgid ""
"head :: forall a. Partial => Array a -> a\n"
"\n"
"tail :: forall a. Partial => Array a -> Array a\n"
msgstr ""
"head :: forall a. Partial => Array a -> a\n"
"\n"
"tail :: forall a. Partial => Array a -> Array a\n"

#. type: Plain text
#: text/chapter6.md:563
msgid ""
"Note that there is no instance defined for the `Partial` type class! Doing "
"so would defeat its purpose: attempting to use the `head` function directly "
"will result in a type error:"
msgstr ""
"`Partial`モジュールの `Partial`型クラスのインスタンスを定義していないことに注"
"意してください。\n"
"こうすると目的を達成できます。\n"
"このままの定義では `head`関数を使用しようとすると型エラーになるのです。"

#. type: Fenced code block (text)
#: text/chapter6.md:564
#, no-wrap
msgid ""
"> head [1, 2, 3]\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Prim.Partial\n"
msgstr ""
"> head [1, 2, 3]\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Prim.Partial\n"

#. type: Plain text
#: text/chapter6.md:573
msgid ""
"Instead, we can republish the `Partial` constraint for any functions making "
"use of partial functions:"
msgstr ""
"代わりに、これらの部分関数を利用する全ての関数で `Partial`制約を再発行できま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:574
#, no-wrap
msgid ""
"secondElement :: forall a. Partial => Array a -> a\n"
"secondElement xs = head (tail xs)\n"
msgstr ""
"secondElement :: forall a. Partial => Array a -> a\n"
"secondElement xs = head (tail xs)\n"

#. type: Plain text
#: text/chapter6.md:580
msgid ""
"We've already seen the `unsafePartial` function, which allows us to treat a "
"partial function as a regular function (unsafely). This function is defined "
"in the `Partial.Unsafe` module:"
msgstr ""
"前章で見た`unsafePartial`関数を使用し、部分関数を通常の関数として（不用心に）"
"扱うことができます。この関数は `Partial.Unsafe`モジュールで定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:581
#, no-wrap
msgid "unsafePartial :: forall a. (Partial => a) -> a\n"
msgstr "unsafePartial :: forall a. (Partial => a) -> a\n"

#. type: Plain text
#: text/chapter6.md:586
msgid ""
"Note that the `Partial` constraint appears _inside the parentheses_ on the "
"left of the function arrow, but not in the outer `forall`. That is, "
"`unsafePartial` is a function from partial values to regular values:"
msgstr ""
"`Partial`制約は関数の矢印の左側の括弧の中に現れますが、外側の `forall`では現"
"れません。\n"
"つまり、 `unsafePartial`は部分的な値から通常の値への関数です。"

#. type: Fenced code block (text)
#: text/chapter6.md:587
#, no-wrap
msgid ""
"> unsafePartial head [1, 2, 3]\n"
"1\n"
"\n"
"> unsafePartial secondElement [1, 2, 3]\n"
"2\n"
msgstr ""
"> unsafePartial head [1, 2, 3]\n"
"1\n"
"\n"
"> unsafePartial secondElement [1, 2, 3]\n"
"2\n"

#. type: Title ##
#: text/chapter6.md:595
#, no-wrap
msgid "Superclasses"
msgstr "上位クラス"

#. type: Plain text
#: text/chapter6.md:598
msgid ""
"Just as we can express relationships between type class instances by making "
"an instance dependent on another instance, we can express relationships "
"between type classes themselves using so-called _superclasses_."
msgstr ""
"インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス"
"間の関係を表現できるように、いわゆる*上位クラス*を使って型クラス間の関係を表"
"現できます。"

#. type: Plain text
#: text/chapter6.md:600
msgid ""
"We say that one type class is a superclass of another if every instance of "
"the second class is required to be an instance of the first, and we indicate "
"a superclass relationship in the class definition by using a backwards "
"facing double arrow."
msgstr ""
"あるクラスのどんなインスタンスも、別のクラスのインスタンスである必要があると"
"き、後者の型クラスは前者の型クラスの上位クラスであるといい、クラス定義で逆向"
"きの太い矢印を使って上位クラス関係を示します。"

#. type: Plain text
#: text/chapter6.md:602
msgid ""
"We've already seen some examples of superclass relationships: the `Eq` class "
"is a superclass of `Ord`, and the `Semigroup` class is a superclass of "
"`Monoid`. For every type class instance of the `Ord` class, there must be a "
"corresponding `Eq` instance for the same type. This makes sense, since in "
"many cases, when the `compare` function reports that two values are "
"incomparable, we often want to use the `Eq` class to determine if they are "
"in fact equal."
msgstr ""
"既に上位クラスの関係の例を目にしました。\n"
"`Eq`クラスは `Ord`の上位クラスですし、`Semigroup`クラスは`Monoid`の上位クラス"
"です。\n"
"`Ord`クラスの全ての型クラスインスタンスについて、その同じ型に対応する `Eq`イ"
"ンスタンスが存在しなければなりません。\n"
"`compare`関数が2つの値の大小を付けられないと報告した時は、それらが実は同値で"
"あるかどうかを決定するために `Eq`クラスを使いたくなることが多いでしょうから、"
"これは理にかなっています。"

#. type: Plain text
#: text/chapter6.md:604
msgid ""
"In general, it makes sense to define a superclass relationship when the laws "
"for the subclass mention the members of the superclass. For example, it is "
"reasonable to assume, for any pair of `Ord` and `Eq` instances, that if two "
"values are equal under the `Eq` instance, then the `compare` function should "
"return `EQ`. In other words, `a == b` should be true exactly when `compare a "
"b` evaluates to `EQ`. This relationship on the level of laws justifies the "
"superclass relationship between `Eq` and `Ord`."
msgstr ""
"一般に、下位クラスの法則が上位クラスのメンバに言及しているとき、上位クラス関"
"係を定義するのは筋が通っています。\n"
"例えば、任意の`Ord`と`Eq`のインスタンスの対について、もし2つの値が`Eq`インス"
"タンスの下で同値であるなら、`compare`関数は `EQ`を返すはずだと見做すのは理に"
"適っています。\n"
"言い換えれば、`a == b`が真であるのはちょうど`compare a b`が`EQ`に評価されると"
"きなのです。\n"
"法則のレベルでのこの関係は`Eq`と`Ord`の間の上位クラス関係の正当性を示します。"

#. type: Plain text
#: text/chapter6.md:606
msgid ""
"Another reason to define a superclass relationship is in the case where "
"there is a clear \"is-a\" relationship between the two classes. That is, "
"every member of the subclass _is a_ member of the superclass as well."
msgstr ""
"上位クラス関係を定義する別の理由となるのは、この2つのクラスの間に明らかに "
"\"is-a\" の関係があることです。\n"
"下位クラスの全てのメンバは、上位クラスのメンバでもあるということです。"

#. type: Bullet: '1. '
#: text/chapter6.md:610
msgid ""
"(Medium) Define a partial function `unsafeMaximum :: Partial => Array Int -> "
"Int` which finds the maximum of a non-empty array of integers. Test out your "
"function in PSCi using `unsafePartial`. _Hint_: Use the `maximum` function "
"from `Data.Foldable`."
msgstr ""
"（普通）部分関数`unsafeMaximum :: Partial => Array Int -> Int`を定義してくだ"
"さい。この関数は空でない整数の配列の最大値を求めます。`unsafePartial`を使って"
"PSCiで関数をテストしてください。*手掛かり*：`Data.Foldable`の `maximum`関数を"
"使います。"

#. type: Bullet: '1. '
#: text/chapter6.md:612
msgid ""
"(Medium) The `Action` class is a multi-parameter type class which defines an "
"action of one type on another:"
msgstr ""
"（普通）次の `Action`クラスは、ある型の別の型での動作 (action) を定義する、多"
"変数型クラスです。"

#. type: Plain text
#: text/chapter6.md:616
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Action}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Action}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:618
#, no-wrap
msgid "    An _action_ is a function which describes how monoidal values are used to determine how to modify a value of another type. There are two laws for the `Action` type class:\n"
msgstr "   *動作*はモノイドな値を使って他の型の値を変更する方法を決めるやり方を記述する関数です。`Action`型クラスには2つの法則があります。\n"

#. type: Bullet: '    - '
#: text/chapter6.md:621
msgid "`act mempty a = a`"
msgstr "`act mempty a = a`"

#. type: Bullet: '    - '
#: text/chapter6.md:621
msgid "`act (m1 <> m2) a = act m1 (act m2 a)`"
msgstr "`act (m1 <> m2) a = act m1 (act m2 a)`"

#. type: Plain text
#: text/chapter6.md:623
#, no-wrap
msgid "    Applying an empty action is a no-op. And applying two actions in sequence is the same as applying the actions combined. That is, actions respect the operations defined by the `Monoid` class.\n"
msgstr ""
"    空の動作を提供しても何も起こりません。\n"
"    そして2つの動作を連続で適用することは結合した動作を適用することと同じです。\n"
"    つまり、動作は`Monoid`クラスで定義される操作に倣っています。\n"

#. type: Plain text
#: text/chapter6.md:625
#, no-wrap
msgid "    For example, the natural numbers form a monoid under multiplication:\n"
msgstr "   例えば自然数は乗算のもとでモノイドを形成します。\n"

#. type: Plain text
#: text/chapter6.md:628
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply}}\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply}}\n"

#. type: Plain text
#: text/chapter6.md:630
#, no-wrap
msgid "    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:semigroupMultiply}}\n"
msgstr "    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:semigroupMultiply}}\n"

#. type: Plain text
#: text/chapter6.md:633
#, no-wrap
msgid ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:monoidMultiply}}\n"
"    ```\n"
msgstr ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:monoidMultiply}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:635
#, no-wrap
msgid "    Write an instance which implements this action:\n"
msgstr "    この動作を実装するインスタンスを書いてください。\n"

#. type: Plain text
#: text/chapter6.md:640
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply_Action}}\n"
"      ...\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply_Action}}\n"
"      ...\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:642
#, no-wrap
msgid "    Remember, your instance must satisfy the laws listed above.\n"
msgstr "    インスタンスが上で挙げた法則を見たさなくてはならないことを思い出してください。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:644
msgid ""
"(Difficult) There are actually multiple ways to implement an instance of "
"`Action Multiply Int`. How many can you think of? Purescript does not allow "
"multiple implementations of a same instance, so you will have to replace "
"your original implementation. _Note_: the tests cover 4 implementations."
msgstr ""
"（難しい）実は`Action Multiply Int`のインスタンスを実装するには複数の方法があ"
"ります。\n"
"どれだけ思い付きますか。\n"
"PureScriptは同じインスタンスの複数の実装を許さないため、元の実装を置き換える"
"必要があります。\n"
"*補足*：テストでは4つの実装を押さえています。"

#. type: Bullet: '1. '
#: text/chapter6.md:646
msgid ""
"(Medium) Write an `Action` instance which repeats an input string some "
"number of times:"
msgstr ""
"（普通）入力の文字列を何回か繰り返す`Action`インスタンスを書いてください。"

#. type: Plain text
#: text/chapter6.md:651
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:actionMultiplyString}}\n"
"      ...\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:actionMultiplyString}}\n"
"      ...\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:653
#, no-wrap
msgid "    _Hint_: Search Pursuit for a helper-function with the signature [`String -> Int -> String`](https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String). Note that `String` might appear as a more generic type (such as `Monoid`).\n"
msgstr ""
"    *手掛かり*：Pursuitでシグネチャが[`String -> Int -> String`](https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String)の補助関数を検索してください。\n"
"    なお`String`は（`Monoid`のような）より汎用的な型として現れます。\n"

#. type: Plain text
#: text/chapter6.md:655
#, no-wrap
msgid "    Does this instance satisfy the laws listed above?\n"
msgstr "    このインスタンスは上に挙げた法則を満たすでしょうか。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:657
msgid ""
"(Medium) Write an instance `Action m a => Action m (Array a)`, where the "
"action on arrays is defined by acting on each array element independently."
msgstr ""
"（普通）インスタンス `Action m a => Action m (Array a)`を書いてみましょう。\n"
"ここで、 配列上の動作はそれぞれの要素を独立に実行するものとして定義されます。"

#. type: Bullet: '1. '
#: text/chapter6.md:659
msgid ""
"(Difficult) Given the following newtype, write an instance for `Action m "
"(Self m)`, where the monoid `m` acts on itself using `append`:"
msgstr ""
"（難しい）以下のnewtypeが与えらえているとき、`Action m (Self m)`のインスタン"
"スを書いてください。\n"
"ここでモノイド`m`はそれ自体が持つ`append`を用いて動作します。"

#. type: Plain text
#: text/chapter6.md:663
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Self}}\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Self}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:665
#, no-wrap
msgid "    _Note_: The testing framework requires `Show` and `Eq` instances for the `Self` and `Multiply` types. You may either write these instances manually, or let the compiler handle this for you with [`derive newtype instance`](https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype) shorthand.\n"
msgstr ""
"    *補足*：テストフレームワークでは`Self`と`Multiply`型に`Show`と`Eq`インスタンスが必要になります。\n"
"    手作業でこれらのインスタンスを書いてもよいですし、[`derive newtype instance`](https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype)と書くだけでコンパイラに取り仕切ってもらうこともできます。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:667
msgid ""
"(Difficult) Should the arguments of the multi-parameter type class `Action` "
"be related by some functional dependency? Why or why not? _Note_: There is "
"no test for this exercise."
msgstr ""
"（難しい）多変数型のクラス `Action`の引数は、何らかの関数従属性によって関連づ"
"けられるべきですか。\n"
"なぜそうすべき、あるいはそうすべきでないでしょうか。\n"
"*補足*：この演習にはテストがありません。"

#. type: Title ##
#: text/chapter6.md:668
#, no-wrap
msgid "A Type Class for Hashes"
msgstr "ハッシュの型クラス"

#. type: Plain text
#: text/chapter6.md:671
msgid ""
"In the last section of this chapter, we will use the lessons from the rest "
"of the chapter to create a library for hashing data structures."
msgstr ""
"この最後の節では、章の残りを使ってデータ構造をハッシュ化するライブラリを作り"
"ます。"

#. type: Plain text
#: text/chapter6.md:673
msgid ""
"Note that this library is for demonstration purposes only, and is not "
"intended to provide a robust hashing mechanism."
msgstr ""
"なお、このライブラリの説明だけを目的としており、堅牢なハッシュ化の仕組みの提"
"供は目的としていません。"

#. type: Plain text
#: text/chapter6.md:675
msgid "What properties might we expect of a hash function?"
msgstr "ハッシュ関数に期待される性質とはどのようなものでしょうか。"

#. type: Bullet: '- '
#: text/chapter6.md:678
msgid ""
"A hash function should be deterministic, and map equal values to equal hash "
"codes."
msgstr ""
"ハッシュ関数は決定的でなくてはなりません。\n"
"つまり、同じ値には同じハッシュ値を対応させなければなりません。"

#. type: Bullet: '- '
#: text/chapter6.md:678
msgid ""
"A hash function should distribute its results approximately uniformly over "
"some set of hash codes."
msgstr ""
"ハッシュ関数はいろいろなハッシュ値の集合で結果が一様に分布しなければなりませ"
"ん。"

#. type: Plain text
#: text/chapter6.md:680
msgid ""
"The first property looks a lot like a law for a type class, whereas the "
"second property is more along the lines of an informal contract, and "
"certainly would not be enforceable by PureScript's type system. However, "
"this should provide the intuition for the following type class:"
msgstr ""
"最初の性質はまさに型クラスの法則のように見える一方で、2番目の性質はよりくだけ"
"た規約の条項のようなもので、PureScriptの型システムによって確実に強制できるよ"
"うなものではなさそうです。\n"
"しかし、これは型クラスについて次のような直感的理解を与えるはずです。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:681
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:Hashable}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:Hashable}}\n"

#. type: Plain text
#: text/chapter6.md:686
msgid "with the associated law that `a == b` implies `hash a == hash b`."
msgstr ""
"これに、 `a == b`ならば `hash a == hash b`を示唆するという関係性の法則が付随"
"しています。"

#. type: Plain text
#: text/chapter6.md:688
msgid ""
"We'll spend the rest of this section building a library of instances and "
"functions associated with the `Hashable` type class."
msgstr ""
"この節の残りの部分を費やして、`Hashable`型クラスに関連付けられているインスタ"
"ンスと関数のライブラリを構築していきます。"

#. type: Plain text
#: text/chapter6.md:690
msgid "We will need a way to combine hash codes in a deterministic way:"
msgstr "決定的な方法でハッシュ値を結合する方法が必要になります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:691
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:combineHashes}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:combineHashes}}\n"

#. type: Plain text
#: text/chapter6.md:696
msgid ""
"The `combineHashes` function will mix two hash codes and redistribute the "
"result over the interval 0-65535."
msgstr ""
"`combineHashes`関数は2つのハッシュ値を混ぜて結果を0-65535の間に分布します。"

#. type: Plain text
#: text/chapter6.md:698
msgid ""
"Let's write a function which uses the `Hashable` constraint to restrict the "
"types of its inputs. One common task which requires a hashing function is to "
"determine if two values hash to the same hash code. The `hashEqual` relation "
"provides such a capability:"
msgstr ""
"それでは、入力の種類を制限する `Hashable`制約を使う関数を書いてみましょう。\n"
"ハッシュ関数を必要とするよくある目的としては、2つの値が同じハッシュ値にハッ"
"シュ化されるかどうかを決定することです。\n"
"`hashEqual`関係はそのような機能を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:699
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashEqual}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashEqual}}\n"

#. type: Plain text
#: text/chapter6.md:704
msgid ""
"This function uses the `on` function from `Data.Function` to define hash-"
"equality in terms of equality of hash codes, and should read like a "
"declarative definition of hash-equality: two values are \"hash-equal\" if "
"they are equal after each value has been passed through the `hash` function."
msgstr ""
"この関数はハッシュコードの等値性を利用したハッシュ同値性を定義するために"
"`Data.Function`の `on`関数を使っていますが、これはハッシュ同値性の宣言的な定"
"義として読めるはずです。\n"
"つまり、それぞれの値が `hash`関数に渡されたあとで2つの値が等しいなら、それら"
"の値は「ハッシュ同値」です。"

#. type: Plain text
#: text/chapter6.md:706
msgid ""
"Let's write some `Hashable` instances for some primitive types. Let's start "
"with an instance for integers. Since a `HashCode` is really just a wrapped "
"integer, this is simple - we can use the `hashCode` helper function:"
msgstr ""
"原始型の `Hashable`インスタンスを幾つか書いてみましょう。\n"
"まずは整数のインスタンスです。\n"
"`HashCode`は実際には単なる梱包された整数なので、これは簡単です。\n"
"`hashCode`補助関数を使うことができます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:707
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashInt}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashInt}}\n"

#. type: Plain text
#: text/chapter6.md:712
msgid ""
"We can also define a simple instance for `Boolean` values using pattern "
"matching:"
msgstr "パターン照合を使うと、`Boolean`値の単純なインスタンスも定義できます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:713
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashBoolean}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashBoolean}}\n"

#. type: Plain text
#: text/chapter6.md:718
msgid ""
"With an instance for hashing integers, we can create an instance for hashing "
"`Char`s by using the `toCharCode` function from `Data.Char`:"
msgstr ""
"整数のインスタンスでは、`Data.Char`の `toCharCode`関数を使うと`Char`をハッ"
"シュ化するインスタンスを作成できます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:719
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashChar}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashChar}}\n"

#. type: Plain text
#: text/chapter6.md:724
msgid ""
"To define an instance for arrays, we can `map` the `hash` function over the "
"elements of the array (if the element type is also an instance of "
"`Hashable`) and then perform a left fold over the resulting hashes using the "
"`combineHashes` function:"
msgstr ""
"（要素型が `Hashable`のインスタンスでもあるならば）配列の要素に `hash`関数を "
"`map`してから、`combineHashes`関数を使って結果のハッシュを左側に畳み込むこと"
"で、配列のインスタンスを定義します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:725
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashArray}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashArray}}\n"

#. type: Plain text
#: text/chapter6.md:730
msgid ""
"Notice how we build up instances using the simpler instances we have already "
"written. Let's use our new `Array` instance to define an instance for "
"`String`s, by turning a `String` into an array of `Char`s:"
msgstr ""
"既に書いたものより単純なインスタンスを使用して、新たなインスタンスを構築して"
"いるやり方に注目してください。\n"
"`String`を`Char`の配列に変換し、この新たな`Array`インスタンスを使って`String`"
"のインスタンスを定義しましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:731
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashString}}\n"
msgstr "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashString}}\n"

#. type: Plain text
#: text/chapter6.md:736
msgid ""
"How can we prove that these `Hashable` instances satisfy the type class law "
"that we stated above? We need to make sure that equal values have equal hash "
"codes. In cases like `Int`, `Char`, `String` and `Boolean`, this is simple "
"because there are no values of those types which are equal in the sense of "
"`Eq` but not equal identically."
msgstr ""
"これらの `Hashable`インスタンスが先ほどの型クラスの法則を満たしていることを証"
"明するにはどうしたらいいでしょうか。\n"
"同じ値が等しいハッシュ値を持っていることを確認する必要があります。\n"
"`Int`、 `Char`、 `String`、 `Boolean`の場合は、`Eq`の意味では同じ値でも厳密に"
"は同じではない、というような型の値は存在しないので簡単です。"

#. type: Plain text
#: text/chapter6.md:738
msgid ""
"What about some more interesting types? To prove the type class law for the "
"`Array` instance, we can use induction on the length of the array. The only "
"array with length zero is `[]`. Any two non-empty arrays are equal only if "
"they have equal head elements and equal tails, by the definition of `Eq` on "
"arrays. By the inductive hypothesis, the tails have equal hashes, and we "
"know that the head elements have equal hashes if the `Hashable a` instance "
"must satisfy the law. Therefore, the two arrays have equal hashes, and so "
"the `Hashable (Array a)` obeys the type class law as well."
msgstr ""
"もっと面白い型についてはどうでしょうか。\n"
"この場合、配列の長さに関する帰納を使うと、型クラスの法則を証明できます。\n"
"長さゼロの唯一の配列は `[]`です。\n"
"配列の `Eq`の定義により、任意の2つの空でない配列は、それらの先頭の要素が同じ"
"で配列の残りの部分が等しいとき、またその時に限り等しくなります。\n"
"この帰納的な仮定により、配列の残りの部分は同じハッシュ値を持ちますし、もし "
"`Hashable a`インスタンスがこの法則を満たすなら、先頭の要素も同じハッシュ値を"
"もつことがわかります。\n"
"したがって、2つの配列は同じハッシュ値を持ち、`Hashable (Array a)`も同様に型ク"
"ラス法則を満たしています。"

#. type: Plain text
#: text/chapter6.md:740
msgid ""
"The source code for this chapter includes several other examples of "
"`Hashable` instances, such as instances for the `Maybe` and `Tuple` type."
msgstr ""
"この章のソースコードには、 `Maybe`と `Tuple`型のインスタンスなど、他にも "
"`Hashable`インスタンスの例が含まれています。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:746
msgid ""
"(Easy) Use PSCi to test the hash functions for each of the defined "
"instances. _Note_: There is no provided unit test for this exercise."
msgstr ""
"（簡単）PSCiを使って、定義した各インスタンスのハッシュ関数をテストしてくださ"
"い。\n"
"*補足*：この演習には単体試験がありません。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:746
msgid ""
"(Medium) Write a function `arrayHasDuplicates` which tests if an array has "
"any duplicate elements based on both hash and value equality. First check "
"for hash equality with the `hashEqual` function, then check for value "
"equality with `==` if a duplicate pair of hashes is found. _Hint_: the "
"`nubByEq` function in `Data.Array` should make this task much simpler."
msgstr ""
"（普通）ハッシュと値の同値性に基づいて配列が重複する要素を持っているかどうか"
"を調べる関数`arrayHasDuplicates`を書いてください。\n"
"まずハッシュ同値性を`hashEqual`関数で確認し、それからもし重複するハッシュの対"
"が見付かったら`==`で値の同値性を確認してください。\n"
"*手掛かり*：`Data.Array`の `nubByEq`関数はこの問題をずっと簡単にしてくれるで"
"しょう。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:746
msgid ""
"(Medium) Write a `Hashable` instance for the following newtype which "
"satisfies the type class law:"
msgstr ""
"（普通）型クラスの法則を満たす、次のnewtypeの `Hashable`インスタンスを書いて"
"ください。"

#. type: Plain text
#: text/chapter6.md:749
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Hour}}\n"
msgstr ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Hour}}\n"

#. type: Plain text
#: text/chapter6.md:752
#, no-wrap
msgid ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:eqHour}}\n"
"    ```\n"
msgstr ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:eqHour}}\n"
"    ```\n"

#. type: Plain text
#: text/chapter6.md:755
#, no-wrap
msgid ""
"    The newtype `Hour` and its `Eq` instance represent the type of integers modulo 12, so that 1 and 13 are identified as equal, for example. Prove that the type class law holds for your instance.\n"
" 1. (Difficult) Prove the type class laws for the `Hashable` instances for `Maybe`, `Either` and `Tuple`. _Note_: There is no test for this exercise.\n"
msgstr ""
"   newtypeの `Hour`とその `Eq`インスタンスは、12を法とする整数の型を表します。\n"
"   したがって、例えば1と13は等しいと見なされます。\n"
"   そのインスタンスが型クラスの法則を満たしていることを証明してください。\n"
" 1. （難しい）`Maybe`、`Either`そして`Tuple`への`Hashable`インスタンスについて型クラスの法則を証明してください。\n"
"    *補足*：この演習にテストはありません。\n"

#. type: Plain text
#: text/chapter6.md:759
msgid ""
"In this chapter, we've been introduced to _type classes_, a type-oriented "
"form of abstraction which enables powerful forms of code reuse. We've seen a "
"collection of standard type classes from the PureScript standard libraries, "
"and defined our own library based on a type class for computing hash codes."
msgstr ""
"この章では、型に基づく抽象化で、コードの再利用のための強力な形式化を可能にす"
"る _型クラス_ を導入しました。PureScriptの標準ライブラリから標準の型クラスを"
"幾つか見てきました。また、ハッシュ値を計算する型クラスに基づく独自のライブラ"
"リを定義しました。"

#. type: Plain text
#: text/chapter6.md:760
msgid ""
"This chapter also gave an introduction to the notion of type class laws, a "
"technique for proving properties about code which uses type classes for "
"abstraction. Type class laws are part of a larger subject called _equational "
"reasoning_, in which the properties of a programming language and its type "
"system are used to enable logical reasoning about its programs. This is an "
"important idea, and will be a theme which we will return to throughout the "
"rest of the book."
msgstr ""
"この章では型クラス法則の考え方も導入しましたが、これは抽象化に型クラスを使う"
"コードについての性質を証明する手法でした。\n"
"型クラス法則は*等式推論*と呼ばれる大きな分野の一部であり、プログラミング言語"
"の性質と型システムがプログラムを論理的に推論するために使われています。\n"
"これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話題となるでしょう。"

#. type: Title ##
#: text/chapter7.md:1 text/chapter7.md:387
#, no-wrap
msgid "Applicative Validation"
msgstr "アプリカティブによる検証"

#. type: Plain text
#: text/chapter7.md:6
msgid ""
"In this chapter, we will meet an important new abstraction - the "
"_applicative functor_, described by the `Applicative` type class. Don't "
"worry if the name sounds confusing - we will motivate the concept with a "
"practical example - validating form data. This technique allows us to "
"convert code which usually involves a lot of boilerplate checking into a "
"simple, declarative description of our form."
msgstr ""
"この章では、`Applicative`型クラスによって表現される _アプリカティブ関手_ "
"(applicative functor) という重要な抽象化と新たに出会うことになります。名前が"
"難しそうに思えても心配しないでください。フォームデータの検証という実用的な例"
"を使ってこの概念の動機付けをします。アプリカティブ関手を使うと、通常であれば"
"大量の決まり文句を伴うようなコードを、簡潔で宣言的な記述へと変えることができ"
"るようになります。"

#. type: Plain text
#: text/chapter7.md:8
msgid ""
"We will also meet another type class, `Traversable`, which describes "
"_traversable functors_, and see how this concept also arises very naturally "
"from solutions to real-world problems."
msgstr ""
"また、*巡回可能関手*を表現する`Traversable`という別の型クラスにも出会います。"
"現実の問題への解決策からこの概念が自然に生じることがわかるでしょう。"

#. type: Plain text
#: text/chapter7.md:10
msgid ""
"The example code for this chapter will be a continuation of the address book "
"example from chapter 3. This time, we will extend our address book data "
"types, and write functions to validate values for those types. The "
"understanding is that these functions could be used, for example in a web "
"user interface, to display errors to the user as part of a data entry form."
msgstr ""
"この章では第3章に引き続き住所録を例として扱います。\n"
"今回は住所録のデータ型を拡張し、これらの型の値を検証する関数を書きます。\n"
"これらの関数は、例えばデータ入力フォームの一部で、使用者へエラーを表示するwebユーザインターフェースで使われると考えてください。"

#. type: Plain text
#: text/chapter7.md:14
msgid ""
"The source code for this chapter is defined in the files `src/Data/"
"AddressBook.purs` and `src/Data/AddressBook/Validation.purs`."
msgstr ""
"この章のソースコードは、2つのファイル`src/Data/AddressBook.purs`、及び`src/"
"Data/AddressBook/Validation.purs`で定義されています。"

#. type: Plain text
#: text/chapter7.md:16
msgid ""
"The project has a number of dependencies, many of which we have seen before. "
"There are two new dependencies:"
msgstr ""
"このプロジェクトには多くの依存関係がありますが、その大半は既に見てきたもので"
"す。\n"
"新しい依存関係は2つです。"

#. type: Bullet: '- '
#: text/chapter7.md:19
msgid ""
"`control`, which defines functions for abstracting control flow using type "
"classes like `Applicative`."
msgstr ""
"`control` - `Applicative`のような、型クラスを使用して制御フローを抽象化する関"
"数が定義されています。"

#. type: Bullet: '- '
#: text/chapter7.md:19
msgid ""
"`validation`, which defines a functor for _applicative validation_, the "
"subject of this chapter."
msgstr ""
"`validation` - この章の主題である _アプリカティブによる検証_ のための関手が定"
"義されています。"

#. type: Plain text
#: text/chapter7.md:21
msgid ""
"The `Data.AddressBook` module defines data types and `Show` instances for "
"the types in our project, and the `Data.AddressBook.Validation` module "
"contains validation rules for those types."
msgstr ""
"`Data.AddressBook`モジュールには、このプロジェクトのデータ型とそれらの型に対"
"する`Show`インスタンスが定義されており、`Data.AddressBook.Validation`モジュー"
"ルにはそれらの型の検証規則が含まれています。"

#. type: Title ##
#: text/chapter7.md:22
#, no-wrap
msgid "Generalizing Function Application"
msgstr "関数適用の一般化"

#. type: Plain text
#: text/chapter7.md:25
msgid ""
"To explain the concept of an _applicative functor_, let's consider the type "
"constructor `Maybe` that we met earlier."
msgstr ""
"_アプリカティブ関手_ の概念を理解するために、以前扱った型構築子`Maybe`につい"
"て考えてみましょう。"

#. type: Plain text
#: text/chapter7.md:27
msgid ""
"The source code for this module defines a function `address` which has the "
"following type:"
msgstr ""
"このモジュールのソースコードでは、次のような型を持つ`address`関数が定義されて"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:28
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"

#. type: Plain text
#: text/chapter7.md:33
msgid ""
"This function is used to construct a value of type `Address` from three "
"strings: a street name, a city, and a state."
msgstr ""
"この関数は、通りの名前、市、州という3つの文字列から型`Address`の値を構築する"
"ために使います。"

#. type: Plain text
#: text/chapter7.md:35
msgid "We can apply this function easily and see the result in PSCi:"
msgstr "この関数は簡単に適用できますので、PSCiでどうなるか見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:36
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> address \"123 Fake St.\" \"Faketown\" \"CA\"\n"
"{ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
msgstr ""
"> import Data.AddressBook\n"
"\n"
"> address \"123 Fake St.\" \"Faketown\" \"CA\"\n"
"{ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"

#. type: Plain text
#: text/chapter7.md:44
msgid ""
"However, suppose we did not necessarily have a street, city, or state, and "
"wanted to use the `Maybe` type to indicate a missing value in each of the "
"three cases."
msgstr ""
"しかし、通り、市、州の3つ全てが必ずしも入力されないものとすると、3つの場合が"
"それぞれ省略可能であることを示すために`Maybe`型を使用したくなります。"

#. type: Plain text
#: text/chapter7.md:46
msgid ""
"In one case, we might have a missing city. If we try to apply our function "
"directly, we will receive an error from the type checker:"
msgstr ""
"考えられる場合としては、市が省略されている場合があるでしょう。\n"
"もし`address`関数を直接適用しようとすると、型検証器からエラーが表示されます。"

#. type: Fenced code block (text)
#: text/chapter7.md:47
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"> address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Could not match type\n"
"\n"
"  Maybe String\n"
"\n"
"with type\n"
"\n"
"  String\n"
msgstr ""
"> import Data.Maybe\n"
"> address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Could not match type\n"
"\n"
"  Maybe String\n"
"\n"
"with type\n"
"\n"
"  String\n"

#. type: Plain text
#: text/chapter7.md:61
msgid ""
"Of course, this is an expected type error - `address` takes strings as "
"arguments, not values of type `Maybe String`."
msgstr ""
"`address`は`Maybe String`型ではなく文字列型の引数を取るので、もちろんこれは期"
"待通り型エラーになります。"

#. type: Plain text
#: text/chapter7.md:63
msgid ""
"However, it is reasonable to expect that we should be able to \"lift\" the "
"`address` function to work with optional values described by the `Maybe` "
"type. In fact, we can, and the `Control.Apply` provides the function `lift3` "
"function which does exactly what we need:"
msgstr ""
"しかし、もし`address`関数を「持ち上げる」ことができれば、`Maybe`型で示される"
"省略可能な値を扱うことができるはずだという予想は理に適っています。実際それは"
"可能で、`Control.Apply`で提供されている関数`lift3`が、まさに求めているもので"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:64
#, no-wrap
msgid ""
"> import Control.Apply\n"
"> lift3 address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Nothing\n"
msgstr ""
"> import Control.Apply\n"
"> lift3 address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:72
msgid ""
"In this case, the result is `Nothing`, because one of the arguments (the "
"city) was missing. If we provide all three arguments using the `Just` "
"constructor, then the result will contain a value as well:"
msgstr ""
"このとき、引数の1つ（市）が欠落していたので、結果は`Nothing`になります。\n"
"もし3つの引数全てに`Just`構築子を使ったものが与えられたら、結果は値を含むこと"
"になります。"

#. type: Fenced code block (text)
#: text/chapter7.md:73
#, no-wrap
msgid ""
"> lift3 address (Just \"123 Fake St.\") (Just \"Faketown\") (Just \"CA\")\n"
"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
msgstr ""
"> lift3 address (Just \"123 Fake St.\") (Just \"Faketown\") (Just \"CA\")\n"
"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"

#. type: Plain text
#: text/chapter7.md:80
msgid ""
"The name of the function `lift3` indicates that it can be used to lift "
"functions of 3 arguments. There are similar functions defined in `Control."
"Apply` for functions of other numbers of arguments."
msgstr ""
"`lift3`という関数の名前は、3引数の関数を持ち上げるために使えることを示してい"
"ます。関数を持ち上げる同様の関数で、引数の数が異なるものが`Control.Apply`で定"
"義されています。"

#. type: Title ##
#: text/chapter7.md:81
#, no-wrap
msgid "Lifting Arbitrary Functions"
msgstr "任意個の引数を持つ関数の持ち上げ"

#. type: Plain text
#: text/chapter7.md:84
msgid ""
"So, we can lift functions with small numbers of arguments by using `lift2`, "
"`lift3`, etc. But how can we generalize this to arbitrary functions?"
msgstr ""
"これで、`lift2`や`lift3`のような関数を使えば、引数が2個や3個の関数を持ち上げ"
"ることができるのはわかりました。\n"
"でも、これを任意個の引数の関数へと一般化できるのでしょうか。"

#. type: Plain text
#: text/chapter7.md:86
msgid "It is instructive to look at the type of `lift3`:"
msgstr "`lift3`の型を見てみるとわかりやすいでしょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:87
#, no-wrap
msgid ""
"> :type lift3\n"
"forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
msgstr ""
"> :type lift3\n"
"forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"

#. type: Plain text
#: text/chapter7.md:93
msgid ""
"In the `Maybe` example above, the type constructor `f` is `Maybe`, so that "
"`lift3` is specialized to the following type:"
msgstr ""
"上の`Maybe`の例では型構築子`f`は`Maybe`ですから、`lift3`は次のように特殊化さ"
"れます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:94
#, no-wrap
msgid "forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
msgstr "forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"

#. type: Plain text
#: text/chapter7.md:99
msgid ""
"This type says that we can take any function with three arguments, and lift "
"it to give a new function whose argument and result types are wrapped with "
"`Maybe`."
msgstr ""
"この型が言っているのは、3引数の任意の関数を取り、その関数を引数と返り値が"
"`Maybe`で包まれた新しい関数へと持ち上げる、ということです。"

#. type: Plain text
#: text/chapter7.md:101
msgid ""
"Certainly, this is not possible for every type constructor `f`, so what is "
"it about the `Maybe` type which allowed us to do this? Well, in specializing "
"the type above, we removed a type class constraint on `f` from the `Apply` "
"type class. `Apply` is defined in the Prelude as follows:"
msgstr ""
"もちろんどんな型構築子`f`についても持ち上げができるわけではないのですが、それ"
"では`Maybe`型を持ち上げができるようにしているものは何なのでしょうか。\n"
"さて、先ほどの型の特殊化では、`f`に対する型クラス制約から`Apply`型クラスを取"
"り除いていました。\n"
"`Apply`はPreludeで次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:102
#, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
"\n"
"class Functor f <= Apply f where\n"
"  apply :: forall a b. f (a -> b) -> f a -> f b\n"
msgstr ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
"\n"
"class Functor f <= Apply f where\n"
"  apply :: forall a b. f (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter7.md:111
#, no-wrap
msgid "The `Apply` type class is a subclass of `Functor`, and defines an additional function `apply`. As `<$>` was defined as an alias for `map`, the `Prelude` module defines `<*>` as an alias for `apply`. As we'll see, these two operators are often used together.\n"
msgstr "`Apply`型クラスは`Functor`の下位クラスであり、追加の関数`apply`を定義しています。`<$>`が`map`の別名として定義されているように、`Prelude`モジュールでは`<*>`を`apply`の別名として定義しています。これから見ていきますが、これら2つの演算子はよく一緒に使われます。\n"

#. type: Plain text
#: text/chapter7.md:113
msgid ""
"Note that this [`apply`](https://pursuit.purescript.org/packages/purescript-"
"prelude/docs/Control.Apply#v:apply) is different than the [`apply`](https://"
"pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:"
"apply) from `Data.Function` (infixed as `$`). Luckily, infix notation is "
"almost always used for the latter, so you don't need to worry about name "
"collisions."
msgstr ""
"なおこの[`apply`](https://pursuit.purescript.org/packages/purescript-prelude/"
"docs/Control.Apply#v:apply)は`Data.Function`の[`apply`](https://pursuit."
"purescript.org/packages/purescript-prelude/docs/Data.Function#v:apply)（中置"
"で`$`）とは異なります。幸いにも後者はほぼ常に中置記法として使われるので、名前"
"の衝突については心配ご無用です。"

#. type: Plain text
#: text/chapter7.md:115
msgid ""
"The type of `apply` looks a lot like the type of `map`. The difference "
"between `map` and `apply` is that `map` takes a function as an argument, "
"whereas the first argument to `apply` is wrapped in the type constructor "
"`f`. We'll see how this is used soon, but first, let's see how to implement "
"the `Apply` type class for the `Maybe` type:"
msgstr ""
"`apply`の型は`map`の型と実によく似ています。\n"
"`map`と`apply`の違いは、`map`がただの関数を引数に取るのに対し、`apply`の最初"
"の引数は型構築子`f`で包まれているという点です。\n"
"これをどのように使うのかはこれからすぐに見ていきますが、その前にまず`Maybe`型"
"について`Apply`型クラスをどう実装するのかを見ていきましょう。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:116
#, no-wrap
msgid ""
"instance functorMaybe :: Functor Maybe where\n"
"  map f (Just a) = Just (f a)\n"
"  map f Nothing  = Nothing\n"
"\n"
"instance applyMaybe :: Apply Maybe where\n"
"  apply (Just f) (Just x) = Just (f x)\n"
"  apply _        _        = Nothing\n"
msgstr ""
"instance functorMaybe :: Functor Maybe where\n"
"  map f (Just a) = Just (f a)\n"
"  map f Nothing  = Nothing\n"
"\n"
"instance applyMaybe :: Apply Maybe where\n"
"  apply (Just f) (Just x) = Just (f x)\n"
"  apply _        _        = Nothing\n"

#. type: Plain text
#: text/chapter7.md:127
msgid ""
"This type class instance says that we can apply an optional function to an "
"optional value, and the result is defined only if both are defined."
msgstr ""
"この型クラスのインスタンスで書かれているのは、任意のオプショナルな値にオプ"
"ショナルな関数を適用でき、その両方が定義されている時に限り結果も定義される、"
"ということです。"

#. type: Plain text
#: text/chapter7.md:129
msgid ""
"Now we'll see how `map` and `apply` can be used together to lift functions "
"of arbitrary number of arguments."
msgstr ""
"それでは、`map`と`apply`を一緒に使い、引数が任意個の関数を持ち上げる方法を見"
"ていきましょう。"

#. type: Plain text
#: text/chapter7.md:131
msgid "For functions of one argument, we can just use `map` directly."
msgstr "1引数の関数については、`map`をそのまま使うだけです。"

#. type: Plain text
#: text/chapter7.md:133
#, no-wrap
msgid "For functions of two arguments, we have a curried function `g` with type `a -> b -> c`, say. This is equivalent to the type `a -> (b -> c)`, so we can apply `map` to `g` to get a new function of type `f a -> f (b -> c)` for any type constructor `f` with a `Functor` instance. Partially applying this function to the first lifted argument (of type `f a`), we get a new wrapped function of type `f (b -> c)`. If we also have an `Apply` instance for `f`, we can then use `apply` to apply the second lifted argument (of type `f b`) to get our final value of type `f c`.\n"
msgstr "2引数関数については、型`a -> b -> c`のカリー化された関数`g`があるとします。これは型`a -> (b -> c)`と同じですから、`Functor`インスタンス付きのあらゆる型構築子`f`について、`map`を`f`に適用すると型`f a -> f (b -> c)`の新たな関数を得ることになります。持ち上げられた（型`f a`の）最初の引数にその関数を部分適用すると、型`f (b -> c)`の新たな包まれた関数が得られます。`f`に`Apply`インスタンスもあるなら、そこから、2番目の持ち上げられた（型`f b`の）引数へ`apply`を適用でき、型`f c`の最終的な値を得ます。\n"

#. type: Plain text
#: text/chapter7.md:135
#, no-wrap
msgid "Putting this all together, we see that if we have values `x :: f a` and `y :: f b`, then the expression `(g <$> x) <*> y` has type `f c` (remember, this expression is equivalent to `apply (map g x) y`). The precedence rules defined in the Prelude allow us to remove the parentheses: `g <$> x <*> y`.\n"
msgstr "纏めると、`x :: f a`と`y :: f b`があるとき、式`(g <$> x) <*> y`の型は`f c`になります（この式は`apply (map g x)  y`と同じ意味だということを思い出しましょう）。Preludeで定義された優先順位の規則に従うと、`g <$> x <*> y`というように括弧を外すことができます。\n"

#. type: Plain text
#: text/chapter7.md:137
#, no-wrap
msgid "In general, we can use `<$>` on the first argument, and `<*>` for the remaining arguments, as illustrated here for `lift3`:\n"
msgstr "一般的には、最初の引数に`<$>`を使い、残りの引数に対しては`<*>`を使います。`lift3`で説明すると次のようになります。\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:138
#, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z\n"
msgstr ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z\n"

#. type: Plain text
#: text/chapter7.md:150
msgid ""
"It is left as an exercise for the reader to verify the types involved in "
"this expression."
msgstr ""
"この式の型がちゃんと整合しているかの確認は、読者への演習として残しておきま"
"す。"

#. type: Plain text
#: text/chapter7.md:152
#, no-wrap
msgid "As an example, we can try lifting the address function over `Maybe`, directly using the `<$>` and `<*>` functions:\n"
msgstr "例として、`<$>`と`<*>`をそのまま使うと、`Maybe`上に`address`関数を持ち上げることができます。\n"

#. type: Fenced code block (text)
#: text/chapter7.md:153
#, no-wrap
msgid ""
"> address <$> Just \"123 Fake St.\" <*> Just \"Faketown\" <*> Just \"CA\"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
"\n"
"> address <$> Just \"123 Fake St.\" <*> Nothing <*> Just \"CA\"\n"
"Nothing\n"
msgstr ""
"> address <$> Just \"123 Fake St.\" <*> Just \"Faketown\" <*> Just \"CA\"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
"\n"
"> address <$> Just \"123 Fake St.\" <*> Nothing <*> Just \"CA\"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:162
msgid ""
"Try lifting some other functions of various numbers of arguments over "
"`Maybe` in this way."
msgstr ""
"同様にして、引数が異なる他のいろいろな関数を`Maybe`上に持ち上げてみてくださ"
"い。"

#. type: Plain text
#: text/chapter7.md:164
msgid ""
"Alternatively _applicative do notation_ can be used for the same purpose in "
"a way that looks similar to the familiar _do notation_. Here is `lift3` "
"using _applicative do notation_. Note `ado` is used instead of `do`, and "
"`in` is used on the final line to denote the yielded value:"
msgstr ""
"この代わりにお馴染の _do記法_ に似た見た目の _アプリカティブdo記法_ が同じ目"
"的で使えます。以下では`lift3`に _アプリカティブdo記法_ を使っています。なお、"
"`ado`が`do`の代わりに使われており、生み出された値を示すために最後の行で`in`が"
"使われています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:165
#, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = ado\n"
"  a <- x\n"
"  b <- y\n"
"  c <- z\n"
"  in f a b c\n"
msgstr ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = ado\n"
"  a <- x\n"
"  b <- y\n"
"  c <- z\n"
"  in f a b c\n"

#. type: Title ##
#: text/chapter7.md:180
#, no-wrap
msgid "The Applicative Type Class"
msgstr "アプリカティブ型クラス"

#. type: Plain text
#: text/chapter7.md:183
msgid "There is a related type class called `Applicative`, defined as follows:"
msgstr ""
"関連する`Applicative`という型クラスが存在しており、次のように定義されていま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:184
#, no-wrap
msgid ""
"class Apply f <= Applicative f where\n"
"  pure :: forall a. a -> f a\n"
msgstr ""
"class Apply f <= Applicative f where\n"
"  pure :: forall a. a -> f a\n"

#. type: Plain text
#: text/chapter7.md:190
msgid ""
"`Applicative` is a subclass of `Apply` and defines the `pure` function. "
"`pure` takes a value and returns a value whose type has been wrapped with "
"the type constructor `f`."
msgstr ""
"`Applicative`は`Apply`の下位クラスであり、`pure`関数が定義されています。\n"
"`pure`は値を取り、その型の型構築子`f`で包まれた値を返します。"

#. type: Plain text
#: text/chapter7.md:192
msgid "Here is the `Applicative` instance for `Maybe`:"
msgstr "`Maybe`についての`Applicative`インスタンスは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:193
#, no-wrap
msgid ""
"instance applicativeMaybe :: Applicative Maybe where\n"
"  pure x = Just x\n"
msgstr ""
"instance applicativeMaybe :: Applicative Maybe where\n"
"  pure x = Just x\n"

#. type: Plain text
#: text/chapter7.md:199
msgid ""
"If we think of applicative functors as functors which allow lifting of "
"functions, then `pure` can be thought of as lifting functions of zero "
"arguments."
msgstr ""
"アプリカティブ関手は関数を持ち上げることを可能にする関手だと考えるとすると、"
"`pure`は引数のない関数の持ち上げだというように考えることができます。"

#. type: Title ##
#: text/chapter7.md:200
#, no-wrap
msgid "Intuition for Applicative"
msgstr "アプリカティブに対する直感的理解"

#. type: Plain text
#: text/chapter7.md:203
msgid ""
"Functions in PureScript are pure and do not support side-effects. "
"Applicative functors allow us to work in larger \"programming languages\" "
"which support some sort of side-effect encoded by the functor `f`."
msgstr ""
"PureScriptの関数は純粋であり、副作用は持っていません。Applicative関手は、関手"
"`f`によって表現されるある種の副作用を提供するような、より大きな「プログラミン"
"グ言語」を扱えるようにします。"

#. type: Plain text
#: text/chapter7.md:205
#, no-wrap
msgid "As an example, the functor `Maybe` represents the side effect of possibly-missing values. Some other examples include `Either err`, which represents the side effect of possible errors of type `err`, and the arrow functor `r ->` which represents the side-effect of reading from a global configuration. For now, we'll only consider the `Maybe` functor.\n"
msgstr ""
"例えば関手`Maybe`はオプショナルな値の副作用を表現しています。\n"
"その他の例としては、型`err`のエラーの可能性の副作用を表す`Either err`や、大域的な構成を読み取る副作用を表すArrow関手 (arrow functor) `r ->`があります。\n"
"ここでは`Maybe`関手についてのみ考えることにします。\n"

#. type: Plain text
#: text/chapter7.md:207
msgid ""
"If the functor `f` represents this larger programming language with effects, "
"then the `Apply` and `Applicative` instances allow us to lift values and "
"function applications from our smaller programming language (PureScript) "
"into the new language."
msgstr ""
"もし関手`f`が作用を持つ、より大きなプログラミング言語を表すとすると、`Apply`"
"と`Applicative`インスタンスは小さなプログラミング言語 (PureScript) から新しい"
"大きな言語へと値や関数を持ち上げることを可能にします。"

#. type: Plain text
#: text/chapter7.md:209
msgid ""
"`pure` lifts pure (side-effect free) values into the larger language, and "
"for functions, we can use `map` and `apply` as described above."
msgstr ""
"`pure`は純粋な（副作用がない）値をより大きな言語へと持ち上げますし、関数につ"
"いては上で述べた通り`map`と`apply`を使うことができます。"

#. type: Plain text
#: text/chapter7.md:211
msgid ""
"This raises a question: if we can use `Applicative` to embed PureScript "
"functions and values into this new language, then how is the new language "
"any larger? The answer depends on the functor `f`. If we can find "
"expressions of type `f a` which cannot be expressed as `pure x` for some "
"`x`, then that expression represents a term which only exists in the larger "
"language."
msgstr ""
"ここで疑問が生まれます。\n"
"もしPureScriptの関数と値を新たな言語へ埋め込むのに`Applicative`が使えるなら、"
"どうやって新たな言語は大きくなっているというのでしょうか。\n"
"この答えは関手`f`に依存します。\n"
"もしなんらかの`x`について`pure x`で表せないような型`f a`の式を見つけたなら、"
"その式はそのより大きな言語だけに存在する項を表しているということです。"

#. type: Plain text
#: text/chapter7.md:213
msgid ""
"When `f` is `Maybe`, an example is the expression `Nothing`: we cannot write "
"`Nothing` as `pure x` for any `x`. Therefore, we can think of PureScript as "
"having been enlarged to include the new term `Nothing`, which represents a "
"missing value."
msgstr ""
"`f`が`Maybe`のときは、式`Nothing`がその例になっています。\n"
"どんな`x`があっても`Nothing`を`pure x`というように書くことはできません。\n"
"したがって、PureScriptは値の欠落を表す新しい項`Nothing`を含むように拡大された"
"と考えることができます。"

#. type: Title ##
#: text/chapter7.md:214
#, no-wrap
msgid "More Effects"
msgstr "もっと作用を"

#. type: Plain text
#: text/chapter7.md:217
msgid ""
"Let's see some more examples of lifting functions over different "
"`Applicative` functors."
msgstr ""
"様々な`Applicative`関手へと関数を持ち上げる例をもっと見ていきましょう。"

#. type: Plain text
#: text/chapter7.md:219
msgid ""
"Here is a simple example function defined in PSCi, which joins three names "
"to form a full name:"
msgstr ""
"以下は、PSCiで定義された3つの名前を結合して完全な名前を作る簡単な関数の例で"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:220
#, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> fullName first middle last = last <> \", \" <> first <> \" \" <> middle\n"
"\n"
"> fullName \"Phillip\" \"A\" \"Freeman\"\n"
"Freeman, Phillip A\n"
msgstr ""
"> import Prelude\n"
"\n"
"> fullName first middle last = last <> \", \" <> first <> \" \" <> middle\n"
"\n"
"> fullName \"Phillip\" \"A\" \"Freeman\"\n"
"Freeman, Phillip A\n"

#. type: Plain text
#: text/chapter7.md:230
msgid ""
"Now suppose that this function forms the implementation of a (very simple!) "
"web service with the three arguments provided as query parameters. We want "
"to make sure that the user provided each of the three parameters, so we "
"might use the `Maybe` type to indicate the presence or otherwise absence of "
"a parameter. We can lift `fullName` over `Maybe` to create an implementation "
"of the web service which checks for missing parameters:"
msgstr ""
"この関数は、クエリパラメータとして与えられた3つの引数を持つ、（とっても簡単"
"な）webサービスの実装であるとしましょう。\n"
"使用者が3つの引数全てを与えたことを確かめたいので、引数が存在するかどうかを表"
"す`Maybe`型を使うことになるでしょう。\n"
"`fullName`を`Maybe`の上へ持ち上げると、省略された引数を確認するwebサービスを"
"実装できます。"

#. type: Fenced code block (text)
#: text/chapter7.md:231
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"
msgstr ""
"> import Data.Maybe\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:242 text/chapter7.md:292 text/chapter7.md:444
#: text/chapter7.md:479 text/chapter7.md:525 text/chapter7.md:557
msgid "or with _applicative do_"
msgstr "または*アプリカティブdo*で次のようにします。"

#. type: Fenced code block (text)
#: text/chapter7.md:243
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> :paste…\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Just \"A\"\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"(Just \"Freeman, Phillip A\")\n"
"\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Nothing\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"Nothing\n"
msgstr ""
"> import Data.Maybe\n"
"\n"
"> :paste…\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Just \"A\"\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"(Just \"Freeman, Phillip A\")\n"
"\n"
"… ado\n"
"…   f <- Just \"Phillip\"\n"
"…   m <- Nothing\n"
"…   l <- Just \"Freeman\"\n"
"…   in fullName f m l\n"
"… ^D\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:265
msgid ""
"Note that the lifted function returns `Nothing` if any of the arguments was "
"`Nothing`."
msgstr ""
"この持ち上げた関数は、引数の何れかが`Nothing`なら`Nothing`を返すことに注意し"
"てください。"

#. type: Plain text
#: text/chapter7.md:267
msgid ""
"This is good, because now we can send an error response back from our web "
"service if the parameters are invalid. However, it would be better if we "
"could indicate which field was incorrect in the response."
msgstr ""
"これで、もし引数が不正ならWebサービスからエラー応答を送信できるので、なかなか"
"いい感じです。\n"
"しかし、どのフィールドが間違っていたのかを応答で示せると、もっと良くなるで"
"しょう。"

#. type: Plain text
#: text/chapter7.md:269
msgid ""
"Instead of lifting over `Maybe`, we can lift over `Either String`, which "
"allows us to return an error message. First, let's write an operator to "
"convert optional inputs into computations which can signal an error using "
"`Either String`:"
msgstr ""
"`Meybe`上へ持ち上げる代わりに`Either String`上へ持ち上げるようにすると、エ"
"ラーメッセージを返すことができるようになります。\n"
"まずは`Either String`を使ってオプショナルな入力をエラーを発信できる計算に変換"
"する演算子を書きましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:270
#, no-wrap
msgid ""
"> import Data.Either\n"
"> :paste\n"
"… withError Nothing  err = Left err\n"
"… withError (Just a) _   = Right a\n"
"… ^D\n"
msgstr ""
"> import Data.Either\n"
"> :paste\n"
"… withError Nothing  err = Left err\n"
"… withError (Just a) _   = Right a\n"
"… ^D\n"

#. type: Plain text
#: text/chapter7.md:279
msgid ""
"_Note_: In the `Either err` applicative functor, the `Left` constructor "
"indicates an error, and the `Right` constructor indicates success."
msgstr ""
"*補足*：`Either err`アプリカティブ関手において、`Left`構築子は失敗を表してお"
"り、`Right`構築子は成功を表しています。"

#. type: Plain text
#: text/chapter7.md:281
msgid ""
"Now we can lift over `Either String`, providing an appropriate error message "
"for each parameter:"
msgstr ""
"これで`Either String`上へ持ち上げることで、それぞれの引数について適切なエラー"
"メッセージを提供できるようになります。"

#. type: Fenced code block (text)
#: text/chapter7.md:282
#, no-wrap
msgid ""
"> :paste\n"
"… fullNameEither first middle last =\n"
"…   fullName <$> (first  `withError` \"First name was missing\")\n"
"…            <*> (middle `withError` \"Middle name was missing\")\n"
"…            <*> (last   `withError` \"Last name was missing\")\n"
"… ^D\n"
msgstr ""
"> :paste\n"
"… fullNameEither first middle last =\n"
"…   fullName <$> (first  `withError` \"First name was missing\")\n"
"…            <*> (middle `withError` \"Middle name was missing\")\n"
"…            <*> (last   `withError` \"Last name was missing\")\n"
"… ^D\n"

#. type: Fenced code block (text)
#: text/chapter7.md:293
#, no-wrap
msgid ""
"> :paste\n"
"… fullNameEither first middle last = ado\n"
"…  f <- first  `withError` \"First name was missing\"\n"
"…  m <- middle `withError` \"Middle name was missing\"\n"
"…  l <- last   `withError` \"Last name was missing\"\n"
"…  in fullName f m l\n"
"… ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"
msgstr ""
"> :paste\n"
"… fullNameEither first middle last = ado\n"
"…  f <- first  `withError` \"First name was missing\"\n"
"…  m <- middle `withError` \"Middle name was missing\"\n"
"…  l <- last   `withError` \"Last name was missing\"\n"
"…  in fullName f m l\n"
"… ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"

#. type: Plain text
#: text/chapter7.md:307
msgid ""
"Now our function takes three optional arguments using `Maybe`, and returns "
"either a `String` error message or a `String` result."
msgstr ""
"これでこの関数は`Maybe`の3つの省略可能な引数を取り、`String`のエラーメッセー"
"ジか`String`の結果のどちらかを返します。"

#. type: Plain text
#: text/chapter7.md:309
msgid "We can try out the function with different inputs:"
msgstr "いろいろな入力でこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:310
#, no-wrap
msgid ""
"> fullNameEither (Just \"Phillip\") (Just \"A\") (Just \"Freeman\")\n"
"(Right \"Freeman, Phillip A\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") Nothing (Just \"Freeman\")\n"
"(Left \"Middle name was missing\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") (Just \"A\") Nothing\n"
"(Left \"Last name was missing\")\n"
msgstr ""
"> fullNameEither (Just \"Phillip\") (Just \"A\") (Just \"Freeman\")\n"
"(Right \"Freeman, Phillip A\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") Nothing (Just \"Freeman\")\n"
"(Left \"Middle name was missing\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") (Just \"A\") Nothing\n"
"(Left \"Last name was missing\")\n"

#. type: Plain text
#: text/chapter7.md:322
msgid ""
"In this case, we see the error message corresponding to the first missing "
"field, or a successful result if every field was provided. However, if we "
"are missing multiple inputs, we still only see the first error:"
msgstr ""
"このとき、全てのフィールドが与えられば成功の結果が表示され、そうでなければ省"
"略されたフィールドのうち最初のものに対応するエラーメッセージが表示されま"
"す。\n"
"しかし、もし複数の入力が省略されているとき、最初のエラーしか見ることができま"
"せん。"

#. type: Fenced code block (text)
#: text/chapter7.md:323
#, no-wrap
msgid ""
"> fullNameEither Nothing Nothing Nothing\n"
"(Left \"First name was missing\")\n"
msgstr ""
"> fullNameEither Nothing Nothing Nothing\n"
"(Left \"First name was missing\")\n"

#. type: Plain text
#: text/chapter7.md:329
msgid ""
"This might be good enough, but if we want to see a list of _all_ missing "
"fields in the error, then we need something more powerful than `Either "
"String`. We will see a solution later in this chapter."
msgstr ""
"これでも充分なときもありますが、エラー時に*全ての*省略されたフィールドの一覧"
"がほしいときは、`Either String`よりも強力なものが必要です。この章の後半で解決"
"策を見ていきます。"

#. type: Title ##
#: text/chapter7.md:330
#, no-wrap
msgid "Combining Effects"
msgstr "作用の結合"

#. type: Plain text
#: text/chapter7.md:333
msgid ""
"As an example of working with applicative functors abstractly, this section "
"will show how to write a function which will generically combine side-"
"effects encoded by an applicative functor `f`."
msgstr ""
"抽象的にアプリカティブ関手を扱う例として、アプリカティブ関手`f`によって表現さ"
"れた副作用を一般的に組み合わせる関数を書く方法をこの節では示します。"

#. type: Plain text
#: text/chapter7.md:335
msgid ""
"What does this mean? Well, suppose we have a list of wrapped arguments of "
"type `f a` for some `a`. That is, suppose we have a list of type `List (f "
"a)`. Intuitively, this represents a list of computations with side-effects "
"tracked by `f`, each with return type `a`. If we could run all of these "
"computations in order, we would obtain a list of results of type `List a`. "
"However, we would still have side-effects tracked by `f`. That is, we expect "
"to be able to turn something of type `List (f a)` into something of type `f "
"(List a)` by \"combining\" the effects inside the original list."
msgstr ""
"これはどういう意味でしょうか。\n"
"何らかの`a`について型`f a`で包まれた引数のリストがあるとしましょう。\n"
"それは型`List (f a)`のリストがあるということです。\n"
"直感的には、これは`f`によって追跡される副作用を持つ、返り値の型が`a`の計算の"
"リストを表しています。\n"
"これらの計算の全てを順番に実行できれば、`List a`型の結果のリストを得るでしょ"
"う。\n"
"しかし、まだ`f`によって追跡される副作用が残ります。\n"
"つまり、元のリストの中の作用を「結合する」ことにより、型`List (f a)`の何かを"
"型`f (List a)`の何かへと変換できると考えられます。"

#. type: Plain text
#: text/chapter7.md:337
#, no-wrap
msgid "For any fixed list size `n`, there is a function of `n` arguments which builds a list of size `n` out of those arguments. For example, if `n` is `3`, the function is `\\x y z -> x : y : z : Nil`. This function has type `a -> a -> a -> List a`. We can use the `Applicative` instance for `List` to lift this function over `f`, to get a function of type `f a -> f a -> f a -> f (List a)`. But, since we can do this for any `n`, it makes sense that we should be able to perform the same lifting for any _list_ of arguments.\n"
msgstr ""
"任意の固定長リストの長さ`n`について、その引数を要素に持った長さ`n`のリストを構築するような`n`引数の関数が存在します。\n"
"例えばもし`n`が`3`なら、関数は`\\x y z -> x : y : z : Nil`です。\n"
"この関数の型は`a -> a -> a -> List a`です。\n"
"`Applicative`インスタンスを使うと、この関数を`f`の上へ持ち上げて関数型`f a -> f a -> f a -> f (List a)`を得ることができます。\n"
"しかし、いかなる`n`についてもこれが可能なので、いかなる引数の*リスト*についても同じように持ち上げられることが確かめられます。\n"

#. type: Plain text
#: text/chapter7.md:339
msgid "That means that we should be able to write a function"
msgstr "したがって、次のような関数を書くことができるはずです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:340 text/chapter7.md:602
#, no-wrap
msgid "combineList :: forall f a. Applicative f => List (f a) -> f (List a)\n"
msgstr "combineList :: forall f a. Applicative f => List (f a) -> f (List a)\n"

#. type: Plain text
#: text/chapter7.md:345
msgid ""
"This function will take a list of arguments, which possibly have side-"
"effects, and return a single wrapped list, applying the side-effects of each."
msgstr ""
"この関数は副作用を持つかもしれない引数のリストを取り、それぞれの副作用を適用"
"することで、`f`に包まれた単一のリストを返します。"

#. type: Plain text
#: text/chapter7.md:347
msgid ""
"To write this function, we'll consider the length of the list of arguments. "
"If the list is empty, then we do not need to perform any effects, and we can "
"use `pure` to simply return an empty list:"
msgstr ""
"この関数を書くためには、引数のリストの長さについて考えます。\n"
"リストが空の場合はどんな作用も実行する必要がありませんから、`pure`を使用して"
"単に空のリストを返すことができます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:348
#, no-wrap
msgid "combineList Nil = pure Nil\n"
msgstr "combineList Nil = pure Nil\n"

#. type: Plain text
#: text/chapter7.md:353
msgid "In fact, this is the only thing we can do!"
msgstr "実際のところこれがたった1つのできることです。"

#. type: Plain text
#: text/chapter7.md:355
#, no-wrap
msgid "If the list is non-empty, then we have a head element, which is a wrapped argument of type `f a`, and a tail of type `List (f a)`. We can recursively combine the effects in the tail, giving a result of type `f (List a)`. We can then use `<$>` and `<*>` to lift the `Cons` constructor over the head and new tail:\n"
msgstr ""
"入力のリストが空でないならば、型`f a`の包まれた引数である先頭要素と、型`List (f a)`の尾鰭について考えます。\n"
"また、再帰的にリストの残りを結合すると、型`f (List a)`の結果が得られます。\n"
"それから`<$>`と`<*>`を使うと、`Cons`構築子を先頭と新しい尾鰭の上に持ち上げることができます。\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:356
#, no-wrap
msgid "combineList (Cons x xs) = Cons <$> x <*> combineList xs\n"
msgstr "combineList (Cons x xs) = Cons <$> x <*> combineList xs\n"

#. type: Plain text
#: text/chapter7.md:361
msgid ""
"Again, this was the only sensible implementation, based on the types we were "
"given."
msgstr ""
"繰り返しになりますが、これは与えられた型に基づいている唯一の妥当な実装です。"

#. type: Plain text
#: text/chapter7.md:363
msgid ""
"We can test this function in PSCi, using the `Maybe` type constructor as an "
"example:"
msgstr "`Maybe`型構築子を例にとって、PSCiでこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:364
#, no-wrap
msgid ""
"> import Data.List\n"
"> import Data.Maybe\n"
"\n"
"> combineList (fromFoldable [Just 1, Just 2, Just 3])\n"
"(Just (Cons 1 (Cons 2 (Cons 3 Nil))))\n"
"\n"
"> combineList (fromFoldable [Just 1, Nothing, Just 2])\n"
"Nothing\n"
msgstr ""
"> import Data.List\n"
"> import Data.Maybe\n"
"\n"
"> combineList (fromFoldable [Just 1, Just 2, Just 3])\n"
"(Just (Cons 1 (Cons 2 (Cons 3 Nil))))\n"
"\n"
"> combineList (fromFoldable [Just 1, Nothing, Just 2])\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:376
msgid ""
"When specialized to `Maybe`, our function returns a `Just` only if every "
"list element was `Just`, otherwise it returns `Nothing`. This is consistent "
"with our intuition of working in a larger language supporting optional "
"values - a list of computations which return optional results only has a "
"result itself if every computation contained a result."
msgstr ""
"`Meybe`へ特殊化して考えると、リストの全ての要素が`Just`であるときに限りこの関"
"数は`Just`を返しますし、そうでなければ`Nothing`を返します。\n"
"これはオプショナルな値に対応する、より大きな言語に取り組む上での直感から一貫"
"しています。\n"
"オプショナルな結果を返す計算のリストは、全ての計算が結果を持っているならばそ"
"れ自身の結果のみを持つのです。"

#. type: Plain text
#: text/chapter7.md:378
#, no-wrap
msgid "But the `combineList` function works for any `Applicative`! We can use it to combine computations which possibly signal an error using `Either err`, or which read from a global configuration using `r ->`.\n"
msgstr ""
"しかし、`combineList`関数はどんな`Applicative`に対しても機能します。\n"
"`Either err`を使ってエラーを発信する可能性を持たせたり、`r ->`を使って大域的な状態を読み取る計算を連鎖させるときにも使えるのです。\n"

#. type: Plain text
#: text/chapter7.md:380
msgid ""
"We will see the `combineList` function again later, when we consider "
"`Traversable` functors."
msgstr ""
"`combineList`関数については、後ほど`Traversable`関手について考えるときに再訪"
"します。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Medium) Write versions of the numeric operators `+`, `-`, `*` and `/` which "
"work with optional arguments (i.e. arguments wrapped in `Maybe`) and return "
"a value wrapped in `Maybe`. Name these functions `addMaybe`, `subMaybe`, "
"`mulMaybe`, and `divMaybe`. _Hint_: Use `lift2`."
msgstr ""
"（普通）数値演算子`+`、`-`、`*`、`/`のオプショナル引数（つまり`Maybe`に包まれ"
"た引数）を扱って`Maybe`に包まれた値を返す版を書いてください。\n"
"これらの関数には`addMaybe`、`subMaybe`、`mulMaybe`、`divMaybe`と名前を付けま"
"す。\n"
"*手掛かり*：`lift2`を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Medium) Extend the above exercise to work with all `Apply` types (not just "
"`Maybe`). Name these new functions `addApply`, `subApply`, `mulApply`, and "
"`divApply`."
msgstr ""
"（普通）上の演習を（`Maybe`だけでなく）全ての`Apply`型で動くように拡張してく"
"ださい。\n"
"これらの新しい関数には`addApply`、`subApply`、`mulApply`、`divApply`と名前を"
"付けます。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Difficult) Write a function `combineMaybe` which has type `forall a f. "
"Applicative f => Maybe (f a) -> f (Maybe a)`. This function takes an "
"optional computation with side-effects, and returns a side-effecting "
"computation which has an optional result."
msgstr ""
"（難しい）型`combineMaybe : forall a f. (Applicative f) => Maybe (f a) -> f "
"(Maybe a)`\n"
"を持つ関数`combineMaybe`を書いてください。\n"
"この関数は副作用をもつオプショナルな計算をとり、オプショナルな結果をもつ副作"
"用のある計算を返します。"

#. type: Plain text
#: text/chapter7.md:390
msgid ""
"The source code for this chapter defines several data types which might be "
"used in an address book application. The details are omitted here, but the "
"key functions which are exported by the `Data.AddressBook` module have the "
"following types:"
msgstr ""
"この章のソースコードでは住所録アプリケーションで使うことのできるいろいろな"
"データ型が定義されています。\n"
"詳細はここでは割愛しますが、`Data.AddressBook`モジュールからエクスポートされ"
"る重要な関数は次のような型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:391
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:phoneNumber_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:person_anno}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:phoneNumber_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:person_anno}}\n"

#. type: Plain text
#: text/chapter7.md:400
msgid "where `PhoneType` is defined as an algebraic data type:"
msgstr "ここで、`PhoneType`は次のような代数的データ型として定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:401
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:PhoneType}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:PhoneType}}\n"

#. type: Plain text
#: text/chapter7.md:406
msgid ""
"These functions can be used to construct a `Person` representing an address "
"book entry. For example, the following value is defined in `Data."
"AddressBook`:"
msgstr ""
"これらの関数は住所録の項目を表す`Person`を構築するのに使えます。\n"
"例えば、`Data.AddressBook`には次のような値が定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:407
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:examplePerson}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:examplePerson}}\n"

#. type: Plain text
#: text/chapter7.md:412
msgid "Test this value in PSCi (this result has been formatted):"
msgstr "PSCiでこれらの値を試してみましょう（結果は整形されています）。"

#. type: Fenced code block (text)
#: text/chapter7.md:413
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> examplePerson\n"
"{ firstName: \"John\"\n"
", lastName: \"Smith\"\n"
", homeAddress:\n"
"    { street: \"123 Fake St.\"\n"
"    , city: \"FakeTown\"\n"
"    , state: \"CA\"\n"
"    }\n"
", phones:\n"
"    [ { type: HomePhone\n"
"      , number: \"555-555-5555\"\n"
"      }\n"
"    , { type: CellPhone\n"
"      , number: \"555-555-0000\"\n"
"      }\n"
"    ]\n"
"}\n"
msgstr ""
"> import Data.AddressBook\n"
"\n"
"> examplePerson\n"
"{ firstName: \"John\"\n"
", lastName: \"Smith\"\n"
", homeAddress:\n"
"    { street: \"123 Fake St.\"\n"
"    , city: \"FakeTown\"\n"
"    , state: \"CA\"\n"
"    }\n"
", phones:\n"
"    [ { type: HomePhone\n"
"      , number: \"555-555-5555\"\n"
"      }\n"
"    , { type: CellPhone\n"
"      , number: \"555-555-0000\"\n"
"      }\n"
"    ]\n"
"}\n"

#. type: Plain text
#: text/chapter7.md:436
msgid ""
"We saw in a previous section how we could use the `Either String` functor to "
"validate a data structure of type `Person`. For example, provided functions "
"to validate the two names in the structure, we might validate the entire "
"data structure as follows:"
msgstr ""
"前の章では型`Person`のデータ構造を検証する上で`Either String`関手の使い方を見"
"ました。例えば、データ構造の2つの名前を検証する関数が与えられたとき、データ構"
"造全体を次のように検証できます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:437
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty1}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty1}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1}}\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:445
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1Ado}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1Ado}}\n"

#. type: Plain text
#: text/chapter7.md:450
msgid ""
"In the first two lines, we use the `nonEmpty1` function to validate a non-"
"empty string. `nonEmpty1` returns an error indicated with the `Left` "
"constructor if its input is empty, otherwise it returns the value wrapped "
"with the `Right` constructor."
msgstr ""
"最初の2行では`nonEmpty`関数を使って空文字列でないことを検証しています。\n"
"もし入力が空なら`nonEMpty`はエラーを返し（`Left`構築子で示されています）、そ"
"うでなければ`Right`構築子を使って値を包んで返します。"

#. type: Plain text
#: text/chapter7.md:452
msgid ""
"The final lines do not perform any validation but simply provide the "
"`address` and `phones` fields to the `person` function as the remaining "
"arguments."
msgstr ""
"最後の2行では何の検証も実行せず、単に`address`フィールドと`phones`フィールド"
"を残りの引数として`person`関数へと提供しています。"

#. type: Plain text
#: text/chapter7.md:454
msgid ""
"This function can be seen to work in PSCi, but has a limitation which we "
"have seen before:"
msgstr ""
"この関数はPSCiでうまく動作するように見えますが、以前見たような制限がありま"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:455
#, no-wrap
msgid ""
"> validatePerson $ person \"\" \"\" (address \"\" \"\" \"\") []\n"
"(Left \"Field cannot be empty\")\n"
msgstr ""
"> validatePerson $ person \"\" \"\" (address \"\" \"\" \"\") []\n"
"(Left \"Field cannot be empty\")\n"

#. type: Plain text
#: text/chapter7.md:461
msgid ""
"The `Either String` applicative functor only provides the first error "
"encountered. Given the input here, we would prefer to see two errors - one "
"for the missing first name, and a second for the missing last name."
msgstr ""
"`Either String`アプリカティブ関手は遭遇した最初のエラーだけを返します。\n"
"でもこの入力では、名前の不足と姓の不足という2つのエラーがわかるようにしたくな"
"るでしょう。"

#. type: Plain text
#: text/chapter7.md:463
msgid ""
"There is another applicative functor which is provided by the `validation` "
"library. This functor is called `V`, and it provides the ability to return "
"errors in any _semigroup_. For example, we can use `V (Array String)` to "
"return an array of `String`s as errors, concatenating new errors onto the "
"end of the array."
msgstr ""
"`validation`ライブラリでは別のアプリカティブ関手も提供されています。\n"
"これは単に`V`と呼ばれていて、何らかの*半群*でエラーを返す機能があります。\n"
"例えば`V (Array String)`を使うと、新しいエラーを配列の最後に連結していき、"
"`String`の配列をエラーとして返すことができます。"

#. type: Plain text
#: text/chapter7.md:465
msgid ""
"The `Data.AddressBook.Validation` module uses the `V (Array String)` "
"applicative functor to validate the data structures in the `Data."
"AddressBook` module."
msgstr ""
"`Data.Validation`モジュールは`Data.AddressBook`モジュールのデータ構造を検証す"
"るために`V (Array String)`アプリカティブ関手を使っています。"

#. type: Plain text
#: text/chapter7.md:467
msgid ""
"Here is an example of a validator taken from the `Data.AddressBook."
"Validation` module:"
msgstr ""
"`Data.AddressBook.Validation`モジュールから取材した検証器の例は次のようになり"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:468
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:Errors}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:lengthIs}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddress}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:Errors}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:lengthIs}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddress}}\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:480
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddressAdo}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddressAdo}}\n"

#. type: Plain text
#: text/chapter7.md:485
msgid ""
"`validateAddress` validates an `Address` structure. It checks that the "
"`street` and `city` fields are non-empty, and checks that the string in the "
"`state` field has length 2."
msgstr ""
"`validateAddress`は`Address`の構造を検証します。\n"
"`street`と`city`が空でないかどうか、`state`の文字列の長さが2であるかどうかを"
"検証します。"

#. type: Plain text
#: text/chapter7.md:487
msgid ""
"Notice how the `nonEmpty` and `lengthIs` validator functions both use the "
"`invalid` function provided by the `Data.Validation` module to indicate an "
"error. Since we are working in the `Array String` semigroup, `invalid` takes "
"an array of strings as its argument."
msgstr ""
"`nonEmpty`と`lengthIs`の2つの検証関数が何れも、`Data.Validation`モジュールで"
"提供されている`invalid`関数をエラーを示すために使っているところに注目してくだ"
"さい。\n"
"`Array String`半群を扱っているので、`invalid`は引数として文字列の配列を取りま"
"す。"

#. type: Plain text
#: text/chapter7.md:489
msgid "We can try this function in PSCi:"
msgstr "PSCiでこの関数を試しましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:490
#, no-wrap
msgid ""
"> import Data.AddressBook\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> validateAddress $ address \"\" \"\" \"\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         , \"Field 'State' must have length 2\"\n"
"         ])\n"
"\n"
"> validateAddress $ address \"\" \"\" \"CA\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         ])\n"
msgstr ""
"> import Data.AddressBook\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> validateAddress $ address \"\" \"\" \"\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         , \"Field 'State' must have length 2\"\n"
"         ])\n"
"\n"
"> validateAddress $ address \"\" \"\" \"CA\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         ])\n"

#. type: Plain text
#: text/chapter7.md:507
msgid "This time, we receive an array of all validation errors."
msgstr "これで、全ての検証エラーの配列を受け取ることができるようになりました。"

#. type: Title ##
#: text/chapter7.md:508
#, no-wrap
msgid "Regular Expression Validators"
msgstr "正規表現検証器"

#. type: Plain text
#: text/chapter7.md:511
msgid ""
"The `validatePhoneNumber` function uses a regular expression to validate the "
"form of its argument. The key is a `matches` validation function, which uses "
"a `Regex` from the `Data.String.Regex` module to validate its input:"
msgstr ""
"`validatePhoneNumber`関数では引数の形式を検証するために正規表現を使っていま"
"す。重要なのは`matches`検証関数で、この関数は`Data.String.Regex`モジュールで"
"定義されている`Regex`を使って入力を検証しています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:512
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:matches}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:matches}}\n"

#. type: Plain text
#: text/chapter7.md:517
msgid ""
"Again, notice how `pure` is used to indicate successful validation, and "
"`invalid` is used to signal an array of errors."
msgstr ""
"繰り返しになりますが、`pure`は常に成功する検証を表しており、エラーの配列の伝"
"達には`invalid`が使われています。"

#. type: Plain text
#: text/chapter7.md:519
msgid ""
"`validatePhoneNumber` is built from the `matches` function in the same way "
"as before:"
msgstr ""
"これまでと同様に、`validatePhoneNumber`は`matches`関数から構築されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:520
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumber}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumber}}\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:526
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumberAdo}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumberAdo}}\n"

#. type: Plain text
#: text/chapter7.md:531
msgid ""
"Again, try running this validator against some valid and invalid inputs in "
"PSCi:"
msgstr ""
"また、PSCiでいろいろな有効な入力や無効な入力に対して、この検証器を実行してみ"
"てください。"

#. type: Fenced code block (text)
#: text/chapter7.md:532
#, no-wrap
msgid ""
"> validatePhoneNumber $ phoneNumber HomePhone \"555-555-5555\"\n"
"pure ({ type: HomePhone, number: \"555-555-5555\" })\n"
"\n"
"> validatePhoneNumber $ phoneNumber HomePhone \"555.555.5555\"\n"
"invalid ([\"Field 'Number' did not match the required format\"])\n"
msgstr ""
"> validatePhoneNumber $ phoneNumber HomePhone \"555-555-5555\"\n"
"pure ({ type: HomePhone, number: \"555-555-5555\" })\n"
"\n"
"> validatePhoneNumber $ phoneNumber HomePhone \"555.555.5555\"\n"
"invalid ([\"Field 'Number' did not match the required format\"])\n"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Easy) Write a regular expression `stateRegex :: Regex` to check that a "
"string only contains two alphabetic characters. _Hint_: see the source code "
"for `phoneNumberRegex`."
msgstr ""
"（簡単）正規表現`stateRegex :: Regex`を書いて文字列が2文字のアルファベットで"
"あることを確かめてください。\n"
"*手掛かり*：`phoneNumberRegex`のソースコードを参照してみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Medium) Write a regular expression `nonEmptyRegex :: Regex` to check that a "
"string is not entirely whitespace. _Hint_: If you need help developing this "
"regex expression, check out [RegExr](https://regexr.com) which has a great "
"cheatsheet and interactive test environment."
msgstr ""
"（普通）文字列全体が空白でないことを検査する正規表現`nonEmptyRegex :: Regex`"
"を書いてください。\n"
"*手掛かり*：この正規表現を開発するのに手助けが必要なら、[RegExr](https://"
"regexr.com)をご確認ください。\n"
"素晴しい早見表と対話的なお試し環境があります。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Medium) Write a function `validateAddressImproved` that is similar to "
"`validateAddress`, but uses the above `stateRegex` to validate the `state` "
"field and `nonEmptyRegex` to validate the `street` and `city` fields. "
"_Hint_: see the source for `validatePhoneNumber` for an example of how to "
"use `matches`."
msgstr ""
"（普通）`validateAddress`に似ていますが、上の`stateRegex`を使って`state`"
"フィールドを検証し、`nonEmptyRegex`を使って`street`と`city`フィールドを検証す"
"る関数`validateAddressImproved`を書いてください。\n"
"*手掛かり*：`matches`の用例については`validatePhoneNumber`のソースを見てくだ"
"さい。"

#. type: Title ##
#: text/chapter7.md:546
#, no-wrap
msgid "Traversable Functors"
msgstr "巡回可能関手"

#. type: Plain text
#: text/chapter7.md:549
msgid ""
"The remaining validator is `validatePerson`, which combines the validators "
"we have seen so far to validate an entire `Person` structure, including the "
"following new `validatePhoneNumbers` function:"
msgstr ""
"残った検証器は`validatePerson`です。\n"
"これはこれまで見てきた検証器と以下の新しい`validatePhoneNumbers`関数を組み合"
"わせて`Person`全体を検証するものです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:550
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumbers}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson}}\n"
msgstr ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumbers}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson}}\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:558
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePersonAdo}}\n"
msgstr "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePersonAdo}}\n"

#. type: Plain text
#: text/chapter7.md:563
msgid ""
"`validatePhoneNumbers` uses a new function we haven't seen before - "
"`traverse`."
msgstr ""
"`validatePhoneNumbers`はこれまでに見たことのない新しい関数、`traverse`を使い"
"ます。"

#. type: Plain text
#: text/chapter7.md:565
msgid ""
"`traverse` is defined in the `Data.Traversable` module, in the `Traversable` "
"type class:"
msgstr ""
"`traverse`は`Data.Traversable`モジュールの`Traversable`型クラスで定義されてい"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:566
#, no-wrap
msgid ""
"class (Functor t, Foldable t) <= Traversable t where\n"
"  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n"
"  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr ""
"class (Functor t, Foldable t) <= Traversable t where\n"
"  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n"
"  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"

#. type: Plain text
#: text/chapter7.md:573
msgid ""
"`Traversable` defines the class of _traversable functors_. The types of its "
"functions might look a little intimidating, but `validatePerson` provides a "
"good motivating example."
msgstr ""
"`Traversable`は _巡回可能関手_ の型クラスを定義します。これらの関数の型は少し"
"難しそうに見えるかもしれませんが、`validatePerson`は良いきっかけとなる例で"
"す。"

#. type: Plain text
#: text/chapter7.md:575
msgid ""
"Every traversable functor is both a `Functor` and `Foldable` (recall that a "
"_foldable functor_ was a type constructor which supported a fold operation, "
"reducing a structure to a single value). In addition, a traversable functor "
"provides the ability to combine a collection of side-effects which depend on "
"its structure."
msgstr ""
"全ての巡回可能関手は`Functor`と`Foldable`のどちらでもあります（*畳み込み可能"
"関手*は、構造を1つの値へと纏める畳み込み操作を提供する型構築子であったことを"
"思い出してください）。\n"
"それに加えて、`Traversable`関手はその構造に依存した副作用の集まりを連結する機"
"能を提供します。"

#. type: Plain text
#: text/chapter7.md:577
msgid ""
"This may sound complicated, but let's simplify things by specializing to the "
"case of arrays. The array type constructor is traversable, which means that "
"there is a function:"
msgstr ""
"複雑そうに聞こえるかもしれませんが、配列の場合に特殊化して簡単にした上で考え"
"てみましょう。配列型構築子は`Traversable`であり、つまりは次のような関数が存在"
"するということです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:578
#, no-wrap
msgid "traverse :: forall a b m. Applicative m => (a -> m b) -> Array a -> m (Array b)\n"
msgstr "traverse :: forall a b m. Applicative m => (a -> m b) -> Array a -> m (Array b)\n"

#. type: Plain text
#: text/chapter7.md:583
msgid ""
"Intuitively, given any applicative functor `m`, and a function which takes a "
"value of type `a` and returns a value of type `b` (with side-effects tracked "
"by `m`), we can apply the function to each element of an array of type "
"`Array a` to obtain a result of type `Array b` (with side-effects tracked by "
"`m`)."
msgstr ""
"直感的にはこうです。\n"
"任意のアプリカティブ関手`m`と、型`a`の値を取って型`b`の値を返す（`f`で追跡さ"
"れる副作用を持つ）関数が与えられたとします。\n"
"このとき、その関数を型`Array a`の配列のそれぞれの要素に適用して型`Array b`の"
"（`f`で追跡される副作用を持つ）結果を得ることができます。"

#. type: Plain text
#: text/chapter7.md:585
msgid ""
"Still not clear? Let's specialize further to the case where `m` is the `V "
"Errors` applicative functor above. Now, we have a function of type"
msgstr ""
"まだよくわからないでしょうか。それでは更に、`f`を上記の`V Errors`アプリカティ"
"ブ関手に特殊化して考えてみましょう。これで次の型を持つ関数が得られます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:586
#, no-wrap
msgid "traverse :: forall a b. (a -> V Errors b) -> Array a -> V Errors (Array b)\n"
msgstr "traverse :: forall a b. (a -> V Errors b) -> Array a -> V Errors (Array b)\n"

#. type: Plain text
#: text/chapter7.md:591
msgid ""
"This type signature says that if we have a validation function `m` for a "
"type `a`, then `traverse m` is a validation function for arrays of type "
"`Array a`. But that's exactly what we need to be able to validate the "
"`phones` field of the `Person` data structure! We pass `validatePhoneNumber` "
"to `traverse` to create a validation function which validates each element "
"successively."
msgstr ""
"この型シグネチャは、型`a`についての検証関数`m`があれば、`traverse m`は型"
"`Array a`の配列についての検証関数であるということを言っています。\n"
"これはまさに、今必要になっている`Person`データ構造体の`phones`フィールドを検"
"証する検証器そのものです。\n"
"それぞれの要素が成功するかどうかを検証する検証関数を作るために、"
"`validatePhoneNumber`を`traverse`へ渡しています。"

#. type: Plain text
#: text/chapter7.md:593
msgid ""
"In general, `traverse` walks over the elements of a data structure, "
"performing computations with side-effects and accumulating a result."
msgstr ""
"一般に、`traverse`はデータ構造の要素を1つずつ辿っていき、副作用を伴いつつ計算"
"し、結果を累積します。"

#. type: Plain text
#: text/chapter7.md:595
msgid ""
"The type signature for `Traversable`'s other function `sequence` might look "
"more familiar:"
msgstr ""
"`Traversable`のもう1つの関数、`sequence`の型シグネチャには見覚えがあるかもし"
"れません。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:596
#, no-wrap
msgid "sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr "sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"

#. type: Plain text
#: text/chapter7.md:601
msgid ""
"In fact, the `combineList` function that we wrote earlier is just a special "
"case of the `sequence` function from the `Traversable` type class. Setting "
"`t` to be the type constructor `List`, we recover the type of the "
"`combineList` function:"
msgstr ""
"実際、先ほど書いた`combineList`関数は`Traversable`型クラスの`sequence`関数の"
"特別な場合に過ぎません。\n"
"`t`を型構築子`List`だとすると、`combineList`関数の型が復元されます。"

#. type: Plain text
#: text/chapter7.md:607
msgid ""
"Traversable functors capture the idea of traversing a data structure, "
"collecting a set of effectful computations, and combining their effects. In "
"fact, `sequence` and `traverse` are equally important to the definition of "
"`Traversable` - each can be implemented in terms of each other. This is left "
"as an exercise for the interested reader."
msgstr ""
"巡回可能関手は、作用のある計算を集めてその作用を結合するという、データ構造走"
"査の考え方を見据えたものです。実際、`sequence`と`traversable`は`Traversable`"
"を定義する上でどちらも同じくらい重要です。これらはお互いがお互いを利用して実"
"装できます。これについては興味ある読者への演習として残しておきます。"

#. type: Plain text
#: text/chapter7.md:609
msgid ""
"The `Traversable` instance for lists given in the `Data.List` module is:"
msgstr ""
"`Data.List`で与えられているリストの`Traversable`インスタンスは次の通り。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:610
#, no-wrap
msgid ""
"instance traversableList :: Traversable List where\n"
"-- traverse :: forall a b m. Applicative m => (a -> m b) -> List a -> m (List b)\n"
"traverse _ Nil         = pure Nil\n"
"traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs\n"
msgstr ""
"instance traversableList :: Traversable List where\n"
"-- traverse :: forall a b m. Applicative m => (a -> m b) -> List a -> m (List b)\n"
"traverse _ Nil         = pure Nil\n"
"traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs\n"

#. type: Plain text
#: text/chapter7.md:618
msgid ""
"(The actual definition was later modified to improve stack safety. You can "
"read more about that change [here](https://github.com/purescript/purescript-"
"lists/pull/87).)"
msgstr ""
"（実際の定義は後にスタック安全性を向上するために変更されました。その変更につ"
"いてより詳しくは[こちら](https://github.com/purescript/purescript-lists/"
"pull/87)で読むことができます）"

#. type: Plain text
#: text/chapter7.md:620
msgid ""
"In the case of an empty list, we can simply return an empty list using "
"`pure`. If the list is non-empty, we can use the function `f` to create a "
"computation of type `f b` from the head element. We can also call `traverse` "
"recursively on the tail. Finally, we can lift the `Cons` constructor over "
"the applicative functor `m` to combine the two results."
msgstr ""
"入力が空のリストのときには、単に`pure`を使って空の配列を返すことができます。"
"配列が空でないときは、関数`f`を使うと先頭の要素から型`f b`の計算を作成できま"
"す。また、配列の残りに対して`traverse`を再帰的に呼び出すことができます。最後"
"に、アプリカティブ関手`m`まで`Cons`構築子を持ち上げて、2つの結果を組み合わせ"
"ます。"

#. type: Plain text
#: text/chapter7.md:622
msgid ""
"But there are more examples of traversable functors than just arrays and "
"lists. The `Maybe` type constructor we saw earlier also has an instance for "
"`Traversable`. We can try it in PSCi:"
msgstr ""
"巡回可能関手の例はただの配列やリスト以外にもあります。\n"
"以前に見た`Maybe`型構築子も`Traversable`のインスタンスを持っています。\n"
"PSCiで試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:623
#, no-wrap
msgid ""
"> import Data.Maybe\n"
"> import Data.Traversable\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> traverse (nonEmpty \"Example\") Nothing\n"
"pure (Nothing)\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"\")\n"
"invalid ([\"Field 'Example' cannot be empty\"])\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"Testing\")\n"
"pure ((Just \"Testing\"))\n"
msgstr ""
"> import Data.Maybe\n"
"> import Data.Traversable\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> traverse (nonEmpty \"Example\") Nothing\n"
"pure (Nothing)\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"\")\n"
"invalid ([\"Field 'Example' cannot be empty\"])\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"Testing\")\n"
"pure ((Just \"Testing\"))\n"

#. type: Plain text
#: text/chapter7.md:639
msgid ""
"These examples show that traversing the `Nothing` value returns `Nothing` "
"with no validation, and traversing `Just x` uses the validation function to "
"validate `x`. That is, `traverse` takes a validation function for type `a` "
"and returns a validation function for `Maybe a`, i.e. a validation function "
"for optional values of type `a`."
msgstr ""
"これらの例では、`Nothing`の値の走査は検証なしで`Nothing`の値を返し、`Just x`"
"を走査すると`x`を検証するのに検証関数が使われるということを示しています。\n"
"要は、`traverse`は型`a`についての検証関数をとり、`Maybe a`についての検証関"
"数、つまり型`a`のオプショナルな値についての検証関数を返すのです。"

#. type: Plain text
#: text/chapter7.md:641
msgid ""
"Other traversable functors include `Array`, and `Tuple a` and `Either a` for "
"any type `a`. Generally, most \"container\" data type constructors have "
"`Traversable` instances. As an example, the exercises will include writing a "
"`Traversable` instance for a type of binary trees."
msgstr ""
"他の巡回可能関手には`Array`、また任意の型`a`について`Tuple a`、`Either a`が含"
"まれます。一般的に、「容器」のようなデータの型構築子は大抵`Traversable`インス"
"タンスを持っています。例として、演習では二分木の型の`Traversable`インスタンス"
"を書くことになります。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:645
msgid ""
"(Easy) Write `Eq` and `Show` instances for the following binary tree data "
"structure:"
msgstr ""
"（簡単）`Eq`と`Show`インスタンスを以下の2分木データ構造に対して書いてくださ"
"い。"

#. type: Plain text
#: text/chapter7.md:649
#, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"
"     ```\n"

#. type: Plain text
#: text/chapter7.md:651
#, no-wrap
msgid "     Recall from the previous chapter that you may either write these instances manually or let the compiler derive them for you.\n"
msgstr "     これらのインスタンスを手作業で書くこともできますし、コンパイラに導出してもらうこともできることを前の章から思い起こしてください。\n"

#. type: Plain text
#: text/chapter7.md:653
#, no-wrap
msgid "     There are many \"correct\" formatting options for `Show` output. The test for this exercise expects the following whitespace style. This happens to match the default formatting of generic show, so you only need to make note of this if you're planning on writing this instance manually.\n"
msgstr ""
"     `Show`の出力には多くの「正しい」書式の選択肢があります。\n"
"     この演習のテストでは以下の空白スタイルを期待しています。\n"
"     これはたまたま一般化されたshowの既定の書式と合致しているため、このインスタンスを手作業で書くつもりのときだけ、このことを念頭に置いておいてください。\n"

#. type: Plain text
#: text/chapter7.md:657
#, no-wrap
msgid ""
"     ```haskell\n"
"     (Branch (Branch Leaf 8 Leaf) 42 Leaf)\n"
"     ```\n"
msgstr ""
"     ```haskell\n"
"     (Branch (Branch Leaf 8 Leaf) 42 Leaf)\n"
"     ```\n"

#. type: Bullet: ' 1. '
#: text/chapter7.md:659
msgid ""
"(Medium) Write a `Traversable` instance for `Tree a`, which combines side-"
"effects from left-to-right. _Hint_: There are some additional instance "
"dependencies that need to be defined for `Traversable`."
msgstr ""
"（普通）`Traversable`インスタンスを`Tree a`に対して書いてください。\n"
"これは副作用を左から右に結合するものです。\n"
"*手掛かり*：`Traversable`に定義する必要のある追加のインスタンス依存関係が幾つ"
"かあります。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:661
msgid ""
"(Medium) Write a function `traversePreOrder :: forall a m b. Applicative m "
"=> (a -> m b) -> Tree a -> m (Tree b)` that performs a pre-order traversal "
"of the tree. This means the order of effect execution is root-left-right, "
"instead of left-root-right as was done for the previous in-order traverse "
"exercise. _Hint_: No additional instances need to be defined, and you don't "
"need to call any of the the functions defined earlier. Applicative do "
"notation (`ado`) is the easiest way to write this function."
msgstr ""
"（普通）行き掛け順に木を巡回する関数`traversePreOrder :: forall a m b. "
"Applicative m => (a -> m b) -> Tree a -> m (Tree b)`を書いてください。\n"
"つまり作用の実行は根左右と行われ、以前の通り掛け順の巡回の演習でしたような左"
"根右ではありません。\n"
"*手掛かり*：追加でインスタンスを定義する必要はありませんし、前に定義した関数"
"は何も呼ぶ必要はありません。\n"
"アプリカティブdo記法 (`ado`) はこの関数を書く最も簡単な方法です。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:663
msgid ""
"(Medium) Write a function `traversePostOrder` that performs a post-order "
"traversal of the tree where effects are executed left-right-root."
msgstr ""
"（普通）木を帰り掛け順に巡回する関数`traversePostOrder`を書いてください。作用"
"は左右根と実行されます。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:665
msgid ""
"(Medium) Create a new version of the `Person` type where the `homeAddress` "
"field is optional (using `Maybe`). Then write a new version of "
"`validatePerson` (renamed as `validatePersonOptionalAddress`) to validate "
"this new `Person`. _Hint_: Use `traverse` to validate a field of type `Maybe "
"a`."
msgstr ""
"（普通）`homeAddress`フィールドがオプショナル（`Maybe`を使用）な新しい版の"
"`Person`型をつくってください。\n"
"それからこの新しい`Person`を検証する新しい版の"
"`validatePerson`（`validatePersonOptionalAddress`と改名します）を書いてくださ"
"い。\n"
"*手掛かり*：`traverse`を使って型`Maybe a`のフィールドを検証してください。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:667
msgid ""
"(Difficult) Write a function `sequenceUsingTraverse` which behaves like "
"`sequence`, but is written in terms of `traverse`."
msgstr ""
"（難しい）`sequence`のように振る舞う関数`sequenceUsingTraverse`を書いてくださ"
"い。\n"
"ただし`traverse`を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:669
msgid ""
"(Difficult) Write a function `traverseUsingSequence` which behaves like "
"`traverse`, but is written in terms of `sequence`."
msgstr ""
"（難しい）`traverse`のように振る舞う関数`traverseUsingSequence`を書いてくださ"
"い。\n"
"ただし`sequence`を使ってください。"

#. type: Title ##
#: text/chapter7.md:670
#, no-wrap
msgid "Applicative Functors for Parallelism"
msgstr "アプリカティブ関手による並列処理"

#. type: Plain text
#: text/chapter7.md:673
msgid ""
"In the discussion above, I chose the word \"combine\" to describe how "
"applicative functors \"combine side-effects\". However, in all the examples "
"given, it would be equally valid to say that applicative functors allow us "
"to \"sequence\" effects. This would be consistent with the intuition that "
"traversable functors provide a `sequence` function to combine effects in "
"sequence based on a data structure."
msgstr ""
"これまでの議論では、アプリカティブ関手がどのように「副作用を結合」させるかを"
"説明するときに、「結合」(combine) という単語を選びました。\n"
"しかし、これらの全ての例において、アプリカティブ関手は作用を「連鎖」"
"(sequence) させる、というように言っても同じく妥当です。\n"
"巡回可能関手がデータ構造に従って作用を順番に結合させる`sequence`関数を提供し"
"ていることと、この直感的理解とは一致するでしょう。"

#. type: Plain text
#: text/chapter7.md:675
msgid ""
"However, in general, applicative functors are more general than this. The "
"applicative functor laws do not impose any ordering on the side-effects that "
"their computations perform. In fact, it would be valid for an applicative "
"functor to perform its side-effects in parallel."
msgstr ""
"しかし一般には、アプリカティブ関手はこれよりももっと一般的です。\n"
"アプリカティブ関手の規則は、その計算の副作用にどんな順序付けも強制しませ"
"ん。\n"
"実際、並列に副作用を実行するためのアプリカティブ関手というものは妥当になりえ"
"ます。"

#. type: Plain text
#: text/chapter7.md:677
msgid ""
"For example, the `V` validation functor returned an _array_ of errors, but "
"it would work just as well if we picked the `Set` semigroup, in which case "
"it would not matter what order we ran the various validators. We could even "
"run them in parallel over the data structure!"
msgstr ""
"例えば`V`検証関手はエラーの*配列*を返しますが、その代わりに`Set`半群を選んだ"
"としてもやはり正常に動き、このときどんな順序でそれぞれの検証器を実行しても問"
"題はありません。\n"
"データ構造に対して並列にこれの実行さえできるのです。"

#. type: Plain text
#: text/chapter7.md:679
msgid ""
"As a second example, the `parallel` package provides a type class `Parallel` "
"which supports _parallel computations_. `Parallel` provides a function "
"`parallel` which uses some `Applicative` functor to compute the result of "
"its input computation _in parallel_:"
msgstr ""
"別の例として、`parallel`パッケージは、*並列計算*に対応する`Parallel`型クラス"
"を与えます。\n"
"`Parallel`は関数`parallel`を提供しており、何らかの`Applicative`関手を使って入"
"力の計算を*並列に*計算できます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:680
#, no-wrap
msgid ""
"f <$> parallel computation1\n"
"  <*> parallel computation2\n"
msgstr ""
"f <$> parallel computation1\n"
"  <*> parallel computation2\n"

#. type: Plain text
#: text/chapter7.md:686
msgid ""
"This computation would start computing values asynchronously using "
"`computation1` and `computation2`. When both results have been computed, "
"they would be combined into a single result using the function `f`."
msgstr ""
"この計算は`computation1`と`computation2`を非同期に使って値の計算を始めるで"
"しょう。そして両方の結果の計算が終わった時に、関数`f`を使って1つの結果へと結"
"合するでしょう。"

#. type: Plain text
#: text/chapter7.md:688
msgid ""
"We will see this idea in more detail when we apply applicative functors to "
"the problem of _callback hell_ later in the book."
msgstr ""
"この考え方の詳細は、本書の後半で _コールバック地獄_ の問題に対してアプリカ"
"ティブ関手を応用するときに見ていきます。"

#. type: Plain text
#: text/chapter7.md:690
msgid ""
"Applicative functors are a natural way to capture side-effects which can be "
"combined in parallel."
msgstr ""
"アプリカティブ関手は並列に結合できる副作用を一纏めにする自然な方法です。"

#. type: Plain text
#: text/chapter7.md:694
msgid "In this chapter, we covered a lot of new ideas:"
msgstr "この章では新しい考え方を沢山扱いました。"

#. type: Bullet: '- '
#: text/chapter7.md:698
msgid ""
"We introduced the concept of an _applicative functor_ which generalizes the "
"idea of function application to type constructors which capture some notion "
"of side-effect."
msgstr ""
"関数適用の概念を副作用の観念を捉えた型構築子へと一般化する、 _アプリカティブ"
"関手_ の概念を導入しました。"

#. type: Bullet: '- '
#: text/chapter7.md:698
msgid ""
"We saw how applicative functors gave a solution to the problem of validating "
"data structures, and how by switching the applicative functor we could "
"change from reporting a single error to reporting all errors across a data "
"structure."
msgstr ""
"データ構造の検証という課題にアプリカティブ関手がどのような解決策を与えるか、"
"どうすれば単一のエラーの報告からデータ構造を横断する全てのエラーの報告へ変換"
"できるのかを見てきました。"

#. type: Bullet: '- '
#: text/chapter7.md:698
msgid ""
"We met the `Traversable` type class, which encapsulates the idea of a "
"_traversable functor_, or a container whose elements can be used to combine "
"values with side-effects."
msgstr ""
"`Traversable`型クラスに出会いました。*巡回可能関手*の考え方を内包するものであ"
"り、要素が副作用を持つ値の結合に使うことができる容れ物でした。"

#. type: Plain text
#: text/chapter7.md:700
msgid ""
"Applicative functors are an interesting abstraction which provide neat "
"solutions to a number of problems. We will see them a few more times "
"throughout the book. In this case, the validation applicative functor "
"provided a way to write validators in a declarative style, allowing us to "
"define _what_ our validators should validate and not _how_ they should "
"perform that validation. In general, we will see that applicative functors "
"are a useful tool for the design of _domain specific languages_."
msgstr ""
"アプリカティブ関手は多くの問題に対して優れた解決策を与える興味深い抽象化で"
"す。\n"
"本書を通じて何度も見ることになるでしょう。\n"
"今回の場合、アプリカティブ関手は宣言的な流儀で書く手段を提供していましたが、"
"これにより検証器が*どうやって*検証するかではなく、*何を*検証すべきなのかを定"
"義できました。\n"
"一般に、アプリカティブ関手は*領域特化言語*を設計する上で便利な道具になりま"
"す。"

#. type: Plain text
#: text/chapter7.md:701
msgid ""
"In the next chapter, we will see a related idea, the class of _monads_, and "
"extend our address book example to run in the browser!"
msgstr ""
"次の章では、これに関連する考え方である*モナド*クラスを見て、アドレス帳の例を"
"ブラウザで実行させられるように拡張しましょう。"

#. type: Title ##
#: text/chapter8.md:1 text/chapter8.md:393
#, no-wrap
msgid "The Effect Monad"
msgstr "作用モナド"

#. type: Plain text
#: text/chapter8.md:6
msgid ""
"In the last chapter, we introduced applicative functors, an abstraction "
"which we used to deal with _side-effects_: optional values, error messages "
"and validation. This chapter will introduce another abstraction for dealing "
"with side-effects in a more expressive way: _monads_."
msgstr ""
"前章では、オプショナルな型やエラーメッセージ、データの検証など、 _副作用_ を"
"扱いを抽象化するアプリカティブ関手を導入しました。この章では、より表現力の高"
"い方法で副作用を扱うための別の抽象化、 _モナド_ を導入します。"

#. type: Plain text
#: text/chapter8.md:8
msgid ""
"The goal of this chapter is to explain why monads are a useful abstraction, "
"and their connection with _do notation_."
msgstr ""
"この章の目的は、なぜモナドが便利な抽象化なのかということと、 _do記法_ との関"
"係を説明することです。"

#. type: Plain text
#: text/chapter8.md:12
msgid "The project adds the following dependencies:"
msgstr "このプロジェクトでは、以下の依存関係が追加されています。"

#. type: Bullet: '- '
#: text/chapter8.md:15
msgid ""
"`effect` - defines the `Effect` monad, the subject of the second half of the "
"chapter. This dependency is often listed in every starter project (it's been "
"a dependency of every chapter so far), so you'll rarely have to explicitly "
"install it."
msgstr ""
"`effect`: 章の後半の主題である`Effect`モナドを定義しています。この依存関係は"
"全てのプロジェクトで始めから入っているものなので（これまでの全ての章でも依存"
"関係にありました）、明示的にインストールしなければいけないことは稀です。"

#. type: Bullet: '- '
#: text/chapter8.md:15
msgid ""
"`react-basic-hooks` - a web framework that we will use for our Address Book "
"app."
msgstr "`react-basic-hooks`: アドレス帳アプリに使うWebフレームワークです。"

#. type: Title ##
#: text/chapter8.md:16
#, no-wrap
msgid "Monads and Do Notation"
msgstr "モナドとdo記法"

#. type: Plain text
#: text/chapter8.md:19
msgid ""
"Do notation was first introduced when we covered _array comprehensions_. "
"Array comprehensions provide syntactic sugar for the `concatMap` function "
"from the `Data.Array` module."
msgstr ""
"do記法は*配列内包表記*を扱うときに初めて導入されました。\n"
"配列内包表記は`Data.Array`モジュールの`concatMap`関数の構文糖として提供されて"
"います。"

#. type: Plain text
#: text/chapter8.md:21
msgid ""
"Consider the following example. Suppose we throw two dice and want to count "
"the number of ways in which we can score a total of `n`. We could do this "
"using the following non-deterministic algorithm:"
msgstr ""
"次の例を考えてみましょう。2つのサイコロを振って出た目を数え、出た目の合計が "
"`n`のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使"
"うとこれを実現できます。"

#. type: Bullet: '- '
#: text/chapter8.md:25
msgid "_Choose_ the value `x` of the first throw."
msgstr "最初の投擲で値 `x`を _選択_ します。"

#. type: Bullet: '- '
#: text/chapter8.md:25
msgid "_Choose_ the value `y` of the second throw."
msgstr "2回目の投擲で値 `y`を _選択_ します。"

#. type: Bullet: '- '
#: text/chapter8.md:25
msgid ""
"If the sum of `x` and `y` is `n` then return the pair `[x, y]`, else fail."
msgstr ""
"もし `x`と `y`の和が `n`なら組 `[x, y]`を返し、そうでなければ失敗します。"

#. type: Plain text
#: text/chapter8.md:27
msgid ""
"Array comprehensions allow us to write this non-deterministic algorithm in a "
"natural way:"
msgstr ""
"配列内包表記を使うと、この非決定的アルゴリズムを自然に書くことができます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:28
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Plus (empty)\n"
"import Data.Array ((..))\n"
"\n"
"{{#include ../exercises/chapter8/test/Examples.purs:countThrows}}\n"
msgstr ""
"import Prelude\n"
"\n"
"import Control.Plus (empty)\n"
"import Data.Array ((..))\n"
"\n"
"{{#include ../exercises/chapter8/test/Examples.purs:countThrows}}\n"

#. type: Plain text
#: text/chapter8.md:38
msgid "We can see that this function works in PSCi:"
msgstr "PSCiでこの関数の動作を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter8.md:39
#, no-wrap
msgid ""
"> import Test.Examples\n"
"\n"
"> countThrows 10\n"
"[[4,6],[5,5],[6,4]]\n"
"\n"
"> countThrows 12\n"
"[[6,6]]\n"
msgstr ""
"> import Test.Examples\n"
"\n"
"> countThrows 10\n"
"[[4,6],[5,5],[6,4]]\n"
"\n"
"> countThrows 12\n"
"[[6,6]]\n"

#. type: Plain text
#: text/chapter8.md:50
msgid ""
"In the last chapter, we formed an intuition for the `Maybe` applicative "
"functor, embedding PureScript functions into a larger programming language "
"supporting _optional values_. In the same way, we can form an intuition for "
"the _array monad_, embedding PureScript functions into a larger programming "
"language supporting _non-deterministic choice_."
msgstr ""
"前の章では、*オプショナルな値*に対応したより大きなプログラミング言語へと"
"PureScriptの関数を埋め込む、`Maybe`アプリカティブ関手についての直感的理解を養"
"いました。\n"
"同様に*配列モナド*についても、*非決定選択*に対応したより大きなプログラミング"
"言語へPureScriptの関数を埋め込む、というような直感的理解を得ることができま"
"す。"

#. type: Plain text
#: text/chapter8.md:52
msgid ""
"In general, a _monad_ for some type constructor `m` provides a way to use do "
"notation with values of type `m a`. Note that in the array comprehension "
"above, every line contains a computation of type `Array a` for some type "
"`a`. In general, every line of a do notation block will contain a "
"computation of type `m a` for some type `a` and our monad `m`. The monad `m` "
"must be the same on every line (i.e. we fix the side-effect), but the types "
"`a` can differ (i.e. individual computations can have different result "
"types)."
msgstr ""
"一般に、ある型構築子 `m`のモナドは、型 `m a`の値を持つdo記法を使う手段を提供"
"します。\n"
"上の配列内包表記では、全ての行に何らかの型 `a`についての型 `Array a`の計算が"
"含まれていることに注目してください。\n"
"一般に、do記法ブロックの全ての行は、何らかの型 `a`とモナド `m`について、型 "
"`m a`の計算を含んでいます。\n"
"モナド `m`は全ての行で同じでなければなりません（つまり、副作用の種類は固定さ"
"れます）が、型 `a`は異なることもあります（言い換えると、個々の計算は異なる型"
"の結果を持つことができます）。"

#. type: Plain text
#: text/chapter8.md:54
msgid ""
"Here is another example of do notation, this time applied to the type "
"constructor `Maybe`. Suppose we have some type `XML` representing XML nodes, "
"and a function"
msgstr ""
"以下はdo記法の別の例です。\n"
"今回は型構築子 `Maybe`に適用されています。\n"
"XMLノードを表す型 `XML`と次の関数があるとします。"

#. type: Fenced code block (hs)
#: text/chapter8.md:55
#, no-wrap
msgid "child :: XML -> String -> Maybe XML\n"
msgstr "child :: XML -> String -> Maybe XML\n"

#. type: Plain text
#: text/chapter8.md:60
msgid ""
"which looks for a child element of a node, and returns `Nothing` if no such "
"element exists."
msgstr ""
"この関数はノードの子の要素を探し、もしそのような要素が存在しなければ "
"`Nothing`を返します。"

#. type: Plain text
#: text/chapter8.md:62
msgid ""
"In this case, we can look for a deeply-nested element by using do notation. "
"Suppose we wanted to read a user's city from a user profile which had been "
"encoded as an XML document:"
msgstr ""
"この場合、do記法を使うと深い入れ子になった要素を検索できます。\n"
"XML文書として符号化された利用者情報から、利用者の住んでいる市町村を読み取りた"
"いとします。"

#. type: Fenced code block (hs)
#: text/chapter8.md:63 text/chapter8.md:293
#, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root = do\n"
"  prof <- child root \"profile\"\n"
"  addr <- child prof \"address\"\n"
"  city <- child addr \"city\"\n"
"  pure city\n"
msgstr ""
"userCity :: XML -> Maybe XML\n"
"userCity root = do\n"
"  prof <- child root \"profile\"\n"
"  addr <- child prof \"address\"\n"
"  city <- child addr \"city\"\n"
"  pure city\n"

#. type: Plain text
#: text/chapter8.md:73
msgid ""
"The `userCity` function looks for a child element `profile`, an element "
"`address` inside the `profile` element, and finally an element `city` inside "
"the `address` element. If any of these elements are missing, the return "
"value will be `Nothing`. Otherwise, the return value is constructed using "
"`Just` from the `city` node."
msgstr ""
"`userCity`関数は子の要素である `profile`を探し、 `profile`要素の中にある "
"`address`要素、最後に `address`要素から `city`要素を探します。\n"
"これらの要素の何れかが欠落している場合は、返り値は `Nothing`になります。\n"
"そうでなければ、返り値は `city`ノードから `Just`を使って構築されています。"

#. type: Plain text
#: text/chapter8.md:75
msgid ""
"Remember, the `pure` function in the last line is defined for every "
"`Applicative` functor. Since `pure` is defined as `Just` for the `Maybe` "
"applicative functor, it would be equally valid to change the last line to "
"`Just city`."
msgstr ""
"最後の行にある`pure`関数は、全ての`Applicative`関手について定義されているので"
"した。\n"
"`Maybe`の`Applicative`関手の`pure`関数は`Just`として定義されており、最後の行"
"を `Just city`へ変更しても同じように正しく動きます。"

#. type: Title ##
#: text/chapter8.md:76
#, no-wrap
msgid "The Monad Type Class"
msgstr "モナド型クラス"

#. type: Plain text
#: text/chapter8.md:79
msgid "The `Monad` type class is defined as follows:"
msgstr "`Monad`型クラスは次のように定義されています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:80
#, no-wrap
msgid ""
"class Apply m <= Bind m where\n"
"  bind :: forall a b. m a -> (a -> m b) -> m b\n"
"\n"
"class (Applicative m, Bind m) <= Monad m\n"
msgstr ""
"class Apply m <= Bind m where\n"
"  bind :: forall a b. m a -> (a -> m b) -> m b\n"
"\n"
"class (Applicative m, Bind m) <= Monad m\n"

#. type: Plain text
#: text/chapter8.md:88
#, no-wrap
msgid "The key function here is `bind`, defined in the `Bind` type class. Just like for the `<$>` and `<*>` operators in the `Functor` and `Apply` type classes, the Prelude defines an infix alias `>>=` for the `bind` function.\n"
msgstr "ここで鍵となる関数は `Bind`型クラスで定義されている演算子 `bind`で、`Functor`及び `Apply`型クラスにある `<$>`や `<*>`などの演算子と同様に、`Prelude`では `>>=`として `bind`の中置の別名が定義されています。\n"

#. type: Plain text
#: text/chapter8.md:90
msgid ""
"The `Monad` type class extends `Bind` with the operations of the "
"`Applicative` type class that we have already seen."
msgstr ""
"`Monad`型クラスは、既に見てきた `Applicative`型クラスの操作で `Bind`を拡張し"
"ます。"

#. type: Plain text
#: text/chapter8.md:92
msgid ""
"It will be useful to see some examples of the `Bind` type class. A sensible "
"definition for `Bind` on arrays can be given as follows:"
msgstr ""
"`Bind`型クラスの例を幾つか見てみるのがわかりやすいでしょう。\n"
"配列についての `Bind`の妥当な定義は次のようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:93
#, no-wrap
msgid ""
"instance bindArray :: Bind Array where\n"
"  bind xs f = concatMap f xs\n"
msgstr ""
"instance bindArray :: Bind Array where\n"
"  bind xs f = concatMap f xs\n"

#. type: Plain text
#: text/chapter8.md:99
msgid ""
"This explains the connection between array comprehensions and the "
"`concatMap` function that has been alluded to before."
msgstr ""
"これは以前に仄めかした、配列内包表記と `concatMap`関数の関係を説明していま"
"す。"

#. type: Plain text
#: text/chapter8.md:101
msgid "Here is an implementation of `Bind` for the `Maybe` type constructor:"
msgstr "`Maybe`型構築子についての `Bind`の実装は次のようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:102
#, no-wrap
msgid ""
"instance bindMaybe :: Bind Maybe where\n"
"  bind Nothing  _ = Nothing\n"
"  bind (Just a) f = f a\n"
msgstr ""
"instance bindMaybe :: Bind Maybe where\n"
"  bind Nothing  _ = Nothing\n"
"  bind (Just a) f = f a\n"

#. type: Plain text
#: text/chapter8.md:109
msgid ""
"This definition confirms the intuition that missing values are propagated "
"through a do notation block."
msgstr ""
"この定義は欠落した値がdo記法ブロックを通じて伝播するという直感的理解を裏付け"
"るものです。"

#. type: Plain text
#: text/chapter8.md:111
msgid ""
"Let's see how the `Bind` type class is related to do notation. Consider a "
"simple do notation block which starts by binding a value from the result of "
"some computation:"
msgstr ""
"`Bind`型クラスとdo記法がどのように関係しているかを見て行きましょう。最初に何"
"らかの計算結果からの値の束縛から始まる簡単なdo記法ブロックについて考えてみま"
"しょう。"

#. type: Fenced code block (hs)
#: text/chapter8.md:112
#, no-wrap
msgid ""
"do value <- someComputation\n"
"   whatToDoNext\n"
msgstr ""
"do value <- someComputation\n"
"   whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:118
msgid ""
"Every time the PureScript compiler sees this pattern, it replaces the code "
"with this:"
msgstr ""
"PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置"
"き換えます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:119
#, no-wrap
msgid "bind someComputation \\value -> whatToDoNext\n"
msgstr "bind someComputation \\value -> whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:124
msgid "or, written infix:"
msgstr "あるいは中置で書くと以下です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:125
#, no-wrap
msgid "someComputation >>= \\value -> whatToDoNext\n"
msgstr "someComputation >>= \\value -> whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:130
msgid "The computation `whatToDoNext` is allowed to depend on `value`."
msgstr "この計算 `whatToDoNext`は `value`に依存できます。"

#. type: Plain text
#: text/chapter8.md:132
msgid ""
"If there are multiple binds involved, this rule is applied multiple times, "
"starting from the top. For example, the `userCity` example that we saw "
"earlier gets desugared as follows:"
msgstr ""
"複数の束縛が関係している場合、この規則は先頭のほうから複数回適用されます。例"
"えば、先ほど見た `userCity`の例では次のように脱糖されます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:133
#, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root =\n"
"  child root \"profile\" >>= \\prof ->\n"
"    child prof \"address\" >>= \\addr ->\n"
"      child addr \"city\" >>= \\city ->\n"
"        pure city\n"
msgstr ""
"userCity :: XML -> Maybe XML\n"
"userCity root =\n"
"  child root \"profile\" >>= \\prof ->\n"
"    child prof \"address\" >>= \\addr ->\n"
"      child addr \"city\" >>= \\city ->\n"
"        pure city\n"

#. type: Plain text
#: text/chapter8.md:143
#, no-wrap
msgid "It is worth noting that code expressed using do notation is often much clearer than the equivalent code using the `>>=` operator. However, writing binds explicitly using `>>=` can often lead to opportunities to write code in _point-free_ form - but the usual warnings about readability apply.\n"
msgstr "do記法を使って表現されたコードは、`>>=`演算子を使って書かれた同じ意味のコードよりしばしば読みやすくなることも特筆すべき点です。一方で、明示的に `>>=`を使って束縛を書くと、しばしば*ポイントフリー*形式でコードが書けるようになります。ただし、読みやすさにはやはり注意がいります。\n"

#. type: Title ##
#: text/chapter8.md:144
#, no-wrap
msgid "Monad Laws"
msgstr "モナド則"

#. type: Plain text
#: text/chapter8.md:147
msgid ""
"The `Monad` type class comes equipped with three laws, called the _monad "
"laws_. These tell us what we can expect from sensible implementations of the "
"`Monad` type class."
msgstr ""
"`Monad`型クラスは*モナド則*と呼ばれる3つの規則を持っています。これらは "
"`Monad`型クラスの合理的な実装から何を期待できるかを教えてくれます。"

#. type: Plain text
#: text/chapter8.md:149
msgid "It is simplest to explain these laws using do notation."
msgstr "do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。"

#. type: Title ###
#: text/chapter8.md:150
#, no-wrap
msgid "Identity Laws"
msgstr "単位元律"

#. type: Plain text
#: text/chapter8.md:153
msgid ""
"The _right-identity_ law is the simplest of the three laws. It tells us that "
"we can eliminate a call to `pure` if it is the last expression in a do "
"notation block:"
msgstr ""
"*右単位元則* (right-identity law) が3つの規則の中で最も簡単です。この規則はdo"
"記法ブロックの最後の式であれば、`pure`の呼び出しを排除できると言っています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:154
#, no-wrap
msgid ""
"do\n"
"  x <- expr\n"
"  pure x\n"
msgstr ""
"do\n"
"  x <- expr\n"
"  pure x\n"

#. type: Plain text
#: text/chapter8.md:161
msgid "The right-identity law says that this is equivalent to just `expr`."
msgstr "右単位元則は、この式は単なる `expr`と同じだと言っています。"

#. type: Plain text
#: text/chapter8.md:163
msgid ""
"The _left-identity_ law states that we can eliminate a call to `pure` if it "
"is the first expression in a do notation block:"
msgstr ""
"*左単位元則* (left-identity law) は、もしそれがdo記法ブロックの最初の式であれ"
"ば、`pure`の呼び出しを除去できると述べています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:164
#, no-wrap
msgid ""
"do\n"
"  x <- pure y\n"
"  next\n"
msgstr ""
"do\n"
"  x <- pure y\n"
"  next\n"

#. type: Plain text
#: text/chapter8.md:171
msgid ""
"This code is equivalent to `next`, after the name `x` has been replaced with "
"the expression `y`."
msgstr "このコードは`next`の名前`x`を式`y`で置き換えたものと同じです。"

#. type: Plain text
#: text/chapter8.md:173
msgid ""
"The last law is the _associativity law_. It tells us how to deal with nested "
"do notation blocks. It states that the following piece of code:"
msgstr ""
"最後の規則は _結合則_ (associativity law) です。これは入れ子になったdo記法ブ"
"ロックをどう扱うのかについて教えてくれます。この規則が述べているのは以下の"
"コード片のことです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:174
#, no-wrap
msgid ""
"c1 = do\n"
"  y <- do\n"
"    x <- m1\n"
"    m2\n"
"  m3\n"
msgstr ""
"c1 = do\n"
"  y <- do\n"
"    x <- m1\n"
"    m2\n"
"  m3\n"

#. type: Plain text
#: text/chapter8.md:183
msgid "is equivalent to this code:"
msgstr "上記のコード片は、次のコードと同じです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:184
#, no-wrap
msgid ""
"c2 = do\n"
"  x <- m1\n"
"  y <- m2\n"
"  m3\n"
msgstr ""
"c2 = do\n"
"  x <- m1\n"
"  y <- m2\n"
"  m3\n"

#. type: Plain text
#: text/chapter8.md:192
msgid ""
"Each of these computations involves three monadic expression `m1`, `m2` and "
"`m3`. In each case, the result of `m1` is eventually bound to the name `x`, "
"and the result of `m2` is bound to the name `y`."
msgstr ""
"これらの計算にはそれぞれ、3つのモナドの式`m1`、`m2`、`m3`が含まれています。\n"
"どちらの場合でも`m1`の結果は名前`x`に束縛され、`m2`の結果は名前`y`に束縛され"
"ます。"

#. type: Plain text
#: text/chapter8.md:194
msgid ""
"In `c1`, the two expressions `m1` and `m2` are grouped into their own do "
"notation block."
msgstr ""
"`c1`では2つの式 `m1`と `m2`がそれぞれのdo記法ブロック内にグループ化されていま"
"す。"

#. type: Plain text
#: text/chapter8.md:196
msgid ""
"In `c2`, all three expressions `m1`, `m2` and `m3` appear in the same do "
"notation block."
msgstr ""
"`c2`では`m1`、`m2`、`m3`の3つ全ての式が同じdo記法ブロックに現れています。"

#. type: Plain text
#: text/chapter8.md:198
msgid ""
"The associativity law tells us that it is safe to simplify nested do "
"notation blocks in this way."
msgstr ""
"結合法則は入れ子になったdo記法ブロックをこのように単純化しても問題ないことを"
"言っています。"

#. type: Plain text
#: text/chapter8.md:200
msgid ""
"_Note_ that by the definition of how do notation gets desugared into calls "
"to `bind`, both of `c1` and `c2` are also equivalent to this code:"
msgstr ""
"*補足*：do記法を`bind`の呼び出しへと脱糖する定義により、 `c1`と `c2`は何れも"
"次のコードと同じです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:201
#, no-wrap
msgid ""
"c3 = do\n"
"  x <- m1\n"
"  do\n"
"    y <- m2\n"
"    m3\n"
msgstr ""
"c3 = do\n"
"  x <- m1\n"
"  do\n"
"    y <- m2\n"
"    m3\n"

#. type: Title ##
#: text/chapter8.md:209
#, no-wrap
msgid "Folding With Monads"
msgstr "モナドで畳み込む"

#. type: Plain text
#: text/chapter8.md:212
msgid ""
"As an example of working with monads abstractly, this section will present a "
"function which works with any type constructor in the `Monad` type class. "
"This should serve to solidify the intuition that monadic code corresponds to "
"programming \"in a larger language\" with side-effects, and also illustrate "
"the generality which programming with monads brings."
msgstr ""
"抽象的にモナドを扱う例として、この節では `Monad`型クラス中の任意の型構築子で"
"機能する関数を紹介していきます。\n"
"これはモナドによるコードが副作用を伴う「より大きな言語」でのプログラミングと"
"対応しているという直感的理解を補強しますし、モナドによるプログラミングがもた"
"らす一般性も示しています。"

#. type: Plain text
#: text/chapter8.md:214
msgid ""
"The function we will write is called `foldM`. It generalizes the `foldl` "
"function that we met earlier to a monadic context. Here is its type "
"signature:"
msgstr ""
"これから `foldM`と呼ばれる関数を書いてみます。これは以前扱った `foldl`関数を"
"モナドの文脈へと一般化します。型シグネチャは次のようになっています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:215
#, no-wrap
msgid ""
"foldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> List b -> m a\n"
"foldl :: forall   a b.            (a -> b ->   a) -> a -> List b ->   a\n"
msgstr ""
"foldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> List b -> m a\n"
"foldl :: forall   a b.            (a -> b ->   a) -> a -> List b ->   a\n"

#. type: Plain text
#: text/chapter8.md:221
msgid ""
"Notice that this is the same as the type of `foldl`, except for the "
"appearance of the monad `m`."
msgstr ""
"モナド `m`が現れている点を除いて、 `foldl`の型と同じであることに注意しましょ"
"う。"

#. type: Plain text
#: text/chapter8.md:223
msgid ""
"Intuitively, `foldM` performs a fold over a list in some context supporting "
"some set of side-effects."
msgstr ""
"直感的には、 `foldM`はさまざまな副作用の組み合わせに対応した文脈での配列の畳"
"み込みを行うと捉えることができます。"

#. type: Plain text
#: text/chapter8.md:225
msgid ""
"For example, if we picked `m` to be `Maybe`, then our fold would be allowed "
"to fail by returning `Nothing` at any stage - every step returns an optional "
"result, and the result of the fold is therefore also optional."
msgstr ""
"例として `m`が `Maybe`であるとすると、この畳み込みはそれぞれの段階で "
"`Nothing`を返すことで失敗させられます。\n"
"それぞれの段階ではオプショナルな結果を返しますから、それゆえ畳み込みの結果も"
"オプショナルになります。"

#. type: Plain text
#: text/chapter8.md:227
msgid ""
"If we picked `m` to be the `Array` type constructor, then every step of the "
"fold would be allowed to return zero or more results, and the fold would "
"proceed to the next step independently for each result. At the end, the set "
"of results would consist of all folds over all possible paths. This "
"corresponds to a traversal of a graph!"
msgstr ""
"もし `m`として配列の型構築子 `Array`を選ぶとすると、畳み込みのそれぞれの段階"
"で複数の結果を返すことができ、畳み込みは結果それぞれに対して次の手順を継続し"
"ます。\n"
"最後に、結果の集まりは、可能な経路全ての畳み込みから構成されることになりま"
"す。\n"
"これはグラフの走査と対応しています。"

#. type: Plain text
#: text/chapter8.md:229
msgid "To write `foldM`, we can simply break the input list into cases."
msgstr "`foldM`を書くには、単に入力のリストについて場合分けをするだけです。"

#. type: Plain text
#: text/chapter8.md:231
msgid ""
"If the list is empty, then to produce the result of type `a`, we only have "
"one option: we have to return the second argument:"
msgstr ""
"リストが空なら、型 `a`の結果を生成するための選択肢は1つしかありません。第2引"
"数を返します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:232
#, no-wrap
msgid "foldM _ a Nil = pure a\n"
msgstr "foldM _ a Nil = pure a\n"

#. type: Plain text
#: text/chapter8.md:237
msgid "Note that we have to use `pure` to lift `a` into the monad `m`."
msgstr ""
"なお`a`をモナド `m`まで持ち上げるために `pure`を使わなくてはいけません。"

#. type: Plain text
#: text/chapter8.md:239
#, no-wrap
msgid "What if the list is non-empty? In that case, we have a value of type `a`, a value of type `b`, and a function of type `a -> b -> m a`. If we apply the function, we obtain a monadic result of type `m a`. We can bind the result of this computation with a backwards arrow `<-`.\n"
msgstr ""
"リストが空でない場合はどうでしょうか。\n"
"その場合、型 `a`の値、型 `b`の値、型 `a -> b -> m a`の関数があります。\n"
"もしこの関数を適用すると、型 `m a`のモナドの結果を手に入れることになります。\n"
"この計算の結果を逆向きの矢印 `<-`で束縛できます。\n"

#. type: Plain text
#: text/chapter8.md:241
msgid ""
"It only remains to recurse on the tail of the list. The implementation is "
"simple:"
msgstr "あとはリストの残りに対して再帰するだけです。実装は簡単です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:242
#, no-wrap
msgid ""
"foldM f a (b : bs) = do\n"
"  a' <- f a b\n"
"  foldM f a' bs\n"
msgstr ""
"foldM f a (b : bs) = do\n"
"  a' <- f a b\n"
"  foldM f a' bs\n"

#. type: Plain text
#: text/chapter8.md:249
msgid ""
"Note that this implementation is almost identical to that of `foldl` on "
"lists, with the exception of do notation."
msgstr ""
"なお、do記法を除けば、この実装は配列に対する `foldl`の実装とほとんど同じで"
"す。"

#. type: Plain text
#: text/chapter8.md:251
msgid ""
"We can define and test this function in PSCi. Here is an example - suppose "
"we defined a \"safe division\" function on integers, which tested for "
"division by zero and used the `Maybe` type constructor to indicate failure:"
msgstr ""
"PSCiでこれを定義し、試してみましょう。\n"
"以下では例として、除算可能かどうかを調べて、失敗を示すために `Maybe`型構築子"
"を使う、整数の「安全な除算」関数を定義するとしましょう。"

#. type: Fenced code block (hs)
#: text/chapter8.md:252
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Examples.purs:safeDivide}}\n"
msgstr "{{#include ../exercises/chapter8/test/Examples.purs:safeDivide}}\n"

#. type: Plain text
#: text/chapter8.md:257
msgid "Then we can use `foldM` to express iterated safe division:"
msgstr "これで、 `foldM`で安全な除算の繰り返しを表現できます。"

#. type: Fenced code block (text)
#: text/chapter8.md:258
#, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.List (fromFoldable)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [5, 2, 2])\n"
"(Just 5)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [2, 0, 4])\n"
"Nothing\n"
msgstr ""
"> import Test.Examples\n"
"> import Data.List (fromFoldable)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [5, 2, 2])\n"
"(Just 5)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [2, 0, 4])\n"
"Nothing\n"

#. type: Plain text
#: text/chapter8.md:270
msgid ""
"The `foldM safeDivide` function returns `Nothing` if a division by zero was "
"attempted at any point. Otherwise it returns the result of repeatedly "
"dividing the accumulator, wrapped in the `Just` constructor."
msgstr ""
"もし何れかの時点で整数にならない除算が行われようとしたら、`foldM safeDivide`"
"関数は `Nothing`を返します。\n"
"そうでなければ、除算を繰り返した累積の結果を`Just`構築子に包んで返します。"

#. type: Title ##
#: text/chapter8.md:271
#, no-wrap
msgid "Monads and Applicatives"
msgstr "モナドとアプリカティブ"

#. type: Plain text
#: text/chapter8.md:274
msgid ""
"Every instance of the `Monad` type class is also an instance of the `Apply` "
"type class, by virtue of the superclass relationship between the two classes."
msgstr ""
"クラス間に上位クラス関係の効能があるため、`Monad`型クラスの全てのインスタンス"
"は `Apply`型クラスのインスタンスでもあります。"

#. type: Plain text
#: text/chapter8.md:276
msgid ""
"However, there is also an implementation of the `Apply` type class which "
"comes \"for free\" for any instance of `Monad`, given by the `ap` function:"
msgstr ""
"しかし、あらゆる`Monad`のインスタンスに「無料で」ついてくる`Apply`型クラスの"
"実装もあります。これは`ap`関数により与えられます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:277
#, no-wrap
msgid ""
"ap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\n"
"ap mf ma = do\n"
"  f <- mf\n"
"  a <- ma\n"
"  pure (f a)\n"
msgstr ""
"ap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\n"
"ap mf ma = do\n"
"  f <- mf\n"
"  a <- ma\n"
"  pure (f a)\n"

#. type: Plain text
#: text/chapter8.md:286
msgid ""
"If `m` is a law-abiding member of the `Monad` type class, then there is a "
"valid `Apply` instance for `m` given by `ap`."
msgstr ""
"もし`m`に`Monad`型クラスの法則の縛りがあれば、`ap`で与えられる`m`について妥当"
"な `Apply`インスタンスが存在します。"

#. type: Plain text
#: text/chapter8.md:288
msgid ""
"The interested reader can check that `ap` agrees with `apply` for the monads "
"we have already encountered: `Array`, `Maybe` and `Either e`."
msgstr ""
"興味のある読者は、これまで登場した `Array`、 `Maybe`、 `Either e`といったモナ"
"ドについて、この `ap`が `apply`と一致することを確かめてみてください。"

#. type: Plain text
#: text/chapter8.md:290
msgid ""
"If every monad is also an applicative functor, then we should be able to "
"apply our intuition for applicative functors to every monad. In particular, "
"we can reasonably expect a monad to correspond, in some sense, to "
"programming \"in a larger language\" augmented with some set of additional "
"side-effects. We should be able to lift functions of arbitrary arities, "
"using `map` and `apply`, into this new language."
msgstr ""
"もし全てのモナドがアプリカティブ関手でもあるなら、アプリカティブ関手について"
"の直感的理解を全てのモナドについても適用できるはずです。\n"
"特に、モナドが更なる副作用の組み合わせで増強された「より大きな言語」でのプロ"
"グラミングといろいろな意味で一致することを予想するのはもっともです。\n"
"`map`と `apply`を使って、引数が任意個の関数をこの新しい言語へと持ち上げること"
"ができるはずです。"

#. type: Plain text
#: text/chapter8.md:292
msgid ""
"But monads allow us to do more than we could do with just applicative "
"functors, and the key difference is highlighted by the syntax of do "
"notation. Consider the `userCity` example again, in which we looked for a "
"user's city in an XML document which encoded their user profile:"
msgstr ""
"しかし、モナドはアプリカティブ関手でできること以上を行うことができ、重要な違"
"いはdo記法の構文で強調されています。\n"
"利用者情報を符号化したXML文書から利用者の都市を検索する、`userCity`の例につい"
"てもう一度考えてみましょう。"

#. type: Plain text
#: text/chapter8.md:303
msgid ""
"Do notation allows the second computation to depend on the result `prof` of "
"the first, and the third computation to depend on the result `addr` of the "
"second, and so on. This dependence on previous values is not possible using "
"only the interface of the `Applicative` type class."
msgstr ""
"do記法では2番目の計算が最初の結果 `prof`に依存し、3番目の計算が2番目の計算の"
"結果`addr`に依存するというようなことができます。\n"
"`Applicative`型クラスのインターフェイスだけを使うのでは、このように以前の値へ"
"依存できません。"

#. type: Plain text
#: text/chapter8.md:305
msgid ""
"Try writing `userCity` using only `pure` and `apply`: you will see that it "
"is impossible. Applicative functors only allow us to lift function arguments "
"which are independent of each other, but monads allow us to write "
"computations which involve more interesting data dependencies."
msgstr ""
"`pure`と `apply`だけを使って `userCity`を書こうとしてみれば、これが不可能であ"
"ることがわかるでしょう。\n"
"アプリカティブ関手ができるのは関数の互いに独立した引数を持ち上げることだけで"
"すが、モナドはもっと興味深いデータの依存関係に関わる計算を書くことを可能にし"
"ます。"

#. type: Plain text
#: text/chapter8.md:307
msgid ""
"In the last chapter, we saw that the `Applicative` type class can be used to "
"express parallelism. This was precisely because the function arguments being "
"lifted were independent of one another. Since the `Monad` type class allows "
"computations to depend on the results of previous computations, the same "
"does not apply - a monad has to combine its side-effects in sequence."
msgstr ""
"前の章では `Applicative`型クラスは並列処理を表現できることを見ました。\n"
"持ち上げられた関数の引数は互いに独立していますから、これはまさにその通りで"
"す。\n"
"`Monad`型クラスは計算が前の計算の結果に依存できるようにしますから、同じように"
"はなりません。\n"
"モナドは副作用を順番に組み合わせなければいけません。"

#. type: Bullet: ' 1. '
#: text/chapter8.md:312
msgid ""
"(Easy) Write a function `third` which returns the third element of an array "
"with three or more elements. Your function should return an appropriate "
"`Maybe` type. _Hint:_ Look up the types of the `head` and `tail` functions "
"from the `Data.Array` module in the `arrays` package. Use do notation with "
"the `Maybe` monad to combine these functions."
msgstr ""
"（簡単）3つ以上の要素がある配列の3つ目の要素を返す関数`third`を書いてくださ"
"い。\n"
"関数は適切な`Maybe`型で返します。\n"
"*手掛かり*：`arrays`パッケージの`Data.Array`モジュールから`head`と`tail`関数"
"の型を見つけ出してください。\n"
"これらの関数を繋げるには`Maybe`モナドと共にdo記法を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter8.md:312
msgid ""
"(Medium) Write a function `possibleSums` which uses `foldM` to determine all "
"possible totals that could be made using a set of coins. The coins will be "
"specified as an array which contains the value of each coin. Your function "
"should have the following result:"
msgstr ""
"（普通）一掴みの硬貨を使ってできる可能な全ての合計を決定する関数 "
"`possibleSums`を、 `foldM`を使って書いてみましょう。\n"
"入力の硬貨は、硬貨の価値の配列として与えられます。この関数は次のような結果に"
"ならなくてはいけません。"

#. type: Plain text
#: text/chapter8.md:316
#, no-wrap
msgid ""
"     ```text\n"
"     > possibleSums []\n"
"     [0]\n"
msgstr ""
"     ```text\n"
"     > possibleSums []\n"
"     [0]\n"

#. type: Plain text
#: text/chapter8.md:320
#, no-wrap
msgid ""
"     > possibleSums [1, 2, 10]\n"
"     [0,1,2,3,10,11,12,13]\n"
"     ```\n"
msgstr ""
"     > possibleSums [1, 2, 10]\n"
"     [0,1,2,3,10,11,12,13]\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:325
#, no-wrap
msgid ""
"     _Hint_: This function can be written as a one-liner using `foldM`. You might want to use the `nub` and `sort` functions to remove duplicates and sort the result respectively.\n"
" 1. (Medium) Confirm that the `ap` function and the `apply` operator agree for the `Maybe` monad. _Note:_ There are no tests for this exercise.\n"
" 1. (Medium) Verify that the monad laws hold for the `Monad` instance for the `Maybe` type, as defined in the `maybe` package. _Note:_ There are no tests for this exercise.\n"
" 1. (Medium) Write a function `filterM` which generalizes the `filter` function on lists. Your function should have the following type signature:\n"
msgstr ""
"     *手掛かり*：`foldM`を使うと1行でこの関数を書くことが可能です。\n"
"     重複を取り除いたり、結果を並び替えたりするのに、`nub`関数や `sort`関数を使いたくなるかもしれません。\n"
"1. （普通）`Maybe`型構築子について、 `ap`関数と `apply`演算子が一致することを確認してください。\n"
"   *補足*：この演習にはテストがありません。\n"
"1. （普通）`maybe`パッケージで定義されている`Maybe`型についての `Monad`インスタンスが、モナド則を満たしていることを検証してください。\n"
"   *補足*：この演習にはテストがありません。\n"
"1. （普通）配列上の `filter`の関数を一般化した関数`filterM`を書いてください。\n"
"   この関数は次の型シグネチャを持ちます。\n"

#. type: Plain text
#: text/chapter8.md:329
#, no-wrap
msgid ""
"     ```hs\n"
"     filterM :: forall m a. Monad m => (a -> m Boolean) -> List a -> m (List a)\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     filterM :: forall m a. Monad m => (a -> m Boolean) -> List a -> m (List a)\n"
"     ```\n"

#. type: Bullet: ' 1. '
#: text/chapter8.md:331
msgid "(Difficult) Every monad has a default `Functor` instance given by:"
msgstr ""
"（難しい）全てのモナドには次で与えられるような既定の`Functor`インスタンスがあ"
"ります。"

#. type: Plain text
#: text/chapter8.md:337
#, no-wrap
msgid ""
"     ```hs\n"
"     map f a = do\n"
"       x <- a\n"
"       pure (f x)\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     map f a = do\n"
"       x <- a\n"
"       pure (f x)\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:339
#, no-wrap
msgid "     Use the monad laws to prove that for any monad, the following holds:\n"
msgstr "     モナド則を使って、全てのモナドが次を満たすことを証明してください。\n"

#. type: Plain text
#: text/chapter8.md:343
#, no-wrap
msgid ""
"     ```hs\n"
"     lift2 f (pure a) (pure b) = pure (f a b)\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     lift2 f (pure a) (pure b) = pure (f a b)\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:345
#, no-wrap
msgid "     where the `Apply` instance uses the `ap` function defined above. Recall that `lift2` was defined as follows:\n"
msgstr ""
"     ここで、 `Applly`インスタンスは上で定義された `ap`関数を使用しています。\n"
"     `lift2`が次のように定義されていたことを思い出してください。\n"

#. type: Plain text
#: text/chapter8.md:350
#, no-wrap
msgid ""
"     ```hs\n"
"     lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n"
"     lift2 f a b = f <$> a <*> b\n"
"     ```\n"
msgstr ""
"     ```hs\n"
"     lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n"
"     lift2 f a b = f <$> a <*> b\n"
"     ```\n"

#. type: Plain text
#: text/chapter8.md:352
#, no-wrap
msgid "    _Note:_ There are no tests for this exercise.\n"
msgstr "    *補足*：この演習にはテストがありません。\n"

#. type: Title ##
#: text/chapter8.md:353
#, no-wrap
msgid "Native Effects"
msgstr "ネイティブな作用"

#. type: Plain text
#: text/chapter8.md:356
msgid ""
"We will now look at one particular monad which is of central importance in "
"PureScript - the `Effect` monad."
msgstr ""
"ここではPureScriptの中核となる重要なモナド、 `Effect`モナドについて見ていきま"
"す。"

#. type: Plain text
#: text/chapter8.md:358
msgid ""
"The `Effect` monad is defined in the `Effect` module. It is used to manage "
"so-called _native_ side-effects. If you are familiar with Haskell, it is the "
"equivalent of the `IO` monad."
msgstr ""
"`Effect`モナドは `Effect`モジュールで定義されています。かつてはいわゆる _ネイ"
"ティブ_ 副作用を管理していました。Haskellに馴染みがあれば、これは`IO`モナドと"
"同等のものです。"

#. type: Plain text
#: text/chapter8.md:360
msgid ""
"What are native side-effects? They are the side-effects which distinguish "
"JavaScript expressions from idiomatic PureScript expressions, which "
"typically are free from side-effects. Some examples of native effects are:"
msgstr ""
"ネイティブな副作用とは何でしょうか。\n"
"この副作用はPureScript特有の式からJavaScriptの式を区別するものです。\n"
"PureScriptの式は概して副作用とは無縁なのです。\n"
"ネイティブな作用の例を以下に示します。"

#. type: Bullet: '- '
#: text/chapter8.md:365
msgid "Console IO"
msgstr "コンソール入出力"

#. type: Bullet: '- '
#: text/chapter8.md:365
msgid "Random number generation"
msgstr "乱数生成"

#. type: Bullet: '- '
#: text/chapter8.md:365
msgid "Reading/writing mutable state"
msgstr "変更可能な状態の読み書き"

#. type: Plain text
#: text/chapter8.md:367
msgid "And in the browser:"
msgstr "また、ブラウザでは次のようなものがあります。"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "DOM manipulation"
msgstr "DOM操作"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "XMLHttpRequest / AJAX calls"
msgstr "XMLHttpRequest / AJAX呼び出し"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "Interacting with a websocket"
msgstr "WebSocketによる相互作用"

#. type: Bullet: '- '
#: text/chapter8.md:372
msgid "Writing/reading to/from local storage"
msgstr "Local Storageの読み書き"

#. type: Plain text
#: text/chapter8.md:374
msgid "We have already seen plenty of examples of \"non-native\" side-effects:"
msgstr "既に「ネイティブでない」副作用の例については数多く見てきています。"

#. type: Bullet: '- '
#: text/chapter8.md:378
msgid "Optional values, as represented by the `Maybe` data type"
msgstr "`Maybe`データ型で表現される省略可能な値"

#. type: Bullet: '- '
#: text/chapter8.md:378
msgid "Errors, as represented by the `Either` data type"
msgstr "`Either`データ型で表現されるエラー"

#. type: Bullet: '- '
#: text/chapter8.md:378
msgid "Multi-functions, as represented by arrays or lists"
msgstr "配列やリストで表現される多値関数"

#. type: Plain text
#: text/chapter8.md:380
msgid ""
"Note that the distinction is subtle. It is true, for example, that an error "
"message is a possible side-effect of a JavaScript expression, in the form of "
"an exception. In that sense, exceptions do represent native side-effects, "
"and it is possible to represent them using `Effect`. However, error messages "
"implemented using `Either` are not a side-effect of the JavaScript runtime, "
"and so it is not appropriate to implement error messages in that style using "
"`Effect`. So it is not the effect itself which is native, but rather how it "
"is implemented at runtime."
msgstr ""
"これらの区別はわかりにくいので注意してください。\n"
"エラーメッセージは例外の形でJavaScriptの式の副作用となることがあります。\n"
"その意味では例外はネイティブな副作用を表していて、 `Effect`を使用して表現でき"
"ます。\n"
"しかし、 `Either`を使用して実装されたエラーメッセージはJavaScriptランタイムの"
"副作用ではなく、 `Effect`を使うスタイルでエラーメッセージを実装するのは適切で"
"はありません。\n"
"そのため、ネイティブなのは作用自体というより、実行時にどのように実装されてい"
"るかです。"

#. type: Title ##
#: text/chapter8.md:381
#, no-wrap
msgid "Side-Effects and Purity"
msgstr "副作用と純粋性"

#. type: Plain text
#: text/chapter8.md:384
msgid ""
"In a pure language like PureScript, one question which presents itself is: "
"without side-effects, how can one write useful real-world code?"
msgstr ""
"PureScriptのような言語が純粋であるとすると、疑問が浮かんできます。副作用がな"
"いなら、どうやって役に立つ実際のコードを書くことができるというのでしょうか。"

#. type: Plain text
#: text/chapter8.md:386
msgid ""
"The answer is that PureScript does not aim to eliminate side-effects. It "
"aims to represent side-effects in such a way that pure computations can be "
"distinguished from computations with side-effects in the type system. In "
"this sense, the language is still pure."
msgstr ""
"その答えはPureScriptの目的は副作用を排除することではないということです。これ"
"は、純粋な計算と副作用のある計算とを型システムにおいて区別できるような方法"
"で、副作用を表現することを目的としているのです。この意味で、言語はあくまで純"
"粋だということです。"

#. type: Plain text
#: text/chapter8.md:388
msgid ""
"Values with side-effects have different types from pure values. As such, it "
"is not possible to pass a side-effecting argument to a function, for "
"example, and have side-effects performed unexpectedly."
msgstr ""
"副作用のある値は、純粋な値とは異なる型を持っています。そういうわけで、例えば"
"副作用のある引数を関数に渡すことはできず、予期せず副作用を持つようなことが起"
"こらなくなります。"

#. type: Plain text
#: text/chapter8.md:390
msgid ""
"The only way in which side-effects managed by the `Effect` monad will be "
"presented is to run a computation of type `Effect a` from JavaScript."
msgstr ""
"`Effect`モナドで管理された副作用を実行する唯一の方法は、型 `Effect a`の計算を"
"JavaScriptから実行することです。"

#. type: Plain text
#: text/chapter8.md:392
msgid ""
"The Spago build tool (and other tools) provide a shortcut, by generating "
"additional JavaScript to invoke the `main` computation when the application "
"starts. `main` is required to be a computation in the `Effect` monad."
msgstr ""
"Spagoビルドツール（や他のツール）は早道を用意しており、アプリケーションの起動"
"時に`main`計算を呼び出すための追加のJavaScriptコードを生成します。\n"
"`main`は `Effect`モナドでの計算であることが要求されます。"

#. type: Plain text
#: text/chapter8.md:396
msgid ""
"The `Effect` monad provides a well-typed API for computations with side-"
"effects, while at the same time generating efficient JavaScript."
msgstr ""
"`Effect`は副作用のある計算を充分に型付けするAPIを提供すると同時に、効率的な"
"JavaScriptを生成します。"

#. type: Plain text
#: text/chapter8.md:399
msgid ""
"Let's take a closer look at the return type of the familiar `log` function. "
"`Effect` indicates that this function produces a native effect, console IO "
"in this case.  `Unit` indicates that no _meaningful_ data is returned. You "
"can think of `Unit` as being analogous to the `void` keyword in other "
"languages, such as C, Java, etc."
msgstr ""
"馴染みのある`log`関数から返る型をもう少し見てみましょう。\n"
"`Effect`はこの関数がネイティブな作用を生み出すことを示しており、この場合はコ"
"ンソールIOです。\n"
"`Unit`はいかなる*意味のある*データも返らないことを示しています。\n"
"`Unit`はC、Javaなど他の言語での`void`キーワードと似たようなものとして考えられ"
"ます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:400
#, no-wrap
msgid "log :: String -> Effect Unit\n"
msgstr "log :: String -> Effect Unit\n"

#. type: Plain text
#: text/chapter8.md:409
#, no-wrap
msgid ""
"> _Aside:_ You may encounter IDE suggestions for the more general (and more elaborately typed) `log` function from `Effect.Class.Console`. This is interchangeable with the one from `Effect.Console` when dealing with the basic `Effect` monad. Reasons for the more general version will become clearer after reading about \"Monad Transformers\" in the \"Monadic Adventures\" chapter. For the curious (and impatient), this works because there's a `MonadEffect` instance for `Effect`.\n"
">\n"
"> ```hs\n"
"> log :: forall m. MonadEffect m => String -> m Unit\n"
"> ```\n"
msgstr ""
"> _余談_ ：より一般的な（そしてより込み入った型を持つ）`Effect.Class.Console`の`log`関数をIDEから提案されるかもしれません。\n"
"> これは基本的な`Effect`モナドを扱う際は`Effect.Console`からの関数と交換可能です。\n"
"> より一般的なバージョンがあることの理由は「モナドな冒険」章の「モナド変換子」について読んだあとにより明らかになっていることでしょう。\n"
"> 好奇心のある（そしてせっかちな）読者のために言うと、これは`Effect`に`MonadEffect`インスタンスがあるから機能するのです。\n"
">\n"
"> ```hs\n"
"> log :: forall m. MonadEffect m => String -> m Unit\n"
"> ```\n"

#. type: Plain text
#: text/chapter8.md:411
msgid ""
"Now let's consider an `Effect` that returns meaningful data. The `random` "
"function from `Effect.Random` produces a random `Number`."
msgstr ""
"それでは意味のあるデータを返す`Effect`を考えましょう。\n"
"`Effect.Random`の`random`関数は乱択された`Number`を生み出します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:412
#, no-wrap
msgid "random :: Effect Number\n"
msgstr "random :: Effect Number\n"

#. type: Plain text
#: text/chapter8.md:417
msgid ""
"Here's a full example program (found in `test/Random.purs` of this chapter's "
"exercises folder)."
msgstr ""
"以下は完全なプログラムの例です（この章の演習フォルダの`test/Random.purs`にあ"
"ります）。"

#. type: Fenced code block (hs)
#: text/chapter8.md:418
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Random.purs}}\n"
msgstr "{{#include ../exercises/chapter8/test/Random.purs}}\n"

#. type: Plain text
#: text/chapter8.md:423
msgid ""
"Because `Effect` is a monad, we use do notation to _unwrap_ the data it "
"contains before passing this data on to the effectful `logShow` function. As "
"a refresher, here's the equivalent code written using the `bind` operator:"
msgstr ""
"`Effect`はモナドなので、do記法を使って含まれるデータを開封し、それからこの"
"データを作用のある`logShow`関数に渡します。\n"
"気分転換に、以下は`bind`演算子を使って書かれた同等なコードです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:424
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = random >>= logShow\n"
msgstr ""
"main :: Effect Unit\n"
"main = random >>= logShow\n"

#. type: Plain text
#: text/chapter8.md:430
msgid "Try running this yourself with:"
msgstr "これを手元で走らせてみてください。"

#. type: Fenced code block (shell)
#: text/chapter8.md:431
#, no-wrap
msgid "spago run --main Test.Random\n"
msgstr "spago run --main Test.Random\n"

#. type: Plain text
#: text/chapter8.md:436
msgid ""
"You should see a randomly chosen number between `0.0` and `1.0` printed to "
"the console."
msgstr ""
"コンソールに出力 `0.0`と `1.0`の間で無作為に選ばれた数が表示されるでしょう。"

#. type: Plain text
#: text/chapter8.md:438
#, no-wrap
msgid "> _Aside:_ `spago run` defaults to searching in the `Main` module for a `main` function. You may also specify an alternate module as an entry point with the `--main` flag, as is done in the above example. Just be sure that this alternate module also contains a `main` function.\n"
msgstr ""
"> 余談：`spago run`は既定で`Main`モジュールとその中の`main`関数を探索します。\n"
"`--main`フラグで代替のモジュールを入口として指定でき、上の例ではそうしています。\n"
"この代替のモジュールもまた`main`関数を含んでいることに注目してください。\n"

#. type: Plain text
#: text/chapter8.md:440
msgid ""
"Note that it's also possible to generate \"random\" (technically "
"pseudorandom) data without resorting to impure effectful code. We'll cover "
"these techniques in the \"Generative Testing\" chapter."
msgstr ""
"なお、不浄な作用付きのコードに訴えることなく、「乱択された」（技術的には疑似"
"乱択された）データも生成できます。\n"
"この技法は「テストを生成する」章で押さえます。"

#. type: Plain text
#: text/chapter8.md:442
msgid ""
"As mentioned previously, the `Effect` monad is of central importance to "
"PureScript. The reason why it's central is because it is the conventional "
"way to interoperate with PureScript's `Foreign Function Interface`, which "
"provides the mechanism to execute a program and perform side effects. While "
"it's desireable to avoid using the `Foreign Function Interface`, it's fairly "
"critical to understand how it works and how to use it, so I recommend "
"reading that chapter before doing any serious PureScript work. That said, "
"the `Effect` monad is fairly simple. It has a few helper functions, but "
"aside from that it doesn't do much except encapsulate side effects."
msgstr ""
"以前言及したように`Effect`モナドはPureScriptで核心的な重要さがあります。\n"
"なぜ核心かというと、それはPureScriptの`外部関数インターフェース`とやりとりす"
"る上での常套手段だからです。\n"
"`外部関数インターフェース`はプログラムを実行したり副作用を発生させたりする仕"
"組みを提供します。\n"
"`外部関数インターフェース`を使うことは避けるのが望ましいのですが、どのように"
"動作しどう使うのか理解することもまた極めて大事なことですので、実際に"
"PureScriptで何か動かす前にその章を読まれることをお勧めします。\n"
"要は`Effect`モナドは結構単純なのです。幾つかの補助関数がありますが、それを差"
"し置いても副作用を内包すること以外には大したことはしません。"

#. type: Plain text
#: text/chapter8.md:446
msgid ""
"Let's examine a function from the `node-fs` package that involves two "
"_native_ side effects: reading mutable state, and exceptions:"
msgstr ""
"2つの _ネイティブな_ 副作用が絡む`node-fs`パッケージの関数を調べましょう。こ"
"こでの副作用は可変状態の読み取りと例外です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:447
#, no-wrap
msgid "readTextFile :: Encoding -> String -> Effect String\n"
msgstr "readTextFile :: Encoding -> String -> Effect String\n"

#. type: Plain text
#: text/chapter8.md:452
msgid "If we attempt to read a file that does not exist:"
msgstr "もし存在しないファイルを読もうとすると……"

#. type: Fenced code block (hs)
#: text/chapter8.md:453
#, no-wrap
msgid ""
"import Node.Encoding (Encoding(..))\n"
"import Node.FS.Sync (readTextFile)\n"
"\n"
"main :: Effect Unit\n"
"main = do\n"
"  lines <- readTextFile UTF8 \"iDoNotExist.md\"\n"
"  log lines\n"
msgstr ""
"import Node.Encoding (Encoding(..))\n"
"import Node.FS.Sync (readTextFile)\n"
"\n"
"main :: Effect Unit\n"
"main = do\n"
"  lines <- readTextFile UTF8 \"iDoNotExist.md\"\n"
"  log lines\n"

#. type: Plain text
#: text/chapter8.md:464
msgid "We encounter the following exception:"
msgstr "以下の例外に遭遇します。"

#. type: Fenced code block (text)
#: text/chapter8.md:465
#, no-wrap
msgid ""
"    throw err;\n"
"    ^\n"
"Error: ENOENT: no such file or directory, open 'iDoNotExist.md'\n"
"...\n"
"  errno: -2,\n"
"  syscall: 'open',\n"
"  code: 'ENOENT',\n"
"  path: 'iDoNotExist.md'\n"
msgstr ""
"    throw err;\n"
"    ^\n"
"Error: ENOENT: no such file or directory, open 'iDoNotExist.md'\n"
"...\n"
"  errno: -2,\n"
"  syscall: 'open',\n"
"  code: 'ENOENT',\n"
"  path: 'iDoNotExist.md'\n"

#. type: Plain text
#: text/chapter8.md:477
msgid ""
"To manage this exception gracefully, we can wrap the potentially problematic "
"code in `try` to handle either outcome:"
msgstr ""
"この例外をうまく管理するには、潜在的に問題があるコードを`try`に包めばどのよう"
"な出力でも制御できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:478
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = do\n"
"  result <- try $ readTextFile UTF8 \"iDoNotExist.md\"\n"
"  case result of\n"
"    Right lines -> log $ \"Contents: \\n\" <> lines\n"
"    Left  error -> log $ \"Couldn't open file. Error was: \" <> message error\n"
msgstr ""
"main :: Effect Unit\n"
"main = do\n"
"  result <- try $ readTextFile UTF8 \"iDoNotExist.md\"\n"
"  case result of\n"
"    Right lines -> log $ \"Contents: \\n\" <> lines\n"
"    Left  error -> log $ \"Couldn't open file. Error was: \" <> message error\n"

#. type: Plain text
#: text/chapter8.md:488
msgid ""
"`try` runs an `Effect` and returns eventual exceptions as a `Left` value. If "
"the computation succeeds, the result gets wrapped in a `Right`:"
msgstr ""
"`try`は`Effect`を走らせて起こりうる例外を`Left`値として返します。\n"
"もし計算が成功すれば結果は`Right`に包まれます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:489
#, no-wrap
msgid "try :: forall a. Effect a -> Effect (Either Error a)\n"
msgstr "try :: forall a. Effect a -> Effect (Either Error a)\n"

#. type: Plain text
#: text/chapter8.md:494
msgid ""
"We can also generate our own exceptions. Here is an alternative "
"implementation of `Data.List.head` which throws an exception if the list is "
"empty, rather than returning a `Maybe` value of `Nothing`."
msgstr ""
"独自の例外も生成できます。\n"
"以下は`Data.List.head`の代替実装で、`Maybe`の値の`Nothing`を返す代わりにリス"
"トが空のとき例外を投げます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:495
#, no-wrap
msgid ""
"exceptionHead :: List Int -> Effect Int\n"
"exceptionHead l = case l of\n"
"  x : _ -> pure x\n"
"  Nil -> throwException $ error \"empty list\"\n"
msgstr ""
"exceptionHead :: List Int -> Effect Int\n"
"exceptionHead l = case l of\n"
"  x : _ -> pure x\n"
"  Nil -> throwException $ error \"empty list\"\n"

#. type: Plain text
#: text/chapter8.md:503
msgid ""
"Note that the `exceptionHead` function is a somewhat impractical example, as "
"it is best to avoid generating exceptions in PureScript code and instead use "
"non-native effects such as `Either` and `Maybe` to manage errors and missing "
"values."
msgstr ""
"ただし`exceptionHead`関数はどこかしら非実用的な例です。\n"
"というのも、PureScriptのコードで例外を生成するのは避け、代わりに`Either`や"
"`Maybe`のようなネイティブでない作用でエラーや欠けた値を使うのが一番だからで"
"す。"

#. type: Title ##
#: text/chapter8.md:504
#, no-wrap
msgid "Mutable State"
msgstr "可変状態"

#. type: Plain text
#: text/chapter8.md:507
msgid "There is another effect defined in the core libraries: the `ST` effect."
msgstr ""
"中核ライブラリには `ST`作用という、これまた別の作用も定義されています。"

#. type: Plain text
#: text/chapter8.md:509
msgid ""
"The `ST` effect is used to manipulate mutable state. As pure functional "
"programmers, we know that shared mutable state can be problematic. However, "
"the `ST` effect uses the type system to restrict sharing in such a way that "
"only safe _local_ mutation is allowed."
msgstr ""
"`ST`作用は変更可能な状態を操作するために使われます。\n"
"純粋関数プログラミングを知っているなら、共有される変更可能な状態は問題を引き"
"起こしやすいということも知っているでしょう。\n"
"しかし、`ST`作用は型システムを使って安全で*局所的な*状態変化を可能にし、状態"
"の共有を制限するのです。"

#. type: Plain text
#: text/chapter8.md:511
msgid ""
"The `ST` effect is defined in the `Control.Monad.ST` module. To see how it "
"works, we need to look at the types of its actions:"
msgstr ""
"`ST`作用は `Control.Monad.ST`モジュールで定義されています。これがどのように動"
"作するかを確認するには、そのアクションの型を見る必要があります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:512
#, no-wrap
msgid ""
"new :: forall a r. a -> ST r (STRef r a)\n"
"\n"
"read :: forall a r. STRef r a -> ST r a\n"
"\n"
"write :: forall a r. a -> STRef r a -> ST r a\n"
"\n"
"modify :: forall r a. (a -> a) -> STRef r a -> ST r a\n"
msgstr ""
"new :: forall a r. a -> ST r (STRef r a)\n"
"\n"
"read :: forall a r. STRef r a -> ST r a\n"
"\n"
"write :: forall a r. a -> STRef r a -> ST r a\n"
"\n"
"modify :: forall r a. (a -> a) -> STRef r a -> ST r a\n"

#. type: Plain text
#: text/chapter8.md:523
msgid ""
"`new` is used to create a new mutable reference cell of type `STRef r a`, "
"which can be read using the `read` action, and modified using the `write` "
"and `modify` actions. The type `a` is the type of the value stored in the "
"cell, and the type `r` is used to indicate a _memory region_ (or _heap_) in "
"the type system."
msgstr ""
"`new`は型`STRef r a`の変更可能な参照領域を新しく作るのに使われます。\n"
"`STRef r a`は `read`アクションを使って状態を読み取ったり、`write`アクション"
"や `modify`アクションで状態を変更するのに使われます。\n"
"型`a`は領域に格納された値の型で、型 `r`は型システムで*メモリ領域*（または*"
"ヒープ*）を表しています。"

#. type: Plain text
#: text/chapter8.md:525
msgid ""
"Here is an example. Suppose we want to simulate the movement of a particle "
"falling under gravity by iterating a simple update function over a large "
"number of small time steps."
msgstr ""
"例を示します。小さな時間刻みで簡単な更新関数の実行を何度も繰り返すことによっ"
"て、重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。"

#. type: Plain text
#: text/chapter8.md:527
msgid ""
"We can do this by creating a mutable reference cell to hold the position and "
"velocity of the particle, and then using a `for` loop to update the value "
"stored in that cell:"
msgstr ""
"粒子の位置と速度を保持する変更可能な参照領域を作成し、領域に格納された値を更"
"新するのにforループを使うことでこれを実現できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:528
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Monad.ST.Ref (modify, new, read)\n"
"import Control.Monad.ST (ST, for, run)\n"
"\n"
"simulate :: forall r. Number -> Number -> Int -> ST r Number\n"
"simulate x0 v0 time = do\n"
"  ref <- new { x: x0, v: v0 }\n"
"  for 0 (time * 1000) \\_ ->\n"
"    modify\n"
"      ( \\o ->\n"
"          { v: o.v - 9.81 * 0.001\n"
"          , x: o.x + o.v * 0.001\n"
"          }\n"
"      )\n"
"      ref\n"
"  final <- read ref\n"
"  pure final.x\n"
msgstr ""
"import Prelude\n"
"\n"
"import Control.Monad.ST.Ref (modify, new, read)\n"
"import Control.Monad.ST (ST, for, run)\n"
"\n"
"simulate :: forall r. Number -> Number -> Int -> ST r Number\n"
"simulate x0 v0 time = do\n"
"  ref <- new { x: x0, v: v0 }\n"
"  for 0 (time * 1000) \\_ ->\n"
"    modify\n"
"      ( \\o ->\n"
"          { v: o.v - 9.81 * 0.001\n"
"          , x: o.x + o.v * 0.001\n"
"          }\n"
"      )\n"
"      ref\n"
"  final <- read ref\n"
"  pure final.x\n"

#. type: Plain text
#: text/chapter8.md:550
msgid ""
"At the end of the computation, we read the final value of the reference "
"cell, and return the position of the particle."
msgstr ""
"計算の最後では、参照領域の最終的な値を読み取り、粒子の位置を返しています。"

#. type: Plain text
#: text/chapter8.md:552
msgid ""
"Note that even though this function uses mutable state, it is still a pure "
"function, so long as the reference cell `ref` is not allowed to be used by "
"other parts of the program. We will see that this is exactly what the `ST` "
"effect disallows."
msgstr ""
"なお、この関数が変更可能な状態を使っていても、その参照領域`ref`がプログラムの"
"他の部分で使われるのが許されない限り、これは純粋な関数のままです。\n"
"`ST`作用が禁止するものが正確には何であるのかについては後ほど見ます。"

#. type: Plain text
#: text/chapter8.md:554
msgid ""
"To run a computation with the `ST` effect, we have to use the `run` function:"
msgstr "`ST`作用付きで計算するには、`run`関数を使用する必要があります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:555
#, no-wrap
msgid "run :: forall a. (forall r. ST r a) -> a\n"
msgstr "run :: forall a. (forall r. ST r a) -> a\n"

#. type: Plain text
#: text/chapter8.md:560
msgid ""
"The thing to notice here is that the region type `r` is quantified _inside "
"the parentheses_ on the left of the function arrow. That means that whatever "
"action we pass to `run` has to work with _any region_ `r` whatsoever."
msgstr ""
"ここで注目して欲しいのは、領域型 `r`が関数矢印の左辺にある*括弧の内側で*量化"
"されているということです。\n"
"`run`に渡したどんなアクションでも、*任意の領域*`r`が何であれ動作するというこ"
"とを意味しています。"

#. type: Plain text
#: text/chapter8.md:562
msgid ""
"However, once a reference cell has been created by `new`, its region type is "
"already fixed, so it would be a type error to try to use the reference cell "
"outside the code delimited by `run`.  This is what allows `run` to safely "
"remove the `ST` effect, and turn `simulate` into a pure function!"
msgstr ""
"しかし、ひとたび参照領域が `new`によって作成されると、その領域の型は既に固定"
"されており、`run`によって限定されたコードの外側で参照領域を使おうとしても型エ"
"ラーになるでしょう。\n"
"`run`が安全に `ST`作用を除去でき、`simulate`を純粋関数にできるのはこれが理由"
"なのです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:563
#, no-wrap
msgid ""
"simulate' :: Number -> Number -> Int -> Number\n"
"simulate' x0 v0 time = run (simulate x0 v0 time)\n"
msgstr ""
"simulate' :: Number -> Number -> Int -> Number\n"
"simulate' x0 v0 time = run (simulate x0 v0 time)\n"

#. type: Plain text
#: text/chapter8.md:569
msgid "You can even try running this function in PSCi:"
msgstr "PSCiでもこの関数を実行してみることができます。"

#. type: Fenced code block (text)
#: text/chapter8.md:570
#, no-wrap
msgid ""
"> import Main\n"
"\n"
"> simulate' 100.0 0.0 0\n"
"100.00\n"
"\n"
"> simulate' 100.0 0.0 1\n"
"95.10\n"
"\n"
"> simulate' 100.0 0.0 2\n"
"80.39\n"
"\n"
"> simulate' 100.0 0.0 3\n"
"55.87\n"
"\n"
"> simulate' 100.0 0.0 4\n"
"21.54\n"
msgstr ""
"> import Main\n"
"\n"
"> simulate' 100.0 0.0 0\n"
"100.00\n"
"\n"
"> simulate' 100.0 0.0 1\n"
"95.10\n"
"\n"
"> simulate' 100.0 0.0 2\n"
"80.39\n"
"\n"
"> simulate' 100.0 0.0 3\n"
"55.87\n"
"\n"
"> simulate' 100.0 0.0 4\n"
"21.54\n"

#. type: Plain text
#: text/chapter8.md:590
msgid ""
"In fact, if we inline the definition of `simulate` at the call to `run`, as "
"follows:"
msgstr ""
"実は、もし `simulate`の定義を `run`の呼び出しのところへ埋め込むとすると、次の"
"ようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:591
#, no-wrap
msgid ""
"simulate :: Number -> Number -> Int -> Number\n"
"simulate x0 v0 time =\n"
"  run do\n"
"    ref <- new { x: x0, v: v0 }\n"
"    for 0 (time * 1000) \\_ ->\n"
"      modify\n"
"        ( \\o ->\n"
"            { v: o.v - 9.81 * 0.001\n"
"            , x: o.x + o.v * 0.001\n"
"            }\n"
"        )\n"
"        ref\n"
"    final <- read ref\n"
"    pure final.x\n"
msgstr ""
"simulate :: Number -> Number -> Int -> Number\n"
"simulate x0 v0 time =\n"
"  run do\n"
"    ref <- new { x: x0, v: v0 }\n"
"    for 0 (time * 1000) \\_ ->\n"
"      modify\n"
"        ( \\o ->\n"
"            { v: o.v - 9.81 * 0.001\n"
"            , x: o.x + o.v * 0.001\n"
"            }\n"
"        )\n"
"        ref\n"
"    final <- read ref\n"
"    pure final.x\n"

#. type: Plain text
#: text/chapter8.md:609
msgid ""
"then the compiler will notice that the reference cell is not allowed to "
"escape its scope, and can safely turn `ref` into a `var`. Here is the "
"generated JavaScript for `simulate` inlined with `run`:"
msgstr ""
"参照領域はそのスコープから逃れることができないことがコンパイラにわかります"
"し、安全に`ref`を`var`に変換できます。\n"
"`run`が埋め込まれた`simulate`に対して生成されたJavaScriptは次のようになりま"
"す。"

#. type: Fenced code block (javascript)
#: text/chapter8.md:610
#, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return (function __do() {\n"
"\n"
"        var ref = { value: { x: x0, v: v0 } };\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        return ref.value.x;\n"
"\n"
"      })();\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return (function __do() {\n"
"\n"
"        var ref = { value: { x: x0, v: v0 } };\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        return ref.value.x;\n"
"\n"
"      })();\n"
"    };\n"
"  };\n"
"};\n"

#. type: Plain text
#: text/chapter8.md:636
msgid ""
"Note that this resulting JavaScript is not as optimal as it could be. See "
"[this issue](https://github.com/purescript-contrib/purescript-book/"
"issues/121) for more details. The above snippet should be updated once that "
"issue is resolved."
msgstr ""
"なおこの結果として得られたJavaScriptは最適化の余地があります。\n"
"詳細は[この課題](https://github.com/purescript-contrib/purescript-book/"
"issues/121)を参照してください。\n"
"上記の抜粋はその課題が解決されたら更新されるでしょう。"

#. type: Plain text
#: text/chapter8.md:638
msgid ""
"For comparison, this is the generated JavaScript of the non-inlined form:"
msgstr "比較としてこちらが埋め込まれていない形式で生成されたJavaScriptです。"

#. type: Fenced code block (js)
#: text/chapter8.md:639
#, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return function __do() {\n"
"\n"
"        var ref = Control_Monad_ST_Internal[\"new\"]({ x: x0, v: v0 })();\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        var $$final = Control_Monad_ST_Internal.read(ref)();\n"
"        return $$final.x;\n"
"      };\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return function __do() {\n"
"\n"
"        var ref = Control_Monad_ST_Internal[\"new\"]({ x: x0, v: v0 })();\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        var $$final = Control_Monad_ST_Internal.read(ref)();\n"
"        return $$final.x;\n"
"      };\n"
"    };\n"
"  };\n"
"};\n"

#. type: Plain text
#: text/chapter8.md:665
msgid ""
"The `ST` effect is a good way to generate short JavaScript when working with "
"locally-scoped mutable state, especially when used together with actions "
"like `for`, `foreach`, and `while` which generate efficient loops."
msgstr ""
"局所的な変更可能状態を扱うとき、特に作用が絡むループを生成する`for`、 "
"`foreach`、 `while`のようなアクションを一緒に使うときには、`ST`作用は短い"
"JavaScriptを生成する良い方法となります。"

#. type: Bullet: '1. '
#: text/chapter8.md:671
msgid ""
"(Medium) Rewrite the `safeDivide` function as `exceptionDivide` and throw an "
"exception using `throwException` with the message `\"div zero\"` if the "
"denominator is zero."
msgstr ""
"（普通）`safeDivide`関数を書き直し、もし分母がゼロなら`throwException`を使っ"
"て文言`\"div zero\"`の例外を投げるようにしたものを`exceptionDivide`としてくだ"
"さい。"

#. type: Bullet: '1. '
#: text/chapter8.md:671
msgid ""
"(Medium) Write a function `estimatePi :: Int -> Number` that uses `n` terms "
"of the [Gregory Series](https://mathworld.wolfram.com/GregorySeries.html) to "
"calculate an approximation of `pi`. _Hints:_ You can pattern your answer "
"like the definition of `simulate` above. You might need to convert an `Int` "
"into a `Number` using `toNumber :: Int -> Number` from `Data.Int`."
msgstr ""
"（普通）関数`estimatePi :: Int -> Number`を書いてください。\n"
"この関数は`n`項[Gregory Series](https://mathworld.wolfram.com/GregorySeries."
"html)を使って`pi`の近似を計算するものです。\n"
"*手掛かり*：解答は上記の`simulate`の定義に倣うことができます。\n"
"また`Data.Int`の`toNumber :: Int -> Number`を使って、`Int`を`Number`に変換す"
"る必要があるかもしれません。"

#. type: Bullet: '1. '
#: text/chapter8.md:671
msgid ""
"(Medium) Write a function `fibonacci :: Int -> Int` to compute the `n`th "
"Fibonacci number, using `ST` to track the values of the previous two "
"Fibonacci numbers. Using PSCi, compare the speed of your new `ST`-based "
"implementation against the recursive implementation (`fib`) from Chapter 4."
msgstr ""
"（普通）`n`番目のフィボナッチ数を計算する関数`fibonacci :: Int -> Int`を書い"
"てください。`ST`を使って前の2つのフィボナッチ数の値を把握します。新しい`ST`に"
"基づく実装の実行速度を第4章の再帰実装に対して比較してください。"

#. type: Title ##
#: text/chapter8.md:672
#, no-wrap
msgid "DOM Effects"
msgstr "DOM作用"

#. type: Plain text
#: text/chapter8.md:675
msgid ""
"In the final sections of this chapter, we will apply what we have learned "
"about effects in the `Effect` monad to the problem of working with the DOM."
msgstr ""
"この章の最後の節では、`Effect`モナドでの作用についてこれまで学んだことを、実"
"際のDOM操作の問題に応用します。"

#. type: Plain text
#: text/chapter8.md:677
msgid ""
"There are a number of PureScript packages for working directly with the DOM, "
"or with open-source DOM libraries. For example:"
msgstr ""
"DOMを直接扱ったり、オープンソースのDOMライブラリを扱ったりするPureScriptパッ"
"ケージが沢山あります。\n"
"例えば以下です。"

#. type: Bullet: '- '
#: text/chapter8.md:681
msgid ""
"[`web-dom`](https://github.com/purescript-web/purescript-web-dom) provides "
"type definitions and low level interface implementations for the W3C DOM "
"spec."
msgstr ""
"[`web-dom`](https://github.com/purescript-web/purescript-web-dom)はW3C\n"
"のDOM規格に向けた型定義と低水準インターフェース実装を提供します。"

#. type: Bullet: '- '
#: text/chapter8.md:681
msgid ""
"[`web-html`](https://github.com/purescript-web/purescript-web-html) provides "
"type definitions and low level interface implementations for the W3C HTML5 "
"spec."
msgstr ""
"[`web-html`](https://github.com/purescript-web/purescript-web-html)はW3Cの"
"HTML5規格に向けた型定義と低水準インターフェース実装を提供します。"

#. type: Bullet: '- '
#: text/chapter8.md:681
msgid ""
"[`jquery`](https://github.com/paf31/purescript-jquery) is a set of bindings "
"to the [jQuery](http://jquery.org) library."
msgstr ""
"[`jquery`](http://github.com/paf31/purescript-jquery)は[jQuery](http://"
"jquery.org)ライブラリのバインディングの集まりです。"

#. type: Plain text
#: text/chapter8.md:683
msgid ""
"There are also PureScript libraries which build abstractions on top of these "
"libraries, such as"
msgstr ""
"上記のライブラリを抽象化するPureScriptライブラリもあります。\n"
"以下のようなものです。"

#. type: Bullet: '- '
#: text/chapter8.md:687
msgid ""
"[`thermite`](https://github.com/paf31/purescript-thermite), which builds on "
"[`react`](https://github.com/purescript-contrib/purescript-react)"
msgstr ""
"[`thermite`](https://github.com/paf31/purescript-thermite)は[`react`]"
"(https://github.com/purescript-contrib/purescript-react)を土台に構築されてい"
"ます。"

#. type: Bullet: '- '
#: text/chapter8.md:687
msgid ""
"[`react-basic-hooks`](https://github.com/megamaddu/purescript-react-basic-"
"hooks), which builds on [`react-basic`](https://github.com/lumihq/purescript-"
"react-basic)"
msgstr ""
"[`react-basic-hooks`](https://github.com/megamaddu/purescript-react-basic-"
"hooks)は[`react-basic`](https://github.com/lumihq/purescript-react-basic)を土"
"台に構築されています。"

#. type: Bullet: '- '
#: text/chapter8.md:687
msgid ""
"[`halogen`](https://github.com/purescript-halogen/purescript-halogen) which "
"provides a type-safe set of abstractions on top of a custom virtual DOM "
"library."
msgstr ""
"[`halogen`](https://github.com/purescript-halogen/purescript-halogen)は独自の"
"仮想DOMライブラリを土台とする型安全な一揃いの抽象化を提供します。"

#. type: Plain text
#: text/chapter8.md:689
msgid ""
"In this chapter, we will use the `react-basic-hooks` library to add a user "
"interface to our address book application, but the interested reader is "
"encouraged to explore alternative approaches."
msgstr ""
"この章では `react-basic-hooks`ライブラリを使用し、住所簿アプリケーションに"
"ユーザーインターフェイスを追加しますが、興味のあるユーザは異なるアプローチで"
"進めることをお勧めします。"

#. type: Title ##
#: text/chapter8.md:690
#, no-wrap
msgid "An Address Book User Interface"
msgstr "住所録のユーザーインターフェース"

#. type: Plain text
#: text/chapter8.md:693
msgid ""
"Using the `react-basic-hooks` library, we will define our application as a "
"React _component_. React components describe HTML elements in code as pure "
"data structures, which are then efficiently rendered to the DOM. In "
"addition, components can respond to events like button clicks. The `react-"
"basic-hooks` library uses the `Effect` monad to describe how to handle these "
"events."
msgstr ""
"`react-basic-hooks`ライブラリを使い、アプリケーションをReact*コンポーネント*"
"として定義していきます。ReactコンポーネントはHTML要素を純粋なデータ構造として"
"コードで記述します。それからこのデータ構造は効率的にDOMへ描画されます。加えて"
"コンポーネントはボタンクリックのようなイベントに応答できます。`react-basic-"
"hooks`ライブラリは`Effect`モナドを使ってこれらのイベントの制御方法を記述しま"
"す。"

#. type: Plain text
#: text/chapter8.md:695
msgid ""
"A full tutorial for the React library is well beyond the scope of this "
"chapter, but the reader is encouraged to consult its documentation where "
"needed. For our purposes, React will provide a practical example of the "
"`Effect` monad."
msgstr ""
"Reactライブラリの完全な入門はこの章の範囲をはるかに超えていますが、読者は必要"
"に応じて説明書を参照することをお勧めします。\n"
"目的に応じて、Reactは `Effect`モナドの実用的な例を提供してくれます。"

#. type: Plain text
#: text/chapter8.md:697
msgid ""
"We are going to build a form which will allow a user to add a new entry into "
"our address book. The form will contain text boxes for the various fields "
"(first name, last name, city, state, etc.), and an area in which validation "
"errors will be displayed. As the user types text into the text boxes, the "
"validation errors will be updated."
msgstr ""
"利用者が住所録に新しい項目を追加できるフォームを構築することにしましょう。\n"
"フォームには、さまざまなフィールド（姓、名前、都市、州など）のテキストボック"
"ス、及び検証エラーが表示される領域が含まれます。\n"
"テキストボックスに利用者がテキストを入力すると、検証エラーが更新されます。"

#. type: Plain text
#: text/chapter8.md:699
msgid ""
"To keep things simple, the form will have a fixed shape: the different phone "
"number types (home, cell, work, other) will be expanded into separate text "
"boxes."
msgstr ""
"簡潔さを保つために、フォームは固定の形状とします。電話番号は種類（自宅、携帯"
"電話、仕事、その他）ごとに別々のテキストボックスへ分けることにします。"

#. type: Plain text
#: text/chapter8.md:701
msgid ""
"You can launch the web app from the `exercises/chapter8` directory with the "
"following commands:"
msgstr ""
"`exercises/chapter8`ディレクトリから以下のコマンドでWebアプリを立ち上げること"
"ができます。"

#. type: Fenced code block (shell)
#: text/chapter8.md:702
#, no-wrap
msgid ""
"$ npm install\n"
"$ npx spago build\n"
"$ npx parcel src/index.html --open\n"
msgstr ""
"$ npm install\n"
"$ npx spago build\n"
"$ npx parcel src/index.html --open\n"

#. type: Plain text
#: text/chapter8.md:709
msgid ""
"If development tools such as `spago` and `parcel` are installed globally, "
"then the `npx` prefix may be omitted. You have likely already installed "
"`spago` globally with `npm i -g spago`, and the same can be done for "
"`parcel`."
msgstr ""
"もし`spago`や`parcel`のような開発ツールが大域的にインストールされていれば、"
"`npx`の前置は省けるでしょう。\n"
"恐らく既に`spago`を`npm i -g spago`で大域的にインストールしていますし、"
"`parcel`についても同じことができるでしょう。"

#. type: Plain text
#: text/chapter8.md:711
msgid ""
"`parcel` should launch a browser window with our \"Address Book\" app. If "
"you keep the `parcel` terminal open, and rebuild with `spago` in another "
"terminal, the page should automatically refresh with your latest edits. You "
"can also configure automatic rebuilds (and therefore automatic page refresh) "
"on file-save if you're using an [editor](https://github.com/purescript/"
"documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors) that "
"supports [`purs ide`](https://github.com/purescript/purescript/tree/master/"
"psc-ide) or are running [`pscid`](https://github.com/kRITZCREEK/pscid)."
msgstr ""
"`parcel`は「アドレス帳」アプリのブラウザ窓を立ち上げます。\n"
"`parcel`の端末を開いたままにし、他の端末で`spago`で再構築すると、最新の編集を"
"含むページが自動的に再読み込みされるでしょう。\n"
"また、[`purs ide`](https://github.com/purescript/purescript/tree/master/psc-"
"ide)に対応していたり[`pscid`](https://github.com/kRITZCREEK/pscid)を走らせて"
"いたりする[エディタ](https://github.com/purescript/documentation/blob/master/"
"ecosystem/Editor-and-tool-support.md#editors)を使っていれば、ファイルを保存し"
"たときに自動的にページが再構築される（そして自動的にページが再読み込みされ"
"る）ように設定できます。"

#. type: Plain text
#: text/chapter8.md:713
msgid ""
"In this Address Book app, you should be able to enter some values into the "
"form fields and see the validation errors printed onto the page."
msgstr ""
"このアドレス帳アプリでフォームフィールドにいろいろな値を入力すると、ページ上"
"に出力された検証エラーを見ることができるでしょう。"

#. type: Plain text
#: text/chapter8.md:715
msgid "Let's explore how it works."
msgstr "動作の仕組みを散策しましょう。"

#. type: Plain text
#: text/chapter8.md:717
msgid "The `src/index.html` file is minimal:"
msgstr "`src/index.html`ファイルは最小限です。"

#. type: Fenced code block (html)
#: text/chapter8.md:718
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.html}}\n"
msgstr "{{#include ../exercises/chapter8/src/index.html}}\n"

#. type: Plain text
#: text/chapter8.md:723
#, no-wrap
msgid "The `<script` line includes the JavaScript entry point, `index.js`, which contains this single line:\n"
msgstr "`<script`の行にJavaScriptの入口が含まれており、`index.js`にはこの実質1行だけが含まれています。\n"

#. type: Fenced code block (js)
#: text/chapter8.md:724
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.js}}\n"
msgstr "{{#include ../exercises/chapter8/src/index.js}}\n"

#. type: Plain text
#: text/chapter8.md:729
msgid ""
"It calls our generated JavaScript equivalent of the `main` function of "
"`module Main` (`src/main.purs`). Recall that `spago build` puts all "
"generated JavaScript in the `output` directory."
msgstr ""
"`module Main` (`src/main.purs`) の`main`関数と等価な、生成したJavaScriptを呼"
"び出しています。\n"
"`spago build`は生成された全てのJavaScriptを`output`ディレクトリに置くことを思"
"い出してください。"

#. type: Plain text
#: text/chapter8.md:731
msgid ""
"The `main` function uses the DOM and HTML APIs to render our address book "
"component within the `container` element we defined in `index.html`:"
msgstr ""
"`main`関数はDOMとHTML APIを使い、`index.html`に定義した`container`要素の中に"
"アドレス帳コンポーネントを描画します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:732
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:main}}\n"
msgstr "{{#include ../exercises/chapter8/src/Main.purs:main}}\n"

#. type: Plain text
#: text/chapter8.md:737
msgid "Note that these three lines:"
msgstr "これら3行に注目してください。"

#. type: Fenced code block (hs)
#: text/chapter8.md:738
#, no-wrap
msgid ""
"w <- window\n"
"doc <- document w\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""
"w <- window\n"
"doc <- document w\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"

#. type: Plain text
#: text/chapter8.md:745
msgid "Can be consolidated to:"
msgstr "これは次のように統合できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:746
#, no-wrap
msgid ""
"doc <- document =<< window\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""
"doc <- document =<< window\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"

#. type: Plain text
#: text/chapter8.md:752
msgid "Or consolidated even further to:"
msgstr "あるいは更なる統合さえできます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:753
#, no-wrap
msgid ""
"ctr <- getElementById \"container\" <<< toNonElementParentNode =<< document =<< window\n"
"-- or, equivalently:\n"
"ctr <- window >>= document >>= toNonElementParentNode >>> getElementById \"container\"\n"
msgstr ""
"ctr <- getElementById \"container\" <<< toNonElementParentNode =<< document =<< window\n"
"-- or, equivalently:\n"
"ctr <- window >>= document >>= toNonElementParentNode >>> getElementById \"container\"\n"

#. type: Plain text
#: text/chapter8.md:760
msgid ""
"It is a matter of personal preference whether the intermediate `w` and `doc` "
"variables aid in readability."
msgstr ""
"途中の`w`や`doc`変数が読みやすさの助けになるかは主観的な好みの問題です。"

#. type: Plain text
#: text/chapter8.md:762
msgid ""
"Let's dig into our AddressBook `reactComponent`. We'll start with a "
"simplified component, and then build up to the actual code in `Main.purs`."
msgstr ""
"AddressBookの`reactComponent`を深堀りしましょう。\n"
"単純化されたコンポーネントから始め、それから`Main.purs`で実際のコードに構築し"
"ていきます。"

#. type: Plain text
#: text/chapter8.md:764
msgid ""
"Take a look at this minimal component. Feel free to substitute the full "
"component with this one to see it run:"
msgstr ""
"以下の最小限のコンポーネントをご覧ください。\n"
"遠慮なく全体のコンポーネントをこれに置き換えて実行の様子を見てみましょう。"

#. type: Fenced code block (hs)
#: text/chapter8.md:765
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp =\n"
"  reactComponent\n"
"    \"AddressBookApp\"\n"
"    (\\props -> pure $ D.text \"Hi! I'm an address book\")\n"
msgstr ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp =\n"
"  reactComponent\n"
"    \"AddressBookApp\"\n"
"    (\\props -> pure $ D.text \"Hi! I'm an address book\")\n"

#. type: Plain text
#: text/chapter8.md:774
msgid "`reactComponent` has this intimidating signature:"
msgstr "`reactComponent`にはこのような威圧的なシグネチャがあります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:775
#, no-wrap
msgid ""
"reactComponent ::\n"
"  forall hooks props.\n"
"  Lacks \"children\" props =>\n"
"  Lacks \"key\" props =>\n"
"  Lacks \"ref\" props =>\n"
"  String ->\n"
"  ({ | props } -> Render Unit hooks JSX) ->\n"
"  Effect (ReactComponent { | props })\n"
msgstr ""
"reactComponent ::\n"
"  forall hooks props.\n"
"  Lacks \"children\" props =>\n"
"  Lacks \"key\" props =>\n"
"  Lacks \"ref\" props =>\n"
"  String ->\n"
"  ({ | props } -> Render Unit hooks JSX) ->\n"
"  Effect (ReactComponent { | props })\n"

#. type: Plain text
#: text/chapter8.md:787
msgid ""
"The important points to note are the arguments after all the type class "
"constraints. It takes a `String` (an arbitrary component name), a function "
"that describes how to convert `props` into rendered `JSX`, and returns our "
"`ReactComponent` wrapped in an `Effect`."
msgstr ""
"重要な注意点は全ての型クラス制約の後の引数にあります。\n"
"`String`（任意のコンポーネント名）、`props`を描画された`JSX`に変換する方法を"
"記述する関数を取り、そして`Effect`に包まれた`ReactComponent`を返します。"

#. type: Plain text
#: text/chapter8.md:789
msgid "The props-to-JSX function is simply:"
msgstr "propsからJSXへの関数は単にこうです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:790
#, no-wrap
msgid "\\props -> pure $ D.text \"Hi! I'm an address book\"\n"
msgstr "\\props -> pure $ D.text \"Hi! I'm an address book\"\n"

#. type: Plain text
#: text/chapter8.md:795
msgid ""
"`props` are ignored, `D.text` returns `JSX`, and `pure` lifts to rendered "
"JSX. Now `component` has everything it needs to produce the `ReactComponent`."
msgstr ""
"`props`は無視されており、`D.text`は`JSX`を返し、そして`pure`は描画されたJSXに"
"持ち上げます。\n"
"これで`component`には`ReactComponent`を生成するのに必要な全てがあります。"

#. type: Plain text
#: text/chapter8.md:797
msgid ""
"Next we'll examine some of the additional complexities of the full Address "
"Book component."
msgstr ""
"次に完全なアドレス帳コンポーネントにある幾つかの複雑な事柄をもう少し調べてい"
"きます。"

#. type: Plain text
#: text/chapter8.md:799
msgid "These are the first few lines of our full component:"
msgstr "これらは完全なコンポーネントの最初の数行です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:800
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp = do\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState examplePerson\n"
msgstr ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp = do\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState examplePerson\n"

#. type: Plain text
#: text/chapter8.md:808
msgid "We track `person` as a piece of state with the `useState` hook."
msgstr "`person`を`useState`フックの状態の一部として追跡します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:809
#, no-wrap
msgid "Tuple person setPerson <- useState examplePerson\n"
msgstr "Tuple person setPerson <- useState examplePerson\n"

#. type: Plain text
#: text/chapter8.md:814
msgid ""
"Note that you are free to break-up component state into multiple pieces of "
"state with multiple calls to `useState`. For example, we could rewrite this "
"app to use a separate piece of state for each record field of `Person`, but "
"that happens to result in a slightly less convenient architecture in this "
"case."
msgstr ""
"なお、複数回`useState`を呼び出すことで、コンポーネントの状態を複数の状態の部"
"品に分解することが自在にできます。\n"
"例えば`Person`のそれぞれのレコードフィールドについて分離した状態の部品を使っ"
"て、このアプリを書き直すことができるでしょう。\n"
"しかしこの場合にそうすると僅かに利便性を損なうアーキテクチャになってしまいま"
"す。"

#. type: Plain text
#: text/chapter8.md:816
msgid ""
"In other examples, you may encounter the `/\\` infix operator for `Tuple`. "
"This is equivalent to the above line:"
msgstr ""
"他の例では`Tuple`用の`/\\`中置演算子に出喰わすかもしれません。\n"
"これは先の行と等しいものです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:817
#, no-wrap
msgid "firstName /\\ setFirstName <- useState p.firstName\n"
msgstr "firstName /\\ setFirstName <- useState p.firstName\n"

#. type: Plain text
#: text/chapter8.md:822
msgid ""
"`useState` takes a default initial value and returns the current value and a "
"way to update the value. We can check the type of `useState` to gain more "
"insight of the types `person` and `setPerson`:"
msgstr ""
"`useState`は、既定の初期値を取って現在の値と値を更新する方法を取ります。\n"
"`useState`の型を確認すれば型`person`と`setPerson`についてより深い洞察が得られ"
"ます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:823
#, no-wrap
msgid ""
"useState ::\n"
"  forall state.\n"
"  state ->\n"
"  Hook (UseState state) (Tuple state ((state -> state) -> Effect Unit))\n"
msgstr ""
"useState ::\n"
"  forall state.\n"
"  state ->\n"
"  Hook (UseState state) (Tuple state ((state -> state) -> Effect Unit))\n"

#. type: Plain text
#: text/chapter8.md:831
msgid ""
"We can strip the `Hook (UseState state)` wrapper off of the return value "
"because `useState` is called within an `R.do` block. We'll elaborate on `R."
"do` later."
msgstr ""
"結果の値の梱包`Hook (UseState state)`は取り去ることができますが、それは"
"`useState`が`R.do`ブロックの中で呼ばれているからです。\n"
"`R.do`は後で詳述します。"

#. type: Plain text
#: text/chapter8.md:833
msgid "So now we can observe the following signatures:"
msgstr "さてこれで以下のシグネチャを観察できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:834
#, no-wrap
msgid ""
"person :: state\n"
"setPerson :: (state -> state) -> Effect Unit\n"
msgstr ""
"person :: state\n"
"setPerson :: (state -> state) -> Effect Unit\n"

#. type: Plain text
#: text/chapter8.md:840
msgid ""
"The specific type of `state` is determined by our initial default value. "
"`Person` `Record` in this case because that is the type of `examplePerson`."
msgstr ""
"`state`の限定された型は初期の既定値によって決定されます。\n"
"これは`examplePerson`の型なのでこの場合は`Person` `Record`です。"

#. type: Plain text
#: text/chapter8.md:842
msgid "`person` is how we access the current state at each rerender."
msgstr "`person`はそれぞれの再描画の時点で現在の状態にアクセスする方法です。"

#. type: Plain text
#: text/chapter8.md:844
msgid ""
"`setPerson` is how we update the state. We simply provide a function that "
"describes how to transform the current state to the new state. The record "
"update syntax is perfect for this when the type of `state` happens to be a "
"`Record`, for example:"
msgstr ""
"`setPerson`は状態を更新する方法です。\n"
"単に現在の状態を新しい状態に変形する方法を記述する関数を提供します。\n"
"`state`の型が偶然`Record`のときは、レコード更新構文がこれにぴったり合いま"
"す。\n"
"例えば以下。"

#. type: Fenced code block (hs)
#: text/chapter8.md:845
#, no-wrap
msgid ""
"setPerson (\\currentPerson -> currentPerson {firstName = \"NewName\"})\n"
"\n"
msgstr ""
"setPerson (\\currentPerson -> currentPerson {firstName = \"NewName\"})\n"
"\n"

#. type: Plain text
#: text/chapter8.md:851
msgid "or as shorthand:"
msgstr "あるいは短かく以下です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:852
#, no-wrap
msgid "setPerson _ {firstName = \"NewName\"}\n"
msgstr "setPerson _ {firstName = \"NewName\"}\n"

#. type: Plain text
#: text/chapter8.md:857
msgid ""
"Non-`Record` states can also follow this update pattern. See [this guide]"
"(https://github.com/megamaddu/purescript-react-basic-hooks/"
"pull/24#issuecomment-620300541) for more details on best practices."
msgstr ""
"`Record`でない状態もまた、この更新パターンに従います。\n"
"ベストプラクティスについて、より詳しいことは[この手引き](https://github.com/"
"megamaddu/purescript-react-basic-hooks/pull/24#issuecomment-620300541)を参照"
"してください。"

#. type: Plain text
#: text/chapter8.md:859
msgid ""
"Recall that `useState` is used within an `R.do` block. `R.do` is a special "
"react hooks variant of `do`. The `R.` prefix \"qualifies\" this as coming "
"from `React.Basic.Hooks`, and means we use their hooks-compatible version of "
"`bind` in the `R.do` block. This is known as a \"qualified do\". It lets us "
"ignore the `Hook (UseState state)` wrapping and bind the inner `Tuple` of "
"values to variables."
msgstr ""
"`useState`が`R.do`ブロックの中で使われていることを思い出しましょう。\n"
"`R.do`は`do`の特別なreactフックの派生です。\n"
"`R.`の前置はこれが`React.Basic.Hooks`から来たものとして「限定する」もので、"
"`R.do`ブロックの中でフック互換版の`bind`を使うことを意味しています。\n"
"これは「限定されたdo」として知られています。\n"
"`Hook (UseState state)`の梱包を無視し、内部の値の`Tuple`と変数に束縛してくれ"
"ます。"

#. type: Plain text
#: text/chapter8.md:861
msgid ""
"Another possible state management strategy is with `useReducer`, but that is "
"outside the scope of this chapter."
msgstr ""
"他の状態管理戦略として挙げられるのは`useReducer`ですが、それはこの章の範疇外"
"です。"

#. type: Plain text
#: text/chapter8.md:863
msgid "Rendering `JSX` occurs here:"
msgstr "以下では`JSX`の描画が行われています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:864
#, no-wrap
msgid ""
"pure\n"
"  $ D.div\n"
"      { className: \"container\"\n"
"      , children:\n"
"          renderValidationErrors errors\n"
"            <> [ D.div\n"
"                  { className: \"row\"\n"
"                  , children:\n"
"                      [ D.form_\n"
"                          $ [ D.h3_ [ D.text \"Basic Information\" ]\n"
"                            , formField \"First Name\" \"First Name\" person.firstName \\s ->\n"
"                                setPerson _ { firstName = s }\n"
"                            , formField \"Last Name\" \"Last Name\" person.lastName \\s ->\n"
"                                setPerson _ { lastName = s }\n"
"                            , D.h3_ [ D.text \"Address\" ]\n"
"                            , formField \"Street\" \"Street\" person.homeAddress.street \\s ->\n"
"                                setPerson _ { homeAddress { street = s } }\n"
"                            , formField \"City\" \"City\" person.homeAddress.city \\s ->\n"
"                                setPerson _ { homeAddress { city = s } }\n"
"                            , formField \"State\" \"State\" person.homeAddress.state \\s ->\n"
"                                setPerson _ { homeAddress { state = s } }\n"
"                            , D.h3_ [ D.text \"Contact Information\" ]\n"
"                            ]\n"
"                          <> renderPhoneNumbers\n"
"                      ]\n"
"                  }\n"
"              ]\n"
"      }\n"
msgstr ""
"pure\n"
"  $ D.div\n"
"      { className: \"container\"\n"
"      , children:\n"
"          renderValidationErrors errors\n"
"            <> [ D.div\n"
"                  { className: \"row\"\n"
"                  , children:\n"
"                      [ D.form_\n"
"                          $ [ D.h3_ [ D.text \"Basic Information\" ]\n"
"                            , formField \"First Name\" \"First Name\" person.firstName \\s ->\n"
"                                setPerson _ { firstName = s }\n"
"                            , formField \"Last Name\" \"Last Name\" person.lastName \\s ->\n"
"                                setPerson _ { lastName = s }\n"
"                            , D.h3_ [ D.text \"Address\" ]\n"
"                            , formField \"Street\" \"Street\" person.homeAddress.street \\s ->\n"
"                                setPerson _ { homeAddress { street = s } }\n"
"                            , formField \"City\" \"City\" person.homeAddress.city \\s ->\n"
"                                setPerson _ { homeAddress { city = s } }\n"
"                            , formField \"State\" \"State\" person.homeAddress.state \\s ->\n"
"                                setPerson _ { homeAddress { state = s } }\n"
"                            , D.h3_ [ D.text \"Contact Information\" ]\n"
"                            ]\n"
"                          <> renderPhoneNumbers\n"
"                      ]\n"
"                  }\n"
"              ]\n"
"      }\n"

#. type: Plain text
#: text/chapter8.md:896
msgid ""
"Here we produce `JSX` which represents the intended state of the DOM. This "
"JSX is typically created by applying functions corresponding to HTML tags (e."
"g. `div`, `form`, `h3`, `li`, `ul`, `label`, `input`) which create single "
"HTML elements. These HTML elements are actually React components themselves, "
"converted to JSX. There are usually three variants of each of these "
"functions:"
msgstr ""
"ここでDOMの意図した状態を表現する`JSX`を生成しています。このJSXはHTMLタグ"
"（例：`div`、`form`、`h3`、`li`、`ul`、`label`、`input`）に対応し、典型的には"
"単一のHTML要素を作る関数を適用することで作られます。これらのHTML要素は実は"
"ReactコンポーネントそのものによりJSXに変換されます。通常これらの関数にはそれ"
"ぞれ3つの種類があります。"

#. type: Bullet: '- '
#: text/chapter8.md:900
msgid "`div_`: Accepts an array of child elements. Uses default attributes."
msgstr ""
"`div_`: 子要素の配列を受け付けます。\n"
"既定の属性を使います。"

#. type: Bullet: '- '
#: text/chapter8.md:900
msgid ""
"`div`: Accepts a `Record` of attributes. An array of child elements may be "
"passed to the `children` field of this record."
msgstr ""
"`div`: 属性の`Record`を受け付けます。\n"
"子要素の配列をこのレコードの`children`フィールドに渡すことができます。"

#. type: Bullet: '- '
#: text/chapter8.md:900
msgid ""
"`div'`: Same as `div`, but returns the `ReactComponent` before conversion to "
"`JSX`."
msgstr ""
"`div'`: `div`と同じですが、`JSX`に変換する前に`ReactComponent`を返します。"

#. type: Plain text
#: text/chapter8.md:902
msgid ""
"To display validation errors (if any) at the top of our form, we create a "
"`renderValidationErrors` helper function that turns the `Errors` structure "
"into an array of JSX. This array is prepended to the rest of our form."
msgstr ""
"検証エラーをフォームの一番上に（もしあれば）表示するため、`Errors`構造体をJSX"
"の配列に変える`renderValidationErrors`補助関数を作ります。この配列はフォーム"
"の残り部分の手前に付けます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:903
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:renderValidationErrors}}\n"
msgstr "{{#include ../exercises/chapter8/src/Main.purs:renderValidationErrors}}\n"

#. type: Plain text
#: text/chapter8.md:908
msgid ""
"Note that since we are simply manipulating regular data structures here, we "
"can use functions like `map` to build up more interesting elements:"
msgstr ""
"なお、ここでは単に通常のデータ構造体を操作しているので、`map`のような関数を"
"使ってもっと面白い要素を構築できます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:909
#, no-wrap
msgid "children: [ D.ul_ (map renderError xs)]\n"
msgstr "children: [ D.ul_ (map renderError xs)]\n"

#. type: Plain text
#: text/chapter8.md:914
msgid ""
"We use the `className` property to define classes for CSS styling. We're "
"using the [Bootstrap](https://getbootstrap.com/) `stylesheet` for this "
"project, which is imported in `index.html`. For example, we want items in "
"our form arranged as `row`s, and validation errors to be emphasized with "
"`alert-danger` styling:"
msgstr ""
"`className`プロパティを使ってCSSスタイルのクラスを定義します。\n"
"このプロジェクトでは[Bootstrap](https://getbootstrap.com/)の`stylesheet`を"
"使っており、これは`index.html`でインポートされています。\n"
"例えばフォーム中のアイテムは`row`として配置されてほしいですし、検証エラーは"
"`alert-danger`の装飾で強調されていてほしいです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:915
#, no-wrap
msgid "className: \"alert alert-danger row\"\n"
msgstr "className: \"alert alert-danger row\"\n"

#. type: Plain text
#: text/chapter8.md:920
msgid ""
"A second helper function is `formField`, which creates a text input for a "
"single form field:"
msgstr ""
"2番目の補助関数は `formField`です。\n"
"これは、単一フォームフィールドのテキスト入力を作ります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:921
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:formField}}\n"
msgstr "{{#include ../exercises/chapter8/src/Main.purs:formField}}\n"

#. type: Plain text
#: text/chapter8.md:926
msgid ""
"Putting the `input` and display `text` in a `label` aids in accessibility "
"for screen readers."
msgstr ""
"`input`を置いて`label`の中に`text`を表示すると、スクリーンリーダーのアクセシ"
"ビリティの助けになります。"

#. type: Plain text
#: text/chapter8.md:928
msgid ""
"The `onChange` attribute allows us to describe how to respond to user input. "
"We use the `handler` function, which has the following type:"
msgstr ""
"`onChange`属性があれば利用者の入力に応答する方法を記述できます。`handler`関数"
"を使いますが、これは以下の型を持ちます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:929
#, no-wrap
msgid "handler :: forall a. EventFn SyntheticEvent a -> (a -> Effect Unit) -> EventHandler\n"
msgstr "handler :: forall a. EventFn SyntheticEvent a -> (a -> Effect Unit) -> EventHandler\n"

#. type: Plain text
#: text/chapter8.md:934
msgid ""
"For the first argument to `handler` we use `targetValue`, which provides the "
"value of the text within the HTML `input` element. It matches the signature "
"expected by `handler` where the type variable `a` in this case is `Maybe "
"String`:"
msgstr ""
"`handler`への最初の引数には`targetValue`を使いますが、これはHTMLの`input`要素"
"中のテキストの値を提供します。\n"
"この場合は型変数`a`が`Maybe String`で、`handler`が期待するシグネチャに合致し"
"ています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:935
#, no-wrap
msgid "targetValue :: EventFn SyntheticEvent (Maybe String)\n"
msgstr "targetValue :: EventFn SyntheticEvent (Maybe String)\n"

#. type: Plain text
#: text/chapter8.md:940
msgid ""
"In JavaScript, the `input` element's `onChange` event is actually "
"accompanied by a `String` value, but since strings in JavaScript can be "
"null, `Maybe` is used for safety."
msgstr ""
"JavaScriptでは`input`要素の`onChange`イベントは実は`String`値と一緒になってい"
"るのですが、JavaScriptの文字列はnullになりえるので、安全のために`Maybe`が使わ"
"れています。"

#. type: Plain text
#: text/chapter8.md:942
#, no-wrap
msgid "The second argument to `handler`, `(a -> Effect Unit)`, must therefore have this signature:\n"
msgstr "したがって`(a -> Effect Unit)`の`handler`への2つ目の引数は、このシグネチャを持ちます。\n"

#. type: Fenced code block (hs)
#: text/chapter8.md:943
#, no-wrap
msgid "Maybe String -> Effect Unit\n"
msgstr "Maybe String -> Effect Unit\n"

#. type: Plain text
#: text/chapter8.md:948
msgid ""
"It is a function that describes how to convert this `Maybe String` value "
"into our desired effect. We define a custom `handleValue` function for this "
"purpose and pass it to `handler` as follows:"
msgstr ""
"この関数は`Maybe String`値を求める作用に変換する方法を記述します。\n"
"この目的のために以下のように独自の`handleValue`関数を定義して`handler`を渡し"
"ます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:949
#, no-wrap
msgid ""
"onChange:\n"
"  let\n"
"    handleValue :: Maybe String -> Effect Unit\n"
"    handleValue (Just v) = setValue v\n"
"    handleValue Nothing  = pure unit\n"
"  in\n"
"    handler targetValue handleValue\n"
msgstr ""
"onChange:\n"
"  let\n"
"    handleValue :: Maybe String -> Effect Unit\n"
"    handleValue (Just v) = setValue v\n"
"    handleValue Nothing  = pure unit\n"
"  in\n"
"    handler targetValue handleValue\n"

#. type: Plain text
#: text/chapter8.md:960
msgid ""
"`setValue` is the function we provided to each `formField` call that takes a "
"string and makes the appropriate record-update call to the `setPerson` hook."
msgstr ""
"`setValue`はそれぞれの`formField`の呼び出しに与えた関数で、文字列を取り"
"`setPerson`フックに適切なレコード更新呼び出しを実施します。"

#. type: Plain text
#: text/chapter8.md:962
msgid "Note that `handleValue` can be substituted as:"
msgstr "なお`handleValue`は以下のようにも置き換えられます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:963
#, no-wrap
msgid "onChange: handler targetValue $ traverse_ setValue\n"
msgstr "onChange: handler targetValue $ traverse_ setValue\n"

#. type: Plain text
#: text/chapter8.md:968
msgid ""
"Feel free to investigate the definition of `traverse_` to see how both forms "
"are indeed equivalent."
msgstr ""
"`traverse_`の定義を調査して、両方の形式が確かに等価であることをご確認くださ"
"い。"

#. type: Plain text
#: text/chapter8.md:970
msgid ""
"That covers the basics of our component implementation. However, you should "
"read the source accompanying this chapter in order to get a full "
"understanding of the way the component works."
msgstr ""
"これでコンポーネント実装の基本を押さえました。しかし、コンポーネントの仕組み"
"を完全に理解するためには、この章に付随する出典元をお読みください。"

#. type: Plain text
#: text/chapter8.md:972
msgid ""
"Obviously, this user interface can be improved in a number of ways. The "
"exercises will explore some ways in which we can make the application more "
"usable."
msgstr ""
"明らかに、このユーザーインターフェースには改善すべき点が沢山あります。\n"
"演習ではアプリケーションがより使いやすくなるような方法を追究していきます。"

#. type: Plain text
#: text/chapter8.md:976
msgid ""
"Modify `src/Main.purs` in the following exercises. There are no unit tests "
"for these exercises."
msgstr ""
"以下の演習では`src/Main.purs`を変更してください。\n"
"これらの演習には単体試験はありません。"

#. type: Bullet: '1. '
#: text/chapter8.md:979
msgid "(Easy) Modify the application to include a work phone number text box."
msgstr ""
"（簡単）このアプリケーションを変更し、職場の電話番号を入力できるテキストボッ"
"クスを追加してください。"

#. type: Bullet: '1. '
#: text/chapter8.md:979
msgid ""
"(Medium) Right now the application shows validation errors collected in a "
"single \"pink-alert\" background.  Modify to give each validation error its "
"own pink-alert background by separating them with blank lines."
msgstr ""
"（普通）現時点でアプリケーションは検証エラーを単一の「pink-alert」背景に集め"
"て表示させています。\n"
"空の線で分割することにより、それぞれの検証エラーにpink-alert背景を持たせるよ"
"うに変更してください。"

#. type: Plain text
#: text/chapter8.md:982
#, no-wrap
msgid ""
"    _Hint_: Instead of using a `ul` element to show the validation errors in a list, modify the code to create one `div` with the `alert` and `alert-danger` styles for each error.\n"
"1. (Difficult, Extended) One problem with this user interface is that the validation errors are not displayed next to the form fields they originated from. Modify the code to fix this problem.\n"
msgstr ""
"    *手掛かり*：リスト中の検証エラーを表示するのに`ul`要素を使う代わりに、コードを変更し、それぞれのエラーに`alert`と`alert-danger`装飾を持つ`div`を作ってください。\n"
"1. （難しい、発展）このユーザーインターフェイスの問題の1つは、検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。コードを変更してこの問題を解決してください。\n"

#. type: Plain text
#: text/chapter8.md:984
#, no-wrap
msgid "    _Hint_: the error type returned by the validator should be extended to indicate which field caused the error. You might want to use the following modified `Errors` type:\n"
msgstr "    *手掛かり*：検証器によって返されるエラーの型は、エラーの原因となっているフィールドを示すために拡張する必要があります。次のような変更されたエラー型を使用したくなるでしょう。\n"

#. type: Plain text
#: text/chapter8.md:992
#, no-wrap
msgid ""
"    ```hs\n"
"    data Field = FirstNameField\n"
"               | LastNameField\n"
"               | StreetField\n"
"               | CityField\n"
"               | StateField\n"
"               | PhoneField PhoneType\n"
msgstr ""
"    ```hs\n"
"    data Field = FirstNameField\n"
"               | LastNameField\n"
"               | StreetField\n"
"               | CityField\n"
"               | StateField\n"
"               | PhoneField PhoneType\n"

#. type: Plain text
#: text/chapter8.md:994
#, no-wrap
msgid "    data ValidationError = ValidationError String Field\n"
msgstr "    data ValidationError = ValidationError String Field\n"

#. type: Plain text
#: text/chapter8.md:997
#, no-wrap
msgid ""
"    type Errors = Array ValidationError\n"
"    ```\n"
msgstr ""
"    type Errors = Array ValidationError\n"
"    ```\n"

#. type: Plain text
#: text/chapter8.md:999
#, no-wrap
msgid "    You will need to write a function which extracts the validation error for a particular `Field` from the `Errors` structure.\n"
msgstr "   `Error`構造体から特定の`Field`のための検証エラーを取り出す関数を書く必要があるでしょう。\n"

#. type: Plain text
#: text/chapter8.md:1003
msgid ""
"This chapter has covered a lot of ideas about handling side-effects in "
"PureScript:"
msgstr ""
"この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。"

#. type: Bullet: '- '
#: text/chapter8.md:1010
msgid "We met the `Monad` type class, and its connection to do notation."
msgstr "`Monad`型クラスとdo記法との関係性に出会いました。"

#. type: Bullet: '- '
#: text/chapter8.md:1010
msgid ""
"We introduced the monad laws, and saw how they allow us to transform code "
"written using do notation."
msgstr ""
"モナド則を導入し、do記法を使って書かれたコードを変換する方法を見ました。"

#. type: Bullet: '- '
#: text/chapter8.md:1010
msgid ""
"We saw how monads can be used abstractly, to write code which works with "
"different side-effects."
msgstr ""
"異なる副作用を扱うコードを書くために、モナドを抽象的に使う方法を見ました。"

#. type: Bullet: '- '
#: text/chapter8.md:1010
msgid ""
"We saw how monads are examples of applicative functors, how both allow us to "
"compute with side-effects, and the differences between the two approaches."
msgstr ""
"モナドがアプリカティブ関手の一例であること、両者がどのように副作用のある計算"
"を可能にするのかということ、そして2つの手法の違いを説明しました。"

#. type: Bullet: '- '
#: text/chapter8.md:1010
msgid ""
"The concept of native effects was defined, and we met the `Effect` monad, "
"which is used to handle native side-effects."
msgstr ""
"ネイティブな作用の概念を定義し、ネイティブな副作用を処理するために使用する "
"`Effect`モナドを導入しました。"

#. type: Bullet: '- '
#: text/chapter8.md:1010
msgid ""
"We used the `Effect` monad to handle a variety of effects: random number "
"generation, exceptions, console IO, mutable state, and DOM manipulation "
"using React."
msgstr ""
"乱数生成、例外、コンソール入出力、変更可能な状態、及びReactを使ったDOM操作と"
"いった、さまざまな作用を扱うために `Effect`モナドを使いました。"

#. type: Plain text
#: text/chapter8.md:1011
msgid ""
"The `Effect` monad is a fundamental tool in real-world PureScript code. It "
"will be used in the rest of the book to handle side-effects in a number of "
"other use-cases."
msgstr ""
"`Effect`モナドは実際のPureScriptコードにおける基本的なツールです。本書ではこ"
"のあとも、多くの場面で副作用を処理するために使っていきます。"

#. type: Title #
#: text/chapter9.md:1
#, no-wrap
msgid "Asynchronous Effects"
msgstr "非同期作用"

#. type: Plain text
#: text/chapter9.md:6
msgid ""
"This chapter focuses on the `Aff` monad, which is similar to the `Effect` "
"monad, but represents _asynchronous_ side-effects. We'll demonstrate "
"examples of asynchronously interacting with the filesystem and making HTTP "
"requests. We'll also cover how to manage sequential and parallel execution "
"of asynchronous effects."
msgstr ""
"この章では`Aff`モナドに集中します。これは`Effect`モナドに似ていますが、*非同"
"期*な副作用を表現するものです。ファイルシステムとやりとりしてHTTPリクエストを"
"作る、非同期な例を実演していきます。また非同期作用の直列ないし並列な実行の管"
"理方法も押さえます。"

#. type: Plain text
#: text/chapter9.md:10
msgid "New PureScript libraries introduced in this chapter are:"
msgstr "この章で導入する新しいPureScriptライブラリは以下です。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`aff` - defines the `Aff` monad."
msgstr "`aff` - `Aff`モナドを定義します。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`node-fs-aff` - asynchronous filesystem operations with `Aff`."
msgstr "`node-fs-aff` - `Aff`を使った非同期のファイルシステム操作。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`affjax` - HTTP requests with AJAX and `Aff`."
msgstr "`affjax` - AJAXと`Aff`を使ったHTTPリクエスト。"

#. type: Bullet: '- '
#: text/chapter9.md:15
msgid "`parallel` - parallel execution of `Aff`."
msgstr "`parallel` - `Aff`の並列実行。"

#. type: Plain text
#: text/chapter9.md:17
msgid ""
"When running outside of the browser (such as in our Node.js environment), "
"the `affjax` library requires the `xhr2` NPM module, which is listed as "
"dependency in the `package.json` of this chapter. Install that by running:"
msgstr ""
"（Node.js環境のような）ブラウザ外で実行する場合、`affjax`ライブラリは"
"`xhr2`NPMモジュールが必要です。\n"
"このモジュールはこの章の`package.json`中の依存関係に挙げられています。\n"
"以下を走らせてインストールします。"

#. type: Fenced code block (shell)
#: text/chapter9.md:18
#, no-wrap
msgid "$ npm install\n"
msgstr "$ npm install\n"

#. type: Title ##
#: text/chapter9.md:22
#, no-wrap
msgid "Asynchronous JavaScript"
msgstr "非同期なJavaScript"

#. type: Plain text
#: text/chapter9.md:25
msgid ""
"A convenient way to work with asynchronous code in JavaScript is with "
"[`async` and `await`](https://developer.mozilla.org/en-US/docs/Learn/"
"JavaScript/Asynchronous/Async_await). See [this article on asynchronous "
"JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/"
"Asynchronous/Introducing) for more background information."
msgstr ""
"JavaScriptで非同期なコードに取り組む上で便利な手段は[`async`と`await`]"
"(https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/"
"Async_await)です。\n"
"[非同期なJavaScriptに関するこの記事](https://developer.mozilla.org/en-US/"
"docs/Learn/JavaScript/Asynchronous/Introducing)を見るとより背景情報がわかりま"
"す。"

#. type: Plain text
#: text/chapter9.md:27
msgid ""
"Here is an example of using this technique to copy the contents of one file "
"to another file:"
msgstr ""
"以下は、この技法を使ってあるファイルの内容を別のファイルに複製する例です。"

#. type: Fenced code block (js)
#: text/chapter9.md:28
#, no-wrap
msgid ""
"import { promises as fsPromises } from 'fs'\n"
"\n"
"async function copyFile(file1, file2) {\n"
"  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });\n"
"  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });\n"
"}\n"
"\n"
"copyFile('file1.txt', 'file2.txt')\n"
".catch(e => {\n"
"  console.log('There was a problem with copyFile: ' + e.message);\n"
"});\n"
msgstr ""
"import { promises as fsPromises } from 'fs'\n"
"\n"
"async function copyFile(file1, file2) {\n"
"  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });\n"
"  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });\n"
"}\n"
"\n"
"copyFile('file1.txt', 'file2.txt')\n"
".catch(e => {\n"
"  console.log('There was a problem with copyFile: ' + e.message);\n"
"});\n"

#. type: Plain text
#: text/chapter9.md:43
msgid ""
"It is also possible to use callbacks or synchronous functions, but those are "
"less desireable because:"
msgstr ""
"コールバックや同期関数を使うことも可能ですが、以下の理由から望ましくありませ"
"ん。"

#. type: Bullet: '- '
#: text/chapter9.md:46
msgid ""
"Callbacks lead to excessive nesting, known as \"Callback Hell\" or the "
"\"Pyramid of Doom\"."
msgstr ""
"コールバックは過剰な入れ子に繋がります。これは「コールバック地獄」や「悪夢の"
"ピラミッド」として知られています。"

#. type: Bullet: '- '
#: text/chapter9.md:46
msgid "Synchronous functions block execution of the other code in your app."
msgstr "同期関数はアプリ中の他のコードの実行を堰き止めてしまいます。"

#. type: Title ##
#: text/chapter9.md:47
#, no-wrap
msgid "Asynchronous PureScript"
msgstr "非同期なPureScript"

#. type: Plain text
#: text/chapter9.md:50
msgid ""
"The `Aff` monad in PureScript offers similar ergonomics of JavaScript's "
"`async`/`await` syntax. Here is the same `copyFile` example from before, but "
"rewritten in PureScript using `Aff`:"
msgstr ""
"PureScriptでの`Aff`モナドはJavaScriptの`async`/`await`構文に似た人間工学を供"
"します。以下は前と同じ`copyFile`の例ですが、`Aff`を使ってPureScriptで書き換え"
"られています。"

#. type: Fenced code block (hs)
#: text/chapter9.md:51
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/Copy.purs:copyFile}}\n"
msgstr "{{#include ../exercises/chapter9/test/Copy.purs:copyFile}}\n"

#. type: Plain text
#: text/chapter9.md:56
msgid ""
"It is also possible to re-write the above snippet using callbacks or "
"synchronous functions (for example with `Node.FS.Async` and `Node.FS.Sync` "
"respectively), but those share the same downsides as discussed earlier with "
"JavaScript, and so that coding style is not recommended."
msgstr ""
"上のコード片をコールバックや同期関数を使って書き換えることも可能ですが（例え"
"ば`Node.FS.Async`や`Node.FS.Sync`をそれぞれ使います）、JavaScriptで前にお話し"
"したのと同じ短所がここでも通用するため、それらのコーディング形式は推奨されま"
"せん。"

#. type: Plain text
#: text/chapter9.md:58
msgid ""
"The syntax for working with `Aff` is very similar to working with `Effect`. "
"They are both monads, and can therefore be written with do notation."
msgstr ""
"`Aff`を扱う文法は`Effect`を扱うものと大変似ています。\n"
"どちらもモナドですし、したがってdo記法で書くことができます。"

#. type: Plain text
#: text/chapter9.md:60
msgid ""
"For example, if we look at the signature of `readTextFile`, we see that it "
"returns the file contents as a `String` wrapped in `Aff`:"
msgstr ""
"例えば`readTextFile`のシグネチャを見れば、これがファイルの内容を`String`と"
"し、`Aff`に包んで返していることがわかります。"

#. type: Fenced code block (hs)
#: text/chapter9.md:61
#, no-wrap
msgid "readTextFile :: Encoding -> FilePath -> Aff String\n"
msgstr "readTextFile :: Encoding -> FilePath -> Aff String\n"

#. type: Plain text
#: text/chapter9.md:66
#, no-wrap
msgid "We can \"unwrap\" the returned string with a bind arrow (`<-`) in do notation:\n"
msgstr "do記法中では束縛矢印 (`<-`) で返却された文字列を「開封」できます。\n"

#. type: Fenced code block (hs)
#: text/chapter9.md:67
#, no-wrap
msgid "my_data <- readTextFile UTF8 file1\n"
msgstr "my_data <- readTextFile UTF8 file1\n"

#. type: Plain text
#: text/chapter9.md:72
msgid "Then pass it as the string argument to `writeTextFile`:"
msgstr "それから`writeTextFile`に文字列引数として渡します。"

#. type: Fenced code block (hs)
#: text/chapter9.md:73
#, no-wrap
msgid "writeTextFile :: Encoding -> FilePath -> String -> Aff Unit\n"
msgstr "writeTextFile :: Encoding -> FilePath -> String -> Aff Unit\n"

#. type: Plain text
#: text/chapter9.md:78
msgid ""
"The only other notable feature unique to `Aff` in the above example is "
"`attempt`, which captures errors or exceptions encountered while running "
"`Aff` code and stores them in an `Either`:"
msgstr ""
"上の例で他に目を引く`Aff`固有の特徴は`attempt`のみです。これは`Aff`のコードの"
"実行中に遭遇したエラーや例外を捕捉して`Either`内に保管するものです。"

#. type: Fenced code block (hs)
#: text/chapter9.md:79
#, no-wrap
msgid "attempt :: forall a. Aff a -> Aff (Either Error a)\n"
msgstr "attempt :: forall a. Aff a -> Aff (Either Error a)\n"

#. type: Plain text
#: text/chapter9.md:84
msgid ""
"You should hopefully be able to draw on your knowledge of concepts from "
"previous chapters and combine this with the new `Aff` patterns learned in "
"the above `copyFile` example to tackle the following exercises:"
msgstr ""
"読者ならきっと、前の章から概念の知識を引き出し、その知識と上の`copyFile`の例"
"で学んだ新しい`Aff`パターンを組み合わせることで、以下の演習に挑戦できるでしょ"
"う。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:88
msgid ""
"(Easy) Write a `concatenateFiles` function which concatenates two text files."
msgstr ""
"（簡単）2つのテキストファイルを連結する関数`concatenateFiles`を書いてくださ"
"い。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:90
msgid ""
"(Medium) Write a function `concatenateMany` to concatenate multiple text "
"files, given an array of input file names and an output file name. _Hint_: "
"use `traverse`."
msgstr ""
"（普通）入力ファイル名の配列と出力ファイル名が与えられたとき、複数のテキスト"
"ファイルを連結する関数`concatenateMany`を書いてください。\n"
"*手掛かり*：`traverse`を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:92
msgid ""
"(Medium) Write a function `countCharacters :: FilePath -> Aff (Either Error "
"Int)` that returns the number of characters in a file, or an error if one is "
"encountered."
msgstr ""
"（普通）ファイル中の文字数を返すか、エラーがあればそれを返す関数"
"`countCharacters :: FilePath -> Aff (Either Error Int)`を書いてください。"

#. type: Title ##
#: text/chapter9.md:93
#, no-wrap
msgid "Additional Aff Resources"
msgstr "更なるAffの資料"

#. type: Plain text
#: text/chapter9.md:96
msgid ""
"If you haven't already taken a look at the [official Aff guide](https://"
"pursuit.purescript.org/packages/purescript-aff/), skim through that now. "
"It's not a direct prerequisite for completing the remaining exercises in "
"this chapter, but you may find it helpful to lookup some functions on "
"Pursuit."
msgstr ""
"もしまだ[公式のAffの手引き](https://pursuit.purescript.org/packages/"
"purescript-aff/)を見ていなければ、今ざっと目を通してください。\n"
"この章の残りの演習を完了する上で事前に必要なことではありませんが、Pursuitで何"
"らかの関数を見付けだす助けになるかもしれません。"

#. type: Plain text
#: text/chapter9.md:98
msgid ""
"You're also welcome to consult these supplemental resources too, but again, "
"the exercises in this chapter don't depend on them:"
msgstr ""
"以下の補足資料についてもあたってみるとよいでしょう。しかし繰り返しになります"
"がこの章の演習はこれらの内容に依りません。"

#. type: Bullet: '- '
#: text/chapter9.md:101
msgid "[Drew's Aff Post](https://blog.drewolson.org/asynchronous-purescript)"
msgstr ""
"[DrewのAffに関する投稿](https://blog.drewolson.org/asynchronous-purescript)"

#. type: Bullet: '- '
#: text/chapter9.md:101
msgid ""
"[Additional Aff Explanation and Examples](https://github.com/JordanMartinez/"
"purescript-jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-"
"Aff/src/03-Aff)"
msgstr ""
"[更なるAffの説明と例](https://github.com/JordanMartinez/purescript-jordans-"
"reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-Aff)"

#. type: Title ##
#: text/chapter9.md:102
#, no-wrap
msgid "A HTTP Client"
msgstr "HTTPクライアント"

#. type: Plain text
#: text/chapter9.md:107
msgid ""
"The `affjax` library offers a convenient way to make asynchronous AJAX HTTP "
"requests with `Aff`. Depending on what environment you are targeting you "
"need to use either the [purescript-affjax-web](https://github.com/purescript-"
"contrib/purescript-affjax-web) or the [purescript-affjax-node](https://"
"github.com/purescript-contrib/purescript-affjax-node) library.  In the rest "
"of this chapter we will be targeting node and thus using `purescript-affjax-"
"node`.  Consult the [Affjax docs](https://pursuit.purescript.org/packages/"
"purescript-affjax) for more usage information. Here is an example that makes "
"HTTP GET requests at a provided URL and returns the response body or an "
"error message:"
msgstr ""
"`affjax`ライブラリは`Aff`で非同期AJAX HTTP要求する便利な手段を提供します。\n"
"対象としている環境が何であるかによって、[purescript-affjax-web](https://"
"github.com/purescript-contrib/purescript-affjax-web)または[purescript-affjax-"
"node](https://github.com/purescript-contrib/purescript-affjax-node)のどちらか"
"のライブラリを使う必要があります。\n"
"この章の以降ではNodeを対象としていくので、`purescript-affjax-node`を使いま"
"す。\n"
"より詳しい使用上の情報は[affjaxのドキュメント](https://pursuit.purescript."
"org/packages/purescript-affjax)にあたってください。\n"
"以下は与えられたURLに向けてHTTP GETを要求し、応答本文ないしエラー文言を返す例"
"です。"

#. type: Fenced code block (hs)
#: text/chapter9.md:108
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/HTTP.purs:getUrl}}\n"
msgstr "{{#include ../exercises/chapter9/test/HTTP.purs:getUrl}}\n"

#. type: Plain text
#: text/chapter9.md:113
msgid ""
"When calling this in the repl, `launchAff_` is required to convert the `Aff` "
"to a repl-compatible `Effect`:"
msgstr ""
"これをREPLで呼び出す際は、`launchAff_`で`Aff`からREPLに互換性のある`Effect`へ"
"と変換する必要があります。"

#. type: Fenced code block (shell)
#: text/chapter9.md:114
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :pa\n"
"… import Prelude\n"
"… import Effect.Aff (launchAff_)\n"
"… import Effect.Class.Console (log)\n"
"… import Test.HTTP (getUrl)\n"
"…\n"
"… launchAff_ do\n"
"…   str <- getUrl \"https://reqres.in/api/users/1\"\n"
"…   log str\n"
"…\n"
"unit\n"
"{\"data\":{\"id\":1,\"email\":\"george.bluth@reqres.in\",\"first_name\":\"George\",\"last_name\":\"Bluth\", ...}}\n"
msgstr ""
"$ spago repl\n"
"\n"
"> :pa\n"
"… import Prelude\n"
"… import Effect.Aff (launchAff_)\n"
"… import Effect.Class.Console (log)\n"
"… import Test.HTTP (getUrl)\n"
"…\n"
"… launchAff_ do\n"
"…   str <- getUrl \"https://reqres.in/api/users/1\"\n"
"…   log str\n"
"…\n"
"unit\n"
"{\"data\":{\"id\":1,\"email\":\"george.bluth@reqres.in\",\"first_name\":\"George\",\"last_name\":\"Bluth\", ...}}\n"

#. type: Bullet: '1. '
#: text/chapter9.md:134
msgid ""
"(Easy) Write a function `writeGet` which makes an HTTP `GET` request to a "
"provided url, and writes the response body to a file."
msgstr ""
"（簡単）与えられたURLにHTTPの`GET`を要求し、応答本文をファイルに書き込む関数"
"`writeGet`を書いてください。"

#. type: Title ##
#: text/chapter9.md:135
#, no-wrap
msgid "Parallel Computations"
msgstr "並列計算"

#. type: Plain text
#: text/chapter9.md:138
msgid ""
"We've seen how to use the `Aff` monad and do notation to compose "
"asynchronous computations in sequence. It would also be useful to be able to "
"compose asynchronous computations _in parallel_. With `Aff`, we can compute "
"in parallel simply by initiating our two computations one after the other."
msgstr ""
"`Aff`モナドとdo記法を使って、非同期計算を順番に実行されるように合成する方法を"
"見てきました。\n"
"非同期計算を*並列にも*合成できたら便利でしょう。\n"
"`Aff`があれば2つの計算を次々に開始するだけで並列に計算できます。"

#. type: Plain text
#: text/chapter9.md:140
msgid ""
"The `parallel` package defines a type class `Parallel` for monads like `Aff` "
"which support parallel execution. When we met applicative functors earlier "
"in the book, we observed how applicative functors can be useful for "
"combining parallel computations. In fact, an instance for `Parallel` defines "
"a correspondence between a monad `m` (such as `Aff`) and an applicative "
"functor `f` which can be used to combine computations in parallel:"
msgstr ""
"`parallel`パッケージは`Aff`のようなモナドのための型クラス`Parallel`を定義して"
"おり、並列実行に対応しています。\n"
"以前に本書でアプリカティブ関手に出会ったとき、並列計算を合成するときにアプリ"
"カティブ関手がどれほど便利なのかを見ました。\n"
"実は`Parallel`のインスタンスは、（`Aff`のような）モナド`m`と、並列に計算を合"
"成するために使われるアプリカティブ関手`f`との対応関係を定義しているのです。"

#. type: Fenced code block (hs)
#: text/chapter9.md:141
#, no-wrap
msgid ""
"class (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n"
"  sequential :: forall a. f a -> m a\n"
"  parallel :: forall a. m a -> f a\n"
msgstr ""
"class (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n"
"  sequential :: forall a. f a -> m a\n"
"  parallel :: forall a. m a -> f a\n"

#. type: Plain text
#: text/chapter9.md:148
msgid "The class defines two functions:"
msgstr "このクラスは2つの関数を定義しています。"

#. type: Bullet: '- '
#: text/chapter9.md:151
msgid ""
"`parallel`, which takes computations in the monad `m` and turns them into "
"computations in the applicative functor `f`, and"
msgstr ""
"`parallel`：モナド`m`中の計算を取り、アプリカティブ関手`f`中の計算に変えま"
"す。"

#. type: Bullet: '- '
#: text/chapter9.md:151
msgid "`sequential`, which performs a conversion in the opposite direction."
msgstr "`sequential`：反対方向に変換します。"

#. type: Plain text
#: text/chapter9.md:153
msgid ""
"The `aff` library provides a `Parallel` instance for the `Aff` monad. It "
"uses mutable references to combine `Aff` actions in parallel, by keeping "
"track of which of the two continuations has been called. When both results "
"have been returned, we can compute the final result and pass it to the main "
"continuation."
msgstr ""
"`aff`ライブラリは `Aff`モナドの `Parallel`インスタンスを提供します。\n"
"これは、2つの継続 (continuation) のどちらが呼び出されたかを把握することによっ"
"て、変更可能な参照を使用して並列に `Aff`アクションを組み合わせます。\n"
"両方の結果が返されたら、最終結果を計算してメインの継続に渡すことができます。"

#. type: Plain text
#: text/chapter9.md:155
msgid ""
"Because applicative functors support lifting of functions of arbitrary "
"arity, we can perform more computations in parallel by using the applicative "
"combinators. We can also benefit from all of the standard library functions "
"which work with applicative functors, such as `traverse` and `sequence`!"
msgstr ""
"アプリカティブ関手では任意個の引数の関数の持ち上げができるので、このアプリカ"
"ティブコンビネータを使ってより多くの計算を並列に実行できます。\n"
"`traverse`や`sequence`といった、アプリカティブ関手を扱う全ての標準ライブラリ"
"関数から恩恵を受けることもできます。"

#. type: Plain text
#: text/chapter9.md:157
msgid ""
"We can also combine parallel computations with sequential portions of code, "
"by using applicative combinators in a do notation block, or vice versa, "
"using `parallel` and `sequential` to change type constructors where "
"appropriate."
msgstr ""
"必要に応じて `parralel`と`sequential`を使って型構築子を変更することで、do記法"
"ブロック中でアプリカティブコンビネータを使い、直列的なコードの一部で並列計算"
"を結合したり、またはその逆を行ったりできます。"

#. type: Plain text
#: text/chapter9.md:161
msgid ""
"To demonstrate the difference between sequential and parallel execution, "
"we'll create an array of 100 10-millisecond delays, then execute those "
"delays with both techniques.  You'll notice in the repl that `seqDelay` is "
"much slower than `parDelay`.  Note that parallel execution is enabled by "
"simply replacing `sequence_` with `parSequence_`."
msgstr ""
"直列実行と並列実行の間の違いを実演するために、100個の10ミリ秒の遅延からなる配"
"列をつくり、それからその遅延を両方の手法で実行します。REPLで試すと`seqDelay`"
"が`parDelay`より遥かに遅いことに気付くでしょう。並列実行が`sequence_`を"
"`parSequence_`で置き換えるだけで有効になるところに注目です。"

#. type: Fenced code block (hs)
#: text/chapter9.md:162
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelDelay.purs:delays}}\n"
msgstr "{{#include ../exercises/chapter9/test/ParallelDelay.purs:delays}}\n"

#. type: Fenced code block (shell)
#: text/chapter9.md:166
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelDelay\n"
"\n"
"> seqDelay -- This is slow\n"
"unit\n"
"\n"
"> parDelay -- This is fast\n"
"unit\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.ParallelDelay\n"
"\n"
"> seqDelay -- This is slow\n"
"unit\n"
"\n"
"> parDelay -- This is fast\n"
"unit\n"

#. type: Plain text
#: text/chapter9.md:179
msgid ""
"Here's a more real-world example of making multiple HTTP requests in "
"parallel. We're reusing our `getUrl` function to fetch information from two "
"users in parallel. Note that `parTraverse` (the parallel version of "
"`traverse`) is used in this case. This example would also work fine with "
"`traverse` instead, but it will be slower."
msgstr ""
"以下は並列で複数回HTTP要求する、より現実味のある例です。\n"
"`getUrl`関数を再利用して2人の利用者から並列で情報を取得します。\n"
"この場合では`parTarverse`（`traverse`の並列版）が使われていますね。\n"
"この例は代わりに`traverse`でも問題なく動きますがより遅くなるでしょう。"

#. type: Fenced code block (hs)
#: text/chapter9.md:180
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelFetch.purs:fetchPar}}\n"
msgstr "{{#include ../exercises/chapter9/test/ParallelFetch.purs:fetchPar}}\n"

#. type: Fenced code block (shell)
#: text/chapter9.md:184
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelFetch\n"
"\n"
"> fetchPar\n"
"unit\n"
"[\"{\\\"data\\\":{\\\"id\\\":1,\\\"email\\\":\\\"george.bluth@reqres.in\\\", ... }\"\n"
",\"{\\\"data\\\":{\\\"id\\\":2,\\\"email\\\":\\\"janet.weaver@reqres.in\\\", ... }\"\n"
"]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Test.ParallelFetch\n"
"\n"
"> fetchPar\n"
"unit\n"
"[\"{\\\"data\\\":{\\\"id\\\":1,\\\"email\\\":\\\"george.bluth@reqres.in\\\", ... }\"\n"
",\"{\\\"data\\\":{\\\"id\\\":2,\\\"email\\\":\\\"janet.weaver@reqres.in\\\", ... }\"\n"
"]\n"

#. type: Plain text
#: text/chapter9.md:197
msgid ""
"A full listing of available parallel functions can be found in the "
"[`parallel` docs on Pursuit](https://pursuit.purescript.org/packages/"
"purescript-parallel/docs/Control.Parallel). The [aff docs section on "
"parallel](https://github.com/purescript-contrib/purescript-aff#parallel-"
"execution) also contains more examples."
msgstr ""
"利用できる並列関数の完全な一覧は[Pursuitの`parallel`のドキュメント](https://"
"pursuit.purescript.org/packages/purescript-parallel/docs/Control.Parallel)に"
"あります。[parallelのaffのドキュメントの節](https://github.com/purescript-"
"contrib/purescript-aff#parallel-execution)にもより多くの例が含まれています。"

#. type: Bullet: '1. '
#: text/chapter9.md:201
msgid ""
"(Easy) Write a `concatenateManyParallel` function which has the same "
"signature as the earlier `concatenateMany` function, but reads all input "
"files in parallel."
msgstr ""
"（簡単）前の`concatenateMany`関数と同じシグネチャを持つ"
"`concatenateManyParallel`関数を書いてください。\n"
"ただし全ての入力ファイルを並列に読むようにしてください。"

#. type: Bullet: '1. '
#: text/chapter9.md:205
msgid ""
"(Medium) Write a `getWithTimeout :: Number -> String -> Aff (Maybe String)` "
"function which makes an HTTP `GET` request at the provided URL and returns "
"either:"
msgstr ""
"（普通）与えられたURLへHTTP `GET`を要求して以下の何れかを返す"
"`getWithTimeout :: Number -> String -> Aff (Maybe String)`関数を書いてくださ"
"い。"

#. type: Bullet: '    - '
#: text/chapter9.md:205
msgid ""
"`Nothing`: if the request takes longer than the provided timeout (in "
"milliseconds)."
msgstr ""
"`Nothing`: 要求してから与えられた時間制限（ミリ秒単位）より長く掛かった場合。"

#. type: Bullet: '    - '
#: text/chapter9.md:205
msgid ""
"The string response: if the request succeeds before the timeout elapses."
msgstr "文字列の応答：時間制限を越える前に要求が成功した場合。"

#. type: Bullet: '1. '
#: text/chapter9.md:207
msgid ""
"(Difficult) Write a `recurseFiles` function which takes a \"root\" file and "
"returns an array of all paths listed in that file (and listed in the listed "
"files too). Read listed files in parallel. Paths are relative to the "
"directory of the file they appear in. _Hint:_ The `node-path` module has "
"some helpful functions for negotiating directories."
msgstr ""
"（難しい）「根」のファイルを取り、そのファイルの中の全てのパスの一覧（そして"
"一覧にあるファイルの中の一覧も）の配列を返す`recurseFiles`関数を書いてくださ"
"い。\n"
"一覧にあるファイルを並列に読んでください。\n"
"パスはそのファイルが表れたディレクトリから相対的なものです。\n"
"*手掛かり*：`node_path`モジュールにはディレクトリを扱う上で便利な関数がありま"
"す。"

#. type: Plain text
#: text/chapter9.md:209
msgid "For example, if starting from the following `root.txt` file:"
msgstr "例えば次のような`root.txt`ファイルから始まるとします。"

#. type: Fenced code block (shell)
#: text/chapter9.md:210
#, no-wrap
msgid ""
"$ cat root.txt\n"
"a.txt\n"
"b/a.txt\n"
"c/a/a.txt\n"
"\n"
"$ cat a.txt\n"
"b/b.txt\n"
"\n"
"$ cat b/b.txt\n"
"c/a.txt\n"
"\n"
"$ cat b/c/a.txt\n"
"\n"
"$ cat b/a.txt\n"
"\n"
"$ cat c/a/a.txt\n"
msgstr ""
"$ cat root.txt\n"
"a.txt\n"
"b/a.txt\n"
"c/a/a.txt\n"
"\n"
"$ cat a.txt\n"
"b/b.txt\n"
"\n"
"$ cat b/b.txt\n"
"c/a.txt\n"
"\n"
"$ cat b/c/a.txt\n"
"\n"
"$ cat b/a.txt\n"
"\n"
"$ cat c/a/a.txt\n"

#. type: Plain text
#: text/chapter9.md:230
msgid "The expected output is:"
msgstr "期待される出力は次の通り。"

#. type: Fenced code block (hs)
#: text/chapter9.md:231
#, no-wrap
msgid "[\"root.txt\",\"a.txt\",\"b/a.txt\",\"b/b.txt\",\"b/c/a.txt\",\"c/a/a.txt\"]\n"
msgstr "[\"root.txt\",\"a.txt\",\"b/a.txt\",\"b/b.txt\",\"b/c/a.txt\",\"c/a/a.txt\"]\n"

#. type: Plain text
#: text/chapter9.md:238
msgid "In this chapter we covered asynchronous effects and learned how to:"
msgstr "この章では非同期エフェクトと以下の方法を押さえました。"

#. type: Bullet: '- '
#: text/chapter9.md:241
msgid "Run asynchronous code in the `Aff` monad with the `aff` library."
msgstr "`aff`ライブラリを使って`Aff`モナド中で非同期コードを走らせる。"

#. type: Bullet: '- '
#: text/chapter9.md:241
msgid "Make HTTP requests asynchronously with the `affjax` library."
msgstr "`affjax`ライブラリを使って非同期にHTTPリクエストを行う。"

#. type: Bullet: '- '
#: text/chapter9.md:241
msgid "Run asynchronous code in parallel with the `parallel` library."
msgstr "`parallel`ライブラリを使って並列に非同期コードを走らせる。"

# 再帰、マップ、畳み込み

## この章の目標

この章では、アルゴリズムを構造化するときに再帰関数をどのように使うかについて見ていきましょう。再帰は関数型プログラミングの基本的な手法であり、この本の全体に亙って使われます。

また、PureScriptの標準ライブラリから標準的な関数をいくつか取り扱います。
`map`や`fold`といった関数だけでなく、`filter`や`concatMap`といった特別な場合において便利なものについても見ていきます。

この章では、仮想的なファイルシステムを操作する関数のライブラリを動機付けに用います。この章で学ぶ手法を応用して、擬似的なファイルシステムによって表されるファイルのプロパティを計算する関数を記述します。

## プロジェクトの準備

この章のソースコードは`src/Data/Path.purs`と`test/Examples.purs`に含まれています。
`Data.Path`モジュールは仮想ファイルシステムのモデルを含みます。
このモジュールの内容を変更する必要はありません。
演習への解答は`Test.MySolutions`モジュールに実装してください。
それぞれの演習を完了させつつ都度`Test.Main`モジュールにある対応するテストを有効にし、
`spago test`を走らせることで解答を確認してください。

このプロジェクトには以下の依存関係があります。

- `maybe`: `Maybe`型構築子が定義されています。
- `arrays`: 配列を扱うための関数が定義されています。
- `strings`: JavaScriptの文字列を扱うための関数が定義されています。
- `foldable-traversable`: 配列やその他のデータ構造を畳み込む関数が定義されています。
- `console`: コンソールへの出力を扱うための関数が定義されています。

## はじめに

再帰は一般のプログラミングでも重要な手法ですが、特に純粋関数型プログラミングでは当たり前のように用いられます。この章で見ていくように、再帰はプログラムの変更可能な状態を減らすために役立つからです。

再帰は**分割統治** (divide and conquer) 戦略と密接な関係があります。
分割統治とはすなわち、何らかの入力としての問題を解くにあたり、入力を小さな部分に分割し、それぞれの部分について問題を解いて、部分ごとの答えから最終的な答えを組み立てるということです。

それでは、PureScriptにおける再帰の簡単な例をいくつか見てみましょう。

次は**階乗関数** (factorial function) のよくある例です。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:factorial}}
```

部分問題へ問題を分割することによって階乗関数がどのように計算されるかがわかります。より小さい数へと階乗を計算していくということです。ゼロに到達すると、答えは直ちに求まります。

次は、**フィボナッチ関数** (Fibonacci function) を計算するという、これまたよくある例です。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:fib}}
```

やはり、部分問題の解決策を考えることで全体を解決していることがわかります。このとき、`fib (n - 1)`と`fib (n -
2)`という式に対応した、２つの部分問題があります。これらの２つの部分問題が解決されていれば、この部分的な答えを加算することで、全体の答えを組み立てることができます。

なお上の`factorial`と`fib`の例は意図通りに動きますが、
より慣習的な実装では`if`や`then`や`else`を使う代わりにパターン照合を使うものでしょう。
パターン照合の技法は後の章でお話しします。

## 配列上での再帰

再帰関数の定義は、`Int`型だけに限定されるものではありません！
本書の後半で**パターン照合** (pattern matching)
を扱うときに、いろいろなデータ型の上での再帰関数について見ていきますが、ここでは数と配列に限っておきます。

入力がゼロでないかどうかについて分岐するのと同じように、配列の場合も、配列が空でないかどうかについて分岐していきます。再帰を使用して配列の長さを計算する次の関数を考えてみます。

```haskell
import Prelude

import Data.Array (null, tail)
import Data.Maybe (fromMaybe)

{{#include ../exercises/chapter4/test/Examples.purs:length}}
```

この関数では配列が空かどうかで分岐するために`if ... then ... else`式を使っています。
この`null`関数は配列が空のときに`true`を返します。
空の配列の長さはゼロであり、空でない配列の長さは配列の先頭を取り除いた残りの部分の長さより1大きいというわけです。

`tail`関数は与えられた配列から最初の要素を除いたものを`Maybe`に包んで返します。
配列が空であれば（つまり尾鰭がありません）`Nothing`が返ります。
`fromMaybe`関数は既定値と`Maybe`値を取ります。
後者が`Nothing`であれば既定義を返し、そうでなければ`Just`に包まれた値を返します。

JavaScriptで配列の長さを調べるのには、この例はどうみても実用的な方法とはいえませんが、次の演習を完了するための手がかりとしては充分でしょう。

## 演習

 1. （簡単）入力が偶数であるとき、かつそのときに限り`true`に返すような再帰関数を書いてみましょう。
 2. （少し難しい）配列内の偶数の数を数える再帰関数`countEven`を書いてみましょう。
    **ヒント**：`Data.Array`モジュールの`head`関数を使うと、空でない配列の最初の要素を見つけることができます。

## マップ

`map`関数は配列に対する再帰関数のひとつです。
この関数を使うと、配列の各要素に順番に関数を適用することで、配列の要素を変換することができます。
そのため、配列の**内容**は変更されますが、その**形状**（ここでは「長さ」）は保存されます。

本書の後半で**型クラス** (type class) の内容を押さえるとき、
`map`関数が形状保存関数のより一般的な様式の一例であることを見ていきます。
これは**関手** (functor) と呼ばれる型構築子のクラスを変換するものです。

それでは、PSCiで`map`関数を試してみましょう。

```text
$ spago repl

> import Prelude
> map (\n -> n + 1) [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
```

`map`がどのように使われているかに注目してください。
最初の引数には配列上で「写す」関数、第2引数には配列そのものを渡します。

## 中置演算子

バッククォートで関数名を囲むと、写す関数と配列の間に、`map`関数を書くことができます。

```text
> (\n -> n + 1) `map` [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
```

この構文は**中置関数適用**と呼ばれ、どんな関数でもこのように中置することができます。
普通は2引数の関数に対して使うのが最適でしょう。

配列を扱うときは、`map`関数と等価な`<$>`という演算子が存在します。この演算子は他の二項演算子と同じように中置で使用することができます。

```text
> (\n -> n + 1) <$> [1, 2, 3, 4, 5]
[2, 3, 4, 5, 6]
```

それでは`map`の型を見てみましょう。

```text
> :type map
forall a b f. Functor f => (a -> b) -> f a -> f b
```

実は`map`の型は、この章で必要とされているものよりも一般的な型になっています。今回の目的では、`map`は次のようなもっと具体的な型であるかのように考えるとよいでしょう。

```text
forall a b. (a -> b) -> Array a -> Array b
```

この型では、`map`関数に適用するときには`a`と`b`という２つの型を自由に選ぶことができる、ということも示されています。
`a`は元の配列の要素の型で、`b`は目的の配列の要素の型です。
もっと言えば、`map`が配列の要素の型を保存する必要があるわけではありません。
たとえば、`map`を使用すると数値を文字列に変換することができます。

```text
> show <$> [1, 2, 3, 4, 5]

["1","2","3","4","5"]
```

中置演算子`<$>`は特別な構文のように見えるかもしれませんが、実はPureScriptの普通の関数の別称です。
中置構文を使用した単なる**適用**にすぎません。
実際、括弧でその名前を囲むと、この関数を通常の関数のように使用することができます。
これは、`map`代わりに、括弧で囲まれた`(<$>)`という名前を使って配列に関数を適用できるということです。

```text
> (<$>) show [1, 2, 3, 4, 5]
["1","2","3","4","5"]
```

中置関数は既存の関数名の別称として定義されます。
たとえば、`Data.Array`モジュールでは次のように`range`関数の同義語として中置演算子`(..)`を定義しています。

```haskell
infix 8 range as ..
```

この演算子は次のように使うことができます。

```text
> import Data.Array

> 1 .. 5
[1, 2, 3, 4, 5]

> show <$> (1 .. 5)
["1","2","3","4","5"]
```

**注意**： 独自の中置演算子は、自然な構文を持った領域特化言語を定義するのに優れた手段になりえます。
ただし、乱用すると初心者が読めないコードになることがありますから、新たな演算子の定義には慎重になるのが賢明です。

上記の例では、`1 .. 5`という式は括弧で囲まれていましたが、実際にはこれは必要ありません。
なぜなら、`Data.Array`モジュールは、`<$>`に割り当てられた優先順位より高い優先順位を`..`演算子に割り当てているからです。
上の例では、`..`の優先順位は、予約語`infix`のあとに書かれた数の`8` と定義されていました。
ここでは`<$>`の優先順位よりも高い優先順位を`..`に割り当てており、このため括弧を付け加える必要がないということです。

```text
> show <$> 1 .. 5
["1","2","3","4","5"]
```

中置演算子に（左または右の）**結合性**を与えたい場合は、代わりに予約語`infixl`と`infixr`を使います。
`infix`を使うと何ら結合性は割り当てられず、
同じ演算子を複数回使ったり複数の同じ優先度の演算子を使ったりするときに、式を括弧で囲まなければいけなくなります。

## 配列のフィルタリング

`Data.Array`モジュールでは他にも、よく`map`と一緒に使われる関数`filter`も提供しています。
この関数は、述語関数に適合する要素のみを残し、既存の配列から新しい配列を作成する機能を提供します。

たとえば、1から10までの数で、偶数であるような数の配列を計算したいとします。これは次のように行うことができます。

```text
> import Data.Array

> filter (\n -> n `mod` 2 == 0) (1 .. 10)
[2,4,6,8,10]
```

## 演習

 1. （簡単）`map`関数や`<$>`関数を使用して、 配列に格納された数のそれぞれの平方を計算する関数`squared`を書いてみましょう。
    **ヒント**：`map`や`<$>`といった関数を使ってください。
 1. （簡単）`filter`関数を使用して、数の配列から負の数を取り除く関数`keepNonNegative`を書いてみましょう。
    **ヒント**：`filter`関数を使ってください。
 1. （やや難しい）
    * `filter`の中置同義語`<$?>`を定義してください。
      **補足**：中置同義語はREPLでは定義できないかもしれませんが、ファイルでは定義することができます。
    * 関数`keepNonNegativeRewrite`を書いてください。
      この関数は`filter`を自前の粗しい中置演算子`<$?>`で置き換えたところ以外は`keepNonNegative`と同じです。
    * PSCiで自前の演算子の優先度合いと結合性を試してください。
      **補足**：この問題のための単体試験はありません。

## 配列の平坦化

配列に関する標準的な関数として`Data.Array`で定義されているものには、`concat`関数もあります。`concat`は配列の配列をひとつの配列へと平坦化します。

```text
> import Data.Array

> :type concat
forall a. Array (Array a) -> Array a

> concat [[1, 2, 3], [4, 5], [6]]
[1, 2, 3, 4, 5, 6]
```

関連する関数として、`concat`と`map`を組み合わせたような`concatMap`と呼ばれる関数もあります。
`map`は（相異なる型も可能な）値からの値への関数を引数に取りますが、それに対して`concatMap`は値から値の配列の関数を取ります。

実際に動かして見てみましょう。

```text
> import Data.Array

> :type concatMap
forall a b. (a -> Array b) -> Array a -> Array b

> concatMap (\n -> [n, n * n]) (1 .. 5)
[1,1,2,4,3,9,4,16,5,25]
```

ここでは、数をその数とその数の平方の2つの要素からなる配列に写す関数`\n -> [n, n * n]`を引数に`concatMap`を呼び出しています。
結果は10個の整数の配列です。
配列は1から5の数とそのそれぞれの数の平方からなります。

`concatMap`がどのように結果を連結しているのかに注目してください。
渡された関数を元の配列のそれぞれの要素について一度づつ呼び出し、その関数はそれぞれ配列を生成します。
最後にそれらの配列を単一の配列に押し潰し、それが結果となります。

`map`と`filter`、`concatMap`は、「配列内包表記」(array comprehensions)
と呼ばれる、配列に関するあらゆる関数の基盤を形成しています。

## 配列内包表記

数`n`のふたつの因数を見つけたいとしましょう。これを行うための簡単​​な方法としては、総当りで調べる方法があります。つまり、`1`から`n`の数のすべての組み合わせを生成し、それを乗算してみるわけです。もしその積が`n`なら、`n`の因数の組み合わせを見つけたということになります。

配列内包表記を使用すると、この計算を実行することができます。
PSCiを対話式の開発環境として使用し、ひとつづつこの手順を進めていきましょう。

最初の手順では`n`以下の数の組み合わせの配列を生成しますが、これには`concatMap`を使えばよいです。

`1 .. n`のそれぞれの数を配列`1 .. n`へとマッピングすることから始めましょう。

```text
> pairs n = concatMap (\i -> 1 .. n) (1 .. n)
```

この関数をテストしてみましょう。

```text
> pairs 3
[1,2,3,1,2,3,1,2,3]
```

これは求めているものとはぜんぜん違います。
単にそれぞれの組み合わせの2つ目の要素を返すのではなく、ペア全体を保持することができるように、内側の`1
.. n`の複製について関数をマッピングする必要があります。

```text
> :paste
… pairs' n =
…   concatMap (\i ->
…     map (\j -> [i, j]) (1 .. n)
…   ) (1 .. n)
… ^D

> pairs' 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
```

いい感じになってきました。しかし、`[1, 2]`と`[2,
1]`の両方があるように、重複した組み合わせが生成されています。`j`を`i`から`n`の範囲に限定することで、２つ目の場合を取り除くことができます。

```text
> :paste
… pairs'' n =
…   concatMap (\i ->
…     map (\j -> [i, j]) (i .. n)
…   ) (1 .. n)
… ^D
> pairs'' 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
```

すばらしいです！因数の候補のすべての組み合わせを手に入れたので、`filter`を使えば、その積が`n`であるような組み合わせを選び出すことができます。

```text
> import Data.Foldable

> factors n = filter (\pair -> product pair == n) (pairs'' n)

> factors 10
[[1,10],[2,5]]
```

このコードでは、`foldable-traversable`ライブラリの`Data.Foldable`モジュールにある`product`関数を使っています。

うまくいきました！因数の組み合わせの正しい集合を重複なく見つけることができました。

## do記法

しかし、このコードの可読性は大幅に向上することができます。
`map`や`concatMap`は基本的な関数であり、**do記法** (do notation) と呼ばれる特別な構文の基礎になっています。
（もっと厳密にいえば、それらの一般化である`map`と`bind`が基礎をなしています。）

**注意**：`map`と`concatMap`が**配列内包表記**を書けるようにしているように、もっと一般的な演算子である`map`と`bind`は**モナド内包表記**
(monad comprehensions) と呼ばれているものを書けるようにします。
本書の後半では**モナド** (monad) の例をたっぷり見ていくことになりますが、
この章では配列のみを考えます。

do記法を使うと、先ほどの`factors`関数を次のように書き直すことができます。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:factors}}
```

キーワード`do`はdo記法を使うコードのブロックを導入します。このブロックは幾つかの種類の式で構成されています。

- 配列の要素を名前に束縛する式。これは後ろ向きの矢印`<-`で 示されていて、その左側は名前、右側は配列の型を持つ式です。
- 名前に配列の要素を束縛しない式。
  最後の行の`pure [i, j]`が、この種類の式の一例です。
- `let`キーワードを使用し、式に名前を与える式。

この新しい記法を使うと、アルゴリズムの構造がわかりやすくなることがあります。
心のなかで`<-`を「選ぶ」という単語に置き換えるとすると、「1からnの間の要素`i`を選び、それからiからnの間の要素`j`を選び、`[i, j]`を返す」というように読むことができるでしょう。

最後の行では、`pure`関数を使っています。
この関数はPSCiで評価することができますが、型を明示する必要があります。

```text
> pure [1, 2] :: Array (Array Int)
[[1, 2]]
```

配列の場合、`pure`は単に1要素の配列を作成します。
実際に、`factors`関数を変更して、`pure`の代わりにこの形式を使うようにすることもできます。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:factorsV2}}
```

そして、結果は同じになります。

## ガード

`factors`関数を更に改良する方法としては、このフィルタを配列内包表記の内側に移動するというものがあります。
これは`control`ライブラリにある`Control.Alternative`モジュールの`guard`関数を使用することで可能になります。

```haskell
import Control.Alternative (guard)

{{#include ../exercises/chapter4/test/Examples.purs:factorsV3}}
```

`pure`と同じように、どのように動作するかを理解するために、PSCiで`guard`関数を適用して調べてみましょう。
`guard`関数の型は、ここで必要とされるものよりもっと一般的な型になっています。

```text
> import Control.Alternative

> :type guard
forall m. Alternative m => Boolean -> m Unit
```

今回の場合は、PSCiは次の型を報告するものと考えてください。

```haskell
Boolean -> Array Unit
```

目的からすると、次の計算の結果から配列における`guard`関数について今知りたいことはすべてわかります。

```text
> import Data.Array

> length $ guard true
1

> length $ guard false
0
```

つまり、`guard`が`true`に評価される式を渡された場合、単一の要素を持つ配列を返すのです。もし式が`false`と評価された場合は、その結果は空です。

ガードが失敗した場合、配列内包表記の現在の分岐は、結果なしで早めに終了されることを意味します。
これは、`guard`の呼び出しが、途中の配列に対して`filter`を使用するのと同じだということです。
実践の場面にもよりますが、`filter`の代わりに`guard`を使いたいことは多いでしょう。
これらが同じ結果になることを確認するために、`factors`の二つの定義を試してみてください。

## 演習

 1. （簡単）整数の引数が素数であるかどうかを調べる関数`isPrime`を定義してみましょう。
    **ヒント**：`factors`関数を使ってください。
 1. （やや難しい）do記法を使い、2つの配列の**直積集合**を見つけるための関数`cartesianProduct`を書いてみましょう。
    直積集合とは、要素`a`、`b`のすべての組み合わせの集合のことです。
    ここで`a`は最初の配列の要素、`b`は2つ目の配列の要素です。
 1. （やや難しい）数値`n`を取って構成要素（値`a`, `b`, `c`）がそれぞれ`n`以下であるような全てのピタゴラスの三つ組
    (pythagorean triples) を返す関数`triples :: Int -> Array (Array
    Int)`を書いてください。
    **ピタゴラスの三つ組** は数値の配列`[a, b, c]`で `a² + b² = c²` です。
    **ヒント**：配列内包表記で`guard`関数を使ってください。
 1. （難しい）`factors`関数を使用して、数`n`の[素因数分解](https://www.mathsisfun.com/prime-factorization.html)を求める関数`primeFactors`を定義してみましょう。
    数`n`の素因数分解とは、素数の積が`n`であるような整数の配列のことです。
    **ヒント**：1より大きい整数について、問題を2つの部分問題に分解してください。
    最初の因数を探し、それから残りの因数を探すのです。

## 畳み込み

配列における左右の畳み込みは、再帰を用いて実装される別の興味深い関数の集まりを提供します。

PSCiを使って、`Data.Foldable`モジュールをインポートし、`foldl`と`foldr`関数の型を調べることから始めましょう。

```text
> import Data.Foldable

> :type foldl
forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b

> :type foldr
forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b
```

これらの型は、現在興味があるものよりも一般的です。
この章の目的では、PSCiは以下の（より具体的な）答えを与えていたと考えておきましょう。

```text
> :type foldl
forall a b. (b -> a -> b) -> b -> Array a -> b

> :type foldr
forall a b. (a -> b -> b) -> b -> Array a -> b
```

どちらの型でも、`a`は配列の要素の型に対応しています。
型`b`は、配列を走査 (traverse) したときの結果を累積する「累積器」(accumulator) の型だと考えることができます。

`foldl`関数と`foldr`関数の違いは走査の方向です。
`foldr`が「右から」配列を畳み込むのに対して、`foldl`は「左から」配列を畳み込みます。

実際にこれらの関数の動きを見てみましょう。
`foldl`を使用して数の配列の和を求めてみます。
型`a`は`Int`になり、結果の型`b`も`Int`として選択することができます。
ここでは、次の要素を累積器に加算する`Int -> Int -> Int`という型の関数、`Int`型の累積器の初期値、
和を求めたい`Int`の配列という、3つの引数を提供する必要があります。
最初の引数としては、加算演算子を使用することができますし、累積器の初期値はゼロになります。

```text
> foldl (+) 0 (1 .. 5)
15
```

この場合では、引数が逆になっていても`(+)`関数は同じ結果を返すので、`foldl`と`foldr`のどちらでも問題ありません。

```text
> foldr (+) 0 (1 .. 5)
15
```

`foldl`と`foldr`の違いを説明するために、畳み込み関数の選択が影響する例も書いてみましょう。
加算関数の代わりに、文字列連結を使用して文字列を作ってみます。

```text
> foldl (\acc n -> acc <> show n) "" [1,2,3,4,5]
"12345"

> foldr (\n acc -> acc <> show n) "" [1,2,3,4,5]
"54321"
```

これは、2つの関数の​​違いを示しています。左畳み込み式は、以下の関数適用と同等です。

```text
((((("" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)
```

それに対し、右畳み込みは以下に相当します。

```text
((((("" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)
```

## 末尾再帰

再帰はアルゴリズムを定義するための強力な手法ですが、問題も抱えています。
JavaScriptで再帰関数を評価するとき、入力が大きすぎるとスタックオーバーフローでエラーを起こす可能性があるのです。

PSCiで次のコードを入力すると、この問題を簡単に検証できます。

```text
> :paste
… f n =
…   if n == 0
…     then 0
…     else 1 + f (n - 1)
… ^D

> f 10
10

> f 100000
RangeError: Maximum call stack size exceeded
```

これは問題です。関数型プログラミングの基本的な手法として再帰を採用しようとするなら、無限かもしれない再帰でも扱える方法が必要です。

PureScriptは**末尾再帰最適化** (tail recursion optimization)
の形でこの問題に対する部分的な解決策を提供しています。

**注意**：この問題へのより完全な解決策としては、いわゆる**トランポリン** (trampolining)
を使用したライブラリで実装する方法がありますが、それはこの章で扱う範囲を超えています。
この内容に興味のある読者は
[`free`](https://pursuit.purescript.org/packages/purescript-free)や
[`tailrec`](https://pursuit.purescript.org/packages/purescript-tailrec)パッケージの
ドキュメントを参照してみてください。

末尾再帰最適化を可能にする上で鍵となる観点は以下となります。
**末尾位置** (tail position)
にある関数の再帰的な呼び出しは、スタックフレームが確保されない**ジャンプ**に置き換えることができます。
関数が戻るより前の最後の呼び出しであるとき、呼び出しが**末尾位置**にあるといいます。
なぜこの例でスタックオーバーフローを観察したのかはこれが理由です。
この`f`の再帰呼び出しは、末尾位置**ではない**からです。

実際には、PureScriptコンパイラは再帰呼び出しをジャンプに置き換えるのではなく、再帰的な関数全体を**whileループ**に置き換えます。

以下はすべての再帰呼び出しが末尾位置にある再帰関数の例です。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:factorialTailRec}}
```

`fact`への再帰呼び出しは、この関数の中で起こる最後のものである、つまり末尾位置にあることに注意してください。

## 累積器

末尾再帰ではない関数を末尾再帰関数に変える一般的な方法としては、**累積器引数** (accumulator parameter)
を使用する方法があります。
累積器引数は関数に追加される余剰の引数で返り値を**累積**するものです。
これは結果を累積するために返り値を使うのとは対称的です。

例えば章の初めに示した`length`関数を再考しましょう。

```haskell
length :: forall a. Array a -> Int
length arr =
  if null arr
    then 0
    else 1 + (length $ fromMaybe [] $ tail arr)
```

この実装は末尾再帰ではないので、大きな入力配列に対して実行されると、
生成されたJavaScriptはスタックオーバーフローを発生させるでしょう。
しかし代わりに、結果を蓄積するための2つ目の引数を関数に導入することで、これを末尾再帰に変えることができます。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:lengthTailRec}}
```

ここでは、配列を逆転させる作業を補助関数`length'`に委譲しています。
`length'`は末尾再帰です。
その唯一の再帰呼び出しは、最後の場合の末尾位置にあります。
これは、生成されたコードが**whileループ**となり、大きな入力でもスタックが溢れないことを意味します。

`lengthTailRec`の実装を理解するために補助関数`length'`に着目しましょう。
この関数は必然的に累積器引数を使って追加の状態……これは部分的な結果です……を維持しています。
0から始まり、入力の配列中の全ての要素それぞれについて1ずつ足して成長していきます。

累積器を「状態」と考えることもできますが、直接に変更がされているわけではないことにも注意してください。

## 明示的な再帰より畳み込みを選ぶ

末尾再帰を使用して再帰関数を記述することができれば末尾再帰最適化の恩恵を受けることができるので、
すべての関数をこの形で書こうとする誘惑にかられます。
しかし、多くの関数は配列やそれに似たデータ構造に対する折り畳みとして直接書くことができることを忘れがちです。
`map`や`fold`のようなコンビネータを使って直接アルゴリズムを書くことには、コードの単純さという利点があります。
これらのコンビネータはよく知られており、明示的な再帰よりもアルゴリズムの**意図**をよりはっきりとさせるのです。

例えば`foldr`を使って配列を反転できます。

```text
> import Data.Foldable

> :paste
… reverse :: forall a. Array a -> Array a
… reverse = foldr (\x xs -> xs <> [x]) []
… ^D

> reverse [1, 2, 3]
[3,2,1]
```

`foldl`を使って`reverse`を書くことは、読者への課題として残しておきます。

## 演習

 1. （簡単）`foldl`を使って真偽値配列の値が全て真か検査する関数`allTrue`を書いてください。
 2. （やや難しい。テストなし）関数`foldl (==) false xs`が真を返すような配列`xs`とはどのようなものか説明してください。
    言い換えると、次の文を完成させることになります。
    「関数は`xs`が……を含むときに`true`を返す。」
 3. （やや難しい）末尾再帰の形式を取っていること以外は`fib`と同じような関数`fibTailRec`を書いてください。
    **ヒント**：累積器引数を使ってください。
 4. （やや難しい）`foldl`を使って`reverse`を書いてみましょう。

## 仮想ファイルシステム

この節では、これまで学んだことを応用して、模擬的なファイルシステムで動作する関数を書いていきます。
事前に定義されたAPIで動作するように、マップ、畳み込み、およびフィルタを使用します。

`Data.Path`モジュールでは、次のように仮想ファイルシステムのAPIが定義されています。

- ファイルシステム内のパスを表す型`Path`があります。
- ルートディレクトリを表すパス`root`があります。
- `ls`関数はディレクトリ内のファイルを列挙します。
- `filename`関数は`Path`のファイル名を返します。
- `size`関数は`Path`が示すファイルの大きさを返します。
- `isDirectory`関数はファイルかディレクトリかを調べます。

型については、型定義は次のようになっています。

```haskell
root :: Path

ls :: Path -> Array Path

filename :: Path -> String

size :: Path -> Maybe Int

isDirectory :: Path -> Boolean
```

PSCiでこのAPIを試してみましょう。

```text
$ spago repl

> import Data.Path

> root
/

> isDirectory root
true

> ls root
[/bin/,/etc/,/home/]
```

`Test.Examples`モジュールでは`Data.Path`APIを使用する関数を定義しています。
`Data.Path`モジュールを変更したり定義を理解したりする必要はありません。
全て`Test.Examples`モジュールだけで作業を行います。

## すべてのファイルの一覧

それでは、内側のディレクトリまで、すべてのファイルを列挙する関数を書いてみましょう。
この関数は以下のような型を持つでしょう。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:allFiles_signature}}
```

再帰を使ってこの関数を定義することができます。
まずは`ls`を使用してディレクトリの直接の子を列挙します。
それぞれの子について再帰的に`allFiles`を適用すると、それぞれパスの配列が返ってくるでしょう。
`concatMap`を適用すると、この結果を同時に平坦化することができます。

最後に、cons演算子`:`を使って現在のファイルも含めます。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:allFiles_implementation}}
```

**注意**：cons演算子`:`は、実際には不変な配列に対してパフォーマンスが悪いので、一般的には推奨されません。
リンクリストやシーケンスなどの他のデータ構造を使用すると、パフォーマンスを向上させることができます。

それではPSCiでこの関数を試してみましょう。

```text
> import Test.Examples
> import Data.Path

> allFiles root

[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]
```

すばらしい！
do記法で配列内包表記を使ってもこの関数を書くことができるので見ていきましょう。

逆向きの矢印は配列から要素を選択するのに相当することを思い出してください。
最初の手順は、引数の直接の子から要素を選択することです。
それから、単にそのファイルに対してこの再帰関数を呼びします。
do記法を使用しているので、再帰的な結果をすべて連結する`concatMap`が暗黙に呼び出されています。

新しいバージョンは次のようになります。

```haskell
{{#include ../exercises/chapter4/test/Examples.purs:allFiles_2}}
```

PSCiで新しいコードを試してみてください。
同じ結果が返ってくるはずです。
どちらのほうがわかりやすいかの選択はお任せします。

## 演習

 1. （簡単）ディレクトリのすべてのサブディレクトリの中まで、
    （ディレクトリを除く）すべてのファイルを返すような関数`onlyFiles`を書いてみてください。
 2. （やや難しい）ファイルを名前で検索する関数`whereIs`を書いてください。
    この関数は型`Maybe Path`の値を返すものとします。
    この値が存在するなら、そのファイルがそのディレクトリに含まれているということを表します。
    この関数は次のように振る舞う必要があります。

     ```text
     > whereIs root "ls"
     Just (/bin/)

     > whereIs root "cat"
     Nothing
     ```

     **ヒント**：この関数をdo記法を使った配列内包表記で書いてみましょう。
 3. （難しい）`Path`を取って`Path`に最大のファイルと最小のファイルを1つずつ含む配列を返す関数`largestSmallest`を書いてください。
    **補足**：空配列や1要素の配列を返すことで、
    `Path`にゼロか1個のファイルがある場合についても考慮してください。

## まとめ

この章では、アルゴリズムを簡潔に表現する手段として、PureScriptでの再帰の基本を説明しました。
また、独自の中置演算子や、マップ、フィルタリングや畳み込みなどの配列に対する標準関数、
およびこれらの概念を組み合わせた配列内包表記を導入しました。
最後に、スタックオーバーフローエラーを回避するために末尾再帰を使用することの重要性、
累積器引数を使用して末尾再帰形に関数を変換する方法を示しました。

- - -

<small>

この翻訳は[aratama](https://github.com/aratama)氏による翻訳を元に改変を加えています。
同氏の翻訳リポジトリは[`aratama/purescript-book-ja`](https://github.com/aratama/purescript-book-ja)に、Webサイトは[実例によるPureScript](http://aratama.github.io/purescript/)にあります。

[原文の使用許諾](https://book.purescript.org/)：

> Copyright (c) 2014-2017 Phil Freeman.
>
> The text of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: <https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US>.
>
> Some text is derived from the [PureScript Documentation Repo](https://github.com/purescript/documentation), which uses the same license, and is copyright [various contributors](https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md).
>
> The exercises are licensed under the MIT license.

[aratama氏訳の使用許諾](http://aratama.github.io/purescript/)：

> This book is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License](http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US).
>
> 本書は[クリエイティブコモンズ 表示 - 非営利 - 継承 3.0 非移植ライセンス](http://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja)でライセンスされています。

本翻訳の使用許諾：

本翻訳も原文と原翻訳にしたがい、
[Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License](https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)の下に提供されています。

</small>
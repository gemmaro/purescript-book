# 実例によるPureScript
# Copyright (C) 2022 gemmaro.
# This file is distributed under the same license as the original document.
#
msgid ""
msgstr ""
"Project-Id-Version: com.github.gemmaro.purescript-book.v0.1.0\n"
"POT-Creation-Date: 2022-07-09 14:23+0900\n"
"PO-Revision-Date: 2022-08-01 23:13+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: Nothing\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ##
#: text/chapter1.md:1 text/chapter4.md:23
#, no-wrap
msgid "Introduction"
msgstr "はじめに"

#. type: Title ##
#: text/chapter1.md:3
#, no-wrap
msgid "Functional JavaScript"
msgstr "関数型JavaScript"

#. type: Plain text
#: text/chapter1.md:6
msgid ""
"Functional programming techniques have been making appearances in JavaScript "
"for some time now:"
msgstr "関数型プログラミングの手法がJavaScriptに姿を現しはじめてからしばらく経ちます。"

#. type: Plain text
#: text/chapter1.md:8
msgid ""
"- Libraries such as [UnderscoreJS](https://underscorejs.org) allow the "
"developer to leverage tried-and-trusted functions such as `map`, `filter` "
"and `reduce` to create larger programs from smaller programs by composition:"
msgstr ""
"- [UnderscoreJS](https://underscorejs.org)などのライブラリがあれば、\n"
"  開発者は`map`や `filter`、\n"
"  `reduce`といった実績のある関数を活用して、\n"
"  小さいプログラムを組み合わせることで大きなプログラムを作ることができます。"

#. type: Plain text
#: text/chapter1.md:18
#, no-wrap
msgid ""
"    ```javascript\n"
"    var sumOfPrimes =\n"
"        _.chain(_.range(1000))\n"
"         .filter(isPrime)\n"
"         .reduce(function(x, y) {\n"
"             return x + y;\n"
"         })\n"
"         .value();\n"
"    ```\n"
msgstr ""
"    ```javascript\n"
"    var sumOfPrimes =\n"
"        _.chain(_.range(1000))\n"
"         .filter(isPrime)\n"
"         .reduce(function(x, y) {\n"
"             return x + y;\n"
"         })\n"
"         .value();\n"
"    ```\n"

#. type: Plain text
#: text/chapter1.md:20
msgid ""
"- Asynchronous programming in NodeJS leans heavily on functions as first-"
"class values to define callbacks."
msgstr ""
"- NodeJSにおける非同期プログラミングでは、第一級の値としての関数をコールバッ"
"クを定義するために多用しています。"

#. type: Plain text
#: text/chapter1.md:23
#, no-wrap
msgid ""
"    ```javascript\n"
"    import { readFile, writeFile } from 'fs'\n"
msgstr ""
"    ```javascript\n"
"    import { readFile, writeFile } from 'fs'\n"

#. type: Plain text
#: text/chapter1.md:34
#, no-wrap
msgid ""
"    readFile(sourceFile, function (error, data) {\n"
"      if (!error) {\n"
"        writeFile(destFile, data, function (error) {\n"
"          if (!error) {\n"
"            console.log(\"File copied\");\n"
"          }\n"
"        });\n"
"      }\n"
"    });\n"
"    ```\n"
msgstr ""
"    readFile(sourceFile, function (error, data) {\n"
"      if (!error) {\n"
"        writeFile(destFile, data, function (error) {\n"
"          if (!error) {\n"
"            console.log(\"File copied\");\n"
"          }\n"
"        });\n"
"      }\n"
"    });\n"
"    ```\n"

#. type: Plain text
#: text/chapter1.md:36
msgid ""
"- Libraries such as [React](https://reactjs.org) and [virtual-dom](https://"
"github.com/Matt-Esch/virtual-dom) model views as pure functions of "
"application state."
msgstr ""
"- [React](https://reactjs.org)や\n"
"  [virtual-dom](https://github.com/Matt-Esch/virtual-dom)などのライブラリは、\n"
"  アプリケーションの状態についての純粋な関数としてその外観をモデル化しています。"

#. type: Plain text
#: text/chapter1.md:38
msgid ""
"Functions enable a simple form of abstraction which can yield great "
"productivity gains. However, functional programming in JavaScript has its "
"own disadvantages: JavaScript is verbose, untyped, and lacks powerful forms "
"of abstraction. Unrestricted JavaScript code also makes equational reasoning "
"very difficult."
msgstr ""
"関数は単純な抽象化を可能にし、優れた生産性をもたらしてくれます。\n"
"しかし、JavaScriptでの関数型プログラミングには欠点があります。\n"
"JavaScriptは冗長で、型付けされず、強力な抽象化を欠いているのです。\n"
"また、無秩序に書かれたJavaScriptコードでは、等式推論がとても困難です。"

#. type: Plain text
#: text/chapter1.md:40
msgid ""
"PureScript is a programming language which aims to address these issues. It "
"features lightweight syntax, which allows us to write very expressive code "
"which is still clear and readable. It uses a rich type system to support "
"powerful abstractions. It also generates fast, understandable code, which is "
"important when interoperating with JavaScript, or other languages which "
"compile to JavaScript. All in all, I hope to convince you that PureScript "
"strikes a very practical balance between the theoretical power of purely "
"functional programming, and the fast-and-loose programming style of "
"JavaScript."
msgstr ""
"PureScriptはこのような問題を解決すべく作られたプログラミング言語です。\n"
"PureScriptは、とても表現力豊かでありながらわかりやすく読みやすいコードを書けるようにする、\n"
"軽量な構文を備えています。\n"
"強力な抽象化を提供する豊かな型システムも採用しています。\n"
"また、JavaScriptやJavaScriptへとコンパイルされる他の言語と相互運用するときに重要な、\n"
"高速で理解しやすいコードを生成します。\n"
"PureScriptをひとことで言えば、純粋関数型プログラミングの理論的な強力さと、\n"
"JavaScriptのお手軽で緩いプログラミングスタイルとの、\n"
"とても現実的なバランスを狙った言語だということを理解して頂けたらと思います。"

#. type: Title ##
#: text/chapter1.md:41
#, no-wrap
msgid "Types and Type Inference"
msgstr "型と型推論"

#. type: Plain text
#: text/chapter1.md:44
msgid ""
"The debate over statically typed languages versus dynamically typed "
"languages is well-documented. PureScript is a _statically typed_ language, "
"meaning that a correct program can be given a _type_ by the compiler which "
"indicates its behavior. Conversely, programs which cannot be given a type "
"are _incorrect programs_, and will be rejected by the compiler. In "
"PureScript, unlike in dynamically typed languages, types exist only at "
"_compile-time_, and have no representation at runtime."
msgstr ""
"動的型付けの言語と静的型付けの言語をめぐる議論についてはよく知られています。\n"
"PureScriptは**静的型付け**の言語、\n"
"つまり正しいプログラムはコンパイラによってその動作を示すような**型**を与えられる言語です。\n"
"逆にいえば、型を​​与えることができないプログラムは**誤ったプログラム**であり、\n"
"コンパイラによって拒否されます。\n"
"動的型付けの言語とは異なり、\n"
"PureScriptでは型は**コンパイル時**のみに存在し、\n"
"実行時には型の表現はありません。"

#. type: Plain text
#: text/chapter1.md:46
msgid ""
"It is important to note that in many ways, the types in PureScript are "
"unlike the types that you might have seen in other languages like Java or "
"C#. While they serve the same purpose at a high level, the types in "
"PureScript are inspired by languages like ML and Haskell. PureScript's types "
"are expressive, allowing the developer to assert strong claims about their "
"programs. Most importantly, PureScript's type system supports _type "
"inference_ - it requires far fewer explicit type annotations than other "
"languages, making the type system a _tool_ rather than a hindrance. As a "
"simple example, the following code defines a _number_, but there is no "
"mention of the `Number` type anywhere in the code:"
msgstr ""
"PureScriptの型は、これまでJavaやC#のような他の言語で見たような型とは、\n"
"いろいろな意味で異なっていることにも注意することが大切です。\n"
"おおまかに言えばPureScriptの型はJavaやC#と同じ目的を持っているものの、\n"
"PureScriptの型はMLとHaskellのような言語に影響を受けています。\n"
"開発者がプログラムについての強い主張を表明できるので、PureScriptの型は表現力豊かなのです。\n"
"最も重要なのは、PureScriptの型システムは**型推論**(type inference)をサポートしていることです。\n"
"型推論があれば他の言語より遥かに少ない型注釈で住み、\n"
"型システムを厄介者ではなく**道具**にしてくれます。\n"
"簡単な例を示すと、次のコードは**数**を定義していますが、\n"
"それが `Number`型だという注釈はコードのどこにもありません。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:47
#, no-wrap
msgid ""
"iAmANumber =\n"
"  let square x = x * x\n"
"  in square 42.0\n"
msgstr ""
"iAmANumber =\n"
"  let square x = x * x\n"
"  in square 42.0\n"

#. type: Plain text
#: text/chapter1.md:54
msgid ""
"A more involved example shows that type-correctness can be confirmed without "
"type annotations, even when there exist types which are _unknown to the "
"compiler_:"
msgstr ""
"次のもっと複雑な例では、\n"
"**コンパイラにとって未知**の型が存在しているときでさえも、\n"
"型注釈なしで型の正しさを確かめることができるということが示されています。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:55
#, no-wrap
msgid ""
"iterate f 0 x = x\n"
"iterate f n x = iterate f (n - 1) (f x)\n"
msgstr ""
"iterate f 0 x = x\n"
"iterate f n x = iterate f (n - 1) (f x)\n"

#. type: Plain text
#: text/chapter1.md:61
msgid ""
"Here, the type of `x` is unknown, but the compiler can still verify that "
"`iterate` obeys the rules of the type system, no matter what type `x` might "
"have."
msgstr ""
"ここで `x`の型は不明ですが、\n"
"`x`がどんな型を持っているかにかかわらず、\n"
"`iterate`が型システムの規則に従っていることをコンパイラは検証することができます。"

#. type: Plain text
#: text/chapter1.md:63
msgid ""
"In this book, I will try to convince you (or reaffirm your belief) that "
"static types are not only a means of gaining confidence in the correctness "
"of your programs, but also an aid to development in their own right. "
"Refactoring a large body of code in JavaScript can be difficult when using "
"any but the simplest of abstractions, but an expressive type system together "
"with a type checker can even make refactoring into an enjoyable, interactive "
"experience."
msgstr ""
"本書で納得していただきたい（または既にお持ちの信条に寄り添って改めて断言したい）ことは、\n"
"静的型が単にプログラムの正しさに自信を持つためだけのものではなく、\n"
"それ自身の正しさによって開発の手助けになるものでもあるということです。\n"
"JavaScriptではごく単純な抽象化を施すのでも大規模なコードのリファクタリングをすることは難しいですが、\n"
"型検証器のある表現力豊かな型システムは、\n"
"リファクタリングさえ楽しく対話的な体験にしてくれます。"

#. type: Plain text
#: text/chapter1.md:65
msgid ""
"In addition, the safety net provided by a type system enables more advanced "
"forms of abstraction. In fact, PureScript provides a powerful form of "
"abstraction which is fundamentally type-driven: type classes, made popular "
"in the functional programming language Haskell."
msgstr ""
"加えて、型システムによって提供されるこのセーフティネットは、\n"
"より高度な抽象化をも可能にします。\n"
"実際に、関数型プログラミング言語Haskellによって知られるようになった、\n"
"型駆動の強力な抽象化の形式である『型クラス』をPureScriptは備えています。"

#. type: Title ##
#: text/chapter1.md:66
#, no-wrap
msgid "Polyglot Web Programming"
msgstr "多言語Webプログラミング"

#. type: Plain text
#: text/chapter1.md:69
msgid ""
"Functional programming has its success stories - applications where it has "
"been particularly successful: data analysis, parsing, compiler "
"implementation, generic programming, parallelism, to name a few."
msgstr ""
"関数型プログラミングはすでに多くの成功を収めています。\n"
"枚挙に暇がありませんが、特に成功している応用例をいくつか挙げると、\n"
"データ解析、構文解析、コンパイラの実装、ジェネリックプログラミング、並列処理などがあります。"

#. type: Plain text
#: text/chapter1.md:71
msgid ""
"It would be possible to practice end-to-end application development in a "
"functional language like PureScript. PureScript provides the ability to "
"import existing JavaScript code, by providing types for its values and "
"functions, and then to use those functions in regular PureScript code. We'll "
"see this approach later in the book."
msgstr ""
"PureScriptのような関数型言語は、\n"
"アプリケーション開発の最初から最後までを​実施することが可能です。\n"
"値や関数の型を提供することで既存のJavaScriptコードをインポートし、\n"
"通常のPureScriptコードからこれらの関数を使用する機能をPureScriptは提供しています。\n"
"この手法については本書の後半で見ていくことになります。"

#. type: Plain text
#: text/chapter1.md:73
msgid ""
"However, one of PureScript's strengths is its interoperability with other "
"languages which target JavaScript. Another approach would be to use "
"PureScript for a subset of your application's development, and to use one or "
"more other languages to write the rest of the JavaScript."
msgstr "しかしながら、PureScriptの強みのひとつは、JavaScriptを対象とする他​​の言語との相互運用性にあります。アプリケーションの開発の一部にだけPureScriptを使用し、JavaScriptの残りの部分を記述するのに他の言語を使用するという方法もあります。"

#. type: Plain text
#: text/chapter1.md:75
msgid "Here are some examples:"
msgstr "いくつかの例を示します。"

#. type: Plain text
#: text/chapter1.md:79
msgid ""
"- Core logic written in PureScript, with the user interface written in "
"JavaScript.  - Application written in JavaScript or another compile-to-JS "
"language, with tests written in PureScript.  - PureScript used to automate "
"user interface tests for an existing application."
msgstr ""
"- 中核となる処理はPureScriptで記述し、\n"
"  ユーザーインターフェイスはJavaScriptで記述する\n"
"- JavaScriptや、他のJavaScriptにコンパイルされる言語でアプリケーションを書き、\n"
"  PureScriptでそのテストを書く\n"
"- 既存のアプリケーションのユーザインタフェースのテストを自動化するためにPureScriptを使用する"

#. type: Plain text
#: text/chapter1.md:81
msgid ""
"In this book, we'll focus on solving small problems with PureScript. The "
"solutions could be integrated into a larger application, but we will also "
"look at how to call PureScript code from JavaScript, and vice versa."
msgstr ""
"この本では小規模な課題をPureScriptで解決することに焦点を当てます。\n"
"ここで学ぶ手法は大規模なアプリケーションに組み込むこともできますが、\n"
"これについてはJavaScriptからPureScriptコードを呼び出す方法、およびその逆についても見ていきます。"

#. type: Title ##
#: text/chapter1.md:82
#, no-wrap
msgid "Prerequisites"
msgstr "ソフトウェア要件"

#. type: Plain text
#: text/chapter1.md:85
msgid ""
"The software requirements for this book are minimal: the first chapter will "
"guide you through setting up a development environment from scratch, and the "
"tools we will use are available in the standard repositories of most modern "
"operating systems."
msgstr ""
"この本でのソフトウェア要件は最小限です。\n"
"第1章では開発環境の構築を一から案内します。\n"
"これから使用するツールは、ほとんどの現代のオペレーティングシステムの標準リポジトリで使用できるものです。"

#. type: Plain text
#: text/chapter1.md:87
msgid ""
"The PureScript compiler itself can be downloaded as a binary distribution, "
"or built from source on any system running an up-to-date installation of the "
"GHC Haskell compiler, and we will walk through this process in the next "
"chapter."
msgstr ""
"PureScriptコンパイラ自体はバイナリ形式でダウンロードすることもできますし、\n"
"最新のHaskellコンパイラが稼働しているシステム上でソースからビルドすることもできます。\n"
"次の章ではこの手順を説明していきます。"

#. type: Plain text
#: text/chapter1.md:90
msgid ""
"The code in this version of the book is compatible with versions `0.15.*` of "
"the PureScript compiler."
msgstr "本書のこのバージョンのコードは`0.15.*`バージョンのPureScriptコンパイラと互換性があります。"

#. type: Title ##
#: text/chapter1.md:91
#, no-wrap
msgid "About You"
msgstr "読者について"

#. type: Plain text
#: text/chapter1.md:94
msgid ""
"I will assume that you are familiar with the basics of JavaScript. Any prior "
"familiarity with common tools from the JavaScript ecosystem, such as NPM and "
"Gulp, will be beneficial if you wish to customize the standard setup to your "
"own needs, but such knowledge is not necessary."
msgstr ""
"読者はJavaScriptの基本をすでに理解しているものと仮定します。\n"
"すでにNPMやBowerのようなJavaScriptのエコシステムでの経験があれば、\n"
"自身の好みに応じて標準設定をカスタマイズしたい場合などに役に立ちます。\n"
"ですが、そのような知識は必須ではありません。"

#. type: Plain text
#: text/chapter1.md:96
msgid ""
"No prior knowledge of functional programming is required, but it certainly "
"won't hurt. New ideas will be accompanied by practical examples, so you "
"should be able to form an intuition for the concepts from functional "
"programming that we will use."
msgstr ""
"関数型プログラミングの予備知識は必要ありませんが、\n"
"あっても害にはならないでしょう。\n"
"新しい考えかたは実例とともに登場するので、\n"
"これから使う関数型プログラミングからこうした概念に対する直感的な理解を得ることができるはずです。"

#. type: Plain text
#: text/chapter1.md:98
msgid ""
"Readers who are familiar with the Haskell programming language will "
"recognize a lot of the ideas and syntax presented in this book, because "
"PureScript is heavily influenced by Haskell. However, those readers should "
"understand that there are a number of important differences between "
"PureScript and Haskell. It is not necessarily always appropriate to try to "
"apply ideas from one language in the other, although many of the concepts "
"presented here will have some interpretation in Haskell."
msgstr "PureScriptはプログラミング言語Haskellに強く影響を受けているため、Haskellに通じている読者はこの本の中で提示された概念や構文の多くに見覚えがあるでしょう。しかしながら、読者はPureScriptとHaskellの間にはいくつか重要な違いがあることも理解しておかなければなりません。ここで紹介する概念の多くはHaskellでも同じように解釈できるとはいえ、どちらかの言語での考え方を他方の言語でそのまま応用しようとすることは、必ずしも適切ではありません。"

#. type: Title ##
#: text/chapter1.md:99
#, no-wrap
msgid "How to Read This Book"
msgstr "本書の読み進めかた"

#. type: Plain text
#: text/chapter1.md:102
msgid ""
"The chapters in this book are largely self contained. A beginner with little "
"functional programming experience would be well-advised, however, to work "
"through the chapters in order. The first few chapters lay the groundwork "
"required to understand the material later on in the book. A reader who is "
"comfortable with the ideas of functional programming (especially one with "
"experience in a strongly-typed language like ML or Haskell) will probably be "
"able to gain a general understanding of the code in the later chapters of "
"the book without reading the preceding chapters."
msgstr ""
"本書の各章は、概ね章ごとに完結しています。\n"
"しかしながら、多少の関数型プログラミングの経験がある初心者でも、\n"
"まずは各章を順番に進めていくことをおすすめします。\n"
"最初の数章では、本書の後半の内容を理解するために必要な基礎知識を養います。\n"
"関数型プログラミングの考え方に十分通じた読者\n"
"（特にMLやHaskellのよう強く型付けされた言語での経験を持つ読者）なら、\n"
"本書の前半の章を読まなくても、後半の章のコードの大まかな理解を得ることがおそらく可能でしょう。"

#. type: Plain text
#: text/chapter1.md:104
msgid ""
"Each chapter will focus on a single practical example, providing the "
"motivation for any new ideas introduced. Code for each chapter are available "
"from the book's [GitHub repository](https://github.com/purescript-contrib/"
"purescript-book). Some chapters will include code snippets taken from the "
"chapter's source code, but for a full understanding, you should read the "
"source code from the repository alongside the material from the book. Longer "
"sections will contain shorter snippets which you can execute in the "
"interactive mode PSCi to test your understanding."
msgstr ""
"各章ではそれぞれひとつの実用的な例に焦点をあて、新しい考え方を導入するための動機付けとして用います。\n"
"各章のコードは本書の[GitHubのリポジトリ](https://github.com/purescript-contrib/purescript-book)から入手できます。\n"
"ソースコードから抜粋したコード片が掲載されている章もありますが、完全に理解するためには本書に掲載されたコードと平行してリポジトリのソースコードを読む必要があります。\n"
"対話式環境PSCiで実行し理解を確かめられるように、長めの節には短いコード片が掲載されていることがあります。"

#. type: Plain text
#: text/chapter1.md:106
msgid "Code samples will appear in a monospaced font, as follows:"
msgstr "コード例は次のように等幅フォントで示されています。"

#. type: Fenced code block (haskell)
#: text/chapter1.md:107
#, no-wrap
msgid ""
"module Example where\n"
"\n"
"import Effect.Console (log)\n"
"\n"
"main = log \"Hello, World!\"\n"
msgstr ""
"module Example where\n"
"\n"
"import Effect.Console (log)\n"
"\n"
"main = log \"Hello, World!\"\n"

#. type: Plain text
#: text/chapter1.md:116
msgid ""
"Commands which should be typed at the command line will be preceded by a "
"dollar symbol:"
msgstr "先頭にドル記号がついた行は、コマンドラインに入力されたコマンドです。"

#. type: Fenced code block (text)
#: text/chapter1.md:117 text/chapter3.md:313
#, no-wrap
msgid "$ spago build\n"
msgstr "$ spago build\n"

#. type: Plain text
#: text/chapter1.md:122
msgid ""
"Usually, these commands will be tailored to Linux/Mac OS users, so Windows "
"users may need to make small changes such as modifying the file separator, "
"or replacing shell built-ins with their Windows equivalents."
msgstr ""
"通常、これらのコマンドはLinuxやMac OSの利用者ならそのまま適用できますが、"
"Windowsの利用者はファイル区切り文字を変更する、シェルの組み込み機能をWindows"
"の相当するものに置き換えるなどの小さな変更を加える必要があるかもしれません。"

#. type: Plain text
#: text/chapter1.md:124
msgid ""
"Commands which should be typed at the PSCi interactive mode prompt will be "
"preceded by an angle bracket:"
msgstr "PSCi対話式モードプロンプトに入力するコマンドは、行の先頭に山括弧が付けられています。"

#. type: Fenced code block (text)
#: text/chapter1.md:125
#, no-wrap
msgid ""
"> 1 + 2\n"
"3\n"
msgstr ""
"> 1 + 2\n"
"3\n"

#. type: Plain text
#: text/chapter1.md:131
msgid ""
"Each chapter will contain exercises, labelled with their difficulty level. "
"It is strongly recommended that you attempt the exercises in each chapter to "
"fully understand the material."
msgstr ""
"各章には演習が付いており、それぞれ難易度も示されています。各章の内容を完全に"
"理解するために、演習に取り組むことを強くお勧めします。"

#. type: Plain text
#: text/chapter1.md:133
msgid ""
"This book aims to provide an introduction to the PureScript language for "
"beginners, but it is not the sort of book that provides a list of template "
"solutions to problems. For beginners, this book should be a fun challenge, "
"and you will get the most benefit if you read the material, attempt the "
"exercises, and most importantly of all, try to write some code of your own."
msgstr "この本は初心者にPureScriptへの導入を提供することを目的としており、問題についてのお決まりの解決策の一覧を提供するような種類の本ではありません。初心者にとってこの本を読むのは楽しい挑戦になるはずですし、本書の内容を読み演習に挑戦すればだいたいの利益を得られるでしょうが、なにより重要なのは、あなたが自分自身のコードを書いてみることです。"

#. type: Title ##
#: text/chapter1.md:134
#, no-wrap
msgid "Getting Help"
msgstr "困ったときには"

#. type: Plain text
#: text/chapter1.md:137
msgid ""
"If you get stuck at any point, there are a number of resources available "
"online for learning PureScript:"
msgstr ""
"もしどこかでつまずいたときには、PureScriptを学べるオンラインで利用可能な資料"
"がたくさんあります。"

#. type: Plain text
#: text/chapter1.md:146
msgid ""
"- The [PureScript Discord server](https://discord.gg/vKn9up84bp) is a great "
"place to chat about issues you may be having. The server is dedicated to "
"chat about PureScript - The [Purescript Discourse Forum](https://discourse."
"purescript.org/) is another good place to search for solutions to common "
"problems. Questions you ask here will be available to help future readers, "
"whereas on Slack, message history is only kept for approximately 2 weeks.  - "
"[PureScript: Jordan's Reference](https://github.com/jordanmartinez/"
"purescript-jordans-reference)  is an alternative learning resource that goes "
"into great depth. If a concept in this book is difficult to understand, "
"consider reading the corresponding section in that reference.  - [Pursuit]"
"(https://pursuit.purescript.org) is a searchable database of PureScript "
"types and functions. Read Pursuit's help page to [learn what kinds of "
"searches you can do](https://pursuit.purescript.org/help/users).  - The "
"unofficial [PureScript Cookbook](https://github.com/JordanMartinez/"
"purescript-cookbook) provides answers via code to \"How do I do X?\"-type "
"questions.  - The [PureScript documentation repository](https://github.com/"
"purescript/documentation) collects articles and examples on a wide variety "
"of topics, written by PureScript developers and users.  - The [PureScript "
"website](https://www.purescript.org) contains links to several learning "
"resources, including code samples, videos and other resources for "
"beginners.  - [Try PureScript!](https://try.purescript.org) is a website "
"which allows users to compile PureScript code in the web browser, and "
"contains several simple examples of code."
msgstr ""
"- [PureScriptのDiscordサーバ](https://discord.gg/vKn9up84bp)は抱えている\n"
"  問題についてチャットするのに良い場所です。\n"
"  サーバはPureScriptについてのチャット専用です。\n"
"- [PurescriptのDiscourseフォーラム](https://discourse.purescript.org/)も\n"
"  よくある問題への解決策を探すのに良い場所です。\n"
"  メッセージ履歴が約2週間しか保たないSlackとは違い、\n"
"  ここで質問した内容は将来の読者の助けとして使えるでしょう。\n"
"- [PureScript: Jordan's Reference](https://github.com/jordanmartinez/purescript-jordans-reference)\n"
"  は別のかなり深く踏み込んだ学習資料です。\n"
"  この本の中のある概念が理解しにくかったら、\n"
"  そちらの参考書の対応する節を読むとよいでしょう。\n"
"- [Pursuit](https://pursuit.purescript.org)\n"
"  はPureScriptの型と関数を検索できるデータベースです。\n"
"  Pursuitのヘルプページを読むと\n"
"  [どのような種類の検索ができるのかがわかります](https://pursuit.purescript.org/help/users)。\n"
"- 非公式の[PureScript Cookbook](https://github.com/JordanMartinez/purescript-cookbook)は\n"
"  「Xするにはどうするの？」といった類の質問にコードを混じえて答えを提供します。\n"
"- [PureScriptドキュメントリポジトリ](https://github.com/purescript/documentation)には、\n"
"  PureScriptの開発者や利用者が書いた幅広い話題の記事と例が集まっています。\n"
"- [PureScriptのWebサイト](https://www.purescript.org)には、\n"
"  コード例、映像、他の初心者向け資料を含むいくつかの学習資料へのリンクがあります。\n"
"- [Try PureScript!](https://try.purescript.org)は\n"
"  利用者がWebブラウザでPureScriptのコードをコンパイルすることができるWebサイトです。\n"
"  いくつかの簡単なコードの例があります。"

#. type: Plain text
#: text/chapter1.md:148
msgid ""
"If you prefer to learn by reading examples, the `purescript`, `purescript-"
"node` and `purescript-contrib` GitHub organizations contain plenty of "
"examples of PureScript code."
msgstr "もしあなたが例を読んで学ぶことを好むなら、GitHubの `purescript`組織、 `purescript-node`組織および `purescript-contrib`組織にはPureScriptコードの例がたくさんあります。"

#. type: Title ##
#: text/chapter1.md:149
#, no-wrap
msgid "About the Author"
msgstr "著者について"

#. type: Plain text
#: text/chapter1.md:152
msgid ""
"I am the original developer of the PureScript compiler. I'm based in Los "
"Angeles, California, and started programming at an early age in BASIC on an "
"8-bit personal computer, the Amstrad CPC. Since then I have worked "
"professionally in a variety of programming languages (including Java, Scala, "
"C#, F#, Haskell and PureScript)."
msgstr ""
"私はPureScriptコンパイラの最初の開発者です。私はカリフォルニア州ロサンゼルスを拠点にしており、8ビットパーソナルコンピュータ、Amstrad CPC上のBASICでまだ幼い時にプログラミングを始めました。\n"
"それ以来、私はいくつものプログラミング言語（JavaやScala、C#、F#、Haskell、そしてPureScript）で業務に携わってきました。"

#. type: Plain text
#: text/chapter1.md:154
msgid ""
"Not long into my professional career, I began to appreciate functional "
"programming and its connections with mathematics, and enjoyed learning "
"functional concepts using the Haskell programming language."
msgstr ""
"プロとしての経歴が始まって間もなく、私は関数型プログラミングと数学の関係を理解するようになり、\n"
"そしてプログラミング言語Haskellを使って関数型の概念の学習を楽しみました。"

#. type: Plain text
#: text/chapter1.md:156
msgid ""
"I started working on the PureScript compiler in response to my experience "
"with JavaScript. I found myself using functional programming techniques that "
"I had picked up in languages like Haskell, but wanted a more principled "
"environment in which to apply them. Solutions at the time included various "
"attempts to compile Haskell to JavaScript while preserving its semantics "
"(Fay, Haste, GHCJS), but I was interested to see how successful I could be "
"by approaching the problem from the other side - attempting to keep the "
"semantics of JavaScript, while enjoying the syntax and type system of a "
"language like Haskell."
msgstr ""
"JavaScriptでの経験をもとに、私はPureScriptコンパイラの開発を始めることにしました。\n"
"気が付くとHaskellのような言語から取り上げた関数型プログラミングの手法を使っていましたが、それを応用するためのもっと理にかなった環境を求めていました。\n"
"そのとき検討した案のなかには、Haskellからその意味論を維持しながらJavaScriptへとコンパイルするいろいろな試み（Fay、Haste、GHCJS）もありましたが、私が興味を持っていたのは、この問題への別の切り口からのアプローチ、すなわちHaskellのような言語の構文と型システムを楽しみながらJavaScriptの意味論も維持するということが、どのようにすれば可能になるのかでした。"

#. type: Plain text
#: text/chapter1.md:158
msgid ""
"I maintain [a blog](https://blog.functorial.com), and can be [reached on "
"Twitter](https://twitter.com/paf31)."
msgstr "私は[ブログ](http://blog.functorial.com)を運営しており、[Twitterで連絡をとる](http://twitter.com/paf31)こともできます。"

#. type: Title ##
#: text/chapter1.md:159
#, no-wrap
msgid "Acknowledgements"
msgstr "謝辞"

#. type: Plain text
#: text/chapter1.md:162
msgid ""
"I would like to thank the many contributors who helped PureScript to reach "
"its current state. Without the huge collective effort which has been made on "
"the compiler, tools, libraries, documentation and tests, the project would "
"certainly have failed."
msgstr ""
"現在の状態に到達するまでPureScriptを手伝ってくれた多くの協力者に感謝したいと"
"思います。コンパイラやツール、ライブラリ、ドキュメント、テストでの組織的で弛"
"まぬ努力がなかったら、プロジェクトは間違いなく失敗していたことでしょう。"

#. type: Plain text
#: text/chapter1.md:164
msgid ""
"The PureScript logo which appears on the cover of this book was created by "
"Gareth Hughes, and is gratefully reused here under the terms of the "
"[Creative Commons Attribution 4.0 license](https://creativecommons.org/"
"licenses/by/4.0/)."
msgstr ""
"この本の表紙に表示されたPureScriptのロゴはGareth Hughesによって作成されたもの"
"で、[Creative Commons Attribution 4.0 license](https://creativecommons.org/"
"licenses/by/4.0/)の条件の下で再利用させて頂いています 。"

#. type: Plain text
#: text/chapter1.md:165
msgid ""
"Finally, I would like to thank everyone who has given me feedback and "
"corrections on the contents of this book."
msgstr ""
"最後に、この本の内容に関する反応や訂正をくださったすべての方に、心より感謝し"
"たいと思います。"

#. type: Title #
#: text/chapter10.md:1
#, no-wrap
msgid "The Foreign Function Interface"
msgstr "外部関数インタフェース"

#. type: Title ##
#: text/chapter10.md:3 text/chapter11.md:3 text/chapter12.md:3
#: text/chapter13.md:3 text/chapter14.md:3 text/chapter2.md:3
#: text/chapter3.md:3 text/chapter4.md:3 text/chapter5.md:3 text/chapter6.md:3
#: text/chapter7.md:3 text/chapter8.md:3 text/chapter9.md:3
#, no-wrap
msgid "Chapter Goals"
msgstr "この章の目標"

#. type: Plain text
#: text/chapter10.md:6
#, fuzzy
msgid ""
"This chapter will introduce PureScript's _foreign function interface_ (or "
"_FFI_), which enables communication from PureScript code to JavaScript code, "
"and vice versa. We will cover how to:"
msgstr ""
"この章でPureScriptの**外部関数インターフェース** (foreign function interface; FFI)を紹介します。\n"
"これによりPureScriptコードからJavaScriptコードへの呼び出し、およびその逆が可能になります。\n"
"これから扱うのは次のようなものです。"

#. type: Plain text
#: text/chapter10.md:10
msgid ""
"- Call pure, effectful, and asynchronous JavaScript functions from "
"PureScript.  - Work with untyped data.  - Encode and parse JSON using the "
"`argonaut` package."
msgstr ""

#. type: Plain text
#: text/chapter10.md:12
#, fuzzy
msgid ""
"Towards the end of this chapter, we will revisit our recurring address book "
"example. The goal of the chapter will be to add the following new "
"functionality to our application using the FFI:"
msgstr ""
"この章の終わりにかけて、再び住所録のコード例について検討します。この章の目的"
"は、FFIを使ってアプリケーションに次のような新しい機能を追加することです。"

#. type: Plain text
#: text/chapter10.md:15
#, fuzzy
msgid ""
"- Alert the user with a popup notification.  - Store the serialized form "
"data in the browser's local storage, and reload it when the application "
"restarts."
msgstr ""
"- ポップアップ通知でユーザーに警告する - フォームのデータを直列化してブラウザ"
"のローカルストレージに保存し、アプリケーションが再起動したときにそれを再読み"
"込みする"

#. type: Plain text
#: text/chapter10.md:17
msgid ""
"There is also an addendum which covers some additional topics which are not "
"as commonly sought-after. Feel free to read these sections, but don't let "
"them stand in the way of progressing through the remainder of the book if "
"they're less relevant to your learning objectives:"
msgstr ""

#. type: Plain text
#: text/chapter10.md:20
msgid ""
"- Understand the representation of PureScript values at runtime.  - Call "
"PureScript functions from JavaScript."
msgstr ""

#. type: Title ##
#: text/chapter10.md:21 text/chapter11.md:7 text/chapter12.md:7
#: text/chapter13.md:9 text/chapter14.md:16 text/chapter3.md:11
#: text/chapter4.md:11 text/chapter5.md:13 text/chapter6.md:13
#: text/chapter7.md:11 text/chapter8.md:9 text/chapter9.md:7
#, no-wrap
msgid "Project Setup"
msgstr "プロジェクトの準備"

#. type: Plain text
#: text/chapter10.md:24
#, fuzzy
msgid ""
"The source code for this module is a continuation of the source code from "
"chapters 3, 7 and 8. As such, the source tree includes the appropriate "
"source files from those chapters."
msgstr ""
"このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。今回も"
"それぞれのディレクトリから適切なソースファイルがソースファイルに含められてい"
"ます。"

#. type: Plain text
#: text/chapter10.md:26
msgid ""
"This chapter introduces the `argonaut` library as a dependency. This library "
"is used for encoding and decoding JSON."
msgstr ""

#. type: Plain text
#: text/chapter10.md:28
msgid ""
"The exercises for this chapter should be written in `test/MySolutions.purs` "
"and can be checked against the unit tests in `test/Main.purs` by running "
"`spago test`."
msgstr ""

#. type: Plain text
#: text/chapter10.md:30
msgid ""
"The Address Book app can be launched with `parcel src/index.html --open`. It "
"uses the same workflow from Chapter 8, so refer to that chapter for more "
"detailed instructions."
msgstr ""

#. type: Title ##
#: text/chapter10.md:31
#, fuzzy, no-wrap
msgid "A Disclaimer"
msgstr "免責事項"

#. type: Plain text
#: text/chapter10.md:34
#, fuzzy
msgid ""
"PureScript provides a straightforward foreign function interface to make "
"working with JavaScript as simple as possible. However, it should be noted "
"that the FFI is an _advanced_ feature of the language. To use it safely and "
"effectively, you should have an understanding of the runtime representation "
"of the data you plan to work with. This chapter aims to impart such an "
"understanding as pertains to code in PureScript's standard libraries."
msgstr ""
"JavaScriptとの共同作業をできる限り簡単にするため、PureScriptは単純な多言語関"
"数インタフェースを提供します。しかしながら、FFIはPureScriptの**高度な**機能で"
"あることには留意していただきたいと思います。FFIを安全かつ効率的に使用するに"
"は、扱うつもりであるデータの実行時の表現についてよく理解していなければなりま"
"せん。この章では、PureScriptの標準ライブラリのコードに関連する、そのような理"
"解を与えることを目指しています。"

#. type: Plain text
#: text/chapter10.md:36
#, fuzzy
msgid ""
"PureScript's FFI is designed to be very flexible. In practice, this means "
"that developers have a choice, between giving their foreign functions very "
"simple types, or using the type system to protect against accidental misuses "
"of foreign code. Code in the standard libraries tends to favor the latter "
"approach."
msgstr ""
"PureScriptのFFIはとても柔軟に設計されています。実際には、外部関数に最低限の型"
"だけを与えるか、それとも型システムを利用して外部のコードの誤った使い方を防ぐ"
"ようにするか、開発者が選ぶことができるということを意味しています。標準ライブ"
"ラリのコードは、後者の手法を好む傾向にあります。"

#. type: Plain text
#: text/chapter10.md:38
#, fuzzy
msgid ""
"As a simple example, a JavaScript function makes no guarantees that its "
"return value will not be `null`. Indeed, idiomatic JavaScript code returns "
"`null` quite frequently! However, PureScript's types are usually not "
"inhabited by a null value. Therefore, it is the responsibility of the "
"developer to handle these corner cases appropriately when designing their "
"interfaces to JavaScript code using the FFI."
msgstr ""
"簡単な例としては、JavaScriptの関数で戻り値が `null`をされないことを保証するこ"
"とはできません。実のところ、既存のJavaScriptコードはかなり頻繁に `null`を返し"
"ます！しかし、PureScriptの型は通常null値を持っていません。そのため、FFIを使っ"
"てJavaScriptコードのインターフェイスを設計するときは、これらの特殊な場合を適"
"切に処理するのは開発者の責任です。"

#. type: Title ##
#: text/chapter10.md:39
#, fuzzy, no-wrap
msgid "Calling JavaScript From PureScript"
msgstr "PureScriptからのJavaScriptコードを使う"

#. type: Plain text
#: text/chapter10.md:42
#, fuzzy
msgid ""
"The simplest way to use JavaScript code from PureScript is to give a type to "
"an existing JavaScript value using a _foreign import_ declaration. Foreign "
"import declarations must have a corresponding JavaScript declaration "
"_exported_ from a _foreign JavaScript module_."
msgstr ""
"PureScriptからJavaScriptコードを使用する最も簡単な方法は、**外部インポート宣"
"言**(foreign import declaration)を使用し、既存のJavaScriptの値に型を与えるこ"
"とです。外部インポート宣言では、対応するJavaScriptの宣言を**外部JavaScriptモ"
"ジュール**(foreign JavaScript module)に持つ必要があります。"

#. type: Plain text
#: text/chapter10.md:44
#, fuzzy
msgid ""
"For example, consider the `encodeURIComponent` function, which can be used "
"in JavaScript to encode a component of a URI by escaping special characters:"
msgstr ""
"たとえば、特殊文字をエスケープすることによりURIのコンポーネントを符号化する"
"JavaScriptの `encodeURIComponent`関数について考えてみます。"

#. type: Fenced code block (text)
#: text/chapter10.md:45
#, fuzzy, no-wrap
msgid ""
"$ node\n"
"\n"
"node> encodeURIComponent('Hello World')\n"
"'Hello%20World'\n"
msgstr ""
"$ node\n"
"\n"
"node> encodeURIComponent('Hello World')\n"
"'Hello%20World'\n"

#. type: Plain text
#: text/chapter10.md:53
#, fuzzy, no-wrap
msgid "This function has the correct runtime representation for the function type `String -> String`, since it takes non-null strings to non-null strings, and has no other side-effects.\n"
msgstr "`null`でない文字列から `null`でない文字列への関数であり、副作用を持っていないので、この関数はその型 `String -> String`について適切な実行時表現を持っています。\n"

#. type: Plain text
#: text/chapter10.md:55
#, fuzzy
msgid ""
"We can assign this type to the function with the following foreign import "
"declaration:"
msgstr ""
"次のような外部インポート宣言を使うと、この関数に型を割り当てることができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:56
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.purs}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:62
msgid ""
"We also need to write a foreign JavaScript module to import it from. A "
"corresponding foreign JavaScript module is one of the same name but "
"extension changed from `.purs` to `.js`. If the Purescript module above is "
"saved as `URI.purs`, then the foreign JavaScript module is saved as `URI."
"js`.  Since `encodeURIComponent` is already defined, we have to export it as "
"`_encodeURIComponent`:"
msgstr ""

#. type: Fenced code block (javascript)
#: text/chapter10.md:63
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/URI.js}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:68
msgid ""
"Since version 0.15, Purescript uses the ES module system when interoperating "
"with JavaScript. In ES modules, functions and values are exported from a "
"module by providing the `export` keyword on an object."
msgstr ""

#. type: Plain text
#: text/chapter10.md:70
#, fuzzy
msgid ""
"With these two pieces in place, we can now use the `_encodeURIComponent` "
"function from PureScript like any function written in PureScript. For "
"example, in PSCi, we can reproduce the calculation above:"
msgstr ""
"これら2つの部品を使うことで、PureScriptで書かれた関数のように、PureScriptから"
"`encodeURIComponent`関数を使うことができます。たとえば、この宣言をモジュール"
"として保存してPSCiにロードすると、上記の計算を再現できます。"

#. type: Fenced code block (text)
#: text/chapter10.md:71
#, fuzzy, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.URI\n"
"> _encodeURIComponent \"Hello World\"\n"
"\"Hello%20World\"\n"
msgstr ""
"$ pulp repl\n"
"\n"
"> import Data.URI\n"
"> encodeURIComponent \"Hello World\"\n"
"\"Hello%20World\"\n"

#. type: Plain text
#: text/chapter10.md:80
msgid ""
"We can also define our own functions in foreign modules. Here's an example "
"of how to create and call a custom JavaScript function that squares a "
"`Number`:"
msgstr ""

#. type: Plain text
#: text/chapter10.md:82
msgid "`test/Examples.js`:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:83
#, no-wrap
msgid ""
"\"use strict\";\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.js:square}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:90
msgid "`test/Examples.purs`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:91
#, no-wrap
msgid ""
"module Test.Examples where\n"
"\n"
"foreign import square :: Number -> Number\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:97
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> square 5.0\n"
"25.0\n"
msgstr ""

#. type: Title ##
#: text/chapter10.md:105
#, fuzzy, no-wrap
msgid "Functions of Multiple Arguments"
msgstr "多変数​関数"

#. type: Plain text
#: text/chapter10.md:108
msgid ""
"Let's rewrite our `diagonal` function from Chapter 2 in a foreign module. "
"This function calculates the diagonal of a right-angled triangle."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:110
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:115
msgid ""
"Recall that functions in PureScript are _curried_. `diagonal` is a function "
"that takes a `Number` and returns a _function_, that takes a `Number` and "
"returns a `Number`."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:117
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:122
msgid "Or with ES6 arrow syntax (see ES6 note below)."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:124
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_arrow}}\n"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:128
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_arrow}}\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:132
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> diagonal 3.0 4.0\n"
"5.0\n"
"> diagonalArrow 3.0 4.0\n"
"5.0\n"
msgstr ""

#. type: Title ##
#: text/chapter10.md:142
#, fuzzy, no-wrap
msgid "Uncurried Functions"
msgstr "カリー化された関数"

#. type: Plain text
#: text/chapter10.md:145
msgid ""
"Writing curried functions in JavaScript isn't always feasible, despite being "
"scarcely idiomatic. A typical multi-argument JavaScript function would be of "
"the _uncurried_ form:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:146
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.js:diagonal_uncurried}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:151
msgid ""
"The module `Data.Function.Uncurried` exports _wrapper_ types and utility "
"functions to work with uncurried functions."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:152
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:diagonal_uncurried}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:157
msgid "Inspecting the type constructor `Fn2`:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:158
#, fuzzy, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Function.Uncurried \n"
"> :kind Fn2\n"
"Type -> Type -> Type -> Type\n"
msgstr ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:167
#, fuzzy
msgid ""
"`Fn2` takes three type arguments. `Fn2 a b c` is a type representing an "
"uncurried function of two arguments of types `a` and `b`, that returns a "
"value of type `c`. We used it to import `diagonalUncurried` from the foreign "
"module."
msgstr ""
"これは3つの型引数を取る型構築子 `Fn2`を定義します。 `Fn2 a b c`は、型 `a`と "
"`b`の２つの引数、返り値の型 `c`をもつJavaScript関数の型を表現しています。"

#. type: Plain text
#: text/chapter10.md:169
msgid ""
"We can then call it with `runFn2` which takes the uncurried function then "
"the arguments."
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:170
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Function.Uncurried\n"
"> runFn2 diagonalUncurried 3.0 4.0\n"
"5.0\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:180
#, fuzzy
msgid ""
"The `functions` package defines similar type constructors for function "
"arities from 0 to 10."
msgstr ""
"Preludeでは0引数から10引数までの関数について同様の型構築子が定義されていま"
"す。"

#. type: Title ##
#: text/chapter10.md:181
#, fuzzy, no-wrap
msgid "A Note About Uncurried Functions"
msgstr "カリー化された関数"

#. type: Plain text
#: text/chapter10.md:184
#, fuzzy
msgid ""
"PureScript's curried functions has certain advantages. It allows us to "
"partially apply functions, and to give type class instances for function "
"types - but it comes with a performance penalty. For performance critical "
"code, it is sometimes necessary to define uncurried JavaScript functions "
"which accept multiple arguments."
msgstr ""
"PureScriptのPreludeには、興味深い外部型がいくつかも含まれています。すでに扱っ"
"てきたように、PureScriptの関数型は単一の引数だけを取りますが、**カリー化"
"**(Currying)を使うと複数の引数の関数をシミュレートすることができます。これに"
"は明らかな利点があります。関数を部分適用することができ、関数型の型クラスイン"
"スタンスを与えることができます。ただし、効率上のペナルティが生じます。パ"
"フォーマンス重視するコードでは、複数の引数を受け入れる本物のJavaScript関数を"
"定義することが必要な場合があります。Preludeではそのような関数を安全に扱うこと"
"ができるようにする外部型が定義されています。"

#. type: Plain text
#: text/chapter10.md:186
#, fuzzy
msgid ""
"We can also create uncurried functions from PureScript. For a function of "
"two arguments, we can use the `mkFn2` function."
msgstr "次のように `mkFn2`関数を使うと、2引数の関数を作成することができます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:187
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_add}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:192
#, fuzzy
msgid ""
"We can apply the uncurried function of two arguments by using `runFn2` as "
"before:"
msgstr "そして、 `runFn2`関数を使うと、2引数の関数を適用することができます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:193
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:uncurried_sum}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:198
#, fuzzy
msgid ""
"The key here is that the compiler _inlines_ the `mkFn2` and `runFn2` "
"functions whenever they are fully applied. The result is that the generated "
"code is very compact:"
msgstr ""
"ここで重要なのは、引数がすべて適用されるなら、コンパイラは `mkFn2`関数や "
"`runFn2`関数を**インライン化**するということです。そのため、生成されるコード"
"はとてもコンパクトになります。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:199
#, no-wrap
msgid ""
"var uncurriedAdd = function (n, m) {\n"
"  return m + n | 0;\n"
"};\n"
"\n"
"var uncurriedSum = uncurriedAdd(3, 10);\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:208
msgid "For contrast, here is a traditional curried function:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter10.md:209
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:curried_add}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:214
msgid ""
"and the resulting generated code, which is less compact due to the nested "
"functions:"
msgstr ""

#. type: Fenced code block (javascript)
#: text/chapter10.md:215
#, fuzzy, no-wrap
msgid ""
"var curriedAdd = function (n) {\n"
"  return function (m) {\n"
"    return m + n | 0;\n"
"  };\n"
"};\n"
"\n"
"var curriedSum = curriedAdd(3)(10);\n"
msgstr ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"

#. type: Title ##
#: text/chapter10.md:225
#, no-wrap
msgid "A Note About Modern JavaScript Syntax"
msgstr ""

#. type: Plain text
#: text/chapter10.md:228
msgid ""
"The arrow function syntax we saw earlier is an ES6 feature, and so it is "
"incompatible with some older browsers (namely IE11). As of writing, it is "
"[estimated that arrow functions are unavailable for the 6% of users](https://"
"caniuse.com/#feat=arrow-functions) who have not yet updated their web "
"browser."
msgstr ""

#. type: Plain text
#: text/chapter10.md:230
msgid ""
"In order to be compatible with the most users, the JavaScript code generated "
"by the PureScript compiler does not use arrow functions. It is also "
"recommended to **avoid arrow functions in public libraries** for the same "
"reason."
msgstr ""

#. type: Plain text
#: text/chapter10.md:232
msgid ""
"You may still use arrow functions in your own FFI code, but then should "
"include a tool such as [Babel](https://github.com/babel/babel#intro) in your "
"deployment workflow to convert these back to ES5 compatible functions."
msgstr ""

#. type: Plain text
#: text/chapter10.md:234
msgid ""
"If you find arrow functions in ES6 more readable, you may transform "
"JavaScript code in the compiler's `output` directory with a tool like [Lebab]"
"(https://github.com/lebab/lebab):"
msgstr ""

#. type: Fenced code block (sh)
#: text/chapter10.md:235
#, no-wrap
msgid ""
"npm i -g lebab\n"
"lebab --replace output/ --transform arrow,arrow-return\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:241
msgid "This operation would convert the above `curriedAdd` function to:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:242
#, no-wrap
msgid ""
"var curriedAdd = n => m =>\n"
"  m + n | 0;\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:248
msgid ""
"The remaining examples in this book will use arrow functions instead of "
"nested functions."
msgstr ""

#. type: Title ##
#: text/chapter10.md:249 text/chapter10.md:324 text/chapter10.md:479
#: text/chapter10.md:717 text/chapter10.md:893 text/chapter2.md:116
#: text/chapter3.md:711 text/chapter5.md:98 text/chapter5.md:227
#: text/chapter5.md:391 text/chapter5.md:463 text/chapter5.md:520
#: text/chapter6.md:319 text/chapter6.md:411 text/chapter6.md:608
#: text/chapter8.md:666 text/chapter8.md:973 text/chapter9.md:124
#, no-wrap
msgid "Exercises"
msgstr "演習"

#. type: Bullet: '1. '
#: text/chapter10.md:253
msgid ""
"(Medium) Write a JavaScript function `volumeFn` in the `Test.MySolutions` "
"module that finds the volume of a box. Use an `Fn` wrapper from `Data."
"Function.Uncurried`."
msgstr ""

#. type: Bullet: '2. '
#: text/chapter10.md:253
msgid "(Medium) Rewrite `volumeFn` with arrow functions as `volumeArrow`."
msgstr ""

#. type: Title ##
#: text/chapter10.md:254
#, fuzzy, no-wrap
msgid "Passing Simple Types"
msgstr "単純な型"

#. type: Plain text
#: text/chapter10.md:257
msgid ""
"The following data types may be passed between PureScript and JavaScript as-"
"is:"
msgstr ""

#. type: Plain text
#: text/chapter10.md:265
msgid ""
"PureScript | JavaScript --- | --- Boolean | Boolean String | String Int, "
"Number | Number Array | Array Record | Object"
msgstr ""

#. type: Plain text
#: text/chapter10.md:267
msgid ""
"We've already seen examples with the primitive types `String` and `Number`. "
"We'll now take a look at the structural types `Array` and `Record` (`Object` "
"in JavaScript)."
msgstr ""

#. type: Plain text
#: text/chapter10.md:269
msgid ""
"To demonstrate passing `Array`s, here's how to call a JavaScript function "
"which takes an `Array` of `Int` and returns the cumulative sum as another "
"array. Recall that, since JavaScript does not have a separate type for "
"`Int`, both `Int` and `Number` in PureScript translate to `Number` in "
"JavaScript."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:270
#, fuzzy, no-wrap
msgid "foreign import cumulativeSums :: Array Int -> Array Int\n"
msgstr ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"

#. type: Fenced code block (js)
#: text/chapter10.md:274
#, no-wrap
msgid ""
"export const cumulativeSums = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  return sums;\n"
"};\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:286
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> cumulativeSums [1, 2, 3]\n"
"[1,3,6]\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:295
msgid ""
"To demonstrate passing `Records`, here's how to call a JavaScript function "
"which takes two `Complex` numbers as records, and returns their sum as "
"another record. Note that a `Record` in PureScript is represented as an "
"`Object` in JavaScript:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:296
#, no-wrap
msgid ""
"type Complex = {\n"
"  real :: Number,\n"
"  imag :: Number\n"
"}\n"
"\n"
"foreign import addComplex :: Complex -> Complex -> Complex\n"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:305
#, no-wrap
msgid ""
"export const addComplex = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    imag: a.imag + b.imag\n"
"  }\n"
"};\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:314
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"{ imag: 6.0, real: 4.0 }\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:323
msgid ""
"Note that the above techniques require trusting that JavaScript will return "
"the expected types, as PureScript is not able to apply type checking to "
"JavaScript code. We will describe this type safety concern in more detail "
"later on in the JSON section, as well as cover techniques to protect against "
"type mismatches."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter10.md:327
msgid ""
"(Medium) Write a JavaScript function `cumulativeSumsComplex` (and "
"corresponding PureScript foreign import) that takes an `Array` of `Complex` "
"numbers and returns the cumulative sum as another array of complex numbers."
msgstr ""

#. type: Title ##
#: text/chapter10.md:328
#, fuzzy, no-wrap
msgid "Beyond Simple Types"
msgstr "単純な型"

#. type: Plain text
#: text/chapter10.md:331
msgid ""
"We have seen examples of how to send and receive types with a native "
"JavaScript representation, such as `String`, `Number`, `Array`, and "
"`Record`, over FFI. Now we'll cover how to use some of the other types "
"available in PureScript, like `Maybe`."
msgstr ""

#. type: Plain text
#: text/chapter10.md:333
#, fuzzy
msgid ""
"Suppose we wanted to recreate the `head` function on arrays by using a "
"foreign declaration. In JavaScript, we might write the function as follows:"
msgstr ""
"外部インポート宣言を使用して、配列についての `head`関数を作成したいとしましょ"
"う。JavaScriptでは次のような関数になるでしょう。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:334
#, fuzzy, no-wrap
msgid ""
"export const head = arr =>\n"
"  arr[0];\n"
msgstr ""
"exports.head = function(arr) {\n"
"  return arr[0];\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:340
#, fuzzy, no-wrap
msgid "How would we type this function? We might try to give it the type `forall a. Array a -> a`, but for empty arrays, this function returns `undefined`. Therefore, the type `forall a. Array a -> a` does not correctly represent this implementation.\n"
msgstr "しかし、この関数には問題があります。型 `forall a. Array a -> a`を与えようとしても、空の配列に対してこの関数は `undefined`を返します。したがって、この特殊な場合を処理するために、ラッパー関数を使用する必要があります。\n"

#. type: Plain text
#: text/chapter10.md:342
msgid "We instead want to return a `Maybe` value to handle this corner case:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:343
#, fuzzy, no-wrap
msgid "foreign import maybeHead :: forall a. Array a -> Maybe a\n"
msgstr "foreign import unsafeHead :: forall a. Array a -> a\n"

#. type: Plain text
#: text/chapter10.md:348
msgid "But how do we return a `Maybe`? It is tempting to write the following:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:349
#, no-wrap
msgid ""
"// Don't do this\n"
"import Data_Maybe from '../Data.Maybe'\n"
"\n"
"export const maybeHead = arr => {\n"
"  if (arr.length) {\n"
"    return Data_Maybe.Just.create(arr[0]);\n"
"  } else {\n"
"    return Data_Maybe.Nothing.value;\n"
"  }\n"
"}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:363
msgid ""
"Importing and using the `Data.Maybe` module directly in the foreign module "
"isn't recommended as it makes our code brittle to changes in the code "
"generator &mdash; `create` and `value` are not public APIs. Additionally, "
"doing this can cause problems when using `purs bundle` for dead code "
"elimination."
msgstr ""

#. type: Plain text
#: text/chapter10.md:365
msgid ""
"The recommended approach is to add extra parameters to our FFI-defined "
"function to accept the functions we need."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:366
#, fuzzy, no-wrap
msgid ""
"export const maybeHeadImpl = just => nothing => arr => {\n"
"  if (arr.length) {\n"
"    return just(arr[0]);\n"
"  } else {\n"
"    return nothing;\n"
"  }\n"
"};\n"
msgstr ""
"exports.unsafeHead = function(arr) {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"

#. type: Fenced code block (hs)
#: text/chapter10.md:376
#, no-wrap
msgid ""
"foreign import maybeHeadImpl :: forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
"\n"
"maybeHead :: forall a. Array a -> Maybe a\n"
"maybeHead arr = maybeHeadImpl Just Nothing arr\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:384
#, fuzzy
msgid "Note that we wrote:"
msgstr "次のように書くことができることにも注意してください。"

#. type: Fenced code block (hs)
#: text/chapter10.md:385
#, fuzzy, no-wrap
msgid "forall a. (forall x. x -> Maybe x) -> (forall x. Maybe x) -> Array a -> Maybe a\n"
msgstr "forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"

#. type: Plain text
#: text/chapter10.md:390
msgid "and not:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:391
#, fuzzy, no-wrap
msgid "forall a. ( a -> Maybe a) -> Maybe a -> Array a -> Maybe a\n"
msgstr "forall a b. (a -> b) -> Array a -> Array b\n"

#. type: Plain text
#: text/chapter10.md:397
msgid ""
"While both forms work, the latter is more vulnerable to unwanted inputs in "
"place of `Just` and `Nothing`.  For example, in the more vulnerable case we "
"could call it as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:398
#, no-wrap
msgid "maybeHeadImpl (\\_ -> Just 1000) (Just 1000) [1,2,3]\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:404
#, no-wrap
msgid ""
"which returns `Just 1000` for any array input.\n"
"This vulnerability is allowed because `(\\_ -> Just 1000)` and `Just 1000` match the signatures of `(a -> Maybe a)` and `Maybe a` respectively when `a` is `Int` (based on input array).\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:407
#, no-wrap
msgid ""
"In the more secure type signature, even when `a` is determined to be `Int` based on the input array, we still need to provide valid functions matching the signatures involving `forall x`.\n"
"The *only* option for `(forall x. Maybe x)` is `Nothing`, since a `Just` value would assume a type for `x` and will no longer be valid for all `x`. The only options for `(forall x. x -> Maybe x)` are `Just` (our desired argument) and `(\\_ -> Nothing)`, which is the only remaining vulnerability.\n"
msgstr ""

#. type: Title ##
#: text/chapter10.md:408
#, fuzzy, no-wrap
msgid "Defining Foreign Types"
msgstr "外部型の定義"

#. type: Plain text
#: text/chapter10.md:411
msgid ""
"Suppose instead of returning a `Maybe a`, we want to actually return "
"`arr[0]`. We want a type that represents a value either of type `a` or the "
"`undefined` value (but not `null`). We'll call this type `Undefined a`."
msgstr ""

#. type: Plain text
#: text/chapter10.md:413
#, fuzzy
msgid ""
"We can define a _foreign type_ using a _foreign type declaration_. The "
"syntax is similar to defining a foreign function:"
msgstr ""
"**外部インポート宣言**とFFIを使うと、**外部型**(foreign type)を定義することが"
"できます。構文は外部関数を定義するのと似ています。\n"

#. type: Fenced code block (haskell)
#: text/chapter10.md:414
#, fuzzy, no-wrap
msgid "foreign import data Undefined :: Type -> Type\n"
msgstr "foreign import data Undefined :: Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:419
#, fuzzy, no-wrap
msgid "The `data` keyword here indicates that we are defining a _type_, not a value. Instead of a type signature, we give the _kind_ of the new type. In this case, we declare the kind of `Undefined` to be `Type -> Type`. In other words, `Undefined` is a type constructor.\n"
msgstr "この予約語 `data`は値ではなく定義している型を表していることに注意してください。型シグネチャの代わりに、新しい型の**種**を与えます。このとき、種 `Undefined`が `Type -> Type`であると宣言しています。つまり `Undefined`は型構築子です。\n"

#. type: Plain text
#: text/chapter10.md:421
#, fuzzy
msgid "We can now simply reuse our original definition for `head`:"
msgstr "これで `head`の定義を簡素化することができます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:422
#, no-wrap
msgid ""
"export const undefinedHead = arr =>\n"
"  arr[0];\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:428
#, fuzzy
msgid "And in the PureScript module:"
msgstr "PureScriptモジュールには以下を追加します。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:429
#, fuzzy, no-wrap
msgid "foreign import undefinedHead :: forall a. Array a -> Undefined a\n"
msgstr "foreign import head :: forall a. Array a -> Undefined a\n"

#. type: Plain text
#: text/chapter10.md:434
msgid ""
"The body of the `undefinedHead` function returns `arr[0]` which may be "
"`undefined`, and the type signature correctly reflects that fact."
msgstr ""

#. type: Plain text
#: text/chapter10.md:436
#, fuzzy
msgid ""
"This function has the correct runtime representation for its type, but is "
"quite useless since we have no way to use a value of type `Undefined a`. "
"Well, not exactly. We can use this type in another FFI!"
msgstr ""
"この関数はその型の適切な実行時表現を持っていますが、型 `Undefined a`の値を使"
"用する方法がありませんので、まったく役に立ちません。しかし、FFIを使用して新し"
"い関数を幾つか書くことによって、それを修正することができます！"

#. type: Plain text
#: text/chapter10.md:438
#, fuzzy
msgid ""
"We can write a function that will tell us whether a value is undefined or "
"not:"
msgstr ""
"次の関数は、値が定義されているかどうかを教えてくれる最も基本的な関数です。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:439
#, fuzzy, no-wrap
msgid "foreign import isUndefined :: forall a. Undefined a -> Boolean\n"
msgstr "foreign import isUndefined :: forall a. Undefined a -> Boolean\n"

#. type: Plain text
#: text/chapter10.md:444
#, fuzzy
msgid "This is defined in our foreign JavaScript module as follows:"
msgstr "JavaScriptモジュールで次のように簡単に定義できます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:445
#, fuzzy, no-wrap
msgid ""
"export const isUndefined = value =>\n"
"  value === undefined;\n"
msgstr ""
"exports.isUndefined = function(value) {\n"
"  return value === undefined;\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:451
#, fuzzy
msgid ""
"We can now use `isUndefined` and `undefinedHead` together from PureScript to "
"define a useful function:"
msgstr ""
"PureScriptから `isUndefined`と `head`を一緒に使用すると、便利な関数を定義する"
"ことができます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:452
#, fuzzy, no-wrap
msgid ""
"isEmpty :: forall a. Array a -> Boolean\n"
"isEmpty = isUndefined <<< undefinedHead\n"
msgstr ""
"isEmpty :: forall a. Array a -> Boolean\n"
"isEmpty = isUndefined <<< head\n"

#. type: Plain text
#: text/chapter10.md:458
#, fuzzy
msgid ""
"Here, the foreign function we defined is very simple, which means we can "
"benefit from the use of PureScript's typechecker as much as possible. This "
"is good practice in general: foreign functions should be kept as small as "
"possible, and application logic moved into PureScript code wherever possible."
msgstr ""
"ここで、定義されたこの外部関数はとても簡単であり、PureScriptの型検査器を使う"
"ことによる利益をなるべく多く得るということを意味します。一般に外部関数は可能"
"な限り小さく保ち、アプリケーションの処理はPureScriptコードへ移動しておくこと"
"をおすすめします。"

#. type: Title ##
#: text/chapter10.md:459 text/chapter8.md:443
#, no-wrap
msgid "Exceptions"
msgstr ""

#. type: Plain text
#: text/chapter10.md:462
#, fuzzy
msgid ""
"Another option is to simply throw an exception in the case of an empty "
"array. Strictly speaking, pure functions should not throw exceptions, but we "
"have the flexibility to do so. We indicate the lack of safety in the "
"function name:"
msgstr ""
"簡単な方法としては、空の配列の場合に例外を投げる方法があります。厳密に言え"
"ば、純粋な関数は例外を投げるべきではありませんが、デモンストレーションの目的"
"ではこれで十分ですし、安全性でないということを関数名で示しておけばいいでしょ"
"う。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:463
#, fuzzy, no-wrap
msgid "foreign import unsafeHead :: forall a. Array a -> a\n"
msgstr "foreign import unsafeHead :: forall a. Array a -> a\n"

#. type: Plain text
#: text/chapter10.md:468
#, fuzzy
msgid ""
"In our foreign JavaScript module, we can define `unsafeHead` as follows:"
msgstr ""
"JavaScriptモジュールでは、 `unsafeHead`を以下のように定義することができます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:469
#, fuzzy, no-wrap
msgid ""
"export const unsafeHead = arr => {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"
msgstr ""
"exports.unsafeHead = function(arr) {\n"
"  if (arr.length) {\n"
"    return arr[0];\n"
"  } else {\n"
"    throw new Error('unsafeHead: empty array');\n"
"  }\n"
"};\n"

#. type: Bullet: '1. '
#: text/chapter10.md:482
msgid ""
"(Medium) Given a record that represents a quadratic polynomial `a*x^2 + b*x "
"+ c = 0`:"
msgstr ""

#. type: Plain text
#: text/chapter10.md:490
#, fuzzy, no-wrap
msgid ""
"    ```hs\n"
"    type Quadratic = {\n"
"      a :: Number,\n"
"      b :: Number,\n"
"      c :: Number\n"
"    }\n"
"    ```\n"
msgstr ""
"    ```haskell\n"
"    newtype Complex = Complex \n"
"        { real :: Number\n"
"        , imaginary :: Number \n"
"        }\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:492
#, no-wrap
msgid "    Write a JavaScript function `quadraticRootsImpl` and a wrapper `quadraticRoots :: Quadratic -> Pair Complex` that uses the quadratic formula to find the roots of this polynomial. Return the two roots as a `Pair` of `Complex` numbers. *Hint:* Use the `quadraticRoots` wrapper to pass a constructor for `Pair` to `quadraticRootsImpl`.\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter10.md:494
msgid ""
"(Medium) Write the function `toMaybe :: forall a. Undefined a -> Maybe a`. "
"This function converts `undefined` to `Nothing` and `a` values to `Just`s."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter10.md:496
msgid "(Difficult) With `toMaybe` in place, we can rewrite `maybeHead` as"
msgstr ""

#. type: Plain text
#: text/chapter10.md:501
#, no-wrap
msgid ""
"    ```hs\n"
"    maybeHead :: forall a. Array a -> Maybe a\n"
"    maybeHead = toMaybe <<< undefinedHead\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:503
#, no-wrap
msgid "    Is this a better approach than our previous implementation? _Note:_ There is no unit test for this exercise.\n"
msgstr ""

#. type: Title ##
#: text/chapter10.md:504
#, no-wrap
msgid "Using Type Class Member Functions"
msgstr ""

#. type: Plain text
#: text/chapter10.md:507
msgid ""
"Just like our earlier guide on passing the `Maybe` constructor over FFI, "
"this is another case of writing PureScript that calls JavaScript, which in "
"turn calls PureScript functions again. Here we will explore how to pass type "
"class member functions over the FFI."
msgstr ""

#. type: Plain text
#: text/chapter10.md:509
msgid ""
"We start with writing a foreign JavaScript function which expects the "
"appropriate instance of `show` to match the type of `x`."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:510
#, no-wrap
msgid ""
"export const boldImpl = show => x =>\n"
"  show(x).toUpperCase() + \"!!!\";\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:516
msgid "Then we write the matching signature:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:517
#, fuzzy, no-wrap
msgid "foreign import boldImpl :: forall a. (a -> String) -> a -> String\n"
msgstr "foreign import head :: forall a. Array a -> Undefined a\n"

#. type: Plain text
#: text/chapter10.md:522
msgid "and a wrapper function that passes the correct instance of `show`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:523
#, fuzzy, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold x = boldImpl show x\n"
msgstr ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"

#. type: Plain text
#: text/chapter10.md:529
msgid "Alternatively in point-free form:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:530
#, fuzzy, no-wrap
msgid ""
"bold :: forall a. Show a => a -> String\n"
"bold = boldImpl show\n"
msgstr ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"

#. type: Plain text
#: text/chapter10.md:536
msgid "We can then call the wrapper:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:537
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> bold (Tuple 1 \"Hat\")\n"
"\"(TUPLE 1 \\\"HAT\\\")!!!\"\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:547
msgid ""
"Here's another example demonstrating passing multiple functions, including a "
"function of multiple arguments (`eq`):"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:548
#, no-wrap
msgid ""
"export const showEqualityImpl = eq => show => a => b => {\n"
"  if (eq(a)(b)) {\n"
"    return \"Equivalent\";\n"
"  } else {\n"
"    return show(a) + \" is not equal to \" + show(b);\n"
"  }\n"
"}\n"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:558
#, no-wrap
msgid ""
"foreign import showEqualityImpl :: forall a. (a -> a -> Boolean) -> (a -> String) -> a -> a -> String\n"
"\n"
"showEquality :: forall a. Eq a => Show a => a -> a -> String\n"
"showEquality = showEqualityImpl eq show\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:565
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Maybe\n"
"> showEquality Nothing (Just 5)\n"
"\"Nothing is not equal to (Just 5)\"\n"
msgstr ""

#. type: Title ##
#: text/chapter10.md:574
#, fuzzy, no-wrap
msgid "Effectful Functions"
msgstr "カリー化された関数"

#. type: Plain text
#: text/chapter10.md:577
msgid ""
"Let's extend our `bold` function to log to the console. Logging is an "
"`Effect`, and `Effect`s are represented in JavaScript as a function of zero "
"arguments, `()` with arrow notation:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:578
#, no-wrap
msgid ""
"export const yellImpl = show => x => () =>\n"
"  console.log(show(x).toUpperCase() + \"!!!\");\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:584
msgid ""
"The new foreign import is the same as before, except that the return type "
"changed from `String` to `Effect Unit`."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:585
#, no-wrap
msgid ""
"foreign import yellImpl :: forall a. (a -> String) -> a -> Effect Unit\n"
"\n"
"yell :: forall a. Show a => a -> Effect Unit\n"
"yell = yellImpl show\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:593
msgid ""
"When testing this in the repl, notice that the string is printed directly to "
"the console (instead of being quoted) and a `unit` value is returned."
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:594
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Tuple\n"
"> yell (Tuple 1 \"Hat\")\n"
"(TUPLE 1 \"HAT\")!!!\n"
"unit\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:605
msgid ""
"There are also `EffectFn` wrappers from `Effect.Uncurried`. These are "
"similar to the `Fn` wrappers from `Data.Function.Uncurried` that we've "
"already seen. These wrappers let you call uncurried effectful functions in "
"PureScript."
msgstr ""

#. type: Plain text
#: text/chapter10.md:607
msgid ""
"You'd generally only use these if you want to call existing JavaScript "
"library APIs directly, rather than wrapping those APIs in curried functions. "
"So it doesn't make much sense to present an example of uncurried `yell`, "
"where the JavaScript relies on PureScript type class members, since you "
"wouldn't find that in the existing JavaScript ecosystem."
msgstr ""

#. type: Plain text
#: text/chapter10.md:609
msgid ""
"Instead, we'll modify our previous `diagonal` example to include logging in "
"addition to returning the result:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:610
#, no-wrap
msgid ""
"export const diagonalLog = function(w, h) {\n"
"  let result = Math.sqrt(w * w + h * h);\n"
"  console.log(\"Diagonal is \" + result);\n"
"  return result;\n"
"};\n"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:618
#, fuzzy, no-wrap
msgid "foreign import diagonalLog :: EffectFn2 Number Number Number\n"
msgstr "foreign import data ALERT :: Effect\n"

#. type: Fenced code block (text)
#: text/chapter10.md:622
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Effect.Uncurried\n"
"> runEffectFn2 diagonalLog 3.0 4.0\n"
"Diagonal is 5\n"
"5.0\n"
msgstr ""

#. type: Title ##
#: text/chapter10.md:632
#, no-wrap
msgid "Asynchronous Functions"
msgstr ""

#. type: Plain text
#: text/chapter10.md:635
msgid ""
"Promises in JavaScript translate directly to asynchronous effects in "
"PureScript with the help of the `aff-promise` library. See that library's "
"[documentation](https://pursuit.purescript.org/packages/purescript-aff-"
"promise) for more information. We'll just go through a few examples."
msgstr ""

#. type: Plain text
#: text/chapter10.md:637
msgid ""
"Suppose we want to use this JavaScript `wait` promise (or asynchronous "
"function) in our PureScript project. It may be used to delay execution for "
"`ms` milliseconds."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:638
#, no-wrap
msgid "const wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:643
msgid ""
"We just need to export it wrapped as an `Effect` (function of zero "
"arguments):"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:644
#, no-wrap
msgid ""
"export const sleepImpl = ms => () =>\n"
"  wait(ms);\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:650
#, fuzzy
msgid "Then import it as follows:"
msgstr "この演算子は次のように使うことができます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:651
#, no-wrap
msgid ""
"foreign import sleepImpl :: Int -> Effect (Promise Unit)\n"
"\n"
"sleep :: Int -> Aff Unit\n"
"sleep = sleepImpl >>> toAffE\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:659
msgid "We can then run this `Promise` in an `Aff` block like so:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:660
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Test.Examples\n"
"> import Effect.Class.Console\n"
"> import Effect.Aff\n"
"> :pa\n"
"â¦ launchAff_ do\n"
"â¦   log \"waiting\"\n"
"â¦   sleep 300\n"
"â¦   log \"done waiting\"\n"
"â¦\n"
"waiting\n"
"unit\n"
"done waiting\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:679
msgid ""
"Note that asynchronous logging in the repl just waits to print until the "
"entire block has finished executing. This code behaves more predictably when "
"run with `spago test` where there is a slight delay *between* prints."
msgstr ""

#. type: Plain text
#: text/chapter10.md:681
msgid ""
"Let's look at another example where we return a value from a promise. This "
"function is written with `async` and `await`, which is just syntactic sugar "
"for promises."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:682
#, no-wrap
msgid ""
"async function diagonalWait(delay, w, h) {\n"
"  await wait(delay);\n"
"  return Math.sqrt(w * w + h * h);\n"
"}\n"
"\n"
"export const diagonalAsyncImpl = delay => w => h => () =>\n"
"  diagonalWait(delay, w, h);\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:693
msgid ""
"Since we're returning a `Number`, we represent this type in the `Promise` "
"and `Aff` wrappers:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:694
#, no-wrap
msgid ""
"foreign import diagonalAsyncImpl :: Int -> Number -> Number -> Effect (Promise Number)\n"
"\n"
"diagonalAsync :: Int -> Number -> Number -> Aff Number\n"
"diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:701
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"import Prelude\n"
"import Test.Examples\n"
"import Effect.Class.Console\n"
"import Effect.Aff\n"
"> :pa\n"
"â¦ launchAff_ do\n"
"â¦   res <- diagonalAsync 300 3.0 4.0\n"
"â¦   logShow res\n"
"â¦\n"
"unit\n"
"5.0\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:719
msgid ""
"Exercises for the above sections are still on the ToDo list. If you have any "
"ideas for good exercises, please make a suggestion."
msgstr ""

#. type: Title ##
#: text/chapter10.md:720
#, no-wrap
msgid "JSON"
msgstr ""

#. type: Plain text
#: text/chapter10.md:723
msgid ""
"There are many reasons to use JSON in an application, for example, it's a "
"common means of communicating with web APIs. This section will discuss other "
"use-cases too, beginning with a technique to improve type safety when "
"passing structural data over the FFI."
msgstr ""

#. type: Plain text
#: text/chapter10.md:725
msgid ""
"Let's revisit our earlier FFI functions `cumulativeSums` and `addComplex` "
"and introduce a bug to each:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:726
#, no-wrap
msgid ""
"export const cumulativeSumsBroken = arr => {\n"
"  let sum = 0\n"
"  let sums = []\n"
"  arr.forEach(x => {\n"
"    sum += x;\n"
"    sums.push(sum);\n"
"  });\n"
"  sums.push(\"Broken\"); // Bug\n"
"  return sums;\n"
"};\n"
"\n"
"export const addComplexBroken = a => b => {\n"
"  return {\n"
"    real: a.real + b.real,\n"
"    broken: a.imag + b.imag // Bug\n"
"  }\n"
"};\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:747
msgid ""
"We can use the original type signatures, and the code will still compile, "
"despite the fact that the return types are incorrect."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:748
#, no-wrap
msgid ""
"foreign import cumulativeSumsBroken :: Array Int -> Array Int\n"
"\n"
"foreign import addComplexBroken :: Complex -> Complex -> Complex\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:755
msgid ""
"We can even execute the code, which might either produce unexpected results "
"or a runtime error:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:756
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Foldable (sum)\n"
"\n"
"> sums = cumulativeSumsBroken [1, 2, 3]\n"
"> sums\n"
"[1,3,6,Broken]\n"
"> sum sums\n"
"0\n"
"\n"
"> complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"> complex.real\n"
"4.0\n"
"> complex.imag + 1.0\n"
"NaN\n"
"> complex.imag\n"
"  var str = n.toString();\n"
"              ^\n"
"TypeError: Cannot read property 'toString' of undefined\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:780
msgid ""
"For example, our resulting `sums` is no-longer a valid `Array Int`, now that "
"a `String` is included in the Array. And further operations produce "
"unexpected behavior, rather than an outright error, as the `sum` of these "
"`sums` is `0` rather than `10`. This could be a difficult bug to track down!"
msgstr ""

#. type: Plain text
#: text/chapter10.md:782
msgid ""
"Likewise, there are no errors when calling `addComplexBroken`; however, "
"accessing the `imag` field of our `Complex` result will either produce "
"unexpected behavior (returning `NaN` instead of `7.0`), or a non-obvious "
"runtime error."
msgstr ""

#. type: Plain text
#: text/chapter10.md:784
msgid ""
"Let's use JSON to make our PureScript code more impervious to bugs in "
"JavaScript code."
msgstr ""

#. type: Plain text
#: text/chapter10.md:786
msgid ""
"The `argonaut` library contains the JSON decoding and encoding capabilities "
"we need. That library has excellent [documentation](https://github.com/"
"purescript-contrib/purescript-argonaut#documentation), so we will only cover "
"basic usage in this book."
msgstr ""

#. type: Plain text
#: text/chapter10.md:788
msgid ""
"If we create an alternate foreign import that defines the return type as "
"`Json`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:789
#, no-wrap
msgid ""
"foreign import cumulativeSumsJson :: Array Int -> Json\n"
"foreign import addComplexJson :: Complex -> Complex -> Json\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:795
msgid "Note that we're simply pointing to our existing broken functions:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:796
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSumsBroken\n"
"export const addComplexJson = addComplexBroken\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:802
msgid "And then write a wrapper to decode the returned foreign `Json` value:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:803
#, no-wrap
msgid ""
"{{#include ../exercises/chapter10/test/Examples.purs:cumulativeSumsDecoded}}\n"
"\n"
"{{#include ../exercises/chapter10/test/Examples.purs:addComplexDecoded}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:810
msgid ""
"Then any values that can't be successfully decoded to our return type appear "
"as a `Left` error `String`:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:811
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Left \"Couldn't decode Array (Failed at index 3): Value is not a Number\")\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Left \"JSON was missing expected field: imag\")\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:824
msgid "If we call the working versions, a `Right` value is returned."
msgstr ""

#. type: Plain text
#: text/chapter10.md:826
msgid ""
"Try this yourself by modifying `test/Examples.js` with the following change "
"to point to the working versions before running the next repl block."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:827
#, no-wrap
msgid ""
"export const cumulativeSumsJson = cumulativeSums\n"
"export const addComplexJson = addComplex\n"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:832
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"\n"
"> cumulativeSumsDecoded [1, 2, 3]\n"
"(Right [1,3,6])\n"
"\n"
"> addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }\n"
"(Right { imag: 6.0, real: 4.0 })\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:845
msgid ""
"Using JSON is also the easiest way to pass other structural types, such as "
"`Map` and `Set` through the FFI. Note that since JSON only consists of "
"booleans, numbers, strings, arrays, and objects of other JSON values, we "
"can't write a `Map` and `Set` directly in JSON. But we can represent these "
"structures as arrays (assuming the keys and values can also be represented "
"in JSON), and then decode them back to `Map` or `Set`."
msgstr ""

#. type: Plain text
#: text/chapter10.md:847
msgid ""
"Here's an example of a foreign function signature that modifies a `Map` of "
"`String` keys and `Int` values, along with the wrapper function that handles "
"JSON encoding and decoding."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:848
#, no-wrap
msgid "{{#include ../exercises/chapter10/test/Examples.purs:mapSetFooJson}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:853
msgid ""
"Note that this is a prime use case for function composition. Both of these "
"alternatives are equivalent to the above:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:854
#, no-wrap
msgid ""
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = decodeJson <<< mapSetFooJson <<< encodeJson\n"
"\n"
"mapSetFoo :: Map String Int -> Either JsonDecodeError (Map String Int)\n"
"mapSetFoo = encodeJson >>> mapSetFooJson >>> decodeJson\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:863
msgid ""
"Here is the JavaScript implementation. Note the `Array.from` step which is "
"necessary to convert the JavaScript `Map` into a JSON-friendly format before "
"decoding converts it back to a PureScript `Map`."
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:864
#, no-wrap
msgid ""
"export const mapSetFooJson = j => {\n"
"  let m = new Map(j);\n"
"  m.set(\"Foo\", 42);\n"
"  return Array.from(m);\n"
"};\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:873
msgid "Now we can send and receive a `Map` over the FFI:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:874
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.Examples\n"
"> import Data.Map\n"
"> import Data.Tuple\n"
"\n"
"> myMap = fromFoldable [ Tuple \"hat\" 1, Tuple \"cat\" 2 ]\n"
"\n"
"> :type myMap\n"
"Map String Int\n"
"\n"
"> myMap\n"
"(fromFoldable [(Tuple \"cat\" 2),(Tuple \"hat\" 1)])\n"
"\n"
"> mapSetFoo myMap\n"
"(Right (fromFoldable [(Tuple \"Foo\" 42),(Tuple \"cat\" 2),(Tuple \"hat\" 1)]))\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter10.md:902
msgid ""
"(Medium) Write a JavaScript function and PureScript wrapper `valuesOfMap :: "
"Map String Int -> Either JsonDecodeError (Set Int)` that returns a `Set` of "
"all the values in a `Map`. _Hint_: The `.values()` instance method for Map "
"may be useful in your JavaScript code."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter10.md:902
msgid ""
"(Easy) Write a new wrapper for the previous JavaScript function with the "
"signature `valuesOfMapGeneric :: forall k v. Map k v -> Either "
"JsonDecodeError (Set v)` so it works with a wider variety of maps. Note that "
"you'll need to add some type class constraints for `k` and `v`. The compiler "
"will guide you."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter10.md:902
msgid ""
"(Medium) Rewrite the earlier `quadraticRoots` function as "
"`quadraticRootsSet` which returns the `Complex` roots as a `Set` via JSON "
"(instead of as a `Pair`)."
msgstr ""

#. type: Plain text
#: text/chapter10.md:902
#, no-wrap
msgid ""
"1. (Difficult) Rewrite the earlier `quadraticRoots` function as `quadraticRootsSafe` which uses JSON to pass the `Pair` of `Complex` roots over FFI. Don't use the `Pair` constructor in JavaScript, but instead, just return the pair in a decoder-compatible format.\n"
"_Hint_: You'll need to write a `DecodeJson` instance for `Pair`. Consult the [argonaut docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances) for instruction on writing your own decode instance. Their [decodeJsonTuple](https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs) instance may also be a helpful reference.  Note that you'll need a `newtype` wrapper for `Pair` to avoid creating an \"orphan instance\".\n"
"1. (Medium) Write a `parseAndDecodeArray2D :: String -> Either String (Array (Array Int))` function to parse and decode a JSON string containing a 2D array, such as `\"[[1, 2, 3], [4, 5], [6]]\"`. _Hint_: You'll need to use `jsonParser` to convert the `String` into `Json` before decoding.\n"
"1. (Medium) The following data type represents a binary tree with values at the leaves:\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:908
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a\n"
"       = Leaf a\n"
"       | Branch (Tree a) (Tree a)\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    data Tree a = Leaf a | Branch (Tree a) (Tree a)\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:913
#, no-wrap
msgid ""
"     Derive generic `EncodeJson` and `DecodeJson` instances for the `Tree` type.\n"
"     Consult the [argonaut docs](https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics) for instructions on how to do this.\n"
"     Note that you'll also need generic instances of `Show` and `Eq` to enable unit testing for this exercise, but those should be straightforward to implement after tackling the JSON instances.\n"
"1. (Difficult) The following `data` type should be represented directly in JSON as either an integer or a string:\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:919
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     data IntOrString\n"
"       = IntOrString_Int Int\n"
"       | IntOrString_String String\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    data IntOrString\n"
"      = IntOrString_Int Int\n"
"      | IntOrString_String String\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:921
#, fuzzy, no-wrap
msgid "     Write instances of `EncodeJson` and `DecodeJson` for the `IntOrString` data type which implement this behavior. _Hint_: The `alt` operator from `Control.Alt` may be helpful.\n"
msgstr "    この動作を実装する `IntOrString`データ型の `Encode`と `Decode`のインスタンスを記述し、エンコードされた値が `PSCi`で正しくデコードできることを確認してください。\n"

#. type: Title ##
#: text/chapter10.md:922
#, fuzzy, no-wrap
msgid "Address book"
msgstr "住所録の作成"

#. type: Plain text
#: text/chapter10.md:925
msgid ""
"In this section we will apply our newly-acquired FFI and JSON knowledge to "
"build on our address book example from chapter 8. We will add the following "
"features:"
msgstr ""

#. type: Plain text
#: text/chapter10.md:929
msgid ""
"- A Save button at the bottom of the form that, when clicked, serializes the "
"state of the form to JSON and saves it in local storage.  - Automatic "
"retrieval of the JSON document from local storage upon page reload. The form "
"fields are populated with the contents of this document.  - A pop-up alert "
"if there is an issue saving or loading the form state."
msgstr ""

#. type: Plain text
#: text/chapter10.md:931
msgid ""
"We'll start by creating FFI wrappers for the following Web Storage APIs in "
"our `Effect.Storage` module:"
msgstr ""

#. type: Plain text
#: text/chapter10.md:934
#, fuzzy
msgid ""
"- `setItem` takes a key and a value (both strings), and returns a "
"computation which stores (or updates) the value in local storage at the "
"specified key.  - `getItem` takes a key, and attempts to retrieve the "
"associated value from local storage. However, since the `getItem` method on "
"`window.localStorage` can return `null`, the return type is not `String`, "
"but `Json`."
msgstr ""
"`getItem`の型はもっと興味深いものです。 `getItem`はキーを引数に取り、キーに関"
"連付けられた値をローカルストレージから取得しようとします。 `window."
"localStorage`の `getItem`メソッドは `null`を返すことがあるので、返り値は "
"`String`ではなく、 `purescript-foreign`パッケージの `Data.Foreign`モジュール"
"で定義されている `Foreign`になっています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:935
#, no-wrap
msgid ""
"foreign import setItem :: String -> String -> Effect Unit\n"
"\n"
"foreign import getItem :: String -> Effect Json\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:942
msgid ""
"Here is the corresponding JavaScript implementation of these functions in "
"`Effect/Storage.js`:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter10.md:943
#, no-wrap
msgid ""
"export const setItem = key => value => () =>\n"
"  window.localStorage.setItem(key, value);\n"
"\n"
"export const getItem = key => () =>\n"
"  window.localStorage.getItem(key);\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:952
msgid "We'll create a save button like so:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:953
#, no-wrap
msgid ""
"saveButton :: R.JSX\n"
"saveButton =\n"
"  D.label\n"
"    { className: \"form-group row col-form-label\"\n"
"    , children:\n"
"        [ D.button\n"
"            { className: \"btn-primary btn\"\n"
"            , onClick: handler_ validateAndSave\n"
"            , children: [ D.text \"Save\" ]\n"
"            }\n"
"        ]\n"
"    }\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:969
msgid ""
"And write our validated `person` as a JSON string with `setItem` in the "
"`validateAndSave` function:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:970
#, no-wrap
msgid ""
"validateAndSave :: Effect Unit\n"
"validateAndSave = do\n"
"  log \"Running validators\"\n"
"  case validatePerson' person of\n"
"    Left errs -> log $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"    Right validPerson -> do\n"
"      setItem \"person\" $ stringify $ encodeJson validPerson\n"
"      log \"Saved\"\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:982
msgid ""
"Note that if we attempt to compile at this stage, we'll encounter the "
"following error:"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter10.md:983
#, no-wrap
msgid ""
"  No type class instance was found for\n"
"    Data.Argonaut.Encode.Class.EncodeJson PhoneType\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:989
msgid ""
"This is because `PhoneType` in the `Person` record needs an `EncodeJson` "
"instance. We'll just derive a generic encode instance, and a decode instance "
"too while we're at it. More information how this works is available in the "
"argonaut docs:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:990
#, no-wrap
msgid ""
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:import}}\n"
"\n"
"{{#include ../exercises/chapter10/src/Data/AddressBook.purs:PhoneType_generic}}\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:997
msgid ""
"Now we can save our `person` to local storage, but this isn't very useful "
"unless we can retrieve the data. We'll tackle that next."
msgstr ""

#. type: Plain text
#: text/chapter10.md:999
msgid "We'll start with retrieving the \"person\" string from local storage:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:1000
#, no-wrap
msgid "item <- getItem \"person\"\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1005
msgid ""
"Then we'll create a helper function to handle converting the string from "
"local storage to our `Person` record. Note that this string in storage may "
"be `null`, so we represent it as a foreign `Json` until it is successfully "
"decoded as a `String`. There are a number of other conversion steps along "
"the way - each of which return an `Either` value, so it makes sense to "
"organize these together in a `do` block."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:1006
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- decodeJson item\n"
"  j          <- jsonParser jsonString\n"
"  decodeJson j\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1015
msgid ""
"Then we inspect this result to see if it succeeded. If it failed, we'll log "
"the errors and use our default `examplePerson`, otherwise we'll use the "
"person retrieved from local storage."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:1016
#, no-wrap
msgid ""
"initialPerson <- case processItem item of\n"
"  Left  err -> do\n"
"    log $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
"    pure examplePerson\n"
"  Right p   -> pure p\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1025
msgid ""
"Finally, we'll pass this `initialPerson` to our component via the `props` "
"record:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:1026
#, no-wrap
msgid ""
"-- Create JSX node from react component.\n"
"app = element addressBookApp { initialPerson }\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1032
msgid "And pick it up on the other side to use in our state hook:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:1033
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })\n"
"mkAddressBookApp =\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState props.initialPerson\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1041
msgid ""
"As a finishing touch, we'll improve the quality of our error messages by "
"appending to the `String` of each `Left` value with `lmap`."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:1042
#, no-wrap
msgid ""
"processItem :: Json -> Either String Person\n"
"processItem item = do\n"
"  jsonString <- lmap (\"No string in local storage: \" <> _) $ decodeJson item\n"
"  j          <- lmap (\"Cannot parse JSON string: \"   <> _) $ jsonParser jsonString\n"
"  lmap               (\"Cannot decode Person: \"       <> _) $ decodeJson j\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1051
msgid ""
"Only the first error should ever occur during normal operation of this app. "
"You can trigger the other errors by opening your web browser's dev tools, "
"editing the saved \"person\" string in local storage, and refreshing the "
"page. How you modify the JSON string determines which error is triggered. "
"See if you can trigger each of them."
msgstr ""

#. type: Plain text
#: text/chapter10.md:1053
#, fuzzy
msgid ""
"That covers local storage. Next we'll implement the `alert` action, which is "
"very similar to the `log` action from the `Effect.Console` module. The only "
"difference is that the `alert` action uses the `window.alert` method, "
"whereas the `log` action uses the `console.log` method. As such, `alert` can "
"only be used in environments where `window.alert` is defined, such as a web "
"browser."
msgstr ""
"このアクションは `Control.Monad.Eff.Console`モジュールの `log`アクションとと"
"てもよく似ています。唯一の違いは、 `log`アクションが `console.log`メソッドを"
"使用しているのに対し、 `alert`アクションは `window.alert`メソッドを使用してい"
"ることです。このように、 `alert`は `window.alert`が定義されているウェブブラウ"
"ザのような環境で使用することができます。"

#. type: Fenced code block (hs)
#: text/chapter10.md:1054
#, fuzzy, no-wrap
msgid "foreign import alert :: String -> Effect Unit\n"
msgstr "foreign import alert :: forall eff. String -> Eff (alert :: ALERT | eff) Unit\n"

#. type: Fenced code block (js)
#: text/chapter10.md:1058
#, no-wrap
msgid ""
"export const alert = msg => () =>\n"
"  window.alert(msg);\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1064
msgid "We want this alert to appear when either:"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1067
msgid ""
"- A user attempts to save a form with validation errors.  - The state cannot "
"be retrieved from local storage."
msgstr ""

#. type: Plain text
#: text/chapter10.md:1069
msgid ""
"That is accomplished by simply replacing `log` with `alert` on these lines:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter10.md:1070
#, no-wrap
msgid ""
"Left errs -> alert $ \"There are \" <> show (length errs) <> \" validation errors.\"\n"
"\n"
"alert $ \"Error: \" <> err <> \". Loading examplePerson\"\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1077 text/chapter10.md:1317 text/chapter11.md:140
#: text/chapter11.md:224 text/chapter11.md:343 text/chapter11.md:549
#: text/chapter11.md:716 text/chapter11.md:915 text/chapter11.md:959
#: text/chapter12.md:154 text/chapter12.md:362 text/chapter12.md:556
#: text/chapter13.md:91 text/chapter13.md:138 text/chapter13.md:245
#: text/chapter13.md:388 text/chapter14.md:250 text/chapter14.md:353
#: text/chapter14.md:570 text/chapter14.md:705 text/chapter4.md:71
#: text/chapter4.md:182 text/chapter4.md:364 text/chapter4.md:522
#: text/chapter4.md:616 text/chapter6.md:131 text/chapter6.md:743
#: text/chapter7.md:382 text/chapter7.md:541 text/chapter7.md:643
#: text/chapter8.md:309 text/chapter9.md:80 text/chapter9.md:192
#, no-wrap
msgid " ## Exercises\n"
msgstr "## 演習\n"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
#, fuzzy
msgid ""
"(Easy) Write a wrapper for the `removeItem` method on the `localStorage` "
"object, and add your foreign function to the `Effect.Storage` module."
msgstr ""
"(やや難しい)`localStorage`オブジェクトの `removeItem`メソッドのラッパを書"
"き、 `Control.Monad.Eff.Storage`モジュールに追加してください"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
msgid ""
"(Medium) Add a \"Reset\" button that, when clicked, calls the newly-created "
"`removeItem` function to delete the \"person\" entry from local storage."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
#, fuzzy
msgid ""
"(Easy) Write a wrapper for the `confirm` method on the JavaScript `Window` "
"object, and add your foreign function to the `Effect.Alert` module."
msgstr ""
"(やや難しい) JavaScriptの `Window`オブジェクトの `confirm`メソッドのラッパを"
"書き、 `Control.Monad.Eff.Alert`モジュールにその関数を追加してください。"

#. type: Bullet: ' 1. '
#: text/chapter10.md:1082
msgid ""
"(Medium) Call this `confirm` function when a users clicks the \"Reset\" "
"button to ask if they're sure they want to reset their address book."
msgstr ""

#. type: Title ##
#: text/chapter10.md:1083 text/chapter11.md:962 text/chapter12.md:594
#: text/chapter13.md:401 text/chapter14.md:722 text/chapter2.md:121
#: text/chapter3.md:719 text/chapter4.md:631 text/chapter5.md:525
#: text/chapter6.md:757 text/chapter7.md:691 text/chapter8.md:1000
#: text/chapter9.md:225
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: text/chapter10.md:1086
#, fuzzy
msgid ""
"In this chapter, we've learned how to work with foreign JavaScript code from "
"PureScript and we've seen the issues involved with writing trustworthy code "
"using the FFI:"
msgstr ""
"この章では、PureScriptから外部のJavaScriptコードを扱う方法、およびその逆の方"
"法を学びました。また、FFIを使用して信頼できるコードを書く時に生じる問題につい"
"て見てきました。"

#. type: Plain text
#: text/chapter10.md:1090
#, fuzzy
msgid ""
"- We've seen the importance of ensuring that foreign functions have correct "
"representations.  - We learned how to deal with corner cases like null "
"values and other types of JavaScript data, by using foreign types, or the "
"`Json` data type.  - We saw how to safely serialize and deserialize JSON "
"data."
msgstr ""
"- データの**実行時表現**の重要性を見て、外部関数が正しい表現を持っていること"
"を確かめました。 - 外部型、つまり `Foreign`データ型を使用することによって、"
"null値のような特殊な場合やJavaScriptの他の型のデータに対処する方法を学びまし"
"た。 - Preludeで定義されたいくつかの共通の外部型、既存のJavaScriptコードとど"
"のように相互運用に使用するかを見てきました。特に、 `Eff`モナドにおける副作用"
"の表現を導入し、新たな副作用を追跡するために `Eff`モナドを使用する方法を説明"
"しました。 - `IsForeign`型クラスを使用して安全にJSONデータを復元する方法を説"
"明しました。"

#. type: Plain text
#: text/chapter10.md:1092
#, fuzzy
msgid ""
"For more examples, the `purescript`, `purescript-contrib` and `purescript-"
"node` GitHub organizations provide plenty of examples of libraries which use "
"the FFI. In the remaining chapters, we will see some of these libraries put "
"to use to solve real-world problems in a type-safe way."
msgstr ""
"その他の例については、Githubの `purescript`組織、`purescript-contrib`組織およ"
"び `purescript-node`組織が、FFIを使用するライブラリの例を多数提供しています。"
"残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾"
"つか見ていきます。"

#. type: Title #
#: text/chapter10.md:1093
#, no-wrap
msgid "Addendum"
msgstr ""

#. type: Title ##
#: text/chapter10.md:1095
#, fuzzy, no-wrap
msgid "Calling PureScript from JavaScript"
msgstr "JavaScriptからPureScriptを呼び出す"

#. type: Plain text
#: text/chapter10.md:1098
#, fuzzy
msgid ""
"Calling a PureScript function from JavaScript is very simple, at least for "
"functions with simple types."
msgstr ""
"少なくとも単純な型を持った関数については、JavaScriptからPureScript関数を呼び"
"出すのはとても簡単です。"

#. type: Plain text
#: text/chapter10.md:1100
#, fuzzy
msgid "Let's take the following simple module as an example:"
msgstr "例として以下のような簡単なモジュールを見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1101
#, fuzzy, no-wrap
msgid ""
"module Test where\n"
"\n"
"gcd :: Int -> Int -> Int\n"
"gcd 0 m = m\n"
"gcd n 0 = n\n"
"gcd n m\n"
"  | n > m     = gcd (n - m) m\n"
"  | otherwise = gcd (m - n) n\n"
msgstr ""
"module Test where\n"
"\n"
"gcd :: Int -> Int -> Int\n"
"gcd 0 m = m\n"
"gcd n 0 = n\n"
"gcd n m\n"
"  | n > m     = gcd (n - m) m\n"
"  | otherwise = gcd (m - n) n\n"

#. type: Plain text
#: text/chapter10.md:1113
#, fuzzy
msgid ""
"This function finds the greatest common divisor of two numbers by repeated "
"subtraction. It is a nice example of a case where you might like to use "
"PureScript to define the function, but have a requirement to call it from "
"JavaScript: it is simple to define this function in PureScript using pattern "
"matching and recursion, and the implementor can benefit from the use of the "
"type checker."
msgstr ""
"この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。関数を"
"定義するのにPureScriptを使いたくなるかもしれない良い例となっていますが、"
"JavaScriptからそれを呼び出すためには条件があります。 PureScriptでパターン照合"
"と再帰を使用してこの関数を定義するのは簡単で、実装する開発者は型検証器の恩恵"
"を受けることができます。"

#. type: Plain text
#: text/chapter10.md:1115
#, fuzzy
msgid ""
"To understand how this function can be called from JavaScript, it is "
"important to realize that PureScript functions always get turned into "
"JavaScript functions of a single argument, so we need to apply its arguments "
"one-by-one:"
msgstr ""
"この関数をJavaScriptから呼び出す方法を理解するには、PureScriptの関数は常に引"
"数がひとつのJavaScript関数へと変換され、引数へは次のようにひとつづつ適用して"
"いかなければならないことを理解するのが重要です。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1116
#, fuzzy, no-wrap
msgid ""
"import Test from 'Test.js';\n"
"Test.gcd(15)(20);\n"
msgstr ""
"var Test = PS.Test;\n"
"Test.gcd(15)(20);\n"

#. type: Plain text
#: text/chapter10.md:1122
#, fuzzy
msgid ""
"Here, I am assuming that the code was compiled with `spago build`, which "
"compiles PureScript modules to ES modules. For that reason, I was able to "
"reference the `gcd` function on the `Test` object, after importing the "
"`Test` module using `import`."
msgstr ""
"ここでは、コードがPureScriptモジュールをCommonJSモジュールにコンパイルする "
"`pulp build`でコンパイルされていると仮定しています。 そのため、 `require`を"
"使って `Test`モジュールをインポートした後、 `Test`オブジェクトの `gcd`関数を"
"参照することができました。"

#. type: Plain text
#: text/chapter10.md:1124
#, fuzzy
msgid ""
"You might also like to bundle JavaScript code for the browser, using `spago "
"bundle-app --to file.js`. In that case, you would access the `Test` module "
"from the global PureScript namespace, which defaults to `PS`:"
msgstr ""
"`pulp build -O --to file.js`を使用して、ブラウザ用のJavaScriptコードをバンド"
"ルすることもできます。 その場合、グローバルなPureScript名前空間から `Test`モ"
"ジュールにアクセスします。デフォルトは `PS`です。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1125
#, fuzzy, no-wrap
msgid ""
"var Test = PS.Test;\n"
"Test.gcd(15)(20);\n"
msgstr ""
"var Test = PS.Test;\n"
"Test.gcd(15)(20);\n"

#. type: Title ##
#: text/chapter10.md:1130
#, fuzzy, no-wrap
msgid "Understanding Name Generation"
msgstr "名前の生成を理解する"

#. type: Plain text
#: text/chapter10.md:1133
#, fuzzy
msgid ""
"PureScript aims to preserve names during code generation as much as "
"possible. In particular, most identifiers which are neither PureScript nor "
"JavaScript keywords can be expected to be preserved, at least for names of "
"top-level declarations."
msgstr ""
"PureScriptはコード生成時にできるだけ名前を保存することを目的としています。具"
"体的には、トップレベルでの宣言では、JavaScriptのキーワードでなければ任意の識"
"別子が保存されます。"

#. type: Plain text
#: text/chapter10.md:1135
#, fuzzy
msgid ""
"If you decide to use a JavaScript keyword as an identifier, the name will be "
"escaped with a double dollar symbol. For example,"
msgstr ""
"識別子としてJavaScriptの予約語を使う場合は、名前はダブルダラー記号でエスケー"
"プされます。たとえば、次のPureScriptコードを考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1136
#, fuzzy, no-wrap
msgid "null = []\n"
msgstr "null = []\n"

#. type: Plain text
#: text/chapter10.md:1141 text/chapter10.md:1153
#, fuzzy
msgid "generates the following JavaScript:"
msgstr ""
"#-#-#-#-#  refs/ja2/src/chapter10.md:83  #-#-#-#-#\n"
"これは以下のようなJavaScriptへコンパイルされます。\n"
"#-#-#-#-#  refs/ja2/src/chapter10.md:95  #-#-#-#-#\n"
"これは以下のJavaScriptにコンパイルされます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1142
#, fuzzy, no-wrap
msgid "var $$null = [];\n"
msgstr "var $$null = [];\n"

#. type: Plain text
#: text/chapter10.md:1147
#, fuzzy
msgid ""
"In addition, if you would like to use special characters in your identifier "
"names, they will be escaped using a single dollar symbol. For example,"
msgstr ""
"また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープ"
"されます。たとえば、このPureScriptコードを考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1148
#, fuzzy, no-wrap
msgid "example' = 100\n"
msgstr "example' = 100\n"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1154
#, fuzzy, no-wrap
msgid "var example$prime = 100;\n"
msgstr "var example$prime = 100;\n"

#. type: Plain text
#: text/chapter10.md:1159
#, fuzzy
msgid ""
"Where compiled PureScript code is intended to be called from JavaScript, it "
"is recommended that identifiers only use alphanumeric characters, and avoid "
"JavaScript keywords. If user-defined operators are provided for use in "
"PureScript code, it is good practice to provide an alternative function with "
"an alphanumeric name for use in JavaScript."
msgstr ""
"コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図してい"
"る場合、識別子は英数字のみを使用し、JavaScriptの予約語を避けることをお勧めし"
"ます。 ユーザ定義演算子がPureScriptコードでの使用のために提供される場合でも、"
"JavaScriptから使うための英数字の名前を持った代替関数を提供しておくことをお勧"
"めします。"

#. type: Title ##
#: text/chapter10.md:1160
#, fuzzy, no-wrap
msgid "Runtime Data Representation"
msgstr "実行時のデータ表現"

#. type: Plain text
#: text/chapter10.md:1163
#, fuzzy
msgid ""
"Types allow us to reason at compile-time that our programs are \"correct\" "
"in some sense - that is, they will not break at runtime. But what does that "
"mean? In PureScript, it means that the type of an expression should be "
"compatible with its representation at runtime."
msgstr ""
"型はプログラムがある意味で「正しい」ことをコンパイル時に判断できるようにしま"
"す。つまり、実行時には中断されません。しかし、これは何を意味するのでしょう"
"か？PureScriptでは式の型は実行時の表現と互換性がなければならないことを意味し"
"ます。"

#. type: Plain text
#: text/chapter10.md:1165
#, fuzzy
msgid ""
"For that reason, it is important to understand the representation of data at "
"runtime to be able to use PureScript and JavaScript code together "
"effectively. This means that for any given PureScript expression, we should "
"be able to understand the behavior of the value it will evaluate to at "
"runtime."
msgstr ""
"そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行"
"時のデータ表現について理解することが重要です。これは、与えられた任意の"
"PureScriptの式について、その値が実行時にどのように評価されるかという挙動を理"
"解できるべきであることを意味しています。"

#. type: Plain text
#: text/chapter10.md:1167
#, fuzzy
msgid ""
"The good news is that PureScript expressions have particularly simple "
"representations at runtime. It should always be possible to understand the "
"runtime data representation of an expression by considering its type."
msgstr ""
"PureScriptの式は、実行時に特に単純な表現を持っているということは朗報です。実"
"際に標準ライブラリのコードについて、その型を考慮すれば式の実行時のデータ表現"
"を把握することが可能です。"

#. type: Plain text
#: text/chapter10.md:1169
#, fuzzy
msgid ""
"For simple types, the correspondence is almost trivial. For example, if an "
"expression has the type `Boolean`, then its value `v` at runtime should "
"satisfy `typeof v === 'boolean'`. That is, expressions of type `Boolean` "
"evaluate to one of the (JavaScript) values `true` or `false`. In particular, "
"there is no PureScript expression of type `Boolean` which evaluates to "
"`null` or `undefined`."
msgstr ""
"単純な型については、対応関係はほとんど自明です。たとえば、式が型 `Boolean`を"
"持っていれば、実行時のその値 `v`は `typeof v === 'boolean'`を満たします。つま"
"り、型 `Boolean`の式は `true`もしくは `false`のどちらか一方の(JavaScriptの)値"
"へと評価されます。実のところ、 `null`や `undefined`に評価される、型 `Boolean`"
"のPureScriptの式はありません。"

#. type: Plain text
#: text/chapter10.md:1171
#, fuzzy
msgid ""
"A similar law holds for expressions of type `Int` `Number` and `String` - "
"expressions of type `Int` or `Number` evaluate to non-null JavaScript "
"numbers, and expressions of type `String` evaluate to non-null JavaScript "
"strings. Expressions of type `Int` will evaluate to integers at runtime, "
"even though they cannot not be distinguished from values of type `Number` by "
"using `typeof`."
msgstr ""
"`Number`と `String`の型の式についても同様のことが成り立ちます。 `Number`型の"
"式は `null`でないJavaScriptの数へと評価されますし、 `String`型の式は `null`で"
"ないJavaScriptの文字列へと評価されます。"

#. type: Plain text
#: text/chapter10.md:1173
msgid ""
"What about `Unit`? Well, since `Unit` has only one inhabitant (`unit`) and "
"its value is not observable, it doesn't actually matter what it's "
"represented with at runtime. Old code tends to represent it using `{}`. "
"Newer code, however, tends to use `undefined`. So, although it doesn't "
"really matter what you use to represent `Unit`, it is recommended to use "
"`undefined` (not returning anything from a function also returns "
"`undefined`)."
msgstr ""

#. type: Plain text
#: text/chapter10.md:1175
#, fuzzy
msgid "What about some more complex types?"
msgstr "もっと複雑な型についてはどうでしょうか？"

#. type: Plain text
#: text/chapter10.md:1177
#, fuzzy, no-wrap
msgid "As we have already seen, PureScript functions correspond to JavaScript functions of a single argument. More precisely, if an expression `f` has type `a -> b` for some types `a` and `b`, and an expression `x` evaluates to a value with the correct runtime representation for type `a`, then `f` evaluates to a JavaScript function, which when applied to the result of evaluating `x`, has the correct runtime representation for type `b`. As a simple example, an expression of type `String -> String` evaluates to a function which takes non-null JavaScript strings to non-null JavaScript strings.\n"
msgstr "すでに見てきたように、PureScriptの関数は引数がひとつのJavaScriptの関数に対応しています。厳密に言えば、任意の型 `a`、 `b`について、式 `f`の型が `a -> b`で、式 `x`が型 `a`についての適切な実行時表現の値へと評価されるなら、 `f`はJavaScriptの関数へと評価され、 `x`を評価した結果に `f`を適用すると、それは型 `b`の適切な実行時表現を持ちます。簡単な例としては、 `String -> String`型の式は、 `null`でないJavaScript文字列から `null`でないJavaScript文字列への関数へと評価されます。\n"

#. type: Plain text
#: text/chapter10.md:1179
#, fuzzy
msgid ""
"As you might expect, PureScript's arrays correspond to JavaScript arrays. "
"But remember - PureScript arrays are homogeneous, so every element has the "
"same type. Concretely, if a PureScript expression `e` has type `Array a` for "
"some type `a`, then `e` evaluates to a (non-null) JavaScript array, all of "
"whose elements have the correct runtime representation for type `a`."
msgstr ""
"ご想像のとおり、PureScriptの配列はJavaScriptの配列に対応しています。しかし、"
"PureScriptの配列は均質であり、つまりすべての要素が同じ型を持っていることは覚"
"えておいてください。具体的には、もしPureScriptの式 `e`が任意の型 `a`について"
"型 `Array a`を持っているなら、 `e`はすべての要素が型 `a`の適切な実行時表現を"
"持った(`null`でない)JavaScript配列へと評価されます。"

#. type: Plain text
#: text/chapter10.md:1181
#, fuzzy
msgid ""
"We've already seen that PureScript's records evaluate to JavaScript objects. "
"Just as for functions and arrays, we can reason about the runtime "
"representation of data in a record's fields by considering the types "
"associated with its labels. Of course, the fields of a record are not "
"required to be of the same type."
msgstr ""
"PureScriptのレコードがJavaScriptのオブジェクトへと評価されることはすでに見て"
"きました。ちょうど関数と配列の場合のように、そのラベルに関連付けられている型"
"を考慮すれば、レコードのフィールドのデータの実行時の表現についても推論するこ"
"とができます。もちろん、レコードのそれぞれのフィールドは、同じ型である必要は"
"ありません。"

#. type: Title ##
#: text/chapter10.md:1182
#, fuzzy, no-wrap
msgid "Representing ADTs"
msgstr "代数的データ型の実行時表現"

#. type: Plain text
#: text/chapter10.md:1185
#, fuzzy
msgid ""
"For every constructor of an algebraic data type, the PureScript compiler "
"creates a new JavaScript object type by defining a function. Its "
"constructors correspond to functions which create new JavaScript objects "
"based on those prototypes."
msgstr ""
"PureScriptコンパイラは、代数的データ型のすべての構築子についてそれぞれ関数を"
"定義し、新たなJavaScriptオブジェクト型を作成します。これらの構築子はこれらの"
"プロトタイプに基づいて新しいJavaScriptオブジェクトを作成する関数に対応してい"
"ます。"

#. type: Plain text
#: text/chapter10.md:1187
#, fuzzy
msgid "For example, consider the following simple ADT:"
msgstr "たとえば、次のような単純な代数的データ型を考えてみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1188
#, fuzzy, no-wrap
msgid "data ZeroOrOne a = Zero | One a\n"
msgstr "data ZeroOrOne a = Zero | One a\n"

#. type: Plain text
#: text/chapter10.md:1193
#, fuzzy
msgid "The PureScript compiler generates the following code:"
msgstr "PureScriptコンパイラは、次のようなコードを生成します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1194
#, fuzzy, no-wrap
msgid ""
"function One(value0) {\n"
"    this.value0 = value0;\n"
"};\n"
"\n"
"One.create = function (value0) {\n"
"    return new One(value0);\n"
"};\n"
"\n"
"function Zero() {\n"
"};\n"
"\n"
"Zero.value = new Zero();\n"
msgstr ""
"function One(value0) {\n"
"    this.value0 = value0;\n"
"};\n"
"\n"
"One.create = function (value0) {\n"
"    return new One(value0);\n"
"};\n"
"\n"
"function Zero() {\n"
"};\n"
"\n"
"Zero.value = new Zero();\n"

#. type: Plain text
#: text/chapter10.md:1210
#, fuzzy
msgid ""
"Here, we see two JavaScript object types: `Zero` and `One`. It is possible "
"to create values of each type by using JavaScript's `new` keyword. For "
"constructors with arguments, the compiler stores the associated data in "
"fields called `value0`, `value1`, etc."
msgstr ""
"ここで2つのJavaScriptオブジェクト型 `Zero`と `One`を見てください。JavaScript"
"の予約語 `new`を使用すると、それぞれの型の値を作成することができます。引数を"
"持つ構築子については、コンパイラは `value0`、 `value1`などと呼ばれるフィール"
"ドに対応するデータを格納します。"

#. type: Plain text
#: text/chapter10.md:1212
#, fuzzy
msgid ""
"The PureScript compiler also generates helper functions. For constructors "
"with no arguments, the compiler generates a `value` property, which can be "
"reused instead of using the `new` operator repeatedly. For constructors with "
"one or more arguments, the compiler generates a `create` function, which "
"takes arguments with the appropriate representation and applies the "
"appropriate constructor."
msgstr ""
"PureScriptコンパイラは補助関数も生成します。引数のない構築子については、コン"
"パイラは構築子が使われるたびに `new`演算子を使うのではなく、データを再利用で"
"きるように `value`プロパティを生成します。ひとつ以上の引数を持つ構築子では、"
"適切な表現を持つ引数を取り適切な構築子を適用する `create`関数をコンパイラは生"
"成します。"

#. type: Plain text
#: text/chapter10.md:1214
#, fuzzy
msgid ""
"What about constructors with more than one argument? In that case, the "
"PureScript compiler also creates a new object type, and a helper function. "
"This time, however, the helper function is curried function of two "
"arguments. For example, this algebraic data type:"
msgstr ""
"２引数以上の構築子についてはどうでしょうか？その場合でも、PureScriptコンパイ"
"ラは新しいオブジェクト型と補助関数を作成します。しかし今回は、補助関数は2引数"
"のカリー化された関数です。たとえば、次のような代数的データ型を考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1215
#, fuzzy, no-wrap
msgid "data Two a b = Two a b\n"
msgstr "data Two a b = Two a b\n"

#. type: Plain text
#: text/chapter10.md:1220
#, fuzzy
msgid "generates this JavaScript code:"
msgstr "このコードからは、次のようなJavaScriptコードを生成されます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1221
#, fuzzy, no-wrap
msgid ""
"function Two(value0, value1) {\n"
"    this.value0 = value0;\n"
"    this.value1 = value1;\n"
"};\n"
"\n"
"Two.create = function (value0) {\n"
"    return function (value1) {\n"
"        return new Two(value0, value1);\n"
"    };\n"
"};\n"
msgstr ""
"function Two(value0, value1) {\n"
"    this.value0 = value0;\n"
"    this.value1 = value1;\n"
"};\n"
"\n"
"Two.create = function (value0) {\n"
"    return function (value1) {\n"
"        return new Two(value0, value1);\n"
"    };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1235
#, fuzzy
msgid ""
"Here, values of the object type `Two` can be created using the `new` "
"keyword, or by using the `Two.create` function."
msgstr ""
"ここで、オブジェクト型 `Two`の値は予約語 `new`または `Two.create`関数を使用す"
"ると作成することができます。"

#. type: Plain text
#: text/chapter10.md:1237
#, fuzzy
msgid ""
"The case of newtypes is slightly different. Recall that a newtype is like an "
"algebraic data type, restricted to having a single constructor taking a "
"single argument. In this case, the runtime representation of the newtype is "
"actually the same as the type of its argument."
msgstr ""
"newtypeの場合はまた少し異なります。newtypeは単一の引数を取る単一の構築子を持"
"つよう制限された代数的データ型であることを思い出してください。この場合には、"
"実際はnewtypeの実行時表現は、その引数の型と同じになります。"

#. type: Plain text
#: text/chapter10.md:1239
#, fuzzy
msgid "For example, this newtype representing telephone numbers:"
msgstr "例えば、電話番号を表す次のようなnewtypeを考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1240
#, fuzzy, no-wrap
msgid "newtype PhoneNumber = PhoneNumber String\n"
msgstr "newtype PhoneNumber = PhoneNumber String\n"

#. type: Plain text
#: text/chapter10.md:1245
#, fuzzy
msgid ""
"is actually represented as a JavaScript string at runtime. This is useful "
"for designing libraries, since newtypes provide an additional layer of type "
"safety, but without the runtime overhead of another function call."
msgstr ""
"これは実行時にはJavaScriptの文字列として表されます。newtypeは型安全性の追加の"
"層を提供しますが、実行時の関数呼び出しのオーバーヘッドがないので、ライブラリ"
"を設計するのに役に立ちます。"

#. type: Title ##
#: text/chapter10.md:1246
#, fuzzy, no-wrap
msgid "Representing Quantified Types"
msgstr "量化された型の実行時表現"

#. type: Plain text
#: text/chapter10.md:1249
#, fuzzy
msgid ""
"Expressions with quantified (polymorphic) types have restrictive "
"representations at runtime. In practice, this means that there are "
"relatively few expressions with a given quantified type, but that we can "
"reason about them quite effectively."
msgstr ""
"量化された型(多相型)の式は、制限された表現を実行時に持っています。実際には、"
"量化された型の式が比較的少数与えられたとき、とても効率的に解決できることを意"
"味しています。"

#. type: Plain text
#: text/chapter10.md:1251
#, fuzzy
msgid "Consider this polymorphic type, for example:"
msgstr "例えば、次の多相型を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1252
#, fuzzy, no-wrap
msgid "forall a. a -> a\n"
msgstr "forall a. a -> a\n"

#. type: Plain text
#: text/chapter10.md:1257
#, fuzzy
msgid ""
"What sort of functions have this type? Well, there is certainly one function "
"with this type - namely, the `identity` function, defined in the `Prelude`:"
msgstr ""
"この型を持っている関数にはどんなものがあるでしょうか。少なくともひとつはこの"
"型を持つ関数が存在しています。すなわち、 `Prelude`で定義されている恒等関数 "
"`id`です。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1258
#, fuzzy, no-wrap
msgid ""
"id :: forall a. a -> a\n"
"id a = a\n"
msgstr ""
"id :: forall a. a -> a\n"
"id a = a\n"

#. type: Plain text
#: text/chapter10.md:1264
#, fuzzy
msgid ""
"In fact, the `identity` function is the _only_ (total) function with this "
"type! This certainly seems to be the case (try writing an expression with "
"this type which is not observably equivalent to `identity`), but how can we "
"be sure? We can be sure by considering the runtime representation of the "
"type."
msgstr ""
"実のところ、 `id`の関数はこの型の**唯一の**(全)関数です！これは確かに間違いな"
"さそうに見えますが(この型を持った `id`とは明らかに異なる式を書こうとしてみて"
"ください)、これを確かめるにはどうしたらいいでしょうか。これは型の実行時表現を"
"考えることによって確認することができます。"

#. type: Plain text
#: text/chapter10.md:1266
#, fuzzy, no-wrap
msgid "What is the runtime representation of a quantified type `forall a. t`? Well, any expression with the runtime representation for this type must have the correct runtime representation for the type `t` for any choice of type `a`. In our example above, a function of type `forall a. a -> a` must have the correct runtime representation for the types `String -> String`, `Number -> Number`, `Array Boolean -> Array Boolean`, and so on. It must take strings to strings, numbers to numbers, etc.\n"
msgstr "量化された型 `forall a. t`の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 `a`をどのように選んでも型 `t`の適切な実行時表現を持っていなければなりません。上の例では、型 `forall a. a -> a`の関数は、 `String -> String`、 `Number -> Number`、 `Array Boolean -> Array Boolean`などといった型について、適切な実行時表現を持っていなければなりません。 これらは、数から数、文字列から文字列の関数でなくてはなりません。\n"

#. type: Plain text
#: text/chapter10.md:1268
#, fuzzy
msgid ""
"But that is not enough - the runtime representation of a quantified type is "
"more strict than this. We require any expression to be _parametrically "
"polymorphic_ - that is, it cannot use any information about the type of its "
"argument in its implementation. This additional condition prevents "
"problematic implementations such as the following JavaScript function from "
"inhabiting a polymorphic type:"
msgstr ""
"しかし、それだけでは十分ではありません。量化された型の実行時表現は、これより"
"も更に厳しくなります。任意の式がパラメトリック多相的でなければなりません。つ"
"まり、その実装において、引数の型についてのどんな情報も使うことができないので"
"す。この追加の条件は、考えられる多相型のうち、次のようなJavaScriptの関数とし"
"て問題のある実装を禁止します。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1269
#, fuzzy, no-wrap
msgid ""
"function invalid(a) {\n"
"    if (typeof a === 'string') {\n"
"        return \"Argument was a string.\";\n"
"    } else {\n"
"        return a;\n"
"    }\n"
"}\n"
msgstr ""
"function invalid(a) {\n"
"    if (typeof a === 'string') {\n"
"        return \"Argument was a string.\";\n"
"    } else {\n"
"        return a;\n"
"    }\n"
"}\n"

#. type: Plain text
#: text/chapter10.md:1280
#, fuzzy, no-wrap
msgid "Certainly, this function takes strings to strings, numbers to numbers, etc. but it does not meet the additional condition, since it inspects the (runtime) type of its argument, so this function would not be a valid inhabitant of the type `forall a. a -> a`.\n"
msgstr "確かにこの関数は文字列から文字列、数から数へというような関数ではありますが、追加の条件を満たしていません。引数の実行時の型を調べているからです。したがって、この関数は型 `forall a. a -> a`の正しい実装だとはいえないのです。\n"

#. type: Plain text
#: text/chapter10.md:1282
#, fuzzy, no-wrap
msgid "Without being able to inspect the runtime type of our function argument, our only option is to return the argument unchanged, and so `identity` is indeed the only inhabitant of the type `forall a. a -> a`.\n"
msgstr "関数の引数の実行時の型を検査することができなければ、唯一の選択肢は引数をそのまま返すことだけであり、したがって `id`は、 `forall a. a -> a`のまったく唯一の実装なのです。\n"

#. type: Plain text
#: text/chapter10.md:1284
#, fuzzy
msgid ""
"A full discussion of _parametric polymorphism_ and _parametricity_ is beyond "
"the scope of this book. Note however, that since PureScript's types are "
"_erased_ at runtime, a polymorphic function in PureScript _cannot_ inspect "
"the runtime representation of its arguments (without using the FFI), and so "
"this representation of polymorphic data is appropriate."
msgstr ""
"**パラメトリック多相**(parametric polymorphism)と**パラメトリック性"
"**(parametricity)についての詳しい議論は本書の範囲を超えています。しかしなが"
"ら、PureScriptの型は、実行時に**消去**されているので、PureScriptの多相関数は"
"(FFIを使わない限り)引数の実行時表現を検査することが**できない**し、この多相的"
"なデータの表現は適切であることに注意してください。\n"

#. type: Title ##
#: text/chapter10.md:1285
#, fuzzy, no-wrap
msgid "Representing Constrained Types"
msgstr "制約された型の実行時表現"

#. type: Plain text
#: text/chapter10.md:1288
#, fuzzy
msgid ""
"Functions with a type class constraint have an interesting representation at "
"runtime. Because the behavior of the function might depend on the type class "
"instance chosen by the compiler, the function is given an additional "
"argument, called a _type class dictionary_, which contains the "
"implementation of the type class functions provided by the chosen instance."
msgstr ""
"型クラス制約を持つ関数は、実行時に面白い表現を持っています。関数の振る舞いは"
"コンパイラによって選ばれた型クラスのインスタンスに依存する可能性があるため、"
"関数には選択したインスタンスから提供された型クラスの関数の実装が含まれてた**"
"型クラス辞書**(type class dictionary)と呼ばれる追加の引数が与えられています。"

#. type: Plain text
#: text/chapter10.md:1290
#, fuzzy
msgid ""
"For example, here is a simple PureScript function with a constrained type "
"which uses the `Show` type class:"
msgstr ""
"例えば、 `Show`型クラスを使用している制約された型を持つ、次のような単純な"
"PureScript関数について考えます。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1291
#, fuzzy, no-wrap
msgid ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"
msgstr ""
"shout :: forall a. Show a => a -> String\n"
"shout a = show a <> \"!!!\"\n"

#. type: Plain text
#: text/chapter10.md:1297
#, fuzzy
msgid "The generated JavaScript looks like this:"
msgstr "このコードから生成されるJavaScriptは次のようになります。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1298
#, fuzzy, no-wrap
msgid ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"
msgstr ""
"var shout = function (dict) {\n"
"    return function (a) {\n"
"        return show(dict)(a) + \"!!!\";\n"
"    };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1307
#, fuzzy
msgid ""
"Notice that `shout` is compiled to a (curried) function of two arguments, "
"not one. The first argument `dict` is the type class dictionary for the "
"`Show` constraint. `dict` contains the implementation of the `show` function "
"for the type `a`."
msgstr ""
"`shout`は１引数ではなく、２引数の(カリー化された)関数にコンパイルされているこ"
"とに注意してください。最初の引数 `dict`は `Show`制約の型クラス辞書です。 "
"`dict`には型 `a`の `show`関数の実装が含まれています。"

#. type: Plain text
#: text/chapter10.md:1309
#, fuzzy
msgid ""
"We can call this function from JavaScript by passing an explicit type class "
"dictionary from `Data.Show` as the first parameter:"
msgstr ""
"最初の引数として明示的にPreludeの型クラス辞書を渡すと、JavaScriptからこの関数"
"を呼び出すことができます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1310
#, no-wrap
msgid ""
"import { showNumber } from 'Data.Show'\n"
"\n"
"shout(showNumber)(42);\n"
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter10.md:1319
#, fuzzy
msgid "(Easy) What are the runtime representations of these types?"
msgstr "(簡単) これらの型の実行時の表現は何でしょうか。"

#. type: Plain text
#: text/chapter10.md:1325
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     forall a. a\n"
"     forall a. a -> a -> a\n"
"     forall a. Ord a => Array a -> Boolean\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    forall a. a\n"
"    forall a. a -> a -> a\n"
"    forall a. Ord a => Array a -> Boolean\n"
"    ```\n"

#. type: Plain text
#: text/chapter10.md:1328
#, fuzzy, no-wrap
msgid ""
"     What can you say about the expressions which have these types?\n"
" 1. (Medium) Try using the functions defined in the `arrays` package, calling them from JavaScript, by compiling the library using `spago build` and importing modules using the `import` function in NodeJS. _Hint_: you may need to configure the output path so that the generated ES modules are available on the NodeJS module path.\n"
msgstr ""
"    これらの型を持つ式についてわかることはなんでしょうか。\n"
"1. (やや難しい)`pulp build`を使ってコンパイルし、NodeJSの `require`関数を使ってモジュールをインポートすることで、JavaScriptから `purescript-arrays`ライブラリの関数を使ってみてください。**ヒント**：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。\n"

#. type: Title ##
#: text/chapter10.md:1329
#, fuzzy, no-wrap
msgid "Representing Side Effects"
msgstr "副作用の表現"

#. type: Plain text
#: text/chapter10.md:1332
#, fuzzy
msgid ""
"The `Effect` monad is also defined as a foreign type. Its runtime "
"representation is quite simple - an expression of type `Effect a` should "
"evaluate to a JavaScript function of **no arguments**, which performs any "
"side-effects and returns a value with the correct runtime representation for "
"type `a`."
msgstr ""
"`Eff`モナドもPreludeの外部型として定義されています。その実行時表現はとても簡"
"単です。型 `Eff eff a`の式は、任意の副作用を実行し型 `a`の適切な実行時表現で"
"値を返す、引数なしのJavaScript関数へと評価されます。"

#. type: Plain text
#: text/chapter10.md:1334
#, fuzzy
msgid ""
"The definition of the `Effect` type constructor is given in the `Effect` "
"module as follows:"
msgstr ""
"`Eff`型の構築子の定義は、 `Control.Monad.Eff`モジュールで次のように与えられて"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1335
#, fuzzy, no-wrap
msgid "foreign import data Effect :: Type -> Type\n"
msgstr "foreign import data Undefined :: Type -> Type\n"

#. type: Plain text
#: text/chapter10.md:1340
#, fuzzy
msgid ""
"As a simple example, consider the `random` function defined in the `random` "
"package. Recall that its type was:"
msgstr ""
"簡単な例として、 `purescript-random`パッケージで定義される `random`関数を考え"
"てみてください。その型は次のようなものでした。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1341
#, fuzzy, no-wrap
msgid "foreign import random :: Effect Number\n"
msgstr "foreign import data ALERT :: Effect\n"

#. type: Plain text
#: text/chapter10.md:1346
#, fuzzy
msgid "The definition of the `random` function is given here:"
msgstr "`random`関数の定義は次のように与えられます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1347
#, fuzzy, no-wrap
msgid "export const random = Math.random;\n"
msgstr ""
"exports.random = function() {\n"
"  return Math.random();\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1352
#, fuzzy
msgid ""
"Notice that the `random` function is represented at runtime as a function of "
"no arguments. It performs the side effect of generating a random number, and "
"returns it, and the return value matches the runtime representation of the "
"`Number` type: it is a non-null JavaScript number."
msgstr ""
"`random`関数は実行時には引数なしの関数として表現されていることに注目してくだ"
"さい。これは乱数生成という副作用を実行しそれを返しますが、返り値は `Number`型"
"の実行時表現と一致します。それは `null`でないJavaScriptの数です。"

#. type: Plain text
#: text/chapter10.md:1354
#, fuzzy
msgid ""
"As a slightly more interesting example, consider the `log` function defined "
"by the `Effect.Console` module in the `console` package. The `log` function "
"has the following type:"
msgstr ""
"もう少し興味深い例として、 Preludeの `Control.Monad.Eff.Console`モジュールで"
"定義された `log`関数を考えてみましょう。 `log`関数は次の型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter10.md:1355
#, fuzzy, no-wrap
msgid "foreign import log :: String -> Effect Unit\n"
msgstr "foreign import log :: forall eff. String -> Eff (console :: CONSOLE | eff) Unit\n"

#. type: Plain text
#: text/chapter10.md:1360
#, fuzzy
msgid "And here is its definition:"
msgstr "この定義は次のようになっています。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1361
#, fuzzy, no-wrap
msgid ""
"export const log = function (s) {\n"
"  return function () {\n"
"    console.log(s);\n"
"  };\n"
"};\n"
msgstr ""
"exports.log = function (s) {\n"
"  return function () {\n"
"    console.log(s);\n"
"  };\n"
"};\n"

#. type: Plain text
#: text/chapter10.md:1370
#, fuzzy
msgid ""
"The representation of `log` at runtime is a JavaScript function of a single "
"argument, returning a function of no arguments. The inner function performs "
"the side-effect of writing a message to the console."
msgstr ""
"実行時の `log`の表現は、引数なしの関数を返す、単一の引数のJavaScript関数で"
"す。内側の関数はコンソールにメッセージを書き込むという副作用を実行し、空のレ"
"コードを返します。 `Unit`は空のレコード型のnewtypeとしてPreludeで定義されてい"
"るので、内側の関数の戻り値の型は `Unit`型の実行時表現と一致していることに注意"
"してください。"

#. type: Plain text
#: text/chapter10.md:1372
#, fuzzy
msgid ""
"Expressions of type `Effect a` can be invoked from JavaScript like regular "
"JavaScript methods. For example, since the `main` function is required to "
"have type `Effect a` for some type `a`, it can be invoked as follows:"
msgstr ""
"`Eff eff a`型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出す"
"ことができます。例えば、この `main`関数は作用の集合 `eff`と何らかの型 `a`につ"
"いて `Eff eff a`という型でなければならないので、次のように実行することができ"
"ます。"

#. type: Fenced code block (javascript)
#: text/chapter10.md:1373
#, no-wrap
msgid ""
"import { main } from 'Main'\n"
"\n"
"main();\n"
msgstr ""

#. type: Plain text
#: text/chapter10.md:1379
#, fuzzy
msgid ""
"When using `spago bundle-app --to` or `spago run`, this call to `main` is "
"generated automatically, whenever the `Main` module is defined."
msgstr ""
"`pulp build -O --to`または `pulp run`を使用するときは、 `main`モジュールが定"
"義されていると、この `main`の呼び出しを自動的に生成することができます。"

#. type: Title #
#: text/chapter11.md:1
#, fuzzy, no-wrap
msgid "Monadic Adventures"
msgstr "モナドの探求"

#. type: Plain text
#: text/chapter11.md:6
#, fuzzy
msgid ""
"The goal of this chapter will be to learn about _monad transformers_, which "
"provide a way to combine side-effects provided by different monads. The "
"motivating example will be a text adventure game which can be played on the "
"console in NodeJS. The various side-effects of the game (logging, state, and "
"configuration) will all be provided by a monad transformer stack."
msgstr ""
"この章の目標は、異なるモナドから提供された副作用を合成する方法を提供する**モ"
"ナド変換子**(monad transformers)について学ぶことです。NodeJSのコンソール上で"
"遊ぶことができる、テキストアドベンチャーゲームを題材として扱います。ゲームの"
"様々な副作用(ロギング、状態、および設定)がすべてモナド変換子スタックによって"
"提供されます。"

#. type: Plain text
#: text/chapter11.md:10 text/chapter12.md:10
#, fuzzy
msgid "This module's project introduces the following new dependencies:"
msgstr ""
"#-#-#-#-#  refs/ja2/src/chapter09.md:10  #-#-#-#-#\n"
"このモジュールのプロジェクトでは、以下のBowerの依存関係が新しく追加されていま"
"す。\n"
"#-#-#-#-#  refs/ja2/src/chapter11.md:10  #-#-#-#-#\n"
"このモジュールのプロジェクトでは以下のBower依存関係が新たに導入されます。"

#. type: Plain text
#: text/chapter11.md:15
#, fuzzy
msgid ""
"- `ordered-collections`, which provides data types for immutable maps and "
"sets - `transformers`, which provides implementations of standard monad "
"transformers - `node-readline`, which provides FFI bindings to the "
"[`readline`](https://nodejs.org/api/readline.html) interface provided by "
"NodeJS - `optparse`, which provides applicative parsers for processing "
"command line arguments"
msgstr ""
"- `purescript-maps`　- 不変のマップと集合のためのデータ型を提供します。 - "
"`purescript-sets`- 不変集合のデータ型を提供する標準的なモナド変換子の実装を提"
"供する - `purescript-transformers`- 標準のモナド変換子の実装を提供します。 - "
"`purescript-node-readline`- NodeJSが提供する[`readline`](http://nodejs.org/"
"api/readline.html)インターフェイスへのFFIバインディングを提供します。 - "
"`purescript-yargs`- [`yargs`](https://www.npmjs.org/package/yargs)コマンドラ"
"イン引数処理ライブラリにApplicativeなインターフェイスを提供します。"

#. type: Title ##
#: text/chapter11.md:16
#, fuzzy, no-wrap
msgid "How To Play The Game"
msgstr "ゲームの遊びかた"

#. type: Plain text
#: text/chapter11.md:19
#, fuzzy
msgid "To run the project, use `spago run`"
msgstr ""
"プロジェクトを実行するには、 `pulp run`でソースコードをビルドしてから、NodeJS"
"にコンパイルされたJavaScriptを渡します。"

#. type: Plain text
#: text/chapter11.md:21
#, fuzzy
msgid "By default you will see a usage message:"
msgstr "デフォルトでは使い方が表示されます。"

#. type: Fenced code block (text)
#: text/chapter11.md:22
#, no-wrap
msgid ""
"Monadic Adventures! A game to learn monad transformers\n"
"\n"
"Usage: run.js (-p|--player <player name>) [-d|--debug]\n"
"  Play the game as <player name>\n"
"\n"
"Available options:\n"
"  -p,--player <player name>\n"
"                           The player's name <String>\n"
"  -d,--debug               Use debug mode\n"
"  -h,--help                Show this help text\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:35
#, no-wrap
msgid "To provide command line arguments, you can either call `spago run` with the `-a` option to pass additional arguments directly to your application, or you can call `spago bundle-app`, which will create an index.js file that can be run directly with `node`.  \n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:37
#, fuzzy
msgid "For example, to provide the player name using the `-p` option:"
msgstr "`-p`オプションを使ってプレイヤー名を指定してください。"

#. type: Fenced code block (text)
#: text/chapter11.md:38
#, fuzzy, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
">\n"
msgstr ""
"pulp run -- -p Phil\n"
"> \n"

#. type: Fenced code block (text)
#: text/chapter11.md:42
#, no-wrap
msgid ""
"$ spago bundle-app \n"
"$ node index.js -p Phil\n"
">\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:49
#, fuzzy
msgid ""
"From the prompt, you can enter commands like `look`, `inventory`, `take`, "
"`use`, `north`, `south`, `east`, and `west`. There is also a `debug` "
"command, which can be used to print the game state when the `--debug` "
"command line option is provided."
msgstr ""
"プロンプトからは、 `look`、 `inventory`、 `take`、 `use`、 `north`、 "
"`south`、 `east`、 `west`などのコマンドを入力することができます。 `--debug`コ"
"マンドラインオプションが与えられたときには、ゲームの状態を出力するための "
"`debug`コマンドも使えます。"

#. type: Plain text
#: text/chapter11.md:51
#, fuzzy
msgid ""
"The game is played on a two-dimensional grid, and the player moves by "
"issuing commands `north`, `south`, `east`, and `west`. The game contains a "
"collection of items which can either be in the player's possession (in the "
"user's _inventory_), or on the game grid at some location. Items can be "
"picked up by the player, using the `take` command."
msgstr ""
"ゲームは2次元の碁盤の目の上でプレイし、コマンド `north`、 `south`、 `east`、 "
"`west`を発行することによってプレイヤーが移動します。ゲームにはアイテムの配列"
"があり、プレイヤーの所持アイテム一覧を表したり、ゲーム盤上のその位置にあるア"
"イテムの一覧を表すのに使われます。 `take`コマンドを使うと、プレイヤーの位置に"
"あるアイテムを拾い上げることができます。"

#. type: Plain text
#: text/chapter11.md:53
#, fuzzy
msgid "For reference, here is a complete walkthrough of the game:"
msgstr "参考までに、このゲームのひと通りの流れは次のようになります。"

#. type: Fenced code block (text)
#: text/chapter11.md:54
#, fuzzy, no-wrap
msgid ""
"$ spago run -a \"-p Phil\"\n"
"\n"
"> look\n"
"You are at (0, 0)\n"
"You are in a dark forest. You see a path to the north.\n"
"You can see the Matches.\n"
"\n"
"> take Matches\n"
"You now have the Matches\n"
"\n"
"> north\n"
"> look\n"
"You are at (0, 1)\n"
"You are in a clearing.\n"
"You can see the Candle.\n"
"\n"
"> take Candle\n"
"You now have the Candle\n"
"\n"
"> inventory\n"
"You have the Candle.\n"
"You have the Matches.\n"
"\n"
"> use Matches\n"
"You light the candle.\n"
"Congratulations, Phil!\n"
"You win!\n"
msgstr ""
"$ pulp run -- -p Phil\n"
"\n"
"> look\n"
"You are at (0, 0)\n"
"You are in a dark forest. You see a path to the north.\n"
"You can see the Matches.\n"
"\n"
"> take Matches\n"
"You now have the Matches\n"
"\n"
"> north\n"
"> look\n"
"You are at (0, 1)\n"
"You are in a clearing.\n"
"You can see the Candle.\n"
"\n"
"> take Candle\n"
"You now have the Candle\n"
"\n"
"> inventory\n"
"You have the Candle.\n"
"You have the Matches.\n"
"\n"
"> use Matches\n"
"You light the candle.\n"
"Congratulations, Phil!\n"
"You win!\n"

#. type: Plain text
#: text/chapter11.md:85
#, fuzzy
msgid ""
"The game is very simple, but the aim of the chapter is to use the "
"`transformers` package to build a library which will enable rapid "
"development of this type of game."
msgstr ""
"このゲームはとても単純ですが、この章の目的は `purescript-transformers`パッ"
"ケージを使用してこのようなゲームを素早く開発できるようにするライブラリを構築"
"することです。"

#. type: Title ##
#: text/chapter11.md:86
#, fuzzy, no-wrap
msgid "The State Monad"
msgstr "Stateモナド"

#. type: Plain text
#: text/chapter11.md:89
#, fuzzy
msgid ""
"We will start by looking at some of the monads provided by the "
"`transformers` package."
msgstr ""
"`purescript-transformers`パッケージで提供されるモナドをいくつか見てみましょ"
"う。"

#. type: Plain text
#: text/chapter11.md:91
#, fuzzy
msgid ""
"The first example is the `State` monad, which provides a way to model "
"_mutable state_ in pure code. We have already seen an approach to mutable "
"state provided by the `Effect` monad. `State` provides an alternative."
msgstr ""
"最初の例は、**純粋な変更可能状態**を提供する `State`モナドです。すでに `Eff`"
"モナド、すなわち `REF`作用と `ST`作用によって提供された変更可能な状態という2"
"つのアプローチについては見てきました。 `State`は第3の選択肢を提供しますが、こ"
"れは `Eff`モナドを使用して実装されているわけではありません。"

#. type: Plain text
#: text/chapter11.md:93
#, fuzzy
msgid ""
"The `State` type constructor takes two type parameters: the type `s` of the "
"state, and the return type `a`. Even though we speak of the \"`State` monad"
"\", the instance of the `Monad` type class is actually provided for the "
"`State s` type constructor, for any type `s`."
msgstr ""
"`State`型構築子は、状態の型 `s`、および返り値の型 `a`という2種類の引数を取り"
"ます。「 `State`モナド」というように説明はしていますが、実際には `Monad`型ク"
"ラスのインスタンスが用意されているのは `State`に対してではなく、任意の型 `s`"
"についての `State s`型構築子に対してです。"

#. type: Plain text
#: text/chapter11.md:95
#, fuzzy
msgid "The `Control.Monad.State` module provides the following API:"
msgstr "`Control.Monad.State`モジュールは以下のAPIを提供しています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:96
#, fuzzy, no-wrap
msgid ""
"get     :: forall s.             State s s\n"
"gets    :: forall s. (s -> a) -> State s a\n"
"put     :: forall s. s        -> State s Unit\n"
"modify  :: forall s. (s -> s) -> State s s\n"
"modify_ :: forall s. (s -> s) -> State s Unit\n"
msgstr ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"

#. type: Plain text
#: text/chapter11.md:105
msgid ""
"Note that these API signatures are presented in a simplified form using the "
"`State` type constructor for now. The actual API involves `MonadState` which "
"we'll cover in the later \"Type Classes\" section of this chapter, so don't "
"worry if you see different signatures in your IDE tooltips or on Pursuit."
msgstr ""

#. type: Plain text
#: text/chapter11.md:107
#, fuzzy
msgid ""
"Let's see an example. One use of the `State` monad might be to add the "
"values in an array of integers to the current state. We could do that by "
"choosing `Int` as the state type `s`, and using `traverse_` to traverse the "
"array, with a call to `modify` for each array element:"
msgstr ""
"例を見てみましょう。 `State`モナドの使いかたのひとつとしては、状態を数とし"
"て、現在の状態に配列の値を加算していくようなものかもしれません。状態の型 `s`"
"として `Number`を選択し、配列の走査に `traverse_`を使って、配列の要素それぞれ"
"について `modify`を呼び出すと、これを実現することができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:108
#, fuzzy, no-wrap
msgid ""
"import Data.Foldable (traverse_)\n"
"import Control.Monad.State\n"
"import Control.Monad.State.Class\n"
"\n"
"sumArray :: Array Int -> State Int Unit\n"
"sumArray = traverse_ \\n -> modify \\sum -> sum + n\n"
msgstr ""
"import Data.Foldable (traverse_)\n"
"import Control.Monad.State\n"
"import Control.Monad.State.Class\n"
"\n"
"sumArray :: Array Number -> State Number Unit\n"
"sumArray = traverse_ \\n -> modify \\sum -> sum + n\n"

#. type: Plain text
#: text/chapter11.md:118
#, fuzzy
msgid ""
"The `Control.Monad.State` module provides three functions for running a "
"computation in the `State` monad:"
msgstr ""
"`Control.Monad.State`モジュールは `State`モナドでの計算を実行するための次の3"
"つの関数を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:119
#, fuzzy, no-wrap
msgid ""
"evalState :: forall s a. State s a -> s -> a\n"
"execState :: forall s a. State s a -> s -> s\n"
"runState  :: forall s a. State s a -> s -> Tuple a s\n"
msgstr ""
"evalState :: forall s a. State s a -> s -> a\n"
"execState :: forall s a. State s a -> s -> s\n"
"runState  :: forall s a. State s a -> s -> Tuple a s\n"

#. type: Plain text
#: text/chapter11.md:126
#, fuzzy
msgid ""
"Each of these functions takes an initial state of type `s` and a computation "
"of type `State s a`. `evalState` only returns the return value, `execState` "
"only returns the final state, and `runState` returns both, expressed as a "
"value of type `Tuple a s`."
msgstr ""
"３つの関数はそれぞれ初期値の型 `s`と計算の型 `State s a`を引数にとります。 "
"`evalState`は返り値だけを返し、 `execState`は最終的な状態だけを返し、 "
"`runState`は `Tuple a s`型の値として表現された返り値と状態の両方を返します。"

#. type: Plain text
#: text/chapter11.md:128
#, fuzzy
msgid ""
"Given the `sumArray` function above, we could use `execState` in PSCi to sum "
"the numbers in several arrays as follows:"
msgstr ""
"先ほどの `sumArray`関数が与えられたとすると、 `PSCi`で次のように `execState`"
"を使うと複数の配列内の数字を合計することができます。"

#. type: Fenced code block (text)
#: text/chapter11.md:129
#, fuzzy, no-wrap
msgid ""
"> :paste\n"
"â¦ execState (do\n"
"â¦   sumArray [1, 2, 3]\n"
"â¦   sumArray [4, 5]\n"
"â¦   sumArray [6]) 0\n"
"â¦ ^D\n"
"21\n"
msgstr ""
"> :paste\n"
"… execState (do\n"
"…   sumArray [1, 2, 3]\n"
"…   sumArray [4, 5]\n"
"…   sumArray [6]) 0\n"
"… ^D\n"
"21\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:144
#, fuzzy
msgid ""
"(Easy) What is the result of replacing `execState` with `runState` or "
"`evalState` in our example above?"
msgstr ""
"(簡単) 上の例で、 `execState`を `runState`や `evalState`で 置き換えると結果は"
"どうなるでしょうか。"

#. type: Plain text
#: text/chapter11.md:144
#, fuzzy, no-wrap
msgid ""
" 1. (Medium) A string of parentheses is _balanced_ if it is obtained by either concatenating zero-or-more shorter balanced\n"
"     strings, or by wrapping a shorter balanced string in a pair of parentheses.\n"
msgstr ""
"1. (やや難しい) A string of parentheses is _balanced_ if it is obtained by either concatenating zero-or-more shorter balanced\n"
"    strings, or by wrapping a shorter balanced string in a pair of parentheses.\n"

#. type: Plain text
#: text/chapter11.md:146
#, fuzzy, no-wrap
msgid "     Use the `State` monad and the `traverse_` function to write a function\n"
msgstr "    `State`モナドと `traverse_`関数を使用して、次のような関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:150
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     testParens :: String -> Boolean\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    testParens :: String -> Boolean\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:153
#, fuzzy, no-wrap
msgid ""
"     which tests whether or not a `String` of parentheses is balanced, by keeping track of the number of opening parentheses\n"
"     which have not been closed. Your function should work as follows:\n"
msgstr "    これは `String`が括弧の対応が正しく付けられているかどうかを調べる関数です。この関数は次のように動作しなくてはなりません。\n"

#. type: Plain text
#: text/chapter11.md:157
#, fuzzy, no-wrap
msgid ""
"     ```text\n"
"     > testParens \"\"\n"
"     true\n"
msgstr ""
"    ```text\n"
"    > testParens \"\"\n"
"    true\n"

#. type: Plain text
#: text/chapter11.md:160
#, fuzzy, no-wrap
msgid ""
"     > testParens \"(()(())())\"\n"
"     true\n"
msgstr ""
"    > testParens \"(()(())())\"\n"
"    true\n"

#. type: Plain text
#: text/chapter11.md:163
#, fuzzy, no-wrap
msgid ""
"     > testParens \")\"\n"
"     false\n"
msgstr ""
"    > testParens \")\"\n"
"    false\n"

#. type: Plain text
#: text/chapter11.md:167
#, fuzzy, no-wrap
msgid ""
"     > testParens \"(()()\"\n"
"     false\n"
"     ```\n"
msgstr ""
"    > testParens \"(()()\"\n"
"    false\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:169
#, fuzzy, no-wrap
msgid "     _Hint_: you may like to use the `toCharArray` function from the `Data.String.CodeUnits` module to turn the input string into an array of characters.\n"
msgstr "    **ヒント**： 入力の文字列を文字の配列に変換するのに、 `Data.String`モジュールの `split`関数を使うと良いでしょう。\n"

#. type: Title ##
#: text/chapter11.md:170
#, fuzzy, no-wrap
msgid "The Reader Monad"
msgstr "Readerモナド"

#. type: Plain text
#: text/chapter11.md:173
#, fuzzy
msgid ""
"Another monad provided by the `transformers` package is the `Reader` monad. "
"This monad provides the ability to read from a global configuration. Whereas "
"the `State` monad provides the ability to read and write a single piece of "
"mutable state, the `Reader` monad only provides the ability to read a single "
"piece of data."
msgstr ""
"`purescript-transformers`パッケージでは `Reader`というモナドも提供されていま"
"す。このモナドは大域的な設定を読み取る機能を提供します。 `State`モナドがひと"
"つの可変状態を読み書きする機能を提供するのに対し、 `Reader`モナドはデータの読"
"み取りの機能だけを提供します。"

#. type: Plain text
#: text/chapter11.md:175
#, fuzzy
msgid ""
"The `Reader` type constructor takes two type arguments: a type `r` which "
"represents the configuration type, and the return type `a`."
msgstr ""
"`Reader`型構築子は、構成の型を表す型 `r`、および戻り値の型 `a`の2つの型引数を"
"取ります。"

#. type: Plain text
#: text/chapter11.md:177
#, fuzzy
msgid "The `Control.Monad.Reader` module provides the following API:"
msgstr "`Contro.Monad.Reader`モジュールは以下のAPIを提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:178
#, fuzzy, no-wrap
msgid ""
"ask   :: forall r. Reader r r\n"
"local :: forall r a. (r -> r) -> Reader r a -> Reader r a\n"
msgstr ""
"ask   :: forall r. Reader r r\n"
"local :: forall r a. (r -> r) -> Reader r a -> Reader r a\n"

#. type: Plain text
#: text/chapter11.md:184
#, fuzzy
msgid ""
"The `ask` action can be used to read the current configuration, and the "
"`local` action can be used to run a computation with a modified "
"configuration."
msgstr ""
"`ask`アクションは現在の設定を読み取るために使い、 `local`アクションは局所的に"
"設定を変更して計算を実行するために使います。"

#. type: Plain text
#: text/chapter11.md:186
#, fuzzy
msgid ""
"For example, suppose we were developing an application controlled by "
"permissions, and we wanted to use the `Reader` monad to hold the current "
"user's permissions object. We might choose the type `r` to be some type "
"`Permissions` with the following API:"
msgstr ""
"たとえば、権限で制御されたアプリケーションを開発しており、現在の利用者の権限"
"オブジェクトを保持するのに `Reader`モナドを使いたいとしましょう。型 `r`を次の"
"ようなAPIを備えた型 `Permission`として選択します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:187
#, fuzzy, no-wrap
msgid ""
"hasPermission :: String -> Permissions -> Boolean\n"
"addPermission :: String -> Permissions -> Permissions\n"
msgstr ""
"hasPermission :: String -> Permissions -> Boolean\n"
"addPermission :: String -> Permissions -> Permissions\n"

#. type: Plain text
#: text/chapter11.md:193
#, fuzzy
msgid ""
"Whenever we wanted to check if the user had a particular permission, we "
"could use `ask` to retrieve the current permissions object. For example, "
"only administrators might be allowed to create new users:"
msgstr ""
"利用者が特定の権限を持っているかどうかを確認したいときは、 `ask`を使って現在"
"の権限オブジェクトを取得すればいつでも調べることができます。たとえば、管理者"
"だけが新しい利用者の作成を許可されているとしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:194
#, fuzzy, no-wrap
msgid ""
"createUser :: Reader Permissions (Maybe User)\n"
"createUser = do\n"
"  permissions <- ask\n"
"  if hasPermission \"admin\" permissions\n"
"    then map Just newUser\n"
"    else pure Nothing\n"
msgstr ""
"createUser :: Reader Permissions (Maybe User)\n"
"createUser = do\n"
"  permissions <- ask\n"
"  if hasPermission \"admin\" permissions\n"
"    then map Just newUser\n"
"    else pure Nothing\n"

#. type: Plain text
#: text/chapter11.md:204
#, fuzzy
msgid ""
"To elevate the user's permissions, we might use the `local` action to modify "
"the `Permissions` object during the execution of some computation:"
msgstr ""
"`local`アクションを使うと、計算の実行中に `Permissions`オブジェクトを局所的に"
"変更し、ユーザーの権限を昇格させることもできます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:205
#, fuzzy, no-wrap
msgid ""
"runAsAdmin :: forall a. Reader Permissions a -> Reader Permissions a\n"
"runAsAdmin = local (addPermission \"admin\")\n"
msgstr ""
"runAsAdmin :: forall a. Reader Permissions a -> Reader Permissions a\n"
"runAsAdmin = local (addPermission \"admin\")\n"

#. type: Plain text
#: text/chapter11.md:211
#, fuzzy
msgid ""
"Then we could write a function to create a new user, even if the user did "
"not have the `admin` permission:"
msgstr ""
"こうすると、利用者が `admin`権限を持っていなかった場合であっても、新しい利用"
"者を作成する関数を書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:212
#, fuzzy, no-wrap
msgid ""
"createUserAsAdmin :: Reader Permissions (Maybe User)\n"
"createUserAsAdmin = runAsAdmin createUser\n"
msgstr ""
"createUserAsAdmin :: Reader Permissions (Maybe User)\n"
"createUserAsAdmin = runAsAdmin createUser\n"

#. type: Plain text
#: text/chapter11.md:218
#, fuzzy
msgid ""
"To run a computation in the `Reader` monad, the `runReader` function can be "
"used to provide the global configuration:"
msgstr ""
"`Reader`モナドの計算を実行するには、大域的な設定を与える `runReader`関数を使"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:219
#, fuzzy, no-wrap
msgid "runReader :: forall r a. Reader r a -> r -> a\n"
msgstr "runReader :: forall r a. Reader r a -> r -> a\n"

#. type: Plain text
#: text/chapter11.md:226
#, fuzzy, no-wrap
msgid " In these exercises, we will use the `Reader` monad to build a small library for rendering documents with indentation. The \"global configuration\" will be a number indicating the current indentation level:\n"
msgstr "以下の演習では、 `Reader`モナドを使って、字下げのついた文書を出力するための小さなライブラリを作っていきます。「大域的な設定」は、現在の字下げの深さを示す数になります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:227
#, fuzzy, no-wrap
msgid ""
"type Level = Int\n"
"\n"
"type Doc = Reader Level String\n"
msgstr ""
"type Level = Number\n"
"\n"
"type Doc = Reader Level String\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:234
#, fuzzy
msgid ""
"(Easy) Write a function `line` which renders a function at the current "
"indentation level. Your function should have the following type:"
msgstr ""
"(簡単)　現在の字下げの深さで文字列を出力する関数 `line`を書いてください。その"
"関数は、以下の型を持っている必要があります。"

#. type: Plain text
#: text/chapter11.md:238
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     line :: String -> Doc\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    line :: String -> Doc\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:241
#, fuzzy, no-wrap
msgid ""
"     _Hint_: use the `ask` function to read the current indentation level. The `power` function from `Data.Monoid` may be helpful too.\n"
" 1. (Easy) Use the `local` function to write a function\n"
msgstr ""
"    **ヒント**：現在の字下げの深さを読み取るためには `ask`関数を使用します。\n"
"1. (やや難しい)`local`関数を使用して次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:245
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     indent :: Doc -> Doc\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    indent :: Doc -> Doc\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:248
#, fuzzy, no-wrap
msgid ""
"     which increases the indentation level for a block of code.\n"
" 1. (Medium) Use the `sequence` function defined in `Data.Traversable` to write a function\n"
msgstr ""
"    この関数はコードブロックの字下げの深さを大きくします。\n"
"1. (やや難しい)`Data.Traversable`で定義された `sequence`関数を使用して、次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:252
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     cat :: Array Doc -> Doc\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    cat :: Array Doc -> Doc\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:255
#, fuzzy, no-wrap
msgid ""
"     which concatenates a collection of documents, separating them with new lines.\n"
" 1. (Medium) Use the `runReader` function to write a function\n"
msgstr ""
"    この関数は文書のリストを改行で区切って連結します。\n"
"1. (やや難しい)`runReader`関数を使用して次の関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:259
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     render :: Doc -> String\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    render :: Doc -> String\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:261
#, fuzzy, no-wrap
msgid "     which renders a document as a String.\n"
msgstr "    この関数は文書を文字列として出力します。\n"

#. type: Plain text
#: text/chapter11.md:263
#, fuzzy, no-wrap
msgid " You should now be able to use your library to write simple documents, as follows:\n"
msgstr "これで、このライブラリを次のように使うと、簡単な文書を書くことができるはずです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:264
#, fuzzy, no-wrap
msgid ""
" render $ cat\n"
"   [ line \"Here is some indented text:\"\n"
"   , indent $ cat\n"
"       [ line \"I am indented\"\n"
"       , line \"So am I\"\n"
"       , indent $ line \"I am even more indented\"\n"
"       ]\n"
"   ]\n"
msgstr ""
"render $ cat\n"
"  [ line \"Here is some indented text:\"\n"
"  , indent $ cat\n"
"      [ line \"I am indented\"\n"
"      , line \"So am I\"\n"
"      , indent $ line \"I am even more indented\"\n"
"      ]\n"
"  ]\n"

#. type: Title ##
#: text/chapter11.md:275
#, fuzzy, no-wrap
msgid "The Writer Monad"
msgstr "Writerモナド"

#. type: Plain text
#: text/chapter11.md:278
#, fuzzy
msgid ""
"The `Writer` monad provides the ability to accumulate a secondary value in "
"addition to the return value of a computation."
msgstr ""
"`Writer`モナドは、計算の返り値に加えて、もうひとつの値を累積していく機能を提"
"供します。"

#. type: Plain text
#: text/chapter11.md:280
#, fuzzy
msgid ""
"A common use case is to accumulate a log of type `String` or `Array String`, "
"but the `Writer` monad is more general than this. It can actually be used to "
"accumulate a value in any monoid, so it might be used to keep track of an "
"integer total using the `Additive Int` monoid, or to track whether any of "
"several intermediate `Boolean` values were true, using the `Disj Boolean` "
"monoid."
msgstr ""
"よくある使い方としては型 `String`もしくは `Array String`でログを累積していく"
"というものなどがありますが、 `Writer`モナドはこれよりもっと一般的なものです。"
"これは累積するのに任意のモノイドの値を使うことができ、 `Sum`モノイドを使っ"
"て、合計を追跡し続けるのに使ったり、 `Any`モノイドを使って途中の `Boolean`値"
"がすべて真であるかどうかを追跡するのに使うことができます。"

#. type: Plain text
#: text/chapter11.md:282
#, fuzzy
msgid ""
"The `Writer` type constructor takes two type arguments: a type `w` which "
"should be an instance of the `Monoid` type class, and the return type `a`."
msgstr ""
"`Writer`型の構築子は、 `Monoid`型クラスのインスタンスである型 `w`、および返り"
"値の型 `a`という2つの型引数を取ります。"

#. type: Plain text
#: text/chapter11.md:284
#, fuzzy
msgid "The key element of the `Writer` API is the `tell` function:"
msgstr "`Writer`のAPIで重要なのは `tell`関数です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:285
#, fuzzy, no-wrap
msgid "tell :: forall w a. Monoid w => w -> Writer w Unit\n"
msgstr "tell :: forall w a. Monoid w => w -> Writer w Unit\n"

#. type: Plain text
#: text/chapter11.md:290
#, fuzzy
msgid ""
"The `tell` action appends the provided value to the current accumulated "
"result."
msgstr "`tell`アクションは、与えられた値を現在の累積結果に加算します。"

#. type: Plain text
#: text/chapter11.md:292
#, fuzzy
msgid ""
"As an example, let's add a log to an existing function by using the `Array "
"String` monoid. Consider our previous implementation of the _greatest common "
"divisor_ function:"
msgstr ""
"例として、 `Array String`モノイドを使用して、既存の関数にログ機能を追加してみ"
"ましょう。**最大公約数**関数の以前の実装を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:293
#, fuzzy, no-wrap
msgid ""
"gcd :: Int -> Int -> Int\n"
"gcd n 0 = n\n"
"gcd 0 m = m\n"
"gcd n m = if n > m\n"
"            then gcd (n - m) m\n"
"            else gcd n (m - n)\n"
msgstr ""
"gcd :: Int -> Int -> Int\n"
"gcd n 0 = n\n"
"gcd 0 m = m\n"
"gcd n m = if n > m\n"
"            then gcd (n - m) m\n"
"            else gcd n (m - n)\n"

#. type: Plain text
#: text/chapter11.md:303
#, fuzzy
msgid ""
"We could add a log to this function by changing the return type to `Writer "
"(Array String) Int`:"
msgstr ""
"`Writer (Array String) Int`に返り値の型を変更することで、この関数にログ機能を"
"追加することができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:304
#, fuzzy, no-wrap
msgid ""
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"\n"
"gcdLog :: Int -> Int -> Writer (Array String) Int\n"
msgstr ""
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"\n"
"gcdLog :: Int -> Int -> Writer (Array String) Int\n"

#. type: Plain text
#: text/chapter11.md:312
#, fuzzy
msgid ""
"We only have to change our function slightly to log the two inputs at each "
"step:"
msgstr "各手順で二つの入力を記録するために、少し関数を変更する必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:313
#, fuzzy, no-wrap
msgid ""
"    gcdLog n 0 = pure n\n"
"    gcdLog 0 m = pure m\n"
"    gcdLog n m = do\n"
"      tell [\"gcdLog \" <> show n <> \" \" <> show m]\n"
"      if n > m\n"
"        then gcdLog (n - m) m\n"
"        else gcdLog n (m - n)\n"
msgstr ""
"gcdLog n 0 = pure n\n"
"gcdLog 0 m = pure m\n"
"gcdLog n m = do\n"
"  tell [\"gcdLog \" <> show n <> \" \" <> show m]\n"
"  if n > m\n"
"    then gcdLog (n - m) m\n"
"    else gcdLog n (m - n)\n"

#. type: Plain text
#: text/chapter11.md:324
#, fuzzy
msgid ""
"We can run a computation in the `Writer` monad by using either of the "
"`execWriter` or `runWriter` functions:"
msgstr ""
"`Writer`モナドの計算を実行するには、 `execWriter`関数と `runWriter`関数のいず"
"れかを使います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:325
#, fuzzy, no-wrap
msgid ""
"execWriter :: forall w a. Writer w a -> w\n"
"runWriter  :: forall w a. Writer w a -> Tuple a w\n"
msgstr ""
"execWriter :: forall w a. Writer w a -> w\n"
"runWriter  :: forall w a. Writer w a -> Tuple a w\n"

#. type: Plain text
#: text/chapter11.md:331
#, fuzzy
msgid ""
"Just like in the case of the `State` monad, `execWriter` only returns the "
"accumulated log, whereas `runWriter` returns both the log and the result."
msgstr ""
"ちょうど `State`モナドの場合と同じように、 `execWriter`が累積されたログだけを"
"返すのに対して、 `runWriter`は累積されたログと結果の両方を返します。"

#. type: Plain text
#: text/chapter11.md:333
#, fuzzy
msgid "We can test our modified function in PSCi:"
msgstr "`PSCi`で修正された関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:334
#, fuzzy, no-wrap
msgid ""
"> import Control.Monad.Writer\n"
"> import Control.Monad.Writer.Class\n"
"\n"
"> runWriter (gcdLog 21 15)\n"
"Tuple 3 [\"gcdLog 21 15\",\"gcdLog 6 15\",\"gcdLog 6 9\",\"gcdLog 6 3\",\"gcdLog 3 3\"]\n"
msgstr ""
"> import Control.Monad.Writer\n"
"> import Control.Monad.Writer.Class\n"
"\n"
"> runWriter (gcdLog 21 15)\n"
"Tuple 3 [\"gcdLog 21 15\",\"gcdLog 6 15\",\"gcdLog 6 9\",\"gcdLog 6 3\",\"gcdLog 3 3\"]\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:346
#, fuzzy
msgid ""
"(Medium) Rewrite the `sumArray` function above using the `Writer` monad and "
"the `Additive Int` monoid from the `monoid` package."
msgstr ""
"(やや難しい)`Writer`モナドと `purescript-monoid`パッケージの `Additive Int`の"
"モノイドを使うように、上の `sumArray`関数を書き換えてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:346
#, fuzzy
msgid ""
"(Medium) The _Collatz_ function is defined on natural numbers `n` as `n / 2` "
"when `n` is even, and `3 * n + 1` when `n` is odd. For example, the iterated "
"Collatz sequence starting at `10` is as follows:"
msgstr ""
"(やや難しい)**コラッツ関数**は、自然数 `n`が偶数なら `n / 2`、 `n`が奇数なら "
"`3 * n + 1`であると定義されています。たとえば、 `10`で始まるコラッツ数列は次"
"のようになります。"

#. type: Plain text
#: text/chapter11.md:350
#, fuzzy, no-wrap
msgid ""
"     ```text\n"
"     10, 5, 16, 8, 4, 2, 1, ...\n"
"     ```\n"
msgstr ""
"    ```text\n"
"    10, 5, 16, 8, 4, 2, 1, ...\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:352
#, fuzzy, no-wrap
msgid "     It is conjectured that the iterated Collatz sequence always reaches `1` after some finite number of applications of the Collatz function.\n"
msgstr "    コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的に `1`になるということとが予想できます。\n"

#. type: Plain text
#: text/chapter11.md:354
#, fuzzy, no-wrap
msgid "     Write a function which uses recursion to calculate how many iterations of the Collatz function are required before the sequence reaches `1`.\n"
msgstr "    数列が `1`に到達するまでに何回のコラッツ関数の適用が必要かを計算する再帰的な関数を書いてください。\n"

#. type: Plain text
#: text/chapter11.md:356
#, fuzzy, no-wrap
msgid "     Modify your function to use the `Writer` monad to log each application of the Collatz function.\n"
msgstr "    `Writer`モナドを使用してコラッツ関数のそれぞれの適用の経過を記録するように、関数を変更してください。\n"

#. type: Title ##
#: text/chapter11.md:357
#, fuzzy, no-wrap
msgid "Monad Transformers"
msgstr "モナド変換子"

#. type: Plain text
#: text/chapter11.md:360
#, fuzzy
msgid ""
"Each of the three monads above: `State`, `Reader` and `Writer`, are also "
"examples of so-called _monad transformers_. The equivalent monad "
"transformers are called `StateT`, `ReaderT`, and `WriterT` respectively."
msgstr ""
"上の3つのモナド、 `State`、 `Reader`、 `Writer`は、いずれもいわゆる**モナド変"
"換子**(monad transformers)の例となっています。対応するモナド変換子はそれぞれ "
"`StateT`、 `ReaderT`、 `WriterT`と呼ばれています。"

#. type: Plain text
#: text/chapter11.md:362
#, fuzzy
msgid ""
"What is a monad transformer? Well, as we have seen, a monad augments "
"PureScript code with some type of side effect, which can be interpreted in "
"PureScript by using the appropriate handler (`runState`, `runReader`, "
"`runWriter`, etc.) This is fine if we only need to use _one_ side-effect. "
"However, it is often useful to use more than one side-effect at once. For "
"example, we might want to use `Reader` together with `Maybe` to express "
"_optional results_ in the context of some global configuration. Or we might "
"want the mutable state provided by the `State` monad together with the pure "
"error tracking capability of the `Either` monad. This is the problem solved "
"by _monad transformers_."
msgstr ""
"モナド変換子とは何でしょうか。さて、これまで見てきたように、モナドは"
"PureScriptで適切なハンドラ(`runState`、 `runReader`、 `runWriter`など)を使っ"
"て解釈される、いろいろな種類の副作用でPureScriptコードを拡張します。使用する"
"必要がある副作用が**ひとつだけ**なら、これで問題ありません。しかし、同時に複"
"数の副作用を使用できると便利なことがよくあります。例えば、 `Maybe`と `Reader`"
"を一緒に使用すると、ある大域的な設定の文脈で**省略可能な結果**を表現すること"
"ができます。もしくは、 `Either`モナドの純粋なエラー追跡機能と、 `State`モナド"
"が提供する変更可能な状態が同時に欲しくなるかもしれません。この問題を解決する"
"のが**モナド変換子**です。"

#. type: Plain text
#: text/chapter11.md:364
#, fuzzy
msgid ""
"Note that we have already seen that the `Effect` monad provides a partial "
"solution to this problem. Monad transformers provide another solution, and "
"each approach has its own benefits and limitations."
msgstr ""
"**拡張可能作用**の手法を使うとネイティブな作用を混在させることができるので、 "
"`Eff`モナドはこの問題に対する部分的な解決策を提供していることをすでに見てきた"
"ことに注意してください。モナド変換子はまた異なった解決策を提供しますが、これ"
"らの手法にはそれぞれ利点と限界があります。\n"

#. type: Plain text
#: text/chapter11.md:366
#, fuzzy
msgid ""
"A monad transformer is a type constructor which is parameterized not only by "
"a type, but by another type constructor. It takes one monad and turns it "
"into another monad, adding its own variety of side-effects."
msgstr ""
"モナド変換子は型だけでなく別の型構築子によってもパラメータ化される型構築子で"
"す。モナド変換子はモナドをひとつ取り、独自のいろいろな副作用を追加した別のモ"
"ナドへと変換します。"

#. type: Plain text
#: text/chapter11.md:368
#, fuzzy
msgid ""
"Let's see an example. The monad transformer version of the `State` monad is "
"`StateT`, defined in the `Control.Monad.State.Trans` module. We can find the "
"kind of `StateT` using PSCi:"
msgstr ""
"例を見てみましょう。 `Control.Monad.State.Trans`で定義された `StateT`は "
"`State`のモナド変換子版です。 `PSCi`を使って `StateT`の種を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:369
#, fuzzy, no-wrap
msgid ""
"> import Control.Monad.State.Trans\n"
"> :kind StateT\n"
"Type -> (Type -> Type) -> Type -> Type\n"
msgstr ""
"> import Control.Monad.State.Trans\n"
"> :kind StateT\n"
"Type -> (Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:376
#, fuzzy
msgid ""
"This looks quite confusing, but we can apply `StateT` one argument at a time "
"to understand how to use it."
msgstr ""
"とても読みにくそうに思うかもしれませんが、使い方を理解するために、 `StateT`に"
"ひとつ引数を与えてみましょう。"

#. type: Plain text
#: text/chapter11.md:378
#, fuzzy
msgid ""
"The first type argument is the type of the state we wish to use, as was the "
"case for `State`. Let's use a state of type `String`:"
msgstr ""
"`State`の場合、最初の型引数は使いたい状態の型です。それでは型 `String`を与え"
"てみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:379
#, fuzzy, no-wrap
msgid ""
"> :kind StateT String\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""
"> :kind StateT String\n"
"(Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:385
#, fuzzy, no-wrap
msgid "The next argument is a type constructor of kind `Type -> Type`. It represents the underlying monad, which we want to add the effects of `StateT` to. For the sake of an example, let's choose the `Either String` monad:\n"
msgstr "次の引数は種 `Type -> Type`の型構築子です。これは `StateT`の機能を追加したい元のモナドを表します。例として、 `Either String`モナドを選んでみます。\n"

#. type: Fenced code block (text)
#: text/chapter11.md:386
#, fuzzy, no-wrap
msgid ""
"> :kind StateT String (Either String)\n"
"Type -> Type\n"
msgstr ""
"> :kind StateT String (Either String)\n"
"Type -> Type\n"

#. type: Plain text
#: text/chapter11.md:392
#, fuzzy
msgid ""
"We are left with a type constructor. The final argument represents the "
"return type, and we might instantiate it to `Number` for example:"
msgstr ""
"型構築子が残りました。最後の引数は戻り値の型を表しており、たとえばそれを "
"`Number`にすることができます。"

#. type: Fenced code block (text)
#: text/chapter11.md:393
#, fuzzy, no-wrap
msgid ""
"> :kind StateT String (Either String) Number\n"
"Type\n"
msgstr ""
"> :kind StateT String (Either String) Number\n"
"Type\n"

#. type: Plain text
#: text/chapter11.md:399
#, fuzzy
msgid ""
"Finally we are left with something of kind `Type`, which means we can try to "
"find values of this type."
msgstr "最後に、種 `Type`の何かが残りましたが、この型の値を探してみましょう。"

#. type: Plain text
#: text/chapter11.md:401
#, fuzzy
msgid ""
"The monad we have constructed - `StateT String (Either String)` - represents "
"computations which can fail with an error, and which can use mutable state."
msgstr ""
"構築したモナド `StateT String (Either String)`は、エラーで失敗する可能性があ"
"り、変更可能な状態を使える計算を表しています。"

#. type: Plain text
#: text/chapter11.md:403
#, fuzzy
msgid ""
"We can use the actions of the outer `StateT String` monad (`get`, `put`, and "
"`modify`) directly, but in order to use the effects of the wrapped monad "
"(`Either String`), we need to \"lift\" them over the monad transformer. The "
"`Control.Monad.Trans` module defines the `MonadTrans` type class, which "
"captures those type constructors which are monad transformers, as follows:"
msgstr ""
"外側の `StateT String (Either String)`モナドのアクション(`get`、 `put`、 "
"`modify`)は直接使うことができますが、ラップされている内側のモナド(`Either "
"String`)の作用を使うためには、これらの関数をモナド変換子まで「持ち上げ」なく"
"てはいけません。 `Control.MonadTrans`モジュールでは、モナド変換子であるような"
"型構築子を捕捉する `MonadTrans`型クラスを次のように定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:404
#, fuzzy, no-wrap
msgid ""
"class MonadTrans t where\n"
"  lift :: forall m a. Monad m => m a -> t m a\n"
msgstr ""
"class MonadTrans t where\n"
"  lift :: forall m a. Monad m => m a -> t m a\n"

#. type: Plain text
#: text/chapter11.md:410
#, fuzzy
msgid ""
"This class contains a single member, `lift`, which takes computations in any "
"underlying monad `m` and lifts them into the wrapped monad `t m`. In our "
"case, the type constructor `t` is `StateT String`, and `m` is the `Either "
"String` monad, so `lift` provides a way to lift computations of type `Either "
"String a` to computations of type `StateT String (Either String) a`. This "
"means that we can use the effects of `StateT String` and `Either String` "
"side-by-side, as long as we use `lift` every time we use a computation of "
"type `Either String a`."
msgstr ""
"このクラスは、基礎となる任意のモナド `m`の計算をとり、それをラップされたモナ"
"ド `t m`へと持ち上げる、 `lift`というひとつの関数だけを持っています。今回の場"
"合、型構築子 `t`は `StateT String`で、 `m`は `Either String`モナドとなり、 "
"`lift`は型 `Either String a`の計算を、型 `State String (Either String) a`の計"
"算へと持ち上げる方法を提供することになります。これは、型 `Either String a`の"
"計算を使うときは、 `lift`を使えばいつでも作用 `StateT String`と `Either "
"String`を隣り合わせに使うことができることを意味します。"

#. type: Plain text
#: text/chapter11.md:412
#, fuzzy
msgid ""
"For example, the following computation reads the underlying state, and then "
"throws an error if the state is the empty string:"
msgstr ""
"たとえば、次の計算は `StateT`モナド変換子で導入されている状態を読み込み、状態"
"が空の文字列である場合はエラーを投げます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:413
#, fuzzy, no-wrap
msgid ""
"import Data.String (drop, take)\n"
"\n"
"split :: StateT String (Either String) String\n"
"split = do\n"
"  s <- get\n"
"  case s of\n"
"    \"\" -> lift $ Left \"Empty string\"\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""
"import Data.String (drop, take)\n"
"\n"
"split :: StateT String (Either String) String\n"
"split = do\n"
"  s <- get\n"
"  case s of\n"
"    \"\" -> lift $ Left \"Empty string\"\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"

#. type: Plain text
#: text/chapter11.md:427
#, fuzzy
msgid ""
"If the state is not empty, the computation uses `put` to update the state to "
"`drop 1 s` (that is, `s` with the first character removed), and returns "
"`take 1 s` (that is, the first character of `s`)."
msgstr ""
"状態が空でなければ、この計算は `put`を使って状態を `drop 1 s`(最初の文字を取"
"り除いた `s`)へと更新し、 `take 1 s`(`s`の最初の文字)を返します。"

#. type: Plain text
#: text/chapter11.md:429
#, fuzzy
msgid "Let's try this in PSCi:"
msgstr "それでは `PSCi`でこれを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter11.md:430
#, fuzzy, no-wrap
msgid ""
"> runStateT split \"test\"\n"
"Right (Tuple \"t\" \"est\")\n"
"\n"
"> runStateT split \"\"\n"
"Left \"Empty string\"\n"
msgstr ""
"> runStateT split \"test\"\n"
"Right (Tuple \"t\" \"est\")\n"
"\n"
"> runStateT split \"\"\n"
"Left \"Empty string\"\n"

#. type: Plain text
#: text/chapter11.md:439
#, fuzzy
msgid ""
"This is not very remarkable, since we could have implemented this without "
"`StateT`. However, since we are working in a monad, we can use do notation "
"or applicative combinators to build larger computations from smaller ones. "
"For example, we can apply `split` twice to read the first two characters "
"from a string:"
msgstr ""
"これは `StateT`を使わなくても実装できるので、さほど驚くようなことではありませ"
"ん。しかし、モナドとして扱っているので、do記法やApplicativeコンビネータを使っ"
"て、小さな計算から大きな計算を構築していくことができます。例えば、2回 `split`"
"を適用すると、文字列から最初の2文字を読むことができます。"

#. type: Fenced code block (text)
#: text/chapter11.md:440
#, fuzzy, no-wrap
msgid ""
"> runStateT ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple \"te\" \"st\"))\n"
msgstr ""
"> runStateT ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple \"te\" \"st\"))\n"

#. type: Plain text
#: text/chapter11.md:446
#, fuzzy
msgid ""
"We can use the `split` function with a handful of other actions to build a "
"basic parsing library. In fact, this is the approach taken by the `parsing` "
"library. This is the power of monad transformers - we can create custom-"
"built monads for a variety of problems, choosing the side-effects that we "
"need, and keeping the expressiveness of do notation and applicative "
"combinators."
msgstr ""
"他にもアクションを幾つか用意すれば、 `split`関数を使って、基本的な構文解析ラ"
"イブラリを構築することができます。これは実際に `purescript-parsing`ライブラリ"
"で採用されている手法です。これがモナド変換子の力なのです。必要な副作用を選択"
"して、do記法とApplicativeコンビネータで表現力を維持しながら、様々な問題のため"
"の特注のモナドを作成することができるのです。"

#. type: Title ##
#: text/chapter11.md:447
#, fuzzy, no-wrap
msgid "The ExceptT Monad Transformer"
msgstr "ExceptTモナド変換子"

#. type: Plain text
#: text/chapter11.md:450
#, fuzzy
msgid ""
"The `transformers` package also defines the `ExceptT e` monad transformer, "
"which is the transformer corresponding to the `Either e` monad. It provides "
"the following API:"
msgstr ""
"`purescript-transformers`パッケージでは、 `Either e`モナドに対応する変換子で"
"ある `ExceptT e`モナド変換子も定義されています。これは次のAPIを提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:451
#, fuzzy, no-wrap
msgid ""
"class MonadError e m where\n"
"  throwError :: forall a. e -> m a\n"
"  catchError :: forall a. m a -> (e -> m a) -> m a\n"
"\n"
"instance monadErrorExceptT :: Monad m => MonadError e (ExceptT e m)\n"
"\n"
"runExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\n"
msgstr ""
"class MonadError e m where\n"
"  throwError :: forall a. e -> m a\n"
"  catchError :: forall a. m a -> (e -> m a) -> m a\n"
"\n"
"instance monadErrorExceptT :: Monad m => MonadError e (ExceptT e m)\n"
"\n"
"runExceptT :: forall e m a. ExceptT e m a -> m (Either e a)\n"

#. type: Plain text
#: text/chapter11.md:462
#, fuzzy
msgid ""
"The `MonadError` class captures those monads which support throwing and "
"catching of errors of some type `e`, and an instance is provided for the "
"`ExceptT e` monad transformer. The `throwError` action can be used to "
"indicate failure, just like `Left` in the `Either e` monad. The `catchError` "
"action allows us to continue after an error is thrown using `throwError`."
msgstr ""
"`MonadError`クラスは `e`型のエラーのスローとキャッチをサポートするモナドを取"
"得し、 `ExceptT e`モナド変換子のインスタンスが提供されます。 `Either e`モナド"
"の `Left`と同じように、 `throwError`アクションは失敗を示すために使われます。 "
"`catchError`アクションを使うと、 `throwError`でエラーが投げられたあとでも処理"
"を継続することができるようになります。"

#. type: Plain text
#: text/chapter11.md:464
#, fuzzy
msgid ""
"The `runExceptT` handler is used to run a computation of type `ExceptT e m "
"a`."
msgstr ""
"`runExceptT`ハンドラを使うと、型 `ExceptT e m a`の計算を実行することができま"
"す。"

#. type: Plain text
#: text/chapter11.md:466
#, fuzzy
msgid ""
"This API is similar to that provided by the `exceptions` package and the "
"`Exception` effect. However, there are some important differences:"
msgstr ""
"このAPIは `purescript-exceptions`パッケージの `Exception`作用によって提供され"
"ているものと似ています。しかし、いくつかの重要な違いがあります。"

#. type: Plain text
#: text/chapter11.md:469
#, fuzzy
msgid ""
"- `Exception` uses actual JavaScript exceptions, whereas `ExceptT` models "
"errors as a pure data structure.  - The `Exception` effect only supports "
"exceptions of one type, namely JavaScript's `Error` type, whereas `ExceptT` "
"supports errors of any type. In particular, we are free to define new error "
"types."
msgstr ""
"- `ExceptT`モデルが代数的データ型を使っているのに対して、 `Exception`は実際の"
"JavaScriptの例外を使っています。 - `ExceptT`が `Error`型クラスのどんな型のエ"
"ラーでも扱うのに対して、 `Exception`作用はJavaScriptの `Error`型というひとつ"
"例外の型だけを扱います。つまり、 `ExceptT`では新たなエラー型を自由に定義でき"
"ます。"

#. type: Plain text
#: text/chapter11.md:471
#, fuzzy
msgid ""
"Let's try out `ExceptT` by using it to wrap the `Writer` monad. Again, we "
"are free to use actions from the monad transformer `ExceptT e` directly, but "
"computations in the `Writer` monad should be lifted using `lift`:"
msgstr ""
"試しに `ExceptT`を使って `Writer`モナドを包んでみましょう。ここでもモナド変換"
"子 `ExceptT e`のアクションは自由に使えますが、 `Writer`モナドの計算は `lift`"
"を使って持ちあげなければなりません。　　"

#. type: Fenced code block (haskell)
#: text/chapter11.md:472
#, fuzzy, no-wrap
msgid ""
"import Control.Monad.Except\n"
"import Control.Monad.Writer\n"
"\n"
"writerAndExceptT :: ExceptT String (Writer (Array String)) String\n"
"writerAndExceptT = do\n"
"  lift $ tell [\"Before the error\"]\n"
"  _ <- throwError \"Error!\"\n"
"  lift $ tell [\"After the error\"]\n"
"  pure \"Return value\"\n"
msgstr ""
"import Control.Monad.Trans\n"
"import Control.Monad.Writer\n"
"import Control.Monad.Writer.Class\n"
"import Control.Monad.Error.Class\n"
"import Control.Monad.Except.Trans\n"
"\n"
"writerAndExceptT :: ExceptT String (Writer (Array String)) String\n"
"writerAndExceptT = do\n"
"  lift $ tell [\"Before the error\"]\n"
"  throwError \"Error!\"\n"
"  lift $ tell [\"After the error\"]\n"
"  pure \"Return value\"\n"

#. type: Plain text
#: text/chapter11.md:485
#, fuzzy
msgid ""
"If we test this function in PSCi, we can see how the two effects of "
"accumulating a log and throwing an error interact. First, we can run the "
"outer `ExceptT` computation of type by using `runExceptT`, leaving a result "
"of type `Writer (Array String) (Either String String)`. We can then use "
"`runWriter` to run the inner `Writer` computation:"
msgstr ""
"`PSCi`でこの関数を試すと、ログの蓄積とエラーの送出という２つの作用がどのよう"
"に相互作用しているのかを見ることができます。まず、 `runExceptT`を使って外側"
"の `ExceptT`計算を実行し、型 `Write String (Either String String)`の結果を残"
"します。それから、 `runWriter`で内側の `Writer`計算を実行します。"

#. type: Fenced code block (text)
#: text/chapter11.md:486
#, fuzzy, no-wrap
msgid ""
"> runWriter $ runExceptT writerAndExceptT\n"
"Tuple (Left \"Error!\") [\"Before the error\"]\n"
msgstr ""
"> runWriter $ runExceptT writerAndExceptT\n"
"Tuple (Left \"Error!\") [\"Before the error\"]\n"

#. type: Plain text
#: text/chapter11.md:492
#, fuzzy
msgid ""
"Note that only those log messages which were written before the error was "
"thrown actually get appended to the log."
msgstr ""
"実際に追加されるログは、エラーが投げられる前に書かれたログメッセージだけであ"
"ることにも注目してください。"

#. type: Title ##
#: text/chapter11.md:493
#, fuzzy, no-wrap
msgid "Monad Transformer Stacks"
msgstr "モナド変換子スタック"

#. type: Plain text
#: text/chapter11.md:496
#, fuzzy
msgid ""
"As we have seen, monad transformers can be used to build new monads on top "
"of existing monads. For some monad transformer `t1` and some monad `m`, the "
"application `t1 m` is also a monad. That means that we can apply a _second_ "
"monad transformer `t2` to the result `t1 m` to construct a third monad `t2 "
"(t1 m)`. In this way, we can construct a _stack_ of monad transformers, "
"which combine the side-effects provided by their constituent monads."
msgstr ""
"これまで見てきたように、モナド変換子を使うと既存のモナドの上に新しいモナドを"
"構築することができます。任意のモナド変換子 `t1`と任意のモナド `m`について、そ"
"の適用 `t1 m`もまたモナドになります。これは**ふたつめの**モナド変換子 `t2`を"
"先ほどの結果 `t1 m`に適用すると、第３のモナド `t2 (t1 m)`を作れることを意味し"
"ています。このように、構成するモナドによって提供された副作用を組み合わせる、"
"モナド変換子の**スタック**を構築することができます。"

#. type: Plain text
#: text/chapter11.md:498
#, fuzzy
msgid ""
"In practice, the underlying monad `m` is either the `Effect` monad, if "
"native side-effects are required, or the `Identity` monad, defined in the "
"`Data.Identity` module. The `Identity` monad adds no new side-effects, so "
"transforming the `Identity` monad only provides the effects of the monad "
"transformer. In fact, the `State`, `Reader` and `Writer` monads are "
"implemented by transforming the `Identity` monad with `StateT`, `ReaderT` "
"and `WriterT` respectively."
msgstr ""
"実際には、基本となるモナド `m`は、ネイティブの副作用が必要なら `Eff`モナド、"
"さもなくば `Control.Monad.Identity`モジュールで定義されている `Identity`モナ"
"ドになります。 `Identity`モナドは何の新しい副作用も追加しませんから、 "
"`Identity`モナドの変換は、モナド変換子の作用だけを提供します。実際に、 "
"`State`モナド、 `Reader`モナド、 `Writer`モナドは、 `Identity`モナドをそれぞ"
"れ `StateT`、 `ReaderT`、 `WriterT`で変換することによって実装されています。"

#. type: Plain text
#: text/chapter11.md:500
#, fuzzy
msgid ""
"Let's see an example in which three side effects are combined. We will use "
"the `StateT`, `WriterT` and `ExceptT` effects, with the `Identity` monad on "
"the bottom of the stack. This monad transformer stack will provide the side "
"effects of mutable state, accumulating a log, and pure errors."
msgstr ""
"それでは3つの副作用が組み合わされている例を見てみましょう。 `Identity`モナド"
"をスタックの底にして、 `StateT`作用、 `WriterT`作用、 `ExceptT`作用を使いま"
"す。このモナド変換子スタックは、ログの蓄積し、純粋なエラー、可変状態の副作用"
"を提供します。"

#. type: Plain text
#: text/chapter11.md:502
#, fuzzy
msgid ""
"We can use this monad transformer stack to reproduce our `split` action with "
"the added feature of logging."
msgstr ""
"このモナド変換子スタックを使うと、ロギングの機能が追加された `split`アクショ"
"ンを作ることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:503
#, fuzzy, no-wrap
msgid ""
"type Errors = Array String\n"
"\n"
"type Log = Array String\n"
"\n"
"type Parser = StateT String (WriterT Log (ExceptT Errors Identity))\n"
"\n"
"split :: Parser String\n"
"split = do\n"
"  s <- get\n"
"  lift $ tell [\"The state is \" <> s]\n"
"  case s of\n"
"    \"\" -> lift $ lift $ throwError [\"Empty string\"]\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"
msgstr ""
"type Errors = Array String\n"
"\n"
"type Log = Array String\n"
"\n"
"type Parser = StateT String (WriterT Log (ExceptT Errors Identity))\n"
"\n"
"split :: Parser String\n"
"split = do\n"
"  s <- get\n"
"  lift $ tell [\"The state is \" <> show s]\n"
"  case s of\n"
"    \"\" -> lift $ lift $ throwError [\"Empty string\"]\n"
"    _ -> do\n"
"      put (drop 1 s)\n"
"      pure (take 1 s)\n"

#. type: Plain text
#: text/chapter11.md:522
#, fuzzy
msgid ""
"If we test this computation in PSCi, we see that the state is appended to "
"the log for every invocation of `split`."
msgstr ""
"この計算を `PSCi`で試してみると、 `split`が実行されるたびに状態がログに追加さ"
"れることがわかります。"

#. type: Plain text
#: text/chapter11.md:524
#, fuzzy
msgid ""
"Note that we have to remove the side-effects in the order in which they "
"appear in the monad transformer stack: first we use `runStateT` to remove "
"the `StateT` type constructor, then `runWriterT`, then `runExceptT`. "
"Finally, we run the computation in the `Identity` monad by using `unwrap`."
msgstr ""
"モナド変換子スタックに現れる順序に従って、副作用を取り除いていかなければなら"
"ないことに注意してください。最初に `StateT`型構築子を取り除くために "
"`runStateT`を使い、それから `runtWriteT`を使い、その後 `runExceptT`を使いま"
"す。最後に `runIdentity`を使用して `Identity`モナドの演算を実行します。"

#. type: Fenced code block (text)
#: text/chapter11.md:525
#, fuzzy, no-wrap
msgid ""
"> runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s\n"
"\n"
"> runParser split \"test\"\n"
"(Right (Tuple (Tuple \"t\" \"est\") [\"The state is test\"]))\n"
"\n"
"> runParser ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple (Tuple \"te\" \"st\") [\"The state is test\", \"The state is est\"]))\n"
msgstr ""
"> runParser p s = runIdentity $ runExceptT $ runWriterT $ runStateT p s\n"
"\n"
"> runParser split \"test\"\n"
"(Right (Tuple (Tuple \"t\" \"est\") [\"The state is test\"]))\n"
"\n"
"> runParser ((<>) <$> split <*> split) \"test\"\n"
"(Right (Tuple (Tuple \"te\" \"st\") [\"The state is test\", \"The state is est\"]))\n"

#. type: Plain text
#: text/chapter11.md:536
#, fuzzy
msgid ""
"However, if the parse is unsuccessful because the state is empty, then no "
"log is printed at all:"
msgstr ""
"しかしながら解析が失敗した場合は、状態が空であるためログはまったく出力されま"
"せん。"

#. type: Fenced code block (text)
#: text/chapter11.md:537
#, fuzzy, no-wrap
msgid ""
"> runParser split \"\"\n"
"(Left [\"Empty string\"])\n"
msgstr ""
"> runParser split \"\"\n"
"(Left [\"Empty string\"])\n"

#. type: Plain text
#: text/chapter11.md:543
#, fuzzy
msgid ""
"This is because of the way in which the side-effects provided by the "
"`ExceptT` monad transformer interact with the side-effects provided by the "
"`WriterT` monad transformer. We can address this by changing the order in "
"which the monad transformer stack is composed. If we move the `ExceptT` "
"transformer to the top of the stack, then the log will contain all messages "
"written up until the first error, as we saw earlier when we transformed "
"`Writer` with `ExceptT`."
msgstr ""
"これは、 `ExceptT`モナド変換子が提供する副作用が、 `WriterT`モナド変換子が提"
"供する副作用に影響を受けるためです。これはモナド変換子スタックが構成されてい"
"る順序を変更することで解決することができます。スタックの最上部に `ExceptT`変"
"換子を移動すると、先ほど `Writer`を `ExceptT`に変換したときと同じように、最初"
"のエラーまでに書かれたすべてのメッセージが含まれるようになります。"

#. type: Plain text
#: text/chapter11.md:545
#, fuzzy
msgid ""
"One problem with this code is that we have to use the `lift` function "
"multiple times to lift computations over multiple monad transformers: for "
"example, the call to `throwError` has to be lifted twice, once over "
"`WriterT` and a second time over `StateT`. This is fine for small monad "
"transformer stacks, but quickly becomes inconvenient."
msgstr ""
"このコードの問題のひとつは、複数のモナド変換子の上まで計算を持ち上げるため"
"に、 `lift`関数を複数回使わなければならないということです。たとえば、 "
"`throwError`の呼び出しは、1回目は `WriteT`へ、2回目は `StateT`へと、2回持ちあ"
"げなければなりません。小さなモナド変換子スタックならなんとかなりますが、その"
"うち不便だと感じるようになるでしょう。"

#. type: Plain text
#: text/chapter11.md:547
#, fuzzy
msgid ""
"Fortunately, as we will see, we can use the automatic code generation "
"provided by type class inference to do most of this \"heavy lifting\" for us."
msgstr ""
"幸いなことに、これから見るような型クラス推論によって提供されるコードの自動生"
"成を使うと、ほとんどの「多段持ち上げ」を行うことができます。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:552
#, fuzzy
msgid ""
"(Easy) Use the `ExceptT` monad transformer over the `Identity` functor to "
"write a function `safeDivide` which divides two numbers, throwing an error "
"(as the String \"Divide by zero!\") if the denominator is zero."
msgstr ""
"(簡単)　`Identity`関手の上の `ExceptT`モナド変換子を使って、分母がゼロの場合"
"はエラーを投​​げる、2つの数の商を求める関数 `safeDivide`を書いてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:552
#, fuzzy
msgid "(Medium) Write a parser"
msgstr "(やや難しい) 次のような構文解析関数を書いてください。"

#. type: Plain text
#: text/chapter11.md:556
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     string :: String -> Parser String\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    string :: String -> Parser String\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:558
#, fuzzy, no-wrap
msgid "     which matches a string as a prefix of the current state, or fails with an error message.\n"
msgstr "    これは現在の状態が接頭辞に適合するか、エラーメッセージとともに失敗します。\n"

#. type: Plain text
#: text/chapter11.md:560
#, fuzzy, no-wrap
msgid "     Your parser should work as follows:\n"
msgstr "    この構文解析器は次のように動作しなくてはなりません。\n"

#. type: Plain text
#: text/chapter11.md:565
#, fuzzy, no-wrap
msgid ""
"     ```text\n"
"     > runParser (string \"abc\") \"abcdef\"\n"
"     (Right (Tuple (Tuple \"abc\" \"def\") [\"The state is abcdef\"]))\n"
"     ```\n"
msgstr ""
"    ```text\n"
"    > runParser (string \"abc\") \"abcdef\"\n"
"    (Right (Tuple (Tuple \"abc\" \"def\") [\"The state is abcdef\"]))\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:568
#, fuzzy, no-wrap
msgid ""
"     _Hint_: you can use the implementation of `split` as a starting point. You might find the `stripPrefix` function useful.\n"
" 1. (Difficult) Use the `ReaderT` and `WriterT` monad transformers to reimplement the document printing library which we wrote earlier using the `Reader` monad.\n"
msgstr ""
"    **ヒント**：出発点として `split`の実装を使うといいでしょう。`stripPrefix`関数も役に立ちます。\n"
"1. (難しい) 以前 `Reader`モナドを使用して書いた文書出力ライブラリを、 `ReaderT`と `WriterT`モナド変換子を使用して再実装してください。\n"

#. type: Plain text
#: text/chapter11.md:570
#, fuzzy, no-wrap
msgid "     Instead of using `line` to emit strings and `cat` to concatenate strings, use the `Array String` monoid with the `WriterT` monad transformer, and `tell` to append a line to the result. Use the same names as in the original implementation but ending with an apostrophe (`'`).\n"
msgstr "    文字列を出力する `line`や文字列を連結する `cat`を使うのではなく、 `WriteT`モナド変換子と一緒に `Array String`モノイドを使い、結果へ行を追加するのに `tell`を使ってください。\n"

#. type: Title ##
#: text/chapter11.md:571
#, fuzzy, no-wrap
msgid "Type Classes to the Rescue!"
msgstr "救済のための型クラス"

#. type: Plain text
#: text/chapter11.md:574
#, fuzzy
msgid ""
"When we looked at the `State` monad at the start of this chapter, I gave the "
"following types for the actions of the `State` monad:"
msgstr ""
"章の最初で扱った `State`モナドを見てみると、 `State`モナドのアクションには次"
"のような型が与えられていました。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:575
#, fuzzy, no-wrap
msgid ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"
msgstr ""
"get    :: forall s.             State s s\n"
"put    :: forall s. s        -> State s Unit\n"
"modify :: forall s. (s -> s) -> State s Unit\n"

#. type: Plain text
#: text/chapter11.md:582
#, fuzzy
msgid ""
"In reality, the types given in the `Control.Monad.State.Class` module are "
"more general than this:"
msgstr ""
"`Control.Monad.State.Class`モジュールで与えられている型は、実際には次のように"
"もっと一般的です。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:583
#, fuzzy, no-wrap
msgid ""
"get    :: forall m s. MonadState s m =>             m s\n"
"put    :: forall m s. MonadState s m => s        -> m Unit\n"
"modify :: forall m s. MonadState s m => (s -> s) -> m Unit\n"
msgstr ""
"get    :: forall m s. MonadState s m =>             m s\n"
"put    :: forall m s. MonadState s m => s        -> m Unit\n"
"modify :: forall m s. MonadState s m => (s -> s) -> m Unit\n"

#. type: Plain text
#: text/chapter11.md:590
#, fuzzy
msgid ""
"The `Control.Monad.State.Class` module defines the `MonadState` (multi-"
"parameter) type class, which allows us to abstract over \"monads which "
"support pure mutable state\". As one would expect, the `State s` type "
"constructor is an instance of the `MonadState s` type class, but there are "
"many more interesting instances of this class."
msgstr ""
"`Control.Monad.State.Class`モジュールには「純粋な変更可能な状態を提供するモナ"
"ド」への抽象化を可能にする `MonadState`(多変数)型クラスが定義されています。予"
"想できると思いますが、 `State s`型構築子は `MonadState s`型クラスのインスタン"
"スになっており、このクラスには他にも興味深いインスタンスが数多くあります。"

#. type: Plain text
#: text/chapter11.md:592
#, fuzzy
msgid ""
"In particular, there are instances of `MonadState` for the `WriterT`, "
"`ReaderT` and `ExceptT` monad transformers, provided in the `transformers` "
"package. Each of these monad transformers has an instance for `MonadState` "
"whenever the underlying `Monad` does. In practice, this means that as long "
"as `StateT` appears _somewhere_ in the monad transformer stack, and "
"everything above `StateT` is an instance of `MonadState`, then we are free "
"to use `get`, `put` and `modify` directly, without the need to use `lift`."
msgstr ""
"特に、 `purescript-transformers`パッケージではモナド変換子 `WriterT`、 "
"`ReaderT`、 `ExceptT`についての `MonadState`のインスタンスが提供されていま"
"す。実際に、 `StateT`がモナド変換子スタックのどこかに現れ、 `StateT`より上の"
"すべてが `MonadState`のインスタンスであれば、 `get`、 `put`、 `modify`を直接"
"自由に使用することができます。"

#. type: Plain text
#: text/chapter11.md:594
#, fuzzy
msgid ""
"Indeed, the same is true of the actions we covered for the `ReaderT`, "
"`WriterT`, and `ExceptT` transformers. `transformers` defines a type class "
"for each of the major transformers, allowing us to abstract over monads "
"which support their operations."
msgstr ""
"実は、これまで扱ってきた `ReaderT`、 `WriterT`、 `ExceptT`変換子についても、"
"同じことが成り立っています。 `purescript-transformers`では、それらの操作をサ"
"ポートするモナドの上に抽象化することを可能にする、主な変換子それぞれについて"
"の型クラスが定義されています。"

#. type: Plain text
#: text/chapter11.md:596
#, fuzzy
msgid ""
"In the case of the `split` function above, the monad stack we constructed is "
"an instance of each of the `MonadState`, `MonadWriter` and `MonadError` type "
"classes. This means that we don't need to call `lift` at all! We can just "
"use the actions `get`, `put`, `tell` and `throwError` as if they were "
"defined on the monad stack itself:"
msgstr ""
"上の `split`関数の場合、構築されたこのモナドスタックは型クラス "
"`MonadState`、 `MonadWriter`、 `MonadError`それぞれのインスタンスです。これは"
"つまり、 `lift`をまったく呼び出す必要がないことを意味します！まるでモナドス"
"タック自体に定義されていたかのように、アクション `get`、 `put`、 `tell`、 "
"`throwError`をそのまま使用することができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:597
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:split}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:602
#, fuzzy
msgid ""
"This computation really looks like we have extended our programming language "
"to support the three new side-effects of mutable state, logging and error "
"handling. However, everything is still implemented using pure functions and "
"immutable data under the hood."
msgstr ""
"この計算はまるで、可変状態、ロギング、エラー処理という３つの副作用に対応し"
"た、独自のプログラミング言語を拡張したかのようにみえます。しかしながら、内部"
"的にはすべてはあくまで純粋な関数と普通のデータを使って実装されているのです。"

#. type: Title ##
#: text/chapter11.md:603
#, fuzzy, no-wrap
msgid "Alternatives"
msgstr "Alternative型クラス"

#. type: Plain text
#: text/chapter11.md:606
#, fuzzy
msgid ""
"The `control` package defines a number of abstractions for working with "
"computations which can fail. One of these is the `Alternative` type class:"
msgstr ""
"`purescript-control`パッケージでは失敗しうる計算を操作するための抽象化がいく"
"つか定義されています。そのひとつは `Alternative`型クラスです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:607
#, fuzzy, no-wrap
msgid ""
"class Functor f <= Alt f where\n"
"  alt :: forall a. f a -> f a -> f a\n"
"\n"
"class Alt f <= Plus f where\n"
"  empty :: forall a. f a\n"
"\n"
"class (Applicative f, Plus f) <= Alternative f\n"
msgstr ""
"class Functor f <= Alt f where\n"
"  alt :: forall a. f a -> f a -> f a\n"
"\n"
"class Alt f <= Plus f where\n"
"  empty :: forall a. f a\n"
"\n"
"class (Applicative f, Plus f) <= Alternative f\n"

#. type: Plain text
#: text/chapter11.md:618
#, fuzzy, no-wrap
msgid "`Alternative` provides two new combinators: the `empty` value, which provides a prototype for a failing computation, and the `alt` function (and its alias, `<|>`) which provides the ability to fall back to an _alternative_ computation in the case of an error.\n"
msgstr ""
"`Alternative`は、失敗しうる計算のプロトタイプを提供する `empty`値、\n"
"エラーが起きたときに**代替**(Alternative)計算へ戻ってやり直す機能を提供する `<|>`演算子 という、2つの新しいコンビネータを提供しています。\n"

#. type: Plain text
#: text/chapter11.md:620
#, fuzzy
msgid ""
"The `Data.Array` module provides two useful functions for working with type "
"constructors in the `Alternative` type class:"
msgstr ""
"`Data.List`モジュールでは `Alternative`型クラスで型構築子を操作する2つの便利"
"な関数を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:621
#, fuzzy, no-wrap
msgid ""
"many :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
"some :: forall f a. Alternative f => Lazy (f (Array a)) => f a -> f (Array a)\n"
msgstr ""
"many :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\n"
"some :: forall f a. Alternative f => Lazy (f (List a)) => f a -> f (List a)\n"

#. type: Plain text
#: text/chapter11.md:627
msgid "There is also an equivalent `many` and `some` for `Data.List`"
msgstr ""

#. type: Plain text
#: text/chapter11.md:629
#, fuzzy
msgid ""
"The `many` combinator uses the `Alternative` type class to repeatedly run a "
"computation _zero-or-more_ times. The `some` combinator is similar, but "
"requires at least the first computation to succeed."
msgstr ""
"`many`コンビネータは計算を**ゼロ回以上**繰り返し実行するために `Alternative`"
"型クラスを使用しています。 `some`コンビネータも似ていますが、成功するために少"
"なくとも１回の計算を必要とします。"

#. type: Plain text
#: text/chapter11.md:631
#, fuzzy
msgid ""
"In the case of our `Parser` monad transformer stack, there is an instance of "
"`Alternative` induced by the `ExceptT` component, which supports failure by "
"composing errors in different branches using a `Monoid` instance (this is "
"why we chose `Array String` for our `Errors` type). This means that we can "
"use the `many` and `some` functions to run a parser multiple times:"
msgstr ""
"今回の `Parser`モナド変換子スタックの場合は、 `ExceptT`コンポーネントから導か"
"れた、明らかな方法で失敗をサポートする、 `Alternative`のインスタンスが存在し"
"ます。これは、構文解析器を複数回実行するために `many`関数と `some`関数を使う"
"ことができることを意味します。"

#. type: Fenced code block (text)
#: text/chapter11.md:632
#, fuzzy, no-wrap
msgid ""
"> import Data.Array (many)\n"
"\n"
"> runParser (many split) \"test\"\n"
"(Right (Tuple (Tuple [\"t\", \"e\", \"s\", \"t\"] \"\")\n"
"              [ \"The state is \\\"test\\\"\"\n"
"              , \"The state is \\\"est\\\"\"\n"
"              , \"The state is \\\"st\\\"\"\n"
"              , \"The state is \\\"t\\\"\"\n"
"              ]))\n"
msgstr ""
"> import Split\n"
"> import Control.Alternative\n"
"\n"
"> runParser (many split) \"test\"\n"
"(Right (Tuple (Tuple [\"t\", \"e\", \"s\", \"t\"] \"\")\n"
"              [ \"The state is \\\"test\\\"\"\n"
"              , \"The state is \\\"est\\\"\"\n"
"              , \"The state is \\\"st\\\"\"\n"
"              , \"The state is \\\"t\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:645
#, fuzzy
msgid ""
"Here, the input string `\"test\"` has been repeatedly split to return an "
"array of four single-character strings, the leftover state is empty, and the "
"log shows that we applied the `split` combinator four times."
msgstr ""
"ここで、入力文字列 `\"test\"`は、１文字の文字列４つの配列を返すように、繰り返"
"し分割されています。残った状態は空文字列で、ログは `split`コンビネータが４回"
"適用されたことを示しています。"

#. type: Title ##
#: text/chapter11.md:646
#, fuzzy, no-wrap
msgid "Monad Comprehensions"
msgstr "モナド内包表記"

#. type: Plain text
#: text/chapter11.md:649
#, fuzzy
msgid ""
"The `Control.MonadPlus` module defines a subclass of the `Alternative` type "
"class, called `MonadPlus`. `MonadPlus` captures those type constructors "
"which are both monads and instances of `Alternative`:"
msgstr ""
"`Control.MonadPlus`モジュールには `MonadPlus`と呼ばれる `Alternative`型クラス"
"の若干の変形が定義されています。 `MonadPlus`はモナドと `Alternative`のインス"
"タンスの両方である型構築子を補足します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:650
#, fuzzy, no-wrap
msgid "class (Monad m, Alternative m) <= MonadPlus m\n"
msgstr ""
"class (Monad m, Alternative m) <= MonadZero m\n"
"\n"
"class MonadZero m <= MonadPlus m\n"

#. type: Plain text
#: text/chapter11.md:655
#, fuzzy
msgid "In particular, our `Parser` monad is an instance of `MonadPlus`."
msgstr "実際、 `Parser`モナドは `MonadPlus`のインスタンスです。"

#. type: Plain text
#: text/chapter11.md:657
#, fuzzy
msgid ""
"When we covered array comprehensions earlier in the book, we introduced the "
"`guard` function, which could be used to filter out unwanted results. In "
"fact, the `guard` function is more general, and can be used for any monad "
"which is an instance of `MonadPlus`:"
msgstr ""
"以前に本書中で配列内包表記を扱ったとき、不要な結果をフィルタリングするため使"
"われる `guard`関数を導入しました。実際は `guard`関数はもっと一般的で、 "
"`MonadPlus`のインスタンスであるすべてのモナドに対して使うことができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:658
#, fuzzy, no-wrap
msgid "guard :: forall m. Alternative m => Boolean -> m Unit\n"
msgstr "guard :: forall m. MonadZero m => Boolean -> m Unit\n"

#. type: Plain text
#: text/chapter11.md:663
#, fuzzy, no-wrap
msgid "The `<|>` operator allows us to backtrack in case of failure. To see how this is useful, let's define a variant of the `split` combinator which only matches upper case characters:\n"
msgstr "`<|>`演算子は失敗時のバックトラッキングをできるようにします。これがどのように役立つかを見るために、大文字だけに適合する `split`コンビネータの亜種を定義してみましょう。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:664
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:upper}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:669
#, fuzzy
msgid ""
"Here, we use a `guard` to fail if the string is not upper case. Note that "
"this code looks very similar to the array comprehensions we saw earlier - "
"using `MonadPlus` in this way, we sometimes refer to constructing _monad "
"comprehensions_."
msgstr ""
"ここで、文字列が大文字でない場合に失敗するよう `guard`を使用しています。この"
"コードは前に見た配列内包表記とよく似ていることに注目してください。このように "
"`MonadPlus`が使われており**モナド内包表記**(monad comprehensions)を構築するた"
"めに参照することがあります。"

#. type: Title ##
#: text/chapter11.md:670
#, fuzzy, no-wrap
msgid "Backtracking"
msgstr "バックトラッキング"

#. type: Plain text
#: text/chapter11.md:673
#, fuzzy, no-wrap
msgid "We can use the `<|>` operator to backtrack to another alternative in case of failure. To demonstrate this, let's define one more parser, which matches lower case characters:\n"
msgstr "`<|>`演算子を使うと、失敗したときに別の代替計算へとバックトラックすることができます。これを確かめるために、小文字に一致するもう一つの構文解析器を定義してみましょう。\n"

#. type: Fenced code block (haskell)
#: text/chapter11.md:674
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Split.purs:lower}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:679
#, fuzzy
msgid ""
"With this, we can define a parser which eagerly matches many upper case "
"characters if the first character is upper case, or many lower case "
"character if the first character is lower case:"
msgstr ""
"これにより、まずもし最初の文字が大文字なら複数の大文字に適合し、さもなくばも"
"し最初の文字が小文字なら複数の小文字に適合する、という構文解析器を定義するこ"
"とができます。"

#. type: Fenced code block (text)
#: text/chapter11.md:680
#, fuzzy, no-wrap
msgid "> upperOrLower = some upper <|> some lower\n"
msgstr "> upperOrLower = some upper <|> some lower\n"

#. type: Plain text
#: text/chapter11.md:685
#, fuzzy
msgid "This parser will match characters until the case changes:"
msgstr ""
"この構文解析器は、大文字と小文字が切り替わるまで、文字に適合し続けます。"

#. type: Fenced code block (text)
#: text/chapter11.md:686
#, fuzzy, no-wrap
msgid ""
"> runParser upperOrLower \"abcDEF\"\n"
"(Right (Tuple (Tuple [\"a\",\"b\",\"c\"] (\"DEF\"))\n"
"              [ \"The state is \\\"abcDEF\\\"\"\n"
"              , \"The state is \\\"bcDEF\\\"\"\n"
"              , \"The state is \\\"cDEF\\\"\"\n"
"              ]))\n"
msgstr ""
"> runParser upperOrLower \"abcDEF\"\n"
"(Right (Tuple (Tuple [\"a\",\"b\",\"c\"] (\"DEF\"))\n"
"              [ \"The state is \\\"abcDEF\\\"\"\n"
"              , \"The state is \\\"bcDEF\\\"\"\n"
"              , \"The state is \\\"cDEF\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:696
#, fuzzy
msgid ""
"We can even use `many` to fully split a string into its lower and upper case "
"components:"
msgstr ""
"`many`を使うと、文字列を小文字と大文字の要素に完全に分割することもできます。"

#. type: Fenced code block (text)
#: text/chapter11.md:697
#, fuzzy, no-wrap
msgid ""
"> components = many upperOrLower\n"
"\n"
"> runParser components \"abCDeFgh\"\n"
"(Right (Tuple (Tuple [[\"a\",\"b\"],[\"C\",\"D\"],[\"e\"],[\"F\"],[\"g\",\"h\"]] \"\")\n"
"              [ \"The state is \\\"abCDeFgh\\\"\"\n"
"              , \"The state is \\\"bCDeFgh\\\"\"\n"
"              , \"The state is \\\"CDeFgh\\\"\"\n"
"              , \"The state is \\\"DeFgh\\\"\"\n"
"              , \"The state is \\\"eFgh\\\"\"\n"
"              , \"The state is \\\"Fgh\\\"\"\n"
"              , \"The state is \\\"gh\\\"\"\n"
"              , \"The state is \\\"h\\\"\"\n"
"              ]))\n"
msgstr ""
"> components = many upperOrLower\n"
"\n"
"> runParser components \"abCDeFgh\"\n"
"(Right (Tuple (Tuple [[\"a\",\"b\"],[\"C\",\"D\"],[\"e\"],[\"F\"],[\"g\",\"h\"]] \"\")\n"
"              [ \"The state is \\\"abCDeFgh\\\"\"\n"
"              , \"The state is \\\"bCDeFgh\\\"\"\n"
"              , \"The state is \\\"CDeFgh\\\"\"\n"
"              , \"The state is \\\"DeFgh\\\"\"\n"
"              , \"The state is \\\"eFgh\\\"\"\n"
"              , \"The state is \\\"Fgh\\\"\"\n"
"              , \"The state is \\\"gh\\\"\"\n"
"              , \"The state is \\\"h\\\"\"\n"
"              ]))\n"

#. type: Plain text
#: text/chapter11.md:714
#, fuzzy
msgid ""
"Again, this illustrates the power of reusability that monad transformers "
"bring - we were able to write a backtracking parser in a declarative style "
"with only a few lines of code, by reusing standard abstractions!"
msgstr ""
"繰り返しになりますが、これはモナド変換子がもたらす再利用性の威力を示していま"
"す。標準的な抽象化を再利用することで、バックトラック構文解析器を宣言型のスタ"
"イルでわずか数行のコードで書くことができました！"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
#, fuzzy
msgid ""
"(Easy) Remove the calls to the `lift` function from your implementation of "
"the `string` parser. Verify that the new implementation type checks, and "
"convince yourself that it should."
msgstr ""
"(簡単)`string`構文解析器の実装から `lift`関数の呼び出しを取り除いてください。"
"新しい実装の型が整合していることを確認し、なぜそのようになるのかをよく納得し"
"ておきましょう。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
#, fuzzy
msgid ""
"(Medium) Use your `string` parser with the `some` combinator to write a "
"parser `asFollowedByBs` which recognizes strings consisting of several "
"copies of the string `\"a\"` followed by several copies of the string `\"b"
"\"`."
msgstr ""
"(やや難しい)`string`構文解析器と `many`コンビネータを使って、文字列 `\"a\"`の"
"連続と、それに続く文字列 `\"b\"`の連続からなる文字列を認識する構文解析器を書"
"いてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
#, fuzzy
msgid ""
"(Medium) Use the `<|>` operator to write a parser `asOrBs` which recognizes "
"strings of the letters `a` or `b` in any order."
msgstr ""
"(やや難しい)`<|>`演算子を使って、文字 `a`と文字 `b`が任意の順序で現れるような"
"文字列を認識する構文解析器を書いてください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:721
#, fuzzy
msgid "(Difficult) The `Parser` monad might also be defined as follows:"
msgstr "(難しい)`Parser`モナドは次のように定義されるかもしれません。"

#. type: Plain text
#: text/chapter11.md:725
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     type Parser = ExceptT Errors (StateT String (WriterT Log Identity))\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    type Parser = ExceptT Errors (StateT String (WriterT Log Identity))\n"
"    ```\n"

#. type: Plain text
#: text/chapter11.md:727
#, fuzzy, no-wrap
msgid "     What effect does this change have on our parsing functions?\n"
msgstr "    このように変更すると、構文解析関数にどのような影響を与えるでしょうか。\n"

#. type: Title ##
#: text/chapter11.md:728
#, fuzzy, no-wrap
msgid "The RWS Monad"
msgstr "RWSモナド"

#. type: Plain text
#: text/chapter11.md:731
#, fuzzy
msgid ""
"One particular combination of monad transformers is so common that it is "
"provided as a single monad transformer in the `transformers` package. The "
"`Reader`, `Writer` and `State` monads are combined into the _reader-writer-"
"state_ monad, or more simply the `RWS` monad. This monad has a corresponding "
"monad transformer called the `RWST` monad transformer."
msgstr ""
"モナド変換子のある特定の組み合わせは、 `purescript-transformers`パッケージ内"
"の単一のモナド変換子として提供されるのが一般的です。 `Reader`、 `Writer`、 "
"`State`のモナドは、**Reader-Writer-State**モナド(`RWS`モナド)へと結合されま"
"す。このモナドは `RWST`モナド変換子と呼ばれる、対応するモナド変換子を持ってい"
"ます。"

#. type: Plain text
#: text/chapter11.md:733
#, fuzzy
msgid ""
"We will use the `RWS` monad to model the game logic for our text adventure "
"game."
msgstr ""
"ここでは `RWS`モナドを使ってテキストアドベンチャーゲームの処理を設計していき"
"ます。"

#. type: Plain text
#: text/chapter11.md:735
#, fuzzy
msgid ""
"The `RWS` monad is defined in terms of three type parameters (in addition to "
"its return type):"
msgstr "`RWS`モナドは(戻り値の型に加えて)3つの型変数で定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:736
#, fuzzy, no-wrap
msgid "type RWS r w s = RWST r w s Identity\n"
msgstr "type RWS r w s = RWST r w s Identity\n"

#. type: Plain text
#: text/chapter11.md:741
#, fuzzy
msgid ""
"Notice that the `RWS` monad is defined in terms of its own monad "
"transformer, by setting the base monad to `Identity` which provides no side-"
"effects."
msgstr ""
"副作用を提供しない `Identity`にベースモナドを設定することで、 `RWS`モナドが独"
"自のモナド変換子の観点から定義されていることに注意してください。"

#. type: Plain text
#: text/chapter11.md:743
#, fuzzy
msgid ""
"The first type parameter, `r`, represents the global configuration type. The "
"second, `w`, represents the monoid which we will use to accumulate a log, "
"and the third, `s` is the type of our mutable state."
msgstr ""
"第1型引数 `r`は大域的な設定の型を表します。第2型引数 `w`はログを蓄積するため"
"に使用するモノイド、第3型引数 `s`は可変状態の型を表しています。"

#. type: Plain text
#: text/chapter11.md:745
#, fuzzy
msgid ""
"In the case of our game, our global configuration is defined in a type "
"called `GameEnvironment` in the `Data.GameEnvironment` module:"
msgstr ""
"このゲームの場合には、大域的な設定は `Data.GameEnvironment`モジュールの "
"`GameEnvironment`と呼ばれる型で定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:746
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameEnvironment.purs:env}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:751
#, fuzzy
msgid ""
"It defines the player name, and a flag which indicates whether or not the "
"game is running in debug mode. These options will be set from the command "
"line when we come to run our monad transformer."
msgstr ""
"`GameEnvironment`では、プレイヤー名と、ゲームがデバッグモードで動作しているか"
"否かを示すフラグが定義されています。これらのオプションは、モナド変換子を実行"
"するときにコマンドラインから設定されます。"

#. type: Plain text
#: text/chapter11.md:753
#, fuzzy
msgid ""
"The mutable state is defined in a type called `GameState` in the `Data."
"GameState` module:"
msgstr ""
"可変状態は `Data.GameState`モジュールの `GameState`と呼ばれる型で定義されてい"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:754
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Data/GameState.purs:imports}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Data/GameState.purs:GameState}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:761
#, fuzzy
msgid ""
"The `Coords` data type represents points on a two-dimensional grid, and the "
"`GameItem` data type is an enumeration of the items in the game:"
msgstr ""
"`Coords`データ型は2次元平面の点を表し、 `GameItem`データ型はゲーム内のアイテ"
"ムです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:762
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Data/GameItem.purs:GameItem}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:767
#, fuzzy
msgid ""
"The `GameState` type uses two new data structures: `Map` and `Set`, which "
"represent sorted maps and sorted sets respectively. The `items` property is "
"a mapping from coordinates of the game grid to sets of game items at that "
"location. The `player` property stores the current coordinates of the "
"player, and the `inventory` property stores a set of game items currently "
"held by the player."
msgstr ""
"`GameState`型はソートされたマップを表す `Map`とソートされた集合を表す `Set`と"
"いう2つの新しいデータ構造を使っています。 `items`プロパティは、そのゲーム平面"
"上の座標と、ゲームアイテムの集合へのマッピングになっています。 `player`プロパ"
"ティはプレイヤーの現在の座標を格納しており、 `inventory`プロパティは現在プレ"
"イヤーが保有するゲームアイテムの集合です。"

#. type: Plain text
#: text/chapter11.md:769
#, fuzzy
msgid ""
"The `Map` and `Set` data structures are sorted by their keys, can be used "
"with any key type in the `Ord` type class. This means that the keys in our "
"data structures should be totally ordered."
msgstr ""
"`Map`と `Set`のデータ構造はキーによってソートされ、 `Ord`型クラスの任意の型を"
"キーとして使用することができます。これは今回のデータ構造のキーが完全に順序付"
"けできることを意味します。"

#. type: Plain text
#: text/chapter11.md:771
#, fuzzy
msgid ""
"We will see how the `Map` and `Set` structures are used as we write the "
"actions for our game."
msgstr ""
"ゲームのアクションを書くために、 `Map`と `Set`構造がどのように使っていくのか"
"を見ていきましょう。"

#. type: Plain text
#: text/chapter11.md:773
#, fuzzy
msgid ""
"For our log, we will use the `List String` monoid. We can define a type "
"synonym for our `Game` monad, implemented using `RWS`:"
msgstr ""
"ログとしては `List String`モノイドを使います。 `RWS`を使って `Game`モナドのた"
"めの型同義語を定義しておきます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:774
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:Game}}\n"
msgstr ""

#. type: Title ##
#: text/chapter11.md:778
#, fuzzy, no-wrap
msgid "Implementing Game Logic"
msgstr "ゲームロジックの実装"

#. type: Plain text
#: text/chapter11.md:781
#, fuzzy
msgid ""
"Our game is going to be built from simple actions defined in the `Game` "
"monad, by reusing the actions from the `Reader`, `Writer` and `State` "
"monads. At the top level of our application, we will run the pure "
"computations in the `Game` monad, and use the `Effect` monad to turn the "
"results into observable side-effects, such as printing text to the console."
msgstr ""
"今回は、 `Reader`モナド、 `Writer`モナド、 `State`モナドのアクションを再利用"
"し、 `Game`モナドで定義されている単純なアクションを組み合わせてゲームを構築し"
"ていきます。このアプリケーションの最上位では、 `Game`モナドで純粋な計算を実行"
"しており、 `Eff`モナドはコンソールにテキストを出力するような追跡可能な副作用"
"へと結果を変換するために使っています。"

#. type: Plain text
#: text/chapter11.md:783
#, fuzzy
msgid ""
"One of the simplest actions in our game is the `has` action. This action "
"tests whether the player's inventory contains a particular game item. It is "
"defined as follows:"
msgstr ""
"このゲームで最も簡単なアクションのひとつは `has`アクションです。このアクショ"
"ンはプレイヤーの持ち物に特定のゲームアイテムが含まれているかどうかを調べま"
"す。これは次のように定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:784
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:has}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:789
#, fuzzy
msgid ""
"This function uses the `get` action defined in the `MonadState` type class "
"to read the current game state, and then uses the `member` function defined "
"in `Data.Set` to test whether the specified `GameItem` appears in the `Set` "
"of inventory items."
msgstr ""
"この関数は、現在のゲームの状態を読み取るために `Monad.State`型クラスで定義さ"
"れている `get`アクションを使っており、指定した `GameItem`が持ち物の `Set`のな"
"かに出現するかどうかを調べるために `Data.Set`で定義されている `member`関数を"
"使っています。"

#. type: Plain text
#: text/chapter11.md:791
#, fuzzy
msgid ""
"Another action is the `pickUp` action. It adds a game item to the player's "
"inventory if it appears in the current room. It uses actions from the "
"`MonadWriter` and `MonadState` type classes. First of all, it reads the "
"current game state:"
msgstr ""
"他にも `pickUp`アクションがあります。現在の位置にゲームアイテムがある場合、プ"
"レイヤーの持ち物にそのアイテムを追加します。これには `MonadWriter`と "
"`MonadState`型クラスのアクションを使っています。まず、現在のゲームの状態を読"
"み取ります。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:792
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_start}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:797
#, fuzzy
msgid ""
"Next, `pickUp` looks up the set of items in the current room. It does this "
"by using the `lookup` function defined in `Data.Map`:"
msgstr ""
"次に `pickUp`は現在の位置にあるアイテムの集合を検索します。これは `Data.Map`"
"で定義された `lookup`関数を使って行います。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:798
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_case}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:803
#, fuzzy
msgid ""
"The `lookup` function returns an optional result indicated by the `Maybe` "
"type constructor. If the key does not appear in the map, the `lookup` "
"function returns `Nothing`, otherwise it returns the corresponding value in "
"the `Just` constructor."
msgstr ""
"`lookup`関数は `Maybe`型構築子で示されたオプショナルな結果を返します。 "
"`lookup`関数は、キーがマップにない場合は `Nothing`を返し、それ以外の場合は "
"`Just`構築子で対応する値を返します。"

#. type: Plain text
#: text/chapter11.md:805
#, fuzzy
msgid ""
"We are interested in the case where the corresponding item set contains the "
"specified game item. Again we can test this using the `member` function:"
msgstr ""
"関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含まれてい"
"る場合です。 `member`関数を使うとこれを調べることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:806
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_Just}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:811
#, fuzzy
msgid ""
"In this case, we can use `put` to update the game state, and `tell` to add a "
"message to the log:"
msgstr ""
"この場合、 `put`を使ってゲームの状態を更新し、 `tell`を使ってログにメッセージ"
"を追加します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:812
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_body}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:817
#, fuzzy
msgid ""
"Note that there is no need to `lift` either of the two computations here, "
"because there are appropriate instances for both `MonadState` and "
"`MonadWriter` for our `Game` monad transformer stack."
msgstr ""
"ここで、 `MonadState`と `MonadWriter`の両方について `Game`モナド変換子スタッ"
"クについての適切なインスタンスが存在するので、２つの計算はどちらも `lift`は必"
"要ないことに注意してください。"

#. type: Plain text
#: text/chapter11.md:819
#, fuzzy
msgid ""
"The argument to `put` uses a record update to modify the game state's "
"`items` and `inventory` fields. We use the `update` function from `Data.Map` "
"which modifies a value at a particular key. In this case, we modify the set "
"of items at the player's current location, using the `delete` function to "
"remove the specified item from the set. `inventory` is also updated, using "
"`insert` to add the new item to the player's inventory set."
msgstr ""
"`put`の引数では、レコード更新を使ってゲームの状態の `items`と `inventory`"
"フィールドを変更しています。特定のキーの値を変更するには `Data.Map`の "
"`update`関数を使います。このとき、 `delete`関数を使い指定したアイテムを集合か"
"ら取り除くことで、プレイヤーの現在の位置にあるアイテムの集合を変更します。"

#. type: Plain text
#: text/chapter11.md:821
#, fuzzy
msgid ""
"Finally, the `pickUp` function handles the remaining cases, by notifying the "
"user using `tell`:"
msgstr ""
"最後に、 `pickUp`関数は `tell`を使ってユーザに次のように通知することにより、"
"残りの場合を処理します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:822
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:pickup_err}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:827
#, fuzzy
msgid ""
"As an example of using the `Reader` monad, we can look at the code for the "
"`debug` command. This command allows the user to inspect the game state at "
"runtime if the game is running in debug mode:"
msgstr ""
"`Reader`モナドを使う例として、 `debug`コマンドのコードを見てみましょう。ゲー"
"ムがデバッグモードで実行されている場合、このコマンドを使うとユーザは実行時に"
"ゲームの状態を調べることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:828
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:debug}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:833
#, fuzzy
msgid ""
"Here, we use the `ask` action to read the game configuration. Again, note "
"that we don't need to `lift` any computation, and we can use actions defined "
"in the `MonadState`, `MonadReader` and `MonadWriter` type classes in the "
"same do notation block."
msgstr ""
"ここでは、ゲームの設定を読み込むために `ask`アクションを使用しています。繰り"
"返しますが、どんな計算の `lift`も必要なく、同じdo記法ブロック内で "
"`MonadState`、 `MonadReader`、 `MonadWriter`型クラスで定義されているアクショ"
"ンを使うことができることに注意してください。"

#. type: Plain text
#: text/chapter11.md:835
#, fuzzy
msgid ""
"If the `debugMode` flag is set, then the `tell` action is used to write the "
"state to the log. Otherwise, an error message is added."
msgstr ""
"`debugMode`フラグが設定されている場合、 `tell`アクションを使ってログに状態が"
"追加されます。そうでなければ、エラーメッセージが追加されます。"

#. type: Plain text
#: text/chapter11.md:837
#, fuzzy
msgid ""
"The remainder of the `Game` module defines a set of similar actions, each "
"using only the actions defined by the `MonadState`, `MonadReader` and "
"`MonadWriter` type classes."
msgstr ""
"`Game.purs`モジュールでは、 `MonadState`型クラス、 `MonadReader`型クラス、 "
"`MonadWriter`型クラスでそれぞれ定義されたアクションだけを使って、同様のアク"
"ションが定義されています。"

#. type: Title ##
#: text/chapter11.md:838
#, fuzzy, no-wrap
msgid "Running the Computation"
msgstr "計算の実行"

#. type: Plain text
#: text/chapter11.md:841
#, fuzzy
msgid ""
"Since our game logic runs in the `RWS` monad, it is necessary to run the "
"computation in order to respond to the user's commands."
msgstr ""
"このゲームロジックは `RWS`モナドで動くため、ユーザのコマンドに応答するために"
"は計算を実行する必要があります。"

#. type: Plain text
#: text/chapter11.md:843
#, fuzzy
msgid ""
"The front-end of our game is built using two packages: `optparse`, which "
"provides applicative command line parsing, and `node-readline`, which wraps "
"NodeJS' `readline` module, allowing us to write interactive console-based "
"applications."
msgstr ""
"このゲームのフロントエンドは、 `yargs`コマンドライン構文解析ライブラリへの"
"Applicativeなインターフェイスを提供する `purescript-yargs`パッケージと、対話"
"的なコンソールベースのアプリケーションを書くことを可能にするNodeJSの "
"`readline`モジュールをラップする `purescript-node-readline`パッケージという２"
"つのパッケージで構成されています。"

#. type: Plain text
#: text/chapter11.md:845
#, fuzzy
msgid ""
"The interface to our game logic is provided by the function `game` in the "
"`Game` module:"
msgstr ""
"このゲームロジックへのインタフェースは `Game`モジュール内の関数 `game`によっ"
"て提供されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:846
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Game.purs:game_sig}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:851
#, fuzzy
msgid ""
"To run this computation, we pass a list of words entered by the user as an "
"array of strings, and run the resulting `RWS` computation using `runRWS`:"
msgstr ""
"この計算を実行するには、ユーザが入力した単語のリストを文字列の配列として渡し"
"てから、 `runRWS`を使って `RWS`の計算を実行します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:852
#, fuzzy, no-wrap
msgid ""
"data RWSResult state result writer = RWSResult state result writer\n"
"\n"
"runRWS :: forall r w s a. RWS r w s a -> r -> s -> RWSResult s a w\n"
msgstr ""
"data RWSResult state result writer = RWSResult state result writer\n"
"\n"
"runRWS :: forall r w s a. RWS r w s a -> r -> s -> RWSResult s a w\n"

#. type: Plain text
#: text/chapter11.md:859
#, fuzzy
msgid ""
"`runRWS` looks like a combination of `runReader`, `runWriter` and "
"`runState`. It takes a global configuration and an initial state as an "
"argument, and returns a data structure containing the log, the result and "
"the final state."
msgstr ""
"`runRWS`は `runReader`、 `runWriter`、 `runState`を組み合わせたように見えま"
"す。これは、引数として大域的な設定および初期状態をとり、ログ、結果、最的な終"
"状態を含むレコードを返します。"

#. type: Plain text
#: text/chapter11.md:861
#, fuzzy
msgid ""
"The front-end of our application is defined by a function `runGame`, with "
"the following type signature:"
msgstr ""
"このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数 `runGame`"
"によって定義されます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:862
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_sig}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:867
#, fuzzy
msgid ""
"This function interacts with the user via the console (using the `node-"
"readline` and `console` packages). `runGame` takes the game configuration as "
"a function argument."
msgstr ""
"`Console`作用は、この関数が `purescript-node-readline`パッケージを使ってコン"
"ソールを介してユーザと対話することを示しています。 `runGame`は関数の引数とし"
"てのゲームの設定とります。"

#. type: Plain text
#: text/chapter11.md:869
#, fuzzy
msgid ""
"The `node-readline` package provides the `LineHandler` type, which "
"represents actions in the `Effect` monad which handle user input from the "
"terminal. Here is the corresponding API:"
msgstr ""
"`purescript-node-readline`パッケージでは、端末からのユーザ入力を扱う `Eff`モ"
"ナドのアクションを表す `LineHandler`型が提供されています。対応するAPIは次のと"
"おりです。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:870
#, fuzzy, no-wrap
msgid ""
"type LineHandler a = String -> Effect a\n"
"\n"
"foreign import setLineHandler\n"
"  :: forall a\n"
"   . Interface\n"
"  -> LineHandler a\n"
"  -> Effect Unit\n"
msgstr ""
"type LineHandler eff a = String -> Eff eff a\n"
"\n"
"setLineHandler :: forall eff a. Interface\n"
"                -> LineHandler (readline :: READLINE | eff) a\n"
"                -> Eff (readline :: READLINE | eff) Unit\n"

#. type: Plain text
#: text/chapter11.md:881
#, fuzzy
msgid ""
"The `Interface` type represents a handle for the console, and is passed as "
"an argument to the functions which interact with it. An `Interface` can be "
"created using the `createConsoleInterface` function:"
msgstr ""
"`Interface`型はコンソールのハンドルを表しており、コンソールと対話する関数への"
"引数として渡されます。 `createInterface`関数を使用すると `Interface`を作成す"
"ることができます。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:882
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:import_RL}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:runGame_interface}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:889
#, fuzzy
msgid ""
"The first step is to set the prompt at the console. We pass the `interface` "
"handle, and provide the prompt string and indentation level:"
msgstr ""
"最初の手順はコンソールにプロンプトを設定することです。 `interface`ハンドルを"
"渡し、プロンプト文字列とインデントレベルを提供します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:890
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_prompt}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:895
#, fuzzy
msgid ""
"In our case, we are interested in implementing the line handler function. "
"Our line handler is defined using a helper function in a `let` declaration, "
"as follows:"
msgstr ""
"今回は `lineHandler`関数を実装してみましょう。 `lineHandler`は `let`宣言内の"
"補助関数を使って次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:896
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_lineHandler}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:901
#, fuzzy
msgid ""
"The `let` binding is closed over both the game configuration, named `env`, "
"and the console handle, named `interface`."
msgstr ""
"`lineHandler`では `env`という名前のゲーム構成や、 `interface`という名前のコン"
"ソールハンドルを参照しています。"

#. type: Plain text
#: text/chapter11.md:903
#, fuzzy
msgid ""
"Our handler takes an additional first argument, the game state. This is "
"required since we need to pass the game state to `runRWS` to run the game's "
"logic."
msgstr ""
"このハンドラは追加の最初の引数としてゲームの状態を取ります。ゲームのロジック"
"を実行するために `runRWS`にゲームの状態を渡さなければならないので、これは必要"
"となっています。"

#. type: Plain text
#: text/chapter11.md:905
#, fuzzy
msgid ""
"The first thing this action does is to break the user input into words using "
"the `split` function from the `Data.String` module. It then uses `runRWS` to "
"run the `game` action (in the `RWS` monad), passing the game environment and "
"current game state."
msgstr ""
"このアクションが最初に行うことは、 `Data.String`モジュールの `split`関数を使"
"用して、ユーザーの入力を単語に分割することです。それから、ゲーム環境と現在の"
"ゲームの状態を渡し、 `runRWS`を使用して(`RWS`モナドで)`game`アクションを実行"
"しています。"

#. type: Plain text
#: text/chapter11.md:907
#, fuzzy
msgid ""
"Having run the game logic, which is a pure computation, we need to print any "
"log messages to the screen and show the user a prompt for the next command. "
"The `for_` action is used to traverse the log (of type `List String`) and "
"print its entries to the console. Finally, `setLineHandler` is used to "
"update the line handler function to use the updated game state, and the "
"prompt is displayed again using the `prompt` action."
msgstr ""
"純粋な計算であるゲームロジックを実行し、画面にすべてのログメッセージを出力し"
"て、ユーザに次のコマンドのプロンプトを表示する必要があります。 `for_`アクショ"
"ンは(`List String`型の)ログを走査し、コンソールにその内容を出力するために使わ"
"れています。そして `setLineHandler`を使って `lineHandler`関数を更新すること"
"で、ゲームの状態を更新します。最後に `prompt`アクションを使ってプロンプトが再"
"び表示しています。"

#. type: Plain text
#: text/chapter11.md:909
#, fuzzy
msgid ""
"The `runGame` function finally attaches the initial line handler to the "
"console interface, and displays the initial prompt:"
msgstr ""
"`runGame`関数ではコンソールインターフェイスに最初のlineHandlerを設定して、最"
"初のプロンプトを表示します。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:910
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:runGame_attach_handler}}\n"
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter11.md:918
#, fuzzy
msgid ""
"(Medium) Implement a new command `cheat`, which moves all game items from "
"the game grid into the user's inventory. Create a function `cheat :: Game "
"Unit` in the `Game` module, and use this function from `game`."
msgstr ""
"(やや難しい) ゲームフィールド上にあるすべてのゲームアイテムをユーザの持ちもの"
"に移動する新しいコマンド `cheat`を実装してください。"

#. type: Bullet: ' 1. '
#: text/chapter11.md:918
#, fuzzy
msgid ""
"(Difficult) The `Writer` component of the `RWS` monad is currently used for "
"two types of messages: error messages and informational messages. Because of "
"this, several parts of the code use case statements to handle error cases."
msgstr ""
"(難しい) `RWS`モナドの ` Writer`コンポーネントは、エラーメッセージと情報メッ"
"セージの２つの種類のメッセージのために使われています。このため、コードのいく"
"つかの箇所では、エラーの場合を扱うためにcase式を使用しています。"

#. type: Plain text
#: text/chapter11.md:920
#, fuzzy, no-wrap
msgid "     Refactor the code to use the `ExceptT` monad transformer to handle the error messages, and `RWS` to handle informational messages. _Note:_ There are no tests for this exercise.\n"
msgstr "    エラーメッセージを扱うのに `ExceptT`モナド変換子を使うようにし、情報メッセージを扱うのに `RWS`を使うようにするよう、コードをリファクタリングしてください。\n"

#. type: Title ##
#: text/chapter11.md:921
#, fuzzy, no-wrap
msgid "Handling Command Line Options"
msgstr "コマンドラインオプションの扱い"

#. type: Plain text
#: text/chapter11.md:924
#, fuzzy
msgid ""
"The final piece of the application is responsible for parsing command line "
"options and creating the `GameEnvironment` configuration record. For this, "
"we use the `optparse` package."
msgstr ""
"このアプリケーションの最後の部品は、コマンドラインオプションの解析と "
"`GameEnvironment`レコードを作成する役目にあります。このためには `purescript-"
"yargs`パッケージを使用します。"

#. type: Plain text
#: text/chapter11.md:926
#, fuzzy
msgid ""
"`optparse` is an example of _applicative command line option parsing_. "
"Recall that an applicative functor allows us to lift functions of arbitrary "
"arity over a type constructor representing some type of side-effect. In the "
"case of the `optparse` package, the functor we are interested in is the "
"`Parser` functor (imported from the optparse module `Options.Applicative`, "
"not to be confused with our `Parser` that we defined in the `Split` module), "
"which adds the side-effect of reading from command line options. It provides "
"the following handler:"
msgstr ""
"`purescript-yargs`は**Applicativeなコマンドラインオプション構文解析器**の例で"
"す。Applicative関手を使うと、いろいろな副作用の型を表す型構築子まで任意個数の"
"引数の関数をを持ち上げられることを思い出してください。 `purescript-yargs`パッ"
"ケージの場合には、コマンドラインオプションからの読み取りの副作用を追加する "
"`Y`関手が興味深い関手になっています。これは次のようなハンドラを提供していま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:927
#, no-wrap
msgid "customExecParser :: forall a. ParserPrefs â ParserInfo a â Effect a\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:932
#, fuzzy
msgid ""
"This is best illustrated by example. The application's `main` function is "
"defined using `customExecParser` as follows:"
msgstr ""
"この関数の使いかたは、例で示すのが最も適しているでしょう。このアプリケーショ"
"ンの `main`関数は `runY`を使って次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter11.md:933
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:main}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:938
#, fuzzy
msgid ""
"The first argument is used to configure the `optparse` library. In our case, "
"we simply configure it to show the help message when the application is run "
"without any arguments (instead of showing a \"missing argument\" error) by "
"using `OP.prefs OP.showHelpOnEmpty`, but the `Options.Applicative.Builder` "
"module provides several other options."
msgstr ""
"最初の引数は `yargs`ライブラリを設定するために使用されます。今回の場合、使用"
"方法のメッセージだけを提供していますが、 `Node.Yargs.Setup`モジュールには他に"
"もいくつかのオプションを提供しています。"

#. type: Plain text
#: text/chapter11.md:940
msgid "The second argument is the complete description of our parser program:"
msgstr ""

#. type: Fenced code block (haskell )
#: text/chapter11.md:940
#, no-wrap
msgid ""
"{{#include ../exercises/chapter11/src/Main.purs:argParser}}\n"
"\n"
"{{#include ../exercises/chapter11/src/Main.purs:parserOptions}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:947
#, no-wrap
msgid "Here `OP.info` combines a `Parser` with a set of options for how the help message is formatted. `env <**> OP.helper` takes any command line argument `Parser` named `env` and adds a `--help` option to it automatically. Options for the help message are of type `InfoMod`, which is a monoid, so we can use the `fold` function to add several options together. \n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:949
msgid ""
"The interesting part of our parser is constructing the `GameEnvironment`:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter11.md:950
#, no-wrap
msgid "{{#include ../exercises/chapter11/src/Main.purs:env}}\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:955
#, no-wrap
msgid "`player` and `debug` are both `Parser`s, so we can use our applicative operators `<$>` and `<*>` to lift our `gameEnvironment` function, which has the type `PlayerName -> Boolean -> GameEnvironment` over `Parser`. `OP.strOption` constructs a command line option that expects a string value, and is configured via a collection of `Mod`s folded together. `OP.flag` works similarly, but doesn't expect an associated value. `optparse` offers extensive [documentation](https://pursuit.purescript.org/packages/purescript-optparse) on different modifiers available to build various command line parsers.\n"
msgstr ""

#. type: Plain text
#: text/chapter11.md:957
#, fuzzy, no-wrap
msgid "Notice how we were able to use the notation afforded by the applicative operators to give a compact, declarative specification of our command line interface. In addition, it is simple to add new command line arguments, simply by adding a new function argument to `runGame`, and then using `<*>` to lift `runGame` over an additional argument in the definition of `env`.\n"
msgstr "Applicative演算子によるこの記法を使うことで、コマンドラインインターフェイスに対してコンパクトで宣言的な仕様を与えることが可能になったことに注意してください。また、 `env`の定義で `runGame`関数に新しい引数を追加し、 `<*>`を使って追加の引数まで `runGame`を持ち上げるだけで、簡単に新しいコマンドライン引数を追加することができます。\n"

#. type: Bullet: ' 1. '
#: text/chapter11.md:961
#, fuzzy
msgid ""
"(Medium) Add a new Boolean-valued property `cheatMode` to the "
"`GameEnvironment` record. Add a new command line flag `-c` to the `optparse` "
"configuration which enables cheat mode. The `cheat` command from the "
"previous exercise should be disallowed if cheat mode is not enabled."
msgstr ""
"(やや難しい)`GameEnvironment`レコードに新しい真偽値のプロパティ `cheatMode`を"
"追加してください。 また、 `yargs`設定に、チートモードを有効にする新しいコマン"
"ドラインフラグ `-c`を追加してください。チートモードが有効になっていない場"
"合、 `cheat`コマンドは禁止されなければなりません。"

#. type: Plain text
#: text/chapter11.md:965
#, fuzzy
msgid ""
"This chapter was a practical demonstration of the techniques we've learned "
"so far, using monad transformers to build a pure specification of our game, "
"and the `Effect` monad to build a front-end using the console."
msgstr ""
"モナド変換子を使用したゲームの純粋な定義、コンソールを使用したフロントエンド"
"を構築するための `Eff`モナドなと、この章ではこれまで学んできた手法を実用的に"
"使いました。"

#. type: Plain text
#: text/chapter11.md:967
#, fuzzy
msgid ""
"Because we separated our implementation from the user interface, it would be "
"possible to create other front-ends for our game. For example, we could use "
"the `Effect` monad to render the game in the browser using the Canvas API or "
"the DOM."
msgstr ""
"ユーザインターフェイスからの実装を分離したので、ゲームの別のフロントエンドを"
"作成することも可能でしょう。例えば、 `Eff`モナドでCanvas APIやDOMを使用して、"
"ブラウザでゲームを描画するようなことができるでしょう。"

#. type: Plain text
#: text/chapter11.md:969
#, fuzzy
msgid ""
"We have seen how monad transformers allow us to write safe code in an "
"imperative style, where effects are tracked by the type system. In addition, "
"type classes provide a powerful way to abstract over the actions provided by "
"a monad, enabling code reuse. We were able to use standard abstractions like "
"`Alternative` and `MonadPlus` to build useful monads by combining standard "
"monad transformers."
msgstr ""
"モナド変換子によって、型システムによって作用が追跡される命令型のスタイルで、"
"安全なコードを書くことができることを見てきました。また、型クラスは、コードの"
"再利用を可能にするモナドによって提供される、アクション上の抽象化の強力な方法"
"を提供します。標準的なモナド変換子を組み合わせることにより、 `Alternative`や "
"`MonadPlus`のような標準的な抽象化を使用して、役に立つモナドを構築することがで"
"きました。"

#. type: Plain text
#: text/chapter11.md:971
#, fuzzy
msgid ""
"Monad transformers are an excellent demonstration of the sort of expressive "
"code that can be written by relying on advanced type system features such as "
"higher-kinded polymorphism and multi-parameter type classes."
msgstr ""
"モナド変換子は、高階多相や多変数型クラスなどの高度な型システムの機能を利用す"
"ることによって記述することができ、表現力の高いコードの優れた実演となっていま"
"す。"

#. type: Title #
#: text/chapter12.md:1
#, fuzzy, no-wrap
msgid "Canvas Graphics"
msgstr "キャンバスグラフィックス"

#. type: Plain text
#: text/chapter12.md:6
#, fuzzy
msgid ""
"This chapter will be an extended example focussing on the `canvas` package, "
"which provides a way to generate 2D graphics from PureScript using the HTML5 "
"Canvas API."
msgstr ""
"この章のコード例では、PureScriptでHTML5のCanvas APIを使用して2Dグラフィックス"
"を生成する `purescript-canvas`パッケージに焦点をあててコードを拡張していきま"
"す。"

#. type: Plain text
#: text/chapter12.md:13
#, fuzzy
msgid ""
"- `canvas`, which gives types to methods from the HTML5 Canvas API - `refs`, "
"which provides a side-effect for using _global mutable references_"
msgstr ""
"- `purescript-canvas`- HTML5のCanvas APIのメソッドの型が定義されています。 - "
"`purescript-refs`- **大域的な変更可能領域への参照**を扱うための副作用を提供し"
"ています。"

#. type: Plain text
#: text/chapter12.md:15
#, fuzzy
msgid ""
"The source code for the chapter is broken up into a set of modules, each of "
"which defines a `main` method. Different sections of this chapter are "
"implemented in different files, and the `Main` module can be changed by "
"modifying the Spago build command to run the appropriate file's `main` "
"method at each point."
msgstr ""
"この章のソースコードは、それぞれに `main`メソッドが定義されている複数のモ​​"
"ジュールへと分割されています。この章の節の内容はそれぞれ異なるファイルで実装"
"されており、それぞれの節で対応するファイルの `main`メソッドを実行できるよう"
"に、Pulpビルドコマンドを変更することで `Main`モジュールが変更できるようになっ"
"ています。"

#. type: Plain text
#: text/chapter12.md:17
#, fuzzy
msgid ""
"The HTML file `html/index.html` contains a single `canvas` element which "
"will be used in each example, and a `script` element to load the compiled "
"PureScript code. To test the code for each section, open the HTML file in "
"your browser. Because most exercises target the browser, there are no unit "
"tests for this chapter."
msgstr ""
"HTMLファイル `html/index.html`には、各例で使用される単一の `canvas`要素、およ"
"びコンパイルされたPureScriptコードを読み込む `script`要素が含まれています。各"
"節のコードをテストするには、ブラウザでこのHTMLファイルを開いてください。"

#. type: Title ##
#: text/chapter12.md:18
#, fuzzy, no-wrap
msgid "Simple Shapes"
msgstr "単純な図形"

#. type: Plain text
#: text/chapter12.md:21
#, fuzzy
msgid ""
"The `Example/Rectangle.purs` file contains a simple introductory example, "
"which draws a single blue rectangle at the center of the canvas. The module "
"imports the `Effect` type from the `Effect` module, and also the `Graphics."
"Canvas` module, which contains actions in the `Effect` monad for working "
"with the Canvas API."
msgstr ""
"`Example/Rectangle.purs`ファイルにはキャンバスの中心に青い四角形をひとつ描画"
"するという簡単な例が含まれています。このモジュールは、 `Control.Monad.Eff`モ"
"ジュールと、Canvas APIを扱うための `Eff`モナドのアクションが定義されている "
"`Graphics.Canvas`モジュールをインポートします。"

#. type: Plain text
#: text/chapter12.md:23
#, fuzzy
msgid ""
"The `main` action starts, like in the other modules, by using the "
"`getCanvasElementById` action to get a reference to the canvas object, and "
"the `getContext2D` action to access the 2D rendering context for the canvas:"
msgstr ""
"他のモジュールでも同様ですが、 `main`アクションは最初に "
"`getCanvasElementById`アクションを使ってCanvasオブジェクトへの参照を取得して"
"います。また、 `getContext2D`アクションを使ってキャンバスの2Dレンダリングコン"
"テキストを参照しています。"

#. type: Plain text
#: text/chapter12.md:25
msgid ""
"The `void` function takes a functor and replaces its value with `Unit`. In "
"the example it is used to make `main` conform with its signature."
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter12.md:26
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:main}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:31
#, fuzzy
msgid ""
"_Note_: the call to `unsafePartial` here is necessary since the pattern "
"match on the result of `getCanvasElementById` is partial, matching only the "
"`Just` constructor. For our purposes, this is fine, but in production code, "
"we would probably want to match the `Nothing` constructor and provide an "
"appropriate error message."
msgstr ""
"**注意**：この`unsafePartial`の呼び出しは必須です。これは "
"`getCanvasElementById`の結果のパターンマッチングが部分的で、`Just`値構築子だ"
"けと照合するためです。ここではこれで問題ありませんが、実際の製品のコードでは"
"おそらく`Nothing`値構築子と照合させ、適切なエラーメッセージを提供したほうがよ"
"いでしょう。\n"

#. type: Plain text
#: text/chapter12.md:33
#, fuzzy
msgid ""
"The types of these actions can be found using PSCi or by looking at the "
"documentation:"
msgstr ""
"これらのアクションの型は、`PSCi`を使うかドキュメントを見ると確認できます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:34
#, fuzzy, no-wrap
msgid ""
"getCanvasElementById :: String -> Effect (Maybe CanvasElement)\n"
"\n"
"getContext2D :: CanvasElement -> Effect Context2D\n"
msgstr ""
"getCanvasElementById :: forall eff. String ->\n"
"  Eff (canvas :: Canvas | eff) (Maybe CanvasElement)\n"
"\n"
"getContext2D :: forall eff. CanvasElement ->\n"
"  Eff (canvas :: Canvas | eff) Context2D\n"

#. type: Plain text
#: text/chapter12.md:41
#, fuzzy
msgid ""
"`CanvasElement` and `Context2D` are types defined in the `Graphics.Canvas` "
"module. The same module also defines the `Canvas` effect, which is used by "
"all of the actions in the module."
msgstr ""
"`CanvasElement`と `Context2D`は `Graphics.Canvas`モジュールで定義されている型"
"です。このモジュールでは、モジュール内のすべてのアクションで使用されている "
"`Canvas`作用も定義されています。"

#. type: Plain text
#: text/chapter12.md:43
#, fuzzy
msgid ""
"The graphics context `ctx` manages the state of the canvas, and provides "
"methods to render primitive shapes, set styles and colors, and apply "
"transformations."
msgstr ""
"グラフィックスコンテキスト `ctx`は、キャンバスの状態を管理し、プリミティブな"
"図形を描画したり、スタイルや色を設定したり、座標変換を適用するためのメソッド"
"を提供しています。"

#. type: Plain text
#: text/chapter12.md:45
msgid ""
"We continue by setting the fill style to solid blue using the `setFillStyle` "
"action. The longer hex notation of `#0000FF` may also be used for blue, but "
"shorthand notation is easier for simple colors:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter12.md:46
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:setFillStyle}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:51
#, fuzzy
msgid ""
"Note that the `setFillStyle` action takes the graphics context as an "
"argument. This is a common pattern in the `Graphics.Canvas` module."
msgstr ""
"`setFillStyle`アクションがグラフィックスコンテキストを引数として取っているこ"
"とに注意してください。これは `Graphics.Canvas`で共通のパターンです。"

#. type: Plain text
#: text/chapter12.md:53
#, fuzzy
msgid ""
"Finally, we use the `fillPath` action to fill the rectangle. `fillPath` has "
"the following type:"
msgstr ""
"最後に、 `fillPath`アクションを使用して矩形を塗りつぶしています。 `fillPath`"
"は次のような型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:54
#, no-wrap
msgid "fillPath :: forall a. Context2D -> Effect a -> Effect a\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:59
#, fuzzy
msgid ""
"`fillPath` takes a graphics context and another action which builds the path "
"to render. To build a path, we can use the `rect` action. `rect` takes a "
"graphics context, and a record which provides the position and size of the "
"rectangle:"
msgstr ""
"`fillPath`はグラフィックスコンテキストとレンダリングするパスを構築する別のア"
"クションを引数にとります。パスは `rect`アクションを使うと構築することができま"
"す。 `rect`はグラフィックスコンテキストと矩形の位置及びサイズを格納するレコー"
"ドを引数にとります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:60
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Rectangle.purs:fillPath}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:65
#, fuzzy
msgid ""
"Build the rectangle example, providing `Example.Rectangle` as the name of "
"the main module:"
msgstr ""
"mainモジュールの名前として`Example.Rectangle`を指定して、この長方形のコード例"
"をビルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:66
#, fuzzy, no-wrap
msgid "$ spago bundle-app --main Example.Rectangle --to dist/Main.js\n"
msgstr ""
"$ mkdir dist/\n"
"$ pulp build -O --main Example.Rectangle --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:71
#, fuzzy
msgid ""
"Now, open the `html/index.html` file and verify that this code renders a "
"blue rectangle in the center of the canvas."
msgstr ""
"それでは `html/index.html`ファイルを開き、このコードによってキャンバスの中央"
"に青い四角形が描画されていることを確認してみましょう。"

#. type: Title ##
#: text/chapter12.md:72
#, fuzzy, no-wrap
msgid "Putting Row Polymorphism to Work"
msgstr "行多相を利用する"

#. type: Plain text
#: text/chapter12.md:75
#, fuzzy
msgid ""
"There are other ways to render paths. The `arc` function renders an arc "
"segment, and the `moveTo`, `lineTo` and `closePath` functions can be used to "
"render piecewise-linear paths."
msgstr ""
"パスを描画する方法は他にもあります。 `arc`関数は円弧を描画します。 `moveTo`関"
"数、 `lineTo`関数、 `closePath`関数は細かい線分を組み合わせることでパスを描画"
"します。"

#. type: Plain text
#: text/chapter12.md:77
#, fuzzy
msgid ""
"The `Shapes.purs` file renders three shapes: a rectangle, an arc segment and "
"a triangle."
msgstr ""
"`Shapes.purs`ファイルでは長方形と円弧セグメント、三角形の、3つの図形を描画し"
"ています。"

#. type: Plain text
#: text/chapter12.md:79
#, fuzzy
msgid ""
"We have seen that the `rect` function takes a record as its argument. In "
"fact, the properties of the rectangle are defined in a type synonym:"
msgstr ""
"`rect`関数は引数としてレコードをとることを見てきました。実際には、長方形のプ"
"ロパティは型同義語で定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:80
#, fuzzy, no-wrap
msgid ""
"type Rectangle =\n"
"  { x :: Number\n"
"  , y :: Number\n"
"  , width :: Number\n"
"  , height :: Number\n"
"  }\n"
msgstr ""
"type Rectangle = { x :: Number\n"
"                 , y :: Number\n"
"                 , w :: Number\n"
"                 , h :: Number \n"
"                 }\n"

#. type: Plain text
#: text/chapter12.md:90
#, fuzzy
msgid ""
"The `x` and `y` properties represent the location of the top-left corner, "
"while the `w` and `h` properties represent the width and height respectively."
msgstr ""
"`x`と `y`プロパティは左上隅の位置を表しており、 `w`と `h`のプロパティはそれぞ"
"れ幅と高さを表しています。"

#. type: Plain text
#: text/chapter12.md:92
#, fuzzy
msgid ""
"To render an arc segment, we can use the `arc` function, passing a record "
"with the following type:"
msgstr ""
"`arc`関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画すること"
"ができます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:93
#, fuzzy, no-wrap
msgid ""
"type Arc =\n"
"  { x      :: Number\n"
"  , y      :: Number\n"
"  , radius :: Number\n"
"  , start  :: Number\n"
"  , end    :: Number\n"
"  }\n"
msgstr ""
"type Arc = { x     :: Number\n"
"           , y     :: Number\n"
"           , r     :: Number\n"
"           , start :: Number\n"
"           , end   :: Number\n"
"           }\n"

#. type: Plain text
#: text/chapter12.md:104
#, fuzzy
msgid ""
"Here, the `x` and `y` properties represent the center point, `r` is the "
"radius, and `start` and `end` represent the endpoints of the arc in radians."
msgstr ""
"ここで、 `x`と `y`プロパティは弧の中心、 `r`は半径、 `start`と `end`は弧の両"
"端の角度を弧度法で表しています。"

#. type: Plain text
#: text/chapter12.md:106
msgid ""
"For example, this code fills an arc segment centered at `(300, 300)` with "
"radius `50`. The arc completes 2/3rds of a rotation. Note that the unit "
"circle is flipped vertically, since the y-axis increases towards the bottom "
"of the canvas:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter12.md:107
#, fuzzy, no-wrap
msgid ""
"  fillPath ctx $ arc ctx\n"
"    { x      : 300.0\n"
"    , y      : 300.0\n"
"    , radius : 50.0\n"
"    , start  : 0.0\n"
"    , end    : Math.tau * 2.0 / 3.0\n"
"    }\n"
msgstr ""
"  fillPath ctx $ arc ctx\n"
"    { x      : 300.0\n"
"    , y      : 300.0\n"
"    , r      : 50.0\n"
"    , start  : Math.pi * 5.0 / 8.0\n"
"    , end    : Math.pi * 2.0\n"
"    }\n"

#. type: Plain text
#: text/chapter12.md:118
#, fuzzy
msgid ""
"Notice that both the `Rectangle` and `Arc` record types contain `x` and `y` "
"properties of type `Number`. In both cases, this pair represents a point. "
"This means that we can write row-polymorphic functions which can act on "
"either type of record."
msgstr ""
"`Number`型の `x`と `y`というプロパティが `Rectangle`レコード型と `Arc`レコー"
"ド型の両方に含まれていることに注意してください。どちらの場合でもこの組は点を"
"表しています。これは、いずれのレコード型にも適用できる、行多相な関数を書くこ"
"とができることを意味します。"

#. type: Plain text
#: text/chapter12.md:120
#, fuzzy
msgid ""
"For example, the `Shapes` module defines a `translate` function which "
"translates a shape by modifying its `x` and `y` properties:"
msgstr ""
"たとえば、 `Shapes`モジュールでは `x`と `y`のプロパティを変更し図形を並行移動"
"する `translate`関数を定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:121
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:translate}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:126
#, fuzzy
msgid ""
"Notice the row-polymorphic type. It says that `translate` accepts any record "
"with `x` and `y` properties _and any other properties_, and returns the same "
"type of record. The `x` and `y` fields are updated, but the rest of the "
"fields remain unchanged."
msgstr ""
"この行多相型に注目してください。これは `triangle`が `x`と `y`というプロパティ"
"と、**それに加えて他の任意のプロパティ**を持ったどんなレコードでも受け入れる"
"ということを言っています。 `x`フィールドと `y`フィールドは更新されますが、残"
"りのフィールドは変更されません。"

#. type: Plain text
#: text/chapter12.md:128
#, fuzzy
msgid ""
"This is an example of _record update syntax_. The expression `shape { ... }` "
"creates a new record based on the `shape` record, with the fields inside the "
"braces updated to the specified values. Note that the expressions inside the "
"braces are separated from their labels by equals symbols, not colons like in "
"record literals."
msgstr ""
"これは**レコード更新構文**の例です。 `shape { ... }`という式は、 `shape`を元"
"にして、括弧の中で指定されたように値が更新されたフィールドを持つ新たなレコー"
"ドを作ります。波括弧の中の式はレコードリテラルのようなコロンではなく、等号で"
"ラベルと式を区切って書くことに注意してください。"

#. type: Plain text
#: text/chapter12.md:130
#, fuzzy
msgid ""
"The `translate` function can be used with both the `Rectangle` and `Arc` "
"records, as can be seen in the `Shapes` example."
msgstr ""
"`Shapes`の例からわかるように、 `translate`関数は `Rectangle`レコードと `Arc`"
"レコード双方に対して使うことができます。"

#. type: Plain text
#: text/chapter12.md:132
#, fuzzy
msgid ""
"The third type of path rendered in the `Shapes` example is a piecewise-"
"linear path. Here is the corresponding code:"
msgstr ""
"`Shape`の例で描画される3つめの型は線分ごとのパスです。対応するコードは次のよ"
"うになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:133
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Shapes.purs:path}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:138
#, fuzzy
msgid "There are three functions in use here:"
msgstr "ここでは3つの関数が使われています。"

#. type: Plain text
#: text/chapter12.md:142
#, fuzzy
msgid ""
"- `moveTo` moves the current location of the path to the specified "
"coordinates, - `lineTo` renders a line segment between the current location "
"and the specified coordinates, and updates the current location, - "
"`closePath` completes the path by rendering a line segment joining the "
"current location to the start position."
msgstr ""
"- `moveTo`はパスの現在位置を指定された座標へ移動させます。 - `lineTo`は現在の"
"位置と指定された座標の間に線分を描画し、現在の位置を更新します。 - "
"`closePath`は開始位置と現在位置を結ぶ線分を描画し、パスを閉じます。"

#. type: Plain text
#: text/chapter12.md:144
#, fuzzy
msgid "The result of this code snippet is to fill an isosceles triangle."
msgstr "このコード片を実行すると、二等辺三角形を塗りつぶされます。"

#. type: Plain text
#: text/chapter12.md:146
#, fuzzy
msgid "Build the example by specifying `Example.Shapes` as the main module:"
msgstr ""
"mainモジュールとして`Example.Shapes`を指定して、この例をビルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:147
#, fuzzy, no-wrap
msgid "$ spago bundle-app --main Example.Shapes --to dist/Main.js\n"
msgstr "$ pulp build -O --main Example.Shapes --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:152
#, fuzzy
msgid ""
"and open `html/index.html` again to see the result. You should see the three "
"different types of shapes rendered to the canvas."
msgstr ""
"そしてもう一度 `html/index.html`を開き、結果を確認してください。キャンバスに"
"３つの異なる図形が描画されるはずです。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
#, fuzzy
msgid ""
"(Easy) Experiment with the `strokePath` and `setStrokeStyle` functions in "
"each of the examples so far."
msgstr ""
"(簡単) これまでの例のそれぞれについて、 `strokePath`関数や `setStrokeStyle`関"
"数を使ってみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
#, fuzzy
msgid ""
"(Easy) The `fillPath` and `strokePath` functions can be used to render "
"complex paths with a common style by using a do notation block inside the "
"function argument. Try changing the `Rectangle` example to render two "
"rectangles side-by-side using the same call to `fillPath`. Try rendering a "
"sector of a circle by using a combination of a piecewise-linear path and an "
"arc segment."
msgstr ""
"(簡単) 関数の引数の内部でdo記法ブロックを使うと、 `fillPath`関数と "
"`strokePath`関数で共通のスタイルを持つ複雑なパスを描画することができます。同"
"じ `fillPath`呼び出しで隣り合った２つの矩形を描画するように、 `Rectangle`の"
"コード例を変更してみてください。線分と円弧を組み合わせてを、円の扇形を描画し"
"てみてください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:158
#, fuzzy
msgid "(Medium) Given the following record type:"
msgstr "(やや難しい) 次のような２次元の点を表すレコードが与えられたとします。"

#. type: Plain text
#: text/chapter12.md:162
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     type Point = { x :: Number, y :: Number }\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    type Point = { x :: Number, y :: Number }\n"
"    ```\n"

#. type: Plain text
#: text/chapter12.md:164
#, fuzzy, no-wrap
msgid "     which represents a 2D point, write a function `renderPath` which strokes a closed path constructed from a number of points:\n"
msgstr "    多数の点からなる閉じたパスを描く関数 `renderPath`書いてください。\n"

#. type: Plain text
#: text/chapter12.md:171
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     renderPath\n"
"       :: Context2D\n"
"       -> Array Point\n"
"       -> Effect Unit\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    renderPath :: forall eff. Context2D -> Array Point -> \n"
"                                           Eff (canvas :: Canvas | eff) Unit\n"
"    ```\n"

#. type: Plain text
#: text/chapter12.md:173
#, fuzzy, no-wrap
msgid "     Given a function\n"
msgstr "    次のような関数を考えます。\n"

#. type: Plain text
#: text/chapter12.md:177
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     f :: Number -> Point\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    f :: Number -> Point\n"
"    ```\n"

#. type: Plain text
#: text/chapter12.md:179
#, fuzzy, no-wrap
msgid "     which takes a `Number` between `0` and `1` as its argument and returns a `Point`, write an action which plots `f` by using your `renderPath` function. Your action should approximate the path by sampling `f` at a finite set of points.\n"
msgstr "    この関数は引数として `1`から `0`の間の `Number`をとり、 `Point`を返します。 `renderPath`関数を利用して関数 `f`のグラフを描くアクションを書いてください。そのアクションは有限個の点を `f`からサンプリングすることによって近似しなければなりません。\n"

#. type: Plain text
#: text/chapter12.md:181
#, fuzzy, no-wrap
msgid "     Experiment by rendering different paths by varying the function `f`.\n"
msgstr "    関数 `f`を変更し、異なるパスが描画されることを確かめてください。\n"

#. type: Title ##
#: text/chapter12.md:182
#, fuzzy, no-wrap
msgid "Drawing Random Circles"
msgstr "無作為に円を描く"

#. type: Plain text
#: text/chapter12.md:185
#, fuzzy
msgid ""
"The `Example/Random.purs` file contains an example which uses the `Effect` "
"monad to interleave two different types of side-effect: random number "
"generation, and canvas manipulation. The example renders one hundred "
"randomly generated circles onto the canvas."
msgstr ""
"`Example/Random.purs`ファイルには2種類の異なる副作用が混在した `Eff`モナドを"
"使う例が含まれています。この例では無作為に生成された円をキャンバスに100個描画"
"します。"

#. type: Plain text
#: text/chapter12.md:187
#, fuzzy
msgid ""
"The `main` action obtains a reference to the graphics context as before, and "
"then sets the stroke and fill styles:"
msgstr ""
"`main`アクションはこれまでのようにグラフィックスコンテキストへの参照を取得"
"し、ストロークと塗りつぶしスタイルを設定します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:188
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:style}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:193
#, fuzzy
msgid ""
"Next, the code uses the `for_` function to loop over the integers between "
"`0` and `100`:"
msgstr ""
"次のコードでは `forE`アクションを使って `0`から `100`までの整数について繰り返"
"しをしています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:194
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:for}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:199
#, fuzzy
msgid ""
"On each iteration, the do notation block starts by generating three random "
"numbers distributed between `0` and `1`. These numbers represent the `x` and "
"`y` coordinates, and the radius of a circle:"
msgstr ""
"これらの数は `0`から `1`の間に無作為に分布しており、それぞれ `x`座標、 `y`座"
"標、半径 `r`を表しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:200
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:random}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:205
#, fuzzy
msgid ""
"Next, for each circle, the code creates an `Arc` based on these parameters "
"and finally fills and strokes the arc with the current styles:"
msgstr ""
"次のコードでこれらの変数に基づいて `Arc`を作成し、最後に現在のスタイルに従っ"
"て円弧の塗りつぶしと線描が行われます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:206
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Random.purs:path}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:211
#, fuzzy
msgid ""
"Build this example by specifying the `Example.Random` module as the main "
"module:"
msgstr ""
"mainモジュールとして`Example.Random`を指定して、この例をビルドしましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:212
#, fuzzy, no-wrap
msgid "$ spago bundle-app --main Example.Random --to dist/Main.js\n"
msgstr "$ pulp build -O --main Example.Random --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:217
#, fuzzy
msgid "and view the result by opening `html/index.html`."
msgstr "`html/index.html`を開いて、結果を確認してみましょう。"

#. type: Title ##
#: text/chapter12.md:218
#, fuzzy, no-wrap
msgid "Transformations"
msgstr "座標変換"

#. type: Plain text
#: text/chapter12.md:221
#, fuzzy
msgid ""
"There is more to the canvas than just rendering simple shapes. Every canvas "
"maintains a transformation which is used to transform shapes before "
"rendering. Shapes can be translated, rotated, scaled, and skewed."
msgstr ""
"キャンバスは簡単な図形を描画するだけのものではありません。キャンバスは変換行"
"列を扱うことができ、図形は描画の前に形状を変形してから描画されます。図形は平"
"行移動、回転、拡大縮小、および斜め変形することができます。"

#. type: Plain text
#: text/chapter12.md:223
#, fuzzy
msgid ""
"The `canvas` library supports these transformations using the following "
"functions:"
msgstr ""
"`purescript-canvas`ライブラリではこれらの変換を以下の関数で提供しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:224
#, fuzzy, no-wrap
msgid ""
"translate :: Context2D\n"
"          -> TranslateTransform\n"
"          -> Effect Context2D\n"
"\n"
"rotate    :: Context2D\n"
"          -> Number\n"
"          -> Effect Context2D\n"
"\n"
"scale     :: Context2D\n"
"          -> ScaleTransform\n"
"          -> Effect Context2D\n"
"\n"
"transform :: Context2D\n"
"          -> Transform\n"
"          -> Effect Context2D\n"
msgstr ""
"translate :: forall eff. TranslateTransform -> Context2D\n"
"                                            -> Eff (canvas :: Canvas | eff) Context2D\n"
"rotate    :: forall eff. Number             -> Context2D\n"
"                                            -> Eff (canvas :: Canvas | eff) Context2D\n"
"scale     :: forall eff. ScaleTransform     -> Context2D\n"
"                                            -> Eff (canvas :: Canvas | eff) Context2D\n"
"transform :: forall eff. Transform          -> Context2D\n"
"                                            -> Eff (canvas :: Canvas | eff) Context2D\n"

#. type: Plain text
#: text/chapter12.md:243
#, fuzzy
msgid ""
"The `translate` action performs a translation whose components are specified "
"by the properties of the `TranslateTransform` record."
msgstr ""
"`translate`アクションは `TranslateTransform`レコードのプロパティで指定した大"
"きさだけ平行移動を行います。"

#. type: Plain text
#: text/chapter12.md:245
#, fuzzy
msgid ""
"The `rotate` action performs a rotation around the origin, through some "
"number of radians specified by the first argument."
msgstr ""
"`rotate`アクションは最初の引数で指定されたラジアンの値に応じて原点を中心とし"
"た回転を行います。"

#. type: Plain text
#: text/chapter12.md:247
#, fuzzy
msgid ""
"The `scale` action performs a scaling, with the origin as the center. The "
"`ScaleTransform` record specifies the scale factors along the `x` and `y` "
"axes."
msgstr ""
"`scale`アクションは原点を中心として拡大縮小します。 `ScaleTransform`レコード"
"は `X`軸と `y`軸に沿った拡大率を指定するのに使います。"

#. type: Plain text
#: text/chapter12.md:249
#, fuzzy
msgid ""
"Finally, `transform` is the most general action of the four here. It "
"performs an affine transformation specified by a matrix."
msgstr ""
"最後の `transform`はこの４つのうちで最も一般的なアクションです。このアクショ"
"ンは行列に従ってアフィン変換を行います。"

#. type: Plain text
#: text/chapter12.md:251
#, fuzzy
msgid ""
"Any shapes rendered after these actions have been invoked will automatically "
"have the appropriate transformation applied."
msgstr ""
"これらのアクションが呼び出された後に描画される図形は、自動的に適切な座標変換"
"が適用されます。"

#. type: Plain text
#: text/chapter12.md:253
#, fuzzy
msgid ""
"In fact, the effect of each of these functions is to _post-multiply_ the "
"transformation with the context's current transformation. The result is that "
"if multiple transformations applied after one another, then their effects "
"are actually applied in reverse:"
msgstr ""
"実際には、これらの関数のそれぞれの作用は、コンテキストの現在の変換行列に対し"
"て変換行列を**右から乗算**していきます。つまり、もしある作用の変換をしていく"
"と、その作用は実際には逆順に適用されていきます。次のような座標変換のアクショ"
"ンを考えてみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:254
#, fuzzy, no-wrap
msgid ""
"transformations ctx = do\n"
"  translate ctx { translateX: 10.0, translateY: 10.0 }\n"
"  scale ctx { scaleX: 2.0, scaleY: 2.0 }\n"
"  rotate ctx (Math.tau / 4.0)\n"
"\n"
"  renderScene\n"
msgstr ""
"transformations ctx = do\n"
"  translate { translateX: 10.0, translateY: 10.0 } ctx\n"
"  scale { scaleX: 2.0, scaleY: 2.0 } ctx\n"
"  rotate (Math.pi / 2.0) ctx\n"
"\n"
"  renderScene\n"

#. type: Plain text
#: text/chapter12.md:264
#, fuzzy
msgid ""
"The effect of this sequence of actions is that the scene is rotated, then "
"scaled, and finally translated."
msgstr ""
"このアクションの作用では、まずシーンが回転され、それから拡大縮小され、最後に"
"平行移動されます。　　　　　"

#. type: Title ##
#: text/chapter12.md:265
#, fuzzy, no-wrap
msgid "Preserving the Context"
msgstr "コンテキストの保存"

#. type: Plain text
#: text/chapter12.md:268
#, fuzzy
msgid ""
"A common use case is to render some subset of the scene using a "
"transformation, and then to reset the transformation afterwards."
msgstr ""
"一般的な使い方としては、変換を適用してシーンの一部をレンダリングし、それから"
"その変換を元に戻します。"

#. type: Plain text
#: text/chapter12.md:270
#, fuzzy
msgid ""
"The Canvas API provides the `save` and `restore` methods, which manipulate a "
"_stack_ of states associated with the canvas. `canvas` wraps this "
"functionality into the following functions:"
msgstr ""
"Canvas APIにはキャンバスの状態の**スタック**を操作する `save`と `restore`メ"
"ソッドが備わっています。 `purescript-canvas`ではこの機能を次のような関数で"
"ラップしています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:271
#, fuzzy, no-wrap
msgid ""
"save\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
"\n"
"restore\n"
"  :: Context2D\n"
"  -> Effect Context2D\n"
msgstr ""
"save    :: forall eff. Context2D -> Eff (canvas :: Canvas | eff) Context2D\n"
"restore :: forall eff. Context2D -> Eff (canvas :: Canvas | eff) Context2D\n"

#. type: Plain text
#: text/chapter12.md:282
#, fuzzy
msgid ""
"The `save` action pushes the current state of the context (including the "
"current transformation and any styles) onto the stack, and the `restore` "
"action pops the top state from the stack and restores it."
msgstr ""
"`save`アクションは現在のコンテキストの状態(現在の変換行列や描画スタイル)をス"
"タックにプッシュし、 `restore`アクションはスタックの一番上の状態をポップし、"
"コンテキストの状態を復元します。"

#. type: Plain text
#: text/chapter12.md:284
#, fuzzy
msgid ""
"This allows us to save the current state, apply some styles and "
"transformations, render some primitives, and finally restore the original "
"transformation and state. For example, the following function performs some "
"canvas action, but applies a rotation before doing so, and restores the "
"transformation afterwards:"
msgstr ""
"これらのアクションにより、現在の状態を保存し、いろいろなスタイルや変換を適用"
"し、プリミティブを描画し、最後に元の変換と状態を復元することが可能になりま"
"す。例えば、次の関数はいくつかのキャンバスアクションを実行しますが、その前に"
"回転を適用し、そのあとに変換を復元します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:285
#, fuzzy, no-wrap
msgid ""
"rotated ctx render = do\n"
"  save ctx\n"
"  rotate (Math.tau / 3.0) ctx\n"
"  render\n"
"  restore ctx\n"
msgstr ""
"rotated ctx render = do\n"
"  save ctx\n"
"  rotate Math.pi ctx\n"
"  render\n"
"  restore ctx\n"

#. type: Plain text
#: text/chapter12.md:294
#, fuzzy
msgid ""
"In the interest of abstracting over common use cases using higher-order "
"functions, the `canvas` library provides the `withContext` function, which "
"performs some canvas action while preserving the original context state:"
msgstr ""
"こういったよくある使いかたの高階関数を利用した抽象化として、 `purescript-"
"canvas`ライブラリでは元のコンテキスト状態を維持しながらいくつかのキャンバスア"
"クションを実行する `withContext`関数が提供されています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:295
#, no-wrap
msgid ""
"withContext\n"
"  :: Context2D\n"
"  -> Effect a\n"
"  -> Effect a\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:303
#, fuzzy
msgid ""
"We could rewrite the `rotated` function above using `withContext` as follows:"
msgstr ""
"`withContext`を使うと、先ほどの `rotated`関数を次のように書き換えることができ"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:304
#, fuzzy, no-wrap
msgid ""
"rotated ctx render =\n"
"  withContext ctx do\n"
"    rotate (Math.tau / 3.0) ctx\n"
"    render\n"
msgstr ""
"rotated ctx render = withContext ctx do\n"
"    rotate Math.pi ctx\n"
"    render\n"

#. type: Title ##
#: text/chapter12.md:311
#, fuzzy, no-wrap
msgid "Global Mutable State"
msgstr "大域的な変更可能状態"

#. type: Plain text
#: text/chapter12.md:314
#, fuzzy
msgid ""
"In this section, we'll use the `refs` package to demonstrate another effect "
"in the `Effect` monad."
msgstr ""
"この節では `purescript-refs`パッケージを使って `Eff`モナドの別の作用について"
"実演してみます。"

#. type: Plain text
#: text/chapter12.md:316
#, fuzzy
msgid ""
"The `Effect.Ref` module provides a type constructor for global mutable "
"references, and an associated effect:"
msgstr ""
"`Control.Monad.Eff.Ref`モジュールでは大域的に変更可能な参照のための型構築子、"
"および関連する作用を提供します。"

#. type: Fenced code block (text)
#: text/chapter12.md:317
#, fuzzy, no-wrap
msgid ""
"> import Effect.Ref\n"
"\n"
"> :kind Ref\n"
"Type -> Type\n"
msgstr ""
"> :kind Record\n"
"# Type -> Type\n"

#. type: Plain text
#: text/chapter12.md:325
msgid ""
"A value of type `Ref a` is a mutable reference cell containing a value of "
"type `a`, used to track global mutation. As such, it should be used "
"sparingly."
msgstr ""

#. type: Plain text
#: text/chapter12.md:327
#, fuzzy
msgid ""
"The `Example/Refs.purs` file contains an example which uses a `Ref` to track "
"mouse clicks on the `canvas` element."
msgstr ""
"`Example/Refs.purs`ファイルには `canvas`要素上のマウスクリックを追跡するのに "
"`Ref`作用を使用する例が含まれています。"

#. type: Plain text
#: text/chapter12.md:329
#, fuzzy
msgid ""
"The code starts by creating a new reference containing the value `0`, by "
"using the `new` action:"
msgstr ""
"このコー​​ドでは最初に `newRef`アクションを使って値 `0`で初期化された領域への新"
"しい参照を作成しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:330
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:clickCount}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:335
#, fuzzy
msgid ""
"Inside the click event handler, the `modify` action is used to update the "
"click count, and the updated value is returned."
msgstr ""
"クリックイベントハンドラの内部では、 `modifyRef`アクションを使用してクリック"
"数を更新しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:336
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:count}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:341
#, fuzzy
msgid ""
"In the `render` function, the click count is used to determine the "
"transformation applied to a rectangle:"
msgstr "`render`関数では、クリック数に応じて変換を矩形に適用しています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:342
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/Refs.purs:withContext}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:347
#, fuzzy
msgid ""
"This action uses `withContext` to preserve the original transformation, and "
"then applies the following sequence of transformations (remember that "
"transformations are applied bottom-to-top):"
msgstr ""
"このアクションでは元の変換を維持するために `withContext`を使用しており、それ"
"から続く変換を順に適用しています(変換が下から上に適用されることを思い出してく"
"ださい)。"

#. type: Plain text
#: text/chapter12.md:352
#, fuzzy
msgid ""
"- The rectangle is translated through `(-100, -100)` so that its center lies "
"at the origin.  - The rectangle is scaled around the origin.  - The "
"rectangle is rotated through some multiple of `10` degrees around the "
"origin.  - The rectangle is translated through `(300, 300)` so that it "
"center lies at the center of the canvas."
msgstr ""
"- 中心が原点に来るように、矩形を `(-100, -100)`平行移動します。 - 矩形を原点"
"を中心に拡大縮小します。 - 矩形を原点を中心に `10`度の倍数だけ回転します。 - "
"中心がキャンバスの中心に位置するように長方形を `(300、300)`だけ平行移動しま"
"す。"

#. type: Plain text
#: text/chapter12.md:354
#, fuzzy
msgid "Build the example:"
msgstr "このコード例をビルドしてみましょう。"

#. type: Fenced code block (text)
#: text/chapter12.md:355
#, fuzzy, no-wrap
msgid "$ spago bundle-app --main Example.Refs --to dist/Main.js\n"
msgstr "$ pulp build -O --main Example.Refs --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:360
#, fuzzy
msgid ""
"and open the `html/index.html` file. If you click the canvas repeatedly, you "
"should see a green rectangle rotating around the center of the canvas."
msgstr ""
"`html/index.html`ファイルを開いてみましょう。何度かキャンバスをクリックする"
"と、キャンバスの中心の周りを回転する緑の四角形が表示されるはずです。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
#, fuzzy
msgid ""
"(Easy) Write a higher-order function which strokes and fills a path "
"simultaneously. Rewrite the `Random.purs` example using your function."
msgstr ""
"(簡単) パスの線描と塗りつぶしを同時に行う高階関数を書いてください。その関数を"
"使用して `Random.purs`例を書きなおしてください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
#, fuzzy
msgid ""
"(Medium) Use `Random` and `Dom` to create an application which renders a "
"circle with random position, color and radius to the canvas when the mouse "
"is clicked."
msgstr ""
"(やや難しい)`Random`作用と `DOM`作用を使用して、マウスがクリックされたときに"
"キャンバスに無作為な位置、色、半径の円を描画するアプリケーションを作成してく"
"ださい。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:366
#, fuzzy
msgid ""
"(Medium) Write a function which transforms the scene by rotating it around a "
"point with specified coordinates. _Hint_: use a translation to first "
"translate the scene to the origin."
msgstr ""
"(やや難しい) シーンを指定された座標を中心に回転する関数を書いてください。**ヒ"
"ント**：最初にシーンを原点まで平行移動しましょう。"

#. type: Title ##
#: text/chapter12.md:367
#, fuzzy, no-wrap
msgid "L-Systems"
msgstr "L-Systems"

#. type: Plain text
#: text/chapter12.md:370
#, fuzzy
msgid ""
"In this final example, we will use the `canvas` package to write a function "
"for rendering _L-systems_ (or _Lindenmayer systems_)."
msgstr ""
"この章の最後の例として、 `purescript-canvas`パッケージを使用して**L-"
"systems**(Lindenmayer systems)を描画する関数を記述します。"

#. type: Plain text
#: text/chapter12.md:372
#, fuzzy
msgid ""
"An L-system is defined by an _alphabet_, an initial sequence of letters from "
"the alphabet, and a set of _production rules_. Each production rule takes a "
"letter of the alphabet and returns a sequence of replacement letters. This "
"process is iterated some number of times starting with the initial sequence "
"of letters."
msgstr ""
"L-Systemsは**アルファベット**、つまり初期状態となるアルファベットの文字列と、"
"**生成規則**の集合で定義されています。各生成規則は、アルファベットの文字をと"
"り、それを置き換える文字の配列を返します。この処理は文字の初期配列から始ま"
"り、複数回繰り返されます。"

#. type: Plain text
#: text/chapter12.md:374
#, fuzzy
msgid ""
"If each letter of the alphabet is associated with some instruction to "
"perform on the canvas, the L-system can be rendered by following the "
"instructions in order."
msgstr ""
"もしアルファベットの各文字がキャンバス上で実行される命令と対応付けられていれ"
"ば、その指示に順番に従うことでL-Systemsを描画することができます。"

#. type: Plain text
#: text/chapter12.md:376
#, fuzzy
msgid ""
"For example, suppose the alphabet consists of the letters `L` (turn left), "
"`R` (turn right) and `F` (move forward). We might define the following "
"production rules:"
msgstr ""
"たとえば、アルファベットが文字 `L`(左回転)、 `R`(右回転)、 `F`(前進)で構成さ"
"れていたとします。また、次のような生成規則を定義します。"

#. type: Fenced code block (text)
#: text/chapter12.md:377
#, fuzzy, no-wrap
msgid ""
"L -> L\n"
"R -> R\n"
"F -> FLFRRFLF\n"
msgstr ""
"L -> L\n"
"R -> R\n"
"F -> FLFRRFLF\n"

#. type: Plain text
#: text/chapter12.md:384
#, fuzzy
msgid ""
"If we start with the initial sequence \"FRRFRRFRR\" and iterate, we obtain "
"the following sequence:"
msgstr ""
"配列 \"FRRFRRFRR\" から始めて処理を繰り返すと、次のような経過を辿ります。"

#. type: Fenced code block (text)
#: text/chapter12.md:385
#, fuzzy, no-wrap
msgid ""
"FRRFRRFRR\n"
"FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR\n"
"FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...\n"
msgstr ""
"FRRFRRFRR\n"
"FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR\n"
"FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...\n"

#. type: Plain text
#: text/chapter12.md:392
#, fuzzy
msgid ""
"and so on. Plotting a piecewise-linear path corresponding to this set of "
"instruction approximates a curve called the _Koch curve_. Increasing the "
"number of iterations increases the resolution of the curve."
msgstr ""
"この命令群に対応する線分パスをプロットすると、**コッホ曲線**と呼ばれる曲線に"
"近似します。反復回数を増やすと、曲線の解像度が増加していきます。"

#. type: Plain text
#: text/chapter12.md:394
#, fuzzy
msgid "Let's translate this into the language of types and functions."
msgstr "それでは型と関数の言語へとこれを翻訳してみましょう。"

#. type: Plain text
#: text/chapter12.md:396
#, fuzzy
msgid "We can represent our alphabet of letters with the following ADT:"
msgstr ""
"アルファベットの選択肢は型の選択肢によって表すことができます。今回の例では、"
"以下のような型で定義することができます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:397
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:letter}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:402
#, fuzzy
msgid ""
"This data type defines one data constructor for each letter in our alphabet."
msgstr ""
"このデータ型では、アルファベットの文字ごとに１つづつデータ構築子が定義されて"
"います。"

#. type: Plain text
#: text/chapter12.md:404
#, fuzzy
msgid ""
"How can we represent the initial sequence of letters? Well, that's just an "
"array of letters from our alphabet, which we will call a `Sentence`:"
msgstr ""
"文字の初期配列はどのように表したらいいでしょうか。単なるアルファベットの配列"
"でいいでしょう。これを `Sentence`と呼ぶことにします。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:405
#, no-wrap
msgid ""
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:sentence}}\n"
"\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:initial}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:412
#, fuzzy
msgid ""
"Our production rules can be represented as a function from `Letter` to "
"`Sentence` as follows:"
msgstr "生成規則は `Alphabet`から `Sentence`への関数として表すことができます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:413
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:productions}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:418
#, fuzzy
msgid "This is just copied straight from the specification above."
msgstr "これはまさに上記の仕様をそのまま書き写したものです。"

#. type: Plain text
#: text/chapter12.md:420
#, fuzzy
msgid ""
"Now we can implement a function `lsystem` which will take a specification in "
"this form, and render it to the canvas. What type should `lsystem` have? "
"Well, it needs to take values like `initial` and `productions` as arguments, "
"as well as a function which can render a letter of the alphabet to the "
"canvas."
msgstr ""
"これで、この形式の仕様を受け取りキャンバスに描画する関数 `lsystem`を実装する"
"ことができます。 `lsystem`はどのような型を持っているべきでしょうか。この関数"
"は初期状態 `initial`と生成規則 `productions`のような値だけでなく、アルファ"
"ベットの文字をキャンバスに描画する関数を引数に取る必要があります。"

#. type: Plain text
#: text/chapter12.md:422
#, fuzzy
msgid "Here is a first approximation to the type of `lsystem`:"
msgstr ""
"`lsystem`の型の最初の大まかな設計としては、次のようになるかもしれません。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:423
#, no-wrap
msgid ""
"Sentence\n"
"-> (Letter -> Sentence)\n"
"-> (Letter -> Effect Unit)\n"
"-> Int\n"
"-> Effect Unit\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:432
#, fuzzy
msgid ""
"The first two argument types correspond to the values `initial` and "
"`productions`."
msgstr "最初の2つの引数の型は、値 `initial`と `productions`に対応しています。"

#. type: Plain text
#: text/chapter12.md:434
#, fuzzy
msgid ""
"The third argument represents a function which takes a letter of the "
"alphabet and _interprets_ it by performing some actions on the canvas. In "
"our example, this would mean turning left in the case of the letter `L`, "
"turning right in the case of the letter `R`, and moving forward in the case "
"of a letter `F`."
msgstr ""
"3番目の引数は、アルファベットの文字を取り、キャンバス上のいくつかのアクション"
"を実行することによって**翻訳**する関数を表します。この例では、文字 `L`は左回"
"転、文字 `R`で右回転、文字 `F`は前進を意味します。"

#. type: Plain text
#: text/chapter12.md:436
#, fuzzy
msgid ""
"The final argument is a number representing the number of iterations of the "
"production rules we would like to perform."
msgstr "最後の引数は、実行したい生成規則の繰り返し回数を表す数です。"

#. type: Plain text
#: text/chapter12.md:438
#, fuzzy
msgid ""
"The first observation is that the `lsystem` function should work for only "
"one type of `Letter`, but for any type, so we should generalize our type "
"accordingly. Let's replace `Letter` and `Sentence` with `a` and `Array a` "
"for some quantified type variable `a`:"
msgstr ""
"最初に気づくことは、現在の `lsystem`関数は `Alphabet`型だけで機能しますが、ど"
"んなアルファベットについても機能すべきですから、この型はもっと一般化されるべ"
"きです。それでは、量子化された型変数 `a`について、 `Alphabet`と `Sentence`を "
"`a`と `Array a`で置き換えましょう。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:439
#, fuzzy, no-wrap
msgid ""
"forall a. Array a\n"
"          -> (a -> Array a)\n"
"          -> (a -> Effect Unit)\n"
"          -> Int\n"
"          -> Effect Unit\n"
msgstr ""
"forall a eff. Array a\n"
"           -> (a -> Array a)\n"
"           -> (a -> Eff (canvas :: Canvas | eff) Unit)\n"
"           -> Int\n"
"           -> Eff (canvas :: Canvas | eff) Unit\n"

#. type: Plain text
#: text/chapter12.md:448
#, fuzzy
msgid ""
"The second observation is that, in order to implement instructions like "
"\"turn left\" and \"turn right\", we will need to maintain some state, "
"namely the direction in which the path is moving at any time. We need to "
"modify our function to pass the state through the computation. Again, the "
"`lsystem` function should work for any type of state, so we will represent "
"it using the type variable `s`."
msgstr ""
"次に気付くこととしては、「左回転」と「右回転」のような命令を実装するために"
"は、いくつかの状態を管理する必要があります。具体的に言えば、その時点でパスが"
"向いている方向を状態として持たなければなりません。計算を通じて状態を関数に渡"
"すように変更する必要があります。ここでも `lsystem`関数は状態がどんな型でも動"
"作しなければなりませんから、型変数 `s`を使用してそれを表しています。"

#. type: Plain text
#: text/chapter12.md:450
#, fuzzy
msgid "We need to add the type `s` in three places:"
msgstr "型 `s`を追加する必要があるのは3箇所で、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:451
#, fuzzy, no-wrap
msgid ""
"forall a s. Array a\n"
"            -> (a -> Array a)\n"
"            -> (s -> a -> Effect s)\n"
"            -> Int\n"
"            -> s\n"
"            -> Effect s\n"
msgstr ""
"forall a s eff. Array a\n"
"             -> (a -> Array a)\n"
"             -> (s -> a -> Eff (canvas :: Canvas | eff) s)\n"
"             -> Int\n"
"             -> s\n"
"             -> Eff (canvas :: Canvas | eff) s\n"

#. type: Plain text
#: text/chapter12.md:461
#, fuzzy
msgid ""
"Firstly, the type `s` was added as the type of an additional argument to "
"`lsystem`. This argument will represent the initial state of the L-system."
msgstr ""
"まず追加の引数の型として `lsystem`に型 `s`が追加されています。この引数はL-"
"Systemの初期状態を表しています。"

#. type: Plain text
#: text/chapter12.md:463
#, fuzzy
msgid ""
"The type `s` also appears as an argument to, and as the return type of the "
"interpretation function (the third argument to `lsystem`). The "
"interpretation function will now receive the current state of the L-system "
"as an argument, and will return a new, updated state as its return value."
msgstr ""
"型 `s`は引数にも現れますが、翻訳関数(`lsystem`の第3引数)の返り値の型としても"
"現れます。翻訳関数は今のところ、引数としてL-Systemの現在の状態を受け取り、返"
"り値として更新された新しい状態を返します。"

#. type: Plain text
#: text/chapter12.md:465
#, fuzzy
msgid ""
"In the case of our example, we can define use following type to represent "
"the state:"
msgstr ""
"この例の場合では、次のような型を使って状態を表す型を定義することができます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:466
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:state}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:471
#, fuzzy
msgid ""
"The properties `x` and `y` represent the current position of the path, and "
"the `theta` property represents the current direction of the path, specified "
"as the angle between the path direction and the horizontal axis, in radians."
msgstr ""
"プロパティ `x`と `y`はパスの現在の位置を表しており、プロパティ `theta`は現在"
"の向きを表しており、ラジアンで表された水平線に対するパスの角度です。"

#. type: Plain text
#: text/chapter12.md:473
#, fuzzy
msgid "The initial state of the system might be specified as follows:"
msgstr "システムの初期状態としては次のようなものが考えられます。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:474
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:initialState}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:479
#, fuzzy
msgid ""
"Now let's try to implement the `lsystem` function. We will find that its "
"definition is remarkably simple."
msgstr ""
"それでは、 `lsystem`関数を実装してみます。定義はとても単純であることがわかる"
"でしょう。"

#. type: Plain text
#: text/chapter12.md:481
#, fuzzy
msgid ""
"It seems reasonable that `lsystem` should recurse on its fourth argument (of "
"type `Int`). On each step of the recursion, the current sentence will "
"change, having been updated by using the production rules. With that in "
"mind, let's begin by introducing names for the function arguments, and "
"delegating to a helper function:"
msgstr ""
"`lsystem`は第４引数の値(型 `Number`)に応じて再帰するのが良さそうです。再帰の"
"各ステップでは、生成規則に従って状態が更新され、現在の文が変化していきます。"
"このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を"
"移譲することから始めましょう。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:482
#, fuzzy, no-wrap
msgid ""
"lsystem :: forall a s\n"
"         . Array a\n"
"        -> (a -> Array a)\n"
"        -> (s -> a -> Effect s)\n"
"        -> Int\n"
"        -> s\n"
"        -> Effect s\n"
"{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_impl}}\n"
msgstr ""
"lsystem :: forall a m s . Monad m =>\n"
"           Array a\n"
"        -> (a -> Array a)\n"
"        -> (s -> a -> m s)\n"
"        -> Int\n"
"        -> s\n"
"        -> m s\n"

#. type: Plain text
#: text/chapter12.md:494
#, fuzzy
msgid ""
"The `go` function works by recursion on its second argument. There are two "
"cases: when `n` is zero, and when `n` is non-zero."
msgstr ""
"`go`関数は第2引数に応じて再帰することで動きます。 `n`がゼロであるときと `n`が"
"ゼロでないときの2つの場合で分岐します。"

#. type: Plain text
#: text/chapter12.md:496
#, fuzzy, no-wrap
msgid "In the first case, the recursion is complete, and we simply need to interpret the current sentence according to the interpretation function. We have a sentence of type `Array a`, a state of type `s`, and a function of type `s -> a -> Effect s`. This sounds like a job for the `foldM` function which we defined earlier, and which is available from the `control` package:\n"
msgstr ""
"`n`がゼロの場合では再帰は完了し、解釈関数に応じて現在の文を解釈します。\n"
"ここでは引数として与えられている、型 `Array a`の文、型 `s`の状態、型 `s -> a -> Eff (canvas :: Canvas | eff) s`の関数を参照することができます。\n"
"これらの引数の型を考えると、以前定義した `foldM`の呼び出しにちょうど対応していることがわかります。 `foldM`は `purescript-control`パッケージでも定義されています。\n"

#. type: Fenced code block (haskell)
#: text/chapter12.md:497
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_0}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:502
#, fuzzy
msgid ""
"What about in the non-zero case? In that case, we can simply apply the "
"production rules to each letter of the current sentence, concatenate the "
"results, and repeat by calling `go` recursively:"
msgstr ""
"ゼロでない場合ではどうでしょうか。その場合は、単に生成規則を現在の文のそれぞ"
"れの文字に適用して、その結果を連結し、そしてこの処理を再帰します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:503
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_go_s_i}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:508
#, fuzzy
msgid ""
"That's it! Note how the use of higher order functions like `foldM` and "
"`concatMap` allowed us to communicate our ideas concisely."
msgstr ""
"これだけです！`foldM`や `concatMap`のような高階関数を使うと、このようにアイデ"
"アを簡潔に表現することができるのです。"

#. type: Plain text
#: text/chapter12.md:510
#, fuzzy
msgid ""
"However, we're not quite done. The type we have given is actually still too "
"specific. Note that we don't use any canvas operations anywhere in our "
"implementation. Nor do we make use of the structure of the `Effect` monad at "
"all. In fact, our function works for _any_ monad `m`!"
msgstr ""
"しかし、まだ完全に終わったわけではありません。ここで与えた型は、実際はまだ特"
"殊化されすぎています。この定義ではキャンバスの操作が実装のどこにも使われてい"
"ないことに注目してください。それに、まったく `Eff`モナドの構造を利用していま"
"せん。実際には、この関数は**どんな**モナド `m`についても動作するのです！"

#. type: Plain text
#: text/chapter12.md:512
#, fuzzy
msgid ""
"Here is the more general type of `lsystem`, as specified in the accompanying "
"source code for this chapter:"
msgstr ""
"この章に添付されたソースコードで定義されている、 `lsystem`のもっと一般的な型"
"は次のようになっています。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:513
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:lsystem_anno}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:518
#, fuzzy
msgid ""
"We can understand this type as saying that our interpretation function is "
"free to have any side-effects at all, captured by the monad `m`. It might "
"render to the canvas, or print information to the console, or support "
"failure or multiple return values. The reader is encouraged to try writing L-"
"systems which use these various types of side-effect."
msgstr ""
"この型が言っているのは、この翻訳関数はモナド `m`で追跡される任意の副作用を"
"まったく自由に持つことができる、ということだと理解することができます。キャン"
"バスに描画したり、またはコンソールに情報を出力するかもしれませんし、失敗や複"
"数の戻り値に対応しているかもしれません。こういった様々な型の副作用を使ったL-"
"Systemを記述してみることを読者にお勧めします。"

#. type: Plain text
#: text/chapter12.md:520
#, fuzzy
msgid ""
"This function is a good example of the power of separating data from "
"implementation. The advantage of this approach is that we gain the freedom "
"to interpret our data in multiple different ways. We might even factor "
"`lsystem` into two smaller functions: the first would build the sentence "
"using repeated application of `concatMap`, and the second would interpret "
"the sentence using `foldM`. This is also left as an exercise for the reader."
msgstr ""
"この関数は実装からデータを分離することの威力を示す良い例となっています。この"
"手法の利点は、複数の異なる方法でデータを解釈する自由が得られることです。 "
"`lsystem`は２つの小さな関数へと分解することができるかもしれません。ひとつめ"
"は `concatMap`の適用の繰り返しを使って文を構築するもので、ふたつめは `foldM`"
"を使って文を翻訳するものです。これは読者の演習として残しておきます。"

#. type: Plain text
#: text/chapter12.md:522
#, fuzzy, no-wrap
msgid "Let's complete our example by implementing its interpretation function. The type of `lsystem` tells us that its type signature must be `s -> a -> m s` for some types `a` and `s` and a type constructor `m`. We know that we want `a` to be `Letter` and `s` to be `State`, and for the monad `m` we can choose `Effect`. This gives us the following type:\n"
msgstr "それでは翻訳関数を実装して、この章の例を完成させましょう​​。 `lsystem`の型は型シグネチャが言っているのは、翻訳関数の型は、何らかの型 `a`と `s`、型構築子 `m`について、 `s -> a -> m s`でなければならないということです。今回は `a`を `Alphabet`、 `s`を `State`、モナド `m`を `Eff (canvas :: Canvas)`というように選びたいということがわかっています。これにより次のような型になります。\n"

#. type: Fenced code block (haskell)
#: text/chapter12.md:523
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpret_anno}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:528
#, fuzzy
msgid ""
"To implement this function, we need to handle the three data constructors of "
"the `Letter` type. To interpret the letters `L` (move left) and `R` (move "
"right), we simply have to update the state to change the angle `theta` "
"appropriately:"
msgstr ""
"この関数を実装するには、 `Alphabet`型の3つのデータ構築子それぞれについて処理"
"する必要があります。文字 `L`(左回転)と `R`(右回転)の解釈では、 `theta`を適切"
"な角度へ変更するように状態を更新するだけです。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:529
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretLR}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:534
#, fuzzy
msgid ""
"To interpret the letter `F` (move forward), we can calculate the new "
"position of the path, render a line segment, and update the state, as "
"follows:"
msgstr ""
"文字 `F`(前進)を解釈するには、パスの新しい位置を計算し、線分を描画し、状態を"
"次のように更新します。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:535
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:interpretF}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:540
#, fuzzy
msgid ""
"Note that in the source code for this chapter, the `interpret` function is "
"defined using a `let` binding inside the `main` function, so that the name "
"`ctx` is in scope. It would also be possible to move the context into the "
"`State` type, but this would be inappropriate because it is not a changing "
"part of the state of the system."
msgstr ""
"この章のソースコードでは、名前 `ctx`を参照できるようにするために、 "
"`interpret`関数は `main`関数内で `let`束縛を使用して定義されていることに注意"
"してください。 `State`型がコンテキストを持つように変更することは可能でしょう"
"が、それはこのシステムの状態の変化部分ではないので不適切でしょう。"

#. type: Plain text
#: text/chapter12.md:542
#, fuzzy
msgid "To render this L-system, we can simply use the `strokePath` action:"
msgstr ""
"このL-Systemsを描画するには、次のような `strokePath`アクションを使用するだけ"
"です。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:543
#, no-wrap
msgid "{{#include ../exercises/chapter12/src/Example/LSystem.purs:strokePath}}\n"
msgstr ""

#. type: Plain text
#: text/chapter12.md:548
#, fuzzy
msgid "Compile the L-system example using"
msgstr "L-Systemをコンパイルし、"

#. type: Fenced code block (text)
#: text/chapter12.md:549
#, fuzzy, no-wrap
msgid "$ spago bundle-app --main Example.LSystem --to dist/Main.js\n"
msgstr "$ pulp build -O --main Example.LSystem --to dist/Main.js\n"

#. type: Plain text
#: text/chapter12.md:554
#, fuzzy
msgid ""
"and open `html/index.html`. You should see the Koch curve rendered to the "
"canvas."
msgstr ""
"`html/index.html`を開いてみましょう。キャンバスにコッホ曲線が描画されるのがわ"
"かると思います。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
#, fuzzy
msgid ""
"(Easy) Modify the L-system example above to use `fillPath` instead of "
"`strokePath`. _Hint_: you will need to include a call to `closePath`, and "
"move the call to `moveTo` outside of the `interpret` function."
msgstr ""
"(簡単)`strokePath`の代わりに `fillPath`を使用するように、上のL-Systemsの例を"
"変更してください。**ヒント**：`closePath`の呼び出しを含め、 `moveTo`の呼び出"
"しを `interpret`関数の外側に移動する必要があります。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
#, fuzzy
msgid ""
"(Easy) Try changing the various numerical constants in the code, to "
"understand their effect on the rendered system."
msgstr ""
"(簡単) 描画システムへの影響を理解するために、コード中の様々な数値の定数を変更"
"してみてください。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
#, fuzzy
msgid ""
"(Medium) Break the `lsystem` function into two smaller functions. The first "
"should build the final sentence using repeated application of `concatMap`, "
"and the second should use `foldM` to interpret the result."
msgstr ""
"(やや難しい)`lsystem`関数を2つの小さな関数に分割してください。ひとつめは "
"`concatMap`の適用の繰り返しを使用して最終的な結果を構築するもので、ふたつめ"
"は `foldM`を使用して結果を解釈するものでなくてはなりません。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
#, fuzzy
msgid ""
"(Medium) Add a drop shadow to the filled shape, by using the "
"`setShadowOffsetX`, `setShadowOffsetY`, `setShadowBlur` and `setShadowColor` "
"actions. _Hint_: use PSCi to find the types of these functions."
msgstr ""
"(やや難しい)`setShadowOffsetX`アクション、 `setShadowOffsetY`アクション、 "
"`setShadowBlur`アクション、 `setShadowColor`アクションを使い、塗りつぶされた"
"図形にドロップシャドウを追加してください。**ヒント**：`PSCi`を使って、これら"
"の関数の型を調べてみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter12.md:562
#, fuzzy
msgid ""
"(Medium) The angle of the corners is currently a constant (`tau/6`). "
"Instead, it can be moved into the `Letter` data type, which allows it to be "
"changed by the production rules:"
msgstr ""
"(やや難しい) 向きを変えるときの角度の大きさは今のところ一定(`pi/3`)です。その"
"代わりに、 `Alphabet`データ型の中に角度の大きさを追加して、生成規則によって角"
"度を変更できるようにしてください。"

#. type: Plain text
#: text/chapter12.md:565
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     type Angle = Number\n"
msgstr ""
"    ```haskell\n"
"    type Angle = Number\n"

#. type: Plain text
#: text/chapter12.md:568
#, fuzzy, no-wrap
msgid ""
"     data Letter = L Angle | R Angle | F\n"
"     ```\n"
msgstr ""
"    data Alphabet = L Angle | R Angle | F Angle\n"
"    ```\n"

#. type: Plain text
#: text/chapter12.md:571
#, fuzzy, no-wrap
msgid ""
"     How can this new information be used in the production rules to create interesting shapes?\n"
" 1. (Difficult) An L-system is given by an alphabet with four letters: `L` (turn left through 60 degrees), `R` (turn right through 60 degrees), `F` (move forward) and `M` (also move forward).\n"
msgstr ""
"    生成規則でこの新しい情報を使うと、どんな面白い図形を作ることができるでしょうか。\n"
"1. (難しい)`L`(60度左回転 )、 `R`(60度右回転)、 `F`(前進)、 `M`(これも前進)という４つの文字からなるアルファベットでL-Systemが与えられたとします。\n"

#. type: Plain text
#: text/chapter12.md:573
#, fuzzy, no-wrap
msgid "     The initial sentence of the system is the single letter `M`.\n"
msgstr "    このシステムの文の初期状態は、単一の文字 `M`です。\n"

#. type: Plain text
#: text/chapter12.md:575
#, fuzzy, no-wrap
msgid "     The production rules are specified as follows:\n"
msgstr "    このシステムの生成規則は次のように指定されています。\n"

#. type: Plain text
#: text/chapter12.md:582
#, fuzzy, no-wrap
msgid ""
"     ```text\n"
"     L -> L\n"
"     R -> R\n"
"     F -> FLMLFRMRFRMRFLMLF\n"
"     M -> MRFRMLFLMLFLMRFRM\n"
"     ```\n"
msgstr ""
"    ```text\n"
"    L -> L\n"
"    R -> R\n"
"    F -> FLMLFRMRFRMRFLMLF\n"
"    M -> MRFRMLFLMLFLMRFRM\n"
"    ```\n"

#. type: Plain text
#: text/chapter12.md:584
#, fuzzy, no-wrap
msgid "     Render this L-system. _Note_: you will need to decrease the number of iterations of the production rules, since the size of the final sentence grows exponentially with the number of iterations.\n"
msgstr "    このL-Systemを描画してください。**注意**：最後の文のサイズは反復回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を削減することが必要になります。\n"

#. type: Plain text
#: text/chapter12.md:586
#, fuzzy, no-wrap
msgid "     Now, notice the symmetry between `L` and `M` in the production rules. The two \"move forward\" instructions can be differentiated using a `Boolean` value using the following alphabet type:\n"
msgstr "    ここで、生成規則における `L`と `M`の間の対称性に注目してください。ふたつの「前進」命令は、次のようなアルファベット型を使用すると、 `Boolean`値を使って区別することができます。\n"

#. type: Plain text
#: text/chapter12.md:590
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     data Letter = L | R | F Boolean\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    data Alphabet = L | R | F Boolean\n"
"    ```\n"

#. type: Plain text
#: text/chapter12.md:593
#, fuzzy, no-wrap
msgid ""
"     Implement this L-system again using this representation of the alphabet.\n"
" 1. (Difficult) Use a different monad `m` in the interpretation function. You might try using `Effect.Console` to write the L-system onto the console, or using `Effect.Random` to apply random \"mutations\" to the state type.\n"
msgstr ""
"    このアルファベットの表現を使用して、もう一度このL-Systemを実装してください。\n"
"1. (難しい) 翻訳関数で別のモナド `m`を使ってみましょう。 `Trace`作用を利用してコンソール上にL-Systemを出力したり、 `Random`作用を利用して状態の型に無作為の突然変異を適用したりしてみてください。\n"

#. type: Plain text
#: text/chapter12.md:597
#, fuzzy
msgid ""
"In this chapter, we learned how to use the HTML5 Canvas API from PureScript "
"by using the `canvas` library. We also saw a practical demonstration of many "
"of the techniques we have learned already: maps and folds, records and row "
"polymorphism, and the `Effect` monad for handling side-effects."
msgstr ""
"この章では、 `purescript-canvas`ライブラリを使用することにより、PureScriptか"
"らHTML5 Canvas APIを使う方法について学びました。マップや畳み込み、レコードと"
"行多型、副作用を扱うための `Eff`モナドなど、これまで学んできた手法を利用した"
"実用的な例について多く見ました。"

#. type: Plain text
#: text/chapter12.md:599
#, fuzzy
msgid ""
"The examples also demonstrated the power of higher-order functions and "
"_separating data from implementation_. It would be possible to extend these "
"ideas to completely separate the representation of a scene from its "
"rendering function, using an algebraic data type, for example:"
msgstr ""
"この章の例では、高階関数の威力を示すとともに、**実装からのデータの分離**も実"
"演してみせました。これは例えば、代数データ型を使用してこれらの概念を次のよう"
"に拡張し、描画関数からシーンの表現を完全に分離できるようになります。"

#. type: Fenced code block (haskell)
#: text/chapter12.md:600
#, fuzzy, no-wrap
msgid ""
"data Scene\n"
"  = Rect Rectangle\n"
"  | Arc Arc\n"
"  | PiecewiseLinear (Array Point)\n"
"  | Transformed Transform Scene\n"
"  | Clipped Rectangle Scene\n"
"  | ...\n"
msgstr ""
"data Scene = Rect Rectangle\n"
"           | Arc Arc\n"
"           | PiecewiseLinear (Array Point)\n"
"           | Transformed Transform Scene\n"
"           | Clipped Rectangle Scene\n"
"           | ...\n"

#. type: Plain text
#: text/chapter12.md:611
#, fuzzy
msgid ""
"This approach is taken in the `drawing` package, and it brings the "
"flexibility of being able to manipulate the scene as data in various ways "
"before rendering."
msgstr ""
"この手法は `purescript-drawing`パッケージでも採用されており、描画前にさまざま"
"な方法でデータとしてシーンを操作することができるという柔軟性をもたらしていま"
"す。"

#. type: Plain text
#: text/chapter12.md:612
msgid ""
"For examples of games rendered to the canvas, see the \"Behavior\" and "
"\"Signal\" recipes in the [cookbook](https://github.com/JordanMartinez/"
"purescript-cookbook/blob/master/README.md#recipes)."
msgstr ""

#. type: Title #
#: text/chapter13.md:1
#, fuzzy, no-wrap
msgid "Generative Testing"
msgstr "テストの自動生成"

#. type: Plain text
#: text/chapter13.md:6
#, fuzzy
msgid ""
"In this chapter, we will see a particularly elegant application of type "
"classes to the problem of testing. Instead of testing our code by telling "
"the compiler _how_ to test, we simply assert _what_ properties our code "
"should have. Test cases can be generated randomly from this specification, "
"using type classes to hide the boilerplate code of random data generation. "
"This is called _generative testing_ (or _property-based testing_), a "
"technique made popular by the [QuickCheck](https://wiki.haskell.org/"
"Introduction_to_QuickCheck1) library in Haskell."
msgstr ""
"この章では、テスティングの問題に対する、型クラスの特に洗練された応用について"
"示します。**どのようにテストするのかを**コンパイラに教えるのではなく、コード"
"が**どのような性質を持っているべきか**を教えることでテストします。型クラスを"
"使って無作為データ生成のための定型コードを隠し、テストケースを仕様から無作為"
"に生成することができます。これは**生成的テスティング**(generative testing、ま"
"たはproperty-based testing）と呼ばれ、Haskellの[QuickCheck](http://www."
"haskell.org/haskellwiki/Introduction_to_QuickCheck1)ライブラリによって知られ"
"るようになった手法です。"

#. type: Plain text
#: text/chapter13.md:8
#, fuzzy
msgid ""
"The `quickcheck` package is a port of Haskell's QuickCheck library to "
"PureScript, and for the most part, it preserves the types and syntax of the "
"original library. We will see how to use `quickcheck` to test a simple "
"library, using Spago to integrate our test suite into our development "
"process."
msgstr ""
"`purescript-quickcheck`パッケージはHaskellのQuickCheckライブラリをPureScript"
"にポーティングしたもので、型や構文はもとのライブラリとほとんど同じようになっ"
"ています。 `purescript-quickcheck`を使って簡単なライブラリをテストし、Pulpで"
"テストスイートを自動化されたビルドに統合する方法を見ていきます。"

#. type: Plain text
#: text/chapter13.md:12
#, fuzzy
msgid "This chapter's project adds `quickcheck` as a dependency."
msgstr ""
"この章のプロジェクトにはBower依存関係として `purescript-quickcheck`が追加され"
"ます。"

#. type: Plain text
#: text/chapter13.md:14
#, fuzzy
msgid ""
"In a Spago project, test sources should be placed in the `test` directory, "
"and the main module for the test suite should be named `Test.Main`. The test "
"suite can be run using the `spago test` command."
msgstr ""
"Pulpプロジェクトでは、テストソースは `test`ディレクトリに置かれ、テストスイー"
"トのメインモジュールは `Test.Main`と名づけられます。 テストスイートは、 "
"`pulp test`コマンドを使用して実行できます。"

#. type: Title ##
#: text/chapter13.md:15
#, fuzzy, no-wrap
msgid "Writing Properties"
msgstr "プロパティの書き込み"

#. type: Plain text
#: text/chapter13.md:18
#, fuzzy
msgid ""
"The `Merge` module implements a simple function `merge`, which we will use "
"to demonstrate the features of the `quickcheck` library."
msgstr ""
"`Merge`モジュールでは `purescript-quickcheck`ライブラリの機能を実演するために"
"使う簡単な関数 `merge`が実装されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:19
#, fuzzy, no-wrap
msgid "merge :: Array Int -> Array Int -> Array Int\n"
msgstr "merge :: Array Int -> Array Int -> Array Int\n"

#. type: Plain text
#: text/chapter13.md:24
#, fuzzy
msgid ""
"`merge` takes two sorted arrays of integers, and merges their elements so "
"that the result is also sorted. For example:"
msgstr ""
"`merge`は2つのソートされた数の配列をとって、その要素を統合し、ソートされた結"
"果を返します。例えば次のようになります。"

#. type: Fenced code block (text)
#: text/chapter13.md:25
#, fuzzy, no-wrap
msgid ""
"> import Merge\n"
"> merge [1, 3, 5] [2, 4, 5]\n"
"\n"
"[1, 2, 3, 4, 5, 5]\n"
msgstr ""
"> import Merge\n"
"> merge [1, 3, 5] [2, 4, 6]\n"
"\n"
"[1, 2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter13.md:33
#, fuzzy
msgid ""
"In a typical test suite, we might test `merge` by generating a few small "
"test cases like this by hand, and asserting that the results were equal to "
"the appropriate values. However, everything we need to know about the "
"`merge` function can be summarized by this property:"
msgstr ""
"典型的なテストスイートでは、手作業でこのような小さなテストケースをいくつも作"
"成し、結果が正しい値と等しいことを確認することでテスト実施します。しかし、 "
"`merge`関数について知る必要があるものはすべて、2つの性質に要約することができ"
"ます。"

#. type: Plain text
#: text/chapter13.md:35
#, fuzzy
msgid ""
"- If `xs` and `ys` are sorted, then `merge xs ys` is the sorted result of "
"both arrays appended together."
msgstr ""
"- (既ソート性)`xs`と `ys`がソート済みなら、 `merge xs ys`もソート済みになりま"
"す。 - （部分配列） `xs`と `ys`ははどちらも `merge xs ys`の部分配列で、要素は"
"元の配列と同じ順序で現れます。"

#. type: Plain text
#: text/chapter13.md:37
#, fuzzy
msgid ""
"`quickcheck` allows us to test this property directly, by generating random "
"test cases. We simply state the properties that we want our code to have, as "
"functions. In this case, we have a single property:"
msgstr ""
"`purescript-quickcheck`では、無作為なテストケースを生成することで、直接これら"
"の性質をテストすることができます。コードが持つべき性質を、次のような関数とし"
"て述べるだけです。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:38
#, fuzzy, no-wrap
msgid ""
"main = do\n"
"  quickCheck \\xs ys ->\n"
"    eq (merge (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"main = do\n"
"  quickCheck \\xs ys ->\n"
"    isSorted $ merge (sort xs) (sort ys)\n"
"  quickCheck \\xs ys ->\n"
"    xs `isSubarrayOf` merge xs ys\n"

#. type: Plain text
#: text/chapter13.md:45
#, fuzzy
msgid ""
"When we run this code, `quickcheck` will attempt to disprove the properties "
"we claimed, by generating random inputs `xs` and `ys`, and passing them to "
"our functions. If our function returns `false` for any inputs, the property "
"will be incorrect, and the library will raise an error. Fortunately, the "
"library is unable to disprove our properties after generating 100 random "
"test cases:"
msgstr ""
"このコードを実行すると、 `purescript-quickcheck`は無作為な入力 `xs`と `ys`を"
"生成してこの関数に渡すことで、主張しようとしている性質を反証しようとします。"
"何らかの入力に対して関数が `false`を返した場合、性質は正しくないことが示さ"
"れ、ライブラリはエラーを発生させます。幸いなことに、次のように100個の無作為な"
"テストケースを生成しても、ライブラリはこの性質を反証することができません。"

#. type: Fenced code block (text)
#: text/chapter13.md:46
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Installation complete.\n"
"Build succeeded.\n"
"100/100 test(s) passed.\n"
"...\n"
"Tests succeeded.\n"
msgstr ""

#. type: Plain text
#: text/chapter13.md:57
#, fuzzy
msgid ""
"If we deliberately introduce a bug into the `merge` function (for example, "
"by changing the less-than check for a greater-than check), then an exception "
"is thrown at runtime after the first failed test case:"
msgstr ""
"もし `merge`関数に意図的にバグを混入した場合（例えば、大なりのチェックを小な"
"りのチェックへと変更するなど）、最初に失敗したテストケースの後で例外が実行時"
"に投げられます。"

#. type: Fenced code block (text)
#: text/chapter13.md:58
#, fuzzy, no-wrap
msgid ""
"Error: Test 1 failed:\n"
"Test returned false\n"
msgstr ""
"Error: Test 1 failed:\n"
"Test returned false\n"

#. type: Plain text
#: text/chapter13.md:64
#, fuzzy
msgid ""
"As we can see, this error message is not very helpful, but it can be "
"improved with a little work."
msgstr ""
"このエラーメッセージではあまり役に立ちませんが、これから見ていくように、少し"
"の作業で改良することができます。"

#. type: Title ##
#: text/chapter13.md:65
#, fuzzy, no-wrap
msgid "Improving Error Messages"
msgstr "エラーメッセージの改善"

#. type: Plain text
#: text/chapter13.md:68
#, fuzzy, no-wrap
msgid "To provide error messages along with our failed test cases, `quickcheck` provides the `<?>` operator. Simply separate the property definition from the error message using `<?>`, as follows:\n"
msgstr "テストケースが失敗した時に同時にエラーメッセージを提供するには、 `purescript-quickcheck`の `<?>`演算子を使います。次のように性質の定義に続けて `<?>`で区切ってエラーメッセージを書くだけです。\n"

#. type: Fenced code block (haskell)
#: text/chapter13.md:69
#, fuzzy, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  let\n"
"    result = merge (sort xs) (sort ys)\n"
"    expected = sort $ xs <> ys\n"
"  in\n"
"    eq result expected <?> \"Result:\\n\" <> show result <> \"\\nnot equal to expected:\\n\" <> show expected\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  let\n"
"    result = merge (sort xs) (sort ys)\n"
"  in\n"
"    xs `isSubarrayOf` result <?> show xs <> \" not a subarray of \" <> show result\n"

#. type: Plain text
#: text/chapter13.md:79
#, fuzzy
msgid ""
"This time, if we modify the code to introduce a bug, we see our improved "
"error message after the first failed test case:"
msgstr ""
"このとき、もしバグを混入するようにコードを変更すると、最初のテストケースが失"
"敗したときに改良されたエラーメッセージが表示されます。"

#. type: Fenced code block (text)
#: text/chapter13.md:80
#, no-wrap
msgid ""
"Error: Test 1 (seed 534161891) failed:\n"
"Result:\n"
"[-822215,-196136,-116841,618343,887447,-888285]\n"
"not equal to expected:\n"
"[-888285,-822215,-196136,-116841,618343,887447]\n"
msgstr ""

#. type: Plain text
#: text/chapter13.md:89
#, fuzzy
msgid ""
"Notice how the input `xs` and `ys` were generated as arrays of randomly-"
"selected integers."
msgstr ""
"入力 `xs`が無作為に選ばれた数の配列として生成されていることに注目してくださ"
"い。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:94
msgid ""
"(Easy) Write a property which asserts that merging an array with the empty "
"array does not modify the original array. _Note_: This new property is "
"redundant, since this situation is already covered by our existing property. "
"We're just trying to give you readers a simple way to practice using "
"quickCheck."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter13.md:94
#, fuzzy
msgid ""
"(Easy) Add an appropriate error message to the remaining property for "
"`merge`."
msgstr ""
"（簡単） `merge`の残りの性質に対して、適切なエラーメッセージを追加してくださ"
"い。"

#. type: Title ##
#: text/chapter13.md:95
#, fuzzy, no-wrap
msgid "Testing Polymorphic Code"
msgstr "多相的なコードのテスト"

#. type: Plain text
#: text/chapter13.md:98
#, fuzzy
msgid ""
"The `Merge` module defines a generalization of the `merge` function, called "
"`mergePoly`, which works not only with arrays of numbers, but also arrays of "
"any type belonging to the `Ord` type class:"
msgstr ""
"`Merge`モジュールでは、数の配列だけでなく、 `Ord`型クラスに属するどんな型の配"
"列に対しても動作する、 `merge`関数を一般化した `mergePoly`という関数が定義さ"
"れています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:99
#, fuzzy, no-wrap
msgid "mergePoly :: forall a. Ord a => Array a -> Array a -> Array a\n"
msgstr "mergePoly :: forall a. Ord a => Array a -> Array a -> Array a\n"

#. type: Plain text
#: text/chapter13.md:104
#, fuzzy
msgid ""
"If we modify our original test to use `mergePoly` in place of `merge`, we "
"see the following error message:"
msgstr ""
"`merge`の代わりに `mergePoly`を使うように元のテストを変更すると、次のようなエ"
"ラーメッセージが表示されます。"

#. type: Fenced code block (text)
#: text/chapter13.md:105
#, fuzzy, no-wrap
msgid ""
"No type class instance was found for\n"
"\n"
"  Test.QuickCheck.Arbitrary.Arbitrary t0\n"
"\n"
"The instance head contains unknown type variables.\n"
"Consider adding a type annotation.\n"
msgstr ""
"No type class instance was found for\n"
"\n"
"  Test.QuickCheck.Arbitrary.Arbitrary t0\n"
"\n"
"The instance head contains unknown type variables.\n"
"Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter13.md:115
#, fuzzy
msgid ""
"This error message indicates that the compiler could not generate random "
"test cases, because it did not know what type of elements we wanted our "
"arrays to have. In these sorts of cases, we can use type annotations to "
"force the compiler to infer a particular type, such as `Array Int`:"
msgstr ""
"このエラーメッセージは、配列に持たせたい要素の型が何なのかわからないので、コ"
"ンパイラが無作為なテストケースを生成できなかったということを示しています。こ"
"のような場合、補助関数を使と、コンパイラが特定の型を推論すること強制できま"
"す。例えば、恒等関数の同義語として `ints`という関数を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:116
#, fuzzy, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (mergePoly (sort xs) (sort ys) :: Array Int) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  isSorted $ numbers $ mergePoly (sort xs) (sort ys)\n"

#. type: Plain text
#: text/chapter13.md:122
msgid ""
"We can alternatively use a helper function to specify type, which may result "
"in cleaner code. For example, if we define a function `ints` as a synonym "
"for the identity function:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter13.md:123
#, fuzzy, no-wrap
msgid ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"
msgstr ""
"ints :: Array Int -> Array Int\n"
"ints = id\n"

#. type: Plain text
#: text/chapter13.md:129
#, fuzzy
msgid ""
"then we can modify our test so that the compiler infers the type `Array Int` "
"for our two array arguments:"
msgstr ""
"それから、コンパイラが引数の２つの配列の型 `Array Int`を推論するように、テス"
"トを変更します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:130
#, fuzzy, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  isSorted $ ints $ mergePoly (sorted xs) (sorted ys)\n"

#. type: Plain text
#: text/chapter13.md:136
#, fuzzy
msgid ""
"Here, `xs` and `ys` both have type `Array Int`, since the `ints` function "
"has been used to disambiguate the unknown type."
msgstr ""
"ここで、 `numbers`関数が不明な型を解消するために使われるので、 `xs`と `ys`は"
"どちらも型 `Array Int`を持っています。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:141
#, fuzzy
msgid ""
"(Easy) Write a function `bools` which forces the types of `xs` and `ys` to "
"be `Array Boolean`, and add additional properties which test `mergePoly` at "
"that type."
msgstr ""
"(簡単)`xs`と `ys`の型を `Array Boolean`に強制する関数 `bools`を書き、 "
"`mergePoly`をその型でテストする性質を追加してください。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:141
#, fuzzy
msgid ""
"(Medium) Choose a pure function from the core libraries (for example, from "
"the `arrays` package), and write a QuickCheck property for it, including an "
"appropriate error message. Your property should use a helper function to fix "
"any polymorphic type arguments to either `Int` or `Boolean`."
msgstr ""
"(やや難しい) 標準関数から(例えば `purescript-arrays`パッケージから)ひとつ関数"
"を選び、適切なエラーメッセージを含めてQuickCheckの性質を書いてください。その"
"性質は、補助関数を使って多相型引数を `Int`か `Boolean`のどちらかに固定しなけ"
"ればいけません。"

#. type: Title ##
#: text/chapter13.md:142
#, fuzzy, no-wrap
msgid "Generating Arbitrary Data"
msgstr "任意のデータの生成"

#. type: Plain text
#: text/chapter13.md:145
#, fuzzy
msgid ""
"Now we will see how the `quickcheck` library is able to randomly generate "
"test cases for our properties."
msgstr ""
"`purescript-quickcheck`ライブラリを使って性質についてのテストケースを無作為に"
"生成する方法について説明します。"

#. type: Plain text
#: text/chapter13.md:147
#, fuzzy
msgid ""
"Those types whose values can be randomly generated are captured by the "
"`Arbitrary` type class:"
msgstr ""
"無作為に値を生成することができるような型は、次のような型クラス `Arbitary`のイ"
"ンスタンスを持っています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:148
#, fuzzy, no-wrap
msgid ""
"class Arbitrary t where\n"
"  arbitrary :: Gen t\n"
msgstr ""
"class Arbitrary t where\n"
"  arbitrary :: Gen t\n"

#. type: Plain text
#: text/chapter13.md:154
#, fuzzy
msgid ""
"The `Gen` type constructor represents the side-effects of _deterministic "
"random data generation_. It uses a pseudo-random number generator to "
"generate deterministic random function arguments from a seed value. The "
"`Test.QuickCheck.Gen` module defines several useful combinators for building "
"generators."
msgstr ""
"`Gen`型構築子は**決定的無作為データ生成**の副作用を表しています。 決定的無作"
"為データ生成は、擬似乱数生成器を使って、シード値から決定的無作為関数の引数を"
"生成します。 `Test.QuickCheck.Gen`モジュールは、ジェネレータを構築するための"
"いくつかの有用なコンビネータを定義します。"

#. type: Plain text
#: text/chapter13.md:156
#, fuzzy
msgid ""
"`Gen` is also a monad and an applicative functor, so we have the usual "
"collection of combinators at our disposal for creating new instances of the "
"`Arbitrary` type class."
msgstr ""
"`Gen`はモナドでもApplicative関手でもあるので、 `Arbitary`型クラスの新しいイン"
"スタンスを作成するのに、いつも使っているようなコンビネータを自由に使うことが"
"できます。"

#. type: Plain text
#: text/chapter13.md:158
#, fuzzy
msgid ""
"For example, we can use the `Arbitrary` instance for the `Int` type, "
"provided in the `quickcheck` library, to create a distribution on the 256 "
"byte values, using the `Functor` instance for `Gen` to map a function from "
"integers to bytes over arbitrary integer values:"
msgstr ""
"例えば、 `purescript-quickcheck`ライブラリで提供されている `Int`型の "
"`Arbitrary`インスタンスは、関数を整数から任意の整数値のバイトまでマップするた"
"めの `Functor`インスタンスを `Gen`に使用することで、バイト値の分布した値を生"
"成します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:159
#, fuzzy, no-wrap
msgid ""
"newtype Byte = Byte Int\n"
"\n"
"instance arbitraryByte :: Arbitrary Byte where\n"
"  arbitrary = map intToByte arbitrary\n"
"    where\n"
"    intToByte n | n >= 0 = Byte (n `mod` 256)\n"
"                | otherwise = intToByte (-n)\n"
msgstr ""
"newtype Byte = Byte Int\n"
"\n"
"instance arbitraryByte :: Arbitrary Byte where\n"
"  arbitrary = map intToByte arbitrary\n"
"    where\n"
"    intToByte n | n >= 0 = Byte (n `mod` 256)\n"
"                | otherwise = intToByte (-n)\n"

#. type: Plain text
#: text/chapter13.md:170
#, fuzzy
msgid ""
"Here, we define a type `Byte` of integral values between 0 and 255. The "
"`Arbitrary` instance uses the `map` function to lift the `intToByte` "
"function over the `arbitrary` action. The type of the inner `arbitrary` "
"action is inferred as `Gen Int`."
msgstr ""
"ここでは、0から255までの間の整数値であるような型 `Byte`を定義しています。 "
"`Arbitrary`インスタンスの `<$>`演算子を使って、 `uniformToByte`関数を "
"`arbitrary`アクションまで持ち上げています。この型の `arbitrary`アクションの型"
"は `Gen Number`だと推論されますが、これは0から1の間に均一に分布する数を生成す"
"ることを意味しています。\n"

#. type: Plain text
#: text/chapter13.md:172
#, fuzzy
msgid "We can also use this idea to improve our test for `merge`:"
msgstr ""
"この考え方を `merge`に対しての既ソート性テストを改良するのに使うこともできま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:173
#, fuzzy, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (numbers $ mergePoly (sort xs) (sort ys)) (sort $ xs <> ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  isSorted $ numbers $ mergePoly (sort xs) (sort ys)\n"

#. type: Plain text
#: text/chapter13.md:179
#, fuzzy
msgid ""
"In this test, we generated arbitrary arrays `xs` and `ys`, but had to sort "
"them, since `merge` expects sorted input. On the other hand, we could create "
"a newtype representing sorted arrays, and write an `Arbitrary` instance "
"which generates sorted data:"
msgstr ""
"このテストでは、任意の配列 `xs`と `ys`を生成しますが、 `merge`はソート済みの"
"入力を期待しているので、 `xs`と `ys`をソートしておかなければなりません。一方"
"で、ソートされた配列を表すnewtypeを作成し、ソートされたデータを生成する "
"`Arbitrary`インスタンスを書くこともできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:180
#, fuzzy, no-wrap
msgid ""
"newtype Sorted a = Sorted (Array a)\n"
"\n"
"sorted :: forall a. Sorted a -> Array a\n"
"sorted (Sorted xs) = xs\n"
"\n"
"instance arbSorted :: (Arbitrary a, Ord a) => Arbitrary (Sorted a) where\n"
"  arbitrary = map (Sorted <<< sort) arbitrary\n"
msgstr ""
"newtype Sorted a = Sorted (Array a)\n"
"\n"
"sorted :: forall a. Sorted a -> Array a\n"
"sorted (Sorted xs) = xs\n"
"\n"
"instance arbSorted :: (Arbitrary a, Ord a) => Arbitrary (Sorted a) where\n"
"  arbitrary = map (Sorted <<< sort) arbitrary\n"

#. type: Plain text
#: text/chapter13.md:191
#, fuzzy
msgid "With this type constructor, we can modify our test as follows:"
msgstr "この型構築子を使うと、テストを次のように変更することができます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:192
#, fuzzy, no-wrap
msgid ""
"quickCheck \\xs ys ->\n"
"  eq (ints $ mergePoly (sorted xs) (sorted ys)) (sort $ sorted xs <> sorted ys)\n"
msgstr ""
"quickCheck \\xs ys ->\n"
"  isSorted $ ints $ mergePoly (sorted xs) (sorted ys)\n"

#. type: Plain text
#: text/chapter13.md:198
#, fuzzy
msgid ""
"This may look like a small change, but the types of `xs` and `ys` have "
"changed to `Sorted Int`, instead of just `Array Int`. This communicates our "
"_intent_ in a clearer way - the `mergePoly` function takes sorted input. "
"Ideally, the type of the `mergePoly` function itself would be updated to use "
"the `Sorted` type constructor."
msgstr ""
"これは些細な変更に見えるかもしれませんが、 `xs`と `ys`の型はただの `Array "
"Int`から `Sorted Int`へと変更されています。これにより、 `mergePoly`関数はソー"
"ト済みの入力を取る、という**意図**を、わかりやすく示すことができます。理想的"
"には、 `mergePoly`関数自体の型が `Sorted`型構築子を使うようにするといいでしょ"
"う。"

#. type: Plain text
#: text/chapter13.md:200
#, fuzzy
msgid ""
"As a more interesting example, the `Tree` module defines a type of sorted "
"binary trees with values at the branches:"
msgstr ""
"より興味深い例として、 `Tree`モジュールでは枝の値でソートされた二分木の型が定"
"義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:201
#, fuzzy, no-wrap
msgid ""
"data Tree a\n"
"  = Leaf\n"
"  | Branch (Tree a) a (Tree a)\n"
msgstr ""
"data Tree a\n"
"  = Leaf\n"
"  | Branch (Tree a) a (Tree a)\n"

#. type: Plain text
#: text/chapter13.md:208
#, fuzzy
msgid "The `Tree` module defines the following API:"
msgstr "`Tree`モジュールでは次のAPIが定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:209
#, fuzzy, no-wrap
msgid ""
"insert    :: forall a. Ord a => a -> Tree a -> Tree a\n"
"member    :: forall a. Ord a => a -> Tree a -> Boolean\n"
"fromArray :: forall a. Ord a => Array a -> Tree a\n"
"toArray   :: forall a. Tree a -> Array a\n"
msgstr ""
"insert    :: forall a. Ord a => a -> Tree a -> Tree a\n"
"member    :: forall a. Ord a => a -> Tree a -> Boolean\n"
"fromArray :: forall a. Ord a => Array a -> Tree a\n"
"toArray   :: forall a. Tree a -> Array a\n"

#. type: Plain text
#: text/chapter13.md:217
#, fuzzy
msgid ""
"The `insert` function is used to insert a new element into a sorted tree, "
"and the `member` function can be used to query a tree for a particular "
"value. For example:"
msgstr ""
"`insert`関数は新しい要素をソート済みの二分木に挿入するのに使われ、 `member`関"
"数は特定の値の有無を木に問い合わせるのに使われます。例えば次のようになりま"
"す。"

#. type: Fenced code block (text)
#: text/chapter13.md:218
#, fuzzy, no-wrap
msgid ""
"> import Tree\n"
"\n"
"> member 2 $ insert 1 $ insert 2 Leaf\n"
"true\n"
"\n"
"> member 1 Leaf\n"
"false\n"
msgstr ""
"> import Tree\n"
"\n"
"> member 2 $ insert 1 $ insert 2 Leaf\n"
"true\n"
"\n"
"> member 1 Leaf\n"
"false\n"

#. type: Plain text
#: text/chapter13.md:229
#, fuzzy
msgid ""
"The `toArray` and `fromArray` functions can be used to convert sorted trees "
"to and from arrays. We can use `fromArray` to write an `Arbitrary` instance "
"for trees:"
msgstr ""
"`toArray`関数と `fromArray`関数は、ソートされた木とソートされた配列を相互に変"
"換するために使われます。 `fromArray`を使うと、木についての `Arbitrary`インス"
"タンスを書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:230
#, fuzzy, no-wrap
msgid ""
"instance arbTree :: (Arbitrary a, Ord a) => Arbitrary (Tree a) where\n"
"  arbitrary = map fromArray arbitrary\n"
msgstr ""
"instance arbTree :: (Arbitrary a, Ord a) => Arbitrary (Tree a) where\n"
"  arbitrary = map fromArray arbitrary\n"

#. type: Plain text
#: text/chapter13.md:236
#, fuzzy
msgid ""
"We can now use `Tree a` as the type of an argument to our test properties, "
"whenever there is an `Arbitrary` instance available for the type `a`. For "
"example, we can test that the `member` test always returns `true` after "
"inserting a value:"
msgstr ""
"型 `a`についての有効な `Arbitary`インスタンスが存在していれば、テストする性質"
"の引数の型として `Tree a`を使うことができます。例えば、 `member`テストは値を"
"挿入した後は常に `true`を返すことをテストできます。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:237
#, fuzzy, no-wrap
msgid ""
"quickCheck \\t a ->\n"
"  member a $ insert a $ treeOfInt t\n"
msgstr ""
"quickCheck \\t a ->\n"
"  member a $ insert a $ treeOfInt t\n"

#. type: Plain text
#: text/chapter13.md:243
#, fuzzy
msgid ""
"Here, the argument `t` is a randomly-generated tree of type `Tree Int`, "
"where the type argument disambiguated by the identity function `treeOfInt`."
msgstr ""
"ここでは、引数 `t`は `Tree Number`型の無作為に生成された木です。型引数は、識"
"別関数 `treeOfInt`によって明確化されています。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:248
#, fuzzy
msgid ""
"(Medium) Create a newtype for `String` with an associated `Arbitrary` "
"instance which generates collections of randomly-selected characters in the "
"range `a-z`. _Hint_: use the `elements` and `arrayOf` functions from the "
"`Test.QuickCheck.Gen` module."
msgstr ""
"（やや難しい） `a-z`の範囲から無作為に選ばれた文字の集まりを生成する "
"`Arbitrary`インスタンスを持った、 `String`のnewtypeを作ってください。**ヒント"
"**：`Test.QuickCheck.Gen`モジュールから `elements`と `arrayOf`関数を使いま"
"す。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:248
#, fuzzy
msgid ""
"(Difficult) Write a property which asserts that a value inserted into a tree "
"is still a member of that tree after arbitrarily many more insertions."
msgstr ""
"（難しい） 木に挿入された値は、任意に多くの挿入があった後も、その木の構成要素"
"であることを主張する性質を書いてください。"

#. type: Title ##
#: text/chapter13.md:249
#, fuzzy, no-wrap
msgid "Testing Higher-Order Functions"
msgstr "高階関数のテスト"

#. type: Plain text
#: text/chapter13.md:252
#, fuzzy
msgid ""
"The `Merge` module defines another generalization of the `merge` function - "
"the `mergeWith` function takes an additional function as an argument which "
"is used to determine the order in which elements should be merged. That is, "
"`mergeWith` is a higher-order function."
msgstr ""
"`Merge`モジュールは `merge`関数についての他の生成も定義します。 `mergeAith`関"
"数は、統合される要素の順序を決定するのに使われる、追加の関数を引数としてとり"
"ます。つまり `mergeWith`は高階関数です。"

#. type: Plain text
#: text/chapter13.md:254
#, fuzzy
msgid ""
"For example, we can pass the `length` function as the first argument, to "
"merge two arrays which are already in length-increasing order. The result "
"should also be in length-increasing order:"
msgstr ""
"例えば、すでに長さの昇順になっている２つの配列を統合するのに、 `length`関数を"
"最初の引数として渡します。このとき、結果も長さの昇順になっていなければなりま"
"せん。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:255
#, fuzzy, no-wrap
msgid ""
"> import Data.String\n"
"\n"
"> mergeWith length\n"
"    [\"\", \"ab\", \"abcd\"]\n"
"    [\"x\", \"xyz\"]\n"
"\n"
"[\"\",\"x\",\"ab\",\"xyz\",\"abcd\"]\n"
msgstr ""
"> import Data.String\n"
"\n"
"> mergeWith length\n"
"    [\"\", \"ab\", \"abcd\"]\n"
"    [\"x\", \"xyz\"]\n"
"\n"
"[\"\",\"x\",\"ab\",\"xyz\",\"abcd\"]\n"

#. type: Plain text
#: text/chapter13.md:266
#, fuzzy
msgid ""
"How might we test such a function? Ideally, we would like to generate values "
"for all three arguments, including the first argument which is a function."
msgstr ""
"このような関数をテストするにはどうしたらいいでしょうか。理想的には、関数であ"
"るような最初の引数を含めた、３つの引数すべてについて、値を生成したいと思うで"
"しょう。"

#. type: Plain text
#: text/chapter13.md:268
#, fuzzy
msgid ""
"There is a second type class which allows us to create randomly-generated "
"functions. It is called `Coarbitrary`, and it is defined as follows:"
msgstr ""
"関数を無作為に生成せきるようにする、もうひとつの型クラスがあります。この型ク"
"ラスは `Coarbitrary`と呼ばれており、次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:269
#, fuzzy, no-wrap
msgid ""
"class Coarbitrary t where\n"
"  coarbitrary :: forall r. t -> Gen r -> Gen r\n"
msgstr ""
"class Coarbitrary t where\n"
"  coarbitrary :: forall r. t -> Gen r -> Gen r\n"

#. type: Plain text
#: text/chapter13.md:275
#, fuzzy
msgid ""
"The `coarbitrary` function takes a function argument of type `t`, and a "
"random generator for a function result of type `r`, and uses the function "
"argument to _perturb_ the random generator. That is, it uses the function "
"argument to modify the random output of the random generator for the result."
msgstr ""
"`coarbitrary`関数は、型 `t`と、関数の結果の型 `r`についての無作為な生成器を関"
"数の引数としてとり、無作為な生成器を**かき乱す**のにこの引数を使います。つま"
"り、この引数を使って、乱数生成器の無作為な出力を変更しているのです。"

#. type: Plain text
#: text/chapter13.md:277
#, fuzzy
msgid ""
"In addition, there is a type class instance which gives us `Arbitrary` "
"functions if the function domain is `Coarbitrary` and the function codomain "
"is `Arbitrary`:"
msgstr ""
"また、もし関数の定義域が `Coarbitrary`で、値域が `Arbitrary`なら、 "
"`Arbitrary`の関数を与える型クラスインスタンスが存在しています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:278
#, fuzzy, no-wrap
msgid "instance arbFunction :: (Coarbitrary a, Arbitrary b) => Arbitrary (a -> b)\n"
msgstr "instance arbFunction :: (Coarbitrary a, Arbitrary b) => Arbitrary (a -> b)\n"

#. type: Plain text
#: text/chapter13.md:283
#, fuzzy
msgid ""
"In practice, this means that we can write properties which take functions as "
"arguments. In the case of the `mergeWith` function, we can generate the "
"first argument randomly, modifying our tests to take account of the new "
"argument."
msgstr ""
"実は、これが意味しているのは、引数として関数を取るような性質を記述できるとい"
"うことです。 `mergeWith`関数の場合では、新しい引数を考慮するようにテストを修"
"正すると、最初の引数を無作為に生成することができます。"

#. type: Plain text
#: text/chapter13.md:285
#, fuzzy
msgid ""
"We cannot guarantee that the result will be sorted - we do not even "
"necessarily have an `Ord` instance - but we can expect that the result be "
"sorted with respect to the function `f` that we pass in as an argument. In "
"addition, we need the two input arrays to be sorted with respect to `f`, so "
"we use the `sortBy` function to sort `xs` and `ys` based on comparison after "
"the function `f` has been applied:"
msgstr ""
"既ソート性の性質については、必ずしも `Ord`インスタンスを持っているとは限らな"
"いので、結果がソートされているということを保証することができませんが、引数と"
"して渡す関数 `f`にしたがって結果がソートされている期待することはできます。さ"
"らに、２つの入力配列が `f`に従ってソートされている必要がありますので、 "
"`sortBy`関数を使って関数 `f`が適用されたあとの比較に基づいて `xs`と `ys`を"
"ソートします。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:286
#, fuzzy, no-wrap
msgid ""
"quickCheck \\xs ys f ->\n"
"  let\n"
"    result =\n"
"      map f $\n"
"        mergeWith (intToBool f)\n"
"                  (sortBy (compare `on` f) xs)\n"
"                  (sortBy (compare `on` f) ys)\n"
"    expected =\n"
"      map f $\n"
"        sortBy (compare `on` f) $ xs <> ys\n"
"  in\n"
"    eq result expected\n"
msgstr ""
"quickCheck \\xs ys f ->\n"
"  isSorted $\n"
"    map f $\n"
"      mergeWith (intToBool f)\n"
"                (sortBy (compare `on` f) xs)\n"
"                (sortBy (compare `on` f) ys)\n"

#. type: Plain text
#: text/chapter13.md:302
#, fuzzy
msgid ""
"Here, we use a function `intToBool` to disambiguate the type of the function "
"`f`:"
msgstr ""
"ここでは、関数 `f`の型を明確にするために、関数 `intToBool`を使用しています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:303
#, fuzzy, no-wrap
msgid ""
"intToBool :: (Int -> Boolean) -> Int -> Boolean\n"
"intToBool = id\n"
msgstr ""
"intToBool :: (Int -> Boolean) -> Int -> Boolean\n"
"intToBool = id\n"

#. type: Plain text
#: text/chapter13.md:309
#, fuzzy
msgid "In addition to being `Arbitrary`, functions are also `Coarbitrary`:"
msgstr "関数は `Arbitrary`であるだけでなく `Coarbitrary`でもあります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:310
#, fuzzy, no-wrap
msgid "instance coarbFunction :: (Arbitrary a, Coarbitrary b) => Coarbitrary (a -> b)\n"
msgstr "instance coarbFunction :: (Arbitrary a, Coarbitrary b) => Coarbitrary (a -> b)\n"

#. type: Plain text
#: text/chapter13.md:315
#, fuzzy
msgid ""
"This means that we are not limited to just values and functions - we can "
"also randomly generate _higher-order functions_, or functions whose "
"arguments are higher-order functions, and so on."
msgstr ""
"これは値の生成が単純な関数だけに限定されるものではないことを意味しています。"
"つまり、**高階関数**や、引数が高階関数であるような関数すら無作為に生成するこ"
"とができるのです。"

#. type: Title ##
#: text/chapter13.md:316
#, fuzzy, no-wrap
msgid "Writing Coarbitrary Instances"
msgstr "Coarbitraryのインスタンスを書く"

#. type: Plain text
#: text/chapter13.md:319
#, fuzzy
msgid ""
"Just as we can write `Arbitrary` instances for our data types by using the "
"`Monad` and `Applicative` instances of `Gen`, we can write our own "
"`Coarbitrary` instances as well. This allows us to use our own data types as "
"the domain of randomly-generated functions."
msgstr ""
"`Gen`の `Monad`や `Applicative`インスタンスを使って独自のデータ型に対して "
"`Arbitrary`インスタンスを書くことができるのとちょうど同じように、独自の "
"`Coarbitrary`インスタンスを書くこともできます。これにより、無作為に生成される"
"関数の定義域として、独自のデータ型を使うことができるようになります。"

#. type: Plain text
#: text/chapter13.md:321
#, fuzzy
msgid ""
"Let's write a `Coarbitrary` instance for our `Tree` type. We will need a "
"`Coarbitrary` instance for the type of the elements stored in the branches:"
msgstr ""
"`Tree`型の `Coarbitrary`インスタンスを書いてみましょう。枝に格納されている要"
"素の型に `Coarbitrary`インスタンスが必要になります。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:322
#, fuzzy, no-wrap
msgid "instance coarbTree :: Coarbitrary a => Coarbitrary (Tree a) where\n"
msgstr "instance coarbTree :: Coarbitrary a => Coarbitrary (Tree a) where\n"

#. type: Plain text
#: text/chapter13.md:327
#, fuzzy
msgid ""
"We have to write a function which perturbs a random generator given a value "
"of type `Tree a`. If the input value is a `Leaf`, then we will just return "
"the generator unchanged:"
msgstr ""
"型 `Tree a`の値を与えられた乱数発生器をかき乱す関数を記述する必要があります。"
"入力値が `Leaf`であれば、そのままの生成器を返します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:328
#, fuzzy, no-wrap
msgid "  coarbitrary Leaf = id\n"
msgstr "coarbitrary Leaf = id\n"

#. type: Plain text
#: text/chapter13.md:333
#, fuzzy
msgid ""
"If the tree is a `Branch`, then we will perturb the generator using the left "
"subtree, the value, and the right subtree. We use function composition to "
"create our perturbing function:"
msgstr ""
"もし木が `Branch`なら、 関数合成で独自のかき乱し関数を作ることにより、 左の部"
"分木、値、右の部分木を使って生成器をかき乱します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:334
#, fuzzy, no-wrap
msgid ""
"  coarbitrary (Branch l a r) =\n"
"    coarbitrary l <<<\n"
"    coarbitrary a <<<\n"
"    coarbitrary r\n"
msgstr ""
"coarbitrary (Branch l a r) =\n"
"  coarbitrary l <<<\n"
"  coarbitrary a <<<\n"
"  coarbitrary r\n"

#. type: Plain text
#: text/chapter13.md:342
#, fuzzy
msgid ""
"Now we are free to write properties whose arguments include functions taking "
"trees as arguments. For example, the `Tree` module defines a function "
"`anywhere`, which tests if a predicate holds on any subtree of its argument:"
msgstr ""
"これで、木を引数にとるような関数を含む性質を自由に書くことができるようになり"
"ました。たとえば、 `Tree`モジュールでは述語が引数のどんな部分木についても成り"
"立っているかを調べる関数 `anywhere`が定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:343
#, fuzzy, no-wrap
msgid "anywhere :: forall a. (Tree a -> Boolean) -> Tree a -> Boolean\n"
msgstr "anywhere :: forall a. (Tree a -> Boolean) -> Tree a -> Boolean\n"

#. type: Plain text
#: text/chapter13.md:348
#, fuzzy
msgid ""
"Now we are able to generate the predicate function randomly. For example, we "
"expect the `anywhere` function to _respect disjunction_:"
msgstr ""
"これで、無作為にこの述語関数 `anywhere`を生成することができるようになりまし"
"た。例えば、 `anywhere`関数が次のような**ある命題のもとで不変**であることを期"
"待します。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:349
#, fuzzy, no-wrap
msgid ""
"quickCheck \\f g t ->\n"
"  anywhere (\\s -> f s || g s) t ==\n"
"    anywhere f (treeOfInt t) || anywhere g t\n"
msgstr ""
"quickCheck \\f g t ->\n"
"  anywhere (\\s -> f s || g s) t ==\n"
"    anywhere f (treeOfInt t) || anywhere g t\n"

#. type: Plain text
#: text/chapter13.md:356
#, fuzzy
msgid ""
"Here, the `treeOfInt` function is used to fix the type of values contained "
"in the tree to the type `Int`:"
msgstr ""
"ここで、 `treeOfInt`関数は木に含まれる値の型を型 `Int`に固定するために使われ"
"ています。"

#. type: Fenced code block (haskell)
#: text/chapter13.md:357
#, fuzzy, no-wrap
msgid ""
"treeOfInt :: Tree Int -> Tree Int\n"
"treeOfInt = id\n"
msgstr ""
"treeOfInt :: Tree Int -> Tree Int\n"
"treeOfInt = id\n"

#. type: Title ##
#: text/chapter13.md:362
#, fuzzy, no-wrap
msgid "Testing Without Side-Effects"
msgstr "副作用のないテスト"

#. type: Plain text
#: text/chapter13.md:365
#, fuzzy
msgid ""
"For the purposes of testing, we usually include calls to the `quickCheck` "
"function in the `main` action of our test suite. However, there is a variant "
"of the `quickCheck` function, called `quickCheckPure` which does not use "
"side-effects. Instead, it is a pure function which takes a random seed as an "
"input, and returns an array of test results."
msgstr ""
"テストの目的では通常、テストスイートの `main`アクションには `quickCheck`関数"
"の呼び出しが含まれています。しかし、副作用を使わない `quickCheckPure`と呼ばれ"
"る `quickCheck`関数の亜種もあります。 `quickCheckPure`は、入力として乱数の種"
"をとり、テスト結果の配列を返す純粋な関数です。"

#. type: Plain text
#: text/chapter13.md:367
#, fuzzy
msgid ""
"We can test `quickCheckPure` using PSCi. Here, we test that the `merge` "
"operation is associative:"
msgstr ""
"`PSCi`を使用して `quickCheckPure`を使ってみましょう。ここでは `merge`操作が結"
"合法則を満たすことをテストしてみます。"

#. type: Fenced code block (text)
#: text/chapter13.md:368
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"> import Merge\n"
"> import Test.QuickCheck\n"
"> import Test.QuickCheck.LCG (mkSeed)\n"
"\n"
"> :paste\n"
"â¦ quickCheckPure (mkSeed 12345) 10 \\xs ys zs ->\n"
"â¦   ((xs `merge` ys) `merge` zs) ==\n"
"â¦     (xs `merge` (ys `merge` zs))\n"
"â¦ ^D\n"
"\n"
"Success : Success : ...\n"
msgstr ""
"> import Prelude\n"
"> import Merge\n"
"> import Test.QuickCheck\n"
"> import Test.QuickCheck.LCG (mkSeed)\n"
"\n"
"> :paste\n"
"… quickCheckPure (mkSeed 12345) 10 \\xs ys zs ->\n"
"…   ((xs `merge` ys) `merge` zs) ==\n"
"…     (xs `merge` (ys `merge` zs))\n"
"… ^D\n"
"\n"
"Success : Success : ...\n"

#. type: Plain text
#: text/chapter13.md:384
#, fuzzy
msgid ""
"`quickCheckPure` takes three arguments: the random seed, the number of test "
"cases to generate, and the property to test. If all tests pass, you should "
"see an array of `Success` data constructors printed to the console."
msgstr ""
"`quickCheckPure`は乱数の種、生成するテストケースの数、テストする性質の３つの"
"引数をとります。もしすべてのテストケースに成功したら、 `Success`データ構築子"
"の配列がコンソールに出力されます。"

#. type: Plain text
#: text/chapter13.md:386
#, fuzzy
msgid ""
"`quickCheckPure` might be useful in other situations, such as generating "
"random input data for performance benchmarks, or generating sample form data "
"for web applications."
msgstr ""
"`quickCheckPure`は、性能ベンチマークの入力データ生成や、ウェブアプリケーショ"
"ンのフォームデータ例を無作為に生成するというような状況で便利かもしれません。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
#, fuzzy
msgid ""
"(Easy) Write `Coarbitrary` instances for the `Byte` and `Sorted` type "
"constructors."
msgstr ""
"（簡単） `Byte`と `Sorted`型構築子についての `Coarbitrary`インスタンスを書い"
"てください。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
#, fuzzy
msgid ""
"(Medium) Write a (higher-order) property which asserts associativity of the "
"`mergeWith f` function for any function `f`. Test your property in PSCi "
"using `quickCheckPure`."
msgstr ""
"（やや難しい）任意の関数 `f`について、 `mergeWith f`関数の結合性を主張する(高"
"階)性質を書いてください。 `quickCheckPure`を使って `PSCi`でその性質をテストし"
"てください。"

#. type: Bullet: ' 1. '
#: text/chapter13.md:392
#, fuzzy
msgid ""
"(Medium) Write `Arbitrary` and `Coarbitrary` instances for the following "
"data type:"
msgstr ""
"（やや難しい）次のデータ型の `Coarbitrary`インスタンスを書いてください。"

#. type: Plain text
#: text/chapter13.md:396
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     data OneTwoThree a = One a | Two a a | Three a a a\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    data OneTwoThree a = One a | Two a a | Three a a a\n"
"    ```\n"

#. type: Plain text
#: text/chapter13.md:400
#, fuzzy, no-wrap
msgid ""
"     _Hint_: Use the `oneOf` function defined in `Test.QuickCheck.Gen` to define your `Arbitrary` instance.\n"
" 1. (Medium) Use `all` to simplify the result of the `quickCheckPure` function - your new function should have type `List Result -> Boolean` and should return `true` if every test passes and `false` otherwise.\n"
" 1. (Medium) As another approach to simplifying the result of `quickCheckPure`, try writing a function `squashResults :: List Result -> Result`. Consider using the `First` monoid from `Data.Maybe.First` with the `foldMap` function to preserve the first error in case of failure.\n"
msgstr ""
"    **ヒント**：`Test.QuickCheck.Gen`で定義された `oneOf`関数を使って `Arbitrary`インスタンスを定義します。\n"
"1. (やや難しい)`all`関数を使って `quickCheckPure`関数の結果を単純化してください。その関数はもしどんなテストもパスするなら `true`を返し、そうでなければ `false`を返さなくてはいけません。 `purescript-monoids`で定義されている `First`モノイドを、失敗時の最初のエラーを保存するために `foldMap`関数と一緒に使ってみてください。\n"

#. type: Plain text
#: text/chapter13.md:404
#, fuzzy
msgid ""
"In this chapter, we met the `quickcheck` package, which can be used to write "
"tests in a declarative way using the paradigm of _generative testing_. In "
"particular:"
msgstr ""
"この章では、生成的テスティングのパラダイムを使って宣言的な方法でテストを書く"
"ための、 `purescript-quickcheck`パッケージを導入しました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
#, fuzzy
msgid "We saw how to automate QuickCheck tests using `spago test`."
msgstr "`pulp test`使ってQuickCheckをテストを自動化する方法を説明しました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
#, fuzzy
msgid ""
"We saw how to write properties as functions, and how to use the `<?>` "
"operator to improve error messages."
msgstr ""
"エラーメッセージを改良する `<?>`演算子の使い方と、性質を関数として書く方法を"
"説明しました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
#, fuzzy
msgid ""
"We saw how the `Arbitrary` and `Coarbitrary` type classes enable generation "
"of boilerplate testing code, and how they allow us to test higher-order "
"properties."
msgstr ""
"`Arbitrary`と `Coarbitrary`型クラスは、定型的なテストコードの自動生成を可能に"
"し、高階性質関数を可能にすることも説明しました。"

#. type: Bullet: '- '
#: text/chapter13.md:408
#, fuzzy
msgid ""
"We saw how to implement custom `Arbitrary` and `Coarbitrary` instances for "
"our own data types."
msgstr ""
"独自のデータ型に対して `Arbitrary`と `Coarbitrary`インスタンスを実装する方法"
"を説明しました。"

#. type: Title #
#: text/chapter14.md:1
#, fuzzy, no-wrap
msgid "Domain-Specific Languages"
msgstr "領域特化言語"

#. type: Plain text
#: text/chapter14.md:6
#, fuzzy
msgid ""
"In this chapter, we will explore the implementation of _domain-specific "
"languages_ (or _DSLs_) in PureScript, using a number of standard techniques."
msgstr ""
"この章では、多数の標準的な手法を使ったPureScriptにおける**領域特化言語"
"**(domain-specific language, DSL) の実装について探求していきます。"

#. type: Plain text
#: text/chapter14.md:8
#, fuzzy
msgid ""
"A domain-specific language is a language which is well-suited to development "
"in a particular problem domain. Its syntax and functions are chosen to "
"maximize readability of code used to express ideas in that domain. We have "
"already seen a number of examples of domain-specific languages in this book:"
msgstr ""
"領域特化言語とは、特定の問題領域での開発に適した言語のことです。領域特化言語"
"の構文および機能は、その領域内の考え方を表現するコードの読みやすさを最大限に"
"発揮すべく選択されます。本書の中では、すでに領域特化言語の例を幾つか見てきて"
"います。"

#. type: Plain text
#: text/chapter14.md:11
#, fuzzy
msgid ""
"- The `Game` monad and its associated actions, developed in chapter 11, "
"constitute a domain-specific language for the domain of _text adventure game "
"development_.  - The `quickcheck` package, covered in chapter 13, is a "
"domain-specific language for the domain of _generative testing_. Its "
"combinators enable a particularly expressive notation for test properties."
msgstr ""
"- 第11章で開発された `Game`モナドと関連するアクションは、**テキストアドベン"
"チャーゲーム開発**という領域に対しての領域特化言語を構成しています。 - 第12章"
"で `ContT`と `Parallel`関手のために書いたコンビネータのライブラリは、**非同期"
"プログラミング**の領域に対する領域特化言語の例と考えることができます。 - 第13"
"章で扱った `purescript-quickcheck`パッケージは、**生成的テスティング**の領域"
"の領域特化言語です。このコンビネータはテストの性質対して特に表現力の高い記法"
"を可能にします。"

#. type: Plain text
#: text/chapter14.md:13
#, fuzzy
msgid ""
"This chapter will take a more structured approach to some of standard "
"techniques in the implementation of domain-specific languages. It is by no "
"means a complete exposition of the subject, but should provide you with "
"enough knowledge to build some practical DSLs for your own tasks."
msgstr ""
"この章では、領域特化言語の実装において、いくつかの標準的な手法による構造的な"
"アプローチを取ります。これがこの話題の完全な説明だということでは決してありま"
"せんが、独自の目的に対する具体的なDSLを構築するには十分な知識を与えてくれるで"
"しょう。"

#. type: Plain text
#: text/chapter14.md:15
#, fuzzy
msgid ""
"Our running example will be a domain-specific language for creating HTML "
"documents. Our aim will be to develop a type-safe language for describing "
"correct HTML documents, and we will work by improving a naive implementation "
"in small steps."
msgstr ""
"この章で実行している例は、HTML文書を作成するための領域特化言語になります。正"
"しいHTML文書を記述するための型安全な言語を開発することが目的で、少しづつ実装"
"を改善することによって作業していきます。"

#. type: Plain text
#: text/chapter14.md:19
#, fuzzy
msgid ""
"The project accompanying this chapter adds one new dependency - the `free` "
"library, which defines the _free monad_, one of the tools which we will be "
"using."
msgstr ""
"この章で使うプロジェクトには新しいBower依存性が追加されます。これから使う道具"
"のひとつである**Freeモナド**が定義されている `purescript-free`ライブラリで"
"す。"

#. type: Plain text
#: text/chapter14.md:21
#, fuzzy
msgid "We will test this chapter's project in PSCi."
msgstr ""
"このプロジェクトのソースコードは、PSCiを使ってビルドすることができます。"

#. type: Title ##
#: text/chapter14.md:22
#, fuzzy, no-wrap
msgid "A HTML Data Type"
msgstr "HTMLデータ型"

#. type: Plain text
#: text/chapter14.md:25
#, fuzzy
msgid ""
"The most basic version of our HTML library is defined in the `Data.DOM."
"Simple` module. The module contains the following type definitions:"
msgstr ""
"このHTMLライブラリの最も基本的なバージョンは `Data.DOM.Simple`モジュールで定"
"義されています。このモジュールには次の型定義が含まれています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:26
#, fuzzy, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Array Content)\n"
"  }\n"
"\n"
"data Content\n"
"  = TextContent String\n"
"  | ElementContent Element\n"
"\n"
"newtype Attribute = Attribute\n"
"  { key          :: String\n"
"  , value        :: String\n"
"  }\n"
msgstr ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Array Content)\n"
"  }\n"
"\n"
"data Content\n"
"  = TextContent String\n"
"  | ElementContent Element\n"
"\n"
"newtype Attribute = Attribute\n"
"  { key          :: String\n"
"  , value        :: String\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:44
#, fuzzy
msgid ""
"The `Element` type represents HTML elements. Each element consists of an "
"element name, an array of attribute pairs and some content. The content "
"property uses the `Maybe` type to indicate that an element might be open "
"(containing other elements and text) or closed."
msgstr ""
"`Element`型はHTMLの要素を表しており、各要素は要素名、属性のペア​​の配列と、要素"
"の内容でで構成されています。 `content`プロパティでは、 `Maybe`タイプを使って"
"要素が開いている(他の要素やテキストを含む)か閉じているかを示しています。"

#. type: Plain text
#: text/chapter14.md:46
#, fuzzy
msgid "The key function of our library is a function"
msgstr "このライブラリの鍵となる機能は次の関数です。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:47
#, fuzzy, no-wrap
msgid "render :: Element -> String\n"
msgstr "render :: Element -> String\n"

#. type: Plain text
#: text/chapter14.md:52
#, fuzzy
msgid ""
"which renders HTML elements as HTML strings. We can try out this version of "
"the library by constructing values of the appropriate types explicitly in "
"PSCi:"
msgstr ""
"この関数はHTML要素をHTML文字列として出力します。 `PSCi`で明示的に適当な型の値"
"を構築し、ライブラリのこのバージョンを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter14.md:53
#, fuzzy, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Simple\n"
"> import Data.Maybe\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"â¦ log $ render $ Element\n"
"â¦   { name: \"p\"\n"
"â¦   , attribs: [\n"
"â¦       Attribute\n"
"â¦         { key: \"class\"\n"
"â¦         , value: \"main\"\n"
"â¦         }\n"
"â¦     ]\n"
"â¦   , content: Just [\n"
"â¦       TextContent \"Hello World!\"\n"
"â¦     ]\n"
"â¦   }\n"
"â¦ ^D\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""
"$ pulp repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Simple\n"
"> import Data.Maybe\n"
"> import Control.Monad.Eff.Console\n"
"\n"
"> :paste\n"
"… log $ render $ Element\n"
"…   { name: \"p\"\n"
"…   , attribs: [\n"
"…       Attribute\n"
"…         { key: \"class\"\n"
"…         , value: \"main\"\n"
"…         }\n"
"…     ]\n"
"…   , content: Just [\n"
"…       TextContent \"Hello World!\"\n"
"…     ]\n"
"…   }\n"
"… ^D\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:81
#, fuzzy
msgid "As it stands, there are several problems with this library:"
msgstr "現状のライブラリにはいくつかの問題があります。"

#. type: Bullet: '- '
#: text/chapter14.md:87
#, fuzzy
msgid ""
"Creating HTML documents is difficult - every new element requires at least "
"one record and one data constructor."
msgstr ""
"HTML文書の作成に手がかかります。すべての新しい要素が少なくとも1つのレコードと"
"1つのデータ構築子が必要です。"

#. type: Bullet: '- '
#: text/chapter14.md:87
#, fuzzy
msgid "It is possible to represent invalid documents:"
msgstr "無効な文書を表現できてしまいます。"

#. type: Bullet: '    - '
#: text/chapter14.md:87
#, fuzzy
msgid "The developer might mistype the element name"
msgstr "要素名の入力を間違えるかもしれません"

#. type: Bullet: '    - '
#: text/chapter14.md:87
#, fuzzy
msgid "The developer can associate an attribute with the wrong type of element"
msgstr "要素に間違った型の属性を関連付けることができてしまいます"

#. type: Bullet: '    - '
#: text/chapter14.md:87
#, fuzzy
msgid "The developer can use a closed element when an open element is correct"
msgstr "開いた要素が正しい場合でも、閉じた要素を使用することができてしまいます"

#. type: Plain text
#: text/chapter14.md:89
#, fuzzy
msgid ""
"In the remainder of the chapter, we will apply certain techniques to solve "
"these problems and turn our library into a usable domain-specific language "
"for creating HTML documents."
msgstr ""
"この章では、さまざまな手法を用いてこれらの問題を解決し、このライブラリーを"
"HTML文書を作成するために使える領域特化言語にしていきます。"

#. type: Title ##
#: text/chapter14.md:90
#, fuzzy, no-wrap
msgid "Smart Constructors"
msgstr "スマート構築子"

#. type: Plain text
#: text/chapter14.md:93
#, fuzzy
msgid ""
"The first technique we will apply is simple but can be very effective. "
"Instead of exposing the representation of the data to the module's users, we "
"can use the module exports list to hide the `Element`, `Content` and "
"`Attribute` data constructors, and only export so-called _smart "
"constructors_, which construct data which is known to be correct."
msgstr ""
"最初に導入する手法は方法は単純なものですが、とても効果的です。モジュールの使"
"用者にデータの表現を露出する代わりに、モジュールエクスポートリスト(module "
"exports list)を使ってデータ構築子 `Element`、 `Content`、 `Attribute`を隠蔽"
"し、正しいことが明らかなデータだけ構築する、いわゆる**スマート構築子**(smart "
"constructors)だけをエクスポートします。"

#. type: Plain text
#: text/chapter14.md:95
#, fuzzy
msgid ""
"Here is an example. First, we provide a convenience function for creating "
"HTML elements:"
msgstr ""
"例を示しましょう。まず、HTML要素を作成するための便利な関数を提供します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:96
#, fuzzy, no-wrap
msgid ""
"element :: String -> Array Attribute -> Maybe (Array Content) -> Element\n"
"element name attribs content = Element\n"
"  { name:      name\n"
"  , attribs:   attribs\n"
"  , content:   content\n"
"  }\n"
msgstr ""
"element :: String -> Array Attribute -> Maybe (Array Content) -> Element\n"
"element name attribs content = Element\n"
"  { name:      name\n"
"  , attribs:   attribs\n"
"  , content:   content\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:106
#, fuzzy
msgid ""
"Next, we create smart constructors for those HTML elements we want our users "
"to be able to create, by applying the `element` function:"
msgstr ""
"次に、 `element`関数を適用することによってHTML要素を作成する、スマート構築子"
"を作成します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:107
#, fuzzy, no-wrap
msgid ""
"a :: Array Attribute -> Array Content -> Element\n"
"a attribs content = element \"a\" attribs (Just content)\n"
"\n"
"p :: Array Attribute -> Array Content -> Element\n"
"p attribs content = element \"p\" attribs (Just content)\n"
"\n"
"img :: Array Attribute -> Element\n"
"img attribs = element \"img\" attribs Nothing\n"
msgstr ""
"a :: Array Attribute -> Array Content -> Element\n"
"a attribs content = element \"a\" attribs (Just content)\n"
"\n"
"p :: Array Attribute -> Array Content -> Element\n"
"p attribs content = element \"p\" attribs (Just content)\n"
"\n"
"img :: Array Attribute -> Element\n"
"img attribs = element \"img\" attribs Nothing\n"

#. type: Plain text
#: text/chapter14.md:119
#, fuzzy
msgid ""
"Finally, we update the module exports list to only export those functions "
"which are known to construct correct data structures:"
msgstr ""
"最後に、正しいデータ構造だけを構築することがわかっているこれらの関数をエクス"
"ポートするように、モジュールエクスポートリストを更新します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:120
#, fuzzy, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute(..)\n"
"  , Content(..)\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute(..)\n"
"  , Content(..)\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , render\n"
"  ) where\n"

#. type: Plain text
#: text/chapter14.md:135
#, fuzzy
msgid ""
"The module exports list is provided immediately after the module name inside "
"parentheses. Each module export can be one of three types:"
msgstr ""
"モジュールエクスポートリストはモジュール名の直後の括弧内に書きます。各モ"
"ジュールのエクスポートは次の3種類のいずれかです。"

#. type: Plain text
#: text/chapter14.md:139
#, fuzzy
msgid ""
"- A value (or function), indicated by the name of the value, - A type class, "
"indicated by the name of the class, - A type constructor and any associated "
"data constructors, indicated by the name of the type followed by a "
"parenthesized list of exported data constructors."
msgstr ""
"- 値の名前で示された、値(または関数)  - クラスの名で示された、型クラス - 型の"
"名前で示された型構築子、およびそれに続けて括弧で囲まれた関連するデータ構築子"
"のリスト"

#. type: Plain text
#: text/chapter14.md:141
#, fuzzy
msgid ""
"Here, we export the `Element` _type_, but we do not export its data "
"constructors. If we did, the user would be able to construct invalid HTML "
"elements."
msgstr ""
"ここでは、 `Element`の**型**をエクスポートしていますが、データ構築子はエクス"
"ポートしていません。もしデータ構築子をエクスポートすると、モジュールの使用者"
"が不正なHTML要素を構築できてしまいます。"

#. type: Plain text
#: text/chapter14.md:143
#, fuzzy
msgid ""
"In the case of the `Attribute` and `Content` types, we still export all of "
"the data constructors (indicated by the symbol `..` in the exports list). We "
"will apply the technique of smart constructors to these types shortly."
msgstr ""
"`Attribute`と `Content`型についてはデータ構築子をすべてエクスポートしています"
"(エクスポートリストの記号 `..`で示されています)。これから、これらの型にスマー"
"ト構築子の手法を適用していきます。"

#. type: Plain text
#: text/chapter14.md:145
#, fuzzy
msgid "Notice that we have already made some big improvements to our library:"
msgstr ""
"すでにライブラリにいくつかの大きな改良を加わっていることに注意してください。"

#. type: Plain text
#: text/chapter14.md:148
#, fuzzy
msgid ""
"- It is impossible to represent HTML elements with invalid names (of course, "
"we are restricted to the set of element names provided by the library).  - "
"Closed elements cannot contain content by construction."
msgstr ""
"- 不正な名前を持つHTML要素を表現することは不可能です(もちろん、ライブラリが提"
"供する要素名に制限されています)。 - 閉じた要素は、構築するときに内容を含める"
"ことはできません。"

#. type: Plain text
#: text/chapter14.md:150
#, fuzzy
msgid ""
"We can apply this technique to the `Content` type very easily. We simply "
"remove the data constructors for the `Content` type from the exports list, "
"and provide the following smart constructors:"
msgstr ""
"`Content`型にもとても簡単にこの手法を適用することができます。単にエクスポート"
"リストから `Content`型のデータ構築子を取り除き、次のスマート構築子を提供しま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:151
#, fuzzy, no-wrap
msgid ""
"text :: String -> Content\n"
"text = TextContent\n"
"\n"
"elem :: Element -> Content\n"
"elem = ElementContent\n"
msgstr ""
"text :: String -> Content\n"
"text = TextContent\n"
"\n"
"elem :: Element -> Content\n"
"elem = ElementContent\n"

#. type: Plain text
#: text/chapter14.md:160
#, fuzzy
msgid ""
"Let's apply the same technique to the `Attribute` type. First, we provide a "
"general-purpose smart constructor for attributes. Here is a first attempt:"
msgstr ""
"`Attribute`型にも同じ手法を適用してみましょう。まず、属性のための汎用のスマー"
"ト構築子を用意します。最初の試みとしては、次のようなものになるかもしれませ"
"ん。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:161
#, fuzzy, no-wrap
msgid ""
"attribute :: String -> String -> Attribute\n"
"attribute key value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
"\n"
"infix 4 attribute as :=\n"
msgstr ""
"attribute :: String -> String -> Attribute\n"
"attribute key value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
"\n"
"infix 4 attribute as :=\n"

#. type: Plain text
#: text/chapter14.md:172
#, fuzzy
msgid ""
"This representation suffers from the same problem as the original `Element` "
"type - it is possible to represent attributes which do not exist or whose "
"names were entered incorrectly. To solve this problem, we can create a "
"newtype which represents attribute names:"
msgstr ""
"この定義では元の `Element`型と同じ問題に悩まされています。存在しなかったり、"
"名前が間違っているような属性を表現することが可能です。この問題を解決するため"
"に、属性名を表すnewtypeを作成します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:173
#, fuzzy, no-wrap
msgid "newtype AttributeKey = AttributeKey String\n"
msgstr "newtype AttributeKey = AttributeKey String\n"

#. type: Plain text
#: text/chapter14.md:178
#, fuzzy
msgid "With that, we can modify our operator as follows:"
msgstr "それから、この演算子を次のように変更します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:179
#, fuzzy, no-wrap
msgid ""
"attribute :: AttributeKey -> String -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"
msgstr ""
"attribute :: AttributeKey -> String -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: value\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:188
#, fuzzy
msgid ""
"If we do not export the `AttributeKey` data constructor, then the user has "
"no way to construct values of type `AttributeKey` other than by using "
"functions we explicitly export. Here are some examples:"
msgstr ""
"`AttributeKey`データ構築子をエクスポートしなければ、明示的にエクスポートされ"
"た次のような関数を使う以外に、使用者が型 `AttributeKey`の値を構築する方法はあ"
"りません。いくつかの例を示します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:189
#, fuzzy, no-wrap
msgid ""
"href :: AttributeKey\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey\n"
"height = AttributeKey \"height\"\n"
msgstr ""
"href :: AttributeKey\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey\n"
"height = AttributeKey \"height\"\n"

#. type: Plain text
#: text/chapter14.md:207
#, fuzzy
msgid ""
"Here is the final exports list for our new module. Note that we no longer "
"export any data constructors directly:"
msgstr ""
"新しいモジュールの最終的なエクスポートリストは次のようになります。もうどんな"
"データ構築子も直接エクスポートしていないことに注意してください。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:208
#, fuzzy, no-wrap
msgid ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute\n"
"  , Content\n"
"  , AttributeKey\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , href\n"
"  , _class\n"
"  , src\n"
"  , width\n"
"  , height\n"
"\n"
"  , attribute, (:=)\n"
"  , text\n"
"  , elem\n"
"\n"
"  , render\n"
"  ) where\n"
msgstr ""
"module Data.DOM.Smart\n"
"  ( Element\n"
"  , Attribute\n"
"  , Content\n"
"  , AttributeKey\n"
"\n"
"  , a\n"
"  , p\n"
"  , img\n"
"\n"
"  , href\n"
"  , _class\n"
"  , src\n"
"  , width\n"
"  , height\n"
"\n"
"  , attribute, (:=)\n"
"  , text\n"
"  , elem\n"
"\n"
"  , render\n"
"  ) where\n"

#. type: Plain text
#: text/chapter14.md:234
#, fuzzy
msgid ""
"If we try this new module in PSCi, we can already see massive improvements "
"in the conciseness of the user code:"
msgstr ""
"`PSCi`でこの新しいモジュールを試してみると、コードが大幅に簡潔になり、改良さ"
"れていることがわかります。"

#. type: Fenced code block (text)
#: text/chapter14.md:235
#, fuzzy, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Smart\n"
"> import Effect.Console\n"
"> log $ render $ p [ _class := \"main\" ] [ text \"Hello World!\" ]\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"
msgstr ""
"$ pulp repl\n"
"\n"
"> import Prelude\n"
"> import Data.DOM.Smart\n"
"> import Control.Monad.Eff.Console\n"
"> log $ render $ p [ _class := \"main\" ] [ text \"Hello World!\" ]\n"
"\n"
"<p class=\"main\">Hello World!</p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:248
#, fuzzy
msgid ""
"Note, however, that no changes had to be made to the `render` function, "
"because the underlying data representation never changed. This is one of the "
"benefits of the smart constructors approach - it allows us to separate the "
"internal data representation for a module from the representation which is "
"perceived by users of its external API."
msgstr ""
"しかし、基礎のデータ表現が変更されていないので、 `render`関数を変更する必要は"
"なかったことにも注目してください。これはスマート構築子による手法の利点のひと"
"つです。外部APIの使用者によって認識される表現から、モジュールの内部データ表現"
"を分離することができるのです。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:253
#, fuzzy
msgid ""
"(Easy) Use the `Data.DOM.Smart` module to experiment by creating new HTML "
"documents using `render`."
msgstr ""
"(簡単)`Data.DOM.Smart`モジュールで `render`を使った新しいHTML文書の作成を試し"
"てみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:253
#, fuzzy
msgid ""
"(Medium) Some HTML attributes such as `checked` and `disabled` do not "
"require values, and may be rendered as _empty attributes_:"
msgstr ""
"(やや難しい)　`checked`と `disabled`など、値を要求しないHTML属性があります"
"が、これらは次のような**空の属性**として表示されるかもしれません。"

#. type: Plain text
#: text/chapter14.md:257
#, fuzzy, no-wrap
msgid ""
"     ```html\n"
"     <input disabled>\n"
"     ```\n"
msgstr ""
"    ```html\n"
"    &lt;input disabled&gt;\n"
"    ```\n"

#. type: Plain text
#: text/chapter14.md:259
#, fuzzy, no-wrap
msgid "     Modify the representation of an `Attribute` to take empty attributes into account. Write a function which can be used in place of `attribute` or `:=` to add an empty attribute to an element.\n"
msgstr "    空の属性を扱えるように `Attribute`の表現を変更してください。要素に空の属性を追加するために、 `attribute`または `:=`の代わりに使える関数を記述してください。\n"

#. type: Title ##
#: text/chapter14.md:260
#, fuzzy, no-wrap
msgid "Phantom Types"
msgstr "幻影型"

#. type: Plain text
#: text/chapter14.md:263
#, fuzzy
msgid "To motivate the next technique, consider the following code:"
msgstr ""
"次に適用する手法についての動機を与えるために、次のコードを考えてみます。"

#. type: Fenced code block (text)
#: text/chapter14.md:264
#, fuzzy, no-wrap
msgid ""
"> log $ render $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := \"foo\"\n"
"    , height := \"bar\"\n"
"    ]\n"
"\n"
"<img src=\"cat.jpg\" width=\"foo\" height=\"bar\" />\n"
"unit\n"
msgstr ""
"> log $ render $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := \"foo\"\n"
"    , height := \"bar\"\n"
"    ]\n"
"\n"
"&lt;img src=\"cat.jpg\" width=\"foo\" height=\"bar\" /&gt;\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:276
#, fuzzy
msgid ""
"The problem here is that we have provided string values for the `width` and "
"`height` attributes, where we should only be allowed to provide numeric "
"values in units of pixels or percentage points."
msgstr ""
"ここでの問題は、 `width`と `height`についての文字列値を提供しているということ"
"で、ここで与えることができるのはピクセルやパーセントの単位の数値だけであるべ"
"きです。"

#. type: Plain text
#: text/chapter14.md:278
#, fuzzy
msgid ""
"To solve this problem, we can introduce a so-called _phantom type_ argument "
"to our `AttributeKey` type:"
msgstr ""
"`AttributeKey`型にいわゆる**幻影型**(phantom type)引数を導入すると、この問題"
"を解決できます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:279
#, fuzzy, no-wrap
msgid "newtype AttributeKey a = AttributeKey String\n"
msgstr "newtype AttributeKey a = AttributeKey String\n"

#. type: Plain text
#: text/chapter14.md:284
#, fuzzy
msgid ""
"The type variable `a` is called a _phantom type_ because there are no values "
"of type `a` involved in the right-hand side of the definition. The type `a` "
"only exists to provide more information at compile-time. Any value of type "
"`AttributeKey a` is simply a string at runtime, but at compile-time, the "
"type of the value tells us the desired type of the values associated with "
"this key."
msgstr ""
"定義の右辺に対応する型 `a`の値が存在しないので、この型変数 `a`は**幻影型**と"
"呼ばれています。この型 `a`はコンパイル時により多くの情報を提供するためだけに"
"存在しています。任意の型 `AttributeKey a`の値は実行時には単なる文字列ですが、"
"そのキーに関連付けられた値に期待されている型を教えてくれます。"

#. type: Plain text
#: text/chapter14.md:286
#, fuzzy
msgid ""
"We can modify the type of our `attribute` function to take the new form of "
"`AttributeKey` into account:"
msgstr ""
"`AttributeKey`の新しい形式で受け取るように、 `attribute`関数の型を次のように"
"変更します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:287
#, fuzzy, no-wrap
msgid ""
"attribute :: forall a. IsValue a => AttributeKey a -> a -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: toValue value\n"
"  }\n"
msgstr ""
"attribute :: forall a. IsValue a => AttributeKey a -> a -> Attribute\n"
"attribute (AttributeKey key) value = Attribute\n"
"  { key: key\n"
"  , value: toValue value\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:296
#, fuzzy
msgid ""
"Here, the phantom type argument `a` is used to ensure that the attribute key "
"and attribute value have compatible types. Since the user cannot create "
"values of type `AttributeKey a` directly (only via the constants we provide "
"in the library), every attribute will be correct by construction."
msgstr ""
"ここで、幻影型の引数 `a`は、属性キーと属性値が互換性のある型を持っていること"
"を確認するために使われます。使用者は `AttributeKey a`を型の値を直接作成できな"
"いので(ライブラリで提供されている定数を介してのみ得ることができます)、すべて"
"の属性が正しくなります。"

#. type: Plain text
#: text/chapter14.md:298
#, fuzzy
msgid ""
"Note that the `IsValue` constraint ensures that whatever value type we "
"associate to a key, its values can be converted to strings and displayed in "
"the generated HTML. The `IsValue` type class is defined as follows:"
msgstr ""
"`IsValue`制約は、キーに関連付けられた値がなんであれ、その値を文字列に変換し、"
"生成したHTML内に出力できることを保証します。 `IsValue`型クラスは次のように定"
"義されています。　　"

#. type: Fenced code block (haskell)
#: text/chapter14.md:299
#, fuzzy, no-wrap
msgid ""
"class IsValue a where\n"
"  toValue :: a -> String\n"
msgstr ""
"class IsValue a where\n"
"  toValue :: a -> String\n"

#. type: Plain text
#: text/chapter14.md:305
#, fuzzy
msgid "We also provide type class instances for the `String` and `Int` types:"
msgstr "`String`と `Int`型についての型クラスインスタンスも提供しておきます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:306
#, fuzzy, no-wrap
msgid ""
"instance stringIsValue :: IsValue String where\n"
"  toValue = id\n"
"\n"
"instance intIsValue :: IsValue Int where\n"
"  toValue = show\n"
msgstr ""
"instance stringIsValue :: IsValue String where\n"
"  toValue = id\n"
"\n"
"instance intIsValue :: IsValue Int where\n"
"  toValue = show\n"

#. type: Plain text
#: text/chapter14.md:315
#, fuzzy
msgid ""
"We also have to update our `AttributeKey` constants so that their types "
"reflect the new type parameter:"
msgstr ""
"また、これらの型が新しい型変数を反映するように、 `AttributeKey`定数を更新しな"
"ければいけません。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:316
#, fuzzy, no-wrap
msgid ""
"href :: AttributeKey String\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey String\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey String\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey Int\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey Int\n"
"height = AttributeKey \"height\"\n"
msgstr ""
"href :: AttributeKey String\n"
"href = AttributeKey \"href\"\n"
"\n"
"_class :: AttributeKey String\n"
"_class = AttributeKey \"class\"\n"
"\n"
"src :: AttributeKey String\n"
"src = AttributeKey \"src\"\n"
"\n"
"width :: AttributeKey Int\n"
"width = AttributeKey \"width\"\n"
"\n"
"height :: AttributeKey Int\n"
"height = AttributeKey \"height\"\n"

#. type: Plain text
#: text/chapter14.md:334
#, fuzzy
msgid ""
"Now we find it is impossible to represent these invalid HTML documents, and "
"we are forced to use numbers to represent the `width` and `height` "
"attributes instead:"
msgstr ""
"これで、不正なHTML文書を表現することが不可能で、 `width`と `height`属性を表現"
"するのに数を使うことが強制されていることがわかります。"

#. type: Fenced code block (text)
#: text/chapter14.md:335
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Phantom\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"â¦ log $ render $ img\n"
"â¦   [ src    := \"cat.jpg\"\n"
"â¦   , width  := 100\n"
"â¦   , height := 200\n"
"â¦   ]\n"
"â¦ ^D\n"
"\n"
"<img src=\"cat.jpg\" width=\"100\" height=\"200\" />\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Phantom\n"
"> import Control.Monad.Eff.Console\n"
"\n"
"> :paste\n"
"… log $ render $ img\n"
"…   [ src    := \"cat.jpg\"\n"
"…   , width  := 100\n"
"…   , height := 200\n"
"…   ]\n"
"… ^D\n"
"\n"
"&lt;img src=\"cat.jpg\" width=\"100\" height=\"200\" /&gt;\n"
"unit\n"

#. type: Bullet: ' 1. '
#: text/chapter14.md:356
#, fuzzy
msgid ""
"(Easy) Create a data type which represents either pixel or percentage "
"lengths. Write an instance of `IsValue` for your type. Modify the `width` "
"and `height` attributes to use your new type."
msgstr ""
"(簡単) ピクセルまたはパーセントの長さのいずれかを表すデータ型を作成してくださ"
"い。その型について `IsValue`のインスタンスを書いてください。この型を使うよう"
"に `width`と `height`属性を変更してください。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:356
#, fuzzy
msgid ""
"(Difficult) By defining type-level representatives for the Boolean values "
"`true` and `false`, we can use a phantom type to encode whether an "
"`AttributeKey` represents an _empty attribute_ such as `disabled` or "
"`checked`."
msgstr ""
"(難しい) 幻影型を使って真偽値 `true`、 `false`についての表現を最上位で定義す"
"ることで、 `AttributeKey`が `disabled`や `chacked`のような**空の属性**を表現"
"しているかどうかを符号化することができます。"

#. type: Plain text
#: text/chapter14.md:361
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     data True\n"
"     data False\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    data True\n"
"    data False\n"
"    ```\n"

#. type: Plain text
#: text/chapter14.md:363
#, fuzzy, no-wrap
msgid "     Modify your solution to the previous exercise to use a phantom type to prevent the user from using the `attribute` operator with an empty attribute.\n"
msgstr "    幻影型を使って、使用者が `attribute`演算子を空の属性に対して使うことを防ぐように、前の演習の解答を変更してください。\n"

#. type: Title ##
#: text/chapter14.md:364
#, fuzzy, no-wrap
msgid "The Free Monad"
msgstr "Freeモナド"

#. type: Plain text
#: text/chapter14.md:367
#, fuzzy
msgid ""
"In our final set of modifications to our API, we will use a construction "
"called the _free monad_ to turn our `Content` type into a monad, enabling do "
"notation. This will allow us to structure our HTML documents in a form in "
"which the nesting of elements becomes clearer - instead of this:"
msgstr ""
"APIに施す最後の変更は、 `Content`型をモナドにしてdo記法を使えるようにするため"
"に、**Freeモナド**と呼ばれる構造を使うことです。Freeモナドは、入れ子になった"
"要素をわかりやすくなるよう、HTML文書の構造化を可能にします。次のようなコード"
"を考えます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:368
#, fuzzy, no-wrap
msgid ""
"p [ _class := \"main\" ]\n"
"  [ elem $ img\n"
"      [ src    := \"cat.jpg\"\n"
"      , width  := 100\n"
"      , height := 200\n"
"      ]\n"
"  , text \"A cat\"\n"
"  ]\n"
msgstr ""
"p [ _class := \"main\" ]\n"
"  [ elem $ img\n"
"      [ src    := \"cat.jpg\"\n"
"      , width  := 100\n"
"      , height := 200\n"
"      ]\n"
"  , text \"A cat\"\n"
"  ]\n"

#. type: Plain text
#: text/chapter14.md:380
#, fuzzy
msgid "we will be able to write this:"
msgstr "これを次のように書くことができるようになります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:381
#, fuzzy, no-wrap
msgid ""
"p [ _class := \"main\" ] $ do\n"
"  elem $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := 100\n"
"    , height := 200\n"
"    ]\n"
"  text \"A cat\"\n"
msgstr ""
"p [ _class := \"main\" ] $ do\n"
"  elem $ img\n"
"    [ src    := \"cat.jpg\"\n"
"    , width  := 100\n"
"    , height := 200\n"
"    ]\n"
"  text \"A cat\"\n"

#. type: Plain text
#: text/chapter14.md:392
#, fuzzy
msgid ""
"However, do notation is not the only benefit of a free monad. The free monad "
"allows us to separate the _representation_ of our monadic actions from their "
"_interpretation_, and even support _multiple interpretations_ of the same "
"actions."
msgstr ""
"しかし、do記法だけがFreeモナドの恩恵だというわけではありません。モナドのアク"
"ションの**表現**をその**解釈**から分離し、同じアクションに**複数の解釈**を持"
"たせることをFreeモナドは可能にします。"

#. type: Plain text
#: text/chapter14.md:394
#, fuzzy
msgid ""
"The `Free` monad is defined in the `free` library, in the `Control.Monad."
"Free` module. We can find out some basic information about it using PSCi, as "
"follows:"
msgstr ""
"`Free`モナドは `purescript-free`ライブラリの `Control.Monad.Free`モジュールで"
"定義されています。 `PSCi`を使うと、次のようにFreeモナドについての基本的な情報"
"を見ることができます。"

#. type: Fenced code block (text)
#: text/chapter14.md:395
#, fuzzy, no-wrap
msgid ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"
msgstr ""
"> import Control.Monad.Free\n"
"\n"
"> :kind Free\n"
"(Type -> Type) -> Type -> Type\n"

#. type: Plain text
#: text/chapter14.md:403
#, fuzzy
msgid ""
"The kind of `Free` indicates that it takes a type constructor as an "
"argument, and returns another type constructor. In fact, the `Free` monad "
"can be used to turn any `Functor` into a `Monad`!"
msgstr ""
"`Free`の種は、引数として型構築子を取り、別の型構築子を返すことを示していま"
"す。実は、 `Free`モナドは任意の `Functor`を `Monad`にするために使うことができ"
"ます！"

#. type: Plain text
#: text/chapter14.md:405
#, fuzzy
msgid ""
"We begin by defining the _representation_ of our monadic actions. To do "
"this, we need to create a `Functor` with one data constructor for each "
"monadic action we wish to support. In our case, our two monadic actions will "
"be `elem` and `text`. In fact, we can simply modify our `Content` type as "
"follows:"
msgstr ""
"モナドのアクションの**表現**を定義することから始めます。これを行うには、サ"
"ポートする各モナドアクションそれぞれについて、ひとつのデータ構築子を持つ "
"`Functor`を作成する必要があります。今回の場合、2つのモナドのアクションは "
"`elem`と `text`になります。実際には、 `Content`型を次のように変更するだけで"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:406
#, fuzzy, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"\n"
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
msgstr ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"\n"
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"

#. type: Plain text
#: text/chapter14.md:417
#, fuzzy
msgid ""
"Here, the `ContentF` type constructor looks just like our old `Content` data "
"type - however, it now takes a type argument `a`, and each data constructor "
"has been modified to take a value of type `a` as an additional argument. The "
"`Functor` instance simply applies the function `f` to the value of type `a` "
"in each data constructor."
msgstr ""
"ここで、この `ContentF`型構築子は以前の `Content`データ型とよく似ています。 "
"`Functor`インスタンスでは、単に各データ構築子で型 `a`の構成要素に関数 `f`を適"
"用します。"

#. type: Plain text
#: text/chapter14.md:419
#, fuzzy
msgid ""
"With that, we can define our new `Content` monad as a type synonym for the "
"`Free` monad, which we construct by using our `ContentF` type constructor as "
"the first type argument:"
msgstr ""
"これにより、最初の型引数として `ContentF`型構築子を使うことで構築された、新し"
"い `Content`型構築子を `Free`モナドを包むnewtypeとして定義することができま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:420
#, fuzzy, no-wrap
msgid "type Content = Free ContentF\n"
msgstr "type Content = Free ContentF\n"

#. type: Plain text
#: text/chapter14.md:425
#, fuzzy
msgid ""
"Instead of a type synonym, we might use a `newtype` to avoid exposing the "
"internal representation of our library to our users - by hiding the "
"`Content` data constructor, we restrict our users to only using the monadic "
"actions we provide."
msgstr ""
"型のシノニムの代わりにnewtypeを使用して、使用者に対してライブラリの内部表現を"
"露出することを避ける事ができます。 `Content`データ構築子を隠すことで、提供し"
"ているモナドのアクションだけを使うことを仕様者に制限しています。"

#. type: Plain text
#: text/chapter14.md:427
#, fuzzy
msgid ""
"Because `ContentF` is a `Functor`, we automatically get a `Monad` instance "
"for `Free ContentF`."
msgstr ""
"`ContentF`は `Functor`なので、 `Free ContentF`に対する `Monad`インスタンスが"
"自動的に手に入り、このインスタンスを `Content`上の `Monad`インスタンスへと持"
"ち上げることができます。"

#. type: Plain text
#: text/chapter14.md:429
#, fuzzy
msgid ""
"We have to modify our `Element` data type slightly to take account of the "
"new type argument on `Content`. We will simply require that the return type "
"of our monadic computations be `Unit`:"
msgstr ""
"`Content`の新しい型引数を考慮するように、少し `Element`データ型を変更する必要"
"があります。モナドの計算の戻り値の型が `Unit`であることだけが要求されます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:430
#, fuzzy, no-wrap
msgid ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Content Unit)\n"
"  }\n"
msgstr ""
"newtype Element = Element\n"
"  { name         :: String\n"
"  , attribs      :: Array Attribute\n"
"  , content      :: Maybe (Content Unit)\n"
"  }\n"

#. type: Plain text
#: text/chapter14.md:439
#, fuzzy
msgid ""
"In addition, we have to modify our `elem` and `text` functions, which become "
"our new monadic actions for the `Content` monad. To do this, we can use the "
"`liftF` function, provided by the `Control.Monad.Free` module. Here is its "
"type:"
msgstr ""
"また、 `Content`モナドについての新しいモナドのアクションになる `elem`と "
"`text`関数を変更する必要があります。これを行うには、 `Control.Monad.Free`モ"
"ジュールで提供されている `liftF`関数を使います。この関数の(簡略化された)型は"
"次のようになっています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:440
#, fuzzy, no-wrap
msgid "liftF :: forall f a. f a -> Free f a\n"
msgstr "liftF :: forall f a. (Functor f) => f a -> Free f a\n"

#. type: Plain text
#: text/chapter14.md:445
#, fuzzy
msgid ""
"`liftF` allows us to construct an action in our free monad from a value of "
"type `f a` for some type `a`. In our case, we can simply use the data "
"constructors of our `ContentF` type constructor directly:"
msgstr ""
"`liftF`は、何らかの型 `a`について、型 `f a`の値からFreeモナドのアクションを構"
"築できるようにします。今回の場合、 `ContentF`型構築子のデータ構築子を次のよう"
"にそのまま使うだけです。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:446
#, fuzzy, no-wrap
msgid ""
"text :: String -> Content Unit\n"
"text s = liftF $ TextContent s unit\n"
"\n"
"elem :: Element -> Content Unit\n"
"elem e = liftF $ ElementContent e unit\n"
msgstr ""
"text :: String -> Content Unit\n"
"text s = liftF $ TextContent s unit\n"
"\n"
"elem :: Element -> Content Unit\n"
"elem e = liftF $ ElementContent e unit\n"

#. type: Plain text
#: text/chapter14.md:455
#, fuzzy
msgid ""
"Some other routine modifications have to be made, but the interesting "
"changes are in the `render` function, where we have to _interpret_ our free "
"monad."
msgstr ""
"他にもコードの変更はありますが、興味深い変更は `render`関数に対してのもので"
"す。ここでは、このFreeモナドを**解釈**しなければいけません。"

#. type: Title ##
#: text/chapter14.md:456
#, fuzzy, no-wrap
msgid "Interpreting the Monad"
msgstr "モナドの解釈"

#. type: Plain text
#: text/chapter14.md:459
#, fuzzy
msgid ""
"The `Control.Monad.Free` module provides a number of functions for "
"interpreting a computation in a free monad:"
msgstr ""
"`Control.Monad.Free`モジュールでは、Freeモナドで計算を解釈するための多数の関"
"数が提供されています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:460
#, fuzzy, no-wrap
msgid ""
"runFree\n"
"  :: forall f a\n"
"   . Functor f\n"
"  => (f (Free f a) -> Free f a)\n"
"  -> Free f a\n"
"  -> a\n"
"\n"
"runFreeM\n"
"  :: forall f m a\n"
"   . (Functor f, MonadRec m)\n"
"  => (f (Free f a) -> m (Free f a))\n"
"  -> Free f a\n"
"  -> m a\n"
msgstr ""
"runFree\n"
"  :: forall f a\n"
"   . Functor f\n"
"  => (f (Free f a) -> Free f a)\n"
"  -> Free f a\n"
"  -> a\n"
"\n"
"runFreeM\n"
"  :: forall f m a\n"
"   . (Functor f, MonadRec m)\n"
"  => (f (Free f a) -> m (Free f a))\n"
"  -> Free f a\n"
"  -> m a\n"

#. type: Plain text
#: text/chapter14.md:477
#, fuzzy
msgid ""
"The `runFree` function is used to compute a _pure_ result. The `runFreeM` "
"function allows us to use a monad to interpret the actions of our free monad."
msgstr ""
"`runFree`関数は、**純粋な**結果を計算するために使用されます。 `runFreeM`関数"
"は、フリーモナドの動作を解釈するためにモナドを使用することを可能にします"

#. type: Plain text
#: text/chapter14.md:479
#, fuzzy
msgid ""
"_Note_: Technically, we are restricted to using monads `m` which satisfy the "
"stronger `MonadRec` constraint. In practice, this means that we don't need "
"to worry about stack overflow, since `m` supports safe _monadic tail "
"recursion_."
msgstr ""
"厳密には、 `MonadRec`のより強い制約を満たすモナド `m`を使用する制限がされてい"
"ます。これはスタックオーバーフローを心配する必要がないことを意味します。なぜ"
"なら `m`は安全な**末尾再帰モナド**(monadic tail recursion)をサポートするから"
"です。"

#. type: Plain text
#: text/chapter14.md:481
#, fuzzy
msgid ""
"First, we have to choose a monad in which we can interpret our actions. We "
"will use the `Writer String` monad to accumulate a HTML string as our result."
msgstr ""
"まず、アクションを解釈することができるモナドを選ばなければなりません。 "
"`Writer String`モナドを使って、結果のHTML文字列を累積することにします。"

#. type: Plain text
#: text/chapter14.md:483
#, fuzzy
msgid ""
"Our new `render` method starts by delegating to a helper function, "
"`renderElement`, and using `execWriter` to run our computation in the "
"`Writer` monad:"
msgstr ""
"新しい `render`メソッドは補助関数 `renderElement`に移譲して開始し、 `Writer`"
"モナドで計算を実行するため `execWriter`を使用します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:484
#, fuzzy, no-wrap
msgid ""
"render :: Element -> String\n"
"render = execWriter <<< renderElement\n"
msgstr ""
"render :: Element -> String\n"
"render = execWriter <<< renderElement\n"

#. type: Plain text
#: text/chapter14.md:490
#, fuzzy
msgid "`renderElement` is defined in a where block:"
msgstr "`renderElement`はwhereブロックで定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:491
#, fuzzy, no-wrap
msgid ""
"  where\n"
"    renderElement :: Element -> Writer String Unit\n"
"    renderElement (Element e) = do\n"
msgstr ""
"  where\n"
"    renderElement :: Element -> Writer String Unit\n"
"    renderElement (Element e) = do\n"

#. type: Plain text
#: text/chapter14.md:498
#, fuzzy
msgid ""
"The definition of `renderElement` is straightforward, using the `tell` "
"action from the `Writer` monad to accumulate several small strings:"
msgstr ""
"`renderElement`の定義は簡単で、いくつかの小さな文字列を累積するために "
"`Writer`モナドの `tell`アクションを使っています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:499
#, fuzzy, no-wrap
msgid ""
"      tell \"<\"\n"
"      tell e.name\n"
"      for_ e.attribs $ \\x -> do\n"
"        tell \" \"\n"
"        renderAttribute x\n"
"      renderContent e.content\n"
msgstr ""
"      tell \"<\"\n"
"      tell e.name\n"
"      for_ e.attribs $ \\x -> do\n"
"        tell \" \"\n"
"        renderAttribute x\n"
"      renderContent e.content\n"

#. type: Plain text
#: text/chapter14.md:509
#, fuzzy
msgid ""
"Next, we define the `renderAttribute` function, which is equally simple:"
msgstr "次に、同じように簡単な `renderAttribute`関数を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:510
#, fuzzy, no-wrap
msgid ""
"    where\n"
"      renderAttribute :: Attribute -> Writer String Unit\n"
"      renderAttribute (Attribute x) = do\n"
"        tell x.key\n"
"        tell \"=\\\"\"\n"
"        tell x.value\n"
"        tell \"\\\"\"\n"
msgstr ""
"    where\n"
"      renderAttribute :: Attribute -> Writer String Unit\n"
"      renderAttribute (Attribute x) = do\n"
"        tell x.key\n"
"        tell \"=\\\"\"\n"
"        tell x.value\n"
"        tell \"\\\"\"\n"

#. type: Plain text
#: text/chapter14.md:521
#, fuzzy
msgid ""
"The `renderContent` function is more interesting. Here, we use the "
"`runFreeM` function to interpret the computation inside the free monad, "
"delegating to a helper function, `renderContentItem`:"
msgstr ""
"`renderContent`関数は、もっと興味深いものです。ここでは、 `runFreeM`関数を"
"使って、Freeモナドの内部で補助関数 `renderContentItem`に移譲する計算を解釈し"
"ています。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:522
#, fuzzy, no-wrap
msgid ""
"      renderContent :: Maybe (Content Unit) -> Writer String Unit\n"
"      renderContent Nothing = tell \" />\"\n"
"      renderContent (Just content) = do\n"
"        tell \">\"\n"
"        runFreeM renderContentItem content\n"
"        tell \"</\"\n"
"        tell e.name\n"
"        tell \">\"\n"
msgstr ""
"      renderContent :: Maybe (Content Unit) -> Writer String Unit\n"
"      renderContent Nothing = tell \" />\"\n"
"      renderContent (Just content) = do\n"
"        tell \">\"\n"
"        runFreeM renderContentItem content\n"
"        tell \"</\"\n"
"        tell e.name\n"
"        tell \">\"\n"

#. type: Plain text
#: text/chapter14.md:534
#, fuzzy
msgid ""
"The type of `renderContentItem` can be deduced from the type signature of "
"`runFreeM`. The functor `f` is our type constructor `ContentF`, and the "
"monad `m` is the monad in which we are interpreting the computation, namely "
"`Writer String`. This gives the following type signature for "
"`renderContentItem`:"
msgstr ""
"`renderContentItem`の型は `runFreeM`の型シグネチャから推測することができま"
"す。関手 `f`は型構築子 `ContentF`で、モナド `m`は解釈している計算のモナド、つ"
"まり `Writer String`です。これにより `renderContentItem`について次の型シグネ"
"チャがわかります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:535
#, fuzzy, no-wrap
msgid "      renderContentItem :: ContentF (Content Unit) -> Writer String (Content Unit)\n"
msgstr "      renderContentItem :: ContentF (Content Unit) -> Writer String (Content Unit)\n"

#. type: Plain text
#: text/chapter14.md:540
#, fuzzy
msgid ""
"We can implement this function by simply pattern matching on the two data "
"constructors of `ContentF`:"
msgstr ""
"`ContentF`の二つのデータ構築子でパターン照合するだけで、この関数を実装するこ"
"とができます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:541
#, fuzzy, no-wrap
msgid ""
"      renderContentItem (TextContent s rest) = do\n"
"        tell s\n"
"        pure rest\n"
"      renderContentItem (ElementContent e rest) = do\n"
"        renderElement e\n"
"        pure rest\n"
msgstr ""
"      renderContentItem (TextContent s rest) = do\n"
"        tell s\n"
"        pure rest\n"
"      renderContentItem (ElementContent e rest) = do\n"
"        renderElement e\n"
"        pure rest\n"

#. type: Plain text
#: text/chapter14.md:551
#, fuzzy
msgid ""
"In each case, the expression `rest` has the type `Content Unit`, and "
"represents the remainder of the interpreted computation. We can complete "
"each case by returning the `rest` action."
msgstr ""
"それぞれの場合において、式 `rest`は型 `Writer String`を持っており、解釈計算の"
"残りを表しています。 `rest`アクションを呼び出すことによって、それぞれの場合を"
"完了することができます。"

#. type: Plain text
#: text/chapter14.md:553
#, fuzzy
msgid "That's it! We can test our new monadic API in PSCi, as follows:"
msgstr ""
"これで完了です！`PSCi`で、次のように新しいモナドのAPIを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter14.md:554
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Free\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"â¦ log $ render $ p [] $ do\n"
"â¦   elem $ img [ src := \"cat.jpg\" ]\n"
"â¦   text \"A cat\"\n"
"â¦ ^D\n"
"\n"
"<p><img src=\"cat.jpg\" />A cat</p>\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Free\n"
"> import Control.Monad.Eff.Console\n"
"\n"
"> :paste\n"
"… log $ render $ p [] $ do\n"
"…   elem $ img [ src := \"cat.jpg\" ]\n"
"…   text \"A cat\"\n"
"… ^D\n"
"\n"
"&lt;p&gt;&lt;img src=\"cat.jpg\" /&gt;A cat&lt;/p&gt;\n"
"unit\n"

#. type: Bullet: ' 1. '
#: text/chapter14.md:572
#, fuzzy
msgid ""
"(Medium) Add a new data constructor to the `ContentF` type to support a new "
"action `comment`, which renders a comment in the generated HTML. Implement "
"the new action using `liftF`. Update the interpretation `renderContentItem` "
"to interpret your new constructor appropriately."
msgstr ""
"(やや難しい)`ContentF`型に新しいデータ構築子を追加して、生成されたHTMLにコメ"
"ントを出力する新しいアクション `comment`に対応してください。 `liftF`を使って"
"この新しいアクションを実装してください。新しい構築子を適切に解釈するように、"
"解釈 `renderContentItem`を更新してください。"

#. type: Title ##
#: text/chapter14.md:573
#, fuzzy, no-wrap
msgid "Extending the Language"
msgstr "言語の拡張"

#. type: Plain text
#: text/chapter14.md:576
#, fuzzy
msgid ""
"A monad in which every action returns something of type `Unit` is not "
"particularly interesting. In fact, aside from an arguably nicer syntax, our "
"monad adds no extra functionality over a `Monoid`."
msgstr ""
"すべてのアクションが型 `Unit`の何かを返すようなモナドは、さほど興味深いもので"
"はありません。実際のところ、概ね良くなったと思われる構文は別として、このモナ"
"ドは `Monoid`以上の機能は何の追加していません。"

#. type: Plain text
#: text/chapter14.md:578
#, fuzzy
msgid ""
"Let's illustrate the power of the free monad construction by extending our "
"language with a new monadic action which returns a non-trivial result."
msgstr ""
"意味のある結果を返す新しいモナドアクションでこの言語を拡張することで、Freeモ"
"ナド構造の威力を説明しましょう​​。"

#. type: Plain text
#: text/chapter14.md:580
#, fuzzy
msgid ""
"Suppose we want to generate HTML documents which contain hyperlinks to "
"different sections of the document using _anchors_. We can accomplish this "
"already, by generating anchor names by hand and including them at least "
"twice in the document: once at the definition of the anchor itself, and once "
"in each hyperlink. However, this approach has some basic issues:"
msgstr ""
"**アンカー**を使用して文書のさまざまな節へのハイパーリンクが含まれているHTML"
"文書を生成するとします。手作業でアンカーの名前を生成すればいいので、これは既"
"に実現できています。文書中で少なくとも２回、ひとつはアンカーの定義自身に、も"
"うひとつはハイパーリンクに、アンカーが含まれています。しかし、この方法には根"
"本的な問題がいくつかあります。\n"

#. type: Plain text
#: text/chapter14.md:583
#, fuzzy
msgid ""
"- The developer might fail to generate unique anchor names.  - The developer "
"might mistype one or more instances of the anchor name."
msgstr ""
"- 開発者は一意なアンカー名を生成するために失敗することがあります。 - 開発者"
"は、アンカー名のひとつまたは複数のインスタンスを誤って入力するかもしれませ"
"ん。"

#. type: Plain text
#: text/chapter14.md:585
#, fuzzy
msgid ""
"In the interest of protecting the developer from their own mistakes, we can "
"introduce a new type which represents anchor names, and provide a monadic "
"action for generating new unique names."
msgstr ""
"自分の間違いから開発者を保護するために、アンカー名を表す新しい型を導入し、新"
"しい一意な名前を生成するためのモナドアクションを提供することができます。"

#. type: Plain text
#: text/chapter14.md:587
#, fuzzy
msgid "The first step is to add a new type for names:"
msgstr "最初の手順は、名前の型を新しく追加することです。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:588
#, fuzzy, no-wrap
msgid ""
"newtype Name = Name String\n"
"\n"
"runName :: Name -> String\n"
"runName (Name n) = n\n"
msgstr ""
"newtype Name = Name String\n"
"\n"
"runName :: Name -> String\n"
"runName (Name n) = n\n"

#. type: Plain text
#: text/chapter14.md:596
#, fuzzy
msgid ""
"Again, we define this as a newtype around `String`, but we must be careful "
"not to export the data constructor in the module's export lists."
msgstr ""
"繰り返しになりますが、 `Name`は `String`のnewtypeとして定義しており、モジュー"
"ルのエクスポートリスト内でデータ構築子をエクスポートしないように注意する必要"
"があります。"

#. type: Plain text
#: text/chapter14.md:598
#, fuzzy
msgid ""
"Next, we define an instance for the `IsValue` type class for our new type, "
"so that we are able to use names in attribute values:"
msgstr ""
"次に、属性値として `Name`を使うことができるように、新しい型 `IsValue`型クラス"
"のインスタンスを定義します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:599
#, fuzzy, no-wrap
msgid ""
"instance nameIsValue :: IsValue Name where\n"
"  toValue (Name n) = n\n"
msgstr ""
"instance nameIsValue :: IsValue Name where\n"
"  toValue (Name n) = n\n"

#. type: Plain text
#: text/chapter14.md:605
#, fuzzy
msgid ""
"We also define a new data type for hyperlinks which can appear in `a` "
"elements, as follows:"
msgstr ""
"また、次のように `a`要素に現れるハイパーリンクの新しいデータ型を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:606
#, fuzzy, no-wrap
msgid ""
"data Href\n"
"  = URLHref String\n"
"  | AnchorHref Name\n"
"\n"
"instance hrefIsValue :: IsValue Href where\n"
"  toValue (URLHref url) = url\n"
"  toValue (AnchorHref (Name nm)) = \"#\" <> nm\n"
msgstr ""
"data Href\n"
"  = URLHref String\n"
"  | AnchorHref Name\n"
"\n"
"instance hrefIsValue :: IsValue Href where\n"
"  toValue (URLHref url) = url\n"
"  toValue (AnchorHref (Name nm)) = \"#\" <> nm\n"

#. type: Plain text
#: text/chapter14.md:617
#, fuzzy
msgid ""
"With this new type, we can modify the value type of the `href` attribute, "
"forcing our users to use our new `Href` type. We can also create a new "
"`name` attribute, which can be used to turn an element into an anchor:"
msgstr ""
"`href`属性の型の値を変更して、この新しい `Href`型の使用を強制します。また、要"
"素をアンカーに変換するのに使う新しい `name`属性を作成します。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:618
#, fuzzy, no-wrap
msgid ""
"href :: AttributeKey Href\n"
"href = AttributeKey \"href\"\n"
"\n"
"name :: AttributeKey Name\n"
"name = AttributeKey \"name\"\n"
msgstr ""
"href :: AttributeKey Href\n"
"href = AttributeKey \"href\"\n"
"\n"
"name :: AttributeKey Name\n"
"name = AttributeKey \"name\"\n"

#. type: Plain text
#: text/chapter14.md:627
#, fuzzy
msgid ""
"The remaining problem is that our users currently have no way to generate "
"new names. We can provide this functionality in our `Content` monad. First, "
"we need to add a new data constructor to our `ContentF` type constructor:"
msgstr ""
"残りの問題は、現在モジュールの使用者が新しい名前を生成する方法がないというこ"
"とです。 `Content`モナドでこの機能を提供することができます。まず、 `ContentF`"
"型構築子に新しいデータ構築子を追加する必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:628
#, fuzzy, no-wrap
msgid ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"  | NewName (Name -> a)\n"
msgstr ""
"data ContentF a\n"
"  = TextContent String a\n"
"  | ElementContent Element a\n"
"  | NewName (Name -> a)\n"

#. type: Plain text
#: text/chapter14.md:636
#, fuzzy, no-wrap
msgid "The `NewName` data constructor corresponds to an action which returns a value of type `Name`. Notice that instead of requiring a `Name` as a data constructor argument, we require the user to provide a _function_ of type `Name -> a`. Remembering that the type `a` represents the _rest of the computation_, we can see that this function provides a way to continue computation after a value of type `Name` has been returned.\n"
msgstr "`NewName`データ構築子は型 `Name`の値を返すアクションに対応しています。データ構築子の引数として `Name`を要求するのではなく、型 `Name -> a`の**関数**を提供するように使用者に要求していることに注意してください。型 `a`は**計算の残り**を表していることを思い出すと、この関数は、型 `Name`の値が返されたあとで、計算を継続する方法を提供するというように直感的に理解することができます。\n"

#. type: Plain text
#: text/chapter14.md:638
#, fuzzy
msgid ""
"We also need to update the `Functor` instance for `ContentF`, taking into "
"account the new data constructor, as follows:"
msgstr ""
"新しいデータ構築子を考慮するように、 `ContentF`についての `Functor`インスタン"
"スを更新する必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:639
#, fuzzy, no-wrap
msgid ""
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
"  map f (NewName k) = NewName (f <<< k)\n"
msgstr ""
"instance functorContentF :: Functor ContentF where\n"
"  map f (TextContent s x) = TextContent s (f x)\n"
"  map f (ElementContent e x) = ElementContent e (f x)\n"
"  map f (NewName k) = NewName (f <<< k)\n"

#. type: Plain text
#: text/chapter14.md:647
#, fuzzy
msgid ""
"Now we can build our new action by using the `liftF` function, as before:"
msgstr ""
"そして、先ほど述べたように、 `liftF`関数を使うと新しいアクションを構築するこ"
"とができます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:648
#, fuzzy, no-wrap
msgid ""
"newName :: Content Name\n"
"newName = liftF $ NewName id\n"
msgstr ""
"newName :: Content Name\n"
"newName = liftF $ NewName id\n"

#. type: Plain text
#: text/chapter14.md:654
#, fuzzy
msgid ""
"Notice that we provide the `id` function as our continuation, meaning that "
"we return the result of type `Name` unchanged."
msgstr ""
"`id`関数を継続として提供していることに注意してください。型 `Name`の結果を変更"
"せずに返すということを意味しています。"

#. type: Plain text
#: text/chapter14.md:656
#, fuzzy
msgid ""
"Finally, we need to update our interpretation function, to interpret the new "
"action. We previously used the `Writer String` monad to interpret our "
"computations, but that monad does not have the ability to generate new "
"names, so we must switch to something else. The `WriterT` monad transformer "
"can be used with the `State` monad to combine the effects we need. We can "
"define our interpretation monad as a type synonym to keep our type "
"signatures short:"
msgstr ""
"最後に、新しいアクションを解釈するために、解釈関数を更新する必要があります。"
"以前は計算を解釈するために `Writer String`モナドを使っていましたが、このモナ"
"ドは新しい名前を生成する能力を持っていないので、何か他のものに切り替えなけれ"
"ばなりません。`WriterT`モナド変換子を`State`モナドと一緒に使うと、必要な作用"
"を組み合わせることができます。型注釈を短く保てるように、この解釈モナドを型同"
"義語として定義しておきます。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:657
#, fuzzy, no-wrap
msgid "type Interp = WriterT String (State Int)\n"
msgstr "type Interp = WriterT String (State Int)\n"

#. type: Plain text
#: text/chapter14.md:662
#, fuzzy
msgid ""
"Here, the state of type `Int` will act as an incrementing counter, used to "
"generate unique names."
msgstr ""
"Int型の引数は状態の型で、この場合は増加していくカウンタとして振る舞う数であ"
"り、一意な名前を生成するのに使われます。"

#. type: Plain text
#: text/chapter14.md:664
#, fuzzy
msgid ""
"Because the `Writer` and `WriterT` monads use the same type class members to "
"abstract their actions, we do not need to change any actions - we only need "
"to replace every reference to `Writer String` with `Interp`. We do, however, "
"need to modify the handler used to run our computation. Instead of just "
"`execWriter`, we now need to use `evalState` as well:"
msgstr ""
"`Writer`と `WriterT`モナドはそれらのアクションを抽象化するのに同じ型クラスメ"
"ンバを使うので、どのアクションも変更する必要がありません。必要なのは、 "
"`Writer String`への参照すべてを `Interp`で置き換えることだけです。しかし、こ"
"の計算を実行するために使われるハンドラを変更しなければいけません。 "
"`execWriter`の代わりに、 `evalState`を使います。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:665
#, fuzzy, no-wrap
msgid ""
"render :: Element -> String\n"
"render e = evalState (execWriterT (renderElement e)) 0\n"
msgstr ""
"render :: Element -> String\n"
"render e = evalState (execWriterT (renderElement e)) 0\n"

#. type: Plain text
#: text/chapter14.md:671
#, fuzzy
msgid ""
"We also need to add a new case to `renderContentItem`, to interpret the new "
"`NewName` data constructor:"
msgstr ""
"新しい `NewName`データ構築子を解釈するために、 `renderContentItem`に新しい場"
"合分けを追加しなければいけません。"

#. type: Fenced code block (haskell)
#: text/chapter14.md:672
#, fuzzy, no-wrap
msgid ""
"renderContentItem (NewName k) = do\n"
"  n <- get\n"
"  let fresh = Name $ \"name\" <> show n\n"
"  put $ n + 1\n"
"  pure (k fresh)\n"
msgstr ""
"renderContentItem (NewName k) = do\n"
"  n <- get\n"
"  let fresh = Name $ \"name\" <> show n\n"
"  put $ n + 1\n"
"  pure (k fresh)\n"

#. type: Plain text
#: text/chapter14.md:681
#, fuzzy, no-wrap
msgid "Here, we are given a continuation `k` of type `Name -> Content a`, and we need to construct an interpretation of type `Content a`. Our interpretation is simple: we use `get` to read the state, use that state to generate a unique name, then use `put` to increment the state. Finally, we pass our new name to the continuation to complete the computation.\n"
msgstr "ここで、型 `Name -> Interp a`の継続 `k`が与えられているので、型 `Interp a`の解釈を構築しなければいけません。この解釈は単純です。 `get`を使って状態を読み、その状態を使って一意な名前を生成し、それから `put`で状態をインクリメントしています。最後に、継続にこの新しい名前を渡して、計算を完了します。\n"

#. type: Plain text
#: text/chapter14.md:683
#, fuzzy
msgid ""
"With that, we can try out our new functionality in PSCi, by generating a "
"unique name inside the `Content` monad, and using it as both the name of an "
"element and the target of a hyperlink:"
msgstr ""
"これにより、 `PSCi`で、 `Content`モナドの内部で一意な名前を生成し、要素の名前"
"とハイパーリンクのリンク先の両方を使って、この新しい機能を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter14.md:684
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.DOM.Name\n"
"> import Effect.Console\n"
"\n"
"> :paste\n"
"â¦ render $ p [ ] $ do\n"
"â¦   top <- newName\n"
"â¦   elem $ a [ name := top ] $\n"
"â¦     text \"Top\"\n"
"â¦   elem $ a [ href := AnchorHref top ] $\n"
"â¦     text \"Back to top\"\n"
"â¦ ^D\n"
"\n"
"<p><a name=\"name0\">Top</a><a href=\"#name0\">Back to top</a></p>\n"
"unit\n"
msgstr ""
"> import Prelude\n"
"> import Data.DOM.Name\n"
"> import Control.Monad.Eff.Console\n"
"\n"
"> :paste\n"
"… render $ p [ ] $ do\n"
"…   top <- newName\n"
"…   elem $ a [ name := top ] $\n"
"…     text \"Top\"\n"
"…   elem $ a [ href := AnchorHref top ] $\n"
"…     text \"Back to top\"\n"
"… ^D\n"
"\n"
"<p><a name=\"name0\">Top</a><a href=\"#name0\">Back to top</a></p>\n"
"unit\n"

#. type: Plain text
#: text/chapter14.md:703
#, fuzzy
msgid ""
"You can verify that multiple calls to `newName` do in fact result in unique "
"names."
msgstr ""
"複数回の `newName`呼び出しの結果が、実際に一意な名前になっていることを確かめ"
"てみてください。"

#. type: Bullet: ' 1. '
#: text/chapter14.md:707
#, fuzzy
msgid ""
"(Medium) We can simplify the API further by hiding the `Element` type from "
"its users. Make these changes in the following steps:"
msgstr ""
"(やや難しい) 使用者から `Element`型を隠蔽すると、さらにAPIを簡素化することが"
"できます。次の手順に従って、これらの変更を行ってください。"

#. type: Bullet: '     - '
#: text/chapter14.md:713
#, fuzzy
msgid ""
"Combine functions like `p` and `img` (with return type `Element`) with the "
"`elem` action to create new actions with return type `Content Unit`."
msgstr ""
"`p`や `img`のような(返り値が `Element`の)関数を `elem`アクションと結合して、"
"型 `Content Unit`を返す新しいアクションを作ってください。"

#. type: Bullet: '     - '
#: text/chapter14.md:713
#, fuzzy
msgid ""
"Change the `render` function to accept an argument of type `Content Unit` "
"instead of `Element`."
msgstr ""
"型 `Content a`の引数を許容し、結果の型 `Tuple String`を返すように、 `render`"
"関数を変更してください。"

#. type: Plain text
#: text/chapter14.md:713
#, fuzzy, no-wrap
msgid ""
" 1. (Medium) Hide the implementation of the `Content` monad by using a `newtype` instead of a type synonym. You should not export the data\n"
"     constructor for your `newtype`.\n"
" 1. (Difficult) Modify the `ContentF` type to support a new action\n"
msgstr "(やや難しい) 型同義語の代わりに `newtype`を使って `Content`モナドの実装を隠し、 `newtype`のためにデータ構築子をエクスポートしないでください。"

#. type: Plain text
#: text/chapter14.md:717
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     isMobile :: Content Boolean\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    testParens :: String -> Boolean\n"
"    ```\n"

#. type: Plain text
#: text/chapter14.md:719
#, fuzzy, no-wrap
msgid "     which returns a boolean value indicating whether or not the document is being rendered for display on a mobile device.\n"
msgstr "　 このアクションは、この文書がモバイルデバイス上での表示のためにレンダリングされているかどうかを示す真偽値を返します。"

#. type: Plain text
#: text/chapter14.md:721
#, fuzzy, no-wrap
msgid "     _Hint_: use the `ask` action and the `ReaderT` monad transformer to interpret this action. Alternatively, you might prefer to use the `RWS` monad.\n"
msgstr "   **ヒント**：`ask`アクションと`ReaderT`型変換子を使って、このアクションを解釈してみてください。あるいは、`RWS`モナドを使うほうが好みの人もいるかもしれません。\n"

#. type: Plain text
#: text/chapter14.md:725
#, fuzzy
msgid ""
"In this chapter, we developed a domain-specific language for creating HTML "
"documents, by incrementally improving a naive implementation using some "
"standard techniques:"
msgstr ""
"この章では、いくつかの標準的な技術を使って、単純な実装を段階的に改善すること"
"により、HTML文書を作成するための領域特化言語を開発しました。"

#. type: Plain text
#: text/chapter14.md:730
#, fuzzy
msgid ""
"- We used _smart constructors_ to hide the details of our data "
"representation, only permitting the user to create documents which were "
"_correct-by-construction_.  - We used an _user-defined infix binary "
"operator_ to improve the syntax of the language.  - We used _phantom types_ "
"to encode additional information in the types of our data, preventing the "
"user from providing attribute values of the wrong type.  - We used the _free "
"monad_ to turn our array representation of a collection of content into a "
"monadic representation supporting do notation. We then extended this "
"representation to support a new monadic action, and interpreted the monadic "
"computations using standard monad transformers."
msgstr ""
"- データ表現の詳細を隠蔽し、**構築方法により正しい**文書を作ることだけを許可"
"するために、**スマート構築子**を使いました。 - 言語の構文を改善するために、**"
"ユーザ定義の中置２項演算子**を使用しました。 - 使用者が間違った型の属性値を提"
"供するのを防ぐために、データの型に追加の情報を符号化する**幻影型**を使用しま"
"した。 - **Freeモナド**を使って、内容の集まりの配列的な表現を、do表記を提供す"
"るモナド的な表現に変換しました。この表現を拡張してモナドの新しいアクションを"
"提供し、標準のモナド型変換子でモナドの計算を解釈しました。"

#. type: Plain text
#: text/chapter14.md:732
#, fuzzy
msgid ""
"These techniques all leverage PureScript's module and type systems, either "
"to prevent the user from making mistakes or to improve the syntax of the "
"domain-specific language."
msgstr ""
"使用者が間違いを犯すのを防ぎ、領域特化言語の構文を改良するために、これらの手"
"法はすべてPureScriptのモジュールと型システムを活用しています。"

#. type: Plain text
#: text/chapter14.md:733
#, fuzzy
msgid ""
"The implementation of domain-specific languages in functional programming "
"languages is an area of active research, but hopefully this provides a "
"useful introduction some simple techniques, and illustrates the power of "
"working in a language with expressive types."
msgstr ""
"関数型プログラミング言語による領域特化言語の実装は活発に研究されている分野で"
"すが、いくつかの簡単なテクニックに対して役に立つ導入を提供し、表現力豊かな型"
"を持つ言語で作業すること威力を示すことができていれば幸いです。"

#. type: Title #
#: text/chapter2.md:1
#, no-wrap
msgid "Getting Started"
msgstr "はじめよう"

#. type: Plain text
#: text/chapter2.md:6
msgid ""
"In this chapter, we'll set up a working PureScript development environment, "
"solve some exercises, and use the tests provided with this book to check our "
"answers. You may also find a [video walkthrough of this chapter](https://www."
"youtube.com/watch?v=GPjPwb6d-70) helpful if that better suits your learning "
"style."
msgstr ""
"この章では実際のPureScriptの開発環境を立ち上げ、\n"
"いくつかの演習を解き、\n"
"この本で提供されているテストを使って答えを確認します。\n"
"もし学習の仕方が合っていれば\n"
"[この章を通して進めるビデオ](https://www.youtube.com/watch?v=GPjPwb6d-70)\n"
"が役に立つでしょう。"

#. type: Title ##
#: text/chapter2.md:7
#, no-wrap
msgid "Environment Setup"
msgstr "環境構築"

#. type: Plain text
#: text/chapter2.md:10
msgid ""
"First, work through this [Getting Started Guide](https://github.com/"
"purescript/documentation/blob/master/guides/Getting-Started.md) in the "
"Documentation Repo to setup your environment and learn a few basics about "
"the language. Don't worry if the code in the example solution to the "
"[Project Euler](http://projecteuler.net/problem=1) problem is confusing or "
"contains unfamiliar syntax. We'll cover all of this in great detail in the "
"upcoming chapters."
msgstr ""
"最初にドキュメンテーションリポジトリにあるこの\n"
"[Getting Started Guide](https://github.com/purescript/documentation/blob/master/guides/Getting-Started.md)\n"
"を通しで進め、環境の構築と言語の基礎を学んでください。\n"
"[Project Euler](http://projecteuler.net/problem=1)\n"
"への解答例にあるコードがわかりにくかったり見慣れない構文を含んでいたとしても心配要りません。\n"
"来たる章でこの全ての内容をとても詳細に押さえていきます。"

#. type: Title ##
#: text/chapter2.md:11
#, no-wrap
msgid "Solving Exercises"
msgstr "演習を解く"

#. type: Plain text
#: text/chapter2.md:14
msgid ""
"Now that you've installed the necessary development tools, clone this book's "
"repo."
msgstr "ここまでで必要な開発ツールをインストールできているので、この本のリポジトリをクローンしてください。"

#. type: Fenced code block (sh)
#: text/chapter2.md:15
#, no-wrap
msgid "git clone https://github.com/purescript-contrib/purescript-book.git\n"
msgstr "git clone https://github.com/purescript-contrib/purescript-book.git\n"

#. type: Plain text
#: text/chapter2.md:20
msgid ""
"The book repo contains PureScript example code and unit tests for the "
"exercises that accompany each chapter. There's some initial setup required "
"to reset the exercise solutions so they are ready to be solved by you. Use "
"the `resetSolutions.sh` script to simplify this process. While you're at it, "
"you should also strip out all the anchor comments with the `removeAnchors."
"sh` script (these anchors are used for copying code snippets into the book's "
"rendered markdown, and you probably don't need this clutter in your local "
"repo):"
msgstr ""
"本のリポジトリにはPureScriptのコード例とそれぞれの章に付属する演習のための単体テストが含まれます。\n"
"演習の解法を白紙に戻すために必要な初期設定があり、こうすることで解く準備ができます。\n"
"`resetSolutions.sh`スクリプトを使ってこの工程を簡単にできます。\n"
"その間に`removeAnchors.sh`スクリプトで全てのアンカーコメントを取り除いておくのもよいでしょう。\n"
"（これらのアンカーはコードスニペットを本の変換後のMarkdownにコピーするために使われており、\n"
"自分のローカルリポジトリではこのアンカーが散らかっていないほうがよいでしょう。）"

#. type: Fenced code block (sh)
#: text/chapter2.md:21
#, no-wrap
msgid ""
"cd purescript-book\n"
"./scripts/resetSolutions.sh\n"
"./scripts/removeAnchors.sh\n"
"git add .\n"
"git commit --all --message \"Exercises ready to be solved\"\n"
msgstr ""
"cd purescript-book\n"
"./scripts/resetSolutions.sh\n"
"./scripts/removeAnchors.sh\n"
"git add .\n"
"git commit --all --message \"Exercises ready to be solved\"\n"

#. type: Plain text
#: text/chapter2.md:30
msgid "Now run the tests for this chapter:"
msgstr "それではこの章のテストを走らせましょう。"

#. type: Fenced code block (sh)
#: text/chapter2.md:31
#, no-wrap
msgid ""
"cd exercises/chapter2\n"
"spago test\n"
msgstr ""
"cd exercises/chapter2\n"
"spago test\n"

#. type: Plain text
#: text/chapter2.md:37
msgid "You should see the following successful test output:"
msgstr "以下の成功したテスト出力が出るでしょう。"

#. type: Fenced code block (sh)
#: text/chapter2.md:38
#, no-wrap
msgid ""
"â Suite: Euler - Sum of Multiples\n"
"  â Passed: below 10\n"
"  â Passed: below 1000\n"
"\n"
"All 2 tests passed! ð\n"
msgstr ""
"→ Suite: Euler - Sum of Multiples\n"
"  → Running: below 10✓ Passed: below 10\n"
"  → Running: below 1000✓ Passed: below 1000\n"
"\n"
"All 2 tests passed! 🎉\n"

#. type: Plain text
#: text/chapter2.md:47
msgid ""
"Note that the `answer` function (found in `src/Euler.purs`) has been "
"modified to find the multiples of 3 and 5 below any integer. The test suite "
"(found in `test/Main.purs`) for this `answer` function is more comprehensive "
"than the test in the earlier getting-started guide. Don't worry about "
"understanding how this test framework code works while reading these early "
"chapters."
msgstr ""
"なお、`answer`節（`src/Euler.purs`にあります）は、\n"
"あらゆる整数以下の3と5の倍数を見付けるように変更されています。\n"
"この`answer`関数のためのテストスート（`test/Main.purs`にあります）は\n"
"Getting Started Guideの冒頭にあるテストよりも網羅的です。\n"
"はじめの章を読んでいる間はこのテストフレームワークの仕組みを理解しようと思い詰めなくて大丈夫です。"

#. type: Plain text
#: text/chapter2.md:49
msgid ""
"The remainder of the book contains lots of exercises. If you write your "
"solutions in the `Test.MySolutions` module (`test/MySolutions.purs`), you "
"can check your work against the provided test suite."
msgstr ""
"本の残りの部分には多くの演習が含まれます。\n"
"`Test.MySolutions`モジュール (`test/MySolutions.purs`) に自分の解法を書けば、\n"
"提供されているテストスートを使って確認できます。"

#. type: Plain text
#: text/chapter2.md:51
msgid ""
"Let's work through this next exercise together in test-driven-development "
"style."
msgstr "テスト駆動開発のスタイルでこの次の演習を一緒に進めてみましょう。"

#. type: Title ##
#: text/chapter2.md:52
#, no-wrap
msgid "Exercise"
msgstr "演習"

#. type: Bullet: '1. '
#: text/chapter2.md:55
msgid ""
"(Medium) Write a `diagonal` function to compute the length of the diagonal "
"(or hypotenuse) of a right-angled triangle when given the lengths of the two "
"other sides."
msgstr ""
"（やや難しい）直角三角形の対角線（あるいは斜辺）の長さを\n"
"他の2つの辺の長さを使って計算する`diagonal`関数を書いてください。"

#. type: Title ##
#: text/chapter2.md:56
#, no-wrap
msgid "Solution"
msgstr "解法"

#. type: Plain text
#: text/chapter2.md:59
msgid ""
"We'll start by enabling the tests for this exercise. Move the start of the "
"block-comment down a few lines as shown below. Block comments start with `{-"
"` and end with `-}`:"
msgstr ""
"この演習のテストを有効にするところから始めます。\n"
"以下に示すようにブロックコメントの開始を数行下に下げてください。\n"
"ブロックコメントは`{-`から始まり`-}`で終わります。"

#. type: Fenced code block (hs)
#: text/chapter2.md:60
#, no-wrap
msgid ""
"{{#include ../exercises/chapter2/test/Main.purs:diagonalTests}}\n"
"    {-  Move this block comment starting point to enable more tests\n"
msgstr ""
"{{#include ../exercises/chapter2/test/Main.purs:diagonalTests}}\n"
"    {-  Move this block comment starting point to enable more tests\n"

#. type: Plain text
#: text/chapter2.md:66
msgid ""
"If we attempt to run the test now, we'll encounter a compilation error "
"because we have not yet implemented our `diagonal` function."
msgstr ""
"ここでテストを走らせようとすると、コンパイルエラーに直面します。\n"
"なぜなら`diagonal`関数をまだ実装していないからです。"

#. type: Fenced code block (sh)
#: text/chapter2.md:67
#, no-wrap
msgid ""
"$ spago test\n"
"\n"
"Error found:\n"
"in module Test.Main\n"
"at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)\n"
"\n"
"  Unknown value diagonal\n"
msgstr ""
"$ spago test\n"
"\n"
"Error found:\n"
"in module Test.Main\n"
"at test/Main.purs:21:27 - 21:35 (line 21, column 27 - line 21, column 35)\n"
"\n"
"  Unknown value diagonal\n"

#. type: Plain text
#: text/chapter2.md:78
msgid ""
"Let's first take a look at what happens with a faulty version of this "
"function. Add the following code to `test/MySolutions.purs`:"
msgstr ""
"まずはこの関数が欠陥のあるバージョンであるときに何が起こるのか見てみましょう。\n"
"以下のコードを`test/MySolutions.purs`に追加してください。"

#. type: Fenced code block (hs)
#: text/chapter2.md:79
#, no-wrap
msgid ""
"import Data.Number (sqrt)\n"
"\n"
"diagonal w h = sqrt (w * w + h)\n"
msgstr ""
"import Data.Number (sqrt)\n"
"\n"
"diagonal w h = sqrt (w * w + h)\n"

#. type: Plain text
#: text/chapter2.md:86
msgid "And check our work by running `spago test`:"
msgstr "そして`spago test`を走らせて確認してください。"

#. type: Fenced code block (hs)
#: text/chapter2.md:87
#, no-wrap
msgid ""
"â Suite: diagonal\n"
"  â  Failed: 3 4 5 because expected 5.0, got 3.605551275463989\n"
"  â  Failed: 5 12 13 because expected 13.0, got 6.082762530298219\n"
"\n"
"2 tests failed:\n"
msgstr ""
"→ Suite: diagonal\n"
"  → Running: 3 4 5☠ Failed: 3 4 5 because expected 5.0, got 3.605551275463989\n"
"  → Running: 5 12 13☠ Failed: 5 12 13 because expected 13.0, got 6.082762530298219\n"
"\n"
"2 tests failed:\n"

#. type: Plain text
#: text/chapter2.md:96
msgid ""
"Uh-oh, that's not quite right. Let's fix this with the correct application "
"of the Pythagorean formula by changing the function to:"
msgstr ""
"あーあ、全然正しくありませんでした。\n"
"ピタゴラスの定理を正しい適用することでこれを修正しましょう。\n"
"関数を以下のように変えます。"

#. type: Fenced code block (hs)
#: text/chapter2.md:97
#, no-wrap
msgid "{{#include ../exercises/chapter2/test/no-peeking/Solutions.purs:diagonal}}\n"
msgstr "{{#include ../exercises/chapter2/test/no-peeking/Solutions.purs:diagonal}}\n"

#. type: Plain text
#: text/chapter2.md:102
msgid "Trying `spago test` again now shows all tests are passing:"
msgstr "ここでもう一度`spago test`としてみると全てのテストが通っています。"

#. type: Fenced code block (hs)
#: text/chapter2.md:103
#, no-wrap
msgid ""
"â Suite: Euler - Sum of Multiples\n"
"  â Passed: below 10\n"
"  â Passed: below 1000\n"
"â Suite: diagonal\n"
"  â Passed: 3 4 5\n"
"  â Passed: 5 12 13\n"
"\n"
"All 4 tests passed! ð\n"
msgstr ""
"→ Suite: Euler - Sum of Multiples\n"
"  → Running: below 10✓ Passed: below 10\n"
"  → Running: below 1000✓ Passed: below 1000\n"
"→ Suite: diagonal\n"
"  → Running: 3 4 5✓ Passed: 3 4 5\n"
"  → Running: 5 12 13✓ Passed: 5 12 13\n"
"\n"
"All 4 tests passed! 🎉\n"

#. type: Plain text
#: text/chapter2.md:115
msgid "Success! Now you're ready to try these next exercises on your own."
msgstr ""
"成功です！\n"
"これで次の演習を自力で解くための準備ができました。"

#. type: Bullet: ' 1. '
#: text/chapter2.md:120
msgid ""
"(Easy) Write a function `circleArea` which computes the area of a circle "
"with a given radius. Use the `pi` constant, which is defined in the "
"`Numbers` module. _Hint_: don't forget to import `pi` by modifying the "
"`import Data.Number` statement."
msgstr ""
"（簡単）指定された半径の円の面積を計算する関数`circleArea`を書いてみましょう。\n"
"`Numbers`モジュールで定義されている `pi`定数を使用してください。\n"
"**ヒント**： `import Data.Number`文を修正して、 `pi`をインポートすることを忘れないようにしましょう。"

#. type: Bullet: ' 1. '
#: text/chapter2.md:120
msgid ""
"(Medium) Write a function `leftoverCents` which takes an `Int` and returns "
"what's leftover after dividing by `100`. Use the `rem` function. Search "
"[Pursuit](https://pursuit.purescript.org/) for this function to learn about "
"usage and which module to import it from. _Note:_ Your IDE may support auto-"
"importing of this function if you accept the auto-completion suggestion."
msgstr ""
"（やや難しい）`Int`を取って`100`で割ったあとの余りを返す関数`leftoverCents`を書いてみましょう。\n"
"`rem`関数を使ってください。\n"
"[Pursuit](https://pursuit.purescript.org/)でこの関数を検索して、\n"
"使用法とどのモジュールからインポートしてくるか調べましょう。\n"
"**補足**：自動補完の提案を受け付ければ、IDEでこの関数の自動的なインポートがサポートされているかもしれません。"

#. type: Plain text
#: text/chapter2.md:124
msgid ""
"In this chapter, we installed the PureScript compiler and the Spago tool. We "
"also learned how to write solutions to exercises and check these for "
"correctness."
msgstr ""
"この章ではPureScriptコンパイラとSpagoツールをインストールしました。\n"
"演習の解答の書き方と正しさの確認方法も学びました。"

#. type: Plain text
#: text/chapter2.md:126
msgid ""
"There will be many more exercises in the chapters ahead, and working through "
"those really helps with learning the material. If you're stumped by any of "
"the exercises, please reach out to any of the community resources listed in "
"the [Getting Help](https://book.purescript.org/chapter1.html#getting-help) "
"section of this book, or even file an issue in this [book's repo](https://"
"github.com/purescript-contrib/purescript-book/issues). This reader feedback "
"on which exercises could be made more approachable helps us improve the book."
msgstr ""
"この先の章にはより多くの演習があり、それらに取り組むうちに学習の助けになっているでしょう。\n"
"演習のどこかでお手あげになったら、\n"
"この本の[困ったときは](chapter1.ja.md#getting-help)の節に挙げられている\n"
"コミュニティの資料のどれでも見てみるか、\n"
"この[本のリポジトリ](https://github.com/purescript-contrib/purescript-book/issues)にイシューを報告することさえできます。\n"
"こうした演習の敷居を下げることに繋がる読者のフィードバックが、本の向上の助けになっています。"

#. type: Plain text
#: text/chapter2.md:128
msgid ""
"Once you solve all the exercises in a chapter, you may compare your answers "
"against those in the `no-peeking/Solutions.purs`. No peeking please without "
"putting in an honest effort to solve these yourself though. And even if you "
"are stuck, try asking a community member for help first, as we would prefer "
"to give you a small hint rather than spoil the exercise. If you found a more "
"elegant solution (that still only requires knowledge of covered content), "
"please send us a PR."
msgstr ""
"章の全ての演習を解いたら、`no-peeking/Solutions.purs`にあるものと解答とを比べられます。\n"
"ただしカンニングしてはだめで、これらの演習を誠実に自力で解く労力を払わないことがないようにしてください。\n"
"そしてたとえ行き詰まったにしても、まずはコミュニティメンバーに尋ねてみるようにしてください。\n"
"演習のネタバレをするよりも、小さなヒントをあげたいからです。\n"
"もっとエレガントな解法（とはいえ本の内容で押さえられている知識のみを必要とするもの）を見つけたときはPRを送ってください。"

#. type: Plain text
#: text/chapter2.md:129
msgid ""
"The repo is continuously being revised, so be sure to check for updates "
"before starting each new chapter."
msgstr "リポジトリは継続して改訂されているため、それぞれの新しい章を始める前に更新を確認するようにしてください。"

#. type: Title #
#: text/chapter3.md:1
#, no-wrap
msgid "Functions and Records"
msgstr "関数とレコード"

#. type: Plain text
#: text/chapter3.md:6
msgid ""
"This chapter will introduce two building blocks of PureScript programs: "
"functions and records. In addition, we'll see how to structure PureScript "
"programs, and how to use types as an aid to program development."
msgstr ""
"この章では、関数およびレコードというPureScriptプログラムの2つの構成要素を導入します。\n"
"さらに、どのようにPureScriptプログラムを構造化するのか、どのように型をプログラム開発に役立てるかを見ていきます。"

#. type: Plain text
#: text/chapter3.md:8
msgid ""
"We will build a simple address book application to manage a list of "
"contacts. This code will introduce some new ideas from the syntax of "
"PureScript."
msgstr ""
"連絡先のリストを管理する簡単​​な住所録アプリケーションを作成していきます。この"
"コード例により、PureScriptの構文からいくつかの新しい概念を導入します。"

#. type: Plain text
#: text/chapter3.md:10
msgid ""
"The front-end of our application will be the interactive mode PSCi, but it "
"would be possible to build on this code to write a front-end in JavaScript. "
"In fact, we will do exactly that in later chapters, adding form validation "
"and save/restore functionality."
msgstr ""
"このアプリケーションのフロントエンドは対話式モードであるPSCiを使うようにしていますが、このコードを土台にJavaScriptでフロントエンドを書くこともできるでしょう。\n"
"実際に後の章で、フォームの検証と保存および復元の機能を追加します。"

#. type: Plain text
#: text/chapter3.md:14
msgid ""
"The source code for this chapter is contained in the file `src/Data/"
"AddressBook.purs`. This file starts with a module declaration and its import "
"list:"
msgstr ""
"この章のソースコードは `src/Data/AddressBook.purs`というファイルに含まれています。\n"
"このファイルは次のようなモジュール宣言とインポート一覧から始まります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:15
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:imports}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:imports}}\n"

#. type: Plain text
#: text/chapter3.md:20
msgid "Here, we import several modules:"
msgstr "ここでは、いくつかのモジュールをインポートします。"

#. type: Plain text
#: text/chapter3.md:24
msgid ""
"- The `Control.Plus` module, which defines the `empty` value.  - The `Data."
"List` module, which is provided by the `lists` package which can be "
"installed using Spago. It contains a few functions which we will need for "
"working with linked lists.  - The `Data.Maybe` module, which defines data "
"types and functions for working with optional values."
msgstr ""
"- `Control.Plus`モジュールには`empty`値が定義されています。\n"
"- `Data.List`モジュールは`lists`パッケージで提供されておりSpagoを使ってインストールできます。\n"
"  連結リストを使うために必要ないくつかの関数が含まれています。\n"
"- `Data.Maybe`モジュールは、オプショナルな値を扱うためのデータ型と関数を定義しています。"

#. type: Plain text
#: text/chapter3.md:26
msgid ""
"Notice that the imports for these modules are listed explicitly in "
"parentheses. This is generally a good practice, as it helps to avoid "
"conflicting imports."
msgstr ""
"このモジュールのインポート内容が括弧内で明示的に列挙されていることに注目して"
"ください。明示的な列挙はインポート内容の衝突を避けるのに役に立つので、一般に"
"良い習慣です。"

#. type: Plain text
#: text/chapter3.md:28
msgid ""
"Assuming you have cloned the book's source code repository, the project for "
"this chapter can be built using Spago, with the following commands:"
msgstr "ソースコードリポジトリを複製したと仮定すると、この章のプロジェクトは次のコマンドでSpagoを使用して構築できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:29
#, no-wrap
msgid ""
"$ cd chapter3\n"
"$ spago build\n"
msgstr ""
"$ cd chapter3\n"
"$ spago build\n"

#. type: Title ##
#: text/chapter3.md:34
#, no-wrap
msgid "Simple Types"
msgstr "単純な型"

#. type: Plain text
#: text/chapter3.md:37
msgid ""
"PureScript defines three built-in types which correspond to JavaScript's "
"primitive types: numbers, strings and booleans. These are defined in the "
"`Prim` module, which is implicitly imported by every module. They are called "
"`Number`, `String`, and `Boolean`, respectively, and you can see them in "
"PSCi by using the `:type` command to print the types of some simple values:"
msgstr ""
"JavaScriptのプリミティブ型に対応する組み込みデータ型として、PureScriptでは数値型と文字列型、真偽型の３つが定義されています。\n"
"これらは`Prim`モジュールで定義されており、全てのモジュールに暗黙にインポートされます。\n"
"これらはそれぞれ `Number`、 `String`、 `Boolean`と呼ばれており、PSCiで`:type`コマンドを使うと簡単な値の型を表示させて確認できます。"

#. type: Fenced code block (text)
#: text/chapter3.md:38
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :type 1.0\n"
"Number\n"
"\n"
"> :type \"test\"\n"
"String\n"
"\n"
"> :type true\n"
"Boolean\n"
msgstr ""
"$ spago repl\n"
"\n"
"> :type 1.0\n"
"Number\n"
"\n"
"> :type \"test\"\n"
"String\n"
"\n"
"> :type true\n"
"Boolean\n"

#. type: Plain text
#: text/chapter3.md:52
msgid ""
"PureScript defines some other built-in types: integers, characters, arrays, "
"records, and functions."
msgstr "PureScriptには他にも、整数、文字、配列、レコード、関数といった組み込み型が定義されています。"

#. type: Plain text
#: text/chapter3.md:54
msgid ""
"Integers are differentiated from floating point values of type `Number` by "
"the lack of a decimal point:"
msgstr ""
"整数は、小数点以下を省くことによって、型 `Number`の浮動小数点数の値と区別され"
"ます。"

#. type: Fenced code block (text)
#: text/chapter3.md:55
#, no-wrap
msgid ""
"> :type 1\n"
"Int\n"
msgstr ""
"> :type 1\n"
"Int\n"

#. type: Plain text
#: text/chapter3.md:61
msgid ""
"Character literals are wrapped in single quotes, unlike string literals "
"which use double quotes:"
msgstr ""
"二重引用符を使用する文字列リテラルとは異なり、文字リテラルは一重引用符で囲み"
"ます。"

#. type: Fenced code block (text)
#: text/chapter3.md:62
#, no-wrap
msgid ""
"> :type 'a'\n"
"Char\n"
msgstr ""
"> :type 'a'\n"
"Char\n"

#. type: Plain text
#: text/chapter3.md:68
msgid ""
"Arrays correspond to JavaScript arrays, but unlike in JavaScript, all "
"elements of a PureScript array must have the same type:"
msgstr ""
"配列はJavaScriptの配列に対応していますが、JavaScriptの配列とは異なり、"
"PureScriptの配列のすべての要素は同じ型を持つ必要があります。"

#. type: Fenced code block (text)
#: text/chapter3.md:69
#, no-wrap
msgid ""
"> :type [1, 2, 3]\n"
"Array Int\n"
"\n"
"> :type [true, false]\n"
"Array Boolean\n"
"\n"
"> :type [1, false]\n"
"Could not match type Int with type Boolean.\n"
msgstr ""
"> :type [1, 2, 3]\n"
"Array Int\n"
"\n"
"> :type [true, false]\n"
"Array Boolean\n"
"\n"
"> :type [1, false]\n"
"Could not match type Int with type Boolean.\n"

#. type: Plain text
#: text/chapter3.md:81
msgid ""
"The error in the last example is an error from the type checker, which "
"unsuccessfully attempted to _unify_ (i.e. make equal) the types of the two "
"elements."
msgstr ""
"最後の例で起きているエラーは型検証器によって報告されたもので、\n"
"配列の2つの要素の型を**単一化**（Unification、等価にするの意）しようとして失敗したことを示しています。"

#. type: Plain text
#: text/chapter3.md:83
msgid ""
"Records correspond to JavaScript's objects, and record literals have the "
"same syntax as JavaScript's object literals:"
msgstr ""
"レコードはJavaScriptのオブジェクトに対応しており、レコードリテラルは"
"JavaScriptのオブジェクトリテラルと同じ構文になっています。"

#. type: Fenced code block (text)
#: text/chapter3.md:84
#, no-wrap
msgid ""
"> author = { name: \"Phil\", interests: [\"Functional Programming\", \"JavaScript\"] }\n"
"\n"
"> :type author\n"
"{ name :: String\n"
", interests :: Array String\n"
"}\n"
msgstr ""
"> author = { name: \"Phil\", interests: [\"Functional Programming\", \"JavaScript\"] }\n"
"\n"
"> :type author\n"
"{ name :: String\n"
", interests :: Array String\n"
"}\n"

#. type: Plain text
#: text/chapter3.md:94
msgid ""
"This type indicates that the specified object has two _fields_, a `name` "
"field which has type `String`, and an `interests` field, which has type "
"`Array String`, i.e. an array of `String`s."
msgstr "この型が示しているのは、指定されたオブジェクトは、 `String`型のフィールド `name` と `Array String`つまり `String`の配列の型のフィールド `interests` という２つの**フィールド** (field) を持っているということです。"

#. type: Plain text
#: text/chapter3.md:96
msgid ""
"Fields of records can be accessed using a dot, followed by the label of the "
"field to access:"
msgstr "レコードのフィールドは、ドットに続けて参照したいフィールドのラベルを書くと参照することができます。"

#. type: Fenced code block (text)
#: text/chapter3.md:97
#, no-wrap
msgid ""
"> author.name\n"
"\"Phil\"\n"
"\n"
"> author.interests\n"
"[\"Functional Programming\",\"JavaScript\"]\n"
msgstr ""
"> author.name\n"
"\"Phil\"\n"
"\n"
"> author.interests\n"
"[\"Functional Programming\",\"JavaScript\"]\n"

#. type: Plain text
#: text/chapter3.md:106
msgid ""
"PureScript's functions correspond to JavaScript's functions. The PureScript "
"standard libraries provide plenty of examples of functions, and we will see "
"more in this chapter:"
msgstr ""
"PureScriptの関数はJavaScriptの関数に対応しています。PureScriptの標準ライブラ"
"リは多くの関数の例を提供しており、この章ではそれらをもう少し詳しく見ていきま"
"す。"

#. type: Fenced code block (text)
#: text/chapter3.md:107
#, no-wrap
msgid ""
"> import Prelude\n"
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"
"\n"
"> :type const\n"
"forall a b. a -> b -> a\n"
msgstr ""
"> import Prelude\n"
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"
"\n"
"> :type const\n"
"forall a b. a -> b -> a\n"

#. type: Plain text
#: text/chapter3.md:117
msgid ""
"Functions can be defined at the top-level of a file by specifying arguments "
"before the equals sign:"
msgstr ""
"ファイルのトップレベルでは、等号の直前に引数を指定することで関数を定義するこ"
"とができます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:118
#, no-wrap
msgid ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"
msgstr ""
"add :: Int -> Int -> Int\n"
"add x y = x + y\n"

#. type: Plain text
#: text/chapter3.md:124
msgid ""
"Alternatively, functions can be defined inline, by using a backslash "
"character followed by a space-delimited list of argument names. To enter a "
"multi-line declaration in PSCi, we can enter \"paste mode\" by using the `:"
"paste` command. In this mode, declarations are terminated using the _Control-"
"D_ key sequence:"
msgstr ""
"バックスラッシュに続けて空白文字で区切られた引数名のリストを書くことで、関数をインラインで定義することもできます。\n"
"PSCiで複数行の宣言を入力するには、 `:paste`コマンドを使用して「貼り付けモード」に入ります。\n"
"このモードでは、**Control-D**キーシーケンスを使用して宣言を終了します。"

#. type: Fenced code block (text)
#: text/chapter3.md:125
#, no-wrap
msgid ""
"> :paste\n"
"â¦ add :: Int -> Int -> Int\n"
"â¦ add = \\x y -> x + y\n"
"â¦ ^D\n"
msgstr ""
"> :paste \n"
"… add :: Int -> Int -> Int \n"
"… add = \\x y -> x + y\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:133
msgid ""
"Having defined this function in PSCi, we can _apply_ it to its arguments by "
"separating the two arguments from the function name by whitespace:"
msgstr "PSCiでこの関数が定義されていると、次のように関数の隣に２つの引数を空白で区切って書くことで、関数をこれらの引数に**適用** (apply) することができます。"

#. type: Fenced code block (text)
#: text/chapter3.md:134
#, no-wrap
msgid ""
"> add 10 20\n"
"30\n"
msgstr ""
"> add 10 20\n"
"30\n"

#. type: Title ##
#: text/chapter3.md:139
#, no-wrap
msgid "Quantified Types"
msgstr "量化された型"

#. type: Plain text
#: text/chapter3.md:142
msgid ""
"In the previous section, we saw the types of some functions defined in the "
"Prelude. For example, the `flip` function had the following type:"
msgstr ""
"前の節ではPreludeで定義された関数の型をいくつか見てきました。たとえば `flip`"
"関数は次のような型を持っていました。"

#. type: Fenced code block (text)
#: text/chapter3.md:143
#, no-wrap
msgid ""
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"
msgstr ""
"> :type flip\n"
"forall a b c. (a -> b -> c) -> b -> a -> c\n"

#. type: Plain text
#: text/chapter3.md:149
msgid ""
"The keyword `forall` here indicates that `flip` has a _universally "
"quantified type_. It means that we can substitute any types for `a`, `b` and "
"`c`, and `flip` will work with those types."
msgstr ""
"この `forall`キーワードは、 `flip`が**全称量化された型** (universally quantified type) を持っていることを示しています。\n"
"これは、 `a`や `b`、 `c`をどの型に置き換えても、 `flip`はその型でうまく動作するという意味です。"

#. type: Plain text
#: text/chapter3.md:151
msgid ""
"For example, we might choose the type `a` to be `Int`, `b` to be `String` "
"and `c` to be `String`. In that case we could _specialize_ the type of "
"`flip` to"
msgstr ""
"例えば、 `a`を `Int`、 `b`を `String`、 `c`を `String`というように選んでみたとします。\n"
"この場合、 `flip`の型を次のように**特殊化** (specialize) することができます。"

#. type: Fenced code block (text)
#: text/chapter3.md:152
#, no-wrap
msgid "(Int -> String -> String) -> String -> Int -> String\n"
msgstr "(Int -> String -> String) -> String -> Int -> String\n"

#. type: Plain text
#: text/chapter3.md:157
msgid ""
"We don't have to indicate in code that we want to specialize a quantified "
"type - it happens automatically. For example, we can just use `flip` as if "
"it had this type already:"
msgstr ""
"量化された型を特殊化したいということをコードで示す必要はありません。特殊化は"
"自動的に行われます。たとえば、すでにその型の `flip`を持っていたかのように、次"
"のように単に `flip`を使用することができます。"

#. type: Fenced code block (text)
#: text/chapter3.md:158
#, no-wrap
msgid ""
"> flip (\\n s -> show n <> s) \"Ten\" 10\n"
"\n"
"\"10Ten\"\n"
msgstr ""
"> flip (\\n s -> show n <> s) \"Ten\" 10\n"
"\n"
"\"10Ten\"\n"

#. type: Plain text
#: text/chapter3.md:165
msgid ""
"While we can choose any types for `a`, `b` and `c`, we have to be "
"consistent. The type of the function we passed to `flip` had to be "
"consistent with the types of the other arguments. That is why we passed the "
"string `\"Ten\"` as the second argument, and the number `10` as the third. "
"It would not work if the arguments were reversed:"
msgstr ""
"`a`、 `b`、 `c`の型はどんな型でも選ぶことができるといっても、型の不整合は生じ"
"ないようにしなければなりません。 `flip`に渡す関数の型は、他の引数の型と整合性"
"がなくてはなりません。第２引数として文字列 `\"Ten\"`、第３引数として数 `10`を"
"渡したのはそれが理由です。もし引数が逆になっているとうまくいかないでしょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:166
#, no-wrap
msgid ""
"> flip (\\n s -> show n <> s) 10 \"Ten\"\n"
"\n"
"Could not match type Int with type String\n"
msgstr ""
"> flip (\\n s -> show n <> s) 10 \"Ten\"\n"
"\n"
"Could not match type Int with type String\n"

#. type: Title ##
#: text/chapter3.md:172
#, no-wrap
msgid "Notes On Indentation"
msgstr "字下げについての注意"

#. type: Plain text
#: text/chapter3.md:175
msgid ""
"PureScript code is _indentation-sensitive_, just like Haskell, but unlike "
"JavaScript. This means that the whitespace in your code is not meaningless, "
"but rather is used to group regions of code, just like curly braces in C-"
"like languages."
msgstr ""
"JavaScriptとは異なり、PureScriptのコードは字下げの大きさに影響されます (indentation-sensitive)。\n"
"これはHaskellと同じようになっています。\n"
"コード内の空白の多寡は無意味ではなく、Cのような言語で中括弧によってコードのまとまりを示しているように、PureScriptでは空白がコードのまとまりを示すのに使われているということです。"

#. type: Plain text
#: text/chapter3.md:177
msgid ""
"If a declaration spans multiple lines, then any lines except the first must "
"be indented past the indentation level of the first line."
msgstr "宣言が複数行にわたる場合は、最初の行以外は最初の行の字下げより深く字下げしなければなりません。"

#. type: Plain text
#: text/chapter3.md:179
msgid "Therefore, the following is valid PureScript code:"
msgstr "したがって、次は正しいPureScriptコードです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:180
#, no-wrap
msgid ""
"add x y z = x +\n"
"  y + z\n"
msgstr ""
"add x y z = x +\n"
"  y + z\n"

#. type: Plain text
#: text/chapter3.md:186
msgid "But this is not valid code:"
msgstr "しかし、次は正しいコードではありません。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:187
#, no-wrap
msgid ""
"add x y z = x +\n"
"y + z\n"
msgstr ""
"add x y z = x +\n"
"y + z\n"

#. type: Plain text
#: text/chapter3.md:193
msgid ""
"In the second case, the PureScript compiler will try to parse _two_ "
"declarations, one for each line."
msgstr ""
"後者では、PureScriptコンパイラはそれぞれの行ごとにひとつ、つまり**2つ**の宣言"
"であると構文解析します。"

#. type: Plain text
#: text/chapter3.md:195
msgid ""
"Generally, any declarations defined in the same block should be indented at "
"the same level. For example, in PSCi, declarations in a let statement must "
"be indented equally. This is valid:"
msgstr ""
"一般に、同じブロック内で定義された宣言は同じ深さで字下げする必要があります。\n"
"例えばPSCiでlet文の宣言は同じ深さで字下げしなければなりません。\n"
"次は正しいコードです。"

#. type: Fenced code block (text)
#: text/chapter3.md:196
#, no-wrap
msgid ""
"> :paste\n"
"â¦ x = 1\n"
"â¦ y = 2\n"
"â¦ ^D\n"
msgstr ""
"> :paste\n"
"… x = 1\n"
"… y = 2\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:204
msgid "but this is not:"
msgstr "しかし、これは正しくありません。"

#. type: Fenced code block (text)
#: text/chapter3.md:205
#, no-wrap
msgid ""
"> :paste\n"
"â¦ x = 1\n"
"â¦  y = 2\n"
"â¦ ^D\n"
msgstr ""
"> :paste\n"
"… x = 1\n"
"…  y = 2\n"
"… ^D\n"

#. type: Plain text
#: text/chapter3.md:213
msgid ""
"Certain PureScript keywords (such as `where`, `of` and `let`) introduce a "
"new block of code, in which declarations must be further-indented:"
msgstr ""
"PureScriptのいくつかの予約語（例えば `where`や `of`、 `let`）は新たなコードの"
"まとまりを導入しますが、そのコードのまとまり内の宣言はそれより深く字下げされ"
"ている必要があります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:214
#, no-wrap
msgid ""
"example x y z = foo + bar\n"
"  where\n"
"    foo = x * y\n"
"    bar = y * z\n"
msgstr ""
"example x y z = foo + bar\n"
"  where\n"
"    foo = x * y\n"
"    bar = y * z\n"

#. type: Plain text
#: text/chapter3.md:222
msgid ""
"Note how the declarations for `foo` and `bar` are indented past the "
"declaration of `example`."
msgstr ""
"ここで `foo`や `bar`の宣言は `example`の宣言より深く字下げされていることに注"
"意してください。"

#. type: Plain text
#: text/chapter3.md:224
msgid ""
"The only exception to this rule is the `where` keyword in the initial "
"`module` declaration at the top of a source file."
msgstr ""
"ただし、ソースファイルの先頭、最初の `module`宣言における予約語 `where`だけ"
"は、この規則の唯一の例外になっています。"

#. type: Title ##
#: text/chapter3.md:225
#, no-wrap
msgid "Defining Our Types"
msgstr "独自の型の定義"

#. type: Plain text
#: text/chapter3.md:228
msgid ""
"A good first step when tackling a new problem in PureScript is to write out "
"type definitions for any values you will be working with. First, let's "
"define a type for records in our address book:"
msgstr ""
"PureScriptで新たな問題に取り組むときは、まずはこれから扱おうとする値の型の定"
"義を書くことから始めるのがよいでしょう。最初に、住所録に含まれるレコードの型"
"を定義してみます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:229
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Entry}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Entry}}\n"

#. type: Plain text
#: text/chapter3.md:234
msgid ""
"This defines a _type synonym_ called `Entry` - the type `Entry` is "
"equivalent to the type on the right of the equals symbol: a record type with "
"three fields - `firstName`, `lastName` and `address`. The two name fields "
"will have type `String`, and the `address` field will have type `Address`, "
"defined as follows:"
msgstr ""
"これは `Entry`という**型同義語** (type synonym、型シノニム) を定義しています。\n"
"型 `Entry`は等号の右辺と同じ型ということです。\n"
"レコードの型はいずれも文字列である `firstName`、 `lastName`、 `phone`という３つのフィールドからなります。\n"
"前者の２つのフィールドは型 `String`を持ち、 `address`は以下のように定義された型 `Address`を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:235
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Address}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:Address}}\n"

#. type: Plain text
#: text/chapter3.md:240
msgid "Note that records can contain other records."
msgstr "なお、レコードには他のレコードを含めることができます。"

#. type: Plain text
#: text/chapter3.md:242
msgid ""
"Now let's define a third type synonym, for our address book data structure, "
"which will be represented simply as a linked list of entries:"
msgstr "それでは、3つめの型同義語も定義してみましょう。住所録のデータ構造としては、単に項目の連結リストとして格納することにします。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:243
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:AddressBook}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:AddressBook}}\n"

#. type: Plain text
#: text/chapter3.md:248
msgid ""
"Note that `List Entry` is not the same as `Array Entry`, which represents an "
"_array_ of entries."
msgstr ""
"`List Entry`は `Array Entry`とは同じではないということに注意してください。 "
"`Array Entry`は住所録の項目の**配列**を意味しています。"

#. type: Title ##
#: text/chapter3.md:249
#, no-wrap
msgid "Type Constructors and Kinds"
msgstr "型構築子と種"

#. type: Plain text
#: text/chapter3.md:252
msgid ""
"`List` is an example of a _type constructor_. Values do not have the type "
"`List` directly, but rather `List a` for some type `a`. That is, `List` "
"takes a _type argument_ `a` and _constructs_ a new type `List a`."
msgstr ""
"`List`は**型構築子**（type constructor、型コンストラクタ）の一例になっています。\n"
"`List`そのものは型ではなく、何らかの型 `a`があるとき `List a`が型になっています。\n"
"つまり、 `List`は**型引数** (type argument) `a`をとり、新たな型 `List a`を**構築**するのです。"

#. type: Plain text
#: text/chapter3.md:254
msgid ""
"Note that just like function application, type constructors are applied to "
"other types simply by juxtaposition: the type `List Entry` is in fact the "
"type constructor `List` _applied_ to the type `Entry` - it represents a list "
"of entries."
msgstr "ちょうど関数適用と同じように、型構築子は他の型に並べることで適用されることに注意してください。型 `List　Entry`は実は型構築子 `List`が型 `Entry`に**適用**されたものです。これは住所録項目のリストを表しています。"

#. type: Plain text
#: text/chapter3.md:256
msgid ""
"If we try to incorrectly define a value of type `List` (by using the type "
"annotation operator `::`), we will see a new type of error:"
msgstr "（型注釈演算子 `::`を使って）もし型 `List`の値を間違って定義しようとすると、今まで見たことのないような種類のエラーが表示されるでしょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:257
#, no-wrap
msgid ""
"> import Data.List\n"
"> Nil :: List\n"
"In a type-annotated expression x :: t, the type t must have kind Type\n"
msgstr ""
"> import Data.List\n"
"> Nil :: List\n"
"In a type-annotated expression x :: t, the type t must have kind Type\n"

#. type: Plain text
#: text/chapter3.md:264
msgid ""
"This is a _kind error_. Just like values are distinguished by their _types_, "
"types are distinguished by their _kinds_, and just like ill-typed values "
"result in _type errors_, _ill-kinded_ types result in _kind errors_."
msgstr ""
"これは**種エラー** (kind error) です。\n"
"値がその**型**で区別されるのと同じように、型はその**種** (kind) によって区別され、間違った型の値が**型エラー**になるように、**間違った種**の型は**種エラー**を引き起こします。"

#. type: Plain text
#: text/chapter3.md:266
msgid ""
"There is a special kind called `Type` which represents the kind of all types "
"which have values, like `Number` and `String`."
msgstr ""
"`Number`や `String`のような、値を持つすべての型の種を表す `Type`と呼ばれる特"
"別な種があります。"

#. type: Plain text
#: text/chapter3.md:268
#, no-wrap
msgid "There are also kinds for type constructors. For example, the kind `Type -> Type` represents a function from types to types, just like `List`. So the error here occurred because values are expected to have types with kind `Type`, but `List` has kind `Type -> Type`.\n"
msgstr ""
"型構築子にも種があります。\n"
"たとえば、種 `Type -> Type`はちょうど `List`のような型から型への関数を表しています。\n"
"ここでエラーが発生したのは、値が種 `Type`であるような型を持つと期待されていたのに、 `List`は種 `Type -> Type`を持っているためです。\n"

#. type: Plain text
#: text/chapter3.md:270
msgid ""
"To find out the kind of a type, use the `:kind` command in PSCi. For example:"
msgstr "PSCiで型の種を調べるには、 `:kind`命令を使用します。例えば次のようになります。"

#. type: Fenced code block (text)
#: text/chapter3.md:271
#, no-wrap
msgid ""
"> :kind Number\n"
"Type\n"
"\n"
"> import Data.List\n"
"> :kind List\n"
"Type -> Type\n"
"\n"
"> :kind List String\n"
"Type\n"
msgstr ""
"> :kind Number\n"
"Type\n"
"\n"
"> import Data.List\n"
"> :kind List\n"
"Type -> Type\n"
"\n"
"> :kind List String\n"
"Type\n"

#. type: Plain text
#: text/chapter3.md:284
msgid ""
"PureScript's _kind system_ supports other interesting kinds, which we will "
"see later in the book."
msgstr ""
"PureScriptの**種システム**は他にも面白い種に対応していますが、それらについて"
"は本書の他の部分で見ていくことになるでしょう。"

#. type: Title ##
#: text/chapter3.md:285
#, no-wrap
msgid "Displaying Address Book Entries"
msgstr "住所録の項目の表示"

#. type: Plain text
#: text/chapter3.md:288
msgid ""
"Let's write our first function, which will render an address book entry as a "
"string. We start by giving the function a type. This is optional, but good "
"practice, since it acts as a form of documentation. In fact, the PureScript "
"compiler will give a warning if a top-level declaration does not contain a "
"type annotation. A type declaration separates the name of a function from "
"its type with the `::` symbol:"
msgstr ""
"それでは最初に、文字列で住所録の項目を表現するような関数を書いてみましょう。\n"
"まずは関数に型を与えることから始めます。\n"
"型の定義は省略することも可能ですが、ドキュメントとしても役立つので型を書いておくようにすると良いでしょう。\n"
"実際、トップレベルの宣言に型註釈が含まれていないと、PureScriptコンパイラが警告を出します。\n"
"型宣言は関数の名前とその型を `::`記号で区切るようにして書きます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:289
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:294
msgid ""
"This type signature says that `showEntry` is a function, which takes an "
"`Entry` as an argument and returns a `String`. Here is the code for "
"`showEntry`:"
msgstr ""
"`showEntry`は引数として `Entry`を取り `string`を返す関数であるということを、この型シグネチャは言っています。\n"
"`showEntry`のコードは次のとおりです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:295
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_implementation}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showEntry_implementation}}\n"

#. type: Plain text
#: text/chapter3.md:300
msgid ""
"This function concatenates the three fields of the `Entry` record into a "
"single string, using the `showAddress` function to turn the record inside "
"the `address` field into a `String`. `showAddress` is defined similarly:"
msgstr "この関数は `Entry`レコードの3つのフィールドを連結し、単一の文字列にします。ここで使用される `showAddress`は `address`フィールドを連接し、単一の文字列にする関数です。 `showAddress`の定義は次のとおりです。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:301
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showAddress}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:showAddress}}\n"

#. type: Plain text
#: text/chapter3.md:306
#, no-wrap
msgid "A function definition begins with the name of the function, followed by a list of argument names. The result of the function is specified after the equals sign. Fields are accessed with a dot, followed by the field name. In PureScript, string concatenation uses the diamond operator (`<>`), instead of the plus operator like in JavaScript.\n"
msgstr "関数定義は関数の名前で始まり、引数名のリストが続きます。関数の結果は等号の後ろに定義します。フィールドはドットに続けてフィールド名を書くことで参照することができます。PureScriptでは、文字列連結はJavaScriptのような単一のプラス記号ではなく、ダイアモンド演算子（ `<>`）を使用します。\n"

#. type: Title ##
#: text/chapter3.md:307
#, no-wrap
msgid "Test Early, Test Often"
msgstr "はやめにテスト、たびたびテスト"

#. type: Plain text
#: text/chapter3.md:310
msgid ""
"The PSCi interactive mode allows for rapid prototyping with immediate "
"feedback, so let's use it to verify that our first few functions behave as "
"expected."
msgstr ""
"PSCi対話式モードでは反応を即座に得られるので、素早い試作開発に向いています。\n"
"それではこの最初の関数が正しく動作するかをPSCiを使用して確認してみましょう。"

#. type: Plain text
#: text/chapter3.md:312
msgid "First, build the code you've written:"
msgstr "まず、これまでに書いたコードをビルドします。"

#. type: Plain text
#: text/chapter3.md:318
msgid ""
"Next, load PSCi, and use the `import` command to import your new module:"
msgstr "次に、PSCiを起動し、この新しいモジュールをインポートするために `import`命令を使います。"

#. type: Fenced code block (text)
#: text/chapter3.md:319
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.AddressBook\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.AddressBook\n"

#. type: Plain text
#: text/chapter3.md:326
msgid ""
"We can create an entry by using a record literal, which looks just like an "
"anonymous object in JavaScript."
msgstr ""
"レコードリテラルを使うと、住所録の項目を作成することができます。レコードリテ"
"ラルはJavaScriptの無名オブジェクトと同じような構文で名前に束縛します。"

#. type: Fenced code block (text)
#: text/chapter3.md:327
#, no-wrap
msgid "> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
msgstr "> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"

#. type: Plain text
#: text/chapter3.md:332
msgid "Now, try applying our function to the example:"
msgstr "​それでは、この例に関数を適用してみてください。"

#. type: Fenced code block (text)
#: text/chapter3.md:333
#, no-wrap
msgid ""
"> showAddress address\n"
"\n"
"\"123 Fake St., Faketown, CA\"\n"
msgstr ""
"> showAddress address\n"
"\n"
"\"123 Fake St., Faketown, CA\"\n"

#. type: Plain text
#: text/chapter3.md:340
msgid ""
"Let's also test `showEntry` by creating an address book entry record "
"containing our example address:"
msgstr "`showEntry`も、住所を含む住所録項目の記録例を作って試しましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:341
#, no-wrap
msgid ""
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> showEntry entry\n"
"\n"
"\"Smith, John: 123 Fake St., Faketown, CA\"\n"
msgstr ""
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> showEntry entry\n"
"\n"
"\"Smith, John: 123 Fake St., Faketown, CA\"\n"

#. type: Title ##
#: text/chapter3.md:348
#, no-wrap
msgid "Creating Address Books"
msgstr "住所録の作成"

#. type: Plain text
#: text/chapter3.md:351
msgid ""
"Now let's write some utility functions for working with address books. We "
"will need a value which represents an empty address book: an empty list."
msgstr ""
"今度は住所録の操作を支援する関数をいくつか書いてみましょう。\n"
"空の住所録を表す値が必要ですが、これには空のリストを使います。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:352
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:emptyBook}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:emptyBook}}\n"

#. type: Plain text
#: text/chapter3.md:357
msgid ""
"We will also need a function for inserting a value into an existing address "
"book. We will call this function `insertEntry`. Start by giving its type:"
msgstr ""
"既存の住所録に値を挿入する関数も必要でしょう。この関数を `insertEntry`と呼ぶ"
"ことにします。関数の型を与えることから始めましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:358
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:363
msgid ""
"This type signature says that `insertEntry` takes an `Entry` as its first "
"argument, and an `AddressBook` as a second argument, and returns a new "
"`AddressBook`."
msgstr "この型シグネチャに書かれているのは、最初の引数として `Entry`、第二引数として `AddressBook`を取り、新しい `AddressBook`を返すということです。"

#. type: Plain text
#: text/chapter3.md:365
msgid ""
"We don't modify the existing `AddressBook` directly. Instead, we return a "
"new `AddressBook` which contains the same data. As such, `AddressBook` is an "
"example of an _immutable data structure_. This is an important idea in "
"PureScript - mutation is a side-effect of code, and inhibits our ability to "
"reason effectively about its behavior, so we prefer pure functions and "
"immutable data where possible."
msgstr ""
"既存の `AddressBook`を直接変更することはしません。\n"
"その代わりに、同じデータが含まれている新しい `AddressBook`を返すようにします。\n"
"このように、 `AddressBook`は**不変データ構造** (immutable data structure) の一例となっています。\n"
"これはPureScriptにおける重要な考え方です。\n"
"変更はコードの副作用であり、効率の良いコードの振る舞いの判断を妨げます。\n"
"そのため、我々は可能な限り純粋な関数や不変のデータを好むのです。"

#. type: Plain text
#: text/chapter3.md:367
msgid ""
"To implement `insertEntry`, we can use the `Cons` function from `Data.List`. "
"To see its type, open PSCi and use the `:type` command:"
msgstr ""
"`insertEntry`を実装するのに`Data.List`の`Cons`関数が使えます。\n"
"この関数の型を見るには、PSCiを起動し `:type`コマンドを使います。"

#. type: Fenced code block (text)
#: text/chapter3.md:368
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type Cons\n"
"\n"
"forall a. a -> List a -> List a\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type Cons\n"
"\n"
"forall a. a -> List a -> List a\n"

#. type: Plain text
#: text/chapter3.md:378
msgid ""
"This type signature says that `Cons` takes a value of some type `a`, and a "
"list of elements of type `a`, and returns a new list with entries of the "
"same type. Let's specialize this with `a` as our `Entry` type:"
msgstr ""
"`Cons`は、なんらかの型 `a`の値と、型 `a`を要素に持つリストを引数にとり、同じ"
"型の要素を持つ新しいリストを返すということを、この型シグネチャは言っていま"
"す。 `a`を `Entry`型として特殊化してみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:379
#, no-wrap
msgid "Entry -> List Entry -> List Entry\n"
msgstr "Entry -> List Entry -> List Entry\n"

#. type: Plain text
#: text/chapter3.md:384
msgid "But `List Entry` is the same as `AddressBook`, so this is equivalent to"
msgstr ""
"しかし、 `List Entry`はまさに `AddressBook`ですから、次と同じになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:385
#, no-wrap
msgid "Entry -> AddressBook -> AddressBook\n"
msgstr "Entry -> AddressBook -> AddressBook\n"

#. type: Plain text
#: text/chapter3.md:390
msgid ""
"In our case, we already have the appropriate inputs: an `Entry`, and an "
"`AddressBook`, so can apply `Cons` and get a new `AddressBook`, which is "
"exactly what we wanted!"
msgstr ""
"今回の場合、すでに適切な入力があります。 `Entry`と `AddressBook`に `Cons`を適"
"用すると、新しい `AddressBook`を得ることができます。これこそまさに私たちが求"
"めていた関数です！"

#. type: Plain text
#: text/chapter3.md:392
msgid "Here is our implementation of `insertEntry`:"
msgstr "`insertEntry`の実装は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:393
#, no-wrap
msgid "insertEntry entry book = Cons entry book\n"
msgstr "insertEntry entry book = Cons entry book\n"

#. type: Plain text
#: text/chapter3.md:398
msgid ""
"This brings the two arguments `entry` and `book` into scope, on the left "
"hand side of the equals symbol, and then applies the `Cons` function to "
"create the result."
msgstr ""
"等号の左側にある２つの引数 `entry`と `book`がスコープに導入されますから、これ"
"らに `Cons`関数を適用して結果の値を作成しています。"

#. type: Title ##
#: text/chapter3.md:399
#, no-wrap
msgid "Curried Functions"
msgstr "カリー化された関数"

#. type: Plain text
#: text/chapter3.md:402
msgid ""
"Functions in PureScript take exactly one argument. While it looks like the "
"`insertEntry` function takes two arguments, it is in fact an example of a "
"_curried function_."
msgstr ""
"PureScriptでは、関数は常にひとつの引数だけを取ります。\n"
"`insertEntry`関数は２つの引数を取るように見えますが、これは実際には**カリー化された関数** (curried function) の一例となっています。"

#. type: Plain text
#: text/chapter3.md:404
#, no-wrap
msgid "The `->` operator in the type of `insertEntry` associates to the right, which means that the compiler parses the type as\n"
msgstr "`insertEntry`の型に含まれる `->`は右結合の演算子であり、つまりこの型はコンパイラによって次のように解釈されます。\n"

#. type: Fenced code block (haskell)
#: text/chapter3.md:405
#, no-wrap
msgid "Entry -> (AddressBook -> AddressBook)\n"
msgstr "Entry -> (AddressBook -> AddressBook)\n"

#. type: Plain text
#: text/chapter3.md:410
msgid ""
"That is, `insertEntry` is a function which returns a function! It takes a "
"single argument, an `Entry`, and returns a new function, which in turn takes "
"a single `AddressBook` argument and returns a new `AddressBook`."
msgstr ""
"すなわち、 `insertEntry`は関数を返す関数である、ということです！この関数は単"
"一の引数 `Entry`を取り、それから単一の引数 `AddressBook`を取り新しい "
"`AddressBook`を返す新しい関数を返すのです。"

#. type: Plain text
#: text/chapter3.md:412
msgid ""
"This means that we can _partially apply_ `insertEntry` by specifying only "
"its first argument, for example. In PSCi, we can see the result type:"
msgstr ""
"これは例えば、最初の引数だけを与えると `insertEntry`を**部分適用** (partial application) できることを意味します。\n"
"PSCiでこの結果の型を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:413
#, no-wrap
msgid ""
"> :type insertEntry entry\n"
"\n"
"AddressBook -> AddressBook\n"
msgstr ""
"> :type insertEntry entry\n"
"\n"
"AddressBook -> AddressBook\n"

#. type: Plain text
#: text/chapter3.md:420
msgid ""
"As expected, the return type was a function. We can apply the resulting "
"function to a second argument:"
msgstr ""
"期待したとおり、戻り値の型は関数になっていました。\n"
"この結果の関数に、2つ目の引数を適用することもできます。"

#. type: Fenced code block (text)
#: text/chapter3.md:421
#, no-wrap
msgid ""
"> :type (insertEntry entry) emptyBook\n"
"AddressBook\n"
msgstr ""
"> :type (insertEntry entry) emptyBook\n"
"AddressBook\n"

#. type: Plain text
#: text/chapter3.md:427
msgid ""
"Note though that the parentheses here are unnecessary - the following is "
"equivalent:"
msgstr "ここで括弧は不要であることにも注意してください。次の式は同等です。"

#. type: Fenced code block (text)
#: text/chapter3.md:428
#, no-wrap
msgid ""
"> :type insertEntry entry emptyBook\n"
"AddressBook\n"
msgstr ""
"> :type insertEntry entry emptyBook\n"
"AddressBook\n"

#. type: Plain text
#: text/chapter3.md:434
msgid ""
"This is because function application associates to the left, and this "
"explains why we can just specify function arguments one after the other, "
"separated by whitespace."
msgstr ""
"これは関数適用が左結合であるためで、\n"
"なぜ単に空白で区切るだけで関数に引数を与えることができるのかの説明にもなっています。"

#. type: Plain text
#: text/chapter3.md:436
#, no-wrap
msgid "The `->` operator in function types is a _type constructor_ for functions. It takes two type arguments, the function's argument type and the return type. The left and right operands respectively.\n"
msgstr ""
"関数の型の`->`演算子は関数の**型構築子**です。\n"
"この演算子は2つの型引数を取ります。\n"
"左右の被演算子はそれぞれ関数の引数の型と返値の型です。\n"

#. type: Plain text
#: text/chapter3.md:438
msgid ""
"Note that in the rest of the book, I will talk about things like \"functions "
"of two arguments\". However, it is to be understood that this means a "
"curried function, taking a first argument and returning a function that "
"takes the second."
msgstr ""
"本書では今後、「2引数の関数」というように表現することがあることに注意してください。\n"
"しかしそれはカリー化された関数を意味していると考えるべきで、その関数は最初の引数を取り2つ目の引数を取る別の関数を返すのです。"

#. type: Plain text
#: text/chapter3.md:440
msgid "Now consider the definition of `insertEntry`:"
msgstr "今度は `insertEntry`の定義について考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:441
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry book = Cons entry book\n"
msgstr ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry book = Cons entry book\n"

#. type: Plain text
#: text/chapter3.md:447
msgid ""
"If we explicitly parenthesize the right-hand side, we get `(Cons entry) "
"book`. That is, `insertEntry entry` is a function whose argument is just "
"passed along to the `(Cons entry)` function. But if two functions have the "
"same result for every input, then they are the same function! So we can "
"remove the argument `book` from both sides:"
msgstr ""
"もし式の右辺に明示的に括弧をつけるなら、 `(Cons entry) book`となります。\n"
"`insertEntry entry`はその引数が単に関数 `(Cons entry)`に渡されるような関数だということです。\n"
"でもこの2つの関数はどんな入力についても同じ結果を返しますから、つまりこれらは同じ関数です！\n"
"よって、両辺から引数 `book`を削除できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:448
#, no-wrap
msgid ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry = Cons entry\n"
msgstr ""
"insertEntry :: Entry -> AddressBook -> AddressBook\n"
"insertEntry entry = Cons entry\n"

#. type: Plain text
#: text/chapter3.md:454
msgid "But now, by the same argument, we can remove `entry` from both sides:"
msgstr "しかし今や同様の議論により、両辺から `entry`も削除することができます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:455
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:insertEntry}}\n"

#. type: Plain text
#: text/chapter3.md:460
msgid ""
"This process is called _eta conversion_, and can be used (along with some "
"other techniques) to rewrite functions in _point-free form_, which means "
"functions defined without reference to their arguments."
msgstr "この処理は**イータ変換** (eta conversion) と呼ばれ、（その他の技法を併用して）引数を参照することなく関数を定義する**ポイントフリー形式** (point-free form) へと関数を書き換えるのに使うことができます。"

#. type: Plain text
#: text/chapter3.md:462
msgid ""
"In the case of `insertEntry`, _eta conversion_ has resulted in a very clear "
"definition of our function - \"`insertEntry` is just cons on lists\". "
"However, it is arguable whether point-free form is better in general."
msgstr ""
"`insertEntry`の場合には、イータ変換によって「`insertEntry`は単にリストに対するconsだ」となり、関数の定義はとても明確になりました。\n"
"しかしながら、一般的にポイントフリー形式のほうがいいのかどうかには議論の余地があります。"

#. type: Title ##
#: text/chapter3.md:463
#, no-wrap
msgid "Property Accessors"
msgstr "プロパティ取得子"

#. type: Plain text
#: text/chapter3.md:466
msgid ""
"One common pattern is to use a function to access individual fields (or "
"\"properties\") of a record. An inline function to extract an `Address` from "
"an `Entry` could be written as:"
msgstr ""
"よくあるパターンの1つとして、レコード中の個別のフィールド（または「プロパティ」）を取得することがあります。\n"
"`Entry`から`Address`を取り出すインライン関数は次のように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:467
#, no-wrap
msgid "\\entry -> entry.address\n"
msgstr "\\entry -> entry.address\n"

#. type: Plain text
#: text/chapter3.md:472
msgid ""
"PureScript also allows [_property accessor_](https://github.com/purescript/"
"documentation/blob/master/language/Syntax.md#property-accessors) shorthand, "
"where an underscore acts as the anonymous function argument, so the inline "
"function above is equivalent to:"
msgstr ""
"PureScriptでは[**プロパティ取得子**](https://github.com/purescript/documentation/blob/master/language/Syntax.md#property-accessors)という略記が使えます。\n"
"この略記では下線文字は無名関数の引数として振舞うため、上記のインライン関数は次と等価です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:473
#, no-wrap
msgid "_.address\n"
msgstr "_.address\n"

#. type: Plain text
#: text/chapter3.md:478
msgid ""
"This works with any number of levels or properties, so a function to extract "
"the city associated with an `Entry` could be written as:"
msgstr "これは何段階のプロパティでも動くため、`Entry`に関連付く街を取り出す関数は次のように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:479
#, no-wrap
msgid "_.address.city\n"
msgstr "_.address.city\n"

#. type: Plain text
#: text/chapter3.md:484 text/chapter5.md:246
msgid "For example:"
msgstr "以下は例です。"

#. type: Fenced code block (text)
#: text/chapter3.md:485
#, no-wrap
msgid ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> _.lastName entry\n"
"\"Smith\"\n"
"\n"
"> _.address.city entry\n"
"\"Faketown\"\n"
msgstr ""
"> address = { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
"> entry = { firstName: \"John\", lastName: \"Smith\", address: address }\n"
"> _.lastName entry\n"
"\"Smith\"\n"
"\n"
"> _.address.city entry\n"
"\"Faketown\"\n"

#. type: Title ##
#: text/chapter3.md:495
#, no-wrap
msgid "Querying the Address Book"
msgstr "あなたの住所録は？"

#. type: Plain text
#: text/chapter3.md:498
msgid ""
"The last function we need to implement for our minimal address book "
"application will look up a person by name and return the correct `Entry`. "
"This will be a nice application of building programs by composing small "
"functions - a key idea from functional programming."
msgstr "最小限の住所録アプリケーションの実装で必要になる最後の関数は、名前で人を検索し適切な `Entry`を返すものです。これは小さな関数を組み合わせることでプログラムを構築するという、関数型プログラミングで鍵となる考え方のよい応用例になるでしょう。"

#. type: Plain text
#: text/chapter3.md:500
msgid ""
"We can first filter the address book, keeping only those entries with the "
"correct first and last names. Then we can simply return the head (i.e. "
"first) element of the resulting list."
msgstr "まずは住所録をフィルタリングし、該当する姓名を持つ項目だけを保持するようにするのがいいでしょう。それから、結果のリストの先頭の (head) 要素を返すだけです。"

#. type: Plain text
#: text/chapter3.md:502
msgid ""
"With this high-level specification of our approach, we can calculate the "
"type of our function. First open PSCi, and find the types of the `filter` "
"and `head` functions:"
msgstr ""
"この大まかな仕様に従って、この関数の型を計算することができます。\n"
"まずPSCiを起動し、 `filter`関数と `head`関数の型を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter3.md:503
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type filter\n"
"\n"
"forall a. (a -> Boolean) -> List a -> List a\n"
"\n"
"> :type head\n"
"\n"
"forall a. List a -> Maybe a\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.List\n"
"> :type filter\n"
"\n"
"forall a. (a -> Boolean) -> List a -> List a\n"
"\n"
"> :type head\n"
"\n"
"forall a. List a -> Maybe a\n"

#. type: Plain text
#: text/chapter3.md:517
msgid "Let's pick apart these two types to understand their meaning."
msgstr ""
"型の意味を理解するために、これらの2つの型の一部を取り出してみましょう。"

#. type: Plain text
#: text/chapter3.md:519
msgid ""
"`filter` is a curried function of two arguments. Its first argument is a "
"function, which takes an element of the list and returns a `Boolean` value "
"as a result. Its second argument is a list of elements, and the return value "
"is another list."
msgstr ""
"`filter`はカリー化された2引数の関数です。\n"
"最初の引数は、リストの要素を取り `Boolean`値を結果として返す関数です。\n"
"第2引数は要素のリストで、返り値は別のリストです。"

#. type: Plain text
#: text/chapter3.md:521
msgid ""
"`head` takes a list as its argument, and returns a type we haven't seen "
"before: `Maybe a`. `Maybe a` represents an optional value of type `a`, and "
"provides a type-safe alternative to using `null` to indicate a missing value "
"in languages like JavaScript. We will see it again in more detail in later "
"chapters."
msgstr "`head`は引数としてリストをとり、 `Maybe a`という今まで見たことがないような型を返します。 `Maybe a`は型 `a`のオプショナルな値、つまり `a`の値を持つか持たないかのどちらかの値を示しており、JavaScriptのような言語で値がないことを示すために使われる `null`の型安全な代替手段を提供します。これについては後の章で詳しく扱います。"

#. type: Plain text
#: text/chapter3.md:523
msgid ""
"The universally quantified types of `filter` and `head` can be _specialized_ "
"by the PureScript compiler, to the following types:"
msgstr "`filter`と `head`の全称量化された型は、PureScriptコンパイラによって次のように**特殊化** (specialized) されます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:524
#, no-wrap
msgid ""
"filter :: (Entry -> Boolean) -> AddressBook -> AddressBook\n"
"\n"
"head :: AddressBook -> Maybe Entry\n"
msgstr ""
"filter :: (Entry -> Boolean) -> AddressBook -> AddressBook\n"
"\n"
"head :: AddressBook -> Maybe Entry\n"

#. type: Plain text
#: text/chapter3.md:531
msgid ""
"We know that we will need to pass the first and last names that we want to "
"search for, as arguments to our function."
msgstr "検索する関数の引数として姓と名前を渡す必要があるのもわかっています。"

#. type: Plain text
#: text/chapter3.md:533
#, no-wrap
msgid "We also know that we will need a function to pass to `filter`. Let's call this function `filterEntry`. `filterEntry` will have type `Entry -> Boolean`. The application `filter filterEntry` will then have type `AddressBook -> AddressBook`. If we pass the result of this function to the `head` function, we get our result of type `Maybe Entry`.\n"
msgstr "`filter`に渡す関数も必要になることもわかります。この関数を `filterEntry`と呼ぶことにしましょう。 `filterEntry`は `Entry -> Boolean`という型を持っています。 `filter filterEntry`という関数適用の式は、 `AddressBook -> AddressBook`という型を持つでしょう。もしこの関数の結果を `head`関数に渡すと、型 `Maybe Entry`の結果を得ることになります。\n"

#. type: Plain text
#: text/chapter3.md:535
msgid ""
"Putting these facts together, a reasonable type signature for our function, "
"which we will call `findEntry`, is:"
msgstr ""
"これまでのことをまとめると、関数の妥当な型シグネチャは次のようになります。\n"
"`findEntry`と呼ぶことにしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:536
#, no-wrap
msgid "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_signature}}\n"
msgstr "{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_signature}}\n"

#. type: Plain text
#: text/chapter3.md:541
msgid ""
"This type signature says that `findEntry` takes two strings, the first and "
"last names, and a `AddressBook`, and returns an optional `Entry`. The "
"optional result will contain a value only if the name is found in the "
"address book."
msgstr ""
"`findEntry`は、姓と名前の2つの文字列、および `AddressBook`を引数にとり、 `Entry`のオプション型の値を結果として返すということを、この型シグネチャは言っています。\n"
"オプショナルな結果は、名前が住所録で発見された場合にのみ値を持ちます。"

#. type: Plain text
#: text/chapter3.md:543
msgid "And here is the definition of `findEntry`:"
msgstr "そして、 `findEntry`の定義は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:544
#, no-wrap
msgid ""
"findEntry firstName lastName book = head (filter filterEntry book)\n"
"  where\n"
"    filterEntry :: Entry -> Boolean\n"
"    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName\n"
msgstr ""
"findEntry firstName lastName book = head (filter filterEntry book)\n"
"  where\n"
"    filterEntry :: Entry -> Boolean\n"
"    filterEntry entry = entry.firstName == firstName && entry.lastName == lastName\n"

#. type: Plain text
#: text/chapter3.md:552
msgid "Let's go over this code step by step."
msgstr "一歩ずつこのコードを調べてみましょう。"

#. type: Plain text
#: text/chapter3.md:554
msgid ""
"`findEntry` brings three names into scope: `firstName`, and `lastName`, both "
"representing strings, and `book`, an `AddressBook`."
msgstr "`findEntry`は、どちらも文字列型である `firstName`と `lastName`、 `AddressBook`型の `book`という3つの名前をスコープに導入します"

#. type: Plain text
#: text/chapter3.md:556
msgid ""
"The right hand side of the definition combines the `filter` and `head` "
"functions: first, the list of entries is filtered, and the `head` function "
"is applied to the result."
msgstr ""
"定義の右辺では `filter`関数と `head`関数が組み合わされています。まず項目のリ"
"ストをフィルタリングし、その結果に `head`関数を適用しています。"

#. type: Plain text
#: text/chapter3.md:558
msgid ""
"The predicate function `filterEntry` is defined as an auxiliary declaration "
"inside a `where` clause. This way, the `filterEntry` function is available "
"inside the definition of our function, but not outside it. Also, it can "
"depend on the arguments to the enclosing function, which is essential here "
"because `filterEntry` uses the `firstName` and `lastName` arguments to "
"filter the specified `Entry`."
msgstr ""
"真偽型を返す関数 `filterEntry`は `where`節の内部で補助的な関数として定義され"
"ています。このため、 `filterEntry`関数はこの定義の内部では使用できますが、外"
"部では使用することができません。また、 `filterEntry`はそれを包む関数の引数に"
"依存することができ、 `filterEntry`は指定された `Entry`をフィルタリングするた"
"めに引数 `firstName`と `lastName`を使用しているので、 `filterEntry`が "
"`findEntry`の内部にあることは必須になっています。"

#. type: Plain text
#: text/chapter3.md:560
msgid ""
"Note that, just like for top-level declarations, it was not necessary to "
"specify a type signature for `filterEntry`. However, doing so is recommended "
"as a form of documentation."
msgstr ""
"最上位での宣言と同じように、必ずしも `filterEntry`の型シグネチャを指定しなく"
"てもよいことに注意してください。ただし、ドキュメントとしても役に立つので型シ"
"グネチャを書くことは推奨されています。"

#. type: Title ##
#: text/chapter3.md:561
#, no-wrap
msgid "Infix Function Application"
msgstr "中置の関数適用"

#. type: Plain text
#: text/chapter3.md:564
msgid ""
"Most of the functions discussed so far used _prefix_ function application, "
"where the function name was put _before_ the arguments. For example, when "
"using the `insertEntry` function to add an `Entry` (`john`) to an empty "
"`AddressBook`, we might write:"
msgstr ""
"これまでお話しした関数のほとんどは**前置**関数適用でした。\n"
"関数名が引数の**前**に置かれていたということです。\n"
"例えば`insertEntry`関数を使って`Entry` (`john`) を空の`AddressBook`に追加する場合、以下のように書けます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:565
#, no-wrap
msgid "> book1 = insertEntry john emptyBook\n"
msgstr "> book1 = insertEntry john emptyBook\n"

#. type: Plain text
#: text/chapter3.md:570
msgid ""
"However, this chapter has also included examples of _infix_ [binary "
"operators](https://github.com/purescript/documentation/blob/master/language/"
"Syntax.md#binary-operators), such as the `==` operator in the definition of "
"`filterEntry`, where the operator is put _between_ the two arguments. These "
"infix operators are actually defined in the PureScript source as infix "
"aliases for their underlying _prefix_ implementations. For example, `==` is "
"defined as an infix alias for the prefix `eq` function with the line:"
msgstr ""
"しかしこの章には**中置**[2引数演算子](https://github.com/purescript/documentation/blob/master/language/Syntax.md#binary-operators)の例も含まれています。\n"
"例えば`filterEntry`の定義中の`==`演算子で、演算子が2つの引数の**間**に置かれています。\n"
"実はこうした中置演算子はPureScriptのソースコードで、\n"
"背後にある**前置**版の実装への中置別称として定義されています。\n"
"例えば`==`は以下の行により前置の`eq`関数の中置別称として定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:571
#, no-wrap
msgid "infix 4 eq as ==\n"
msgstr "infix 4 eq as ==\n"

#. type: Plain text
#: text/chapter3.md:576
msgid ""
"and therefore `entry.firstName == firstName` in `filterEntry` could be "
"replaced with the `eq entry.firstName firstName`. We'll cover a few more "
"examples of defining infix operators later in this section."
msgstr ""
"したがって`filterEntry`中の`entry.firstName == firstName`は`eq entry.firstName firstName`で置き換えられます。\n"
"この節の後のほうで中置演算子を定義する例をもう少し押さえます。"

#. type: Plain text
#: text/chapter3.md:578
msgid ""
"There are situations where putting a prefix function in an infix position as "
"an operator leads to more readable code. One example is the `mod` function:"
msgstr ""
"前置関数を演算子としての中置の位置に置くとより読みやすいコードになる場面があります。\n"
"その一例が`mod`関数です。"

#. type: Fenced code block (text)
#: text/chapter3.md:579
#, no-wrap
msgid ""
"> mod 8 3\n"
"2\n"
msgstr ""
"> mod 8 3\n"
"2\n"

#. type: Plain text
#: text/chapter3.md:585
msgid ""
"The above usage works fine, but is awkward to read. A more familiar phrasing "
"is \"eight mod three\", which you can achieve by wrapping a prefix function "
"in backticks (\\`):"
msgstr ""
"上の用例は正しく動きますが、読みづらいです。\n"
"より馴染みのある表現の仕方は「8 mod 3」ですが、\n"
"バックスラッシュ (\\`) の中に前置関数を包めばこのように書けます。"

#. type: Fenced code block (text)
#: text/chapter3.md:586
#, no-wrap
msgid ""
"> 8 `mod` 3\n"
"2\n"
msgstr ""
"> 8 `mod` 3\n"
"2\n"

#. type: Plain text
#: text/chapter3.md:592
msgid ""
"In the same way, wrapping `insertEntry` in backticks turns it into an infix "
"operator, such that `book1` and `book2` below are equivalent:"
msgstr ""
"同様に、`insertEntry`をバックスラッシュで包むと中置演算子に変わります。\n"
"例えば以下の`book1`と`book2`は等価です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:593
#, no-wrap
msgid ""
"book1 = insertEntry john emptyBook\n"
"book2 = john `insertEntry` emptyBook\n"
msgstr ""
"book1 = insertEntry john emptyBook\n"
"book2 = john `insertEntry` emptyBook\n"

#. type: Plain text
#: text/chapter3.md:599
msgid ""
"We can make an `AddressBook` with multiple entries by using multiple "
"applications of `insertEntry` as a prefix function (`book3`) or as an infix "
"operator (`book4`) as shown below:"
msgstr "複数回`insertEntry`を適用することで複数の項目がある`AddressBook`を作ることができますが、以下のように前置関数 (`book3`) として適用するか中置演算子 (`book4`) として適用するかの2択があります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:600
#, no-wrap
msgid ""
"book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))\n"
"book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))\n"
msgstr ""
"book3 = insertEntry john (insertEntry peggy (insertEntry ned emptyBook))\n"
"book4 = john `insertEntry` (peggy `insertEntry` (ned `insertEntry` emptyBook))\n"

#. type: Plain text
#: text/chapter3.md:606
msgid ""
"We can also define an infix operator alias (or synonym) for `insertEntry.` "
"We'll arbitrarily choose `++` for this operator, give it a [precedence]"
"(https://github.com/purescript/documentation/blob/master/language/Syntax."
"md#precedence) of `5`, and make it right [associative](https://github.com/"
"purescript/documentation/blob/master/language/Syntax.md#associativity) using "
"`infixr`:"
msgstr ""
"`insertEntry`に中置演算子別称（または同義語）を定義することもできます。\n"
"この演算子の名前に適当に`++`を選び、\n"
"[優先度](https://github.com/purescript/documentation/blob/master/language/Syntax.md#precedence)を`5`にし、\n"
"そして`infixr`を使って右[結合](https://github.com/purescript/documentation/blob/master/language/Syntax.md#associativity)とします。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:607
#, no-wrap
msgid "infixr 5 insertEntry as ++\n"
msgstr "infixr 5 insertEntry as ++\n"

#. type: Plain text
#: text/chapter3.md:612
msgid "This new operator lets us rewrite the above `book4` example as:"
msgstr "この新しい演算子で上の`book4`の例を次のように書き直せます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:613
#, no-wrap
msgid "book5 = john ++ (peggy ++ (ned ++ emptyBook))\n"
msgstr "book5 = john ++ (peggy ++ (ned ++ emptyBook))\n"

#. type: Plain text
#: text/chapter3.md:618
msgid ""
"and the right associativity of our new `++` operator lets us get rid of the "
"parentheses without changing the meaning:"
msgstr "そして新しい`++`演算子が右結合なので意味を変えずに括弧を除去できます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:619
#, no-wrap
msgid "book6 = john ++ peggy ++ ned ++ emptyBook\n"
msgstr "book6 = john ++ peggy ++ ned ++ emptyBook\n"

#. type: Plain text
#: text/chapter3.md:624
msgid ""
"Another common technique for eliminating parens is to use `apply`'s infix "
"operator `$`, along with your standard prefix functions."
msgstr "括弧を消去する他のよくある技法は、いつもの前置関数と一緒に`apply`の中置演算子`$`を使うというものです。"

#. type: Plain text
#: text/chapter3.md:626
msgid "For example, the earlier `book3` example could be rewritten as:"
msgstr "例えば前の`book3`の例は以下のように書き直せます。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:626
#, no-wrap
msgid "book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook\n"
msgstr "book7 = insertEntry john $ insertEntry peggy $ insertEntry ned emptyBook\n"

#. type: Plain text
#: text/chapter3.md:631
msgid ""
"Substituting `$` for parens is usually easier to type and (arguably) easier "
"to read. A mnemonic to remember the meaning of this symbol is to think of "
"the dollar sign as being drawn from two parens that are also being crossed-"
"out, suggesting the parens are now unnecessary."
msgstr ""
"括弧を`$`で置き換えるのは大抵入力しやすくなりますし（議論の余地がありますが）読みやすくなります。\n"
"この記号の意味を覚えるための記憶術として、ドル記号を2つの括弧に打ち消し線が引かれたものと見ることで、これで括弧が不必要になったのだと推測できるという方法があります。"

#. type: Plain text
#: text/chapter3.md:633
msgid ""
"Note that `$` isn't special syntax that's hardcoded into the language. It's "
"simply the infix operator for a regular function called `apply`, which is "
"defined in `Data.Function` as follows:"
msgstr ""
"なお、`($)`は言語にハードコードされた特別な構文ではありません。\n"
"単に`apply`という名前の通常の関数のための中置演算子であって、`Data.Function`で以下のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:634
#, no-wrap
msgid ""
"apply :: forall a b. (a -> b) -> a -> b\n"
"apply f x = f x\n"
"\n"
"infixr 0 apply as $\n"
msgstr ""
"apply :: forall a b. (a -> b) -> a -> b\n"
"apply f x = f x\n"
"\n"
"infixr 0 apply as $\n"

#. type: Plain text
#: text/chapter3.md:642
#, no-wrap
msgid "The `apply` function takes another function (of type `(a -> b)`) as its first argument and a value (of type `a`) as its second argument, then calls that function with that value. If it seems like this function doesn't contribute anything meaningful, you are absolutely correct! Your program is logically identical without it (see [referential transparency](https://en.wikipedia.org/wiki/Referential_transparency)). The syntactic utility of this function comes from the special properties assigned to its infix operator. `$` is a right-associative (`infixr`), low precedence (`0`) operator, which lets us remove sets of parentheses for deeply-nested applications.\n"
msgstr ""
"`apply`関数は、他の関数（型は`(a -> b)`）を最初の引数に、値（型は`a`）を2つ目の引数に取って、その値に対して関数を呼びます。\n"
"この関数が何ら意味のあることをしていないようだと思ったら、まったくもって正しいです！\n"
"この関数がなくてもプログラムは論理的に同一です。\n"
"（[参照透過性](https://en.wikipedia.org/wiki/Referential_transparency)も見てください。）\n"
"この関数の構文的な利便性はその中置演算子に割り当てられた特別な性質からきています。\n"
"`$`は右結合 (`infixr`) で低い優先度 (`0`) の演算子ですが、これにより深い入れ子になった適用から括弧の束を削除できるのです。\n"

#. type: Plain text
#: text/chapter3.md:644
msgid ""
"Another parens-busting opportunity for the `$` operator is in our earlier "
"`findEntry` function:"
msgstr "さらなる`$`演算子を使った括弧退治の機会は、以前の`findEntry`関数にあります。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:644
#, no-wrap
msgid "findEntry firstName lastName book = head $ filter filterEntry book\n"
msgstr "findEntry firstName lastName book = head $ filter filterEntry book\n"

#. type: Plain text
#: text/chapter3.md:648
msgid ""
"We'll see an even more elegant way to rewrite this line with \"function "
"composition\" in the next section."
msgstr "この行をより簡潔に書き換える方法を次節の「関数合成」で見ていきます。"

#. type: Plain text
#: text/chapter3.md:650
msgid ""
"If you'd like to use a concise infix operator alias as a prefix function, "
"you can surround it in parentheses:"
msgstr "名前の短い中置演算子を前置関数として使いたければ括弧で囲むことができます。"

#. type: Fenced code block (text)
#: text/chapter3.md:651
#, no-wrap
msgid ""
"> 8 + 3\n"
"11\n"
"\n"
"> (+) 8 3\n"
"11\n"
msgstr ""
"> 8 + 3\n"
"11\n"
"\n"
"> (+) 8 3\n"
"11\n"

#. type: Plain text
#: text/chapter3.md:660
msgid ""
"Alternatively, operators can be partially applied by surrounding the "
"expression with parentheses and using `_` as an operand in an [operator "
"section](https://github.com/purescript/documentation/blob/master/language/"
"Syntax.md#operator-sections). You can think of this as a more convenient way "
"to create simple anonymous functions (although in the below example, we're "
"then binding that anonymous function to a name, so it's not so anonymous "
"anymore):"
msgstr ""
"その代わりの手段として演算子は部分適用することができ、これには式を括弧で囲んで[演算子節](https://github.com/purescript/documentation/blob/master/language/Syntax.md#operator-sections)中の引数として`_`を使います。\n"
"これは簡単な無名関数を作るより便利な方法として考えることができます。\n"
"（以下の例ではそこから無名関数を名前に束縛しているので、もはや別に無名とも言えなくなっていますが。）"

#. type: Fenced code block (text)
#: text/chapter3.md:661
#, no-wrap
msgid ""
"> add3 = (3 + _)\n"
"> add3 2\n"
"5\n"
msgstr ""
"> add3 = (3 + _)\n"
"> add3 2\n"
"5\n"

#. type: Plain text
#: text/chapter3.md:668
msgid ""
"To summarize, the following are equivalent definitions of a function that "
"adds `5` to its argument:"
msgstr "まとめると、以下は引数に`5`を加える関数の等価な定義です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:669
#, no-wrap
msgid ""
"add5 x = 5 + x\n"
"add5 x = add 5 x\n"
"add5 x = (+) 5 x\n"
"add5 x = 5 `add` x\n"
"add5   = add 5\n"
"add5   = \\x -> 5 + x\n"
"add5   = (5 + _)\n"
"add5 x = 5 `(+)` x  -- Yo Dawg, I herd you like infix, so we put infix in your infix!\n"
msgstr ""
"add5 x = 5 + x\n"
"add5 x = add 5 x\n"
"add5 x = (+) 5 x\n"
"add5 x = 5 `add` x\n"
"add5   = add 5\n"
"add5   = \\x -> 5 + x\n"
"add5   = (5 + _)\n"
"add5 x = 5 `(+)` x  -- よおポチ、中置に目がないっていうから、中置の中に中置を入れといたぜ！\n"

#. type: Title ##
#: text/chapter3.md:680
#, no-wrap
msgid "Function Composition"
msgstr "関数合成"

#. type: Plain text
#: text/chapter3.md:683
msgid ""
"Just like we were able to simplify the `insertEntry` function by using eta "
"conversion, we can simplify the definition of `findEntry` by reasoning about "
"its arguments."
msgstr "イータ変換を使うと `insertEntry`関数を簡略化できたのと同じように、引数をよく考察すると `findEntry`の定義を簡略化することができます。"

#. type: Plain text
#: text/chapter3.md:685
msgid ""
"Note that the `book` argument is passed to the `filter filterEntry` "
"function, and the result of this application is passed to `head`. In other "
"words, `book` is passed to the _composition_ of the functions `filter "
"filterEntry` and `head`."
msgstr "引数 `book`が関数 `filter filterEntry`に渡され、この適用の結果が `head`に渡されることに注目してください。これは言いかたを変えれば、 `filter filterEntry`と `head`の**合成** (composition) に `book`が渡されるということです。"

#. type: Plain text
#: text/chapter3.md:687
#, no-wrap
msgid "In PureScript, the function composition operators are `<<<` and `>>>`. The first is \"backwards composition\", and the second is \"forwards composition\".\n"
msgstr "PureScriptの関数合成演算子は `<<<`と `>>>`です。前者は「逆方向の合成」であり、後者は「順方向の合成」です。\n"

#. type: Plain text
#: text/chapter3.md:689
msgid ""
"We can rewrite the right-hand side of `findEntry` using either operator. "
"Using backwards-composition, the right-hand side would be"
msgstr ""
"いずれかの演算子を使用して `findEntry`の右辺を書き換えることができます。逆順"
"の合成を使用すると、右辺は次のようになります。"

#. type: Fenced code block
#: text/chapter3.md:690
#, no-wrap
msgid "(head <<< filter filterEntry) book\n"
msgstr "(head <<< filter filterEntry) book\n"

#. type: Plain text
#: text/chapter3.md:695
msgid ""
"In this form, we can apply the eta conversion trick from earlier, to arrive "
"at the final form of `findEntry`:"
msgstr ""
"この形式なら最初の定義にイータ変換の技を適用することができ、 `findEntry`は最"
"終的に次のような形式に到達します。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:696
#, no-wrap
msgid ""
"{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_implementation}}\n"
"    ...\n"
msgstr ""
"{{#include ../exercises/chapter3/src/Data/AddressBook.purs:findEntry_implementation}}\n"
"    ...\n"

#. type: Plain text
#: text/chapter3.md:702
msgid "An equally valid right-hand side would be:"
msgstr "右辺を次のようにしても同じく妥当です。"

#. type: Fenced code block (haskell)
#: text/chapter3.md:703
#, no-wrap
msgid "filter filterEntry >>> head\n"
msgstr "filter filterEntry >>> head\n"

#. type: Plain text
#: text/chapter3.md:708
msgid ""
"Either way, this gives a clear definition of the `findEntry` function: "
"\"`findEntry` is the composition of a filtering function and the `head` "
"function\"."
msgstr ""
"どちらにしても、これは「 `findEntry`はフィルタリング関数と `head`関数の合成で"
"ある」という `findEntry`関数のわかりやすい定義を与えます。"

#. type: Plain text
#: text/chapter3.md:710
msgid ""
"I will let you make your own decision which definition is easier to "
"understand, but it is often useful to think of functions as building blocks "
"in this way - each function executing a single task, and solutions assembled "
"using function composition."
msgstr ""
"どちらの定義のほうがわかりやすいかの判断はお任せしますが、このように関数を部品として捉えると有用なことがよくあります。\n"
"関数はひとつの役目だけをこなし、機能を関数合成で組み立てるというように。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:718
msgid ""
"(Easy) Test your understanding of the `findEntry` function by writing down "
"the types of each of its major subexpressions. For example, the type of the "
"`head` function as used is specialized to `AddressBook -> Maybe Entry`. "
"_Note_: There is no test for this exercise."
msgstr ""
"（簡単） `findEntry`関数の定義の主な部分式の型を書き下し、 `findEntry`関数についてよく理解しているか試してみましょう。\n"
"たとえば、 `findEntry`の定義のなかにある `head`関数の型は `AddressBook -> Maybe Entry`と特殊化されています。\n"
"**補足**：この問題にはテストがありません。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:718
msgid ""
"(Medium) Write a function `findEntryByStreet :: String -> AddressBook -> "
"Maybe Entry` which looks up an `Entry` given a street address. _Hint_ "
"reusing the existing code in `findEntry`. Test your function in PSCi and by "
"running `spago test`."
msgstr ""
"（やや難しい）関数`findEntryByStreet :: String -> AddressBook -> Maybe Entry`を書いてください。\n"
"この関数は与えられた通りの住所から`Entry`を見付け出します。\n"
"**ヒント**：`findEntry`にある既存のコードを再利用してください。\n"
"実装した関数をPSCiと`spago test`を走らせることでテストしてください。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:718
msgid ""
"(Medium) Rewrite `findEntryByStreet` to replace `filterEntry` with the "
"composition (using `<<<` or `>>>`) of: a property accessor (using the `_.` "
"notation); and a function that tests whether its given string argument is "
"equal to the given street address."
msgstr ""
"（やや難しい）`filterEntry`を（`<<<`や`>>>`を使った）合成で置き換えて、`findEntryByStreet`を書き直してください。\n"
"合成の対象は、プロパティ取得子（`_.`記法を使います）と、与えられた文字列引数が与えられた通りの住所に等しいかを判定する関数です。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:718
msgid ""
"(Medium) Write a function `isInBook` which tests whether a name appears in a "
"`AddressBook`, returning a Boolean value. _Hint_: Use PSCi to find the type "
"of the `Data.List.null` function, which tests whether a list is empty or not."
msgstr ""
"（やや難しい） 指定された名前が `AddressBook`に存在するかどうかを調べて真偽値で返す関数`isInBook`を書いてみましょう。\n"
"**ヒント**：リストが空かどうかを調べる `Data.List.null`関数の型をPSCiで調べてみてみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter3.md:718
msgid ""
"(Difficult) Write a function `removeDuplicates` which removes \"duplicate\" "
"address book entries. We'll consider entries duplicated if they share the "
"same first and last names, while ignoring `address` fields. _Hint_: Use PSCi "
"to find the type of the `Data.List.nubByEq` function, which removes "
"duplicate elements from a list based on an equality predicate. Note that the "
"first element in each set of duplicates (closest to list head) is the one "
"that is kept."
msgstr ""
"（難しい） 「重複」している項目を住所録から削除する関数 `removeDuplicates`を書いてみましょう。\n"
"項目が同じ姓名を共有していれば`address`フィールドに関係なく、項目が重複していると考えます。\n"
"**ヒント**：関数 `Data.List.nubBy`の型を、PSCiを使用して調べてみましょう。\n"
"この関数は値同士の等価性を定義する述語関数に基づいてリストから重複要素を削除します。\n"
"なお、それぞれの重複する項目の集合における最初の要素（リストの先頭に最も近い）が保持する項目です。"

#. type: Plain text
#: text/chapter3.md:722
msgid ""
"In this chapter, we covered several new functional programming concepts:"
msgstr "この章では、関数型プログラミングの新しい概念をいくつか導入しました。"

#. type: Plain text
#: text/chapter3.md:730
msgid ""
"- How to use the interactive mode PSCi to experiment with functions and test "
"ideas.  - The role of types as both a correctness tool, and an "
"implementation tool.  - The use of curried functions to represent functions "
"of multiple arguments.  - Creating programs from smaller components by "
"composition.  - Structuring code neatly using `where` expressions.  - How to "
"avoid null values by using the `Maybe` type.  - Using techniques like eta "
"conversion and function composition to refactor code into a clear "
"specification."
msgstr ""
"- 対話的モードPSCiを使用して関数を調べるなど思いついたことを試す方法\n"
"- 検証や実装の道具としての型の役割\n"
"- 多引数関数を表現する、カリー化された関数の使用\n"
"- 関数合成で小さな部品を組み合わせてのプログラムの構築\n"
"- `where`節を利用したコードの構造化\n"
"- `Maybe`型を使用してnull値を回避する方法\n"
"- イータ変換や関数合成のような手法を利用した、よりわかりやすいコードへの再構成"

#. type: Plain text
#: text/chapter3.md:731
msgid "In the following chapters, we'll build on these ideas."
msgstr "次の章からは、これらの考えかたに基づいて進めていきます。"

#. type: Title #
#: text/chapter4.md:1
#, no-wrap
msgid "Recursion, Maps And Folds"
msgstr "再帰、マップ、畳み込み"

#. type: Plain text
#: text/chapter4.md:6
msgid ""
"In this chapter, we will look at how recursive functions can be used to "
"structure algorithms. Recursion is a basic technique used in functional "
"programming, which we will use throughout this book."
msgstr "この章では、アルゴリズムを構造化するときに再帰関数をどのように使うかについて見ていきましょう。再帰は関数型プログラミングの基本的な手法であり、この本の全体に亙って使われます。"

#. type: Plain text
#: text/chapter4.md:8
msgid ""
"We will also cover some standard functions from PureScript's standard "
"libraries. We will see the `map` and `fold` functions, as well as some "
"useful special cases, like `filter` and `concatMap`."
msgstr ""
"また、PureScriptの標準ライブラリから標準的な関数をいくつか取り扱います。\n"
"`map`や`fold`といった関数だけでなく、`filter`や`concatMap`といった特別な場合において便利なものについても見ていきます。"

#. type: Plain text
#: text/chapter4.md:10
msgid ""
"The motivating example for this chapter is a library of functions for "
"working with a virtual filesystem. We will apply the techniques learned in "
"this chapter to write functions which compute properties of the files "
"represented by a model of a filesystem."
msgstr ""
"この章では、仮想的なファイルシステムを操作する関数のライブラリを動機付けに用"
"います。この章で学ぶ手法を応用して、擬似的なファイルシステムによって表される"
"ファイルのプロパティを計算する関数を記述します。"

#. type: Plain text
#: text/chapter4.md:14
msgid ""
"The source code for this chapter is contained in `src/Data/Path.purs` and "
"`test/Examples.purs`. The `Data.Path` module contains a model of a virtual "
"filesystem. You do not need to modify the contents of this module. Implement "
"your solutions to the exercises in the `Test.MySolutions` module. Enable "
"accompanying tests in the `Test.Main` module as you complete each exercise "
"and check your work by running `spago test`."
msgstr ""
"この章のソースコードは`src/Data/Path.purs`と`test/Examples.purs`に含まれています。\n"
"`Data.Path`モジュールは仮想ファイルシステムのモデルを含みます。\n"
"このモジュールの内容を変更する必要はありません。\n"
"演習への解答は`Test.MySolutions`モジュールに実装してください。\n"
"それぞれの演習を完了させつつ都度`Test.Main`モジュールにある対応するテストを有効にし、\n"
"`spago test`を走らせることで解答を確認してください。"

#. type: Plain text
#: text/chapter4.md:16 text/chapter6.md:18
msgid "The project has the following dependencies:"
msgstr "このプロジェクトには以下の依存関係があります。"

#. type: Plain text
#: text/chapter4.md:22
msgid ""
"- `maybe`, which defines the `Maybe` type constructor - `arrays`, which "
"defines functions for working with arrays - `strings`, which defines "
"functions for working with JavaScript strings - `foldable-traversable`, "
"which defines functions for folding arrays and other data structures - "
"`console`, which defines functions for printing to the console"
msgstr ""
"- `maybe`: `Maybe`型構築子が定義されています。\n"
"- `arrays`: 配列を扱うための関数が定義されています。\n"
"- `strings`: JavaScriptの文字列を扱うための関数が定義されています。\n"
"- `foldable-traversable`: 配列やその他のデータ構造を畳み込む関数が定義されています。\n"
"- `console`: コンソールへの出力を扱うための関数が定義されています。"

#. type: Plain text
#: text/chapter4.md:26
msgid ""
"Recursion is an important technique in programming in general, but "
"particularly common in pure functional programming, because, as we will see "
"in this chapter, recursion helps to reduce the mutable state in our programs."
msgstr ""
"再帰は一般のプログラミングでも重要な手法ですが、特に純粋関数型プログラミング"
"では当たり前のように用いられます。この章で見ていくように、再帰はプログラムの"
"変更可能な状態を減らすために役立つからです。"

#. type: Plain text
#: text/chapter4.md:28
msgid ""
"Recursion is closely linked to the _divide and conquer_ strategy: to solve a "
"problem on certain inputs, we can break down the inputs into smaller parts, "
"solve the problem on those parts, and then assemble a solution from the "
"partial solutions."
msgstr ""
"再帰は**分割統治** (divide and conquer) 戦略と密接な関係があります。\n"
"分割統治とはすなわち、何らかの入力としての問題を解くにあたり、入力を小さな部分に分割し、それぞれの部分について問題を解いて、部分ごとの答えから最終的な答えを組み立てるということです。"

#. type: Plain text
#: text/chapter4.md:30
msgid "Let's see some simple examples of recursion in PureScript."
msgstr "それでは、PureScriptにおける再帰の簡単な例をいくつか見てみましょう。"

#. type: Plain text
#: text/chapter4.md:32
msgid "Here is the usual _factorial function_ example:"
msgstr "次は**階乗関数** (factorial function) のよくある例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:33
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorial}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorial}}\n"

#. type: Plain text
#: text/chapter4.md:38
msgid ""
"Here, we can see how the factorial function is computed by reducing the "
"problem to a subproblem - that of computing the factorial of a smaller "
"integer. When we reach zero, the answer is immediate."
msgstr ""
"部分問題へ問題を分割することによって階乗関数がどのように計算されるかがわかり"
"ます。より小さい数へと階乗を計算していくということです。ゼロに到達すると、答"
"えは直ちに求まります。"

#. type: Plain text
#: text/chapter4.md:40
msgid ""
"Here is another common example, which computes the _Fibonacci function_:"
msgstr "次は、**フィボナッチ関数** (Fibonacci function) を計算するという、これまたよくある例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:41
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:fib}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:fib}}\n"

#. type: Plain text
#: text/chapter4.md:46
msgid ""
"Again, this problem is solved by considering the solutions to subproblems. "
"In this case, there are two subproblems, corresponding to the expressions "
"`fib (n - 1)` and `fib (n - 2)`. When these two subproblems are solved, we "
"assemble the result by adding the partial results."
msgstr ""
"やはり、部分問題の解決策を考えることで全体を解決していることがわかります。こ"
"のとき、`fib (n - 1)`と`fib (n - 2)`という式に対応した、２つの部分問題があり"
"ます。これらの２つの部分問題が解決されていれば、この部分的な答えを加算するこ"
"とで、全体の答えを組み立てることができます。"

#. type: Plain text
#: text/chapter4.md:48
msgid ""
"Note that, while the above examples of `factorial` and `fib` work as "
"intended, a more idiomatic implementation would use pattern matching instead "
"of `if`/`then`/`else`. Pattern matching techniques are discussed in a later "
"chapter."
msgstr ""
"なお上の`factorial`と`fib`の例は意図通りに動きますが、\n"
"より慣習的な実装では`if`や`then`や`else`を使う代わりにパターン照合を使うものでしょう。\n"
"パターン照合の技法は後の章でお話しします。"

#. type: Title ##
#: text/chapter4.md:49
#, no-wrap
msgid "Recursion on Arrays"
msgstr "配列上での再帰"

#. type: Plain text
#: text/chapter4.md:52
msgid ""
"We are not limited to defining recursive functions over the `Int` type! We "
"will see recursive functions defined over a wide array of data types when we "
"cover _pattern matching_ later in the book, but for now, we will restrict "
"ourselves to numbers and arrays."
msgstr ""
"再帰関数の定義は、`Int`型だけに限定されるものではありません！\n"
"本書の後半で**パターン照合** (pattern matching) を扱うときに、いろいろなデータ型の上での再帰関数について見ていきますが、ここでは数と配列に限っておきます。"

#. type: Plain text
#: text/chapter4.md:54
msgid ""
"Just as we branch based on whether the input is non-zero, in the array case, "
"we will branch based on whether the input is non-empty. Consider this "
"function, which computes the length of an array using recursion:"
msgstr ""
"入力がゼロでないかどうかについて分岐するのと同じように、配列の場合も、配列が"
"空でないかどうかについて分岐していきます。再帰を使用して配列の長さを計算する"
"次の関数を考えてみます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:55
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Data.Array (null, tail)\n"
"import Data.Maybe (fromMaybe)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:length}}\n"
msgstr ""
"import Prelude\n"
"\n"
"import Data.Array (null, tail)\n"
"import Data.Maybe (fromMaybe)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:length}}\n"

#. type: Plain text
#: text/chapter4.md:65
msgid ""
"In this function, we use an `if .. then .. else` expression to branch based "
"on the emptiness of the array. The `null` function returns `true` on an "
"empty array. Empty arrays have length zero, and a non-empty array has a "
"length that is one more than the length of its tail."
msgstr ""
"この関数では配列が空かどうかで分岐するために`if ... then ... else`式を使っています。\n"
"この`null`関数は配列が空のときに`true`を返します。\n"
"空の配列の長さはゼロであり、空でない配列の長さは配列の先頭を取り除いた残りの部分の長さより1大きいというわけです。"

#. type: Plain text
#: text/chapter4.md:67
msgid ""
"The `tail` function returns a `Maybe` wrapping the given array without its "
"first element. If the array is empty (i.e. it doesn't have a tail) `Nothing` "
"is returned. The `fromMaybe` function takes a default value and a `Maybe` "
"value. If the latter is `Nothing` it returns the default, in the other case "
"it returns the value wrapped by `Just`."
msgstr ""
"`tail`関数は与えられた配列から最初の要素を除いたものを`Maybe`に包んで返します。\n"
"配列が空であれば（つまり尾鰭がありません）`Nothing`が返ります。\n"
"`fromMaybe`関数は既定値と`Maybe`値を取ります。\n"
"後者が`Nothing`であれば既定義を返し、そうでなければ`Just`に包まれた値を返します。"

#. type: Plain text
#: text/chapter4.md:69
msgid ""
"This example is obviously a very impractical way to find the length of an "
"array in JavaScript, but should provide enough help to allow you to complete "
"the following exercises:"
msgstr ""
"JavaScriptで配列の長さを調べるのには、この例はどうみても実用的な方法とはいえ"
"ませんが、次の演習を完了するための手がかりとしては充分でしょう。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:74
msgid ""
"(Easy) Write a recursive function `isEven` which returns `true` if and only "
"if its input is an even integer."
msgstr "（簡単）入力が偶数であるとき、かつそのときに限り`true`に返すような再帰関数を書いてみましょう。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:74
msgid ""
"(Medium) Write a recursive function `countEven` which counts the number of "
"even integers in an array. _Hint_: the function `head` (also available in "
"`Data.Array`) can be used to find the first element in a non-empty array."
msgstr ""
"（少し難しい）配列内の偶数の数を数える再帰関数`countEven`を書いてみましょう。\n"
"**ヒント**：`Data.Array`モジュールの`head`関数を使うと、空でない配列の最初の要素を見つけることができます。"

#. type: Title ##
#: text/chapter4.md:75
#, no-wrap
msgid "Maps"
msgstr "マップ"

#. type: Plain text
#: text/chapter4.md:78
msgid ""
"The `map` function is an example of a recursive function on arrays. It is "
"used to transform the elements of an array by applying a function to each "
"element in turn. Therefore, it changes the _contents_ of the array, but "
"preserves its _shape_ (i.e. its length)."
msgstr ""
"`map`関数は配列に対する再帰関数のひとつです。\n"
"この関数を使うと、配列の各要素に順番に関数を適用することで、配列の要素を変換することができます。\n"
"そのため、配列の**内容**は変更されますが、その**形状**（ここでは「長さ」）は保存されます。"

#. type: Plain text
#: text/chapter4.md:80
msgid ""
"When we cover _type classes_ later in the book we will see that the `map` "
"function is an example of a more general pattern of shape-preserving "
"functions which transform a class of type constructors called _functors_."
msgstr ""
"本書の後半で**型クラス** (type class) の内容を押さえるとき、\n"
"`map`関数が形状保存関数のより一般的な様式の一例であることを見ていきます。\n"
"これは**関手** (functor) と呼ばれる型構築子のクラスを変換するものです。"

#. type: Plain text
#: text/chapter4.md:82
msgid "Let's try out the `map` function in PSCi:"
msgstr "それでは、PSCiで`map`関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:83
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> map (\\n -> n + 1) [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Prelude\n"
"> map (\\n -> n + 1) [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:92
msgid ""
"Notice how `map` is used - we provide a function which should be \"mapped "
"over\" the array in the first argument, and the array itself in its second."
msgstr ""
"`map`がどのように使われているかに注目してください。\n"
"最初の引数には配列上で「写す」関数、第2引数には配列そのものを渡します。"

#. type: Title ##
#: text/chapter4.md:93
#, no-wrap
msgid "Infix Operators"
msgstr "中置演算子"

#. type: Plain text
#: text/chapter4.md:96
msgid ""
"The `map` function can also be written between the mapping function and the "
"array, by wrapping the function name in backticks:"
msgstr "バッククォートで関数名を囲むと、写す関数と配列の間に、`map`関数を書くことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:97
#, no-wrap
msgid ""
"> (\\n -> n + 1) `map` [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"> (\\n -> n + 1) `map` [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:103
msgid ""
"This syntax is called _infix function application_, and any function can be "
"made infix in this way. It is usually most appropriate for functions with "
"two arguments."
msgstr ""
"この構文は**中置関数適用**と呼ばれ、どんな関数でもこのように中置することができます。\n"
"普通は2引数の関数に対して使うのが最適でしょう。"

#. type: Plain text
#: text/chapter4.md:105
#, no-wrap
msgid "There is an operator which is equivalent to the `map` function when used with arrays, called `<$>`. This operator can be used infix like any other binary operator:\n"
msgstr "配列を扱うときは、`map`関数と等価な`<$>`という演算子が存在します。この演算子は他の二項演算子と同じように中置で使用することができます。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:106
#, no-wrap
msgid ""
"> (\\n -> n + 1) <$> [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"
msgstr ""
"> (\\n -> n + 1) <$> [1, 2, 3, 4, 5]\n"
"[2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:112
msgid "Let's look at the type of `map`:"
msgstr "それでは`map`の型を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:113
#, no-wrap
msgid ""
"> :type map\n"
"forall a b f. Functor f => (a -> b) -> f a -> f b\n"
msgstr ""
"> :type map\n"
"forall a b f. Functor f => (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter4.md:119
msgid ""
"The type of `map` is actually more general than we need in this chapter. For "
"our purposes, we can treat `map` as if it had the following less general "
"type:"
msgstr ""
"実は`map`の型は、この章で必要とされているものよりも一般的な型になっています。"
"今回の目的では、`map`は次のようなもっと具体的な型であるかのように考えるとよい"
"でしょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:120
#, no-wrap
msgid "forall a b. (a -> b) -> Array a -> Array b\n"
msgstr "forall a b. (a -> b) -> Array a -> Array b\n"

#. type: Plain text
#: text/chapter4.md:125
#, no-wrap
msgid "This type says that we can choose any two types, `a` and `b`, with which to apply the `map` function. `a` is the type of elements in the source array, and `b` is the type of elements in the target array. In particular, there is no reason why `map` has to preserve the type of the array elements. We can use `map` or `<$>` to transform integers to strings, for example:\n"
msgstr ""
"この型では、`map`関数に適用するときには`a`と`b`という２つの型を自由に選ぶことができる、ということも示されています。\n"
"`a`は元の配列の要素の型で、`b`は目的の配列の要素の型です。\n"
"もっと言えば、`map`が配列の要素の型を保存する必要があるわけではありません。\n"
"たとえば、`map`を使用すると数値を文字列に変換することができます。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:126
#, no-wrap
msgid ""
"> show <$> [1, 2, 3, 4, 5]\n"
"\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> show <$> [1, 2, 3, 4, 5]\n"
"\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:133
#, no-wrap
msgid "Even though the infix operator `<$>` looks like special syntax, it is in fact just an alias for a regular PureScript function. The function is simply _applied_ using infix syntax. In fact, the function can be used like a regular function by enclosing its name in parentheses. This means that we can used the parenthesized name `(<$>)` in place of `map` on arrays:\n"
msgstr ""
"中置演算子`<$>`は特別な構文のように見えるかもしれませんが、実はPureScriptの普通の関数の別称です。\n"
"中置構文を使用した単なる**適用**にすぎません。\n"
"実際、括弧でその名前を囲むと、この関数を通常の関数のように使用することができます。\n"
"これは、`map`代わりに、括弧で囲まれた`(<$>)`という名前を使って配列に関数を適用できるということです。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:134
#, no-wrap
msgid ""
"> (<$>) show [1, 2, 3, 4, 5]\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> (<$>) show [1, 2, 3, 4, 5]\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:140
msgid ""
"Infix function names are defined as _aliases_ for existing function names. "
"For example, the `Data.Array` module defines an infix operator `(..)` as a "
"synonym for the `range` function, as follows:"
msgstr ""
"中置関数は既存の関数名の別称として定義されます。\n"
"たとえば、`Data.Array`モジュールでは次のように`range`関数の同義語として中置演算子`(..)`を定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:141
#, no-wrap
msgid "infix 8 range as ..\n"
msgstr "infix 8 range as ..\n"

#. type: Plain text
#: text/chapter4.md:146
msgid "We can use this operator as follows:"
msgstr "この演算子は次のように使うことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:147
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> 1 .. 5\n"
"[1, 2, 3, 4, 5]\n"
"\n"
"> show <$> (1 .. 5)\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> 1 .. 5\n"
"[1, 2, 3, 4, 5]\n"
"\n"
"> show <$> (1 .. 5)\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:158
msgid ""
"_Note_: Infix operators can be a great tool for defining domain-specific "
"languages with a natural syntax. However, used excessively, they can render "
"code unreadable to beginners, so it is wise to exercise caution when "
"defining any new operators."
msgstr ""
"**注意**： 独自の中置演算子は、自然な構文を持った領域特化言語を定義するのに優れた手段になりえます。\n"
"ただし、乱用すると初心者が読めないコードになることがありますから、新たな演算子の定義には慎重になるのが賢明です。"

#. type: Plain text
#: text/chapter4.md:160
#, no-wrap
msgid "In the example above, we parenthesized the expression `1 .. 5`, but this was actually not necessary, because the `Data.Array` module assigns a higher precedence level to the `..` operator than that assigned to the `<$>` operator. In the example above, the precedence of the `..` operator was defined as `8`, the number after the `infix` keyword. This is higher than the precedence level of `<$>`, meaning that we do not need to add parentheses:\n"
msgstr ""
"上記の例では、`1 .. 5`という式は括弧で囲まれていましたが、実際にはこれは必要ありません。\n"
"なぜなら、`Data.Array`モジュールは、`<$>`に割り当てられた優先順位より高い優先順位を`..`演算子に割り当てているからです。\n"
"上の例では、`..`の優先順位は、予約語`infix`のあとに書かれた数の`8` と定義されていました。\n"
"ここでは`<$>`の優先順位よりも高い優先順位を`..`に割り当てており、このため括弧を付け加える必要がないということです。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:161
#, no-wrap
msgid ""
"> show <$> 1 .. 5\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"
msgstr ""
"> show <$> 1 .. 5\n"
"[\"1\",\"2\",\"3\",\"4\",\"5\"]\n"

#. type: Plain text
#: text/chapter4.md:167
msgid ""
"If we wanted to assign an _associativity_ (left or right) to an infix "
"operator, we could do so with the `infixl` and `infixr` keywords instead.  "
"Using `infix` assigns no associativity, meaning that you must parenthesize "
"any expression using the same operator multiple times or using multiple "
"operators of the same precedence."
msgstr ""
"中置演算子に（左または右の）**結合性**を与えたい場合は、代わりに予約語`infixl`と`infixr`を使います。\n"
"`infix`を使うと何ら結合性は割り当てられず、\n"
"同じ演算子を複数回使ったり複数の同じ優先度の演算子を使ったりするときに、式を括弧で囲まなければいけなくなります。"

#. type: Title ##
#: text/chapter4.md:168
#, no-wrap
msgid "Filtering Arrays"
msgstr "配列のフィルタリング"

#. type: Plain text
#: text/chapter4.md:171
msgid ""
"The `Data.Array` module provides another function `filter`, which is "
"commonly used together with `map`. It provides the ability to create a new "
"array from an existing array, keeping only those elements which match a "
"predicate function."
msgstr ""
"`Data.Array`モジュールでは他にも、よく`map`と一緒に使われる関数`filter`も提供しています。\n"
"この関数は、述語関数に適合する要素のみを残し、既存の配列から新しい配列を作成する機能を提供します。"

#. type: Plain text
#: text/chapter4.md:173
msgid ""
"For example, suppose we wanted to compute an array of all numbers between 1 "
"and 10 which were even. We could do so as follows:"
msgstr ""
"たとえば、1から10までの数で、偶数であるような数の配列を計算したいとします。こ"
"れは次のように行うことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:174
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> filter (\\n -> n `mod` 2 == 0) (1 .. 10)\n"
"[2,4,6,8,10]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> filter (\\n -> n `mod` 2 == 0) (1 .. 10)\n"
"[2,4,6,8,10]\n"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid ""
"(Easy) Write a function `squared` which calculates the squares of an array "
"of numbers. _Hint_: Use the `map` or `<$>` function."
msgstr ""
"（簡単）`map`関数や`<$>`関数を使用して、 配列に格納された数のそれぞれの平方を計算する関数`squared`を書いてみましょう。\n"
"**ヒント**：`map`や`<$>`といった関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid ""
"(Easy) Write a function `keepNonNegative` which removes the negative numbers "
"from an array of numbers. _Hint_: Use the `filter` function."
msgstr ""
"（簡単）`filter`関数を使用して、数の配列から負の数を取り除く関数`keepNonNegative`を書いてみましょう。\n"
"**ヒント**：`filter`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:189
msgid "(Medium)"
msgstr "（やや難しい）"

#. type: Bullet: '    * '
#: text/chapter4.md:189
msgid ""
"Define an infix synonym `<$?>` for `filter`. _Note_: Infix synonyms may not "
"be defined in the REPL, but you can define it in a file."
msgstr ""
"`filter`の中置同義語`<$?>`を定義してください。\n"
"**補足**：中置同義語はREPLでは定義できないかもしれませんが、ファイルでは定義することができます。"

#. type: Bullet: '    * '
#: text/chapter4.md:189
msgid ""
"Write a `keepNonNegativeRewrite` function, which is the same as "
"`keepNonNegative`, but replaces `filter` with your new infix operator `<$?>`."
msgstr ""
"関数`keepNonNegativeRewrite`を書いてください。\n"
"この関数は`filter`を自前の粗しい中置演算子`<$?>`で置き換えたところ以外は`keepNonNegative`と同じです。"

#. type: Bullet: '    * '
#: text/chapter4.md:189
msgid ""
"Experiment with the precedence level and associativity of your operator in "
"PSCi. _Note_: There are no unit tests for this step."
msgstr ""
"PSCiで自前の演算子の優先度合いと結合性を試してください。\n"
"**補足**：この問題のための単体試験はありません。"

#. type: Title ##
#: text/chapter4.md:190
#, no-wrap
msgid "Flattening Arrays"
msgstr "配列の平坦化"

#. type: Plain text
#: text/chapter4.md:193
msgid ""
"Another standard function on arrays is the `concat` function, defined in "
"`Data.Array`. `concat` flattens an array of arrays into a single array:"
msgstr ""
"配列に関する標準的な関数として`Data.Array`で定義されているものには、`concat`"
"関数もあります。`concat`は配列の配列をひとつの配列へと平坦化します。"

#. type: Fenced code block (text)
#: text/chapter4.md:194
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> :type concat\n"
"forall a. Array (Array a) -> Array a\n"
"\n"
"> concat [[1, 2, 3], [4, 5], [6]]\n"
"[1, 2, 3, 4, 5, 6]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> :type concat\n"
"forall a. Array (Array a) -> Array a\n"
"\n"
"> concat [[1, 2, 3], [4, 5], [6]]\n"
"[1, 2, 3, 4, 5, 6]\n"

#. type: Plain text
#: text/chapter4.md:205
msgid ""
"There is a related function called `concatMap` which is like a combination "
"of the `concat` and `map` functions. Where `map` takes a function from "
"values to values (possibly of a different type), `concatMap` takes a "
"function from values to arrays of values."
msgstr ""
"関連する関数として、`concat`と`map`を組み合わせたような`concatMap`と呼ばれる関数もあります。\n"
"`map`は（相異なる型も可能な）値からの値への関数を引数に取りますが、それに対して`concatMap`は値から値の配列の関数を取ります。"

#. type: Plain text
#: text/chapter4.md:207
msgid "Let's see it in action:"
msgstr "実際に動かして見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:208
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> :type concatMap\n"
"forall a b. (a -> Array b) -> Array a -> Array b\n"
"\n"
"> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
"[1,1,2,4,3,9,4,16,5,25]\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> :type concatMap\n"
"forall a b. (a -> Array b) -> Array a -> Array b\n"
"\n"
"> concatMap (\\n -> [n, n * n]) (1 .. 5)\n"
"[1,1,2,4,3,9,4,16,5,25]\n"

#. type: Plain text
#: text/chapter4.md:219
#, no-wrap
msgid "Here, we call `concatMap` with the function `\\n -> [n, n * n]` which sends an integer to the array of two elements consisting of that integer and its square. The result is an array of ten integers: the integers from 1 to 5 along with their squares.\n"
msgstr ""
"ここでは、数をその数とその数の平方の2つの要素からなる配列に写す関数`\\n -> [n, n * n]`を引数に`concatMap`を呼び出しています。\n"
"結果は10個の整数の配列です。\n"
"配列は1から5の数とそのそれぞれの数の平方からなります。\n"

#. type: Plain text
#: text/chapter4.md:221
msgid ""
"Note how `concatMap` concatenates its results. It calls the provided "
"function once for each element of the original array, generating an array "
"for each. Finally, it collapses all of those arrays into a single array, "
"which is its result."
msgstr ""
"`concatMap`がどのように結果を連結しているのかに注目してください。\n"
"渡された関数を元の配列のそれぞれの要素について一度づつ呼び出し、その関数はそれぞれ配列を生成します。\n"
"最後にそれらの配列を単一の配列に押し潰し、それが結果となります。"

#. type: Plain text
#: text/chapter4.md:223
msgid ""
"`map`, `filter` and `concatMap` form the basis for a whole range of "
"functions over arrays called \"array comprehensions\"."
msgstr "`map`と`filter`、`concatMap`は、「配列内包表記」(array comprehensions) と呼ばれる、配列に関するあらゆる関数の基盤を形成しています。"

#. type: Title ##
#: text/chapter4.md:224
#, no-wrap
msgid "Array Comprehensions"
msgstr "配列内包表記"

#. type: Plain text
#: text/chapter4.md:227
msgid ""
"Suppose we wanted to find the factors of a number `n`. One simple way to do "
"this would be by brute force: we could generate all pairs of numbers between "
"1 and `n`, and try multiplying them together. If the product was `n`, we "
"would have found a pair of factors of `n`."
msgstr ""
"数`n`のふたつの因数を見つけたいとしましょう。これを行うための簡単​​な方法として"
"は、総当りで調べる方法があります。つまり、`1`から`n`の数のすべての組み合わせ"
"を生成し、それを乗算してみるわけです。もしその積が`n`なら、`n`の因数の組み合"
"わせを見つけたということになります。"

#. type: Plain text
#: text/chapter4.md:229
msgid ""
"We can perform this computation using an array comprehension. We will do so "
"in steps, using PSCi as our interactive development environment."
msgstr ""
"配列内包表記を使用すると、この計算を実行することができます。\n"
"PSCiを対話式の開発環境として使用し、ひとつづつこの手順を進めていきましょう。"

#. type: Plain text
#: text/chapter4.md:231
msgid ""
"The first step is to generate an array of pairs of numbers below `n`, which "
"we can do using `concatMap`."
msgstr "最初の手順では`n`以下の数の組み合わせの配列を生成しますが、これには`concatMap`を使えばよいです。"

#. type: Plain text
#: text/chapter4.md:233
msgid "Let's start by mapping each number to the array `1 .. n`:"
msgstr "`1 .. n`のそれぞれの数を配列`1 .. n`へとマッピングすることから始めましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:234
#, no-wrap
msgid "> pairs n = concatMap (\\i -> 1 .. n) (1 .. n)\n"
msgstr "> pairs n = concatMap (\\i -> 1 .. n) (1 .. n)\n"

#. type: Plain text
#: text/chapter4.md:239
msgid "We can test our function"
msgstr "この関数をテストしてみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:240
#, no-wrap
msgid ""
"> pairs 3\n"
"[1,2,3,1,2,3,1,2,3]\n"
msgstr ""
"> pairs 3\n"
"[1,2,3,1,2,3,1,2,3]\n"

#. type: Plain text
#: text/chapter4.md:246
msgid ""
"This is not quite what we want. Instead of just returning the second element "
"of each pair, we need to map a function over the inner copy of `1 .. n` "
"which will allow us to keep the entire pair:"
msgstr ""
"これは求めているものとはぜんぜん違います。\n"
"単にそれぞれの組み合わせの2つ目の要素を返すのではなく、ペア全体を保持することができるように、内側の`1 .. n`の複製について関数をマッピングする必要があります。"

#. type: Fenced code block (text)
#: text/chapter4.md:247
#, no-wrap
msgid ""
"> :paste\n"
"â¦ pairs' n =\n"
"â¦   concatMap (\\i ->\n"
"â¦     map (\\j -> [i, j]) (1 .. n)\n"
"â¦   ) (1 .. n)\n"
"â¦ ^D\n"
"\n"
"> pairs' 3\n"
"[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\n"
msgstr ""
"> :paste\n"
"… pairs' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (1 .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"\n"
"> pairs' 3\n"
"[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]\n"

#. type: Plain text
#: text/chapter4.md:260
msgid ""
"This is looking better. However, we are generating too many pairs: we keep "
"both [1, 2] and [2, 1] for example. We can exclude the second case by making "
"sure that `j` only ranges from `i` to `n`:"
msgstr ""
"いい感じになってきました。しかし、`[1, 2]`と`[2, 1]`の両方があるように、重複"
"した組み合わせが生成されています。`j`を`i`から`n`の範囲に限定することで、２つ"
"目の場合を取り除くことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:261
#, no-wrap
msgid ""
"> :paste\n"
"â¦ pairs'' n =\n"
"â¦   concatMap (\\i ->\n"
"â¦     map (\\j -> [i, j]) (i .. n)\n"
"â¦   ) (1 .. n)\n"
"â¦ ^D\n"
"> pairs'' 3\n"
"[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n"
msgstr ""
":paste\n"
"… pairs'' n =\n"
"…   concatMap (\\i ->\n"
"…     map (\\j -> [i, j]) (i .. n)\n"
"…   ) (1 .. n)\n"
"… ^D\n"
"pairs'' 3\n"
"[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n"

#. type: Plain text
#: text/chapter4.md:273
msgid ""
"Great! Now that we have all of the pairs of potential factors, we can use "
"`filter` to choose the pairs which multiply to give `n`:"
msgstr ""
"すばらしいです！因数の候補のすべての組み合わせを手に入れたので、`filter`を使"
"えば、その積が`n`であるような組み合わせを選び出すことができます。"

#. type: Fenced code block (text)
#: text/chapter4.md:274
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> factors n = filter (\\pair -> product pair == n) (pairs'' n)\n"
"\n"
"> factors 10\n"
"[[1,10],[2,5]]\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> factors n = filter (\\pair -> product pair == n) (pairs'' n)\n"
"\n"
"> factors 10\n"
"[[1,10],[2,5]]\n"

#. type: Plain text
#: text/chapter4.md:284
msgid ""
"This code uses the `product` function from the `Data.Foldable` module in the "
"`foldable-traversable` library."
msgstr "このコードでは、`foldable-traversable`ライブラリの`Data.Foldable`モジュールにある`product`関数を使っています。"

#. type: Plain text
#: text/chapter4.md:286
msgid ""
"Excellent! We've managed to find the correct set of factor pairs without "
"duplicates."
msgstr "うまくいきました！因数の組み合わせの正しい集合を重複なく見つけることができました。"

#. type: Title ##
#: text/chapter4.md:287
#, no-wrap
msgid "Do Notation"
msgstr "do記法"

#. type: Plain text
#: text/chapter4.md:290
msgid ""
"However, we can improve the readability of our code considerably. `map` and "
"`concatMap` are so fundamental, that they (or rather, their generalizations "
"`map` and `bind`) form the basis of a special syntax called _do notation_."
msgstr ""
"しかし、このコードの可読性は大幅に向上することができます。\n"
"`map`や`concatMap`は基本的な関数であり、**do記法** (do notation) と呼ばれる特別な構文の基礎になっています。\n"
"（もっと厳密にいえば、それらの一般化である`map`と`bind`が基礎をなしています。）"

#. type: Plain text
#: text/chapter4.md:292
msgid ""
"_Note_: Just like `map` and `concatMap` allowed us to write _array "
"comprehensions_, the more general operators `map` and `bind` allow us to "
"write so-called _monad comprehensions_. We'll see plenty more examples of "
"_monads_ later in the book, but in this chapter, we will only consider "
"arrays."
msgstr ""
"**注意**：`map`と`concatMap`が**配列内包表記**を書けるようにしているように、もっと一般的な演算子である`map`と`bind`は**モナド内包表記** (monad comprehensions) と呼ばれているものを書けるようにします。\n"
"本書の後半では**モナド** (monad) の例をたっぷり見ていくことになりますが、\n"
"この章では配列のみを考えます。"

#. type: Plain text
#: text/chapter4.md:294
msgid "We can rewrite our `factors` function using do notation as follows:"
msgstr ""
"do記法を使うと、先ほどの`factors`関数を次のように書き直すことができます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:295
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factors}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factors}}\n"

#. type: Plain text
#: text/chapter4.md:300
msgid ""
"The keyword `do` introduces a block of code which uses do notation. The "
"block consists of expressions of a few types:"
msgstr "キーワード`do`はdo記法を使うコードのブロックを導入します。このブロックは幾つかの種類の式で構成されています。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid ""
"Expressions which bind elements of an array to a name. These are indicated "
"with the backwards-facing arrow `<-`, with a name on the left, and an "
"expression on the right whose type is an array."
msgstr ""
"配列の要素を名前に束縛する式。これは後ろ向きの矢印`<-`で 示されていて、その左"
"側は名前、右側は配列の型を持つ式です。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid ""
"Expressions which do not bind elements of the array to names. The `do` "
"*result* is an example of this kind of expression and is illustrated in the "
"last line, `pure [i, j]`."
msgstr ""
"名前に配列の要素を束縛しない式。\n"
"最後の行の`pure [i, j]`が、この種類の式の一例です。"

#. type: Bullet: '- '
#: text/chapter4.md:304
msgid "Expressions which give names to expressions, using the `let` keyword."
msgstr "`let`キーワードを使用し、式に名前を与える式。"

#. type: Plain text
#: text/chapter4.md:306
#, no-wrap
msgid "This new notation hopefully makes the structure of the algorithm clearer. If you mentally replace the arrow `<-` with the word \"choose\", you might read it as follows: \"choose an element `i` between 1 and n, then choose an element `j` between `i` and `n`, and return `[i, j]`\".\n"
msgstr ""
"この新しい記法を使うと、アルゴリズムの構造がわかりやすくなることがあります。\n"
"心のなかで`<-`を「選ぶ」という単語に置き換えるとすると、「1からnの間の要素`i`を選び、それからiからnの間の要素`j`を選び、`[i, j]`を返す」というように読むことができるでしょう。\n"

#. type: Plain text
#: text/chapter4.md:308
msgid ""
"In the last line, we use the `pure` function. This function can be evaluated "
"in PSCi, but we have to provide a type:"
msgstr ""
"最後の行では、`pure`関数を使っています。\n"
"この関数はPSCiで評価することができますが、型を明示する必要があります。"

#. type: Fenced code block (text)
#: text/chapter4.md:309
#, no-wrap
msgid ""
"> pure [1, 2] :: Array (Array Int)\n"
"[[1, 2]]\n"
msgstr ""
"> pure [1, 2] :: Array (Array Int)\n"
"[[1, 2]]\n"

#. type: Plain text
#: text/chapter4.md:315
msgid ""
"In the case of arrays, `pure` simply constructs a singleton array. In fact, "
"we could modify our `factors` function to use this form, instead of using "
"`pure`:"
msgstr ""
"配列の場合、`pure`は単に1要素の配列を作成します。\n"
"実際に、`factors`関数を変更して、`pure`の代わりにこの形式を使うようにすることもできます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:316
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorsV2}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorsV2}}\n"

#. type: Plain text
#: text/chapter4.md:321
msgid "and the result would be the same."
msgstr "そして、結果は同じになります。"

#. type: Title ##
#: text/chapter4.md:322 text/chapter5.md:77
#, no-wrap
msgid "Guards"
msgstr "ガード"

#. type: Plain text
#: text/chapter4.md:325
msgid ""
"One further change we can make to the `factors` function is to move the "
"filter inside the array comprehension. This is possible using the `guard` "
"function from the `Control.Alternative` module (from the `control` package):"
msgstr ""
"`factors`関数を更に改良する方法としては、このフィルタを配列内包表記の内側に移動するというものがあります。\n"
"これは`control`ライブラリにある`Control.Alternative`モジュールの`guard`関数を使用することで可能になります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:326
#, no-wrap
msgid ""
"import Control.Alternative (guard)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:factorsV3}}\n"
msgstr ""
"import Control.Alternative (guard)\n"
"\n"
"{{#include ../exercises/chapter4/test/Examples.purs:factorsV3}}\n"

#. type: Plain text
#: text/chapter4.md:333
msgid ""
"Just like `pure`, we can apply the `guard` function in PSCi to understand "
"how it works. The type of the `guard` function is more general than we need "
"here:"
msgstr ""
"`pure`と同じように、どのように動作するかを理解するために、PSCiで`guard`関数を適用して調べてみましょう。\n"
"`guard`関数の型は、ここで必要とされるものよりもっと一般的な型になっています。"

#. type: Fenced code block (text)
#: text/chapter4.md:334
#, no-wrap
msgid ""
"> import Control.Alternative\n"
"\n"
"> :type guard\n"
"forall m. Alternative m => Boolean -> m Unit\n"
msgstr ""
"> import Control.Alternative\n"
"\n"
"> :type guard\n"
"forall m. Alternative m => Boolean -> m Unit\n"

#. type: Plain text
#: text/chapter4.md:342
msgid "In our case, we can assume that PSCi reported the following type:"
msgstr "今回の場合は、PSCiは次の型を報告するものと考えてください。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:343
#, no-wrap
msgid "Boolean -> Array Unit\n"
msgstr "Boolean -> Array Unit\n"

#. type: Plain text
#: text/chapter4.md:348
msgid ""
"For our purposes, the following calculations tell us everything we need to "
"know about the `guard` function on arrays:"
msgstr "目的からすると、次の計算の結果から配列における`guard`関数について今知りたいことはすべてわかります。"

#. type: Fenced code block (text)
#: text/chapter4.md:349
#, no-wrap
msgid ""
"> import Data.Array\n"
"\n"
"> length $ guard true\n"
"1\n"
"\n"
"> length $ guard false\n"
"0\n"
msgstr ""
"> import Data.Array\n"
"\n"
"> length $ guard true\n"
"1\n"
"\n"
"> length $ guard false\n"
"0\n"

#. type: Plain text
#: text/chapter4.md:360
msgid ""
"That is, if `guard` is passed an expression which evaluates to `true`, then "
"it returns an array with a single element. If the expression evaluates to "
"`false`, then its result is empty."
msgstr ""
"つまり、`guard`が`true`に評価される式を渡された場合、単一の要素を持つ配列を返"
"すのです。もし式が`false`と評価された場合は、その結果は空です。"

#. type: Plain text
#: text/chapter4.md:362
msgid ""
"This means that if the guard fails, then the current branch of the array "
"comprehension will terminate early with no results. This means that a call "
"to `guard` is equivalent to using `filter` on the intermediate array. "
"Depending on the application, you might prefer to use `guard` instead of a "
"`filter`. Try the two definitions of `factors` to verify that they give the "
"same results."
msgstr ""
"ガードが失敗した場合、配列内包表記の現在の分岐は、結果なしで早めに終了されることを意味します。\n"
"これは、`guard`の呼び出しが、途中の配列に対して`filter`を使用するのと同じだということです。\n"
"実践の場面にもよりますが、`filter`の代わりに`guard`を使いたいことは多いでしょう。\n"
"これらが同じ結果になることを確認するために、`factors`の二つの定義を試してみてください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Easy) Write a function `isPrime` which tests if its integer argument is "
"prime or not. _Hint_: Use the `factors` function."
msgstr ""
"（簡単）整数の引数が素数であるかどうかを調べる関数`isPrime`を定義してみましょう。\n"
"**ヒント**：`factors`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Medium) Write a function `cartesianProduct` which uses do notation to find "
"the _cartesian product_ of two arrays, i.e. the set of all pairs of elements "
"`a`, `b`, where `a` is an element of the first array, and `b` is an element "
"of the second."
msgstr ""
"（やや難しい）do記法を使い、2つの配列の**直積集合**を見つけるための関数`cartesianProduct`を書いてみましょう。\n"
"直積集合とは、要素`a`、`b`のすべての組み合わせの集合のことです。\n"
"ここで`a`は最初の配列の要素、`b`は2つ目の配列の要素です。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Medium) Write a function `triples :: Int -> Array (Array Int)` which takes "
"a number `n` and returns all Pythagorean triples whose components (the `a`, "
"`b` and `c` values) are each less than or equal to `n`. A _Pythagorean "
"triple_ is an array of numbers `[a, b, c]` such that `aÂ² + bÂ² = cÂ²`. "
"_Hint_: Use the `guard` function in an array comprehension."
msgstr ""
"（やや難しい）数値`n`を取って構成要素（値`a`, `b`, `c`）がそれぞれ`n`以下であるような全てのピタゴラスの三つ組 (pythagorean triples) を返す関数`triples :: Int -> Array (Array Int)`を書いてください。\n"
"**ピタゴラスの三つ組** は数値の配列`[a, b, c]`で \\\\( a ^ 2 + b ^ 2 = c ^ 2 \\\\) です。\n"
"**ヒント**：配列内包表記で`guard`関数を使ってください。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:369
msgid ""
"(Difficult) Write a function `primeFactors` which produces the [prime "
"factorization](https://www.mathsisfun.com/prime-factorization.html) of `n`, "
"i.e. the array of prime integers whose product is `n`. _Hint_: for an "
"integer greater than 1, break the problem down into two subproblems: finding "
"the first factor, and finding the remaining factors."
msgstr ""
"（難しい）`factors`関数を使用して、数`n`の[素因数分解](https://www.mathsisfun.com/prime-factorization.html)を求める関数`primeFactors`を定義してみましょう。\n"
"数`n`の素因数分解とは、素数の積が`n`であるような整数の配列のことです。\n"
"**ヒント**：1より大きい整数について、問題を2つの部分問題に分解してください。\n"
"最初の因数を探し、それから残りの因数を探すのです。"

#. type: Title ##
#: text/chapter4.md:370
#, no-wrap
msgid "Folds"
msgstr "畳み込み"

#. type: Plain text
#: text/chapter4.md:373
msgid ""
"Left and right folds over arrays provide another class of interesting "
"functions which can be implemented using recursion."
msgstr "配列における左右の畳み込みは、再帰を用いて実装される別の興味深い関数の集まりを提供します。"

#. type: Plain text
#: text/chapter4.md:375
msgid ""
"Start by importing the `Data.Foldable` module, and inspecting the types of "
"the `foldl` and `foldr` functions using PSCi:"
msgstr "PSCiを使って、`Data.Foldable`モジュールをインポートし、`foldl`と`foldr`関数の型を調べることから始めましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:376
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> :type foldl\n"
"forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b\n"
"\n"
"> :type foldr\n"
"forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> :type foldl\n"
"forall a b f. Foldable f => (b -> a -> b) -> b -> f a -> b\n"
"\n"
"> :type foldr\n"
"forall a b f. Foldable f => (a -> b -> b) -> b -> f a -> b\n"

#. type: Plain text
#: text/chapter4.md:387
msgid ""
"These types are actually more general than we are interested in right now. "
"For the purposes of this chapter, we can assume that PSCi had given the "
"following (more specific) answer:"
msgstr ""
"これらの型は、現在興味があるものよりも一般的です。\n"
"この章の目的では、PSCiは以下の（より具体的な）答えを与えていたと考えておきましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:388
#, no-wrap
msgid ""
"> :type foldl\n"
"forall a b. (b -> a -> b) -> b -> Array a -> b\n"
"\n"
"> :type foldr\n"
"forall a b. (a -> b -> b) -> b -> Array a -> b\n"
msgstr ""
"> :type foldl\n"
"forall a b. (b -> a -> b) -> b -> Array a -> b\n"
"\n"
"> :type foldr\n"
"forall a b. (a -> b -> b) -> b -> Array a -> b\n"

#. type: Plain text
#: text/chapter4.md:397
msgid ""
"In both of these cases, the type `a` corresponds to the type of elements of "
"our array. The type `b` can be thought of as the type of an \"accumulator\", "
"which will accumulate a result as we traverse the array."
msgstr ""
"どちらの型でも、`a`は配列の要素の型に対応しています。\n"
"型`b`は、配列を走査 (traverse) したときの結果を累積する「累積器」(accumulator) の型だと考えることができます。"

#. type: Plain text
#: text/chapter4.md:399
msgid ""
"The difference between the `foldl` and `foldr` functions is the direction of "
"the traversal. `foldl` folds the array \"from the left\", whereas `foldr` "
"folds the array \"from the right\"."
msgstr ""
"`foldl`関数と`foldr`関数の違いは走査の方向です。\n"
"`foldr`が「右から」配列を畳み込むのに対して、`foldl`は「左から」配列を畳み込みます。"

#. type: Plain text
#: text/chapter4.md:401
#, no-wrap
msgid "Let's see these functions in action. Let's use `foldl` to sum an array of integers. The type `a` will be `Int`, and we can also choose the result type `b` to be `Int`. We need to provide three arguments: a function `Int -> Int -> Int`, which will add the next element to the accumulator, an initial value for the accumulator of type `Int`, and an array of `Int`s to add. For the first argument, we can just use the addition operator, and the initial value of the accumulator will be zero:\n"
msgstr ""
"実際にこれらの関数の動きを見てみましょう。\n"
"`foldl`を使用して数の配列の和を求めてみます。\n"
"型`a`は`Int`になり、結果の型`b`も`Int`として選択することができます。\n"
"ここでは、次の要素を累積器に加算する`Int -> Int -> Int`という型の関数、`Int`型の累積器の初期値、\n"
"和を求めたい`Int`の配列という、3つの引数を提供する必要があります。\n"
"最初の引数としては、加算演算子を使用することができますし、累積器の初期値はゼロになります。\n"

#. type: Fenced code block (text)
#: text/chapter4.md:402
#, no-wrap
msgid ""
"> foldl (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""
"> foldl (+) 0 (1 .. 5)\n"
"15\n"

#. type: Plain text
#: text/chapter4.md:408
msgid ""
"In this case, it didn't matter whether we used `foldl` or `foldr`, because "
"the result is the same, no matter what order the additions happen in:"
msgstr "この場合では、引数が逆になっていても`(+)`関数は同じ結果を返すので、`foldl`と`foldr`のどちらでも問題ありません。"

#. type: Fenced code block (text)
#: text/chapter4.md:409
#, no-wrap
msgid ""
"> foldr (+) 0 (1 .. 5)\n"
"15\n"
msgstr ""
"> foldr (+) 0 (1 .. 5)\n"
"15\n"

#. type: Plain text
#: text/chapter4.md:415
msgid ""
"Let's write an example where the choice of folding function does matter, in "
"order to illustrate the difference. Instead of the addition function, let's "
"use string concatenation to build a string:"
msgstr ""
"`foldl`と`foldr`の違いを説明するために、畳み込み関数の選択が影響する例も書いてみましょう。\n"
"加算関数の代わりに、文字列連結を使用して文字列を作ってみます。"

#. type: Fenced code block (text)
#: text/chapter4.md:416
#, no-wrap
msgid ""
"> foldl (\\acc n -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"12345\"\n"
"\n"
"> foldr (\\n acc -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"54321\"\n"
msgstr ""
"> foldl (\\acc n -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"12345\"\n"
"\n"
"> foldr (\\n acc -> acc <> show n) \"\" [1,2,3,4,5]\n"
"\"54321\"\n"

#. type: Plain text
#: text/chapter4.md:425
msgid ""
"This illustrates the difference between the two functions. The left fold "
"expression is equivalent to the following application:"
msgstr ""
"これは、2つの関数の​​違いを示しています。左畳み込み式は、以下の関数適用と同等で"
"す。"

#. type: Fenced code block (text)
#: text/chapter4.md:426
#, no-wrap
msgid "(((((\"\" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)\n"
msgstr "(((((\"\" <> show 1) <> show 2) <> show 3) <> show 4) <> show 5)\n"

#. type: Plain text
#: text/chapter4.md:431
msgid "whereas the right fold is equivalent to this:"
msgstr "それに対し、右畳み込みは以下に相当します。"

#. type: Fenced code block (text)
#: text/chapter4.md:432
#, no-wrap
msgid "(((((\"\" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)\n"
msgstr "(((((\"\" <> show 5) <> show 4) <> show 3) <> show 2) <> show 1)\n"

#. type: Title ##
#: text/chapter4.md:436
#, no-wrap
msgid "Tail Recursion"
msgstr "末尾再帰"

#. type: Plain text
#: text/chapter4.md:439
msgid ""
"Recursion is a powerful technique for specifying algorithms, but comes with "
"a problem: evaluating recursive functions in JavaScript can lead to stack "
"overflow errors if our inputs are too large."
msgstr ""
"再帰はアルゴリズムを定義するための強力な手法ですが、問題も抱えています。\n"
"JavaScriptで再帰関数を評価するとき、入力が大きすぎるとスタックオーバーフローでエラーを起こす可能性があるのです。"

#. type: Plain text
#: text/chapter4.md:441
msgid "It is easy to verify this problem, with the following code in PSCi:"
msgstr "PSCiで次のコードを入力すると、この問題を簡単に検証できます。"

#. type: Fenced code block (text)
#: text/chapter4.md:442
#, no-wrap
msgid ""
"> :paste\n"
"â¦ f n =\n"
"â¦   if n == 0\n"
"â¦     then 0\n"
"â¦     else 1 + f (n - 1)\n"
"â¦ ^D\n"
"\n"
"> f 10\n"
"10\n"
"\n"
"> f 100000\n"
"RangeError: Maximum call stack size exceeded\n"
msgstr ""
"> :paste\n"
"… f n =\n"
"…   if n == 0\n"
"…     then 0\n"
"…     else 1 + f (n - 1)\n"
"… ^D\n"
"\n"
"> f 10\n"
"10\n"
"\n"
"> f 100000\n"
"RangeError: Maximum call stack size exceeded\n"

#. type: Plain text
#: text/chapter4.md:458
msgid ""
"This is a problem. If we are going to adopt recursion as a standard "
"technique from functional programming, then we need a way to deal with "
"possibly unbounded recursion."
msgstr ""
"これは問題です。関数型プログラミングの基本的な手法として再帰を採用しようとす"
"るなら、無限かもしれない再帰でも扱える方法が必要です。"

#. type: Plain text
#: text/chapter4.md:460
msgid ""
"PureScript provides a partial solution to this problem in the form of _tail "
"recursion optimization_."
msgstr "PureScriptは**末尾再帰最適化** (tail recursion optimization) の形でこの問題に対する部分的な解決策を提供しています。"

#. type: Plain text
#: text/chapter4.md:462
msgid ""
"_Note_: more complete solutions to the problem can be implemented in "
"libraries using so-called _trampolining_, but that is beyond the scope of "
"this chapter. The interested reader can consult the documentation for the "
"[`free`](https://pursuit.purescript.org/packages/purescript-free) and "
"[`tailrec`](https://pursuit.purescript.org/packages/purescript-tailrec) "
"packages."
msgstr ""
"**注意**：この問題へのより完全な解決策としては、いわゆる**トランポリン** (trampolining) を使用したライブラリで実装する方法がありますが、それはこの章で扱う範囲を超えています。\n"
"この内容に興味のある読者は\n"
"[`free`](https://pursuit.purescript.org/packages/purescript-free)や\n"
"[`tailrec`](https://pursuit.purescript.org/packages/purescript-tailrec)パッケージの\n"
"ドキュメントを参照してみてください。"

#. type: Plain text
#: text/chapter4.md:464
msgid ""
"The key observation which enables tail recursion optimization is the "
"following: a recursive call in _tail position_ to a function can be replaced "
"with a _jump_, which does not allocate a stack frame. A call is in _tail "
"position_ when it is the last call made before a function returns. This is "
"the reason why we observed a stack overflow in the example - the recursive "
"call to `f` was _not_ in tail position."
msgstr ""
"末尾再帰最適化を可能にする上で鍵となる観点は以下となります。\n"
"**末尾位置** (tail position) にある関数の再帰的な呼び出しは、スタックフレームが確保されない**ジャンプ**に置き換えることができます。\n"
"関数が戻るより前の最後の呼び出しであるとき、呼び出しが**末尾位置**にあるといいます。\n"
"なぜこの例でスタックオーバーフローを観察したのかはこれが理由です。\n"
"この`f`の再帰呼び出しは、末尾位置**ではない**からです。"

#. type: Plain text
#: text/chapter4.md:466
msgid ""
"In practice, the PureScript compiler does not replace the recursive call "
"with a jump, but rather replaces the entire recursive function with a _while "
"loop_."
msgstr "実際には、PureScriptコンパイラは再帰呼び出しをジャンプに置き換えるのではなく、再帰的な関数全体を**whileループ**に置き換えます。"

#. type: Plain text
#: text/chapter4.md:468
msgid ""
"Here is an example of a recursive function with all recursive calls in tail "
"position:"
msgstr "以下はすべての再帰呼び出しが末尾位置にある再帰関数の例です。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:469
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:factorialTailRec}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:factorialTailRec}}\n"

#. type: Plain text
#: text/chapter4.md:474
msgid ""
"Notice that the recursive call to `factorialTailRec` is the last thing that "
"happens in this function - it is in tail position."
msgstr ""
"`fact`への再帰呼び出しは、この関数の中で起こる最後のものである、つまり末尾位"
"置にあることに注意してください。"

#. type: Title ##
#: text/chapter4.md:475
#, no-wrap
msgid "Accumulators"
msgstr "累積器"

#. type: Plain text
#: text/chapter4.md:478
msgid ""
"One common way to turn a function which is not tail recursive into a tail "
"recursive function is to use an _accumulator parameter_. An accumulator "
"parameter is an additional parameter which is added to a function which "
"_accumulates_ a return value, as opposed to using the return value to "
"accumulate the result."
msgstr ""
"末尾再帰ではない関数を末尾再帰関数に変える一般的な方法としては、**累積器引数** (accumulator parameter) を使用する方法があります。\n"
"累積器引数は関数に追加される余剰の引数で返り値を**累積**するものです。\n"
"これは結果を累積するために返り値を使うのとは対称的です。"

#. type: Plain text
#: text/chapter4.md:480
msgid ""
"For example, consider again the `length` function presented in the beginning "
"of the chapter:"
msgstr "例えば章の初めに示した`length`関数を再考しましょう。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:481
#, no-wrap
msgid ""
"length :: forall a. Array a -> Int\n"
"length arr =\n"
"  if null arr\n"
"    then 0\n"
"    else 1 + (length $ fromMaybe [] $ tail arr)\n"
msgstr ""
"length :: forall a. Array a -> Int\n"
"length arr =\n"
"  if null arr\n"
"    then 0\n"
"    else 1 + (length $ fromMaybe [] $ tail arr)\n"

#. type: Plain text
#: text/chapter4.md:490
msgid ""
"This implementation is not tail recursive, so the generated JavaScript will "
"cause a stack overflow when executed on a large input array. However, we can "
"make it tail recursive, by introducing a second function argument to "
"accumulate the result instead:"
msgstr ""
"この実装は末尾再帰ではないので、大きな入力配列に対して実行されると、\n"
"生成されたJavaScriptはスタックオーバーフローを発生させるでしょう。\n"
"しかし代わりに、結果を蓄積するための2つ目の引数を関数に導入することで、これを末尾再帰に変えることができます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:491
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:lengthTailRec}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:lengthTailRec}}\n"

#. type: Plain text
#: text/chapter4.md:496
msgid ""
"In this case, we delegate to the helper function `length'`, which is tail "
"recursive - its only recursive call is in the last case, and is in tail "
"position. This means that the generated code will be a _while loop_, and "
"will not blow the stack for large inputs."
msgstr ""
"ここでは、配列を逆転させる作業を補助関数`length'`に委譲しています。\n"
"`length'`は末尾再帰です。\n"
"その唯一の再帰呼び出しは、最後の場合の末尾位置にあります。\n"
"これは、生成されたコードが**whileループ**となり、大きな入力でもスタックが溢れないことを意味します。"

#. type: Plain text
#: text/chapter4.md:498
msgid ""
"To understand the implementation of `lengthTailRec`, note that the helper "
"function `length'` essentially uses the accumulator parameter to maintain an "
"additional piece of state - the partial result. It starts out at 0, and "
"grows by adding 1 for every element in the input array."
msgstr ""
"`lengthTailRec`の実装を理解するために補助関数`length'`に着目しましょう。\n"
"この関数は必然的に累積器引数を使って追加の状態……これは部分的な結果です……を維持しています。\n"
"0から始まり、入力の配列中の全ての要素それぞれについて1ずつ足して成長していきます。"

#. type: Plain text
#: text/chapter4.md:500
msgid ""
"Note also that while we might think of the accumulator as \"state\", there "
"is no direct mutation going on."
msgstr "累積器を「状態」と考えることもできますが、直接に変更がされているわけではないことにも注意してください。"

#. type: Title ##
#: text/chapter4.md:501
#, no-wrap
msgid "Prefer Folds to Explicit Recursion"
msgstr "明示的な再帰より畳み込みを選ぶ"

#. type: Plain text
#: text/chapter4.md:504
msgid ""
"If we can write our recursive functions using tail recursion, then we can "
"benefit from tail recursion optimization, so it becomes tempting to try to "
"write all of our functions in this form. However, it is often easy to forget "
"that many functions can be written directly as a fold over an array or "
"similar data structure. Writing algorithms directly in terms of combinators "
"such as `map` and `fold` has the added advantage of code simplicity - these "
"combinators are well-understood, and as such, communicate the _intent_ of "
"the algorithm much better than explicit recursion."
msgstr ""
"末尾再帰を使用して再帰関数を記述することができれば末尾再帰最適化の恩恵を受けることができるので、\n"
"すべての関数をこの形で書こうとする誘惑にかられます。\n"
"しかし、多くの関数は配列やそれに似たデータ構造に対する折り畳みとして直接書くことができることを忘れがちです。\n"
"`map`や`fold`のようなコンビネータを使って直接アルゴリズムを書くことには、コードの単純さという利点があります。\n"
"これらのコンビネータはよく知られており、明示的な再帰よりもアルゴリズムの**意図**をよりはっきりとさせるのです。"

#. type: Plain text
#: text/chapter4.md:506
msgid "For example, we can reverse an array using `foldr`:"
msgstr "例えば`foldr`を使って配列を反転できます。"

#. type: Fenced code block (text)
#: text/chapter4.md:507
#, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> :paste\n"
"â¦ reverse :: forall a. Array a -> Array a\n"
"â¦ reverse = foldr (\\x xs -> xs <> [x]) []\n"
"â¦ ^D\n"
"\n"
"> reverse [1, 2, 3]\n"
"[3,2,1]\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> :paste\n"
"… reverse :: forall a. Array a -> Array a\n"
"… reverse = foldr (\\x xs -> xs <> [x]) []\n"
"… ^D\n"
"\n"
"> reverse [1, 2, 3]\n"
"[3,2,1]\n"

#. type: Plain text
#: text/chapter4.md:520
msgid ""
"Writing `reverse` in terms of `foldl` will be left as an exercise for the "
"reader."
msgstr ""
"`foldl`を使って`reverse`を書くことは、読者への課題として残しておきます。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:527
msgid ""
"(Easy) Write a function `allTrue` which uses `foldl` to test whether an "
"array of boolean values are all true."
msgstr "（簡単）`foldl`を使って真偽値配列の値が全て真か検査する関数`allTrue`を書いてください。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:527
msgid ""
"(Medium - No Test) Characterize those arrays `xs` for which the function "
"`foldl (==) false xs` returns `true`. In other words, complete the sentence: "
"\"The function returns `true` when `xs` contains ...\""
msgstr ""
"（やや難しい。テストなし）関数`foldl (==) false xs`が真を返すような配列`xs`とはどのようなものか説明してください。\n"
"言い換えると、次の文を完成させることになります。\n"
"「関数は`xs`が……を含むときに`true`を返す。」"

#. type: Bullet: ' 3. '
#: text/chapter4.md:527
msgid ""
"(Medium) Write a function `fibTailRec` which is the same as `fib` but in "
"tail recursive form. _Hint_: Use an accumulator parameter."
msgstr ""
"（やや難しい）末尾再帰の形式を取っていること以外は`fib`と同じような関数`fibTailRec`を書いてください。\n"
"**ヒント**：累積器引数を使ってください。"

#. type: Bullet: ' 4. '
#: text/chapter4.md:527
msgid "(Medium) Write `reverse` in terms of `foldl`."
msgstr "（やや難しい）`foldl`を使って`reverse`を書いてみましょう。"

#. type: Title ##
#: text/chapter4.md:528
#, no-wrap
msgid "A Virtual Filesystem"
msgstr "仮想ファイルシステム"

#. type: Plain text
#: text/chapter4.md:531
msgid ""
"In this section, we're going to apply what we've learned, writing functions "
"which will work with a model of a filesystem. We will use maps, folds and "
"filters to work with a predefined API."
msgstr ""
"この節では、これまで学んだことを応用して、模擬的なファイルシステムで動作する関数を書いていきます。\n"
"事前に定義されたAPIで動作するように、マップ、畳み込み、およびフィルタを使用します。"

#. type: Plain text
#: text/chapter4.md:533
msgid ""
"The `Data.Path` module defines an API for a virtual filesystem, as follows:"
msgstr ""
"`Data.Path`モジュールでは、次のように仮想ファイルシステムのAPIが定義されてい"
"ます。"

#. type: Plain text
#: text/chapter4.md:540
msgid ""
"- There is a type `Path` which represents a path in the filesystem.  - There "
"is a path `root` which represents the root directory.  - The `ls` function "
"enumerates the files in a directory.  - The `filename` function returns the "
"file name for a `Path`.  - The `size` function returns the file size for a "
"`Path` which represents a file.  - The `isDirectory` function tests whether "
"a `Path` is a file or a directory."
msgstr ""
"- ファイルシステム内のパスを表す型`Path`があります。\n"
"- ルートディレクトリを表すパス`root`があります。\n"
"- `ls`関数はディレクトリ内のファイルを列挙します。\n"
"- `filename`関数は`Path`のファイル名を返します。\n"
"- `size`関数は`Path`が示すファイルの大きさを返します。\n"
"- `isDirectory`関数はファイルかディレクトリかを調べます。"

#. type: Plain text
#: text/chapter4.md:542
msgid "In terms of types, we have the following type definitions:"
msgstr "型については、型定義は次のようになっています。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:543
#, no-wrap
msgid ""
"root :: Path\n"
"\n"
"ls :: Path -> Array Path\n"
"\n"
"filename :: Path -> String\n"
"\n"
"size :: Path -> Maybe Int\n"
"\n"
"isDirectory :: Path -> Boolean\n"
msgstr ""
"root :: Path\n"
"\n"
"ls :: Path -> Array Path\n"
"\n"
"filename :: Path -> String\n"
"\n"
"size :: Path -> Maybe Int\n"
"\n"
"isDirectory :: Path -> Boolean\n"

#. type: Plain text
#: text/chapter4.md:556
msgid "We can try out the API in PSCi:"
msgstr "PSCiでこのAPIを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:557
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Data.Path\n"
"\n"
"> root\n"
"/\n"
"\n"
"> isDirectory root\n"
"true\n"
"\n"
"> ls root\n"
"[/bin/,/etc/,/home/]\n"
msgstr ""
"$ spago repl\n"
"\n"
"> import Data.Path\n"
"\n"
"> root\n"
"/\n"
"\n"
"> isDirectory root\n"
"true\n"
"\n"
"> ls root\n"
"[/bin/,/etc/,/home/]\n"

#. type: Plain text
#: text/chapter4.md:573
msgid ""
"The `Test.Examples` module defines functions which use the `Data.Path` API. "
"You do not need to modify the `Data.Path` module, or understand its "
"implementation. We will work entirely in the `Test.Examples` module."
msgstr ""
"`Test.Examples`モジュールでは`Data.Path`APIを使用する関数を定義しています。\n"
"`Data.Path`モジュールを変更したり定義を理解したりする必要はありません。\n"
"全て`Test.Examples`モジュールだけで作業を行います。"

#. type: Title ##
#: text/chapter4.md:574
#, no-wrap
msgid "Listing All Files"
msgstr "すべてのファイルの一覧"

#. type: Plain text
#: text/chapter4.md:577
msgid ""
"Let's write a function which performs a deep enumeration of all files inside "
"a directory. This function will have the following type:"
msgstr ""
"それでは、内側のディレクトリまで、すべてのファイルを列挙する関数を書いてみましょう。\n"
"この関数は以下のような型を持つでしょう。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:578
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_signature}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_signature}}\n"

#. type: Plain text
#: text/chapter4.md:583
msgid ""
"We can define this function by recursion. First, we can use `ls` to "
"enumerate the immediate children of the directory. For each child, we can "
"recursively apply `allFiles`, which will return an array of paths. "
"`concatMap` will allow us to apply `allFiles` and flatten the results at the "
"same time."
msgstr ""
"再帰を使ってこの関数を定義することができます。\n"
"まずは`ls`を使用してディレクトリの直接の子を列挙します。\n"
"それぞれの子について再帰的に`allFiles`を適用すると、それぞれパスの配列が返ってくるでしょう。\n"
"`concatMap`を適用すると、この結果を同時に平坦化することができます。"

#. type: Plain text
#: text/chapter4.md:585
msgid "Finally, we use the cons operator `:` to include the current file:"
msgstr "最後に、cons演算子`:`を使って現在のファイルも含めます。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:586
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_implementation}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_implementation}}\n"

#. type: Plain text
#: text/chapter4.md:591
msgid ""
"_Note_: the cons operator `:` actually has poor performance on immutable "
"arrays, so it is not recommended in general. Performance can be improved by "
"using other data structures, such as linked lists and sequences."
msgstr ""
"**注意**：cons演算子`:`は、実際には不変な配列に対してパフォーマンスが悪いので、一般的には推奨されません。\n"
"リンクリストやシーケンスなどの他のデータ構造を使用すると、パフォーマンスを向上させることができます。"

#. type: Plain text
#: text/chapter4.md:593
msgid "Let's try this function in PSCi:"
msgstr "それではPSCiでこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter4.md:594
#, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.Path\n"
"\n"
"> allFiles root\n"
"\n"
"[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]\n"
msgstr ""
"> import Test.Examples\n"
"> import Data.Path\n"
"\n"
"> allFiles root\n"
"\n"
"[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]\n"

#. type: Plain text
#: text/chapter4.md:604
msgid ""
"Great! Now let's see if we can write this function using an array "
"comprehension using do notation."
msgstr ""
"すばらしい！\n"
"do記法で配列内包表記を使ってもこの関数を書くことができるので見ていきましょう。"

#. type: Plain text
#: text/chapter4.md:606
msgid ""
"Recall that a backwards arrow corresponds to choosing an element from an "
"array. The first step is to choose an element from the immediate children of "
"the argument. Then we simply call the function recursively for that file. "
"Since we are using do notation, there is an implicit call to `concatMap` "
"which concatenates all of the recursive results."
msgstr ""
"逆向きの矢印は配列から要素を選択するのに相当することを思い出してください。\n"
"最初の手順は、引数の直接の子から要素を選択することです。\n"
"それから、単にそのファイルに対してこの再帰関数を呼びします。\n"
"do記法を使用しているので、再帰的な結果をすべて連結する`concatMap`が暗黙に呼び出されています。"

#. type: Plain text
#: text/chapter4.md:608
msgid "Here is the new version:"
msgstr "新しいバージョンは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter4.md:609
#, no-wrap
msgid "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_2}}\n"
msgstr "{{#include ../exercises/chapter4/test/Examples.purs:allFiles_2}}\n"

#. type: Plain text
#: text/chapter4.md:614
msgid ""
"Try out the new version in PSCi - you should get the same result. I'll let "
"you decide which version you find clearer."
msgstr ""
"PSCiで新しいコードを試してみてください。\n"
"同じ結果が返ってくるはずです。\n"
"どちらのほうがわかりやすいかの選択はお任せします。"

#. type: Bullet: ' 1. '
#: text/chapter4.md:619
msgid ""
"(Easy) Write a function `onlyFiles` which returns all _files_ (not "
"directories) in all subdirectories of a directory."
msgstr ""
"（簡単）ディレクトリのすべてのサブディレクトリの中まで、\n"
"（ディレクトリを除く）すべてのファイルを返すような関数`onlyFiles`を書いてみてください。"

#. type: Bullet: ' 2. '
#: text/chapter4.md:619
msgid ""
"(Medium) Write a function `whereIs` to search for a file by name. The "
"function should return a value of type `Maybe Path`, indicating the "
"directory containing the file, if it exists. It should behave as follows:"
msgstr ""
"（やや難しい）ファイルを名前で検索する関数`whereIs`を書いてください。\n"
"この関数は型`Maybe Path`の値を返すものとします。\n"
"この値が存在するなら、そのファイルがそのディレクトリに含まれているということを表します。\n"
"この関数は次のように振る舞う必要があります。"

#. type: Plain text
#: text/chapter4.md:623
#, no-wrap
msgid ""
"     ```text\n"
"     > whereIs root \"ls\"\n"
"     Just (/bin/)\n"
msgstr ""
"     ```text\n"
"     > whereIs root \"ls\"\n"
"     Just (/bin/)\n"

#. type: Plain text
#: text/chapter4.md:627
#, no-wrap
msgid ""
"     > whereIs root \"cat\"\n"
"     Nothing\n"
"     ```\n"
msgstr ""
"     > whereIs root \"cat\"\n"
"     Nothing\n"
"     ```\n"

#. type: Plain text
#: text/chapter4.md:630
#, no-wrap
msgid ""
"     _Hint_: Try to write this function as an array comprehension using do notation.\n"
" 3. (Difficult) Write a function `largestSmallest` which takes a `Path` and returns an array containing the single largest and single smallest files in the `Path`. _Note_: consider the cases where there are zero or one files in the `Path` by returning an empty array or a one-element array respectively.\n"
msgstr ""
"     **ヒント**：この関数をdo記法を使った配列内包表記で書いてみましょう。\n"
" 3. （難しい）`Path`を取って`Path`に最大のファイルと最小のファイルを1つずつ含む配列を返す関数`largestSmallest`を書いてください。\n"
"    **補足**：空配列や1要素の配列を返すことで、\n"
"    `Path`にゼロか1個のファイルがある場合についても考慮してください。\n"

#. type: Plain text
#: text/chapter4.md:633
msgid ""
"In this chapter, we covered the basics of recursion in PureScript, as a "
"means of expressing algorithms concisely. We also introduced user-defined "
"infix operators, standard functions on arrays such as maps, filters and "
"folds, and array comprehensions which combine these ideas. Finally, we "
"showed the importance of using tail recursion in order to avoid stack "
"overflow errors, and how to use accumulator parameters to convert functions "
"to tail recursive form."
msgstr ""
"この章では、アルゴリズムを簡潔に表現する手段として、PureScriptでの再帰の基本を説明しました。\n"
"また、独自の中置演算子や、マップ、フィルタリングや畳み込みなどの配列に対する標準関数、\n"
"およびこれらの概念を組み合わせた配列内包表記を導入しました。\n"
"最後に、スタックオーバーフローエラーを回避するために末尾再帰を使用することの重要性、\n"
"累積器引数を使用して末尾再帰形に関数を変換する方法を示しました。"

#. type: Title #
#: text/chapter5.md:1
#, no-wrap
msgid "Pattern Matching"
msgstr "パターン照合"

#. type: Plain text
#: text/chapter5.md:6
msgid ""
"This chapter will introduce two new concepts: algebraic data types, and "
"pattern matching. We will also briefly cover an interesting feature of the "
"PureScript type system: row polymorphism."
msgstr ""
"この章では、代数的データ型とパターン照合という、ふたつの新しい概念を導入します。\n"
"また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱います。"

#. type: Plain text
#: text/chapter5.md:8
msgid ""
"Pattern matching is a common technique in functional programming and allows "
"the developer to write compact functions which express potentially complex "
"ideas, by breaking their implementation down into multiple cases."
msgstr ""
"**パターン照合** (pattern matching) は関数​​型プログラミングにおける一般的な手法で、\n"
"複数の場合に実装を分解することにより、開発者は潜在的に複雑な動作の関数を簡潔に書くことができます。"

#. type: Plain text
#: text/chapter5.md:10
msgid ""
"Algebraic data types are a feature of the PureScript type system which "
"enable a similar level of expressiveness in the language of types - they are "
"closely related to pattern matching."
msgstr ""
"代数的データ型はPureScriptの型システムの機能であり、\n"
"型のある言語において同様の水準の表現力を可能にしています。\n"
"パターン照合とも密接に関連しています。"

#. type: Plain text
#: text/chapter5.md:12
msgid ""
"The goal of the chapter will be to write a library to describe and "
"manipulate simple vector graphics using algebraic types and pattern matching."
msgstr ""
"この章の目的は、代数的データ型やパターン照合を使用して、\n"
"単純なベクターグラフィックスを描画し操作するためのライブラリを書くことです。"

#. type: Plain text
#: text/chapter5.md:16
msgid ""
"The source code for this chapter is defined in the file `src/Data/Picture."
"purs`."
msgstr ""
"この章のソースコードはファイル `src/Data/Picture.purs`で定義されています。"

#. type: Plain text
#: text/chapter5.md:18
msgid ""
"The `Data.Picture` module defines a data type `Shape` for simple shapes, and "
"a type `Picture` for collections of shapes, along with functions for working "
"with those types."
msgstr "`Data.Picture`モジュールは、簡単な図形を表すデータ型 `Shape`や、図形の集合である型 `Picture`、及びこれらの型を扱うための関数を定義しています。"

#. type: Plain text
#: text/chapter5.md:20
msgid ""
"The module imports the `Data.Foldable` module, which provides functions for "
"folding data structures:"
msgstr "このモジュールでは、データ構造の畳込みを行う関数を提供する `Data.Foldable`モジュールもインポートします。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:21
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:module_picture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:module_picture}}\n"

#. type: Plain text
#: text/chapter5.md:26
msgid ""
"The `Data.Picture` module also imports the `Number` module, but this time "
"using the `as` keyword:"
msgstr "`Data.Picture`モジュールは`Number`モジュールもインポートしますが、こちらは`as`キーワードを使います。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:27
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:picture_import_as}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:picture_import_as}}\n"

#. type: Plain text
#: text/chapter5.md:32
msgid ""
"This makes the types and functions in that module available for use, but "
"only by using the _qualified name_, like `Number.max`. This can be useful to "
"avoid overlapping imports, or just to make it clearer which modules certain "
"things are imported from."
msgstr ""
"これは型や関数をモジュール内で使用できるようにしますが、\n"
"それは`Number.max`のように**修飾名**を使ったときのみです。\n"
"これは重複したインポートを避けたり、\n"
"何らかのものがどのモジュールからインポートされたのかを明らかにするのに役立ちます。"

#. type: Plain text
#: text/chapter5.md:34
msgid ""
"_Note_: it is not necessary to use the same module name as the original "
"module for a qualified import. Shorter qualified names like `import Data."
"Number as N` are possible, and quite common."
msgstr ""
"**注意**：元のモジュールと同じモジュール名を修飾名に使用するのは不要です。\n"
"`import Math as M`などのより短い名前にすることは可能ですし、かなりよくあります。"

#. type: Title ##
#: text/chapter5.md:35
#, no-wrap
msgid "Simple Pattern Matching"
msgstr "単純なパターン照合"

#. type: Plain text
#: text/chapter5.md:38
msgid ""
"Let's begin by looking at an example. Here is a function which computes the "
"greatest common divisor of two integers using pattern matching:"
msgstr ""
"それではコード例を見ることから始めましょう。\n"
"パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:39
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcd}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcd}}\n"

#. type: Plain text
#: text/chapter5.md:44
msgid ""
"This algorithm is called the Euclidean Algorithm. If you search for its "
"definition online, you will likely find a set of mathematical equations "
"which look a lot like the code above. This is one benefit of pattern "
"matching: it allows you to define code by cases, writing simple, declarative "
"code which looks like a specification of a mathematical function."
msgstr ""
"このアルゴリズムはユークリッドの互除法と呼ばれています。\n"
"その定義をオンラインで検索すると、\n"
"おそらく上記のコードによく似た数学の方程式が見つかるでしょう。\n"
"パターン照合の利点のひとつは、\n"
"上記のようにコードを場合分けして定義することができ、\n"
"数学関数の定義と似たような簡潔で宣言型なコードを書くことができることです。"

#. type: Plain text
#: text/chapter5.md:46
msgid ""
"A function written using pattern matching works by pairing sets of "
"conditions with their results. Each line is called an _alternative_ or a "
"_case_. The expressions on the left of the equals sign are called "
"_patterns_, and each case consists of one or more patterns, separated by "
"spaces. Cases describe which conditions the arguments must satisfy before "
"the expression on the right of the equals sign should be evaluated and "
"returned. Each case is tried in order, and the first case whose patterns "
"match their inputs determines the return value."
msgstr ""
"パターン照合を使用して書かれた関数は、\n"
"条件と結果の組み合わせによって動作します。\n"
"この定義の各行は**選択肢** (alternative) や**場合** (case) と呼ばれています。\n"
"等号の左辺の式は**パターン**と呼ばれており、\n"
"それぞれの場合は空白で区切られた1つ以上のパターンで構成されています。\n"
"場合の集まりは、等号の右側の式が評価され値が返される前に、\n"
"引数が満たさなければならないどれかの条件を表現しています。\n"
"それぞれの場合は上からこの順番に試されていき、\n"
"最初に入力に適合した場合が返り値を決定します。"

#. type: Plain text
#: text/chapter5.md:48
msgid "For example, the `gcd` function is evaluated using the following steps:"
msgstr "たとえば、 `gcd`関数は次の手順で評価されます。"

#. type: Plain text
#: text/chapter5.md:52
msgid ""
"- The first case is tried: if the second argument is zero, the function "
"returns `n` (the first argument).  - If not, the second case is tried: if "
"the first argument is zero, the function returns `m` (the second argument).  "
"- Otherwise, the function evaluates and returns the expression in the last "
"line."
msgstr ""
"- まず最初の場合が試されます。第2引数がゼロの場合、関数は `n`（最初の引数）を返します。\n"
"- そうでなければ、2番目の場合が試されます。\n"
"  最初の引数がゼロの場合、関数は `m`（第2引数）を返します。\n"
"- それ以外の場合、関数は最後の行の式を評価して返します。"

#. type: Plain text
#: text/chapter5.md:54
msgid ""
"Note that patterns can bind values to names - each line in the example binds "
"one or both of the names `n` and `m` to the input values. As we learn about "
"different kinds of patterns, we will see that different types of patterns "
"correspond to different ways to choose names from the input arguments."
msgstr ""
"パターンは値を名前に束縛することができることに注意してください。\n"
"この例の各行では `n`という名前と `m`という名前の両方、\n"
"またはどちらか一方に、入力された値を束縛しています。\n"
"これよりさまざまな種類のパターンについて学びますが、\n"
"これらのパターンは入力の引数から名前を選ぶさまざまな方法に対応付けられることがわかるでしょう。"

#. type: Title ##
#: text/chapter5.md:55
#, no-wrap
msgid "Simple Patterns"
msgstr "単純なパターン"

#. type: Plain text
#: text/chapter5.md:58
msgid "The example code above demonstrates two types of patterns:"
msgstr "上記のコード例では、2種類のパターンを示しました。"

#. type: Plain text
#: text/chapter5.md:61
msgid ""
"- Integer literals patterns, which match something of type `Int`, only if "
"the value matches exactly.  - Variable patterns, which bind their argument "
"to a name"
msgstr ""
"- `Int`型の値が正確に一致する場合にのみ適合する、整数リテラルパターン\n"
"- 引数を名前に束縛する、変数パターン"

#. type: Plain text
#: text/chapter5.md:63
msgid "There are other types of simple patterns:"
msgstr "単純なパターンには他にも種類があります。"

#. type: Plain text
#: text/chapter5.md:66
msgid ""
"- `Number`, `String`, `Char` and `Boolean` literals - Wildcard patterns, "
"indicated with an underscore (`_`), which match any argument, and which do "
"not bind any names."
msgstr ""
"- `Number`、`String`、`Char`、そして`Boolean`といったリテラル\n"
"- どんな引数とも適合するが名前に束縛はしない、\n"
"  アンダースコア (`_`) で表されるワイルドカードパターン"

#. type: Plain text
#: text/chapter5.md:68
msgid ""
"Here are two more examples which demonstrate using these simple patterns:"
msgstr "ここではこれらの単純なパターンを使用した、さらに2つの例を示します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:69
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:fromString}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:toString}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:fromString}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:toString}}\n"

#. type: Plain text
#: text/chapter5.md:76
msgid "Try these functions in PSCi."
msgstr "PSCiでこれらの関数を試してみてください。"

#. type: Plain text
#: text/chapter5.md:80
#, no-wrap
msgid "In the Euclidean algorithm example, we used an `if .. then .. else` expression to switch between the two alternatives when `m > n` and `m <= n`. Another option in this case would be to use a _guard_.\n"
msgstr ""
"ユークリッドの互除法の例では、\n"
"`m > n`のときと `m <= n`のときの２つに分岐するために `if .. then .. else`式を使っていました。\n"
"こういうときには他に**ガード** (guard) を使うという選択肢もあります。\n"

#. type: Plain text
#: text/chapter5.md:82
msgid ""
"A guard is a boolean-valued expression which must be satisfied in addition "
"to the constraints imposed by the patterns. Here is the Euclidean algorithm "
"rewritten to use a guard:"
msgstr ""
"ガードはパターンによる制約に加えて満たされなくてはいけない真偽値の式です。\n"
"ガードを使用してユークリッドの互除法を書き直すと、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:83
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcdV2}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:gcdV2}}\n"

#. type: Plain text
#: text/chapter5.md:88
msgid ""
"In this case, the third line uses a guard to impose the extra condition that "
"the first argument is strictly larger than the second. The guard in the "
"final line uses the expression `otherwise`, which might seem like a keyword, "
"but is in fact just a regular binding in `Prelude`:"
msgstr ""
"この場合、3行目ではガードを使用して、最初の引数が第2引数よりも厳密に大きいという条件を付け加えています。\n"
"最後の行でのガードは式`otherwise`を使っており、キーワードのようにも見えますが、\n"
"実際にはただの`Prelude`における通常の束縛なのです。"

#. type: Fenced code block (text)
#: text/chapter5.md:88
#, no-wrap
msgid ""
"> :type otherwise\n"
"Boolean\n"
"\n"
"> otherwise\n"
"true\n"
msgstr ""
"> :type otherwise\n"
"Boolean\n"
"\n"
"> otherwise\n"
"true\n"

#. type: Plain text
#: text/chapter5.md:97
msgid ""
"As this example demonstrates, guards appear on the left of the equals "
"symbol, separated from the list of patterns by a pipe character (`|`)."
msgstr "この例が示すように、ガードは等号の左側に現れ、パイプ文字 (`|`) でパターンのリストと区切られています。"

#. type: Bullet: '1. '
#: text/chapter5.md:103
msgid ""
"(Easy) Write the `factorial` function using pattern matching. _Hint_: "
"Consider the two corner cases of zero and non-zero inputs. _Note_: This is a "
"repeat of an example from the previous chapter, but see if you can rewrite "
"it here on your own."
msgstr ""
"（簡単）パターン照合を使用して、階乗関数`factorial`を書いてみましょう。\n"
"**ヒント**:入力がゼロのときとゼロでないときの、ふたつのコーナーケースを考えてみてください。\n"
"**補足**：これは前の章からの例の繰り返しですが、ここでは自力で書き直せるかやってみてください。"

#. type: Bullet: '1. '
#: text/chapter5.md:103
msgid ""
"(Medium) Write a function `binomial` which finds the coefficient of the "
"x^`k`th term in the polynomial expansion of (1 + x)^`n`. This is the same as "
"the number of ways to choose a subset of `k` elements from a set of `n` "
"elements. Use the formula `n! / k! (n - k)!`, where `!` is the factorial "
"function written earlier. _Hint_: Use pattern matching to handle corner "
"cases. If it takes a long time to complete or crashes with an error about "
"the call stack, try adding more corner cases."
msgstr ""
"（やや難しい）\\\\( (1 + x) ^ n \\\\)を多項式展開した式にある\n"
"\\\\( x ^ k \\\\)の項の係数を求める関数`binomial`を書いてください。\n"
"これは`n`要素の集合から`k`要素の部分集合を選ぶ方法の数と同じです。\n"
"数式\\\\( n! / k! (n - k)! \\\\)を使ってください。\n"
"ここで \\\\( ! \\\\) は前に書いた階乗関数です。\n"
"**ヒント**：パターン照合を使ってコーナーケースを制御してください。\n"
"長い時間が掛かったりコールスタックのエラーでクラッシュしたりしたら、\n"
"もっとコーナーケースを追加してみてください。"

#. type: Bullet: '1. '
#: text/chapter5.md:103
msgid ""
"(Medium) Write a function `pascal` which uses [_Pascal`s Rule_](https://en."
"wikipedia.org/wiki/Pascal%27s_rule) for computing the same binomial "
"coefficients as the previous exercise."
msgstr ""
"（やや難しい）[**パスカルの法則**](https://en.wikipedia.org/wiki/Pascal%27s_rule)を使って\n"
"前の演習の同じ2項係数を計算する関数`pascal`を書いてください。"

#. type: Title ##
#: text/chapter5.md:104
#, no-wrap
msgid "Array Patterns"
msgstr "配列パターン"

#. type: Plain text
#: text/chapter5.md:107
msgid ""
"_Array literal patterns_ provide a way to match arrays of a fixed length. "
"For example, suppose we want to write a function `isEmpty` which identifies "
"empty arrays. We could do this by using an empty array pattern (`[]`) in the "
"first alternative:"
msgstr ""
"**配列リテラルパターン** (array literal patterns) は、固定長の配列に対して照合を行う方法を提供します。\n"
"たとえば、空の配列であることを特定する関数 `isEmpty`を書きたいとします。\n"
"最初の選択肢に空の配列パターン (`[]`) を用いるとこれを実現できます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:108
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:isEmpty}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:isEmpty}}\n"

#. type: Plain text
#: text/chapter5.md:113
msgid ""
"Here is another function which matches arrays of length five, binding each "
"of its five elements in a different way:"
msgstr "次の関数では、長さ5の配列と適合し、配列の5つの要素をそれぞれ異なった方法で束縛しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:114
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:takeFive}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:takeFive}}\n"

#. type: Plain text
#: text/chapter5.md:119
msgid ""
"The first pattern only matches arrays with five elements, whose first and "
"second elements are 0 and 1 respectively. In that case, the function returns "
"the product of the third and fourth elements. In every other case, the "
"function returns zero. For example, in PSCi:"
msgstr ""
"最初のパターンは、第1要素と第2要素がそれぞれ0と1であるような、5要素の配列にのみ適合します。\n"
"その場合、関数は第3要素と第4要素の積を返します。\n"
"それ以外の場合は、関数は0を返します。\n"
"PSCiで試してみると、たとえば次のようになります。"

#. type: Fenced code block (text)
#: text/chapter5.md:120
#, no-wrap
msgid ""
"> :paste\n"
"â¦ takeFive [0, 1, a, b, _] = a * b\n"
"â¦ takeFive _ = 0\n"
"â¦ ^D\n"
"\n"
"> takeFive [0, 1, 2, 3, 4]\n"
"6\n"
"\n"
"> takeFive [1, 2, 3, 4, 5]\n"
"0\n"
"\n"
"> takeFive []\n"
"0\n"
msgstr ""
"> :paste\n"
"… takeFive [0, 1, a, b, _] = a * b\n"
"… takeFive _ = 0\n"
"… ^D\n"
"\n"
"> takeFive [0, 1, 2, 3, 4]\n"
"6\n"
"\n"
"> takeFive [1, 2, 3, 4, 5]\n"
"0\n"
"\n"
"> takeFive []\n"
"0\n"

#. type: Plain text
#: text/chapter5.md:137
msgid ""
"Array literal patterns allow us to match arrays of a fixed length, but "
"PureScript does _not_ provide any means of matching arrays of an unspecified "
"length, since destructuring immutable arrays in these sorts of ways can lead "
"to poor performance. If you need a data structure which supports this sort "
"of matching, the recommended approach is to use `Data.List`. Other data "
"structures exist which provide improved asymptotic performance for different "
"operations."
msgstr ""
"配列のリテラルパターンでは、固定長の配列と一致させることはできますが、\n"
"PureScriptは不特定の長さの配列を照合させる手段を提供していません。\n"
"そのような方法で不変な配列を分解すると、\n"
"実行速度が低下する可能性があるためです。\n"
"この種の照合を行うことができるデータ構造が必要な場合は、\n"
"`Data.List`を使うことをお勧めします。\n"
"そのほかの操作について、\n"
"より優れた漸近性能を提供するデータ構造も存在します。"

#. type: Title ##
#: text/chapter5.md:138
#, no-wrap
msgid "Record Patterns and Row Polymorphism"
msgstr "レコードパターンと行多相"

#. type: Plain text
#: text/chapter5.md:141
msgid "_Record patterns_ are used to match - you guessed it - records."
msgstr "**レコードパターン** (Record patterns) は（ご想像のとおり）レコードに照合します。"

#. type: Plain text
#: text/chapter5.md:143
msgid ""
"Record patterns look just like record literals, but instead of values on the "
"right of the colon, we specify a binder for each field."
msgstr ""
"レコードパターンはレコードリテラルに見た目が似ていますが、\n"
"レコードリテラルでラベルと式を**コロン**で区切るのとは異なり、\n"
"レコードパターンではラベルとパターンを**等号**で区切ります。"

#. type: Plain text
#: text/chapter5.md:145
msgid ""
"For example: this pattern matches any record which contains fields called "
"`first` and `last`, and binds their values to the names `x` and `y` "
"respectively:"
msgstr ""
"たとえば、次のパターンは `first`と `last`と呼ばれるフィールドが含まれた任意のレコードにマッチし、\n"
"これらのフィールドの値はそれぞれ `x`と `y`という名前に束縛されます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:146
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPerson}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPerson}}\n"

#. type: Plain text
#: text/chapter5.md:151
msgid ""
"Record patterns provide a good example of an interesting feature of the "
"PureScript type system: _row polymorphism_. Suppose we had defined "
"`showPerson` without a type signature above. What would its inferred type "
"have been? Interestingly, it is not the same as the type we gave:"
msgstr ""
"レコードパターンはPureScriptの型システムの興味深い機能である\n"
"**行多相** (row polymorphism) の良い例となっています。\n"
"もし上の`showPerson`を型シグネチャなしで定義していたとすると、\n"
"この型はどのように推論されるのでしょうか？\n"
"面白いことに、推論される型は上で与えた型とは同じではありません。"

#. type: Fenced code block (text)
#: text/chapter5.md:152
#, no-wrap
msgid ""
"> showPerson { first: x, last: y } = y <> \", \" <> x\n"
"\n"
"> :type showPerson\n"
"forall r. { first :: String, last :: String | r } -> String\n"
msgstr ""
"> showPerson { first: x, last: y } = y <> \", \" <> x\n"
"\n"
"> :type showPerson\n"
"forall r. { first :: String, last :: String | r } -> String\n"

#. type: Plain text
#: text/chapter5.md:160
msgid ""
"What is the type variable `r` here? Well, if we try `showPerson` in PSCi, we "
"see something interesting:"
msgstr ""
"この型変数 `r`とは何でしょうか？\n"
"PSCiで `showPerson`を使ってみると、面白いことがわかります。"

#. type: Fenced code block (text)
#: text/chapter5.md:161
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\", last: \"Freeman\" }\n"
"\"Freeman, Phil\"\n"
"\n"
"> showPerson { first: \"Phil\", last: \"Freeman\", location: \"Los Angeles\" }\n"
"\"Freeman, Phil\"\n"
msgstr ""
"> showPerson { first: \"Phil\", last: \"Freeman\" }\n"
"\"Freeman, Phil\"\n"
"\n"
"> showPerson { first: \"Phil\", last: \"Freeman\", location: \"Los Angeles\" }\n"
"\"Freeman, Phil\"\n"

#. type: Plain text
#: text/chapter5.md:170
msgid ""
"We are able to append additional fields to the record, and the `showPerson` "
"function will still work. As long as the record contains the `first` and "
"`last` fields of type `String`, the function application is well-typed. "
"However, it is _not_ valid to call `showPerson` with too _few_ fields:"
msgstr ""
"レコードにそれ以外のフィールドが追加されていても、\n"
"`showPerson`関数はそのまま動作するのです。\n"
"型が `String`であるようなフィールド `first`と `last`がレコードに少なくとも含まれていれば、\n"
"関数適用は正しく型付けされます。\n"
"しかし、フィールドが**不足**していると、 `showPerson`の呼び出しは**不正**となります。"

#. type: Fenced code block (text)
#: text/chapter5.md:171
#, no-wrap
msgid ""
"> showPerson { first: \"Phil\" }\n"
"\n"
"Type of expression lacks required label \"last\"\n"
msgstr ""
"> showPerson { first: \"Phil\" }\n"
"\n"
"Type of expression lacks required label \"last\"\n"

#. type: Plain text
#: text/chapter5.md:178
msgid ""
"We can read the new type signature of `showPerson` as \"takes any record "
"with `first` and `last` fields which are `Strings` _and any other fields_, "
"and returns a `String`\". This function is polymorphic in the _row_ `r` of "
"record fields, hence the name _row polymorphism_.  Note that this behavior "
"is different than that of the original `showPerson`. Without the row "
"variable `r`, `showPerson` only accepts records with _exactly_ a `first` and "
"`last` field and no others."
msgstr ""
"`showPerson`の新しい型シグネチャを読むとこうです。\n"
"「`String`な`first`と`last`フィールド**と他のフィールドを何でも**持つあらゆるレコードを取り、\n"
"`String`を返す。」\n"
"なお、この振舞いは元の`showPerson`のものとは異なります。\n"
"行変数`r`がなければ`showPerson`は**厳密に**`first`と`last`フィールドしかないレコードのみを受け付けます。"

#. type: Plain text
#: text/chapter5.md:180
msgid "Note that we could have also written"
msgstr "次のように書くことができることにも注意してください。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:181
#, no-wrap
msgid "> showPerson p = p.last <> \", \" <> p.first\n"
msgstr "> showPerson p = p.last <> \", \" <> p.first\n"

#. type: Plain text
#: text/chapter5.md:186
msgid "and PSCi would have inferred the same type."
msgstr "この場合も、 PSCiは先ほどと同じ型を推論するでしょう。"

#. type: Title ##
#: text/chapter5.md:187
#, no-wrap
msgid "Record Puns"
msgstr "レコード同名利用"

#. type: Plain text
#: text/chapter5.md:190
msgid ""
"Recall that the `showPerson` function matches a record inside its argument, "
"binding the `first` and `last` fields to values named `x` and `y`. We could "
"alternatively just reuse the field names themselves, and simplify this sort "
"of pattern match as follows:"
msgstr ""
"`showPerson`関数は引数内のレコードと一致し、\n"
"`first`と`last`フィールドを`x`と `y`という名前の値に束縛していたのでした。\n"
"別の方法として、フィールド名自体を再利用するだけで、このようなパターン一致を次のように単純化できます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:191
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPersonV2}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:showPersonV2}}\n"

#. type: Plain text
#: text/chapter5.md:196
msgid ""
"Here, we only specify the names of the fields, and we do not need to specify "
"the names of the values we want to introduce. This is called a _record pun_."
msgstr ""
"ここでは、プロパティの名前のみを指定し、名前に導入したい値を指定する必要はありません。\n"
"これは**レコード同名利用** (record pun) と呼ばれます。"

#. type: Plain text
#: text/chapter5.md:198
msgid ""
"It is also possible to use record puns to _construct_ records. For example, "
"if we have values named `first` and `last` in scope, we can construct a "
"person record using `{ first, last }`:"
msgstr ""
"レコード同名利用をレコードの**構築**に使用することもできます。\n"
"例えば、スコープ内に `first`と `last`という名前の値があれば、\n"
"`{ first, last }`を使って人物レコードを作ることができます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:199
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:unknownPerson}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:unknownPerson}}\n"

#. type: Plain text
#: text/chapter5.md:204
msgid "This may improve readability of code in some circumstances."
msgstr "これは、状況によってはコードの可読性を向上させるのに役立ちます。"

#. type: Title ##
#: text/chapter5.md:205
#, no-wrap
msgid "Nested Patterns"
msgstr "入れ子になったパターン"

#. type: Plain text
#: text/chapter5.md:208
msgid ""
"Array patterns and record patterns both combine smaller patterns to build "
"larger patterns. For the most part, the examples above have only used simple "
"patterns inside array patterns and record patterns, but it is important to "
"note that patterns can be arbitrarily _nested_, which allows functions to be "
"defined using conditions on potentially complex data types."
msgstr ""
"配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大きなパターンを構成しています。\n"
"これまでの例ではほとんどの場合で配列パターンとレコードパターンの内部に単純なパターンを使用していましたが、\n"
"パターンが自由に**入れ子**にすることができることも知っておくのが大切です。\n"
"入れ子になったパターンを使うと、\n"
"潜在的に複雑なデータ型に対しての条件分岐を用いて関数を定義できるようになります。"

#. type: Plain text
#: text/chapter5.md:210
msgid "For example, this code combines two record patterns:"
msgstr "たとえば、このコードは2つのレコードパターンを結合します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:211
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:livesInLA}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:livesInLA}}\n"

#. type: Title ##
#: text/chapter5.md:215
#, no-wrap
msgid "Named Patterns"
msgstr "名前付きパターン"

#. type: Plain text
#: text/chapter5.md:218
msgid ""
"Patterns can be _named_ to bring additional names into scope when using "
"nested patterns. Any pattern can be named by using the `@` symbol."
msgstr ""
"入れ子のパターンを使う場合、パターンには**名前を付け**て追加で名前をスコープに持ち込むことができます。\n"
"任意のパターンに名前を付けるには、 `@`記号を使います。"

#. type: Plain text
#: text/chapter5.md:220
msgid ""
"For example, this function sorts two-element arrays, naming the two "
"elements, but also naming the array itself:"
msgstr ""
"たとえば、次の関数は2要素配列を整列するもので、2つの要素の名前を付けていますが、\n"
"配列自身にも名前を付けています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:221
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:sortPair}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:sortPair}}\n"

#. type: Plain text
#: text/chapter5.md:226
msgid ""
"This way, we save ourselves from allocating a new array if the pair is "
"already sorted. Note that if the input array does not contain _exactly_ two "
"elements, then this function simply returns it unchanged, even if it's "
"unsorted."
msgstr ""
"このようにすれば対が既に整列されているときに新しい配列を割り当てなくて済みます。\n"
"なおもし入力の配列が**厳密に**2つの要素を含んでいなければ、\n"
"たとえ整列されていなかったとしても、この関数は単に元のまま変えずに返しています。"

#. type: Bullet: '1. '
#: text/chapter5.md:232
msgid ""
"(Easy) Write a function `sameCity` which uses record patterns to test "
"whether two `Person` records belong to the same city."
msgstr ""
"（簡単）レコードパターンを使って、\n"
"2つの `Person`レコードが同じ都市にいるか探す関数 `sameCity`を定義してみましょう。"

#. type: Bullet: '1. '
#: text/chapter5.md:232
msgid ""
"(Medium) What is the most general type of the `sameCity` function, taking "
"into account row polymorphism? What about the `livesInLA` function defined "
"above? _Note_: There is no test for this exercise."
msgstr ""
"（やや難しい）行多相を考慮すると、 `sameCity`関数の最も一般的な型は何でしょうか？\n"
"先ほど定義した `livesInLA`関数についてはどうでしょうか？\n"
"**補足**：この演習にテストはありません。"

#. type: Bullet: '1. '
#: text/chapter5.md:232
msgid ""
"(Medium) Write a function `fromSingleton` which uses an array literal "
"pattern to extract the sole member of a singleton array. If the array is not "
"a singleton, your function should return a provided default value. Your "
"function should have type `forall a. a -> Array a -> a`"
msgstr ""
"（やや難しい）配列リテラルパターンを使って、\n"
"1要素の配列の唯一のメンバーを抽出する関数`fromSingleton`を書いてみましょう。\n"
"1要素だけを持つ配列でない場合、\n"
"関数は指定されたデフォルト値を返さなければなりません。\n"
"この関数は `forall a. a -> Array a -> a`という型を持っていなければなりません。"

#. type: Title ##
#: text/chapter5.md:233
#, no-wrap
msgid "Case Expressions"
msgstr "Case式"

#. type: Plain text
#: text/chapter5.md:236
msgid ""
"Patterns do not only appear in top-level function declarations. It is "
"possible to use patterns to match on an intermediate value in a computation, "
"using a `case` expression. Case expressions provide a similar type of "
"utility to anonymous functions: it is not always desirable to give a name to "
"a function, and a `case` expression allows us to avoid naming a function "
"just because we want to use a pattern."
msgstr ""
"パターンは最上位にある関数宣言だけに現れるわけではありません。\n"
"`case`式を使って計算の途中の値に対してパターン照合を使うことができます。\n"
"case式には無名関数に似た種類の便利さがあります。\n"
"関数に名前を与えることがいつも望ましいわけではないように、\n"
"パターン照合を使いたいためだけに関数に名前をつけるようなことを避けられるようになります。"

#. type: Plain text
#: text/chapter5.md:238
msgid ""
"Here is an example. This function computes \"longest zero suffix\" of an "
"array (the longest suffix which sums to zero):"
msgstr ""
"例を示しましょう。\n"
"次の関数は、配列の「最長ゼロ末尾」（和がゼロであるような、最も長い配列の末尾）を計算します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:239
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzsImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzs}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzsImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:lzs}}\n"

#. type: Fenced code block (text)
#: text/chapter5.md:247
#, no-wrap
msgid ""
"> lzs [1, 2, 3, 4]\n"
"[]\n"
"\n"
"> lzs [1, -1, -2, 3]\n"
"[-1, -2, 3]\n"
msgstr ""
"> lzs [1, 2, 3, 4]\n"
"[]\n"
"\n"
"> lzs [1, -1, -2, 3]\n"
"[-1, -2, 3]\n"

#. type: Plain text
#: text/chapter5.md:256
msgid ""
"This function works by case analysis. If the array is empty, our only option "
"is to return an empty array. If the array is non-empty, we first use a "
"`case` expression to split into two cases. If the sum of the array is zero, "
"we return the whole array. If not, we recurse on the tail of the array."
msgstr ""
"この関数は場合ごとの分析によって動作します。\n"
"もし配列が空なら、唯一の選択肢は空の配列を返すことです。\n"
"配列が空でない場合は、さらに2つの場合に分けるためにまず `case`式を使用します。\n"
"配列の合計がゼロであれば、配列全体を返します。\n"
"そうでなければ、配列の残りに対して再帰します。"

#. type: Title ##
#: text/chapter5.md:257
#, no-wrap
msgid "Pattern Match Failures and Partial Functions"
msgstr "パターン照合の失敗と部分関数"

#. type: Plain text
#: text/chapter5.md:260
msgid ""
"If patterns in a case expression are tried in order, then what happens in "
"the case when none of the patterns in a case alternatives match their "
"inputs? In this case, the case expression will fail at runtime with a "
"_pattern match failure_."
msgstr ""
"case式のパターンを順番に照合していって、\n"
"もし選択肢のいずれの場合も入力が適合しなかった時は何が起こるのでしょうか？\n"
"この場合、**パターン照合失敗**によって、case式は実行時に失敗します。"

#. type: Plain text
#: text/chapter5.md:262
msgid "We can see this behavior with a simple example:"
msgstr "簡単な例でこの動作を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:263
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:unsafePartialImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:partialFunction}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:unsafePartialImport}}\n"
"\n"
"{{#include ../exercises/chapter5/src/ChapterExamples.purs:partialFunction}}\n"

#. type: Plain text
#: text/chapter5.md:270
msgid ""
"This function contains only a single case, which only matches a single "
"input, `true`. If we compile this file, and test in PSCi with any other "
"argument, we will see an error at runtime:"
msgstr ""
"この関数は単一の場合しか含んでおらず、その場合では単一の入力である`true`にのみ照合します。\n"
"このファイルをコンパイルして PSCiでそれ以外の値を与えてテストすると、実行時エラーが発生します。"

#. type: Fenced code block (text)
#: text/chapter5.md:271
#, no-wrap
msgid ""
"> partialFunction false\n"
"\n"
"Failed pattern match\n"
msgstr ""
"> partialFunction false\n"
"\n"
"Failed pattern match\n"

#. type: Plain text
#: text/chapter5.md:278
msgid ""
"Functions which return a value for any combination of inputs are called "
"_total_ functions, and functions which do not are called _partial_."
msgstr ""
"どんな入力の組み合わせに対しても値を返すような関数は**全関数** (total function) と呼ばれ、\n"
"そうでない関数は**部分的** (partial) であると呼ばれます。"

#. type: Plain text
#: text/chapter5.md:280
msgid ""
"It is generally considered better to define total functions where possible. "
"If it is known that a function does not return a result for some valid set "
"of inputs, it is usually better to return a value capable of indicating "
"failure, such as type `Maybe a` for some `a`, using `Nothing` when it cannot "
"return a valid result. This way, the presence or absence of a value can be "
"indicated in a type-safe way."
msgstr ""
"一般的には、可能な限り全関数として定義したほうが良いと考えられています。\n"
"もし関数が何らかの妥当な入力の集合について結果を返さないことがわかっているなら、\n"
"大抵は失敗であることを示すことができる値を返すほうがよいでしょう。\n"
"例えば何らかの`a`についての型`Maybe a`で、妥当な結果を返せないときは`Nothing`を使います。\n"
"この方法なら、型安全な方法で値の有無を示すことができます。"

#. type: Plain text
#: text/chapter5.md:282
msgid ""
"The PureScript compiler will generate an error if it can detect that your "
"function is not total due to an incomplete pattern match. The "
"`unsafePartial` function can be used to silence these errors (if you are "
"sure that your partial function is safe!) If we removed the call to the "
"`unsafePartial` function above, then the compiler would generate the "
"following error:"
msgstr ""
"PureScriptコンパイラは、\n"
"パターンマッチが不完全で関数が全関数ではないことを検出するとエラーを生成します。\n"
"部分関数が安全である場合、\n"
"`unsafePartial`関数を使ってこれらのエラーを抑制することができます。\n"
"（その部分関数が安全だと言い切れるなら！）\n"
"もし上記の `unsafePartial`関数の呼び出しを取り除くと、コンパイラは次のエラーを生成します。"

#. type: Fenced code block (text)
#: text/chapter5.md:283
#, no-wrap
msgid ""
"A case expression could not be determined to cover all inputs.\n"
"The following additional cases are required to cover all inputs:\n"
"\n"
"  false\n"
msgstr ""
"A case expression could not be determined to cover all inputs.\n"
"The following additional cases are required to cover all inputs:\n"
"\n"
"  false\n"

#. type: Plain text
#: text/chapter5.md:291
msgid ""
"This tells us that the value `false` is not matched by any pattern. In "
"general, these warnings might include multiple unmatched cases."
msgstr ""
"これは値`false`が、定義されたどのパターンとも一致しないことを示しています。\n"
"一般的にこれらの警告には、複数の不一致のケースが含まれることがあります。"

#. type: Plain text
#: text/chapter5.md:293
msgid "If we also omit the type signature above:"
msgstr "上記の型シグネチャも省略した場合は、次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:294
#, no-wrap
msgid "partialFunction true = true\n"
msgstr "partialFunction true = true\n"

#. type: Plain text
#: text/chapter5.md:299
msgid "then PSCi infers a curious type:"
msgstr "このとき、PSCiは興味深い型を推論します｡"

#. type: Fenced code block (text)
#: text/chapter5.md:300
#, no-wrap
msgid ""
"> :type partialFunction\n"
"\n"
"Partial => Boolean -> Boolean\n"
msgstr ""
"> :type partialFunction\n"
"\n"
"Partial => Boolean -> Boolean\n"

#. type: Plain text
#: text/chapter5.md:307
#, no-wrap
msgid "We will see more types which involve the `=>` symbol later on in the book (they are related to _type classes_), but for now, it suffices to observe that PureScript keeps track of partial functions using the type system, and that we must explicitly tell the type checker when they are safe.\n"
msgstr ""
"本書ではのちに`=>`記号を含むいろいろな型を見ることになります。\n"
"（これらは**型クラス**に関連しています。）\n"
"しかし、今のところは、PureScriptは型システムを使って部分関数を追跡していることと、\n"
"安全な場合に型検証器に明示する必要があることを確認すれば十分です。\n"

#. type: Plain text
#: text/chapter5.md:309
msgid ""
"The compiler will also generate a warning in certain cases when it can "
"detect that cases are _redundant_ (that is, a case only matches values which "
"would have been matched by a prior case):"
msgstr ""
"コンパイラは、定義されたパターンが**冗長**であることを検出した場合\n"
"（前の方に定義されたパターンに一致するケースのみ）でも警告を生成します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:310
#, no-wrap
msgid ""
"redundantCase :: Boolean -> Boolean\n"
"redundantCase true = true\n"
"redundantCase false = false\n"
"redundantCase false = false\n"
msgstr ""
"redundantCase :: Boolean -> Boolean\n"
"redundantCase true = true\n"
"redundantCase false = false\n"
"redundantCase false = false\n"

#. type: Plain text
#: text/chapter5.md:318
msgid "In this case, the last case is correctly identified as redundant:"
msgstr "このとき、最後のケースは冗長であると正しく検出されます。"

#. type: Fenced code block (text)
#: text/chapter5.md:319
#, no-wrap
msgid ""
"A case expression contains unreachable cases:\n"
"\n"
"  false\n"
msgstr ""
"A case expression contains unreachable cases:\n"
"\n"
"  false\n"

#. type: Plain text
#: text/chapter5.md:326
msgid ""
"_Note_: PSCi does not show warnings, so to reproduce this example, you will "
"need to save this function as a file and compile it using `spago build`."
msgstr ""
"**注意**：PSCiは警告を表示しないので、\n"
"この例を再現するには、この関数をファイルとして保存し、 `pulp build`を使ってコンパイルします。"

#. type: Title ##
#: text/chapter5.md:327
#, no-wrap
msgid "Algebraic Data Types"
msgstr "代数的データ型"

#. type: Plain text
#: text/chapter5.md:330
msgid ""
"This section will introduce a feature of the PureScript type system called "
"_Algebraic Data Types_ (or _ADTs_), which are fundamentally related to "
"pattern matching."
msgstr ""
"この節では**代数的データ型** (algebraic data type, ADT) と呼ばれる、\n"
"PureScriptの型システムの機能を導入します。\n"
"この機能はパターン照合と地続きの関係があります。"

#. type: Plain text
#: text/chapter5.md:332
msgid ""
"However, we'll first consider a motivating example, which will provide the "
"basis of a solution to this chapter's problem of implementing a simple "
"vector graphics library."
msgstr ""
"しかしまずは切り口となる例について考えていきます。\n"
"この例では単純なベクターグラフィックスライブラリの実装というこの章の課題を解決する基礎を提供します。"

#. type: Plain text
#: text/chapter5.md:334
msgid ""
"Suppose we wanted to define a type to represent some simple shapes: lines, "
"rectangles, circles, text, etc. In an object oriented language, we would "
"probably define an interface or abstract class `Shape`, and one concrete "
"subclass for each type of shape that we wanted to be able to work with."
msgstr ""
"直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとします。\n"
"オブジェクト指向言語では、おそらくインタフェースもしくは抽象クラス `Shape`を定義し、\n"
"使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。"

#. type: Plain text
#: text/chapter5.md:336
msgid ""
"However, this approach has one major drawback: to work with `Shape`s "
"abstractly, it is necessary to identify all of the operations one might wish "
"to perform, and to define them on the `Shape` interface. It becomes "
"difficult to add new operations without breaking modularity."
msgstr ""
"しかしながら、この方針は大きな欠点をひとつ抱えています。\n"
"`Shape`を抽象的に扱うためには、実行したいと思う可能性のあるすべての操作を事前に把握し、\n"
"`Shape`インタフェースに定義する必要があるのです。\n"
"このため、モジュール性を壊さずに新しい操作を追加することが難しくなります。"

#. type: Plain text
#: text/chapter5.md:338
msgid ""
"Algebraic data types provide a type-safe way to solve this sort of problem, "
"if the set of shapes is known in advance. It is possible to define new "
"operations on `Shape` in a modular way, and still maintain type-safety."
msgstr ""
"もし図形の種類が事前にわかっているなら、\n"
"代数的データ型はこうした問題を解決する型安全な方法を提供します。\n"
"モジュール性のある方法で `Shape`に新たな操作を定義し、\n"
"型安全性が維持できます。"

#. type: Plain text
#: text/chapter5.md:340
msgid "Here is how `Shape` might be represented as an algebraic data type:"
msgstr "代数的データ型としてどのように`Shape`が表現されるかを次に示します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:341
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Shape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Point}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Shape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:Point}}\n"

#. type: Plain text
#: text/chapter5.md:348
msgid ""
"This declaration defines `Shape` as a sum of different constructors, and for "
"each constructor identifies the data that is included. A `Shape` is either a "
"`Circle` which contains a center `Point` and a radius (a number), or a "
"`Rectangle`, or a `Line`, or `Text`. There are no other ways to construct a "
"value of type `Shape`."
msgstr ""
"この宣言では`Shape`をそれぞれの構築子の和として定義しており、\n"
"各構築子では含まれるデータを指定します。\n"
"`Shape`は、中央 `Point`と半径（数値）を持つ `Circle`か、\n"
"`Rectangle`、 `Line`、 `Text`のいずれかです。\n"
"他には `Shape`型の値を構築する方法はありません。"

#. type: Plain text
#: text/chapter5.md:350
msgid ""
"An algebraic data type is introduced using the `data` keyword, followed by "
"the name of the new type and any type arguments. The type's constructors (i."
"e. its _data constructors_) are defined after the equals symbol, and are "
"separated by pipe characters (`|`). The data carried by an ADT's "
"constructors doesn't have to be restricted to primitive types: constructors "
"can include records, arrays, or even other ADTs."
msgstr ""
"代数的データ型の定義はキーワード `data`から始まり、\n"
"それに新しい型の名前と任意個の型引数が続きます。\n"
"その型の構築子（あるいは**データ構築子** (data constructor)）は等号の後に定義され、\n"
"パイプ文字 (`|`) で区切られます。\n"
"ADTの構築子が持つデータは原始型に限りません。\n"
"構築子にはレコード、配列、また他のADTさえも含むことができます。"

#. type: Plain text
#: text/chapter5.md:352
msgid ""
"Let's see another example from PureScript's standard libraries. We saw the "
"`Maybe` type, which is used to define optional values, earlier in the book. "
"Here is its definition from the `maybe` package:"
msgstr ""
"それではPureScriptの標準ライブラリから別の例を見てみましょう。\n"
"オプショナルな値を定義するのに使われる `Maybe`型を本書の冒頭で扱いました。\n"
"`maybe`パッケージでは `Maybe`を次のように定義しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:353
#, no-wrap
msgid "data Maybe a = Nothing | Just a\n"
msgstr "data Maybe a = Nothing | Just a\n"

#. type: Plain text
#: text/chapter5.md:358
msgid ""
"This example demonstrates the use of a type parameter `a`. Reading the pipe "
"character as the word \"or\", its definition almost reads like English: \"a "
"value of type `Maybe a` is either `Nothing`, or `Just` a value of type `a`\"."
msgstr ""
"この例では型引数 `a`の使用方法を示しています。\n"
"パイプ文字を「または」と読むことにすると、\n"
"この定義は「 `Maybe a`型の値は、無い (`Nothing`) か、\n"
"またはただの (`Just`) 型 `a`の値だ」とほぼ英語のように読むことができます。"

#. type: Plain text
#: text/chapter5.md:360
msgid ""
"Note that we don't use the syntax `forall a.` anywhere in our data "
"definition. `forall` syntax is necessary for functions, but is not used when "
"defining ADTs with `data` or type aliases with `type`."
msgstr ""
"なおデータ定義のどこにも構文`forall a`を使っていません。\n"
"`forall`構文は関数には必須ですが、`data`によるADTや`type`での型別称を定義するときは使われません。"

#. type: Plain text
#: text/chapter5.md:362
msgid ""
"Data constructors can also be used to define recursive data structures. Here "
"is one more example, defining a data type of singly-linked lists of elements "
"of type `a`:"
msgstr ""
"データ構築子は再帰的なデータ構造を定義するために使用することもできます。\n"
"更に例を挙げると、要素が型 `a`の単方向連結リストのデータ型を定義はこのようになります。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:363
#, no-wrap
msgid "data List a = Nil | Cons a (List a)\n"
msgstr "data List a = Nil | Cons a (List a)\n"

#. type: Plain text
#: text/chapter5.md:368
msgid ""
"This example is taken from the `lists` package. Here, the `Nil` constructor "
"represents an empty list, and `Cons` is used to create non-empty lists from "
"a head element and a tail. Notice how the tail is defined using the data "
"type `List a`, making this a recursive data type."
msgstr ""
"この例は `lists`パッケージから持ってきました。\n"
"ここで `Nil`構築子は空のリストを表しており、\n"
"`Cons`は先頭となる要素と尾鰭から空でないリストを作成するために使われます。\n"
"`Cons`の2つ目のフィールドでデータ型 `List a`を使用しており、\n"
"再帰的なデータ型になっていることに注目してください。"

#. type: Title ##
#: text/chapter5.md:369
#, no-wrap
msgid "Using ADTs"
msgstr "ADTの使用"

#. type: Plain text
#: text/chapter5.md:372
msgid ""
"It is simple enough to use the constructors of an algebraic data type to "
"construct a value: simply apply them like functions, providing arguments "
"corresponding to the data included with the appropriate constructor."
msgstr ""
"代数的データ型の構築子を使用して値を構築するのはとても簡単です。\n"
"対応する構築子に含まれるデータに応じた引数を用意し、\n"
"その構築子を単に関数のように適用するだけです。"

#. type: Plain text
#: text/chapter5.md:374
msgid ""
"For example, the `Line` constructor defined above required two `Point`s, so "
"to construct a `Shape` using the `Line` constructor, we have to provide two "
"arguments of type `Point`:"
msgstr ""
"例えば、上で定義した `Line`構築子は2つの `Point`を必要としていますので、\n"
"`Line`構築子を使って `Shape`を構築するには、\n"
"型 `Point`のふたつの引数を与えなければなりません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:375
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:exampleLine}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:exampleLine}}\n"

#. type: Plain text
#: text/chapter5.md:380
msgid ""
"So, constructing values of algebraic data types is simple, but how do we use "
"them? This is where the important connection with pattern matching appears: "
"the only way to consume a value of an algebraic data type is to use a "
"pattern to match its constructor."
msgstr ""
"さて、代数的データ型で値を構築することは簡単ですが、\n"
"これをどうやって使ったらよいのでしょうか？\n"
"ここで代数的データ型とパターン照合との重要な接点が見えてきます。\n"
"代数的データ型の値を消費する唯一の方法は構築子に照合するパターンを使うことです。"

#. type: Plain text
#: text/chapter5.md:382
msgid ""
"Let's see an example. Suppose we want to convert a `Shape` into a `String`. "
"We have to use pattern matching to discover which constructor was used to "
"construct the `Shape`. We can do this as follows:"
msgstr ""
"例を見てみましょう。\n"
"`Shape`を `String`に変換したいとします。\n"
"`Shape`を構築するのにどの構築子が使用されたかを調べるには、\n"
"パターン照合を使用しなければなりません。\n"
"これには次のようにします。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:383
#, no-wrap
msgid ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showShape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showPoint}}\n"
msgstr ""
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showShape}}\n"
"\n"
"{{#include ../exercises/chapter5/src/Data/Picture.purs:showPoint}}\n"

#. type: Plain text
#: text/chapter5.md:390
msgid ""
"Each constructor can be used as a pattern, and the arguments to the "
"constructor can themselves be bound using patterns of their own. Consider "
"the first case of `showShape`: if the `Shape` matches the `Circle` "
"constructor, then we bring the arguments of `Circle` (center and radius) "
"into scope using two variable patterns, `c` and `r`. The other cases are "
"similar."
msgstr ""
"各構築子はパターンとして使用することができ、\n"
"構築子への引数はそのパターンで束縛することができます。\n"
"`showShape`の最初の場合を考えてみましょう。\n"
"もし `Shape`が `Circle`構築子適合した場合、\n"
"2つの変数パターン `c`と `r`を使って\n"
"`Circle`の引数（中心と半径）がスコープに導入されます。\n"
"その他の場合も同様です。"

#. type: Bullet: '1. '
#: text/chapter5.md:396
msgid ""
"(Easy) Write a function `circleAtOrigin` which constructs a `Circle` (of "
"type `Shape`) centered at the origin with radius `10.0`."
msgstr ""
"（簡単）`Circle`（型は`Shape`）を構築する関数`circleAtOrigin`を書いてください。\n"
"中心は原点にあり、半径は`10.0`です。"

#. type: Bullet: '1. '
#: text/chapter5.md:396
msgid ""
"(Medium) Write a function `doubleScaleAndCenter` which scales the size of a "
"`Shape` by a factor of `2.0` and centers it at the origin."
msgstr "（やや難しい）`Shape`を、原点を中心として`2.0`倍に拡大する関数`doubleScaleAndCenter`を書いてみましょう。"

#. type: Bullet: '1. '
#: text/chapter5.md:396
msgid ""
"(Medium) Write a function `shapeText` which extracts the text from a "
"`Shape`. It should return `Maybe String`, and use the `Nothing` constructor "
"if the input is not constructed using `Text`."
msgstr ""
"（やや難しい） `Shape`からテキストを抽出する関数`shapeText`を書いてください。\n"
"この関数は `Maybe String`を返しますが、\n"
"もし入力が `Text`を使用して構築されたのでなければ、返り値には `Nothing`構築子を使ってください。"

#. type: Title ##
#: text/chapter5.md:397
#, no-wrap
msgid "Newtypes"
msgstr "Newtype"

#. type: Plain text
#: text/chapter5.md:400
msgid ""
"There is a special case of algebraic data types, called _newtypes_. Newtypes "
"are introduced using the `newtype` keyword instead of the `data` keyword."
msgstr ""
"代数的データ型の特別な場合として、**newtype**と呼ばれるものがあります。\n"
"newtypeはキーワード `data`の代わりにキーワード `newtype`を使用して導入します。"

#. type: Plain text
#: text/chapter5.md:402
msgid ""
"Newtypes must define _exactly one_ constructor, and that constructor must "
"take _exactly one_ argument. That is, a newtype gives a new name to an "
"existing type. In fact, the values of a newtype have the same runtime "
"representation as the underlying type, so there is no runtime performance "
"overhead. They are, however, distinct from the point of view of the type "
"system. This gives an extra layer of type safety."
msgstr ""
"newtype宣言では**過不足なくひとつだけの**構築子を定義しなければならず、\n"
"その構築子は**過不足なくひとつだけの**引数を取る必要があります。\n"
"つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。\n"
"実際、newtypeの値は、元の型と同じ実行時表現を持ってるので、実行時性能のオーバーヘッドがありません。\n"
"しかし、これらは型システムの観点から区別されます。\n"
"これは型安全性の追加の層を提供するのです。"

#. type: Plain text
#: text/chapter5.md:404
msgid ""
"As an example, we might want to define newtypes as type-level aliases for "
"`Number`, to ascribe units like volts, amps, and ohms:"
msgstr ""
"例として、ボルト、アンペア、オームのような単位を表現するために、\n"
"`Number`の型レベルの別名を定義したくなる場合があるかもしれません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:405
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:electricalUnits}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:electricalUnits}}\n"

#. type: Plain text
#: text/chapter5.md:410
msgid "Then we define functions and values using these types:"
msgstr "それからこれらの型を使う関数と値を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:411
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:calculateCurrent}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:calculateCurrent}}\n"

#. type: Plain text
#: text/chapter5.md:416
msgid ""
"This prevents us from making silly mistakes, such as attempting to calculate "
"the current produced by _two_ lightbulbs _without_ a voltage source."
msgstr ""
"これによりつまらないミスを防ぐことができます。\n"
"例えば電源**なし**に**2つ**の電球により生み出される電流を計算しようとするなどです。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:417
#, no-wrap
msgid ""
"current :: Amp\n"
"current = calculateCurrent lightbulb lightbulb\n"
"{-\n"
"TypesDoNotUnify:\n"
"  current = calculateCurrent lightbulb lightbulb\n"
"                             ^^^^^^^^^\n"
"  Could not match type\n"
"    Ohm\n"
"  with type\n"
"    Volt\n"
"-}\n"
msgstr ""
"current :: Amp\n"
"current = calculateCurrent lightbulb lightbulb\n"
"{-\n"
"TypesDoNotUnify:\n"
"  current = calculateCurrent lightbulb lightbulb\n"
"                             ^^^^^^^^^\n"
"  Could not match type\n"
"    Ohm\n"
"  with type\n"
"    Volt\n"
"-}\n"

#. type: Plain text
#: text/chapter5.md:432
msgid ""
"If we instead just used `Number` without `newtype`, then the compiler can't "
"help us catch this mistake:"
msgstr "もし`newtype`なしに単に`Numebr`を使っていたら、コンパイラはこのミスを補足できません。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:433
#, no-wrap
msgid ""
"-- This also compiles, but is not as type safe.\n"
"calculateCurrent :: Number -> Number -> Number\n"
"calculateCurrent v r = v / r\n"
"\n"
"battery :: Number\n"
"battery = 1.5\n"
"\n"
"lightbulb :: Number\n"
"lightbulb = 500.0\n"
"\n"
"current :: Number\n"
"current = calculateCurrent lightbulb lightbulb -- uncaught mistake\n"
msgstr ""
"-- これもコンパイルできますが、型安全ではありません。\n"
"calculateCurrent :: Number -> Number -> Number\n"
"calculateCurrent v r = v / r\n"
"\n"
"battery :: Number\n"
"battery = 1.5\n"
"\n"
"lightbulb :: Number\n"
"lightbulb = 500.0\n"
"\n"
"current :: Number\n"
"current = calculateCurrent lightbulb lightbulb -- 補足されないミス\n"

#. type: Plain text
#: text/chapter5.md:449
msgid ""
"Note that while a newtype can only have a single constructor, and the "
"constructor must be of a single value, a newtype _can_ take any number of "
"type variables. For example, the following newtype would be a valid "
"definition (`err` and `a` are the type variables, and the `CouldError` "
"constructor expects a _single_ value of type `Either err a`):"
msgstr ""
"なお、newtypeは単一の構築子しかとれず、構築子は単一の値でなくてはなりませんが、\n"
"newtypeは任意の数の型変数を取ることが**できます**。\n"
"例えば以下のnewtypeは妥当な定義です。\n"
"（`err`と`a`は型変数で、`CouldError`構築子は型`Either err a`の**単一**の値を期待します。）"

#. type: Fenced code block (Haskell)
#: text/chapter5.md:450
#, no-wrap
msgid "newtype CouldError err a = CouldError (Either err a)\n"
msgstr "newtype CouldError err a = CouldError (Either err a)\n"

#. type: Plain text
#: text/chapter5.md:455
msgid ""
"Also note that the constructor of a newtype often has the same name as the "
"newtype itself, but this is not a requirement. For example, unique names are "
"also valid:"
msgstr ""
"また、newtypeの構築子はよくnewtype自身と同じ名前を持つことがあることにも注意してください。\n"
"ただこれは必須ではありません。\n"
"例えば固有の名前であっても妥当です。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:455
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/ChapterExamples.purs:Coulomb}}\n"
msgstr "{{#include ../exercises/chapter5/src/ChapterExamples.purs:Coulomb}}\n"

#. type: Plain text
#: text/chapter5.md:460
msgid ""
"In this case, `Coulomb` is the _type constructor_ (of zero arguments) and "
"`MakeCoulomb` is the _data constructor_. These constructors live in "
"different namespaces, even when the names are identical, such as with the "
"`Volt` example. This is true for all ADTs. Note that although the type "
"constructor and data constructor can have different names, in practice it is "
"idiomatic for them to share the same name. This is the case with `Amp` and "
"`Volt` types above."
msgstr ""
"この場合`Coulomb`は**型構築子**（引数はゼロ）で`MakeCoulomb`は**データ構築子**です。\n"
"これらの構築子は異なる名前空間に属しており、`Volt`の例でそうだったように、名前に一意性があります。\n"
"これは全てのADTについて言えることです。\n"
"なお、型構築子とデータ構築子は異なる名前を持つことができますが、\n"
"実際には同じ名前を共有するのが普通です。\n"
"上の`Amp`と`Volt`の場合がこれです。"

#. type: Plain text
#: text/chapter5.md:462
msgid ""
"Another application of newtypes is to attach different _behavior_ to an "
"existing type without changing its representation at runtime. We cover that "
"use case in the next chapter when we discuss _type classes_."
msgstr ""
"newtypeの別の応用は、実行時表現を変えることなく、既存の型に異なる**振舞い**を付加することです。\n"
"その利用例については次章で**型クラス**をお話しするときに押さえます。"

#. type: Bullet: '1. '
#: text/chapter5.md:466
msgid ""
"(Easy) Define `Watt` as a `newtype` of `Number`. Then define a "
"`calculateWattage` function using this new `Watt` type and the above "
"definitions `Amp` and `Volt`:"
msgstr ""
"（簡単）`Watt`を`Number`の`newtype`として定義してください。\n"
"それからこの新しい`Watt`型と上の`Amp`と`Volt`の定義を使って`calculateWattage`関数を定義してください。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:466
#, no-wrap
msgid "calculateWattage :: Amp -> Volt -> Watt\n"
msgstr "calculateWattage :: Amp -> Volt -> Watt\n"

#. type: Plain text
#: text/chapter5.md:470
msgid ""
"A wattage in `Watt`s can be calculated as the product of a given current in "
"`Amp`s and a given voltage in `Volt`s."
msgstr "`Watt`中のワット数は与えられた`Amp`中の電流と与えられた`Volt`の電圧の積で計算できます。"

#. type: Title ##
#: text/chapter5.md:471
#, no-wrap
msgid "A Library for Vector Graphics"
msgstr "ベクターグラフィックスライブラリ"

#. type: Plain text
#: text/chapter5.md:474
msgid ""
"Let's use the data types we have defined above to create a simple library "
"for using vector graphics."
msgstr "これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライブラリを作成していきましょう。"

#. type: Plain text
#: text/chapter5.md:476
msgid "Define a type synonym for a `Picture` - just an array of `Shape`s:"
msgstr "ただの `Shape`の配列であるような、 `Picture`という型同義語を定義しておきます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:477
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:Picture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:Picture}}\n"

#. type: Plain text
#: text/chapter5.md:482
msgid ""
"For debugging purposes, we'll want to be able to turn a `Picture` into "
"something readable. The `showPicture` function lets us do that:"
msgstr ""
"デバッグしていると `Picture`を `String`として表示できるようにしたくなることもあるでしょう。\n"
"これはパターン照合を使用して定義された `showPicture`関数で行うことができます。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:483
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:showPicture}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:showPicture}}\n"

#. type: Plain text
#: text/chapter5.md:488
msgid ""
"Let's try it out. Compile your module with `spago build` and open PSCi with "
"`spago repl`:"
msgstr ""
"試してみましょう。\n"
"モジュールを `spago build`でコンパイルし、 `spago repl`でPSCiを開きます。"

#. type: Fenced code block (text)
#: text/chapter5.md:489
#, fuzzy, no-wrap
msgid ""
"$ spago build\n"
"$ spago repl\n"
"\n"
"> import Data.Picture\n"
"\n"
"> showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]\n"
"\n"
"[\"Line [start: (0.0, 0.0), end: (1.0, 1.0)]\"]\n"
msgstr ""
"$ spago build\n"
"$ spago repl\n"
"\n"
"> import Data.Picture\n"
"\n"
"> showPicture [ Line { x: 0.0, y: 0.0 } { x: 1.0, y: 1.0 } ]\n"
"\n"
"[\"Line [start: (0.0, 0.0), end: (1.0, 1.0)]\"]\n"

#. type: Title ##
#: text/chapter5.md:500
#, no-wrap
msgid "Computing Bounding Rectangles"
msgstr "外接矩形の算出"

#. type: Plain text
#: text/chapter5.md:503
msgid ""
"The example code for this module contains a function `bounds` which computes "
"the smallest bounding rectangle for a `Picture`."
msgstr "このモジュールのコード例には、 `Picture`の最小外接矩形を計算する関数 `bounds`が含まれています。"

#. type: Plain text
#: text/chapter5.md:505
msgid "The `Bounds` type defines a bounding rectangle."
msgstr "`Bounds`型は外接矩形を定義します。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:506
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:Bounds}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:Bounds}}\n"

#. type: Plain text
#: text/chapter5.md:511
msgid ""
"`bounds` uses the `foldl` function from `Data.Foldable` to traverse the "
"array of `Shapes` in a `Picture`, and accumulate the smallest bounding "
"rectangle:"
msgstr ""
"`Picture`内の `Shape`の配列を走査し、最小の外接矩形を累積するため、\n"
"`bounds`は `Data.Foldable`の `foldl`関数を使用しています。"

#. type: Fenced code block (haskell)
#: text/chapter5.md:512
#, no-wrap
msgid "{{#include ../exercises/chapter5/src/Data/Picture.purs:bounds}}\n"
msgstr "{{#include ../exercises/chapter5/src/Data/Picture.purs:bounds}}\n"

#. type: Plain text
#: text/chapter5.md:517
msgid ""
"In the base case, we need to find the smallest bounding rectangle of an "
"empty `Picture`, and the empty bounding rectangle defined by `emptyBounds` "
"suffices."
msgstr ""
"基底の場合では、空の `Picture`の最小外接矩形を求める必要がありますが、\n"
"`emptyBounds`で定義される空の外接矩形がその条件を満たしています。"

#. type: Plain text
#: text/chapter5.md:519
msgid ""
"The accumulating function `combine` is defined in a `where` block. `combine` "
"takes a bounding rectangle computed from `foldl`'s recursive call, and the "
"next `Shape` in the array, and uses the `union` function to compute the "
"union of the two bounding rectangles. The `shapeBounds` function computes "
"the bounds of a single shape using pattern matching."
msgstr ""
"累積関数 `combine`は `where`ブロックで定義されています。\n"
"`combine`は `foldl`の再帰呼び出しで計算された外接矩形と、\n"
"配列内の次の `Shape`を引数にとり、\n"
"ユーザ定義の演算子 `union`を使ってふたつの外接矩形の和を計算しています。\n"
"`shapeBounds`関数は、パターン照合を使用して、単一の図形の外接矩形を計算します。"

#. type: Bullet: '1. '
#: text/chapter5.md:524
msgid ""
"(Medium) Extend the vector graphics library with a new operation `area` "
"which computes the area of a `Shape`. For the purpose of this exercise, the "
"area of a line or a piece of text is assumed to be zero."
msgstr ""
"（やや難しい） ベクターグラフィックライブラリを拡張し、\n"
"`Shape`の面積を計算する新しい操作 `area`を追加してください。\n"
"この演習では、テキストの面積は0であるものとしてください。"

#. type: Bullet: '1. '
#: text/chapter5.md:524
msgid ""
"(Difficult) Extend the `Shape` type with a new data constructor `Clipped`, "
"which clips another `Picture` to a rectangle. Extend the `shapeBounds` "
"function to compute the bounds of a clipped picture. Note that this makes "
"`Shape` into a recursive data type."
msgstr ""
"（難しい） `Shape`を拡張し、新しいデータ構築子 `Clipped`を追加してください。\n"
"`Clipped`は他の `Picture`を矩形に切り抜きます。\n"
"切り抜いてきた`Picture`の境界を計算できるよう、\n"
"`shapeBounds`関数を拡張してください。\n"
"なお、これにより`Shape`は再帰的なデータ型になります。"

#. type: Plain text
#: text/chapter5.md:528
msgid ""
"In this chapter, we covered pattern matching, a basic but powerful technique "
"from functional programming. We saw how to use simple patterns as well as "
"array and record patterns to match parts of deep data structures."
msgstr ""
"この章では、関数型プログラミングから基本だが強力なテクニックであるパターン照合を扱いました。\n"
"複雑なデータ構造の部分と照合するために、\n"
"簡単なパターンの使い方だけではなく、\n"
"配列パターンやレコードパターンを使った深いデータ構造の一部の照合方法を見てきました。"

#. type: Plain text
#: text/chapter5.md:530
msgid ""
"This chapter also introduced algebraic data types, which are closely related "
"to pattern matching. We saw how algebraic data types allow concise "
"descriptions of data structures, and provide a modular way to extend data "
"types with new operations."
msgstr ""
"またこの章では、パターン照合に密接に関連する代数的データ型を紹介しました。\n"
"代数的データ型のおかげでデータ構造を簡潔に記述することができ、\n"
"新たな操作でデータ型を拡張するためのモジュール性のある方法が提供されることを見てきました。"

#. type: Plain text
#: text/chapter5.md:532
msgid ""
"Finally, we covered _row polymorphism_, a powerful type of abstraction which "
"allows many idiomatic JavaScript functions to be given a type."
msgstr ""
"最後に強力な抽象化である**行多相**を扱いました。\n"
"これにより多くの既存のJavaScript関数に型を与えられます。"

#. type: Plain text
#: text/chapter5.md:533
msgid ""
"In the rest of the book, we will use ADTs and pattern matching extensively, "
"so it will pay dividends to become familiar with them now. Try creating your "
"own algebraic data types and writing functions to consume them using pattern "
"matching."
msgstr ""
"本書では今後も代数的データ型とパターン照合をいろんなところで使用するので、\n"
"今のうちにこれらに習熟しておくと後で実を結ぶことでしょう。\n"
"これ以外にも独自の代数的データ型を作成し、\n"
"パターン照合を使用してそれらを使う関数を書くことを試してみてください。"

#. type: Title #
#: text/chapter6.md:1
#, fuzzy, no-wrap
msgid "Type Classes"
msgstr "型クラス"

#. type: Plain text
#: text/chapter6.md:6
#, fuzzy
msgid ""
"This chapter will introduce a powerful form of abstraction which is enabled "
"by PureScript's type system - type classes."
msgstr ""
"この章では、PureScriptの型システムによって可能になる強力な抽象化の手法であ"
"る、型クラスを導入します。"

#. type: Plain text
#: text/chapter6.md:8
#, fuzzy
msgid ""
"This motivating example for this chapter will be a library for hashing data "
"structures. We will see how the machinery of type classes allow us to hash "
"complex data structures without having to think directly about the structure "
"of the data itself."
msgstr ""
"この章ではデータ構造をハッシュするためのライブラリを題材に説明していきます。"
"データ自身の構造について直接考えることなく複雑な構造のデータのハッシュ値を求"
"めるために、型クラスの仕組みがどのようにして働くのかを見ていきます。"

#. type: Plain text
#: text/chapter6.md:10
#, fuzzy
msgid ""
"We will also see a collection of standard type classes from PureScript's "
"Prelude and standard libraries. PureScript code leans heavily on the power "
"of type classes to express ideas concisely, so it will be beneficial to "
"familiarize yourself with these classes."
msgstr ""
"また、PureScriptのPreludeや標準ライブラリに含まれる、標準的な型クラスも見てい"
"きます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大き"
"く依存しているので、これらのクラスに慣れておくと役に立つでしょう。"

#. type: Plain text
#: text/chapter6.md:12
msgid ""
"If you come from an Object Oriented background, please note that the word "
"\"class\" means something _very_ different in this context than what you're "
"used to. A type class serves a purpose more similar to an OO interface."
msgstr ""

#. type: Plain text
#: text/chapter6.md:16
#, fuzzy
msgid ""
"The source code for this chapter is defined in the file `src/Data/Hashable."
"purs`."
msgstr ""
"この章のソースコードは、ファイル `src/data/Hashable.purs`で定義されています。"

#. type: Plain text
#: text/chapter6.md:24
#, fuzzy
msgid ""
"- `maybe`, which defines the `Maybe` data type, which represents optional "
"values.  - `tuples`, which defines the `Tuple` data type, which represents "
"pairs of values.  - `either`, which defines the `Either` data type, which "
"represents disjoint unions.  - `strings`, which defines functions which "
"operate on strings.  - `functions`, which defines some helper functions for "
"defining PureScript functions."
msgstr ""
"- `purescript-maybe`: オプショナルな値を表す `Maybe`データ型が定義されていま"
"す。 - `purescript-tuples`: 値の組を表す `Tuple`データ型が定義されています。 "
"- `purescript-either`: 非交和を表す `Either`データ型が定義されています。 - "
"`purescript-strings`: 文字列を操作する関数が定義されています。 - `purescript-"
"functions`: PureScriptの記述用の補助関数が定義されています。"

#. type: Plain text
#: text/chapter6.md:26
#, fuzzy
msgid ""
"The module `Data.Hashable` imports several modules provided by these "
"packages."
msgstr ""
"モジュール `Data.Hashable`では、これらのBowerパッケージによって提供されるモ"
"ジュールのいくつかをインポートしています。"

#. type: Title ##
#: text/chapter6.md:27
#, fuzzy, no-wrap
msgid "Show Me!"
msgstr "見せてください！(Show Me!)"

#. type: Plain text
#: text/chapter6.md:30
#, fuzzy
msgid ""
"Our first simple example of a type class is provided by a function we've "
"seen several times already: the `show` function, which takes a value and "
"displays it as a string."
msgstr ""
"型クラスの最初に扱う例は、すでに何回か見たことがある関数と関係しています。 "
"`show`は、何らかの値を取り、それを文字列として表示する関数です。"

#. type: Plain text
#: text/chapter6.md:32
#, fuzzy
msgid ""
"`show` is defined by a type class in the `Prelude` module called `Show`, "
"which is defined as follows:"
msgstr ""
"`show`は `Prelude`モジュールの `Show`と呼ばれる型クラスで次のように定義されて"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:33
#, fuzzy, no-wrap
msgid ""
"class Show a where\n"
"  show :: a -> String\n"
msgstr ""
"class Show a where\n"
"  show :: a -> String\n"

#. type: Plain text
#: text/chapter6.md:39
#, fuzzy
msgid ""
"This code declares a new _type class_ called `Show`, which is parameterized "
"by the type variable `a`."
msgstr ""
"このコードでは、型変数 `a`でパラメータ化された、 `Show`という新しい**型クラス"
"**(type class)を宣言しています。"

#. type: Plain text
#: text/chapter6.md:41
#, fuzzy
msgid ""
"A type class _instance_ contains implementations of the functions defined in "
"a type class, specialized to a particular type."
msgstr ""
"型クラス**インスタンス**には、型クラスで定義された関数の、その型に特殊化され"
"た実装が含まれています。"

#. type: Plain text
#: text/chapter6.md:43
#, fuzzy
msgid ""
"For example, here is the definition of the `Show` type class instance for "
"`Boolean` values, taken from the Prelude:"
msgstr ""
"例えば、Preludeにある `Boolean`値に対する `Show`型クラスインスタンスの定義は"
"次のとおりです。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:44
#, fuzzy, no-wrap
msgid ""
"instance showBoolean :: Show Boolean where\n"
"  show true = \"true\"\n"
"  show false = \"false\"\n"
msgstr ""
"instance showBoolean :: Show Boolean where\n"
"  show true = \"true\"\n"
"  show false = \"false\"\n"

#. type: Plain text
#: text/chapter6.md:51
#, fuzzy
msgid ""
"This code declares a type class instance called `showBoolean` - in "
"PureScript, type class instances can be named to aid the readability of the "
"generated JavaScript. We say that the `Boolean` type _belongs to the `Show` "
"type class_."
msgstr ""
"このコードは `showBool​​ean`という名前の型クラスのインスタンスを宣言します。 "
"PureScriptでは、生成されたJavaScriptの可読性を良くするために、型クラスインス"
"タンスに名前をつけます。このとき、**`Boolean`型は `Show`型クラスに属している"
"**といいます。"

#. type: Plain text
#: text/chapter6.md:53
#, fuzzy
msgid ""
"We can try out the `Show` type class in PSCi, by showing a few values with "
"different types:"
msgstr ""
"`PSCi`で、いろいろな型の値を`Show`型クラスを利用して表示してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:54
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> show true\n"
"\"true\"\n"
"\n"
"> show 1.0\n"
"\"1.0\"\n"
"\n"
"> show \"Hello World\"\n"
"\"\\\"Hello World\\\"\"\n"
msgstr ""
"> import Prelude\n"
"\n"
"> show true\n"
"\"true\"\n"
"\n"
"> show 1.0\n"
"\"1.0\"\n"
"\n"
"> show \"Hello World\"\n"
"\"\\\"Hello World\\\"\"\n"

#. type: Plain text
#: text/chapter6.md:68
#, fuzzy
msgid ""
"These examples demonstrate how to `show` values of various primitive types, "
"but we can also `show` values with more complicated types:"
msgstr ""
"この例ではさまざまなプリミティブ型の値を `show`しましたが、もっと複雑な型を持"
"つ値を `show`することもできます。"

#. type: Fenced code block (text)
#: text/chapter6.md:69
#, fuzzy, no-wrap
msgid ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"
msgstr ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"

#. type: Plain text
#: text/chapter6.md:82
msgid ""
"The output of `show` should be a string that you can paste back into the "
"repl (or `.purs` file) to recreate the item being shown. Here we'll use "
"`logShow`, which just calls `show` then `log`, to render the string without "
"quotes. Ignore the `unit` print - that will covered in Chapter 8 when we "
"examine `Effect`s, like `log`."
msgstr ""

#. type: Fenced code block (text)
#: text/chapter6.md:83
#, fuzzy, no-wrap
msgid ""
"> import Effect.Console\n"
"\n"
"> logShow (Tuple 1 true)\n"
"(Tuple 1 true)\n"
"unit\n"
"\n"
"> logShow (Just \"testing\")\n"
"(Just \"testing\")\n"
"unit\n"
msgstr ""
"> import Data.Tuple\n"
"\n"
"> show (Tuple 1 true)\n"
"\"(Tuple 1 true)\"\n"
"\n"
"> import Data.Maybe\n"
"\n"
"> show (Just \"testing\")\n"
"\"(Just \\\"testing\\\")\"\n"

#. type: Plain text
#: text/chapter6.md:96
#, fuzzy
msgid ""
"If we try to show a value of type `Data.Either`, we get an interesting error "
"message:"
msgstr ""
"型 `Data.Either`の値を表示しようとすると、興味深いエラーメッセージが表示され"
"ます。"

#. type: Fenced code block (text)
#: text/chapter6.md:97
#, fuzzy, no-wrap
msgid ""
"> import Data.Either\n"
"> show (Left 10)\n"
"\n"
"The inferred type\n"
"\n"
"    forall a. Show a => String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"> import Data.Either\n"
"> show (Left 10)\n"
"\n"
"The inferred type\n"
"\n"
"    forall a. Show a => String\n"
"\n"
"has type variables which are not mentioned in the body of the type.\n"
"Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:109
#, fuzzy
msgid ""
"The problem here is not that there is no `Show` instance for the type we "
"intended to `show`, but rather that PSCi was unable to infer the type. This "
"is indicated by the _unknown type_ `a` in the inferred type."
msgstr ""
"ここでの問題は `show`しようとしている型に対する `Show`インスタンスが存在しな"
"いということではなく、 `PSCi`がこの型を推論できなかったということです。このエ"
"ラーメッセージで**未知の型**`a`と表示されているのがそれです。"

#. type: Plain text
#: text/chapter6.md:111
#, fuzzy
msgid ""
"We can annotate the expression with a type, using the `::` operator, so that "
"PSCi can choose the correct type class instance:"
msgstr ""
"`::`演算子を使って式に対して型注釈を加えると、 `PSCi`が正しい型クラスインスタ"
"ンスを選ぶことができるようになります。"

#. type: Fenced code block (text)
#: text/chapter6.md:112
#, fuzzy, no-wrap
msgid ""
"> show (Left 10 :: Either Int String)\n"
"\"(Left 10)\"\n"
msgstr ""
"> show (Left 10 :: Either Int String)\n"
"\"(Left 10)\"\n"

#. type: Plain text
#: text/chapter6.md:118
#, fuzzy, no-wrap
msgid "Some types do not have a `Show` instance defined at all. One example of this is the function type `->`. If we try to `show` a function from `Int` to `Int`, we get an appropriate error message from the type checker:\n"
msgstr "`Show`インスタンスをまったく持っていない型もあります。関数の型 `->`がその一例です。 `Int`から `Int`への関数を `show`しようとすると、型検証器によってその通りのエラーメッセージが表示されます。\n"

#. type: Fenced code block (text)
#: text/chapter6.md:119
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"> show $ \\n -> n + 1\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Data.Show.Show (Int -> Int)\n"
msgstr ""
"> import Prelude\n"
"> show $ \\n -> n + 1\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Data.Show.Show (Int -> Int)\n"

#. type: Plain text
#: text/chapter6.md:129
msgid ""
"Type class instances can be defined in one of two places: in the same module "
"that the type class is defined, or in the same module that the type "
"\"belonging to\" the type class is defined. An instance defined in any other "
"spot is called an [\"orphan instance\"](https://github.com/purescript/"
"documentation/blob/master/language/Type-Classes.md#orphan-instances) and is "
"not allowed by the PureScript compiler. Some of the exercises in this "
"chapter will require you to copy the definition of a type into your "
"MySolutions module so that you can define type class instances for that type."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:133
msgid ""
"(Easy) Define a `Show` instance for `Point`. Match the same output as the "
"`showPoint` function from the previous chapter. _Note:_ Point is now a "
"`newtype` (instead of a `type` synonym), which allows us to customize how to "
"`show` it. Otherwise, we'd be stuck with the default `Show` instance for "
"records."
msgstr ""

#. type: Plain text
#: text/chapter6.md:137
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Point}}\n"
"    ```\n"
msgstr ""

#. type: Title ##
#: text/chapter6.md:138
#, fuzzy, no-wrap
msgid "Common Type Classes"
msgstr "標準的な型クラス"

#. type: Plain text
#: text/chapter6.md:141
#, fuzzy
msgid ""
"In this section, we'll look at some standard type classes defined in the "
"Prelude and standard libraries. These type classes form the basis of many "
"common patterns of abstraction in idiomatic PureScript code, so a basic "
"understanding of their functions is highly recommended."
msgstr ""
"この節では、Preludeや標準ライブラリで定義されている標準的な型クラスをいくつか"
"見ていきましょう。これらの型クラスはPureScript特有の抽象化の基礎としてあちこ"
"ちで使われているので、これらの関数の基本についてよく理解しておくことを強くお"
"勧めします。"

#. type: Title ###
#: text/chapter6.md:142
#, fuzzy, no-wrap
msgid "Eq"
msgstr "Eq型クラス"

#. type: Plain text
#: text/chapter6.md:145
#, fuzzy
msgid ""
"The `Eq` type class defines the `eq` function, which tests two values for "
"equality. The `==` operator is actually just an alias for `eq`."
msgstr ""
"`Eq`型クラスは、2つの値が等しいかどうかを調べる`eq`関数を定義しています。等値"
"演算子(`==`)は`eq`の別名にすぎません。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:146
#, fuzzy, no-wrap
msgid ""
"class Eq a where\n"
"  eq :: a -> a -> Boolean\n"
msgstr ""
"class Eq a where\n"
"  eq :: a -> a -> Boolean\n"

#. type: Plain text
#: text/chapter6.md:152
#, fuzzy
msgid ""
"Note that in either case, the two arguments must have the same type: it does "
"not make sense to compare two values of different types for equality."
msgstr ""
"異なる型の2つの値を比較しても意味がありませんから、いずれの演算子も2つの引数"
"が同じ型を持つ必要があることに注意してください。"

#. type: Plain text
#: text/chapter6.md:154
#, fuzzy
msgid "Try out the `Eq` type class in PSCi:"
msgstr "`PSCi`で `Eq`型クラスを試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:155
#, fuzzy, no-wrap
msgid ""
"> 1 == 2\n"
"false\n"
"\n"
"> \"Test\" == \"Test\"\n"
"true\n"
msgstr ""
"> 1 == 2\n"
"false\n"
"\n"
"> \"Test\" == \"Test\"\n"
"true\n"

#. type: Title ###
#: text/chapter6.md:163
#, fuzzy, no-wrap
msgid "Ord"
msgstr "Ord型クラス"

#. type: Plain text
#: text/chapter6.md:166
#, fuzzy, no-wrap
msgid "The `Ord` type class defines the `compare` function, which can be used to compare two values, for types which support ordering. The comparison operators `<` and `>` along with their non-strict companions `<=` and `>=`, can be defined in terms of `compare`.\n"
msgstr "`Ord`型クラスは順序付け可能な型に対して2つの値を比較する `compare`関数を定義します。 `compare`関数が定義されていると、比較演算子 `<`、 `>`と、その仲間 `<=`、 `>=`も定義されます。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:167
#, fuzzy, no-wrap
msgid ""
"data Ordering = LT | EQ | GT\n"
"\n"
"class Eq a <= Ord a where\n"
"  compare :: a -> a -> Ordering\n"
msgstr ""
"data Ordering = LT | EQ | GT\n"
"\n"
"class Eq a <= Ord a where\n"
"  compare :: a -> a -> Ordering\n"

#. type: Plain text
#: text/chapter6.md:175
#, fuzzy
msgid ""
"The `compare` function compares two values, and returns an `Ordering`, which "
"has three alternatives:"
msgstr ""
"`compare`関数は2つの値を比較して `Ordering`の3つの値のうちいずれかを返しま"
"す。"

#. type: Plain text
#: text/chapter6.md:179
#, fuzzy
msgid ""
"- `LT` - if the first argument is less than the second.  - `EQ` - if the "
"first argument is equal to the second.  - `GT` - if the first argument is "
"greater than the second."
msgstr ""
"- `LT`- 最初の引数が2番目の値より小さいとき - `EQ`- 最初の引数が2番目の値と等"
"しい(または比較できない)とき - `GT`- 最初の引数が2番目の値より大きいとき"

#. type: Plain text
#: text/chapter6.md:181
#, fuzzy
msgid "Again, we can try out the `compare` function in PSCi:"
msgstr "`compare`関数についても `PSCi`で試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:182
#, fuzzy, no-wrap
msgid ""
"> compare 1 2\n"
"LT\n"
"\n"
"> compare \"A\" \"Z\"\n"
"LT\n"
msgstr ""
"> compare 1 2\n"
"LT\n"
"\n"
"> compare \"A\" \"Z\"\n"
"LT\n"

#. type: Title ###
#: text/chapter6.md:190
#, fuzzy, no-wrap
msgid "Field"
msgstr "Field型クラス"

#. type: Plain text
#: text/chapter6.md:193
#, fuzzy
msgid ""
"The `Field` type class identifies those types which support numeric "
"operators such as addition, subtraction, multiplication and division. It is "
"provided to abstract over those operators, so that they can be reused where "
"appropriate."
msgstr ""
"`Field`型クラスは加算、減算、乗算、除算などの数値演算子を使用可能な型を示しま"
"す。必要に応じて再利用できるように、これらの演算子を抽象化するわけです。"

#. type: Plain text
#: text/chapter6.md:195
#, fuzzy
msgid ""
"_Note_: Just like the `Eq` and `Ord` type classes, the `Field` type class "
"has special support in the PureScript compiler, so that simple expressions "
"such as `1 + 2 * 3` get translated into simple JavaScript, as opposed to "
"function calls which dispatch based on a type class implementation."
msgstr ""
"**注意**: 関数呼び出しが型クラスの実装に基いて呼び出されるのとは対照的に、型"
"クラス `Eq`や `Ord`のクラスと同様に、 `Field`型のクラスはPureScriptでは特別に"
"扱われ、 `1 + 2 * 3`のような単純な式は単純なJavaScriptへと変換されます。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:196
#, fuzzy, no-wrap
msgid "class EuclideanRing a <= Field a\n"
msgstr "class EuclideanRing a <= Field a\n"

#. type: Plain text
#: text/chapter6.md:201
#, fuzzy
msgid ""
"The `Field` type class is composed from several more general _superclasses_. "
"This allows us to talk abstractly about types which support some but not all "
"of the `Field` operations. For example, a type of natural numbers would be "
"closed under addition and multiplication, but not necessarily under "
"subtraction, so that type might have an instance of the `Semiring` class "
"(which is a superclass of `Num`), but not an instance of `Ring` or `Field`."
msgstr ""
"`Field`型クラスは、いくつかのより抽象的な**上位クラス**(Super Class)が組み合"
"わさってできています。これは、その型は`Field`型クラスの操作をすべてを提供して"
"いるわけではないが、その一部を提供する、というように抽象的に説明することがで"
"きます。この型クラスは抽象的なすべてではないいくつかの数値演算子をサポートし"
"ています。例えば、自然数の型は加算および乗算については閉じていますが、減算に"
"ついては閉じていないため、この型は`Semiring`クラス(これは`Num`の上位クラスで"
"す)のインスタンスですが、`Ring`や`Field`のインスタンスではありません。"

#. type: Plain text
#: text/chapter6.md:203
#, fuzzy
msgid ""
"Superclasses will be explained later in this chapter, but the full [numeric "
"type class hierarchy](https://a-guide-to-the-purescript-numeric-hierarchy."
"readthedocs.io/en/latest/introduction.html) ([cheatsheet](https://harry."
"garrood.me/numeric-hierarchy-overview/)) is beyond the scope of this "
"chapter. The interested reader is encouraged to read the documentation for "
"the superclasses of `Field` in `prelude`."
msgstr ""
"上位クラスについては、この章の後半で詳しく説明します。しかし、すべての数値型"
"クラスの階層について述べるのはこの章の目的から外れているため、この内容に興味"
"のある読者は`purescript-prelude`内の `Field`に関するドキュメントを参照してく"
"ださい。"

#. type: Title ###
#: text/chapter6.md:204
#, fuzzy, no-wrap
msgid "Semigroups and Monoids"
msgstr "半群とモノイド"

#. type: Plain text
#: text/chapter6.md:207
#, fuzzy
msgid ""
"The `Semigroup` type class identifies those types which support an `append` "
"operation to combine two values:"
msgstr ""
"`Semigroup`(半群)型クラスは、連結演算子 `append`を提供する型を示します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:208
#, fuzzy, no-wrap
msgid ""
"class Semigroup a where\n"
"  append :: a -> a -> a\n"
msgstr ""
"class Semigroup a where\n"
"  append :: a -> a -> a\n"

#. type: Plain text
#: text/chapter6.md:214
#, fuzzy
msgid ""
"Strings form a semigroup under regular string concatenation, and so do "
"arrays. Several other standard instances are provided by the `prelude` "
"package."
msgstr ""
"普通の文字列連結について文字列は半群をなし、同様に配列も半群をなします。その"
"他の標準的なインスタンスの幾つかは、 `purescript-monoid`パッケージで提供され"
"ています。"

#. type: Plain text
#: text/chapter6.md:216
#, fuzzy, no-wrap
msgid "The `<>` concatenation operator, which we have already seen, is provided as an alias for `append`.\n"
msgstr "以前に見た `<>`連結演算子は、 `append`の別名として提供されています。\n"

#. type: Plain text
#: text/chapter6.md:218
#, fuzzy
msgid ""
"The `Monoid` type class (provided by the `prelude` package) extends the "
"`Semigroup` type class with the concept of an empty value, called `mempty`:"
msgstr ""
"`purescript-monoid`パッケージで提供されている `Monoid`型クラスは、 `mempty`と"
"呼ばれる空の値の概念で `Semigroup`型クラスを拡張します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:219
#, fuzzy, no-wrap
msgid ""
"class Semigroup m <= Monoid m where\n"
"  mempty :: m\n"
msgstr ""
"class Semigroup m <= Monoid m where\n"
"  mempty :: m\n"

#. type: Plain text
#: text/chapter6.md:225
#, fuzzy
msgid "Again, strings and arrays are simple examples of monoids."
msgstr "文字列や配列はモノイドの簡単な例になっています。"

#. type: Plain text
#: text/chapter6.md:227
#, fuzzy
msgid ""
"A `Monoid` type class instance for a type describes how to _accumulate_ a "
"result with that type, by starting with an \"empty\" value, and combining "
"new results. For example, we can write a function which concatenates an "
"array of values in some monoid by using a fold. In PSCi:"
msgstr ""
"`Monoid`型クラスインスタンスでは、「空」の値から始めて新たな値を合成してい"
"き、その型で**累積**した結果を返すにはどうするかを記述する型クラスです。例え"
"ば、畳み込みを使っていくつかのモノイドの値の配列を連結する関数を書くことがで"
"きます。 `PSCi`で試すと次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:228
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"> import Data.Monoid\n"
"> import Data.Foldable\n"
"\n"
"> foldl append mempty [\"Hello\", \" \", \"World\"]\n"
"\"Hello World\"\n"
"\n"
"> foldl append mempty [[1, 2, 3], [4, 5], [6]]\n"
"[1,2,3,4,5,6]\n"
msgstr ""
"> import Data.Monoid\n"
"> import Data.Foldable\n"
"\n"
"> foldl append mempty [\"Hello\", \" \", \"World\"]  \n"
"\"Hello World\"\n"
"\n"
"> foldl append mempty [[1, 2, 3], [4, 5], [6]]\n"
"[1,2,3,4,5,6]\n"

#. type: Plain text
#: text/chapter6.md:241
#, fuzzy
msgid ""
"The `prelude` package provides many examples of monoids and semigroups, "
"which we will use in the rest of the book."
msgstr ""
"`purescript-monoid`パッケージにはモノイドと半群の多くの例を提供しており、これ"
"らを本書で扱っていきます。"

#. type: Title ###
#: text/chapter6.md:242
#, fuzzy, no-wrap
msgid "Foldable"
msgstr "Foldable型クラス"

#. type: Plain text
#: text/chapter6.md:245
#, fuzzy
msgid ""
"If the `Monoid` type class identifies those types which act as the result of "
"a fold, then the `Foldable` type class identifies those type constructors "
"which can be used as the source of a fold."
msgstr ""
"`Monoid`型クラスは畳み込みの結果になるような型を示しますが、 `Foldable`型クラ"
"スは、畳み込みの元のデータとして使えるような型構築子を示しています。"

#. type: Plain text
#: text/chapter6.md:247
#, fuzzy
msgid ""
"The `Foldable` type class is provided in the `foldable-traversable` package, "
"which also contains instances for some standard containers such as arrays "
"and `Maybe`."
msgstr ""
"また、 `Foldable`型クラスは、配列や `Maybe`などのいくつかの標準的なコンテナの"
"インスタンスを含む `purescript-foldable-traversable`パッケージで提供されてい"
"ます。"

#. type: Plain text
#: text/chapter6.md:249
#, fuzzy
msgid ""
"The type signatures for the functions belonging to the `Foldable` class are "
"a little more complicated than the ones we've seen so far:"
msgstr ""
"`Foldable`クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し"
"複雑です。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:250
#, fuzzy, no-wrap
msgid ""
"class Foldable f where\n"
"  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n"
"  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n"
"  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n"
msgstr ""
"class Foldable f where\n"
"  foldr :: forall a b. (a -> b -> b) -> b -> f a -> b\n"
"  foldl :: forall a b. (b -> a -> b) -> b -> f a -> b\n"
"  foldMap :: forall a m. Monoid m => (a -> m) -> f a -> m\n"

#. type: Plain text
#: text/chapter6.md:258
#, fuzzy
msgid ""
"It is instructive to specialize to the case where `f` is the array type "
"constructor. In this case, we can replace `f a` with `Array a` for any a, "
"and we notice that the types of `foldl` and `foldr` become the types that we "
"saw when we first encountered folds over arrays."
msgstr ""
"この定義は `f`を配列の型構築子だと特殊化して考えてみるとわかりやすくなりま"
"す。この場合、すべての `a`について `f a`を `Array a`に置き換える事ができます"
"が、 `foldl`と `foldr`の型が、最初に見た配列に対する畳み込みの型になるとわか"
"ります。"

#. type: Plain text
#: text/chapter6.md:260
#, fuzzy, no-wrap
msgid "What about `foldMap`? Well, that becomes `forall a m. Monoid m => (a -> m) -> Array a -> m`. This type signature says that we can choose any type `m` for our result type, as long as that type is an instance of the `Monoid` type class. If we can provide a function which turns our array elements into values in that monoid, then we can accumulate over our array using the structure of the monoid, and return a single value.\n"
msgstr "`foldMap`についてはどうでしょうか？これは `forall a m. Monoid m => (a -> m) -> Array a -> m`になります。この型シグネチャは、型 `m`が `Monoid`型クラスのインスタンスであればどんな型でも返り値の型として選ぶことができると言っています。配列の要素をそのモノイドの値へと変換する関数を提供すれば、そのモノイドの構造を利用して配列を畳み込み、ひとつの値にして返すことができます。\n"

#. type: Plain text
#: text/chapter6.md:262
#, fuzzy
msgid "Let's try out `foldMap` in PSCi:"
msgstr "それでは `PSCi`で `foldMap`を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:263
#, fuzzy, no-wrap
msgid ""
"> import Data.Foldable\n"
"\n"
"> foldMap show [1, 2, 3, 4, 5]\n"
"\"12345\"\n"
msgstr ""
"> import Data.Foldable\n"
"\n"
"> foldMap show [1, 2, 3, 4, 5]\n"
"\"12345\"\n"

#. type: Plain text
#: text/chapter6.md:271
#, fuzzy
msgid ""
"Here, we choose the monoid for strings, which concatenates strings together, "
"and the `show` function which renders an `Int` as a `String`. Then, passing "
"in an array of integers, we see that the results of `show`ing each integer "
"have been concatenated into a single `String`."
msgstr ""
"ここではモノイドとして文字列を選び、 `Int`を文字列として表示する `show`関数を"
"使いました。それから、数の配列を渡し、それぞれの数を `show`してひとつの文字列"
"へと連結した結果出力されました。"

#. type: Plain text
#: text/chapter6.md:273
#, fuzzy
msgid ""
"But arrays are not the only types which are foldable. `foldable-traversable` "
"also defines `Foldable` instances for types like `Maybe` and `Tuple`, and "
"other libraries like `lists` define `Foldable` instances for their own data "
"types. `Foldable` captures the notion of an _ordered container_."
msgstr ""
"畳み込み可能な型は配列だけではありません。 `purescript-foldable-traversable`"
"では `Maybe`や `Tuple`のような型の `Foldable`インスタンスが定義されており、 "
"`purescript-lists`のような他のライブラリでは、そのライブラリのそれぞれのデー"
"タ型に対して `Foldable`インスタンスが定義されています。 `Foldable`は**順序付"
"きコンテナ**(ordered container)の概念を抽象化するのです。"

#. type: Title ###
#: text/chapter6.md:274
#, fuzzy, no-wrap
msgid "Functor, and Type Class Laws"
msgstr "関手と型クラス則"

#. type: Plain text
#: text/chapter6.md:277
#, fuzzy
msgid ""
"The Prelude also defines a collection of type classes which enable a "
"functional style of programming with side-effects in PureScript: `Functor`, "
"`Applicative` and `Monad`. We will cover these abstractions later in the "
"book, but for now, let's look at the definition of the `Functor` type class, "
"which we have seen already in the form of the `map` function:"
msgstr ""
"PureScriptで副作用を伴う関数型プログラミングのスタイルを可能にするための "
"`Functor`と `Applicative`、 `Monad`といった型クラスがPreludeでは定義されてい"
"ます。これらの抽象については本書で後ほど扱いますが、まずは「持ち上げ演算子」 "
"`map`の形ですでに見てきた `Functor`型クラスの定義を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:278
#, fuzzy, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
msgstr ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter6.md:284
#, fuzzy, no-wrap
msgid "The `map` function (and its alias `<$>`) allows a function to be \"lifted\" over a data structure. The precise definition of the word \"lifted\" here depends on the data structure in question, but we have already seen its behavior for some simple types:\n"
msgstr "演算子 `map`関数（別名`<$>`）は関数をそのデータ構造まで「持ち上げる」(lift)ことができます。ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、すでにいくつかの単純な型についてその動作を見てきました。\n"

#. type: Fenced code block (text)
#: text/chapter6.md:285
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> map (\\n -> n < 3) [1, 2, 3, 4, 5]\n"
"[true, true, false, false, false]\n"
"\n"
"> import Data.Maybe\n"
"> import Data.String (length)\n"
"\n"
"> map length (Just \"testing\")\n"
"(Just 7)\n"
msgstr ""
"> import Prelude\n"
"\n"
"> map (\\n -> n < 3) [1, 2, 3, 4, 5]\n"
"[true, true, false, false, false]\n"
"\n"
"> import Data.Maybe\n"
"> import Data.String (length)\n"
"\n"
"> map length (Just \"testing\")\n"
"(Just 7)\n"

#. type: Plain text
#: text/chapter6.md:299
#, fuzzy
msgid ""
"How can we understand the meaning of the `map` function, when it acts on "
"many different structures, each in a different way?"
msgstr ""
"`map`演算子は様々な構造の上でそれぞれ異なる振る舞いをしますが、 `map`演算子の"
"意味はどのように理解すればいいのでしょうか。"

#. type: Plain text
#: text/chapter6.md:301
#, fuzzy
msgid ""
"Well, we can build an intuition that the `map` function applies the function "
"it is given to each element of a container, and builds a new container from "
"the results, with the same shape as the original. But how do we make this "
"concept precise?"
msgstr ""
"直感的には、 `map`演算子はコンテナのそれぞれの要素へ関数を適用し、その結果か"
"ら元のデータと同じ形状を持った新しいコンテナを構築するのだというように理解す"
"ることができます。しかし、この概念を厳密にするにはどうしたらいいでしょうか？"

#. type: Plain text
#: text/chapter6.md:303
#, fuzzy
msgid ""
"Type class instances for `Functor` are expected to adhere to a set of "
"_laws_, called the _functor laws_:"
msgstr ""
"`Functor`の型クラスのインスタンスは、**関手則**(functor laws)と呼ばれる法則を"
"順守するものと期待されています。"

#. type: Bullet: '- '
#: text/chapter6.md:306
#, fuzzy
msgid "`map identity xs = xs`"
msgstr "`map id xs = xs`"

#. type: Bullet: '- '
#: text/chapter6.md:306
#, fuzzy
msgid "`map g (map f xs) = map (g <<< f) xs`"
msgstr "`map g (map f xs) = map (g <<< f) xs`"

#. type: Plain text
#: text/chapter6.md:308
#, fuzzy
msgid ""
"The first law is the _identity law_. It states that lifting the identity "
"function (the function which returns its argument unchanged) over a "
"structure just returns the original structure. This makes sense since the "
"identity function does not modify its input."
msgstr ""
"最初の法則は**恒等射律**(identity law)です。これは、恒等関数をその構造まで持"
"ち上げると、元の構造をそのまま返す恒等射になるということと言っています。恒等"
"関数は入力を変更しませんから、これは理にかなっています。"

#. type: Plain text
#: text/chapter6.md:310
#, fuzzy
msgid ""
"The second law is the _composition law_. It states that mapping one function "
"over a structure, and then mapping a second, is the same thing as mapping "
"the composition of the two functions over the structure."
msgstr ""
"第二の法則は**合成律**(composition law)です。構造をひとつの関数で写してから２"
"つめの関数で写すのは、２つの関数の合成で構造を写すのと同じだ、と言っていま"
"す。"

#. type: Plain text
#: text/chapter6.md:312
#, fuzzy
msgid ""
"Whatever \"lifting\" means in the general sense, it should be true that any "
"reasonable definition of lifting a function over a data structure should "
"obey these rules."
msgstr ""
"「持ち上げ」の一般的な意味が何であれ、データ構造に対する持ち上げ関数の正しい"
"定義はこれらの法則に従っていなければなりません。"

#. type: Plain text
#: text/chapter6.md:314
#, fuzzy
msgid ""
"Many standard type classes come with their own set of similar laws. The laws "
"given to a type class give structure to the functions of that type class and "
"allow us to study its instances in generality. The interested reader can "
"research the laws ascribed to the standard type classes that we have seen "
"already."
msgstr ""
"標準の型クラスの多くには、このような法則が付随しています。一般に、型クラスに"
"与えられた法則は、型クラスの関数に構造を与え、インスタンスについて調べられる"
"ようにします。興味のある読者は、すでに見てきた標準の型クラスに属する法則につ"
"いて調べてみてもよいでしょう。"

#. type: Title ###
#: text/chapter6.md:315
#, fuzzy, no-wrap
msgid "Deriving Instances"
msgstr "インスタンスの重複"

#. type: Plain text
#: text/chapter6.md:318
msgid ""
"Rather than writing instances manually, you can let the compiler do most of "
"the work for you. Take a look at this [Type Class Deriving guide](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md). That information will help you solve the following exercises."
msgstr ""

#. type: Plain text
#: text/chapter6.md:322
#, fuzzy
msgid "The following newtype represents a complex number:"
msgstr "(簡単)次のnewtypeは複素数を表します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:323
#, no-wrap
msgid "{{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Complex}}\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:328
msgid ""
"(Easy) Define a `Show` instance for `Complex`. Match the output format "
"expected by the tests (e.g. `1.2+3.4i`, `5.6-7.8i`, etc.)."
msgstr ""

#. type: Bullet: '2. '
#: text/chapter6.md:330
msgid ""
"(Easy) Derive an `Eq` instance for `Complex`. _Note_: You may instead write "
"this instance manually, but why do more work if you don't have to?"
msgstr ""

#. type: Bullet: '3. '
#: text/chapter6.md:332
msgid ""
"(Medium) Define a `Semiring` instance for `Complex`. _Note_: You can use "
"`wrap` and `over2` from [`Data.Newtype`](https://pursuit.purescript.org/"
"packages/purescript-newtype/docs/Data.Newtype) to create a more concise "
"solution. If you do so, you will also need to import `class Newtype` from "
"`Data.Newtype` and derive a `Newtype` instance for `Complex`."
msgstr ""

#. type: Bullet: '4. '
#: text/chapter6.md:334
msgid ""
"(Easy) Derive (via `newtype`) a `Ring` instance for `Complex`. _Note_: You "
"may instead write this instance manually, but that's not as convenient."
msgstr ""

#. type: Plain text
#: text/chapter6.md:336
#, no-wrap
msgid "    Here's the `Shape` ADT from the previous chapter:\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:340
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Shape}}\n"
"    ```\n"
msgstr ""

#. type: Bullet: '5. '
#: text/chapter6.md:342
msgid ""
"(Medium) Derive (via `Generic`) a `Show` instance for `Shape`. How does the "
"amount of code written and `String` output compare to `showShape` from the "
"previous chapter? _Hint_: See the [Deriving from `Generic`](https://github."
"com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md#deriving-from-generic) section of the [Type Class Deriving](https://"
"github.com/purescript/documentation/blob/master/guides/Type-Class-Deriving."
"md) guide."
msgstr ""

#. type: Title ##
#: text/chapter6.md:343
#, fuzzy, no-wrap
msgid "Type Class Constraints"
msgstr "ハッシュの型クラス"

#. type: Plain text
#: text/chapter6.md:346
#, fuzzy
msgid ""
"Types of functions can be constrained by using type classes. Here is an "
"example: suppose we want to write a function which tests if three values are "
"equal, by using equality defined using an `Eq` type class instance."
msgstr ""
"型クラスを使うと、関数の型に制約を加えることができます。例を示しましょう。 "
"`Eq`型クラスのインスタンスで定義された等値性を使って、３つの値が等しいかどう"
"かを調べる関数を書きたいとします。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:347
#, fuzzy, no-wrap
msgid ""
"threeAreEqual :: forall a. Eq a => a -> a -> a -> Boolean\n"
"threeAreEqual a1 a2 a3 = a1 == a2 && a2 == a3\n"
msgstr ""
"threeAreEqual :: forall a. Eq a => a -> a -> a -> Boolean\n"
"threeAreEqual a1 a2 a3 = a1 == a2 && a2 == a3\n"

#. type: Plain text
#: text/chapter6.md:353
#, fuzzy, no-wrap
msgid "The type declaration looks like an ordinary polymorphic type defined using `forall`. However, there is a type class constraint `Eq a`, separated from the rest of the type by a double arrow `=>`.\n"
msgstr "この型宣言は `forall`を使って定義された通常の多相型のようにも見えます。しかし、太い矢印 `=>`で型の残りの部分から区切られた、型クラス制約(type class constraint)`Eq a`があります。\n"

#. type: Plain text
#: text/chapter6.md:355
#, fuzzy
msgid ""
"This type says that we can call `threeAreEqual` with any choice of type `a`, "
"as long as there is an `Eq` instance available for `a` in one of the "
"imported modules."
msgstr ""
"インポートされたモジュールのどれかに `a`に対する `Eq`インスタンスが存在するな"
"ら、どんな型 `a`を選んでも `threeAsEqual`を呼び出すことができる、とこの型は"
"言っています。"

#. type: Plain text
#: text/chapter6.md:357
#, fuzzy
msgid ""
"Constrained types can contain several type class instances, and the types of "
"the instances are not restricted to simple type variables. Here is another "
"example which uses `Ord` and `Show` instances to compare two values:"
msgstr ""
"制約された型には複数の型クラスインスタンスを含めることができますし、インスタ"
"ンスの型は単純な型変数に限定されません。 `Ord`と `Show`のインスタンスを使って"
"2つの値を比較する例を次に示します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:358
#, fuzzy, no-wrap
msgid ""
"showCompare :: forall a. Ord a => Show a => a -> a -> String\n"
"showCompare a1 a2 | a1 < a2 =\n"
"  show a1 <> \" is less than \" <> show a2\n"
"showCompare a1 a2 | a1 > a2 =\n"
"  show a1 <> \" is greater than \" <> show a2\n"
"showCompare a1 a2 =\n"
"  show a1 <> \" is equal to \" <> show a2\n"
msgstr ""
"showCompare :: forall a. Ord a => Show a => a -> a -> String\n"
"showCompare a1 a2 | a1 < a2 =\n"
"  show a1 <> \" is less than \" <> show a2\n"
"showCompare a1 a2 | a1 > a2 =\n"
"  show a1 <> \" is greater than \" <> show a2\n"
"showCompare a1 a2 =\n"
"  show a1 <> \" is equal to \" <> show a2\n"

#. type: Plain text
#: text/chapter6.md:370
#, fuzzy, no-wrap
msgid ""
"Note that multiple constraints can be specified by using the `=>` symbol multiple times, just like we specify curried functions\n"
"of multiple arguments. But remember not to confuse the two symbols:\n"
msgstr "`=>`シンボルを複数回使って複数の制約を指定できることに注意してください。複数の引数のカリー化された関数を定義するのと同様です。しかし、2つの記号を混同しないように注意してください。\n"

#. type: Bullet: '- '
#: text/chapter6.md:373
#, fuzzy
msgid ""
"`a -> b` denotes the type of functions from _type_ `a` to _type_ `b`, whereas"
msgstr "`a -> b`は**型**`a`から**型**`b`への関数の型を表します。"

#. type: Bullet: '- '
#: text/chapter6.md:373
#, fuzzy
msgid "`a => b` applies the _constraint_ `a` to the type `b`."
msgstr "`a => b`は**制約**`a`を型`b`に適用します。"

#. type: Plain text
#: text/chapter6.md:375
#, fuzzy
msgid ""
"The PureScript compiler will try to infer constrained types when a type "
"annotation is not provided. This can be useful if we want to use the most "
"general type possible for a function."
msgstr ""
"PureScriptコンパイラは、型の注釈が提供されていない場合、制約付き型を推測しよ"
"うとします。これは、関数に対して可能な最も一般的な型を使用したい場合に便利で"
"す。"

#. type: Plain text
#: text/chapter6.md:377
#, fuzzy
msgid ""
"To see this, try using one of the standard type classes like `Semiring` in "
"PSCi:"
msgstr ""
"`PSCi`で `Semiring`のような標準の型クラスのいずれかを使って、このことを試して"
"みましょう。"

#. type: Fenced code block (text)
#: text/chapter6.md:378
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> :type \\x -> x + x\n"
"forall a. Semiring a => a -> a\n"
msgstr ""
"> import Prelude\n"
"\n"
"> :type \\x -> x + x\n"
"forall a. Semiring a => a -> a\n"

#. type: Plain text
#: text/chapter6.md:386
#, fuzzy, no-wrap
msgid "Here, we might have annotated this function as `Int -> Int`, or `Number -> Number`, but PSCi shows us that the most general type works for any `Semiring`, allowing us to use our function with both `Int`s and `Number`s.\n"
msgstr "ここで、この関数には`Int -> Int`または`Number -> Number`と注釈を付けることが考えられますが、最も一般的な型が`Semiring`で動作するため、PSCiでは`Int`と `Number`の両方で関数を実行させることができます。\n"

#. type: Title ##
#: text/chapter6.md:387
#, fuzzy, no-wrap
msgid "Instance Dependencies"
msgstr "インスタンスの依存関係"

#. type: Plain text
#: text/chapter6.md:390
#, fuzzy
msgid ""
"Just as the implementation of functions can depend on type class instances "
"using constrained types, so can the implementation of type class instances "
"depend on other type class instances. This provides a powerful form of "
"program inference, in which the implementation of a program can be inferred "
"using its types."
msgstr ""
"制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、型ク"
"ラスインスタンスの実装は他の型クラスインスタンスに依存することができます。こ"
"れにより、型を使ってプログラムの実装を推論するという、プログラム推論の強力な"
"形式を提供します。"

#. type: Plain text
#: text/chapter6.md:392
#, fuzzy
msgid ""
"For example, consider the `Show` type class. We can write a type class "
"instance to `show` arrays of elements, as long as we have a way to `show` "
"the elements themselves:"
msgstr ""
"`Show`型クラスを例に考えてみましょう。要素を `show`する方法があるとき、その要"
"素の配列を `show`する型クラスインスタンスを書くことができます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:393
#, fuzzy, no-wrap
msgid ""
"instance showArray :: Show a => Show (Array a) where\n"
"  ...\n"
msgstr ""
"instance showArray :: Show a => Show (Array a) where\n"
"  ...\n"

#. type: Plain text
#: text/chapter6.md:400
#, fuzzy, no-wrap
msgid ""
"If a type class instance depends on multiple other instances, those instances should be grouped in parentheses and separated by\n"
"commas on the left hand side of the `=>` symbol:\n"
msgstr "型クラスインスタンスが複数の他のインスタンスに依存する場合、括弧で囲んでそれらのインスタンスをコンマで区切り、それを`=>`シンボルの左側に置く必要があります。\n"

#. type: Fenced code block (haskell)
#: text/chapter6.md:401
#, fuzzy, no-wrap
msgid ""
"instance showEither :: (Show a, Show b) => Show (Either a b) where\n"
"  ...\n"
msgstr ""
"instance showEither :: (Show a, Show b) => Show (Either a b) where\n"
"  ...\n"

#. type: Plain text
#: text/chapter6.md:407
#, fuzzy
msgid "These two type class instances are provided in the `prelude` library."
msgstr ""
"これらの2つの型クラスインスタンスは `purescript-prelude`ライブラリにありま"
"す。"

#. type: Plain text
#: text/chapter6.md:409
#, fuzzy
msgid ""
"When the program is compiled, the correct type class instance for `Show` is "
"chosen based on the inferred type of the argument to `show`. The selected "
"instance might depend on many such instance relationships, but this "
"complexity is not exposed to the developer."
msgstr ""
"プログラムがコンパイルされると、 `Show`の正しい型クラスのインスタンスは "
"`show`の引数の推論された型に基づいて選ばれますが、このあたりの複雑さに開発者"
"が関与することはありません。"

#. type: Bullet: '1. '
#: text/chapter6.md:414
#, fuzzy
msgid ""
"(Easy) The following declaration defines a type of non-empty arrays of "
"elements of type `a`:"
msgstr "(簡単)次は型 `a`の要素の空でない配列の型を定義しています。"

#. type: Plain text
#: text/chapter6.md:418
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:NonEmpty}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:420
#, no-wrap
msgid "    Write an `Eq` instance for the type `NonEmpty a` which reuses the instances for `Eq a` and `Eq (Array a)`. _Note:_ you may instead derive the `Eq` instance.\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:422
msgid ""
"(Medium) Write a `Semigroup` instance for `NonEmpty a` by reusing the "
"`Semigroup` instance for `Array`."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:424
#, fuzzy
msgid "(Medium) Write a `Functor` instance for `NonEmpty`."
msgstr "(やや難しい)`foldl`を使って`reverse`を書いてみましょう。"

#. type: Bullet: '1. '
#: text/chapter6.md:426
msgid ""
"(Medium) Given any type `a` with an instance of `Ord`, we can add a new "
"\"infinite\" value which is greater than any other value:"
msgstr ""

#. type: Plain text
#: text/chapter6.md:430
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Extended}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:432
#, no-wrap
msgid "    Write an `Ord` instance for `Extended a` which reuses the `Ord` instance for `a`.\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:434
msgid ""
"(Difficult) Write a `Foldable` instance for `NonEmpty`. _Hint_: reuse the "
"`Foldable` instance for arrays."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:436
#, fuzzy
msgid ""
"(Difficult) Given a type constructor `f` which defines an ordered container "
"(and so has a `Foldable` instance), we can create a new container type which "
"includes an extra element at the front:"
msgstr ""
"   `a`の `Ord`インスタンスを再利用して、 `Extended a`の `Ord`インスタンスを書"
"いてみましょう。\n"
"1. (難しい)`NonEmpty`の `Foldable`インスタンスを書いてみましょう。**ヒント"
"**：配列の `Foldable`インスタンスを再利用してみましょう。\n"
"1. (難しい)　順序付きコンテナを定義する(そして `Foldable`のインスタンスを持っ"
"ている)ような型構築子 `f`が与えられたとき、追加の要素を先頭に含めるような新た"
"なコンテナ型を作ることができます。\n"

#. type: Plain text
#: text/chapter6.md:440
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:442
#, fuzzy, no-wrap
msgid "    The container `OneMore f` also has an ordering, where the new element comes before any element of `f`. Write a `Foldable` instance for `OneMore f`:\n"
msgstr "   このコンテナ `OneMore f`もまた順序を持っています。ここで、新しい要素は任意の `f`の要素よりも前にきます。この `OneMore f`の `Foldable`インスタンスを書いてみましょう。\n"

#. type: Plain text
#: text/chapter6.md:447
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:OneMore_Foldable}}\n"
"      ...\n"
"    ```\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:449
msgid ""
"(Medium) Write a `dedupShapes :: Array Shape -> Array Shape` function which "
"removes duplicate `Shape`s from an array using the `nubEq` function."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:451
msgid ""
"(Medium) Write a `dedupShapesFast` function which is the same as "
"`dedupShapes`, but uses the more efficient `nub` function."
msgstr ""

#. type: Title ##
#: text/chapter6.md:452
#, fuzzy, no-wrap
msgid "Multi Parameter Type Classes"
msgstr "多変数型クラス"

#. type: Plain text
#: text/chapter6.md:455
#, fuzzy
msgid ""
"It's not the case that a type class can only take a single type as an "
"argument. This is the most common case, but in fact, a type class can be "
"parameterized by _zero or more_ type arguments."
msgstr ""
"型クラスは必ずしもひとつの型だけを型変数としてとるわけではありません。型変数"
"がひとつだけなのが最も一般的ですが、実際には型クラスは**ゼロ個以上の**型変数"
"を持つことができます。"

#. type: Plain text
#: text/chapter6.md:457
#, fuzzy
msgid "Let's see an example of a type class with two type arguments."
msgstr "それでは2つの型引数を持つ型クラスの例を見てみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:458
#, fuzzy, no-wrap
msgid ""
"module Stream where\n"
"\n"
"import Data.Array as Array\n"
"import Data.Maybe (Maybe)\n"
"import Data.String.CodeUnits as String\n"
"\n"
"class Stream stream element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
"\n"
"instance streamArray :: Stream (Array a) a where\n"
"  uncons = Array.uncons\n"
"\n"
"instance streamString :: Stream String Char where\n"
"  uncons = String.uncons\n"
msgstr ""
"module Stream where\n"
"\n"
"import Data.Array as Array\n"
"import Data.Maybe (Maybe)\n"
"import Data.String as String\n"
"\n"
"class Stream stream element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
"\n"
"instance streamArray :: Stream (Array a) a where\n"
"  uncons = Array.uncons\n"
"\n"
"instance streamString :: Stream String Char where\n"
"  uncons = String.uncons\n"

#. type: Plain text
#: text/chapter6.md:476
#, fuzzy
msgid ""
"The `Stream` module defines a class `Stream` which identifies types which "
"look like streams of elements, where elements can be pulled from the front "
"of the stream using the `uncons` function."
msgstr ""
"この `Stream`モジュールでは、 `uncons`関数を使ってストリームの先頭から要素を"
"取り出すことができる、要素のストリームのような型を示すクラス `Stream`が定義さ"
"れています。"

#. type: Plain text
#: text/chapter6.md:478
#, fuzzy
msgid ""
"Note that the `Stream` type class is parameterized not only by the type of "
"the stream itself, but also by its elements. This allows us to define type "
"class instances for the same stream type but different element types."
msgstr ""
"`Stream`型クラスは、ストリーム自身の型だけでなくその要素の型も型変数として"
"持っていることに注意してください。これによって、ストリームの型が同じでも要素"
"の型について異なる型クラスインスタンスを定義することができます。"

#. type: Plain text
#: text/chapter6.md:480
#, fuzzy
msgid ""
"The module defines two type class instances: an instance for arrays, where "
"`uncons` removes the head element of the array using pattern matching, and "
"an instance for String, which removes the first character from a String."
msgstr ""
"このモジュールでは、 `uncons`がパターン照合で配列の先頭の要素を取り除くような"
"配列のインスタンスと、文字列から最初の文字を取り除くような文字列のインスタン"
"スという、２つの型クラスインスタンスが定義されています。"

#. type: Plain text
#: text/chapter6.md:482
#, fuzzy
msgid ""
"We can write functions which work over arbitrary streams. For example, here "
"is a function which accumulates a result in some `Monoid` based on the "
"elements of a stream:"
msgstr ""
"任意のストリーム上で動作する関数を記述することができます。例えば、ストリーム"
"の要素に基づいて `Monoid`に結果を累積する関数は次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:483
#, fuzzy, no-wrap
msgid ""
"import Prelude\n"
"import Data.Monoid (class Monoid, mempty)\n"
"\n"
"foldStream :: forall l e m. Stream l e => Monoid m => (e -> m) -> l -> m\n"
"foldStream f list =\n"
"  case uncons list of\n"
"    Nothing -> mempty\n"
"    Just cons -> f cons.head <> foldStream f cons.tail\n"
msgstr ""
"import Prelude\n"
"import Data.Maybe (Maybe(..))\n"
"import Data.Monoid (class Monoid, mempty)\n"
"\n"
"foldStream :: forall l e m. Stream l e => Monoid m => (e -> m) -> l -> m\n"
"foldStream f list =\n"
"  case uncons list of\n"
"    Nothing -> mempty\n"
"    Just cons -> f cons.head <> foldStream f cons.tail\n"

#. type: Plain text
#: text/chapter6.md:495
#, fuzzy
msgid ""
"Try using `foldStream` in PSCi for different types of `Stream` and different "
"types of `Monoid`."
msgstr ""
"`PSCi`で使って、異なる `Stream`の型や異なる `Monoid`の型について `foldStream`"
"を呼び出してみましょう。"

#. type: Title ##
#: text/chapter6.md:496
#, fuzzy, no-wrap
msgid "Functional Dependencies"
msgstr "関数従属性"

#. type: Plain text
#: text/chapter6.md:499
#, fuzzy
msgid ""
"Multi-parameter type classes can be very useful, but can easily lead to "
"confusing types and even issues with type inference. As a simple example, "
"consider writing a generic `tail` function on streams using the `Stream` "
"class given above:"
msgstr ""
"多変数型クラスは非常に便利ですが、混乱しやすい型や型推論の問題にもつながりま"
"す。簡単な例として、上記の `Stream`クラスを使って `genericTail`関数をストリー"
"ムに書くことを考えてみましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:500
#, fuzzy, no-wrap
msgid "genericTail xs = map _.tail (uncons xs)\n"
msgstr "genericTail xs = map _.tail (uncons xs)\n"

#. type: Plain text
#: text/chapter6.md:505
#, fuzzy
msgid "This gives a somewhat confusing error message:"
msgstr "これはやや複雑なエラーメッセージを出力します。"

#. type: Fenced code block (text)
#: text/chapter6.md:506
#, fuzzy, no-wrap
msgid ""
"The inferred type\n"
"\n"
"  forall stream a. Stream stream a => stream -> Maybe stream\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"The inferred type\n"
"\n"
"  forall stream a. Stream stream a => stream -> Maybe stream\n"
"\n"
"has type variables which are not mentioned in the body of the type.\n"
"Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:515
#, fuzzy
msgid ""
"The problem is that the `genericTail` function does not use the `element` "
"type mentioned in the definition of the `Stream` type class, so that type is "
"left unsolved."
msgstr ""
"エラーは、 `genericTail`関数が `Stream`型クラスの定義で言及された `element`型"
"を使用しないので、その型は未解決のままであることを指しています。"

#. type: Plain text
#: text/chapter6.md:517
#, fuzzy
msgid ""
"Worse still, we cannot even use `genericTail` by applying it to a specific "
"type of stream:"
msgstr ""
"さらに、特定の型のストリームに `genericTail`を適用することができません。"

#. type: Fenced code block (text)
#: text/chapter6.md:518
#, fuzzy, no-wrap
msgid ""
"> map _.tail (uncons \"testing\")\n"
"\n"
"The inferred type\n"
"\n"
"  forall a. Stream String a => Maybe String\n"
"\n"
"has type variables which are not mentioned in the body of the type. Consider adding a type annotation.\n"
msgstr ""
"> map _.tail (uncons \"testing\")\n"
"\n"
"The inferred type\n"
"\n"
"  forall a. Stream String a => Maybe String\n"
"\n"
"has type variables which are not mentioned in the body of the type.\n"
"Consider adding a type annotation.\n"

#. type: Plain text
#: text/chapter6.md:529
#, fuzzy
msgid ""
"Here, we might expect the compiler to choose the `streamString` instance. "
"After all, a `String` is a stream of `Char`s, and cannot be a stream of any "
"other type of elements."
msgstr ""
"ここでは、コンパイラが `streamString`インスタンスを選択することを期待していま"
"す。結局のところ、 `String`は `Char`のストリームであり、他の型のストリームで"
"あってはなりません。"

#. type: Plain text
#: text/chapter6.md:531
#, fuzzy
msgid ""
"The compiler is unable to make that deduction automatically, and cannot "
"commit to the `streamString` instance. However, we can help the compiler by "
"adding a hint to the type class definition:"
msgstr ""
"コンパイラは自動的にその排除を行うことはできず、 `streamString`インスタンスに"
"引き渡すことはできません。しかし、型クラス定義にヒントを追加すると、コンパイ"
"ラを助けることができます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:532
#, fuzzy, no-wrap
msgid ""
"class Stream stream element | stream -> element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"
msgstr ""
"class Stream stream element | stream -> element where\n"
"  uncons :: stream -> Maybe { head :: element, tail :: stream }\n"

#. type: Plain text
#: text/chapter6.md:538
#, fuzzy, no-wrap
msgid "Here, `stream -> element` is called a _functional dependency_. A functional dependency asserts a functional relationship between the type arguments of a multi-parameter type class. This functional dependency tells the compiler that there is a function from stream types to (unique) element types, so if the compiler knows the stream type, then it can commit to the element type.\n"
msgstr "ここで、 `stream -> element`は**関数従属性**(functional dependency)と呼ばれます。関数従属性は、多変数型クラスの型引数間の関数関係を宣言します。この関数の依存関係は、ストリーム型から（一意の）要素型への関数があることをコンパイラに伝えるので、コンパイラがストリーム型を知っていれば要素型へ適用できます。\n"

#. type: Plain text
#: text/chapter6.md:540
#, fuzzy
msgid ""
"This hint is enough for the compiler to infer the correct type for our "
"generic tail function above:"
msgstr ""
"このヒントは、コンパイラが上記の `genericTail`関数の正しい型を推論するのに十"
"分です。"

#. type: Fenced code block (text)
#: text/chapter6.md:541
#, fuzzy, no-wrap
msgid ""
"> :type genericTail\n"
"forall stream element. Stream stream element => stream -> Maybe stream\n"
"\n"
"> genericTail \"testing\"\n"
"(Just \"esting\")\n"
msgstr ""
"> :type genericTail\n"
"forall stream element. Stream stream element => stream -> Maybe stream\n"
"\n"
"> genericTail \"testing\"\n"
"(Just \"esting\")\n"

#. type: Plain text
#: text/chapter6.md:550
#, fuzzy
msgid ""
"Functional dependencies can be quite useful when using multi-parameter type "
"classes to design certain APIs."
msgstr ""
"多種の型のクラスを使用して特定のAPIを設計する場合、関数従属性は非常に有用で"
"す。"

#. type: Title ##
#: text/chapter6.md:551
#, fuzzy, no-wrap
msgid "Nullary Type Classes"
msgstr "型変数のない型クラス"

#. type: Plain text
#: text/chapter6.md:554
#, fuzzy
msgid ""
"We can even define type classes with zero type arguments! These correspond "
"to compile-time assertions about our functions, allowing us to track global "
"properties of our code in the type system."
msgstr ""
"ゼロ個の型変数を持つ型クラスを定義することもできます！これらは関数に対するコ"
"ンパイル時のアサーションに対応しており、型システム内のコードの大域的な性質を"
"追跡することができます。"

#. type: Plain text
#: text/chapter6.md:556
#, fuzzy
msgid ""
"An important example is the `Partial` class which we saw earlier when "
"discussing partial functions. Take for example the functions `head` and "
"`tail` defined in `Data.Array.Partial` that allow us to get the head or tail "
"of an array without wrapping them in a `Maybe`, so they can fail if the "
"array is empty:"
msgstr ""
"たとえば、型システムを使って部分関数の使用を追跡したいとしましょう。すでに "
"`Data.Array.Partial`で定義されている `head`と `tail`の部分関数を確認します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:557
#, fuzzy, no-wrap
msgid ""
"head :: forall a. Partial => Array a -> a\n"
"\n"
"tail :: forall a. Partial => Array a -> Array a\n"
msgstr ""
"head :: forall a. Partial => Array a -> a\n"
"\n"
"tail :: forall a. Partial => Array a -> Array a\n"

#. type: Plain text
#: text/chapter6.md:564
#, fuzzy
msgid ""
"Note that there is no instance defined for the `Partial` type class! Doing "
"so would defeat its purpose: attempting to use the `head` function directly "
"will result in a type error:"
msgstr ""
"`Partial`モジュールの `Partial`型クラスのインスタンスを定義していないことに注"
"意してください。こうすると目的を達成できます。このままの定義では `head`関数を"
"使用しようとすると型エラーになるのです。"

#. type: Fenced code block (text)
#: text/chapter6.md:565
#, fuzzy, no-wrap
msgid ""
"> head [1, 2, 3]\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Prim.Partial\n"
msgstr ""
"> head [1, 2, 3]\n"
"\n"
"No type class instance was found for\n"
"\n"
"  Prim.Partial\n"

#. type: Plain text
#: text/chapter6.md:574
#, fuzzy
msgid ""
"Instead, we can republish the `Partial` constraint for any functions making "
"use of partial functions:"
msgstr ""
"代わりに、これらの部分関数を利用するすべての関数で `Partial`制約を再発行する"
"方法ができます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:575
#, fuzzy, no-wrap
msgid ""
"secondElement :: forall a. Partial => Array a -> a\n"
"secondElement xs = head (tail xs)\n"
msgstr ""
"secondElement :: forall a. Partial => Array a -> a\n"
"secondElement xs = head (tail xs)\n"

#. type: Plain text
#: text/chapter6.md:581
#, fuzzy
msgid ""
"We've already seen the `unsafePartial` function, which allows us to treat a "
"partial function as a regular function (unsafely). This function is defined "
"in the `Partial.Unsafe` module:"
msgstr ""
"前章で見た `unsafePartial`関数を使用し、部分関数を通常の関数（unsafely）とし"
"て扱うことができます。 この関数は `Partial.Unsafe`モジュールで定義されていま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:582
#, fuzzy, no-wrap
msgid "unsafePartial :: forall a. (Partial => a) -> a\n"
msgstr "unsafePartial :: forall a. (Partial => a) -> a\n"

#. type: Plain text
#: text/chapter6.md:587
#, fuzzy
msgid ""
"Note that the `Partial` constraint appears _inside the parentheses_ on the "
"left of the function arrow, but not in the outer `forall`. That is, "
"`unsafePartial` is a function from partial values to regular values:"
msgstr ""
"`Partial`制約は関数の矢印の左側の括弧の中に現れますが、外側の `forall`では現"
"れません。 つまり、 `unsafePartial`は部分的な値から通常の値への関数です。"

#. type: Fenced code block (text)
#: text/chapter6.md:588
#, no-wrap
msgid ""
"> unsafePartial head [1, 2, 3]\n"
"1\n"
"\n"
"> unsafePartial secondElement [1, 2, 3]\n"
"2\n"
msgstr ""

#. type: Title ##
#: text/chapter6.md:596
#, fuzzy, no-wrap
msgid "Superclasses"
msgstr "上位クラス"

#. type: Plain text
#: text/chapter6.md:599
#, fuzzy
msgid ""
"Just as we can express relationships between type class instances by making "
"an instance dependent on another instance, we can express relationships "
"between type classes themselves using so-called _superclasses_."
msgstr ""
"インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス"
"間の関係を表現することができるように、いわゆる**上位クラス**(superclass)を"
"使って型クラス間の関係を表現することができます。"

#. type: Plain text
#: text/chapter6.md:601
#, fuzzy
msgid ""
"We say that one type class is a superclass of another if every instance of "
"the second class is required to be an instance of the first, and we indicate "
"a superclass relationship in the class definition by using a backwards "
"facing double arrow."
msgstr ""
"あるクラスのどんなインスタンスも、その他のあるクラスのインスタンスで必要とさ"
"れているとき、前者の型クラスは後者の型クラスの上位クラスであるといい、クラス"
"定義で逆向きの太い矢印(<=)を使い上位クラス関係を示します。\n"

#. type: Plain text
#: text/chapter6.md:603
#, fuzzy
msgid ""
"We've already seen some examples of superclass relationships: the `Eq` class "
"is a superclass of `Ord`, and the `Semigroup` class is a superclass of "
"`Monoid`. For every type class instance of the `Ord` class, there must be a "
"corresponding `Eq` instance for the same type. This makes sense, since in "
"many cases, when the `compare` function reports that two values are "
"incomparable, we often want to use the `Eq` class to determine if they are "
"in fact equal."
msgstr ""
"すでに上位クラスの関係の一例について見ています。 `Eq`クラスは `Ord`の上位クラ"
"スです。 `Ord`クラスのすべての型クラスインスタンスについて、その同じ型に対応"
"する `Eq`インスタンスが存在しなければなりません。 `compare`関数が2つの値が比"
"較できないと報告した時は、それらが実は同値であるかどうかを決定するために `Eq`"
"クラスを使いたくなることが多いでしょうから、これは理にかなっています。"

#. type: Plain text
#: text/chapter6.md:605
#, fuzzy
msgid ""
"In general, it makes sense to define a superclass relationship when the laws "
"for the subclass mention the members of the superclass. For example, it is "
"reasonable to assume, for any pair of `Ord` and `Eq` instances, that if two "
"values are equal under the `Eq` instance, then the `compare` function should "
"return `EQ`. In other words, `a == b` should be true exactly when `compare a "
"b` evaluates to `EQ`. This relationship on the level of laws justifies the "
"superclass relationship between `Eq` and `Ord`."
msgstr ""
"一般に、下位クラスの法則が上位クラスのメンバに言及しているとき、上位クラス関"
"係を定義するのは理にかなっています。例えば、 `Ord`と `Eq`のインスタンスのどん"
"な組についても、もしふたつの値が `Eq`インスタンスのもとで同値であるなら、 "
"`compare`関数は `EQ`を返すはずだとみなすのは妥当です。言い換えれば、 `a == b`"
"ならば `compare a b == EQ`です。法則の階層上のこの関係は、 `Eq`と `Ord`の間の"
"上位クラス関係を説明します。"

#. type: Plain text
#: text/chapter6.md:607
#, fuzzy
msgid ""
"Another reason to define a superclass relationship is in the case where "
"there is a clear \"is-a\" relationship between the two classes. That is, "
"every member of the subclass _is a_ member of the superclass as well."
msgstr ""
"この場合に上位クラス関係を定義する別の考え方としては、この２つのクラスの間に"
"は明らかに\"is-a\"の関係があることです。下位クラスのすべてのメンバは、上位ク"
"ラスのメンバでもあるということです。"

#. type: Bullet: '1. '
#: text/chapter6.md:611
#, fuzzy
msgid ""
"(Medium) Define a partial function `unsafeMaximum :: Partial => Array Int -> "
"Int` which finds the maximum of a non-empty array of integers. Test out your "
"function in PSCi using `unsafePartial`. _Hint_: Use the `maximum` function "
"from `Data.Foldable`."
msgstr ""
"(やや難しい) 整数の空でない配列の最大値を求める部分関数を定義します。あなたの"
"関数の型は `Partial => Array Int - > Int`でなければなりません。 "
"`unsafePartial`を使ってPSCiであなたの関数をテストしてください。 **ヒント**："
"`Data.Foldable`の `maximum`関数を使います。"

#. type: Bullet: '1. '
#: text/chapter6.md:613
#, fuzzy
msgid ""
"(Medium) The `Action` class is a multi-parameter type class which defines an "
"action of one type on another:"
msgstr ""
"(やや難しい) 次の `Action`クラスは、ある型の動作(action)を定義する、多変数型"
"クラスです。"

#. type: Plain text
#: text/chapter6.md:617
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Action}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:619
#, fuzzy, no-wrap
msgid "    An _action_ is a function which describes how monoidal values are used to determine how to modify a value of another type. There are two laws for the `Action` type class:\n"
msgstr "   **act**はモノイドがどうやって他の型の値を変更するのに使われるのかを説明する関数です。この動作が　モノイドの連結演算子に従っていると期待しましょう。\n"

#. type: Bullet: '    - '
#: text/chapter6.md:622
#, fuzzy
msgid "`act mempty a = a`"
msgstr "`act mempty a = a`"

#. type: Bullet: '    - '
#: text/chapter6.md:622
#, fuzzy
msgid "`act (m1 <> m2) a = act m1 (act m2 a)`"
msgstr "`act (m1 <> m2) a = act m1 (act m2 a)`"

#. type: Plain text
#: text/chapter6.md:624
#, no-wrap
msgid "    Applying an empty action is a no-op. And applying two actions in sequence is the same as applying the actions combined. That is, actions respect the operations defined by the `Monoid` class.\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:626
#, fuzzy, no-wrap
msgid "    For example, the natural numbers form a monoid under multiplication:\n"
msgstr "   たとえば、乗算を持つ自然数のモノイドを形成します。\n"

#. type: Plain text
#: text/chapter6.md:629
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:631
#, no-wrap
msgid "    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:semigroupMultiply}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:634
#, no-wrap
msgid ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:monoidMultiply}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:636
#, no-wrap
msgid "    Write an instance which implements this action:\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:641
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Multiply_Action}}\n"
"      ...\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:643
#, no-wrap
msgid "    Remember, your instance must satisfy the laws listed above.\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:645
msgid ""
"(Difficult) There are actually multiple ways to implement an instance of "
"`Action Multiply Int`. How many can you think of? Purescript does not allow "
"multiple implementations of a same instance, so you will have to replace "
"your original implementation. _Note_: the tests cover 4 implementations."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:647
msgid ""
"(Medium) Write an `Action` instance which repeats an input string some "
"number of times:"
msgstr ""

#. type: Plain text
#: text/chapter6.md:652
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:actionMultiplyString}}\n"
"      ...\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:654
#, no-wrap
msgid "    _Hint_: Search Pursuit for a helper-function with the signature [`String -> Int -> String`](https://pursuit.purescript.org/search?q=String%20-%3E%20Int%20-%3E%20String). Note that `String` might appear as a more generic type (such as `Monoid`).\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:656
#, no-wrap
msgid "    Does this instance satisfy the laws listed above?\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:658
#, fuzzy
msgid ""
"(Medium) Write an instance `Action m a => Action m (Array a)`, where the "
"action on arrays is defined by acting on each array element independently."
msgstr ""
"   このインスタンスが上記の法則を満たしているか確かめましょう。\n"
"1. (やや難しい) インスタンス `Action m a => Action m（Array a） `を書いてみま"
"しょう。ここで、 配列上の動作は要素の順序で実行されるように定義されるものとし"
"ます。\n"
"1. (難しい) 以下のnewtypeが与えられたとき、 `Action m (Self m)`のインスタンス"
"を書いてみましょう。ここで、モノイド `m`は連結によって自身に作用するものとし"
"ます。\n"

#. type: Bullet: '1. '
#: text/chapter6.md:660
msgid ""
"(Difficult) Given the following newtype, write an instance for `Action m "
"(Self m)`, where the monoid `m` acts on itself using `append`:"
msgstr ""

#. type: Plain text
#: text/chapter6.md:664
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Self}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:666
#, no-wrap
msgid "    _Note_: The testing framework requires `Show` and `Eq` instances for the `Self` and `Multiply` types. You may either write these instances manually, or let the compiler handle this for you with [`derive newtype instance`](https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#derive-from-newtype) shorthand.\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter6.md:668
#, fuzzy
msgid ""
"(Difficult) Should the arguments of the multi-parameter type class `Action` "
"be related by some functional dependency? Why or why not? _Note_: There is "
"no test for this exercise."
msgstr ""
"（難しい）多変数型のクラス `Action`の引数は、いくつかの関数従属性によって関連"
"づけられるべきですか。それはなぜでしょうか。"

#. type: Title ##
#: text/chapter6.md:669
#, fuzzy, no-wrap
msgid "A Type Class for Hashes"
msgstr "ハッシュの型クラス"

#. type: Plain text
#: text/chapter6.md:672
#, fuzzy
msgid ""
"In the last section of this chapter, we will use the lessons from the rest "
"of the chapter to create a library for hashing data structures."
msgstr ""
"この最後の節では、章の残りを費やしてデータ構造をハッシュするライブラリを作り"
"ます。"

#. type: Plain text
#: text/chapter6.md:674
#, fuzzy
msgid ""
"Note that this library is for demonstration purposes only, and is not "
"intended to provide a robust hashing mechanism."
msgstr ""
"このライブラリの目的は説明だけであり、堅牢なハッシングの仕組みの提供を目的と"
"していないことに注意してください。"

#. type: Plain text
#: text/chapter6.md:676
#, fuzzy
msgid "What properties might we expect of a hash function?"
msgstr "ハッシュ関数に期待される性質とはどのようなものでしょうか？"

#. type: Plain text
#: text/chapter6.md:679
#, fuzzy
msgid ""
"- A hash function should be deterministic, and map equal values to equal "
"hash codes.  - A hash function should distribute its results approximately "
"uniformly over some set of hash codes."
msgstr ""
"- ハッシュ関数は決定的でなくてはなりません。つまり、同じ値には同じハッシュ値"
"を対応させなければなりません - ハッシュ関数はいろいろなハッシュ値の集合で結果"
"が一様に分布しなければなりません。"

#. type: Plain text
#: text/chapter6.md:681
#, fuzzy
msgid ""
"The first property looks a lot like a law for a type class, whereas the "
"second property is more along the lines of an informal contract, and "
"certainly would not be enforceable by PureScript's type system. However, "
"this should provide the intuition for the following type class:"
msgstr ""
"最初の性質はまさに型クラスの法則のように見える一方で、２番目の性質はもっとぼ"
"んやりとした規約に従っていて、PureScriptの型システムによって確実に強制できる"
"ようなものではなさそうです。しかし、これは型クラスについて次のような直感的理"
"解を与えるはずです。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:682
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:Hashable}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:687
#, fuzzy
msgid "with the associated law that `a == b` implies `hash a == hash b`."
msgstr ""
"これに、 `a == b`ならば `hash a == hash b`という関係性の法則が付随していま"
"す。"

#. type: Plain text
#: text/chapter6.md:689
#, fuzzy
msgid ""
"We'll spend the rest of this section building a library of instances and "
"functions associated with the `Hashable` type class."
msgstr ""
"この節の残りの部分を費やして、 `Hashable`型クラスに関連付けられているインスタ"
"ンスと関数のライブラリを構築していきます。"

#. type: Plain text
#: text/chapter6.md:691
#, fuzzy
msgid "We will need a way to combine hash codes in a deterministic way:"
msgstr "決定的な方法でハッシュ値を結合する方法が必要になります。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:692
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:combineHashes}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:697
#, fuzzy
msgid ""
"The `combineHashes` function will mix two hash codes and redistribute the "
"result over the interval 0-65535."
msgstr ""
"`combineHashes`関数は、２つのハッシュ値を混ぜて結果を0-65535の間に分布しま"
"す。"

#. type: Plain text
#: text/chapter6.md:699
#, fuzzy
msgid ""
"Let's write a function which uses the `Hashable` constraint to restrict the "
"types of its inputs. One common task which requires a hashing function is to "
"determine if two values hash to the same hash code. The `hashEqual` relation "
"provides such a capability:"
msgstr ""
"それでは、入力の種類を制限する `Hashable`制約を使う関数を書いてみましょう。"
"ハッシュ関数を必要とするよくある目的としては、2つの値が同じハッシュ値にハッ"
"シュされるかどうかを決定することです。 `hashEqual`関係はそのような機能を提供"
"します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:700
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashEqual}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:705
#, fuzzy
msgid ""
"This function uses the `on` function from `Data.Function` to define hash-"
"equality in terms of equality of hash codes, and should read like a "
"declarative definition of hash-equality: two values are \"hash-equal\" if "
"they are equal after each value has been passed through the `hash` function."
msgstr ""
"この関数はハッシュ同値性を定義するために `Data.Function`の `on`関数を使ってい"
"ますが、このハッシュ同値性の定義は『それぞれの値が `hash`関数に渡されたあとで"
"２つの値が等しいなら、それらの値は「ハッシュ同値」である』というように宣言的"
"に読めるはずです。"

#. type: Plain text
#: text/chapter6.md:707
#, fuzzy
msgid ""
"Let's write some `Hashable` instances for some primitive types. Let's start "
"with an instance for integers. Since a `HashCode` is really just a wrapped "
"integer, this is simple - we can use the `hashCode` helper function:"
msgstr ""
"プリミティブ型の `Hashable`インスタンスをいくつか書いてみましょう。まずは整数"
"のインスタンスです。 `HashCode`は実際には単なるラップされた整数なので、これは"
"簡単です。`hashCode`ヘルパー関数を使うことができます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:708
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashInt}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:713
#, fuzzy
msgid ""
"We can also define a simple instance for `Boolean` values using pattern "
"matching:"
msgstr ""
"パターン照合を使うと、`Boolean`値の単純なインスタンスを定義することもできま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:714
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashBoolean}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:719
#, fuzzy
msgid ""
"With an instance for hashing integers, we can create an instance for hashing "
"`Char`s by using the `toCharCode` function from `Data.Char`:"
msgstr ""
"整数のインスタンスでは、 `Data.Char`の `toCharCode`関数を使うと`Char`をハッ"
"シュするインスタンスを作成できます。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:720
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashChar}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:725
#, fuzzy
msgid ""
"To define an instance for arrays, we can `map` the `hash` function over the "
"elements of the array (if the element type is also an instance of "
"`Hashable`) and then perform a left fold over the resulting hashes using the "
"`combineHashes` function:"
msgstr ""
"（要素型が `Hashable`のインスタンスでもあるならば）配列の要素に `hash`関数を "
"`map`してから、 `combineHashes`関数の結果を使ってハッシュを左側に畳み込むこと"
"で、配列のインスタンスを定義します。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:726
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashArray}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:731
#, fuzzy
msgid ""
"Notice how we build up instances using the simpler instances we have already "
"written. Let's use our new `Array` instance to define an instance for "
"`String`s, by turning a `String` into an array of `Char`s:"
msgstr ""
"すでに書いたより単純なインスタンスを使用して新たなインスタンスを構築する方法"
"に注目してください。 `String`を`Char`の配列に変換し、この新たな`Array`インス"
"タンスを使って`String`インスタンスを定義しましょう。"

#. type: Fenced code block (haskell)
#: text/chapter6.md:732
#, no-wrap
msgid "{{#include ../exercises/chapter6/src/Data/Hashable.purs:hashString}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:737
#, fuzzy
msgid ""
"How can we prove that these `Hashable` instances satisfy the type class law "
"that we stated above? We need to make sure that equal values have equal hash "
"codes. In cases like `Int`, `Char`, `String` and `Boolean`, this is simple "
"because there are no values of those types which are equal in the sense of "
"`Eq` but not equal identically."
msgstr ""
"これらの `Hashable`インスタンスが先ほどの型クラスの法則を満たしていることを証"
"明するにはどうしたらいいでしょうか。同じ値が等しいハッシュ値を持っていること"
"を確認する必要があります。 `Int`、 `Char`、 `String`、 `Boolean`の場合は、 "
"`Eq`の意味では同じ値でも厳密には同じではない、というような型の値は存在しない"
"ので簡単です。"

#. type: Plain text
#: text/chapter6.md:739
#, fuzzy
msgid ""
"What about some more interesting types? To prove the type class law for the "
"`Array` instance, we can use induction on the length of the array. The only "
"array with length zero is `[]`. Any two non-empty arrays are equal only if "
"they have equal head elements and equal tails, by the definition of `Eq` on "
"arrays. By the inductive hypothesis, the tails have equal hashes, and we "
"know that the head elements have equal hashes if the `Hashable a` instance "
"must satisfy the law. Therefore, the two arrays have equal hashes, and so "
"the `Hashable (Array a)` obeys the type class law as well."
msgstr ""
"もっと面白い型についてはどうでしょうか。この場合、配列の長さに関する帰納を使"
"うと、型クラスの法則を証明することができます。長さゼロの唯一の配列は `[]`で"
"す。配列の `Eq`の定義により、任意の二つの空でない配列は、それらの先頭の要素が"
"同じで配列の残りの部分が等しいとき、その時に限り等しくなります。この帰納的な"
"仮定により、配列の残りの部分は同じハッシュ値を持ちますし、もし `Hashable a`イ"
"ンスタンスがこの法則を満たすなら、先頭の要素も同じハッシュ値をもつことがわか"
"ります。したがって、２つの配列は同じハッシュ値を持ち、 `Hashable（Array a） `"
"も同様に型クラス法則を満たしています。"

#. type: Plain text
#: text/chapter6.md:741
#, fuzzy
msgid ""
"The source code for this chapter includes several other examples of "
"`Hashable` instances, such as instances for the `Maybe` and `Tuple` type."
msgstr ""
"この章のソースコードには、 `Maybe`と `Tuple`型のインスタンスなど、他にも "
"`Hashable`インスタンスの例が含まれています。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:747
#, fuzzy
msgid ""
"(Easy) Use PSCi to test the hash functions for each of the defined "
"instances. _Note_: There is no provided unit test for this exercise."
msgstr ""
"(簡単)`PSCi`を使って、各インスタンスのハッシュ関数をテストしてください。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:747
#, fuzzy
msgid ""
"(Medium) Write a function `arrayHasDuplicates` which tests if an array has "
"any duplicate elements based on both hash and value equality. First check "
"for hash equality with the `hashEqual` function, then check for value "
"equality with `==` if a duplicate pair of hashes is found. _Hint_: the "
"`nubByEq` function in `Data.Array` should make this task much simpler."
msgstr ""
"(やや難しい) 同値性の近似として `hashEqual`関数のハッシュ同値性を使い、配列が"
"重複する要素を持っているかどうかを調べる関数を書いてください。ハッシュ値が一"
"致したペアが見つかった場合は、 `==`を使って値の同値性を厳密に検証することを忘"
"れないようにしてください。 **ヒント**：`Data.Array`の `nubBy`関数を使用してみ"
"てください。"

#. type: Bullet: ' 1. '
#: text/chapter6.md:747
#, fuzzy
msgid ""
"(Medium) Write a `Hashable` instance for the following newtype which "
"satisfies the type class law:"
msgstr ""
"(やや難しい) 型クラスの法則を満たす、次のnewtypeの `Hashable`インスタンスを書"
"いてください。"

#. type: Plain text
#: text/chapter6.md:750
#, no-wrap
msgid ""
"    ```haskell\n"
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:Hour}}\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:753
#, no-wrap
msgid ""
"    {{#include ../exercises/chapter6/test/no-peeking/Solutions.purs:eqHour}}\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter6.md:756
#, fuzzy, no-wrap
msgid ""
"    The newtype `Hour` and its `Eq` instance represent the type of integers modulo 12, so that 1 and 13 are identified as equal, for example. Prove that the type class law holds for your instance.\n"
" 1. (Difficult) Prove the type class laws for the `Hashable` instances for `Maybe`, `Either` and `Tuple`. _Note_: There is no test for this exercise.\n"
msgstr "   newtypeの `Hour`とその `Eq`インスタンスは、12進数である型を表します。したがって、1と13は等しいと見なされます。そのインスタンスが型クラスの法則を満たしていることを証明してください。\n"

#. type: Plain text
#: text/chapter6.md:760
#, fuzzy
msgid ""
"In this chapter, we've been introduced to _type classes_, a type-oriented "
"form of abstraction which enables powerful forms of code reuse. We've seen a "
"collection of standard type classes from the PureScript standard libraries, "
"and defined our own library based on a type class for computing hash codes."
msgstr ""
"この章では、型に基づく抽象化で、コードの再利用のための強力な形式化を可能にす"
"る**型クラス**を導入しました。PureScriptの標準ライブラリから標準の型クラスを"
"幾つか見てきました。また、ハッシュ値を計算する型クラスに基づく独自のライブラ"
"リを定義しました。"

#. type: Plain text
#: text/chapter6.md:761
#, fuzzy
msgid ""
"This chapter also gave an introduction to the notion of type class laws, a "
"technique for proving properties about code which uses type classes for "
"abstraction. Type class laws are part of a larger subject called _equational "
"reasoning_, in which the properties of a programming language and its type "
"system are used to enable logical reasoning about its programs. This is an "
"important idea, and will be a theme which we will return to throughout the "
"rest of the book."
msgstr ""
"この章では型クラス法則の考え方を導入するとともに、抽象化のための型クラスを使"
"うコードについて、その性質を証明する手法を導入しました。型クラス法則は**等式"
"推論**(equational reasoning)と呼ばれる大きな分野の一部であり、プログラミング"
"言語の性質と型システムはプログラムについて論理的な推論をできるようにするため"
"に使われています。これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話"
"題となるでしょう。"

#. type: Title ##
#: text/chapter7.md:1 text/chapter7.md:387
#, fuzzy, no-wrap
msgid "Applicative Validation"
msgstr "Applicativeによる検証"

#. type: Plain text
#: text/chapter7.md:6
#, fuzzy
msgid ""
"In this chapter, we will meet an important new abstraction - the "
"_applicative functor_, described by the `Applicative` type class. Don't "
"worry if the name sounds confusing - we will motivate the concept with a "
"practical example - validating form data. This technique allows us to "
"convert code which usually involves a lot of boilerplate checking into a "
"simple, declarative description of our form."
msgstr ""
"この章では、`Applicative`型クラスによって表現される**Applicative関手"
"**(applicative functor)という重要な抽象化と新たに出会うことになります。名前が"
"難しそうに思えても心配しないでください。フォームデータの検証という実用的な例"
"を使ってこの概念を説明していきます。Applicative関手を使うと、大量の決まり文句"
"を伴うような入力項目の内容を検証するためのコードを、簡潔で宣言的な記述へと変"
"えることができるようになります。"

#. type: Plain text
#: text/chapter7.md:8
#, fuzzy
msgid ""
"We will also meet another type class, `Traversable`, which describes "
"_traversable functors_, and see how this concept also arises very naturally "
"from solutions to real-world problems."
msgstr ""
"また、**Traversable関手**(traversable functor)を表現する`Traversable`という別"
"の型クラスにも出会います。現実の問題への解決策からこの概念が自然に生じるとい"
"うことがわかるでしょう。"

#. type: Plain text
#: text/chapter7.md:10
#, fuzzy
msgid ""
"The example code for this chapter will be a continuation of the address book "
"example from chapter 3. This time, we will extend our address book data "
"types, and write functions to validate values for those types. The "
"understanding is that these functions could be used, for example in a web "
"user interface, to display errors to the user as part of a data entry form."
msgstr ""
"この章では第3章に引き続き住所録を例として扱います。今回は住所録のデータ型を拡"
"張し、これらの型の値を検証する関数を書きます。これらの関数は、例えばデータ入"
"力フォームの一部で、使用者へエラーを表示するウェブユーザインタフェースで使わ"
"れると考えてください。　　　　"

#. type: Plain text
#: text/chapter7.md:14
#, fuzzy
msgid ""
"The source code for this chapter is defined in the files `src/Data/"
"AddressBook.purs` and `src/Data/AddressBook/Validation.purs`."
msgstr ""
"この章のソース·コードは、ふたつのファイル`src/Data/AddressBook.purs`および"
"`src/Data/AddressBook/Validation.purs`で定義されています。"

#. type: Plain text
#: text/chapter7.md:16
#, fuzzy
msgid ""
"The project has a number of dependencies, many of which we have seen before. "
"There are two new dependencies:"
msgstr ""
"このプロジェクトは多くのBower依存関係を持っていますが、その大半はすでに見てき"
"たものです。新しい依存関係は２つです。"

#. type: Plain text
#: text/chapter7.md:19
#, fuzzy
msgid ""
"- `control`, which defines functions for abstracting control flow using type "
"classes like `Applicative`.  - `validation`, which defines a functor for "
"_applicative validation_, the subject of this chapter."
msgstr ""
"- `purescript-control` - `Applicative`のような型クラスを使用して制御フローを"
"抽象化する関数が定義されています - `purescript-validation` - この章の主題であ"
"る **`Applicative`による検証** のための関手が定義されています。"

#. type: Plain text
#: text/chapter7.md:21
#, fuzzy
msgid ""
"The `Data.AddressBook` module defines data types and `Show` instances for "
"the types in our project, and the `Data.AddressBook.Validation` module "
"contains validation rules for those types."
msgstr ""
"`Data.AddressBook`モジュールには、このプロジェクトのデータ型とそれらの型に対"
"する`Show`インスタンスが定義されており、`Data.AddressBook.Validation`モジュー"
"ルにはそれらの型の検証規則含まれています。"

#. type: Title ##
#: text/chapter7.md:22
#, fuzzy, no-wrap
msgid "Generalizing Function Application"
msgstr "関数適用の一般化"

#. type: Plain text
#: text/chapter7.md:25
#, fuzzy
msgid ""
"To explain the concept of an _applicative functor_, let's consider the type "
"constructor `Maybe` that we met earlier."
msgstr ""
"**Applicative関手**の概念を理解するために、まずは以前扱った型構築子`Maybe`に"
"ついて考えてみましょう。\n"

#. type: Plain text
#: text/chapter7.md:27
#, fuzzy
msgid ""
"The source code for this module defines a function `address` which has the "
"following type:"
msgstr ""
"このモジュールのソースコードでは、次のような型を持つ`address`関数が定義されて"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:28
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:33
#, fuzzy
msgid ""
"This function is used to construct a value of type `Address` from three "
"strings: a street name, a city, and a state."
msgstr ""
"この関数は、通りの名前、市、州という３つの文字列から型`Address`の値を構築する"
"ために使います。"

#. type: Plain text
#: text/chapter7.md:35
#, fuzzy
msgid "We can apply this function easily and see the result in PSCi:"
msgstr "この関数は簡単に適用できますので、`PSCi`でどうなるか見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:36
#, fuzzy, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> address \"123 Fake St.\" \"Faketown\" \"CA\"\n"
"{ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"
msgstr ""
"> import Data.AddressBook\n"
"\n"
"> address \"123 Fake St.\" \"Faketown\" \"CA\"\n"
"Address { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" }\n"

#. type: Plain text
#: text/chapter7.md:44
#, fuzzy
msgid ""
"However, suppose we did not necessarily have a street, city, or state, and "
"wanted to use the `Maybe` type to indicate a missing value in each of the "
"three cases."
msgstr ""
"しかし、通り、市、州の三つすべてが必ずしも入力されないものとすると、三つの場"
"合がそれぞれ省略可能であることを示すために`Maybe`型を使用したくなります。"

#. type: Plain text
#: text/chapter7.md:46
#, fuzzy
msgid ""
"In one case, we might have a missing city. If we try to apply our function "
"directly, we will receive an error from the type checker:"
msgstr ""
"考えられる場合としては、市が省略されている場合があるでしょう。もし`address`関"
"数を直接適用しようとすると、型検証器からエラーが表示されます。"

#. type: Fenced code block (text)
#: text/chapter7.md:47
#, fuzzy, no-wrap
msgid ""
"> import Data.Maybe\n"
"> address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Could not match type\n"
"\n"
"  Maybe String\n"
"\n"
"with type\n"
"\n"
"  String\n"
msgstr ""
"> import Data.Maybe\n"
"> address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Could not match type Maybe String with type String\n"

#. type: Plain text
#: text/chapter7.md:61
#, fuzzy
msgid ""
"Of course, this is an expected type error - `address` takes strings as "
"arguments, not values of type `Maybe String`."
msgstr ""
"`address`は`Maybe String`型ではなく文字列型の引数を取るので、もちろんこれは型"
"エラーになります。"

#. type: Plain text
#: text/chapter7.md:63
#, fuzzy
msgid ""
"However, it is reasonable to expect that we should be able to \"lift\" the "
"`address` function to work with optional values described by the `Maybe` "
"type. In fact, we can, and the `Control.Apply` provides the function `lift3` "
"function which does exactly what we need:"
msgstr ""
"しかし、もし`address`関数を「持ち上げる」ことができれば、`Maybe`型で示される"
"省略可能な値を扱うことができるはずだと期待することは理にかなっています。実際"
"に、`Control.Apply`で提供されている関数`lift3`が、まさに求めているものです。"

#. type: Fenced code block (text)
#: text/chapter7.md:64
#, fuzzy, no-wrap
msgid ""
"> import Control.Apply\n"
"> lift3 address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Nothing\n"
msgstr ""
"> import Control.Apply\n"
"> lift3 address (Just \"123 Fake St.\") Nothing (Just \"CA\")\n"
"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:72
#, fuzzy
msgid ""
"In this case, the result is `Nothing`, because one of the arguments (the "
"city) was missing. If we provide all three arguments using the `Just` "
"constructor, then the result will contain a value as well:"
msgstr ""
"このとき、引数のひとつ(市)が欠落していたので、結果は`Nothing`になります。もし"
"3つの引数すべてが`Just`構築子を使って与えられれば、結果は値を含むことになりま"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:73
#, fuzzy, no-wrap
msgid ""
"> lift3 address (Just \"123 Fake St.\") (Just \"Faketown\") (Just \"CA\")\n"
"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
msgstr ""
"> lift3 address (Just \"123 Fake St.\") (Just \"Faketown\") (Just \"CA\")\n"
"  \n"
"Just (Address { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"

#. type: Plain text
#: text/chapter7.md:80
#, fuzzy
msgid ""
"The name of the function `lift3` indicates that it can be used to lift "
"functions of 3 arguments. There are similar functions defined in `Control."
"Apply` for functions of other numbers of arguments."
msgstr ""
"`lift3`という関数の名前は、3引数の関数を持ち上げるために使用できることを示し"
"ています。関数を持ち上げる同様の関数で、引数の数が異なるものが、`Control."
"Apply`で定義されています。"

#. type: Title ##
#: text/chapter7.md:81
#, fuzzy, no-wrap
msgid "Lifting Arbitrary Functions"
msgstr "任意個の引数を持つ関数の持ち上げ"

#. type: Plain text
#: text/chapter7.md:84
#, fuzzy
msgid ""
"So, we can lift functions with small numbers of arguments by using `lift2`, "
"`lift3`, etc. But how can we generalize this to arbitrary functions?"
msgstr ""
"これで、`lift2`や`lift3`のような関数を使えば、引数が2個や3個の関数を持ち上げ"
"ることができるのはわかりました。でも、これを任意個の引数の関数へと一般化する"
"ことはできるのでしょうか。"

#. type: Plain text
#: text/chapter7.md:86
#, fuzzy
msgid "It is instructive to look at the type of `lift3`:"
msgstr "`lift3`の型を見てみるとわかりやすいでしょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:87
#, fuzzy, no-wrap
msgid ""
"> :type lift3\n"
"forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
msgstr ""
"> :type lift3\n"
"forall a b c d f. Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"

#. type: Plain text
#: text/chapter7.md:93
#, fuzzy
msgid ""
"In the `Maybe` example above, the type constructor `f` is `Maybe`, so that "
"`lift3` is specialized to the following type:"
msgstr ""
"上の`Maybe`の例では型構築子`f`は`Maybe`ですから、`lift3`は次のように特殊化さ"
"れます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:94
#, fuzzy, no-wrap
msgid "forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
msgstr "forall a b c d. (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"

#. type: Plain text
#: text/chapter7.md:99
#, fuzzy
msgid ""
"This type says that we can take any function with three arguments, and lift "
"it to give a new function whose argument and result types are wrapped with "
"`Maybe`."
msgstr ""
"この型が言っているのは、3引数の任意の関数を取り、その関数を引数と返り値が"
"`Maybe`で包まれた新しい関数へと持ち上げる、ということです。"

#. type: Plain text
#: text/chapter7.md:101
#, fuzzy
msgid ""
"Certainly, this is not possible for every type constructor `f`, so what is "
"it about the `Maybe` type which allowed us to do this? Well, in specializing "
"the type above, we removed a type class constraint on `f` from the `Apply` "
"type class. `Apply` is defined in the Prelude as follows:"
msgstr ""
"もちろんどんな型構築子`f`についても持ち上げができるわけではないのですが、それ"
"では`Maybe`型を持ち上げができるようにしているものは何なのでしょうか。さて、先"
"ほどの型の特殊化では、`f`に対する型クラス制約から`Apply`型クラスを取り除いて"
"いました。`Apply`はPreludeで次のように定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:102
#, fuzzy, no-wrap
msgid ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
"\n"
"class Functor f <= Apply f where\n"
"  apply :: forall a b. f (a -> b) -> f a -> f b\n"
msgstr ""
"class Functor f where\n"
"  map :: forall a b. (a -> b) -> f a -> f b\n"
"class Functor f <= Apply f where\n"
"  apply :: forall a b. f (a -> b) -> f a -> f b\n"

#. type: Plain text
#: text/chapter7.md:111
#, fuzzy, no-wrap
msgid "The `Apply` type class is a subclass of `Functor`, and defines an additional function `apply`. As `<$>` was defined as an alias for `map`, the `Prelude` module defines `<*>` as an alias for `apply`. As we'll see, these two operators are often used together.\n"
msgstr ""
"`Apply`型クラスは`Functor`の下位クラスであり、追加の関数`apply`が定義しています。\n"
"`Prelude`モジュールでは`<$>`を、`map`の別名として、`<*>`を`apply`の別名として定義しています。\n"
"`map`とよく似た型を持つ追加の関数`apply`が定義されています。\n"

#. type: Plain text
#: text/chapter7.md:113
msgid ""
"Note that this [`apply`](https://pursuit.purescript.org/packages/purescript-"
"prelude/docs/Control.Apply#v:apply) is different than the [`apply`](https://"
"pursuit.purescript.org/packages/purescript-prelude/docs/Data.Function#v:"
"apply) from `Data.Function` (infixed as `$`). Luckily, infix notation is "
"almost always used for the latter, so you don't need to worry about name "
"collisions."
msgstr ""

#. type: Plain text
#: text/chapter7.md:115
#, fuzzy
msgid ""
"The type of `apply` looks a lot like the type of `map`. The difference "
"between `map` and `apply` is that `map` takes a function as an argument, "
"whereas the first argument to `apply` is wrapped in the type constructor "
"`f`. We'll see how this is used soon, but first, let's see how to implement "
"the `Apply` type class for the `Maybe` type:"
msgstr ""
"`map`と`apply`の違いは、`map`がただの関数を引数に取るのに対し、`apply`の最初"
"の引数は型構築子`f`で包まれているという点です。 これをどのように使うのかはこ"
"れからすぐに見ていきますが、その前にまず`Maybe`型について`Apply`型クラスをど"
"う実装するのかを見ていきましょう。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:116
#, fuzzy, no-wrap
msgid ""
"instance functorMaybe :: Functor Maybe where\n"
"  map f (Just a) = Just (f a)\n"
"  map f Nothing  = Nothing\n"
"\n"
"instance applyMaybe :: Apply Maybe where\n"
"  apply (Just f) (Just x) = Just (f x)\n"
"  apply _        _        = Nothing\n"
msgstr ""
"instance functorMaybe :: Functor Maybe where\n"
"  map f (Just a) = Just (f a)\n"
"  map f Nothing  = Nothing\n"
"\n"
"instance applyMaybe :: Apply Maybe where\n"
"  apply (Just f) (Just x) = Just (f x)\n"
"  apply _        _        = Nothing\n"

#. type: Plain text
#: text/chapter7.md:127
#, fuzzy
msgid ""
"This type class instance says that we can apply an optional function to an "
"optional value, and the result is defined only if both are defined."
msgstr ""
"この型クラスのインスタンスが言っているのは、任意のオプショナルな値にオプショ"
"ナルな関数を適用することができ、その両方が定義されている時に限り結果も定義さ"
"れる、ということです。"

#. type: Plain text
#: text/chapter7.md:129
#, fuzzy
msgid ""
"Now we'll see how `map` and `apply` can be used together to lift functions "
"of arbitrary number of arguments."
msgstr ""
"それでは、`map`と`apply`を一緒に使ってどうやって引数が任意個の関数を持ち上げ"
"るのかを見ていきましょう。"

#. type: Plain text
#: text/chapter7.md:131
#, fuzzy
msgid "For functions of one argument, we can just use `map` directly."
msgstr "１引数の関数については、`map`をそのまま使うだけです。"

#. type: Plain text
#: text/chapter7.md:133
#, fuzzy, no-wrap
msgid "For functions of two arguments, we have a curried function `g` with type `a -> b -> c`, say. This is equivalent to the type `a -> (b -> c)`, so we can apply `map` to `g` to get a new function of type `f a -> f (b -> c)` for any type constructor `f` with a `Functor` instance. Partially applying this function to the first lifted argument (of type `f a`), we get a new wrapped function of type `f (b -> c)`. If we also have an `Apply` instance for `f`, we can then use `apply` to apply the second lifted argument (of type `f b`) to get our final value of type `f c`.\n"
msgstr "２引数の関数についても考えてみます。型`a -> b -> c`を持つカリー化された関数`f`があるとしましょう。これは型`a -> (b -> c)`と同じですから、`map`を`f`に適用すると型`f a -> f (b -> c)`の新たな関数を得ることになります。持ち上げられた(型`f a`の)最初の引数にその関数を部分適用すると、型`f (b -> c)`の新たな包まれた関数が得られます。それから、２番目の持ち上げられた(型`f b`の)引数へ`apply`を適用することができ、型`f c`の最終的な値を得ます。\n"

#. type: Plain text
#: text/chapter7.md:135
#, fuzzy, no-wrap
msgid "Putting this all together, we see that if we have values `x :: f a` and `y :: f b`, then the expression `(g <$> x) <*> y` has type `f c` (remember, this expression is equivalent to `apply (map g x) y`). The precedence rules defined in the Prelude allow us to remove the parentheses: `g <$> x <*> y`.\n"
msgstr "まとめると、`x :: f a`と`y :: f b`があるとき、式`(f <$> x) <*> y`の型は`f c`になります(この式は`apply (map f x)  y`と同じ意味だということを思い出しましょう)。Preludeで定義された優先順位の規則に従うと、`f <$> x <*> y`というように括弧を外すことができます。\n"

#. type: Plain text
#: text/chapter7.md:137
#, fuzzy, no-wrap
msgid "In general, we can use `<$>` on the first argument, and `<*>` for the remaining arguments, as illustrated here for `lift3`:\n"
msgstr "一般的にいえば、最初の引数に`<$>`を使い、残りの引数に対しては`<*>`を使います。`lift3`で説明すると次のようになります。\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:138
#, fuzzy, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z\n"
msgstr ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z \n"

#. type: Plain text
#: text/chapter7.md:150
#, fuzzy
msgid ""
"It is left as an exercise for the reader to verify the types involved in "
"this expression."
msgstr ""
"この式の型がちゃんと整合しているかの確認は、読者への演習として残しておきま"
"す。"

#. type: Plain text
#: text/chapter7.md:152
#, fuzzy, no-wrap
msgid "As an example, we can try lifting the address function over `Maybe`, directly using the `<$>` and `<*>` functions:\n"
msgstr "例として、`<$>`と`<*>`をそのまま使うと、`Maybe`上に`address`関数を持ち上げることができます。\n"

#. type: Fenced code block (text)
#: text/chapter7.md:153
#, fuzzy, no-wrap
msgid ""
"> address <$> Just \"123 Fake St.\" <*> Just \"Faketown\" <*> Just \"CA\"\n"
"Just ({ street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
"\n"
"> address <$> Just \"123 Fake St.\" <*> Nothing <*> Just \"CA\"\n"
"Nothing\n"
msgstr ""
"> address <$> Just \"123 Fake St.\" <*> Just \"Faketown\" <*> Just \"CA\"\n"
"Just (Address { street: \"123 Fake St.\", city: \"Faketown\", state: \"CA\" })\n"
"\n"
"> address <$> Just \"123 Fake St.\" <*> Nothing <*> Just \"CA\"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:162
#, fuzzy
msgid ""
"Try lifting some other functions of various numbers of arguments over "
"`Maybe` in this way."
msgstr ""
"このように、引数が異なる他のいろいろな関数を`Maybe`上に持ち上げてみてくださ"
"い。"

#. type: Plain text
#: text/chapter7.md:164
msgid ""
"Alternatively _applicative do notation_ can be used for the same purpose in "
"a way that looks similar to the familiar _do notation_. Here is `lift3` "
"using _applicative do notation_. Note `ado` is used instead of `do`, and "
"`in` is used on the final line to denote the yielded value:"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter7.md:165
#, fuzzy, no-wrap
msgid ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = ado\n"
"  a <- x\n"
"  b <- y\n"
"  c <- z\n"
"  in f a b c\n"
msgstr ""
"lift3 :: forall a b c d f\n"
"       . Apply f\n"
"      => (a -> b -> c -> d)\n"
"      -> f a\n"
"      -> f b\n"
"      -> f c\n"
"      -> f d\n"
"lift3 f x y z = f <$> x <*> y <*> z \n"

#. type: Title ##
#: text/chapter7.md:180
#, fuzzy, no-wrap
msgid "The Applicative Type Class"
msgstr "Applicative型クラス"

#. type: Plain text
#: text/chapter7.md:183
#, fuzzy
msgid "There is a related type class called `Applicative`, defined as follows:"
msgstr ""
"これに関連する`Applicative`という型クラスが存在しており、次のように定義されて"
"います。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:184
#, fuzzy, no-wrap
msgid ""
"class Apply f <= Applicative f where\n"
"  pure :: forall a. a -> f a\n"
msgstr ""
"class Apply f <= Applicative f where\n"
"  pure :: forall a. a -> f a\n"

#. type: Plain text
#: text/chapter7.md:190
#, fuzzy
msgid ""
"`Applicative` is a subclass of `Apply` and defines the `pure` function. "
"`pure` takes a value and returns a value whose type has been wrapped with "
"the type constructor `f`."
msgstr ""
"`Applicative`は`Apply`の下位クラスであり、`pure`関数が定義されています。"
"`pure`は値を取り、その型の型構築子`f`で包まれた値を返します。"

#. type: Plain text
#: text/chapter7.md:192
#, fuzzy
msgid "Here is the `Applicative` instance for `Maybe`:"
msgstr "`Maybe`についての`Applicative`インスタンスは次のようになります。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:193
#, fuzzy, no-wrap
msgid ""
"instance applicativeMaybe :: Applicative Maybe where\n"
"  pure x = Just x\n"
msgstr ""
"instance applicativeMaybe :: Applicative Maybe where\n"
"  pure x = Just x\n"

#. type: Plain text
#: text/chapter7.md:199
#, fuzzy
msgid ""
"If we think of applicative functors as functors which allow lifting of "
"functions, then `pure` can be thought of as lifting functions of zero "
"arguments."
msgstr ""
"Applicative関手は関数を持ち上げることを可能にする関手だと考えるとすると、"
"`pure`は引数のない関数の持ち上げだというように考えることができます。"

#. type: Title ##
#: text/chapter7.md:200
#, fuzzy, no-wrap
msgid "Intuition for Applicative"
msgstr "Applicativeに対する直感的理解"

#. type: Plain text
#: text/chapter7.md:203
#, fuzzy
msgid ""
"Functions in PureScript are pure and do not support side-effects. "
"Applicative functors allow us to work in larger \"programming languages\" "
"which support some sort of side-effect encoded by the functor `f`."
msgstr ""
"PureScriptの関数は純粋であり、副作用は持っていません。Applicative関手は、関手"
"`f`によって表現されたある種の副作用を提供するような、より大きな「プログラミン"
"グ言語」を扱えるようにします。"

#. type: Plain text
#: text/chapter7.md:205
#, fuzzy, no-wrap
msgid "As an example, the functor `Maybe` represents the side effect of possibly-missing values. Some other examples include `Either err`, which represents the side effect of possible errors of type `err`, and the arrow functor `r ->` which represents the side-effect of reading from a global configuration. For now, we'll only consider the `Maybe` functor.\n"
msgstr "たとえば、関手`Maybe`はオプショナルな値の副作用を表現しています。その他の例としては、型`err`のエラーの可能性の副作用を表す`Either err`や、大域的な構成を読み取る副作用を表すArrow関手(arrow functor)`r ->`があります。ここでは`Maybe`関手についてだけを考えることにします。\n"

#. type: Plain text
#: text/chapter7.md:207
#, fuzzy
msgid ""
"If the functor `f` represents this larger programming language with effects, "
"then the `Apply` and `Applicative` instances allow us to lift values and "
"function applications from our smaller programming language (PureScript) "
"into the new language."
msgstr ""
"もし関手`f`が作用を持つより大きなプログラミング言語を表すとすると、`Apply`と"
"`Applicative`インスタンスは小さなプログラミング言語(PureScript)から新しい大き"
"な言語へと値や関数を持ち上げることを可能にします。"

#. type: Plain text
#: text/chapter7.md:209
#, fuzzy
msgid ""
"`pure` lifts pure (side-effect free) values into the larger language, and "
"for functions, we can use `map` and `apply` as described above."
msgstr ""
"`pure`は純粋な(副作用がない)値をより大きな言語へと持ち上げますし、関数につい"
"ては上で述べたとおり`map`と`apply`を使うことができます。"

#. type: Plain text
#: text/chapter7.md:211
#, fuzzy
msgid ""
"This raises a question: if we can use `Applicative` to embed PureScript "
"functions and values into this new language, then how is the new language "
"any larger? The answer depends on the functor `f`. If we can find "
"expressions of type `f a` which cannot be expressed as `pure x` for some "
"`x`, then that expression represents a term which only exists in the larger "
"language."
msgstr ""
"ここで新たな疑問が生まれます。もしPureScriptの関数と値を新たな言語へ埋め込む"
"のに`Applicative`が使えるなら、どうやって新たな言語は大きくなっているというの"
"でしょうか。この答えは関手`f`に依存します。もしなんらかの`x`について`pure x`"
"で表せないような型`f a`の式を見つけたなら、その式はそのより大きな言語だけに存"
"在する項を表しているということです。"

#. type: Plain text
#: text/chapter7.md:213
#, fuzzy
msgid ""
"When `f` is `Maybe`, an example is the expression `Nothing`: we cannot write "
"`Nothing` as `pure x` for any `x`. Therefore, we can think of PureScript as "
"having been enlarged to include the new term `Nothing`, which represents a "
"missing value."
msgstr ""
"`f`が`Maybe`のときの式`Nothing`がその例になっています。`Nothing`を何らかの`x`"
"について`pure x`というように書くことはできません。したがって、PureScriptは省"
"略可能な値を表す新しい項`Nothing`を含むように拡大されたと考えることができま"
"す。"

#. type: Title ##
#: text/chapter7.md:214
#, fuzzy, no-wrap
msgid "More Effects"
msgstr "その他の作用について"

#. type: Plain text
#: text/chapter7.md:217
#, fuzzy
msgid ""
"Let's see some more examples of lifting functions over different "
"`Applicative` functors."
msgstr ""
"それでは、他にも`Applicative`関手へと関数を持ち上げる例をいろいろ見ていきま"
"しょう。"

#. type: Plain text
#: text/chapter7.md:219
#, fuzzy
msgid ""
"Here is a simple example function defined in PSCi, which joins three names "
"to form a full name:"
msgstr ""
"次は、`PSCi`で定義された3つの名前を結合して完全な名前を作る簡単なコード例で"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:220
#, fuzzy, no-wrap
msgid ""
"> import Prelude\n"
"\n"
"> fullName first middle last = last <> \", \" <> first <> \" \" <> middle\n"
"\n"
"> fullName \"Phillip\" \"A\" \"Freeman\"\n"
"Freeman, Phillip A\n"
msgstr ""
"> import Prelude\n"
"> fullName first middle last = last <> \", \" <> first <> \" \" <> middle\n"
"> fullName \"Phillip\" \"A\" \"Freeman\"\n"
"Freeman, Phillip A\n"

#. type: Plain text
#: text/chapter7.md:230
#, fuzzy
msgid ""
"Now suppose that this function forms the implementation of a (very simple!) "
"web service with the three arguments provided as query parameters. We want "
"to make sure that the user provided each of the three parameters, so we "
"might use the `Maybe` type to indicate the presence or otherwise absence of "
"a parameter. We can lift `fullName` over `Maybe` to create an implementation "
"of the web service which checks for missing parameters:"
msgstr ""
"この関数は、クエリパラメータとして与えられた3つの引数を持つ、(とても簡単な!)"
"ウェブサービスの実装であるとしましょう。使用者が3つの引数すべてを与えたことを"
"確かめたいので、引数が存在するかどうかを表す`Maybe`型をつかうことになるでしょ"
"う。`fullName`を`Maybe`の上へ持ち上げると、省略された引数を確認するウェブサー"
"ビスを実装することができます。"

#. type: Fenced code block (text)
#: text/chapter7.md:231
#, fuzzy, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"
msgstr ""
"> import Data.Maybe\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:242 text/chapter7.md:292 text/chapter7.md:444
#: text/chapter7.md:479 text/chapter7.md:525 text/chapter7.md:557
msgid "or with _applicative do_"
msgstr ""

#. type: Fenced code block (text)
#: text/chapter7.md:243
#, fuzzy, no-wrap
msgid ""
"> import Data.Maybe\n"
"\n"
"> :pasteâ¦\n"
"â¦ ado\n"
"â¦   f <- Just \"Phillip\"\n"
"â¦   m <- Just \"A\"\n"
"â¦   l <- Just \"Freeman\"\n"
"â¦   in fullName f m l\n"
"â¦ ^D\n"
"(Just \"Freeman, Phillip A\")\n"
"\n"
"â¦ ado\n"
"â¦   f <- Just \"Phillip\"\n"
"â¦   m <- Nothing\n"
"â¦   l <- Just \"Freeman\"\n"
"â¦   in fullName f m l\n"
"â¦ ^D\n"
"Nothing\n"
msgstr ""
"> import Data.Maybe\n"
"> fullName <$> Just \"Phillip\" <*> Just \"A\" <*> Just \"Freeman\"\n"
"Just (\"Freeman, Phillip A\")\n"
"> fullName <$> Just \"Phillip\" <*> Nothing <*> Just \"Freeman\"\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:265
#, fuzzy
msgid ""
"Note that the lifted function returns `Nothing` if any of the arguments was "
"`Nothing`."
msgstr ""
"この持ち上げた関数は、引数のいずれかが`Nothing`なら`Nothing`返すことに注意し"
"てください。"

#. type: Plain text
#: text/chapter7.md:267
#, fuzzy
msgid ""
"This is good, because now we can send an error response back from our web "
"service if the parameters are invalid. However, it would be better if we "
"could indicate which field was incorrect in the response."
msgstr ""
"これで、もし引数が不正ならWebサービスからエラー応答を送信することができるの"
"で、なかなかいい感じです。しかし、どのフィールドが間違っていたのかを応答で表"
"示できると、もっと良くなるでしょう。"

#. type: Plain text
#: text/chapter7.md:269
#, fuzzy
msgid ""
"Instead of lifting over `Maybe`, we can lift over `Either String`, which "
"allows us to return an error message. First, let's write an operator to "
"convert optional inputs into computations which can signal an error using "
"`Either String`:"
msgstr ""
"`Meybe`上へ持ち上げる代わりに`Either String`上へ持ち上げるようにすると、エ"
"ラーメッセージを返すことができるようになります。まずは入力を`Either String`を"
"使ってエラーを発信できる計算に変換する演算子を書きましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:270
#, fuzzy, no-wrap
msgid ""
"> import Data.Either\n"
"> :paste\n"
"â¦ withError Nothing  err = Left err\n"
"â¦ withError (Just a) _   = Right a\n"
"â¦ ^D\n"
msgstr ""
"> :paste\n"
"… withError Nothing err = Left err\n"
"… withError (Just a) _  = Right a\n"
"… ^D\n"

#. type: Plain text
#: text/chapter7.md:279
#, fuzzy
msgid ""
"_Note_: In the `Either err` applicative functor, the `Left` constructor "
"indicates an error, and the `Right` constructor indicates success."
msgstr ""
"**注意**：`Either err`Applicative関手において、`Left`構築子は失敗を表してお"
"り、`Right`構築子は成功を表しています。\n"

#. type: Plain text
#: text/chapter7.md:281
#, fuzzy
msgid ""
"Now we can lift over `Either String`, providing an appropriate error message "
"for each parameter:"
msgstr ""
"これで`Either String`上へ持ち上げることで、それぞれの引数について適切なエラー"
"メッセージを提供できるようになります。"

#. type: Fenced code block (text)
#: text/chapter7.md:282
#, fuzzy, no-wrap
msgid ""
"> :paste\n"
"â¦ fullNameEither first middle last =\n"
"â¦   fullName <$> (first  `withError` \"First name was missing\")\n"
"â¦            <*> (middle `withError` \"Middle name was missing\")\n"
"â¦            <*> (last   `withError` \"Last name was missing\")\n"
"â¦ ^D\n"
msgstr ""
"> :paste\n"
"… fullNameEither first middle last =\n"
"…   fullName <$> (first  `withError` \"First name was missing\")\n"
"…            <*> (middle `withError` \"Middle name was missing\")\n"
"…            <*> (last   `withError` \"Last name was missing\")\n"
"… ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"

#. type: Fenced code block (text)
#: text/chapter7.md:293
#, fuzzy, no-wrap
msgid ""
"> :paste\n"
"â¦ fullNameEither first middle last = ado\n"
"â¦  f <- first  `withError` \"First name was missing\"\n"
"â¦  m <- middle `withError` \"Middle name was missing\"\n"
"â¦  l <- last   `withError` \"Last name was missing\"\n"
"â¦  in fullName f m l\n"
"â¦ ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"
msgstr ""
"> :paste\n"
"… fullNameEither first middle last =\n"
"…   fullName <$> (first  `withError` \"First name was missing\")\n"
"…            <*> (middle `withError` \"Middle name was missing\")\n"
"…            <*> (last   `withError` \"Last name was missing\")\n"
"… ^D\n"
"\n"
"> :type fullNameEither\n"
"Maybe String -> Maybe String -> Maybe String -> Either String String\n"

#. type: Plain text
#: text/chapter7.md:307
#, fuzzy
msgid ""
"Now our function takes three optional arguments using `Maybe`, and returns "
"either a `String` error message or a `String` result."
msgstr ""
"この関数は`Maybe`の3つの省略可能な引数を取り、`String`のエラーメッセージか"
"`String`の結果のどちらかを返します。"

#. type: Plain text
#: text/chapter7.md:309
#, fuzzy
msgid "We can try out the function with different inputs:"
msgstr "いろいろな入力でこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:310
#, fuzzy, no-wrap
msgid ""
"> fullNameEither (Just \"Phillip\") (Just \"A\") (Just \"Freeman\")\n"
"(Right \"Freeman, Phillip A\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") Nothing (Just \"Freeman\")\n"
"(Left \"Middle name was missing\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") (Just \"A\") Nothing\n"
"(Left \"Last name was missing\")\n"
msgstr ""
"> fullNameEither (Just \"Phillip\") (Just \"A\") (Just \"Freeman\")\n"
"(Right \"Freeman, Phillip A\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") Nothing (Just \"Freeman\")\n"
"(Left \"Middle name was missing\")\n"
"\n"
"> fullNameEither (Just \"Phillip\") (Just \"A\") Nothing\n"
"(Left \"Last name was missing\")\n"

#. type: Plain text
#: text/chapter7.md:322
#, fuzzy
msgid ""
"In this case, we see the error message corresponding to the first missing "
"field, or a successful result if every field was provided. However, if we "
"are missing multiple inputs, we still only see the first error:"
msgstr ""
"このとき、すべてのフィールドが与えられば成功の結果が表示され、そうでなければ"
"省略されたフィールドのうち最初のものに対応するエラーメッセージが表示されま"
"す。しかし、もし複数の入力が省略されているとき、最初のエラーしか見ることがで"
"きません。"

#. type: Fenced code block (text)
#: text/chapter7.md:323
#, fuzzy, no-wrap
msgid ""
"> fullNameEither Nothing Nothing Nothing\n"
"(Left \"First name was missing\")\n"
msgstr ""
"> fullNameEither Nothing Nothing Nothing\n"
"\n"
"(Left \"First name was missing\")\n"

#. type: Plain text
#: text/chapter7.md:329
#, fuzzy
msgid ""
"This might be good enough, but if we want to see a list of _all_ missing "
"fields in the error, then we need something more powerful than `Either "
"String`. We will see a solution later in this chapter."
msgstr ""
"これでも十分なときもありますが、エラー時に**すべての**省略されたフィールドの"
"一覧がほしいときは、`Either String`よりも強力なものが必要です。この章の後半で"
"この解決策を見ていきます。"

#. type: Title ##
#: text/chapter7.md:330
#, fuzzy, no-wrap
msgid "Combining Effects"
msgstr "作用の結合"

#. type: Plain text
#: text/chapter7.md:333
#, fuzzy
msgid ""
"As an example of working with applicative functors abstractly, this section "
"will show how to write a function which will generically combine side-"
"effects encoded by an applicative functor `f`."
msgstr ""
"抽象的にApplicative関手を扱う例として、Applicative関手`f`によって表現された副"
"作用を総称的に組み合わせる関数をどのように書くのかをこの節では示します。"

#. type: Plain text
#: text/chapter7.md:335
#, fuzzy
msgid ""
"What does this mean? Well, suppose we have a list of wrapped arguments of "
"type `f a` for some `a`. That is, suppose we have a list of type `List (f "
"a)`. Intuitively, this represents a list of computations with side-effects "
"tracked by `f`, each with return type `a`. If we could run all of these "
"computations in order, we would obtain a list of results of type `List a`. "
"However, we would still have side-effects tracked by `f`. That is, we expect "
"to be able to turn something of type `List (f a)` into something of type `f "
"(List a)` by \"combining\" the effects inside the original list."
msgstr ""
"これはどういう意味でしょうか？何らかの`a`について型`f a`の包まれた引数の配列"
"があるとしましょう。型`List (f a)`の配列があるということです。直感的には、こ"
"れは`f`によって追跡される副作用を持つ、返り値の型が`a`の計算の配列を表してい"
"ます。これらの計算のすべてを順番に実行することができれば、`List a`型の結果の"
"配列を得るでしょう。しかし、まだ`f`によって追跡される副作用が残ります。つま"
"り、元の配列の中の作用を「結合する」ことにより、型`List (f a)`の何かを型"
"`List a`の何かへと変換することができると考えられます。"

#. type: Plain text
#: text/chapter7.md:337
#, fuzzy, no-wrap
msgid "For any fixed list size `n`, there is a function of `n` arguments which builds a list of size `n` out of those arguments. For example, if `n` is `3`, the function is `\\x y z -> x : y : z : Nil`. This function has type `a -> a -> a -> List a`. We can use the `Applicative` instance for `List` to lift this function over `f`, to get a function of type `f a -> f a -> f a -> f (List a)`. But, since we can do this for any `n`, it makes sense that we should be able to perform the same lifting for any _list_ of arguments.\n"
msgstr "任意の固定長配列の長さ`n`について、その引数を要素に持った長さ`n`の配列を構築するような`n`引数の関数が存在します。たとえば、もし`n`が`3`なら、関数は`\\x y z -> x : y : z : Nil`です。 この関数の型は`a -> a -> a -> List a`です。`Applicative`インスタンスを使うと、この関数を`f`の上へ持ち上げて関数型`f a -> f a -> f a -> f (List a)`を得ることができます。しかし、いかなる`n`についてもこれが可能なので、いかなる引数の**配列**についても同じように持ち上げられることが確かめられます。\n"

#. type: Plain text
#: text/chapter7.md:339
#, fuzzy
msgid "That means that we should be able to write a function"
msgstr "したがって、次のような関数を書くことができるはずです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:340 text/chapter7.md:602
#, fuzzy, no-wrap
msgid "combineList :: forall f a. Applicative f => List (f a) -> f (List a)\n"
msgstr "combineList :: forall f a. Applicative f => List (f a) -> f (List a)\n"

#. type: Plain text
#: text/chapter7.md:345
#, fuzzy
msgid ""
"This function will take a list of arguments, which possibly have side-"
"effects, and return a single wrapped list, applying the side-effects of each."
msgstr ""
"この関数は副作用を持つかもしれない引数の配列をとり、それぞれの副作用を適用す"
"ることで、`f`に包まれた単一の配列を返します。"

#. type: Plain text
#: text/chapter7.md:347
#, fuzzy
msgid ""
"To write this function, we'll consider the length of the list of arguments. "
"If the list is empty, then we do not need to perform any effects, and we can "
"use `pure` to simply return an empty list:"
msgstr ""
"この関数を書くためには、引数の配列の長さについて考えます。配列が空の場合はど"
"んな作用も実行する必要はありませんから、`pure`を使用して単に空の配列を返すこ"
"とができます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:348
#, fuzzy, no-wrap
msgid "combineList Nil = pure Nil\n"
msgstr "combineList Nil = pure Nil\n"

#. type: Plain text
#: text/chapter7.md:353
#, fuzzy
msgid "In fact, this is the only thing we can do!"
msgstr "実際のところ、これが可能な唯一の​​定義です！"

#. type: Plain text
#: text/chapter7.md:355
#, fuzzy, no-wrap
msgid "If the list is non-empty, then we have a head element, which is a wrapped argument of type `f a`, and a tail of type `List (f a)`. We can recursively combine the effects in the tail, giving a result of type `f (List a)`. We can then use `<$>` and `<*>` to lift the `Cons` constructor over the head and new tail:\n"
msgstr "入力の配列が空でないならば、型`f a`の先頭要素と、型`List (f a)`の配列の残りについて考えます。また、再帰的に配列の残りを結合すると、型`f (List a)`の結果を得ることができます。`<$>`と`<*>`を使うと、`cons`関数を先頭と配列の残りの上に持ち上げることができます。\n"

#. type: Fenced code block (haskell)
#: text/chapter7.md:356
#, fuzzy, no-wrap
msgid "combineList (Cons x xs) = Cons <$> x <*> combineList xs\n"
msgstr "combineList (Cons x xs) = Cons <$> x <*> combineList xs\n"

#. type: Plain text
#: text/chapter7.md:361
#, fuzzy
msgid ""
"Again, this was the only sensible implementation, based on the types we were "
"given."
msgstr ""
"繰り返しになりますが、これは与えられた型に基づいている唯一の妥当な実装です。"

#. type: Plain text
#: text/chapter7.md:363
#, fuzzy
msgid ""
"We can test this function in PSCi, using the `Maybe` type constructor as an "
"example:"
msgstr "`Maybe`型構築子を例にとって、`PSCi`でこの関数を試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:364
#, fuzzy, no-wrap
msgid ""
"> import Data.List\n"
"> import Data.Maybe\n"
"\n"
"> combineList (fromFoldable [Just 1, Just 2, Just 3])\n"
"(Just (Cons 1 (Cons 2 (Cons 3 Nil))))\n"
"\n"
"> combineList (fromFoldable [Just 1, Nothing, Just 2])\n"
"Nothing\n"
msgstr ""
"> import Data.List\n"
"> import Data.Maybe\n"
"> combineList (fromFoldable [Just 1, Just 2, Just 3])\n"
"(Just (Cons 1 (Cons 2 (Cons 3 Nil))))\n"
"> combineList (fromFoldable [Just 1, Nothing, Just 2])\n"
"Nothing\n"

#. type: Plain text
#: text/chapter7.md:376
#, fuzzy
msgid ""
"When specialized to `Maybe`, our function returns a `Just` only if every "
"list element was `Just`, otherwise it returns `Nothing`. This is consistent "
"with our intuition of working in a larger language supporting optional "
"values - a list of computations which return optional results only has a "
"result itself if every computation contained a result."
msgstr ""
"`Meybe`へ特殊化して考えると、配列のすべての要素が`Just`であるとき、そのときに"
"限りこの関数は`Just`を返します。そうでなければ、`Nothing`を返します。オプショ"
"ナルな結果を返す計算の配列は、そのすべての計算が結果を持っていたときに全体も"
"結果を持っているという、オプショナルな値に対応したより大きな言語での振る舞い"
"に対する直感的な理解とこれは一致しています。"

#. type: Plain text
#: text/chapter7.md:378
#, fuzzy, no-wrap
msgid "But the `combineList` function works for any `Applicative`! We can use it to combine computations which possibly signal an error using `Either err`, or which read from a global configuration using `r ->`.\n"
msgstr "しかも、`combineArray`関数はどんな`Applicative`に対しても機能します！`Either err`を使ってエラーを発信するかもしれなかったり、`r ->`を使って大域的な状態を読み取る計算を連鎖させるときにも`combineArray`関数を使うことができるのです。\n"

#. type: Plain text
#: text/chapter7.md:380
#, fuzzy
msgid ""
"We will see the `combineList` function again later, when we consider "
"`Traversable` functors."
msgstr ""
"`combineArray`関数については、後ほど`Traversable`関手について考えるときに再び"
"扱います。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Medium) Write versions of the numeric operators `+`, `-`, `*` and `/` which "
"work with optional arguments (i.e. arguments wrapped in `Maybe`) and return "
"a value wrapped in `Maybe`. Name these functions `addMaybe`, `subMaybe`, "
"`mulMaybe`, and `divMaybe`. _Hint_: Use `lift2`."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
msgid ""
"(Medium) Extend the above exercise to work with all `Apply` types (not just "
"`Maybe`). Name these new functions `addApply`, `subApply`, `mulApply`, and "
"`divApply`."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:386
#, fuzzy
msgid ""
"(Difficult) Write a function `combineMaybe` which has type `forall a f. "
"Applicative f => Maybe (f a) -> f (Maybe a)`. This function takes an "
"optional computation with side-effects, and returns a side-effecting "
"computation which has an optional result."
msgstr ""
"(難しい) 型`combineMaybe : forall a f. (Applicative f) => Maybe (f a) -> f "
"(Maybe a)`を持つ関数`combineMaybe`を書いてください。 この関数は副作用をもつオ"
"プショナルな計算をとり、オプショナルな結果をもつ副作用のある計算を返します。"

#. type: Plain text
#: text/chapter7.md:390
#, fuzzy
msgid ""
"The source code for this chapter defines several data types which might be "
"used in an address book application. The details are omitted here, but the "
"key functions which are exported by the `Data.AddressBook` module have the "
"following types:"
msgstr ""
"この章のソースコードでは住所録アプリケーションで使われるいろいろなデータ型が"
"定義されています。詳細はここでは割愛しますが、`Data.AddressBook`モジュールか"
"らエクスポートされる重要な関数は次のような型を持っています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:391
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:address_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:phoneNumber_anno}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook.purs:person_anno}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:400
#, fuzzy
msgid "where `PhoneType` is defined as an algebraic data type:"
msgstr "ここで、`PhoneType`は次のような代数的データ型として定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:401
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:PhoneType}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:406
#, fuzzy
msgid ""
"These functions can be used to construct a `Person` representing an address "
"book entry. For example, the following value is defined in `Data."
"AddressBook`:"
msgstr ""
"これらの関数は住所録の項目を表す`Person`を構築するのに使います。例えば、"
"`Data.AddressBook`には次のような値が定義されています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:407
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook.purs:examplePerson}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:412
#, fuzzy
msgid "Test this value in PSCi (this result has been formatted):"
msgstr "`PSCi`でこれらの値使ってみましょう(結果は整形されています)。"

#. type: Fenced code block (text)
#: text/chapter7.md:413
#, fuzzy, no-wrap
msgid ""
"> import Data.AddressBook\n"
"\n"
"> examplePerson\n"
"{ firstName: \"John\"\n"
", lastName: \"Smith\"\n"
", homeAddress:\n"
"    { street: \"123 Fake St.\"\n"
"    , city: \"FakeTown\"\n"
"    , state: \"CA\"\n"
"    }\n"
", phones:\n"
"    [ { type: HomePhone\n"
"      , number: \"555-555-5555\"\n"
"      }\n"
"    , { type: CellPhone\n"
"      , number: \"555-555-0000\"\n"
"      }\n"
"    ]\n"
"}\n"
msgstr ""
"> import Data.AddressBook\n"
"> examplePerson\n"
"Person\n"
"  { firstName: \"John\",\n"
"  , lastName: \"Smith\",\n"
"  , address: Address\n"
"    { street: \"123 Fake St.\"\n"
"    , city: \"FakeTown\"\n"
"    , state: \"CA\"\n"
"    },\n"
"  , phones: [ PhoneNumber\n"
"              { type: HomePhone\n"
"              , number: \"555-555-5555\"\n"
"              }\n"
"            , PhoneNumber\n"
"              { type: CellPhone\n"
"              , number: \"555-555-0000\"\n"
"              }\n"
"            ]\n"
"  }\n"

#. type: Plain text
#: text/chapter7.md:436
#, fuzzy
msgid ""
"We saw in a previous section how we could use the `Either String` functor to "
"validate a data structure of type `Person`. For example, provided functions "
"to validate the two names in the structure, we might validate the entire "
"data structure as follows:"
msgstr ""
"前の章では型`Person`のデータ構造を検証するのに`Either String`関手をどのように"
"使うかを見ました。例えば、データ構造の２つの名前を検証する関数が与えられたと"
"き、データ構造全体を次のように検証することができます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:437
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty1}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1}}\n"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter7.md:445
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson1Ado}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:450
#, fuzzy
msgid ""
"In the first two lines, we use the `nonEmpty1` function to validate a non-"
"empty string. `nonEmpty1` returns an error indicated with the `Left` "
"constructor if its input is empty, otherwise it returns the value wrapped "
"with the `Right` constructor."
msgstr ""
"最初の２行では`nonEmpty`関数を使って空文字列でないことを検証しています。もし"
"入力が空なら`nonEMpty`はエラーを返し(`Left`構築子で示されています)、そうでな"
"ければ`Right`構築子を使って空の値(`unit`)を正常に返します。２つの検証を実行"
"し、右辺の検証の結果を返すことを示す連鎖演算子`*>`を使っています。ここで、入"
"力を変更せずに返す検証器として右辺では単に`pure`を使っています。\n"

#. type: Plain text
#: text/chapter7.md:452
#, fuzzy
msgid ""
"The final lines do not perform any validation but simply provide the "
"`address` and `phones` fields to the `person` function as the remaining "
"arguments."
msgstr ""
"最後の２行では何の検証も実行せず、単に`address`フィールドと`phones`フィールド"
"を残りの引数として`person`関数へと提供しています。"

#. type: Plain text
#: text/chapter7.md:454
#, fuzzy
msgid ""
"This function can be seen to work in PSCi, but has a limitation which we "
"have seen before:"
msgstr ""
"この関数は`PSCi`でうまく動作するように見えますが、以前見たような制限がありま"
"す。"

#. type: Fenced code block (text)
#: text/chapter7.md:455
#, fuzzy, no-wrap
msgid ""
"> validatePerson $ person \"\" \"\" (address \"\" \"\" \"\") []\n"
"(Left \"Field cannot be empty\")\n"
msgstr ""
"> validatePerson $ person \"\" \"\" (address \"\" \"\" \"\") []\n"
"(Left \"Field cannot be empty\")\n"

#. type: Plain text
#: text/chapter7.md:461
#, fuzzy
msgid ""
"The `Either String` applicative functor only provides the first error "
"encountered. Given the input here, we would prefer to see two errors - one "
"for the missing first name, and a second for the missing last name."
msgstr ""
"`Either String`Applicative関手は遭遇した最初のエラーだけを返します。でもこの"
"入力では、名前の不足と姓の不足という２つのエラーがわかるようにしたくなるで"
"しょう。"

#. type: Plain text
#: text/chapter7.md:463
#, fuzzy
msgid ""
"There is another applicative functor which is provided by the `validation` "
"library. This functor is called `V`, and it provides the ability to return "
"errors in any _semigroup_. For example, we can use `V (Array String)` to "
"return an array of `String`s as errors, concatenating new errors onto the "
"end of the array."
msgstr ""
"`purescript-validation`ライブラリは別のApplicative関手も提供されています。こ"
"れは単に`V`と呼ばれていて、何らかの**半群**(Semigroup)でエラーを返す機能があ"
"ります。たとえば、`V (Array String)`を使うと、新しいエラーを配列の最後に連結"
"していき、`String`の配列をエラーとして返すことができます。"

#. type: Plain text
#: text/chapter7.md:465
#, fuzzy
msgid ""
"The `Data.AddressBook.Validation` module uses the `V (Array String)` "
"applicative functor to validate the data structures in the `Data."
"AddressBook` module."
msgstr ""
"`Data.Validation`モジュールは`Data.AddressBook`モジュールのデータ構造を検証す"
"るために`V (Array String)`Applicative関手を使っています。"

#. type: Plain text
#: text/chapter7.md:467
#, fuzzy
msgid ""
"Here is an example of a validator taken from the `Data.AddressBook."
"Validation` module:"
msgstr ""
"`Data.AddressBook.Validation`モジュールにある検証の例としては次のようになりま"
"す。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:468
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:Errors}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:nonEmpty}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:lengthIs}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddress}}\n"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter7.md:480
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validateAddressAdo}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:485
#, fuzzy
msgid ""
"`validateAddress` validates an `Address` structure. It checks that the "
"`street` and `city` fields are non-empty, and checks that the string in the "
"`state` field has length 2."
msgstr ""
"`validateAddress`は`Address`を検証します。`street`と`city`が空でないかどう"
"か、`state`の文字列の長さが2であるかどうかを検証します。"

#. type: Plain text
#: text/chapter7.md:487
#, fuzzy
msgid ""
"Notice how the `nonEmpty` and `lengthIs` validator functions both use the "
"`invalid` function provided by the `Data.Validation` module to indicate an "
"error. Since we are working in the `Array String` semigroup, `invalid` takes "
"an array of strings as its argument."
msgstr ""
"`nonEmpty`と`lengthIs`の２つの検証関数はいずれも、`Data.Validation`モジュール"
"で提供されている`invalid`関数をエラーを示すために使っていることに注目してくだ"
"さい。`Array String`半群を扱っているので、`invalid`は引数として文字列の配列を"
"取ります。"

#. type: Plain text
#: text/chapter7.md:489
#, fuzzy
msgid "We can try this function in PSCi:"
msgstr "`PSCi`でこの関数を使ってみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:490
#, fuzzy, no-wrap
msgid ""
"> import Data.AddressBook\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> validateAddress $ address \"\" \"\" \"\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         , \"Field 'State' must have length 2\"\n"
"         ])\n"
"\n"
"> validateAddress $ address \"\" \"\" \"CA\"\n"
"(invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         ])\n"
msgstr ""
"> import Data.AddressBook\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> validateAddress $ address \"\" \"\" \"\"\n"
"(Invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         , \"Field 'State' must have length 2\"\n"
"         ])\n"
"\n"
"> validateAddress $ address \"\" \"\" \"CA\"\n"
"(Invalid [ \"Field 'Street' cannot be empty\"\n"
"         , \"Field 'City' cannot be empty\"\n"
"         ])\n"

#. type: Plain text
#: text/chapter7.md:507
#, fuzzy
msgid "This time, we receive an array of all validation errors."
msgstr ""
"これで、すべての検証エラーの配列を受け取ることができるようになりました。"

#. type: Title ##
#: text/chapter7.md:508
#, fuzzy, no-wrap
msgid "Regular Expression Validators"
msgstr "正規表現検証器"

#. type: Plain text
#: text/chapter7.md:511
#, fuzzy
msgid ""
"The `validatePhoneNumber` function uses a regular expression to validate the "
"form of its argument. The key is a `matches` validation function, which uses "
"a `Regex` from the `Data.String.Regex` module to validate its input:"
msgstr ""
"`validatePhoneNumber`関数では引数の形式を検証するために正規表現を使っていま"
"す。重要なのは`matches`検証関数で、この関数は`Data.String.Regex`モジュールの"
"て定義されている`Regex`を使って入力を検証しています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:512
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:matches}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:517
#, fuzzy
msgid ""
"Again, notice how `pure` is used to indicate successful validation, and "
"`invalid` is used to signal an array of errors."
msgstr ""
"繰り返しになりますが、`pure`は常に成功する検証を表しており、エラーの配列の伝"
"達には`invalid`が使われています。"

#. type: Plain text
#: text/chapter7.md:519
#, fuzzy
msgid ""
"`validatePhoneNumber` is built from the `matches` function in the same way "
"as before:"
msgstr ""
"これまでと同じような感じで、`validatePhoneNumber`は`matches`関数から構築され"
"ています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:520
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumber}}\n"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter7.md:526
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumberAdo}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:531
#, fuzzy
msgid ""
"Again, try running this validator against some valid and invalid inputs in "
"PSCi:"
msgstr ""
"また、`PSCi`でいろいろな有効な入力や無効な入力に対して、この検証器を実行して"
"みてください。"

#. type: Fenced code block (text)
#: text/chapter7.md:532
#, fuzzy, no-wrap
msgid ""
"> validatePhoneNumber $ phoneNumber HomePhone \"555-555-5555\"\n"
"pure ({ type: HomePhone, number: \"555-555-5555\" })\n"
"\n"
"> validatePhoneNumber $ phoneNumber HomePhone \"555.555.5555\"\n"
"invalid ([\"Field 'Number' did not match the required format\"])\n"
msgstr ""
"> validatePhoneNumber $ phoneNumber HomePhone \"555-555-5555\"\n"
"Valid (PhoneNumber { type: HomePhone, number: \"555-555-5555\" })\n"
"\n"
"> validatePhoneNumber $ phoneNumber HomePhone \"555.555.5555\"\n"
"Invalid ([\"Field 'Number' did not match the required format\"])\n"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
#, fuzzy
msgid ""
"(Easy) Write a regular expression `stateRegex :: Regex` to check that a "
"string only contains two alphabetic characters. _Hint_: see the source code "
"for `phoneNumberRegex`."
msgstr ""
"(簡単) 正規表現の検証器を使って、`Address`型の`state`フィールドが2文字のアル"
"ファベットであることを確かめてください。**ヒント**：`phoneNumberRegex`のソー"
"スコードを参照してみましょう。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Medium) Write a regular expression `nonEmptyRegex :: Regex` to check that a "
"string is not entirely whitespace. _Hint_: If you need help developing this "
"regex expression, check out [RegExr](https://regexr.com) which has a great "
"cheatsheet and interactive test environment."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:545
msgid ""
"(Medium) Write a function `validateAddressImproved` that is similar to "
"`validateAddress`, but uses the above `stateRegex` to validate the `state` "
"field and `nonEmptyRegex` to validate the `street` and `city` fields. "
"_Hint_: see the source for `validatePhoneNumber` for an example of how to "
"use `matches`."
msgstr ""

#. type: Title ##
#: text/chapter7.md:546
#, fuzzy, no-wrap
msgid "Traversable Functors"
msgstr "Traversable関手"

#. type: Plain text
#: text/chapter7.md:549
#, fuzzy
msgid ""
"The remaining validator is `validatePerson`, which combines the validators "
"we have seen so far to validate an entire `Person` structure, including the "
"following new `validatePhoneNumbers` function:"
msgstr ""
"残った検証器は、これまで見てきた検証器を組み合わせて`Person`全体を検証する"
"`validatePerson`です。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:550
#, no-wrap
msgid ""
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePhoneNumbers}}\n"
"\n"
"{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePerson}}\n"
msgstr ""

#. type: Fenced code block (haskell)
#: text/chapter7.md:558
#, no-wrap
msgid "{{#include ../exercises/chapter7/src/Data/AddressBook/Validation.purs:validatePersonAdo}}\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:563
#, fuzzy
msgid ""
"`validatePhoneNumbers` uses a new function we haven't seen before - "
"`traverse`."
msgstr ""
"これまでと同じような感じで、`validatePhoneNumber`は`matches`関数から構築され"
"ています。"

#. type: Plain text
#: text/chapter7.md:565
#, fuzzy
msgid ""
"`traverse` is defined in the `Data.Traversable` module, in the `Traversable` "
"type class:"
msgstr ""
"`traverse`は`Data.Traversable`モジュールの`Traversable`型クラスで定義されてい"
"ます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:566
#, fuzzy, no-wrap
msgid ""
"class (Functor t, Foldable t) <= Traversable t where\n"
"  traverse :: forall a b m. Applicative m => (a -> m b) -> t a -> m (t b)\n"
"  sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr ""
"class (Functor t, Foldable t) <= Traversable t where\n"
"  traverse :: forall a b f. Applicative f => (a -> f b) -> t a -> f (t b)\n"
"  sequence :: forall a f. Applicative f => t (f a) -> f (t a)\n"

#. type: Plain text
#: text/chapter7.md:573
#, fuzzy
msgid ""
"`Traversable` defines the class of _traversable functors_. The types of its "
"functions might look a little intimidating, but `validatePerson` provides a "
"good motivating example."
msgstr ""
"`Traversable`は**Traversable関手**の型クラスを定義します。これらの関数の型は"
"少し難しそうに見えるかもしれませんが、`validatePerson`は良いきっかけとなる例"
"です。"

#. type: Plain text
#: text/chapter7.md:575
#, fuzzy
msgid ""
"Every traversable functor is both a `Functor` and `Foldable` (recall that a "
"_foldable functor_ was a type constructor which supported a fold operation, "
"reducing a structure to a single value). In addition, a traversable functor "
"provides the ability to combine a collection of side-effects which depend on "
"its structure."
msgstr ""
"すべてのTraversable関手は`Functor`と`Foldable`のどちらでもあります"
"(**Foldable 関手**は構造をひとつの値へとまとめる、畳み込み操作を提供する型構"
"築子であったことを思い出してください)。それ加えて、`Traversable`関手はその構"
"造に依存した副作用のあつまりを連結する機能を提供します。"

#. type: Plain text
#: text/chapter7.md:577
#, fuzzy
msgid ""
"This may sound complicated, but let's simplify things by specializing to the "
"case of arrays. The array type constructor is traversable, which means that "
"there is a function:"
msgstr ""
"複雑そうに聞こえるかもしれませんが、配列の場合に特殊化して簡単に考えてみま"
"しょう。配列型構築子は`Traversable`である、つまり次のような関数が存在するとい"
"うことです。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:578
#, fuzzy, no-wrap
msgid "traverse :: forall a b m. Applicative m => (a -> m b) -> Array a -> m (Array b)\n"
msgstr "traverse :: forall a b f. Applicative f => (a -> f b) -> Array a -> f (Array b)\n"

#. type: Plain text
#: text/chapter7.md:583
#, fuzzy
msgid ""
"Intuitively, given any applicative functor `m`, and a function which takes a "
"value of type `a` and returns a value of type `b` (with side-effects tracked "
"by `m`), we can apply the function to each element of an array of type "
"`Array a` to obtain a result of type `Array b` (with side-effects tracked by "
"`m`)."
msgstr ""
"直感的には、Applicative関手`f`と、型`a`の値をとり型`b`の値を返す(`f`で追跡さ"
"れる副作用を持つ)関数が与えられたとき、型`[a]`の配列の要素それぞれにこの関数"
"を適用し、型`[b]`の(`f`で追跡される副作用を持つ)結果を得ることができます。"

#. type: Plain text
#: text/chapter7.md:585
#, fuzzy
msgid ""
"Still not clear? Let's specialize further to the case where `m` is the `V "
"Errors` applicative functor above. Now, we have a function of type"
msgstr ""
"まだよくわからないでしょうか。それでは、更に`f`を`V Errors`Applicative関手に"
"特殊化して考えてみましょう。`traversable`が次のような型の関数だとしましょう。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:586
#, fuzzy, no-wrap
msgid "traverse :: forall a b. (a -> V Errors b) -> Array a -> V Errors (Array b)\n"
msgstr "traverse :: forall a b. (a -> V Errors b) -> Array a -> V Errors (Array b)\n"

#. type: Plain text
#: text/chapter7.md:591
#, fuzzy
msgid ""
"This type signature says that if we have a validation function `m` for a "
"type `a`, then `traverse m` is a validation function for arrays of type "
"`Array a`. But that's exactly what we need to be able to validate the "
"`phones` field of the `Person` data structure! We pass `validatePhoneNumber` "
"to `traverse` to create a validation function which validates each element "
"successively."
msgstr ""
"この型シグネチャは、型`a`についての検証関数`f`があれば、`traverse f`は型"
"`Array a`の配列についての検証関数であるということを言っています。これはまさに"
"今必要になっている`Person`データ構造体の`phones`フィールドを検証する検証器そ"
"のものです！それぞれの要素が成功するかどうかを検証する検証関数を作るために、"
"`validatePhoneNumber`を`traverse`へ渡しています。"

#. type: Plain text
#: text/chapter7.md:593
#, fuzzy
msgid ""
"In general, `traverse` walks over the elements of a data structure, "
"performing computations with side-effects and accumulating a result."
msgstr ""
"一般に、`traverse`はデータ構造の要素をひとつづつ辿っていき、副作用のある計算"
"を実行して結果を累積します。"

#. type: Plain text
#: text/chapter7.md:595
#, fuzzy
msgid ""
"The type signature for `Traversable`'s other function `sequence` might look "
"more familiar:"
msgstr ""
"`Traversable`のもう一つの関数、`sequence`の型シグネチャには見覚えがあるかもし"
"れません。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:596
#, fuzzy, no-wrap
msgid "sequence :: forall a m. Applicative m => t (m a) -> m (t a)\n"
msgstr "sequence :: forall a f. (Applicative m) => t (f a) -> f (t a)\n"

#. type: Plain text
#: text/chapter7.md:601
#, fuzzy
msgid ""
"In fact, the `combineList` function that we wrote earlier is just a special "
"case of the `sequence` function from the `Traversable` type class. Setting "
"`t` to be the type constructor `List`, we recover the type of the "
"`combineList` function:"
msgstr ""
"実際、先ほど書いた`combineArray`関数は`Traversable`型の`sequence`関数が特殊化"
"されたものに過ぎません。`t`を配列型構築子として、`combineArray`関数の型をもう"
"一度考えてみましょう。"

#. type: Plain text
#: text/chapter7.md:607
#, fuzzy
msgid ""
"Traversable functors capture the idea of traversing a data structure, "
"collecting a set of effectful computations, and combining their effects. In "
"fact, `sequence` and `traverse` are equally important to the definition of "
"`Traversable` - each can be implemented in terms of each other. This is left "
"as an exercise for the interested reader."
msgstr ""
"`Traversable`関手は、作用のある計算の集合を集めてその作用を連鎖させるという、"
"データ構造走査の考え方を把握できるようにするものです。実際、`sequence`と"
"`traversable`は`Traversable`を定義するのにどちらも同じくらい重要です。これら"
"はお互いが互いを利用して実装することができます。これについては興味ある読者へ"
"の演習として残しておきます。"

#. type: Plain text
#: text/chapter7.md:609
#, fuzzy
msgid ""
"The `Traversable` instance for lists given in the `Data.List` module is:"
msgstr ""
"配列の`Traversable`インスタンスは`Data.Traversable`モジュールで与えられていま"
"す。`traverse`の定義は次のようになっています。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:610
#, fuzzy, no-wrap
msgid ""
"instance traversableList :: Traversable List where\n"
"-- traverse :: forall a b m. Applicative m => (a -> m b) -> List a -> m (List b)\n"
"traverse _ Nil         = pure Nil\n"
"traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs\n"
msgstr ""
"-- traverse :: forall a b f. Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverse _ Nil = pure Nil\n"
"traverse f (Cons x xs) = Cons <$> f x <*> traverse f xs\n"

#. type: Plain text
#: text/chapter7.md:618
msgid ""
"(The actual definition was later modified to improve stack safety. You can "
"read more about that change [here](https://github.com/purescript/purescript-"
"lists/pull/87).)"
msgstr ""

#. type: Plain text
#: text/chapter7.md:620
#, fuzzy
msgid ""
"In the case of an empty list, we can simply return an empty list using "
"`pure`. If the list is non-empty, we can use the function `f` to create a "
"computation of type `f b` from the head element. We can also call `traverse` "
"recursively on the tail. Finally, we can lift the `Cons` constructor over "
"the applicative functor `m` to combine the two results."
msgstr ""
"入力が空の配列のときには、単に`pure`を使って空の配列を返すことができます。配"
"列が空でないときは、関数`f`を使うと先頭の要素から型`f b`の計算を作成すること"
"ができます。また、配列の残りに対して`traverse`を再帰的に呼び出すことができま"
"す。最後に、Applicative関手`f`までcons演算子`(:)`を持ち上げて、２つの結果を組"
"み合わせます。"

#. type: Plain text
#: text/chapter7.md:622
#, fuzzy
msgid ""
"But there are more examples of traversable functors than just arrays and "
"lists. The `Maybe` type constructor we saw earlier also has an instance for "
"`Traversable`. We can try it in PSCi:"
msgstr ""
"Traversable関手の例はただの配列以外にもあります。以前に見た`Maybe`型構築子も"
"`Traversable`のインスタンスを持っています。`PSCi`で試してみましょう。"

#. type: Fenced code block (text)
#: text/chapter7.md:623
#, fuzzy, no-wrap
msgid ""
"> import Data.Maybe\n"
"> import Data.Traversable\n"
"> import Data.AddressBook.Validation\n"
"\n"
"> traverse (nonEmpty \"Example\") Nothing\n"
"pure (Nothing)\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"\")\n"
"invalid ([\"Field 'Example' cannot be empty\"])\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"Testing\")\n"
"pure ((Just \"Testing\"))\n"
msgstr ""
"> import Data.Maybe\n"
"> import Data.Traversable\n"
"\n"
"> traverse (nonEmpty \"Example\") Nothing\n"
"(Valid Nothing)\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"\")\n"
"(Invalid [\"Field 'Example' cannot be empty\"])\n"
"\n"
"> traverse (nonEmpty \"Example\") (Just \"Testing\")\n"
"(Valid (Just unit))\n"

#. type: Plain text
#: text/chapter7.md:639
#, fuzzy
msgid ""
"These examples show that traversing the `Nothing` value returns `Nothing` "
"with no validation, and traversing `Just x` uses the validation function to "
"validate `x`. That is, `traverse` takes a validation function for type `a` "
"and returns a validation function for `Maybe a`, i.e. a validation function "
"for optional values of type `a`."
msgstr ""
"これらの例では、`Nothing`の値の走査は検証なしで`Nothing`の値を返し、`Just x`"
"を走査すると`x`を検証するのにこの検証関数が使われるということを示しています。"
"つまり、`traverse`は型`a`についての検証関数をとり、`Maybe a`についての検証関"
"数を返すのです。"

#. type: Plain text
#: text/chapter7.md:641
#, fuzzy
msgid ""
"Other traversable functors include `Array`, and `Tuple a` and `Either a` for "
"any type `a`. Generally, most \"container\" data type constructors have "
"`Traversable` instances. As an example, the exercises will include writing a "
"`Traversable` instance for a type of binary trees."
msgstr ""
"他にも、何らかの型`a`についての`Tuple a`や`Either a`や、連結リストの型構築子"
"`List`といったTraversable関手があります。一般的に、「コンテナ」のようなデータ"
"の型構築子は大抵`Traversable`インスタンスを持っています。例として、演習では二"
"分木の型の`Traversable`インスタンスを書くようになっています。"

#. type: Bullet: ' 1. '
#: text/chapter7.md:645
#, fuzzy
msgid ""
"(Easy) Write `Eq` and `Show` instances for the following binary tree data "
"structure:"
msgstr ""
"（やや難しい）次のデータ型の `Coarbitrary`インスタンスを書いてください。"

#. type: Plain text
#: text/chapter7.md:649
#, fuzzy, no-wrap
msgid ""
"     ```haskell\n"
"     data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"
"     ```\n"
msgstr ""
"    ```haskell\n"
"    data Tree a = Leaf a | Branch (Tree a) (Tree a)\n"
"    ```\n"

#. type: Plain text
#: text/chapter7.md:651
#, no-wrap
msgid "     Recall from the previous chapter that you may either write these instances manually or let the compiler derive them for you.\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:653
#, no-wrap
msgid "     There are many \"correct\" formatting options for `Show` output. The test for this exercise expects the following whitespace style. This happens to match the default formatting of generic show, so you only need to make note of this if you're planning on writing this instance manually.\n"
msgstr ""

#. type: Plain text
#: text/chapter7.md:657
#, no-wrap
msgid ""
"     ```\n"
"     (Branch (Branch Leaf 8 Leaf) 42 Leaf)\n"
"     ```\n"
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:659
msgid ""
"(Medium) Write a `Traversable` instance for `Tree a`, which combines side-"
"effects from left-to-right. _Hint_: There are some additional instance "
"dependencies that need to be defined for `Traversable`."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:661
msgid ""
"(Medium) Write a function `traversePreOrder :: forall a m b. Applicative m "
"=> (a -> m b) -> Tree a -> m (Tree b)` that performs a pre-order traversal "
"of the tree. This means the order of effect execution is root-left-right, "
"instead of left-root-right as was done for the previous in-order traverse "
"exercise. _Hint_: No additional instances need to be defined, and you don't "
"need to call any of the the functions defined earlier. Applicative do "
"notation (`ado`) is the easiest way to write this function."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:663
msgid ""
"(Medium) Write a function `traversePostOrder` that performs a post-order "
"traversal of the tree where effects are executed left-right-root."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:665
msgid ""
"(Medium) Create a new version of the `Person` type where the `homeAddress` "
"field is optional (using `Maybe`). Then write a new version of "
"`validatePerson` (renamed as `validatePersonOptionalAddress`) to validate "
"this new `Person`. _Hint_: Use `traverse` to validate a field of type `Maybe "
"a`."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:667
msgid ""
"(Difficult) Write a function `sequenceUsingTraverse` which behaves like "
"`sequence`, but is written in terms of `traverse`."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter7.md:669
#, fuzzy
msgid ""
"(Difficult) Write a function `traverseUsingSequence` which behaves like "
"`traverse`, but is written in terms of `sequence`."
msgstr ""
"(難しい)`traverse`を使って`sequence`を書いてみましょう。また、`sequence`を"
"使って`traverse`を書けるでしょうか？"

#. type: Title ##
#: text/chapter7.md:670
#, fuzzy, no-wrap
msgid "Applicative Functors for Parallelism"
msgstr "Applicative関手による並列処理"

#. type: Plain text
#: text/chapter7.md:673
#, fuzzy
msgid ""
"In the discussion above, I chose the word \"combine\" to describe how "
"applicative functors \"combine side-effects\". However, in all the examples "
"given, it would be equally valid to say that applicative functors allow us "
"to \"sequence\" effects. This would be consistent with the intuition that "
"traversable functors provide a `sequence` function to combine effects in "
"sequence based on a data structure."
msgstr ""
"これまでの議論では、Applicative関手がどのように「副作用を結合」させるかを説明"
"するときに、「結合」(combine)という単語を選びました。しかしながら、これらのす"
"べての例において、Applicative関手は作用を「連鎖」(sequence)させる、というよう"
"に言っても同じく妥当です。`Traverse`関手はデータ構造に従って作用を順番に結合"
"させる`sequence`関数を提供する、という直感的理解とこれは一致するでしょう。"

#. type: Plain text
#: text/chapter7.md:675
#, fuzzy
msgid ""
"However, in general, applicative functors are more general than this. The "
"applicative functor laws do not impose any ordering on the side-effects that "
"their computations perform. In fact, it would be valid for an applicative "
"functor to perform its side-effects in parallel."
msgstr ""
"しかし一般には、Applicative関手はこれよりももっと一般的です。Applicative関手"
"の規則は、その計算を実行する副作用にどんな順序付けも強制しません。実際、並列"
"に副作用を実行するためのApplicative関手というものは妥当になりえます。"

#. type: Plain text
#: text/chapter7.md:677
#, fuzzy
msgid ""
"For example, the `V` validation functor returned an _array_ of errors, but "
"it would work just as well if we picked the `Set` semigroup, in which case "
"it would not matter what order we ran the various validators. We could even "
"run them in parallel over the data structure!"
msgstr ""
"たとえば、`V`検証関手はエラーの**配列**を返しますが、その代わりに`Set`半群を"
"選んだとしてもやはり正常に動き、このときどんな順序でそれぞれの検証器を実行し"
"ても問題はありません。データ構造に対して並列にこれを実行することさえできるの"
"です！"

#. type: Plain text
#: text/chapter7.md:679
#, fuzzy
msgid ""
"As a second example, the `parallel` package provides a type class `Parallel` "
"which supports _parallel computations_. `Parallel` provides a function "
"`parallel` which uses some `Applicative` functor to compute the result of "
"its input computation _in parallel_:"
msgstr ""
"別の例とし、`purescript-parallel`パッケージは、並列計算をサポートする"
"`Parallel`型クラスを与えます。**非同期計算**を表現する型構築子`parallel`は、"
"並列に結果を計算する`Applicative`インスタンスを持つことができます。"

#. type: Fenced code block (haskell)
#: text/chapter7.md:680
#, fuzzy, no-wrap
msgid ""
"f <$> parallel computation1\n"
"  <*> parallel computation2\n"
msgstr ""
"f <$> parallel computation1\n"
"  <*> parallel computation2\n"

#. type: Plain text
#: text/chapter7.md:686
#, fuzzy
msgid ""
"This computation would start computing values asynchronously using "
"`computation1` and `computation2`. When both results have been computed, "
"they would be combined into a single result using the function `f`."
msgstr ""
"この計算は、`computation1`と`computation2`を非同期に使って値を計算を始めるで"
"しょう。そして両方の結果の計算が終わった時に、関数`f`を使ってひとつの結果へと"
"結合するでしょう。"

#. type: Plain text
#: text/chapter7.md:688
#, fuzzy
msgid ""
"We will see this idea in more detail when we apply applicative functors to "
"the problem of _callback hell_ later in the book."
msgstr ""
"この考え方の詳細は、本書の後半で**コールバック地獄**の問題に対してApplicative"
"関手を応用するときに見ていきます。"

#. type: Plain text
#: text/chapter7.md:690
#, fuzzy
msgid ""
"Applicative functors are a natural way to capture side-effects which can be "
"combined in parallel."
msgstr "Applicative関手は並列に結合されうる副作用を捕捉する自然な方法です。"

#. type: Plain text
#: text/chapter7.md:694
#, fuzzy
msgid "In this chapter, we covered a lot of new ideas:"
msgstr "この章では新しい考え方をたくさん扱いました。"

#. type: Plain text
#: text/chapter7.md:698
#, fuzzy
msgid ""
"- We introduced the concept of an _applicative functor_ which generalizes "
"the idea of function application to type constructors which capture some "
"notion of side-effect.  - We saw how applicative functors gave a solution to "
"the problem of validating data structures, and how by switching the "
"applicative functor we could change from reporting a single error to "
"reporting all errors across a data structure.  - We met the `Traversable` "
"type class, which encapsulates the idea of a _traversable functor_, or a "
"container whose elements can be used to combine values with side-effects."
msgstr ""
"- 関数適用の概念を副作用の考え方を表現する型構築子へと一般化する、"
"**Applicative関手**の概念を導入しました。 - データ構造の検証という課題に"
"Applicative関手がどのような解決策を与えるか、単一のエラーの報告からデータ構造"
"を横断するすべてのエラーの報告へ変換できるApplicative関手を見てきました。 - "
"要素が副作用を持つ値の結合に使われることのできるコンテナである**Traversable関"
"手**の考え方を表現する、`Traversable`型クラス導入しました。"

#. type: Plain text
#: text/chapter7.md:700
#, fuzzy
msgid ""
"Applicative functors are an interesting abstraction which provide neat "
"solutions to a number of problems. We will see them a few more times "
"throughout the book. In this case, the validation applicative functor "
"provided a way to write validators in a declarative style, allowing us to "
"define _what_ our validators should validate and not _how_ they should "
"perform that validation. In general, we will see that applicative functors "
"are a useful tool for the design of _domain specific languages_."
msgstr ""
"Applicative関手は多くの問題に対して優れた解決策を与える興味深い抽象化です。本"
"書を通じて何度も見ることになるでしょう。今回は、**どうやって**検証を行うかで"
"はなく、**何を**検証器が検証すべきなのかを定義することを可能にする、宣言的な"
"スタイルで書く手段をApplicative関手は提供しました。一般に、Applicative関手は"
"**領域特化言語**の設計のための便利な道具になります。"

#. type: Plain text
#: text/chapter7.md:701
#, fuzzy
msgid ""
"In the next chapter, we will see a related idea, the class of _monads_, and "
"extend our address book example to run in the browser!"
msgstr ""
"次の章では、これに関連する**モナド**という型クラスについて見ていきましょう。"

#. type: Title ##
#: text/chapter8.md:1 text/chapter8.md:393
#, fuzzy, no-wrap
msgid "The Effect Monad"
msgstr "Effモナド"

#. type: Plain text
#: text/chapter8.md:6
#, fuzzy
msgid ""
"In the last chapter, we introduced applicative functors, an abstraction "
"which we used to deal with _side-effects_: optional values, error messages "
"and validation. This chapter will introduce another abstraction for dealing "
"with side-effects in a more expressive way: _monads_."
msgstr ""
"第7章では、オプショナルな型やエラーメッセージ、データの検証など、**副作用**を"
"扱いを抽象化するApplicative関手を導入しました。この章では、より表現力の高い方"
"法で副作用を扱うための別の抽象化、**モナド**を導入します。"

#. type: Plain text
#: text/chapter8.md:8
msgid ""
"The goal of this chapter is to explain why monads are a useful abstraction, "
"and their connection with _do notation_."
msgstr ""

#. type: Plain text
#: text/chapter8.md:12
#, fuzzy
msgid "The project adds the following dependencies:"
msgstr "このプロジェクトでは、以下のBowerの依存関係が追加されています。"

#. type: Plain text
#: text/chapter8.md:15
msgid ""
"- `effect` - defines the `Effect` monad, the subject of the second half of "
"the chapter. This dependency is often listed in every starter project (it's "
"been a dependency of every chapter so far), so you'll rarely have to "
"explicitly install it.  - `react-basic-hooks` - a web framework that we will "
"use for our Address Book app."
msgstr ""

#. type: Title ##
#: text/chapter8.md:16
#, fuzzy, no-wrap
msgid "Monads and Do Notation"
msgstr "モナドとdo記法"

#. type: Plain text
#: text/chapter8.md:19
#, fuzzy
msgid ""
"Do notation was first introduced when we covered _array comprehensions_. "
"Array comprehensions provide syntactic sugar for the `concatMap` function "
"from the `Data.Array` module."
msgstr ""
"do記法は**配列内包表記**を扱うときに最初に導入されました。配列内包表記は "
"`Data.Array`モジュールの `concatMap`関数の構文糖として提供されています。"

#. type: Plain text
#: text/chapter8.md:21
#, fuzzy
msgid ""
"Consider the following example. Suppose we throw two dice and want to count "
"the number of ways in which we can score a total of `n`. We could do this "
"using the following non-deterministic algorithm:"
msgstr ""
"次の例を考えてみましょう。２つのサイコロを振って出た目を数え、出た目の合計が "
"`n`のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使"
"うとこれを実現することができます。"

#. type: Plain text
#: text/chapter8.md:25
#, fuzzy
msgid ""
"- _Choose_ the value `x` of the first throw.  - _Choose_ the value `y` of "
"the second throw.  - If the sum of `x` and `y` is `n` then return the pair "
"`[x, y]`, else fail."
msgstr ""
"- 最初の投擲で値 `x`を**選択**します。 - ２回目の投擲で値 `y`を**選択**しま"
"す。 - もし `x`と `y`の和が `n`なら組 `{x, y}`を返し、そうでなければ失敗しま"
"す。"

#. type: Plain text
#: text/chapter8.md:27
#, fuzzy
msgid ""
"Array comprehensions allow us to write this non-deterministic algorithm in a "
"natural way:"
msgstr ""
"配列内包表記を使うと、この非決定的アルゴリズムを自然に書くことができます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:28
#, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Plus (empty)\n"
"import Data.Array ((..))\n"
"\n"
"{{#include ../exercises/chapter8/test/Examples.purs:countThrows}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:38
#, fuzzy
msgid "We can see that this function works in PSCi:"
msgstr "`PSCi`で動作を見てみましょう。"

#. type: Fenced code block (text)
#: text/chapter8.md:39
#, fuzzy, no-wrap
msgid ""
"> import Test.Examples\n"
"\n"
"> countThrows 10\n"
"[[4,6],[5,5],[6,4]]\n"
"\n"
"> countThrows 12\n"
"[[6,6]]\n"
msgstr ""
"> countThrows 10\n"
"[[4,6],[5,5],[6,4]]\n"
"\n"
"> countThrows 12  \n"
"[[6,6]]\n"

#. type: Plain text
#: text/chapter8.md:50
#, fuzzy
msgid ""
"In the last chapter, we formed an intuition for the `Maybe` applicative "
"functor, embedding PureScript functions into a larger programming language "
"supporting _optional values_. In the same way, we can form an intuition for "
"the _array monad_, embedding PureScript functions into a larger programming "
"language supporting _non-deterministic choice_."
msgstr ""
"前の章では、**オプショナルな値**に対応したより大きなプログラミング言語へと"
"PureScriptの関数を埋め込む、 `Maybe` Applicative関手についての直感的理解を養"
"いました。同様に**配列モナド**についても、**非決定選択**に対応したより大きな"
"プログラミング言語へPureScriptの関数を埋め込む、というような直感的理解を得る"
"ことができます。"

#. type: Plain text
#: text/chapter8.md:52
#, fuzzy
msgid ""
"In general, a _monad_ for some type constructor `m` provides a way to use do "
"notation with values of type `m a`. Note that in the array comprehension "
"above, every line contains a computation of type `Array a` for some type "
"`a`. In general, every line of a do notation block will contain a "
"computation of type `m a` for some type `a` and our monad `m`. The monad `m` "
"must be the same on every line (i.e. we fix the side-effect), but the types "
"`a` can differ (i.e. individual computations can have different result "
"types)."
msgstr ""
"一般に、ある型構築子 `m`のモナドは、型 `m a`の値を持つdo記法を使う方法を提供"
"します。上の配列内包表記では、すべての行に何らかの型 `a`についての型 `Array "
"a`の計算が含まれていることに注目してください。一般に、do記法ブロックのすべて"
"の行は、何らかの型 `a`とモナド `m`について、型 `m a`の計算を含んでいます。モ"
"ナド `m`はすべての行で同じでなければなりません(つまり、副作用の種類は固定され"
"ます)が、型 `a`は異なることもあります(言い換えると、ここの計算は異なる型の結"
"果を持つことができます)。"

#. type: Plain text
#: text/chapter8.md:54
#, fuzzy
msgid ""
"Here is another example of do notation, this type applied to the type "
"constructor `Maybe`. Suppose we have some type `XML` representing XML nodes, "
"and a function"
msgstr ""
"型構築子 `Maybe`が適用された、do記法の別の例を見てみましょう。XMLノードを表す"
"型 `XML`と演算子があるとします。"

#. type: Fenced code block (hs)
#: text/chapter8.md:55
#, fuzzy, no-wrap
msgid "child :: XML -> String -> Maybe XML\n"
msgstr "child :: XML -> String -> Maybe XML\n"

#. type: Plain text
#: text/chapter8.md:60
#, fuzzy
msgid ""
"which looks for a child element of a node, and returns `Nothing` if no such "
"element exists."
msgstr ""
"この演算子はノードの子の要素を探し、もしそのような要素が存在しなければ "
"`Nothing`を返します。"

#. type: Plain text
#: text/chapter8.md:62
#, fuzzy
msgid ""
"In this case, we can look for a deeply-nested element by using do notation. "
"Suppose we wanted to read a user's city from a user profile which had been "
"encoded as an XML document:"
msgstr ""
"この場合、do記法を使うと深い入れ子になった要素を検索することができます。XML文"
"書として符号化された利用者情報から、利用者の住んでいる市町村を読み取りたいと"
"します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:63 text/chapter8.md:293
#, fuzzy, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root = do\n"
"  prof <- child root \"profile\"\n"
"  addr <- child prof \"address\"\n"
"  city <- child addr \"city\"\n"
"  pure city\n"
msgstr ""
"userCity :: XML -> Maybe XML\n"
"userCity root = do\n"
"  prof <- child root \"profile\"\n"
"  addr <- child prof \"address\"\n"
"  city <- child addr \"city\"\n"
"  pure city\n"

#. type: Plain text
#: text/chapter8.md:73
#, fuzzy
msgid ""
"The `userCity` function looks for a child element `profile`, an element "
"`address` inside the `profile` element, and finally an element `city` inside "
"the `address` element. If any of these elements are missing, the return "
"value will be `Nothing`. Otherwise, the return value is constructed using "
"`Just` from the `city` node."
msgstr ""
"`userCity`関数は子の要素である `profile`を探し、 `profile`要素の中にある "
"`address`要素、最後に `address`要素から `city`要素を探します。これらの要素の"
"いずれかが欠落している場合は、返り値は `Nothing`になります。そうでなければ、"
"返り値は `city`ノードから `Just`を使って構築されています。"

#. type: Plain text
#: text/chapter8.md:75
#, fuzzy
msgid ""
"Remember, the `pure` function in the last line is defined for every "
"`Applicative` functor. Since `pure` is defined as `Just` for the `Maybe` "
"applicative functor, it would be equally valid to change the last line to "
"`Just city`."
msgstr ""
"最後の行にある`pure`関数は、すべての`Applicative`関手について定義されているの"
"でした。`Maybe`の`Applicative`関手の`pure`関数は`Just`として定義されており、"
"最後の行を `Just city`へ変更しても同じように正しく動きます。"

#. type: Title ##
#: text/chapter8.md:76
#, fuzzy, no-wrap
msgid "The Monad Type Class"
msgstr "モナド型クラス"

#. type: Plain text
#: text/chapter8.md:79
#, fuzzy
msgid "The `Monad` type class is defined as follows:"
msgstr "`Monad`型クラスは次のように定義されています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:80
#, fuzzy, no-wrap
msgid ""
"class Apply m <= Bind m where\n"
"  bind :: forall a b. m a -> (a -> m b) -> m b\n"
"\n"
"class (Applicative m, Bind m) <= Monad m\n"
msgstr ""
"class Apply m <= Bind m where\n"
"  bind :: forall a b. m a -> (a -> m b) -> m b\n"
"class (Applicative m, Bind m) <= Monad m\n"

#. type: Plain text
#: text/chapter8.md:88
#, fuzzy, no-wrap
msgid "The key function here is `bind`, defined in the `Bind` type class. Just like for the `<$>` and `<*>` operators in the `Functor` and `Apply` type classes, the Prelude defines an infix alias `>>=` for the `bind` function.\n"
msgstr "ここで鍵となる関数は `Bind`型クラスで定義されている演算子 `bind`で、 `Functor`及び `Apply`型クラスにある `<$>`や `<*>`などの演算子と同じ様に `Prelude`では `>>=`として `bind`の別名が定義されています。\n"

#. type: Plain text
#: text/chapter8.md:90
#, fuzzy
msgid ""
"The `Monad` type class extends `Bind` with the operations of the "
"`Applicative` type class that we have already seen."
msgstr ""
"`Monad`型クラスは、すでに見てきた `Applicative`型クラスの操作で `Bind`を拡張"
"します。"

#. type: Plain text
#: text/chapter8.md:92
#, fuzzy
msgid ""
"It will be useful to see some examples of the `Bind` type class. A sensible "
"definition for `Bind` on arrays can be given as follows:"
msgstr ""
"`Bind`型クラスの例をいくつか見てみるのがわかりやすいでしょう。配列についての "
"`Bind`の妥当な定義は次のようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:93
#, fuzzy, no-wrap
msgid ""
"instance bindArray :: Bind Array where\n"
"  bind xs f = concatMap f xs\n"
msgstr ""
"instance bindArray :: Bind Array where\n"
"  bind xs f = concatMap f xs\n"

#. type: Plain text
#: text/chapter8.md:99
#, fuzzy
msgid ""
"This explains the connection between array comprehensions and the "
"`concatMap` function that has been alluded to before."
msgstr ""
"これは以前にほのめかした配列内包表記と `concatMap`関数の関係を説明していま"
"す。"

#. type: Plain text
#: text/chapter8.md:101
#, fuzzy
msgid "Here is an implementation of `Bind` for the `Maybe` type constructor:"
msgstr "`Maybe`型構築子についての `Bind`の実装は次のようになります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:102
#, fuzzy, no-wrap
msgid ""
"instance bindMaybe :: Bind Maybe where\n"
"  bind Nothing  _ = Nothing\n"
"  bind (Just a) f = f a\n"
msgstr ""
"instance bindMaybe :: Bind Maybe where\n"
"  bind Nothing  _ = Nothing\n"
"  bind (Just a) f = f a\n"

#. type: Plain text
#: text/chapter8.md:109
#, fuzzy
msgid ""
"This definition confirms the intuition that missing values are propagated "
"through a do notation block."
msgstr ""
"この定義はdo記法ブロックを通じて伝播された欠落した値についての直感的理解を補"
"強するものです。"

#. type: Plain text
#: text/chapter8.md:111
#, fuzzy
msgid ""
"Let's see how the `Bind` type class is related to do notation. Consider a "
"simple do notation block which starts by binding a value from the result of "
"some computation:"
msgstr ""
"`Bind`型クラスとdo記法がどのように関係しているかを見て行きましょう。最初に何"
"らかの計算結果から値を束縛するような、簡単などdo記法ブロックについて考えてみ"
"ましょう。"

#. type: Fenced code block (hs)
#: text/chapter8.md:112
#, fuzzy, no-wrap
msgid ""
"do value <- someComputation\n"
"   whatToDoNext\n"
msgstr ""
"do value <- someComputation\n"
"   whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:118
#, fuzzy
msgid ""
"Every time the PureScript compiler sees this pattern, it replaces the code "
"with this:"
msgstr ""
"PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置"
"き換えます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:119
#, fuzzy, no-wrap
msgid "bind someComputation \\value -> whatToDoNext\n"
msgstr "bind someComputation \\value -> whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:124
#, fuzzy
msgid "or, written infix:"
msgstr "下記のように表記することもできます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:125
#, fuzzy, no-wrap
msgid "someComputation >>= \\value -> whatToDoNext\n"
msgstr "someComputation >>= \\value -> whatToDoNext\n"

#. type: Plain text
#: text/chapter8.md:130
#, fuzzy
msgid "The computation `whatToDoNext` is allowed to depend on `value`."
msgstr "この計算 `whatToDoNext`は `value`に依存することができます。"

#. type: Plain text
#: text/chapter8.md:132
#, fuzzy
msgid ""
"If there are multiple binds involved, this rule is applied multiple times, "
"starting from the top. For example, the `userCity` example that we saw "
"earlier gets desugared as follows:"
msgstr ""
"連続した複数の束縛がある場合でも、この規則が先頭のほうから複数回適用されま"
"す。例えば、先ほど見た `userCity`の例では次のように構文糖が脱糖されます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:133
#, fuzzy, no-wrap
msgid ""
"userCity :: XML -> Maybe XML\n"
"userCity root =\n"
"  child root \"profile\" >>= \\prof ->\n"
"    child prof \"address\" >>= \\addr ->\n"
"      child addr \"city\" >>= \\city ->\n"
"        pure city\n"
msgstr ""
"userCity :: XML -> Maybe XML\n"
"userCity root =\n"
"  child root \"profile\" >>= \\prof ->\n"
"    child prof \"address\" >>= \\addr ->\n"
"      child addr \"city\" >>= \\city ->\n"
"        pure city\n"

#. type: Plain text
#: text/chapter8.md:143
#, fuzzy, no-wrap
msgid "It is worth noting that code expressed using do notation is often much clearer than the equivalent code using the `>>=` operator. However, writing binds explicitly using `>>=` can often lead to opportunities to write code in _point-free_ form - but the usual warnings about readability apply.\n"
msgstr "do記法を使って表現されたコードは、 `>>=`演算子を使って書かれた同じ意味のコードよりしばしば読みやすくなることも特筆すべき点です。一方で、明示的に `>>=`を使って束縛が書くと、**point-free**形式でコードを書く機会を増やすことになります。ただし、通常は読みやすさを優先すべきでしょう。\n"

#. type: Title ##
#: text/chapter8.md:144
#, fuzzy, no-wrap
msgid "Monad Laws"
msgstr "モナド則"

#. type: Plain text
#: text/chapter8.md:147
#, fuzzy
msgid ""
"The `Monad` type class comes equipped with three laws, called the _monad "
"laws_. These tell us what we can expect from sensible implementations of the "
"`Monad` type class."
msgstr ""
"`Monad`型クラスは**モナド則**(monad laws)と呼ばれる3つの規則を持っています。"
"これらは `Monad`型クラスの理にかなった実装から何を期待できるかを教えてくれま"
"す。"

#. type: Plain text
#: text/chapter8.md:149
#, fuzzy
msgid "It is simplest to explain these laws using do notation."
msgstr "do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。"

#. type: Title ###
#: text/chapter8.md:150
#, fuzzy, no-wrap
msgid "Identity Laws"
msgstr "Identity律"

#. type: Plain text
#: text/chapter8.md:153
#, fuzzy
msgid ""
"The _right-identity_ law is the simplest of the three laws. It tells us that "
"we can eliminate a call to `pure` if it is the last expression in a do "
"notation block:"
msgstr ""
"**右単位元則**(right-identity law)が３つの規則の中で最も簡単です。この規則は"
"do記法ブロックの最後の式であれば、 `pure`の呼び出しを排除することができると"
"言っています。\n"

#. type: Fenced code block (hs)
#: text/chapter8.md:154
#, fuzzy, no-wrap
msgid ""
"do\n"
"  x <- expr\n"
"  pure x\n"
msgstr ""
"do\n"
"  x <- expr\n"
"  pure x\n"

#. type: Plain text
#: text/chapter8.md:161
#, fuzzy
msgid "The right-identity law says that this is equivalent to just `expr`."
msgstr "右単位元則は、この式は単なる `expr`と同じだと言っています。"

#. type: Plain text
#: text/chapter8.md:163
#, fuzzy
msgid ""
"The _left-identity_ law states that we can eliminate a call to `pure` if it "
"is the first expression in a do notation block:"
msgstr ""
"**左単位元則**(left-identity law)は、もしそれがdo記法ブロックの最初の式であれ"
"ば、 `pure`の呼び出しを除去することができると述べています。\n"

#. type: Fenced code block (hs)
#: text/chapter8.md:164
#, fuzzy, no-wrap
msgid ""
"do\n"
"  x <- pure y\n"
"  next\n"
msgstr ""
"do\n"
"  x <- pure y\n"
"  next\n"

#. type: Plain text
#: text/chapter8.md:171
#, fuzzy
msgid ""
"This code is equivalent to `next`, after the name `x` has been replaced with "
"the expression `y`."
msgstr "このコードの名前 `x`を式 `y`で置き換えたものと `next`は同じです。"

#. type: Plain text
#: text/chapter8.md:173
#, fuzzy
msgid ""
"The last law is the _associativity law_. It tells us how to deal with nested "
"do notation blocks. It states that the following piece of code:"
msgstr ""
"最後の規則は**結合則**(associativity law)です。これは入れ子になったdo記法ブ"
"ロックをどう扱うのかについて教えてくれます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:174
#, fuzzy, no-wrap
msgid ""
"c1 = do\n"
"  y <- do\n"
"    x <- m1\n"
"    m2\n"
"  m3\n"
msgstr ""
"c1 = do\n"
"  y <- do\n"
"    x <- m1\n"
"    m2\n"
"  m3\n"

#. type: Plain text
#: text/chapter8.md:183
#, fuzzy
msgid "is equivalent to this code:"
msgstr "上記のコード片は、次のコードと同じです。"

#. type: Fenced code block (hs)
#: text/chapter8.md:184
#, fuzzy, no-wrap
msgid ""
"c2 = do\n"
"  x <- m1\n"
"  y <- m2\n"
"  m3\n"
msgstr ""
"c2 = do\n"
"  x <- m1\n"
"  y <- m2\n"
"  m3\n"

#. type: Plain text
#: text/chapter8.md:192
#, fuzzy
msgid ""
"Each of these computations involves three monadic expression `m1`, `m2` and "
"`m3`. In each case, the result of `m1` is eventually bound to the name `x`, "
"and the result of `m2` is bound to the name `y`."
msgstr ""
"これら計算にはそれぞれ、3つのモナドの式 `m1`、 `m2`、 `m3`が含まれています。"
"どちらの場合でも `m1`の結果は名前 `x`に束縛され、 `m2`の結果は名前 `y`に束縛"
"されます。"

#. type: Plain text
#: text/chapter8.md:194
#, fuzzy
msgid ""
"In `c1`, the two expressions `m1` and `m2` are grouped into their own do "
"notation block."
msgstr ""
"`c1`では２つの式 `m1`と `m2`がそれぞれのdo記法ブロック内にグループ化されてい"
"ます。"

#. type: Plain text
#: text/chapter8.md:196
#, fuzzy
msgid ""
"In `c2`, all three expressions `m1`, `m2` and `m3` appear in the same do "
"notation block."
msgstr ""
"`c2`では `m1`、 `m2`、 `m3`の３つすべての式が同じdo記法ブロックに現れていま"
"す。"

#. type: Plain text
#: text/chapter8.md:198
#, fuzzy
msgid ""
"The associativity law tells us that it is safe to simplify nested do "
"notation blocks in this way."
msgstr ""
"結合規則は　入れ子になったdo記法ブロックをこのように単純化しても安全であると"
"いうことを言っています。"

#. type: Plain text
#: text/chapter8.md:200
#, fuzzy
msgid ""
"_Note_ that by the definition of how do notation gets desugared into calls "
"to `bind`, both of `c1` and `c2` are also equivalent to this code:"
msgstr ""
"**注意**: do記法がどのように `bind`の呼び出しへと脱糖されるかの定義により、 "
"`c1`と `c2`はいずれも次のコードと同じです。 `\n"

#. type: Fenced code block (hs)
#: text/chapter8.md:201
#, fuzzy, no-wrap
msgid ""
"c3 = do\n"
"  x <- m1\n"
"  do\n"
"    y <- m2\n"
"    m3\n"
msgstr ""
"c3 = do\n"
"  x <- m1\n"
"  do\n"
"    y <- m2\n"
"    m3\n"

#. type: Title ##
#: text/chapter8.md:209
#, fuzzy, no-wrap
msgid "Folding With Monads"
msgstr "モナドと畳み込み"

#. type: Plain text
#: text/chapter8.md:212
#, fuzzy
msgid ""
"As an example of working with monads abstractly, this section will present a "
"function which works with any type constructor in the `Monad` type class. "
"This should serve to solidify the intuition that monadic code corresponds to "
"programming \"in a larger language\" with side-effects, and also illustrate "
"the generality which programming with monads brings."
msgstr ""
"抽象的にモナドを扱う例として、この節では `Monad`型クラスの何らかの型構築子と"
"一緒に機能するある関数を示していきます。これはモナドによるコードが副作用を伴"
"う「より大きな言語」でのプログラミングと対応しているという直感的理解を補強し"
"ますし、モナドによるプログラミングがもたらす一般性も示しています。"

#. type: Plain text
#: text/chapter8.md:214
#, fuzzy
msgid ""
"The function we will write is called `foldM`. It generalizes the `foldl` "
"function that we met earlier to a monadic context. Here is its type "
"signature:"
msgstr ""
"これから `foldM`と呼ばれる関数を書いてみます。これは以前扱った `foldl`関数を"
"モナドの文脈へと一般化します。型シグネチャは次のようになっています。"

#. type: Fenced code block (hs)
#: text/chapter8.md:215
#, fuzzy, no-wrap
msgid ""
"foldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> List b -> m a\n"
"foldl :: forall   a b.            (a -> b ->   a) -> a -> List b ->   a\n"
msgstr ""
"foldM :: forall m a b\n"
"       . Monad m\n"
"      => (a -> b -> m a)\n"
"      -> a\n"
"      -> List b\n"
"      -> m a\n"

#. type: Plain text
#: text/chapter8.md:221
#, fuzzy
msgid ""
"Notice that this is the same as the type of `foldl`, except for the "
"appearance of the monad `m`."
msgstr ""
"モナド `m`が現れている点を除いて、 `foldl`の型と同じであることに注意しましょ"
"う。"

#. type: Plain text
#: text/chapter8.md:223
#, fuzzy
msgid ""
"Intuitively, `foldM` performs a fold over a list in some context supporting "
"some set of side-effects."
msgstr ""
"直感的には、 `foldM`はさまざまな副作用の組み合わせに対応した文脈での配列の畳"
"み込みを行うと捉えることができます。"

#. type: Plain text
#: text/chapter8.md:225
#, fuzzy
msgid ""
"For example, if we picked `m` to be `Maybe`, then our fold would be allowed "
"to fail by returning `Nothing` at any stage - every step returns an optional "
"result, and the result of the fold is therefore also optional."
msgstr ""
"例として `m`が `Maybe`であるとすると、この畳み込みはそれぞれの段階で "
"`Nothing`を返すことで失敗することができます。それぞれの段階ではオプショナルな"
"結果を返しますから、それゆえ畳み込みの結果もオプショナルになります。"

#. type: Plain text
#: text/chapter8.md:227
#, fuzzy
msgid ""
"If we picked `m` to be the `Array` type constructor, then every step of the "
"fold would be allowed to return zero or more results, and the fold would "
"proceed to the next step independently for each result. At the end, the set "
"of results would consist of all folds over all possible paths. This "
"corresponds to a traversal of a graph!"
msgstr ""
"もし `m`として配列の型構築子 `Array`を選ぶとすると、畳み込みのそれぞれの段階"
"で複数の結果を返すことができ、畳み込みは結果それぞれに対して次の手順を継続し"
"ます。最後に、結果の集まりは、可能な経路すべての畳み込みから構成されることに"
"なります。これはグラフの走査と対応しています！"

#. type: Plain text
#: text/chapter8.md:229
#, fuzzy
msgid "To write `foldM`, we can simply break the input list into cases."
msgstr "`foldM`を書くには、単に入力の配列について場合分けをするだけです。"

#. type: Plain text
#: text/chapter8.md:231
#, fuzzy
msgid ""
"If the list is empty, then to produce the result of type `a`, we only have "
"one option: we have to return the second argument:"
msgstr ""
"配列が空なら、型 `a`の結果を生成するための選択肢はひとつしかありません。第２"
"引数を返します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:232
#, fuzzy, no-wrap
msgid "foldM _ a Nil = pure a\n"
msgstr "foldM _ a Nil = pure a\n"

#. type: Plain text
#: text/chapter8.md:237
#, fuzzy
msgid "Note that we have to use `pure` to lift `a` into the monad `m`."
msgstr ""
"`a`をモナド `m`まで持ち上げるために `pure`を使わなくてはいけないことも忘れな"
"いようにしてください。"

#. type: Plain text
#: text/chapter8.md:239
#, fuzzy, no-wrap
msgid "What if the list is non-empty? In that case, we have a value of type `a`, a value of type `b`, and a function of type `a -> b -> m a`. If we apply the function, we obtain a monadic result of type `m a`. We can bind the result of this computation with a backwards arrow `<-`.\n"
msgstr "配列が空でない場合はどうでしょうか？その場合、型 `a`の値、型 `b`の値、型 `a -> b -> m a`の関数があります。もしこの関数を適用すると、型 `m a`のモナドの結果を手に入れることになります。この計算の結果を逆向きの矢印 `<-`で束縛することができます。\n"

#. type: Plain text
#: text/chapter8.md:241
#, fuzzy
msgid ""
"It only remains to recurse on the tail of the list. The implementation is "
"simple:"
msgstr "あとは配列の残りに対して再帰するだけです。実装は簡単です。"

#. type: Fenced code block (hs)
#: text/chapter8.md:242
#, fuzzy, no-wrap
msgid ""
"foldM f a (b : bs) = do\n"
"  a' <- f a b\n"
"  foldM f a' bs\n"
msgstr ""
"foldM f a (b : bs) = do\n"
"  a' <- f a b\n"
"  foldM f a' bs\n"

#. type: Plain text
#: text/chapter8.md:249
#, fuzzy
msgid ""
"Note that this implementation is almost identical to that of `foldl` on "
"lists, with the exception of do notation."
msgstr ""
"do記法を除けば、この実装は配列に対する `foldl`の実装とほとんど同じであること"
"にも注意してください。"

#. type: Plain text
#: text/chapter8.md:251
#, fuzzy
msgid ""
"We can define and test this function in PSCi. Here is an example - suppose "
"we defined a \"safe division\" function on integers, which tested for "
"division by zero and used the `Maybe` type constructor to indicate failure:"
msgstr ""
"`PSCi`でこれを定義し、試してみましょう。除算可能かどうかを調べて、失敗を示す"
"ために `Maybe`型構築子を使う、整数の「安全な除算」関数を定義するとしましょ"
"う。"

#. type: Fenced code block (hs)
#: text/chapter8.md:252
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Examples.purs:safeDivide}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:257
#, fuzzy
msgid "Then we can use `foldM` to express iterated safe division:"
msgstr "これで、 `foldM`で安全な除算の繰り返しを表現することができます。"

#. type: Fenced code block (text)
#: text/chapter8.md:258
#, fuzzy, no-wrap
msgid ""
"> import Test.Examples\n"
"> import Data.List (fromFoldable)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [5, 2, 2])\n"
"(Just 5)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [2, 0, 4])\n"
"Nothing\n"
msgstr ""
"> import Data.List\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [5, 2, 2])\n"
"(Just 5)\n"
"\n"
"> foldM safeDivide 100 (fromFoldable [2, 0, 4])\n"
"Nothing\n"

#. type: Plain text
#: text/chapter8.md:270
#, fuzzy
msgid ""
"The `foldM safeDivide` function returns `Nothing` if a division by zero was "
"attempted at any point. Otherwise it returns the result of repeatedly "
"dividing the accumulator, wrapped in the `Just` constructor."
msgstr ""
"もしいずれかの時点で整数にならない除算が行われようとしたら、 `foldM "
"safeDivide`関数は `Nothing`を返します。そうでなければ、 `Just`構築子に包まれ"
"た除算の繰り返した累積の結果を返します。"

#. type: Title ##
#: text/chapter8.md:271
#, fuzzy, no-wrap
msgid "Monads and Applicatives"
msgstr "モナドとApplicative"

#. type: Plain text
#: text/chapter8.md:274
#, fuzzy
msgid ""
"Every instance of the `Monad` type class is also an instance of the `Apply` "
"type class, by virtue of the superclass relationship between the two classes."
msgstr ""
"クラス間に上位クラス関係があるため、 `Monad`型クラスのすべてのインスタンスは "
"`Applicative`型クラスのインスタンスでもあります。"

#. type: Plain text
#: text/chapter8.md:276
#, fuzzy
msgid ""
"However, there is also an implementation of the `Apply` type class which "
"comes \"for free\" for any instance of `Monad`, given by the `ap` function:"
msgstr ""
"しかしながら、どんな `Monad`のインスタンスについても `Applicative`型クラスの"
"実装が、それ以上の条件なしで存在し、次のような `ap`が与えられます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:277
#, fuzzy, no-wrap
msgid ""
"ap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\n"
"ap mf ma = do\n"
"  f <- mf\n"
"  a <- ma\n"
"  pure (f a)\n"
msgstr ""
"ap :: forall m a b. Monad m => m (a -> b) -> m a -> m b\n"
"ap mf ma = do\n"
"  f <- mf\n"
"  a <- ma\n"
"  pure (f a)\n"

#. type: Plain text
#: text/chapter8.md:286
#, fuzzy
msgid ""
"If `m` is a law-abiding member of the `Monad` type class, then there is a "
"valid `Apply` instance for `m` given by `ap`."
msgstr ""
"もし `m`が `Monad`型クラスの規則に従っているなら、 `m`が `ap`で与えられるよう"
"な、妥当な `Applicative`インスタンスが存在します。　　　　"

#. type: Plain text
#: text/chapter8.md:288
#, fuzzy
msgid ""
"The interested reader can check that `ap` agrees with `apply` for the monads "
"we have already encountered: `Array`, `Maybe` and `Either e`."
msgstr ""
"興味のある読者は、これまで登場した `Array`、 `Maybe`、 `Either e`といったモナ"
"ドについて、この `ap`が `apply`と一致することを確かめてみてください。"

#. type: Plain text
#: text/chapter8.md:290
#, fuzzy
msgid ""
"If every monad is also an applicative functor, then we should be able to "
"apply our intuition for applicative functors to every monad. In particular, "
"we can reasonably expect a monad to correspond, in some sense, to "
"programming \"in a larger language\" augmented with some set of additional "
"side-effects. We should be able to lift functions of arbitrary arities, "
"using `map` and `apply`, into this new language."
msgstr ""
"もしすべてのモナドがApplicative関手でもあるなら、Applicative関手についての直"
"感的理解をすべてのモナドについても適用することができるはずです。特に、更なる"
"副作用の組み合わせで増強された「より大きな言語」でのプログラミングとモナドが"
"いろいろな意味で一致することを当然に期待することができます。 `map`と `apply`"
"を使って、引数が任意個の関数をこの新しい言語へと持ち上げることができるはずで"
"す。"

#. type: Plain text
#: text/chapter8.md:292
#, fuzzy
msgid ""
"But monads allow us to do more than we could do with just applicative "
"functors, and the key difference is highlighted by the syntax of do "
"notation. Consider the `userCity` example again, in which we looked for a "
"user's city in an XML document which encoded their user profile:"
msgstr ""
"しかし、モナドはApplicative関手で可能な以上のことを行うことができ、重要な違い"
"はdo記法の構文で強調されています。利用者情報を符号化したXML文書から利用者の都"
"市を検索する、 `userCity`の例についてもう一度考えてみましょう。"

#. type: Plain text
#: text/chapter8.md:303
#, fuzzy
msgid ""
"Do notation allows the second computation to depend on the result `prof` of "
"the first, and the third computation to depend on the result `addr` of the "
"second, and so on. This dependence on previous values is not possible using "
"only the interface of the `Applicative` type class."
msgstr ""
"２番目の計算が最初の結果 `prof`に依存し、３番目の計算が２番目の計算の結果 "
"`addr`に依存するというようなことをdo記法は可能にします。 `Applicative`型クラ"
"スのインターフェイスだけを使うのでは、このような以前の値への依存は不可能で"
"す。"

#. type: Plain text
#: text/chapter8.md:305
#, fuzzy
msgid ""
"Try writing `userCity` using only `pure` and `apply`: you will see that it "
"is impossible. Applicative functors only allow us to lift function arguments "
"which are independent of each other, but monads allow us to write "
"computations which involve more interesting data dependencies."
msgstr ""
"`pure`と `apply`だけを使って `userCity`を書こうとしてみれば、これが不可能であ"
"ることがわかるでしょう。Applicativeは関数の互いに独立した引数を持ち上げること"
"だけを可能にしますが、モナドはもっと興味深いデータ依存関係に関わる計算を書く"
"ことを可能にします。"

#. type: Plain text
#: text/chapter8.md:307
#, fuzzy
msgid ""
"In the last chapter, we saw that the `Applicative` type class can be used to "
"express parallelism. This was precisely because the function arguments being "
"lifted were independent of one another. Since the `Monad` type class allows "
"computations to depend on the results of previous computations, the same "
"does not apply - a monad has to combine its side-effects in sequence."
msgstr ""
"前の章では `Applicative`型クラスは並列処理を表現できることを見ました。持ち上"
"げられた関数の引数は互いに独立していますから、これはまさにその通りです。 "
"`Monad`型クラスは計算が前の計算の結果に依存できるようにしますから、同じように"
"はなりません。モナドはその副作用を順番に組み合わせしなければいけません。"

#. type: Bullet: ' 1. '
#: text/chapter8.md:312
msgid ""
"(Easy) Write a function `third` which returns the third element of an array "
"with three or more elements. Your function should return an appropriate "
"`Maybe` type. _Hint:_ Look up the types of the `head` and `tail` functions "
"from the `Data.Array` module in the `arrays` package. Use do notation with "
"the `Maybe` monad to combine these functions."
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter8.md:312
#, fuzzy
msgid ""
"(Medium) Write a function `possibleSums` which uses `foldM` to determine all "
"possible totals that could be made using a set of coins. The coins will be "
"specified as an array which contains the value of each coin. Your function "
"should have the following result:"
msgstr ""
"（やや難しい） 与えられた幾つかの硬貨を組み合わせてできる可能性のあるすべての"
"合計を決定する関数 `sum`を、 `foldM`を使って書いてみましょう。入力の硬貨は、"
"硬貨の価値の配列として与えられます。この関数は次のような結果にならなくてはい"
"けません。"

#. type: Plain text
#: text/chapter8.md:316
#, fuzzy, no-wrap
msgid ""
"     ```text\n"
"     > possibleSums []\n"
"     [0]\n"
msgstr ""
"    ```text\n"
"    > testParens \"\"\n"
"    true\n"

#. type: Plain text
#: text/chapter8.md:320
#, fuzzy, no-wrap
msgid ""
"     > possibleSums [1, 2, 10]\n"
"     [0,1,2,3,10,11,12,13]\n"
"     ```\n"
msgstr ""
"   > sums []\n"
"   [0]\n"
"\n"
"   > sums [1, 2, 10]\n"
"   [0,1,2,3,10,11,12,13]\n"

#. type: Plain text
#: text/chapter8.md:325
#, fuzzy, no-wrap
msgid ""
"     _Hint_: This function can be written as a one-liner using `foldM`. You might want to use the `nub` and `sort` functions to remove duplicates and sort the result respectively.\n"
" 1. (Medium) Confirm that the `ap` function and the `apply` operator agree for the `Maybe` monad. _Note:_ There are no tests for this exercise.\n"
" 1. (Medium) Verify that the monad laws hold for the `Monad` instance for the `Maybe` type, as defined in the `maybe` package. _Note:_ There are no tests for this exercise.\n"
" 1. (Medium) Write a function `filterM` which generalizes the `filter` function on lists. Your function should have the following type signature:\n"
msgstr ""
"   **ヒント**：`foldM`を使うと１行でこの関数を書くことが可能です。重複する要素を取り除いたり、結果を昇順に並び替えたりするのに、 `nub`関数や `sort`関数を使いたくなるかもしれません。\n"
"1. （やや難しい） `Maybe`型構築子について、 `ap`関数と `apply`演算子が一致することを確認してください。\n"
"1. （やや難しい） `purescript-maybe`パッケージで定義されている `Maybe`型についての `Monad`インスタンスが、モナド則を満たしていることを検証してください。\n"
"1. （やや難しい） 配列上の `filter`の関数を一般化した関数 `filterM`を書いてください。この関数は次の型シグネチャを持つ必要があります。\n"

#. type: Plain text
#: text/chapter8.md:329
#, fuzzy, no-wrap
msgid ""
"     ```hs\n"
"     filterM :: forall m a. Monad m => (a -> m Boolean) -> List a -> m (List a)\n"
"     ```\n"
msgstr "   filterM :: forall m a. Monad m => (a -> m Boolean) -> List a -> m (List a)\n"

#. type: Bullet: ' 1. '
#: text/chapter8.md:331
#, fuzzy
msgid "(Difficult) Every monad has a default `Functor` instance given by:"
msgstr ""
"   `PSCi`で `Maybe`と `Array`モナドを使ってその関数を試してみてください。\n"
"1. （難しい） すべてのモナドは、次で与えられるような既定の `Functor`インスタ"
"ンスがあります。\n"

#. type: Plain text
#: text/chapter8.md:337
#, fuzzy, no-wrap
msgid ""
"     ```hs\n"
"     map f a = do\n"
"       x <- a\n"
"       pure (f x)\n"
"     ```\n"
msgstr ""
"   map f a = do\n"
"     x <- a\n"
"     pure (f x)\n"

#. type: Plain text
#: text/chapter8.md:339
#, fuzzy, no-wrap
msgid "     Use the monad laws to prove that for any monad, the following holds:\n"
msgstr "   モナド則を使って、すべてのモナドが次を満たすことを証明してください。\n"

#. type: Plain text
#: text/chapter8.md:343
#, fuzzy, no-wrap
msgid ""
"     ```hs\n"
"     lift2 f (pure a) (pure b) = pure (f a b)\n"
"     ```\n"
msgstr "   lift2 f (pure a) (pure b) = pure (f a b)\n"

#. type: Plain text
#: text/chapter8.md:345
#, fuzzy, no-wrap
msgid "     where the `Apply` instance uses the `ap` function defined above. Recall that `lift2` was defined as follows:\n"
msgstr "   ここで、 `Applicative`インスタンスは上で定義された `ap`関数を使用しています。 `lift2`が次のように定義されていたことを思い出してください。\n"

#. type: Plain text
#: text/chapter8.md:350
#, fuzzy, no-wrap
msgid ""
"     ```hs\n"
"     lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c\n"
"     lift2 f a b = f <$> a <*> b\n"
"     ```\n"
msgstr ""
"   lift2 :: forall f a b c. Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"   lift2 f a b = f <$> a <*> b\n"

#. type: Plain text
#: text/chapter8.md:352
#, no-wrap
msgid "    _Note:_ There are no tests for this exercise.\n"
msgstr ""

#. type: Title ##
#: text/chapter8.md:353
#, fuzzy, no-wrap
msgid "Native Effects"
msgstr "ネイティブな作用"

#. type: Plain text
#: text/chapter8.md:356
#, fuzzy
msgid ""
"We will now look at one particular monad which is of central importance in "
"PureScript - the `Effect` monad."
msgstr ""
"ここではPureScriptの中核となる重要なモナド、 `Eff`モナドについて見ていきま"
"す。"

#. type: Plain text
#: text/chapter8.md:358
#, fuzzy
msgid ""
"The `Effect` monad is defined in the `Effect` module. It is used to manage "
"so-called _native_ side-effects. If you are familiar with Haskell, it is the "
"equivalent of the `IO` monad."
msgstr ""
"`Eff`モナドは `Control.Monad.Eff`モジュール、およびPreludeで定義されていま"
"す。これはいわゆる**ネイティブな作用**を扱うために使います。"

#. type: Plain text
#: text/chapter8.md:360
#, fuzzy
msgid ""
"What are native side-effects? They are the side-effects which distinguish "
"JavaScript expressions from idiomatic PureScript expressions, which "
"typically are free from side-effects. Some examples of native effects are:"
msgstr ""
"ネイティブな副作用とは何でしょうか。ネイティブな副作用とは、従来のJavaScript"
"の式が持つ副作用と、PureScript特有の式が持つ副作用を区別するものです。ネイ"
"ティブな作用には次のようなものがあります。"

#. type: Plain text
#: text/chapter8.md:365
#, fuzzy
msgid ""
"- Console IO - Random number generation - Exceptions - Reading/writing "
"mutable state"
msgstr "- コンソール入出力 - 乱数生成 - 例外 - 変更可能な状態の読み書き"

#. type: Plain text
#: text/chapter8.md:367
#, fuzzy
msgid "And in the browser:"
msgstr "また、ブラウザでは次のようなものがあります。"

#. type: Plain text
#: text/chapter8.md:372
#, fuzzy
msgid ""
"- DOM manipulation - XMLHttpRequest / AJAX calls - Interacting with a "
"websocket - Writing/reading to/from local storage"
msgstr ""
"- DOM操作 - XMLHttpRequest / AJAX呼び出し - WebSocketによる相互作用 - Local "
"Storageの読み書き"

#. type: Plain text
#: text/chapter8.md:374
#, fuzzy
msgid "We have already seen plenty of examples of \"non-native\" side-effects:"
msgstr "すでに「ネイティブでない」副作用の例については数多く見てきています。"

#. type: Plain text
#: text/chapter8.md:378
#, fuzzy
msgid ""
"- Optional values, as represented by the `Maybe` data type - Errors, as "
"represented by the `Either` data type - Multi-functions, as represented by "
"arrays or lists"
msgstr ""
"- `Maybe`データ型で表現される省略可能な値 - `Either`データ型で表現されるエ"
"ラー - 配列やリストで表現される多価関数"

#. type: Plain text
#: text/chapter8.md:380
#, fuzzy
msgid ""
"Note that the distinction is subtle. It is true, for example, that an error "
"message is a possible side-effect of a JavaScript expression, in the form of "
"an exception. In that sense, exceptions do represent native side-effects, "
"and it is possible to represent them using `Effect`. However, error messages "
"implemented using `Either` are not a side-effect of the JavaScript runtime, "
"and so it is not appropriate to implement error messages in that style using "
"`Effect`. So it is not the effect itself which is native, but rather how it "
"is implemented at runtime."
msgstr ""
"これらの区別はわかりにくいので注意してください。エラーメッセージは例外の形で"
"JavaScriptの式の副作用となることがあります。その意味では例外はネイティブな副"
"作用を表していて、 `Eff`を使用して表現することができます。しかし、 `Either`を"
"使用して実装されたエラーメッセージはJavaScriptランタイムの副作用ではなく、 "
"`Eff`を使うスタイルでエラーメッセージを実装するのは適切ではありません。そのた"
"め、ネイティブなのは作用自体というより、実行時にどのように実装されているかで"
"す。"

#. type: Title ##
#: text/chapter8.md:381
#, fuzzy, no-wrap
msgid "Side-Effects and Purity"
msgstr "副作用と純粋性"

#. type: Plain text
#: text/chapter8.md:384
#, fuzzy
msgid ""
"In a pure language like PureScript, one question which presents itself is: "
"without side-effects, how can one write useful real-world code?"
msgstr ""
"PureScriptのような言語が純粋であるとすると、疑問が浮かんできます。副作用がな"
"いなら、どうやって役に立つ実際のコードを書くことができるというのでしょうか。"

#. type: Plain text
#: text/chapter8.md:386
#, fuzzy
msgid ""
"The answer is that PureScript does not aim to eliminate side-effects. It "
"aims to represent side-effects in such a way that pure computations can be "
"distinguished from computations with side-effects in the type system. In "
"this sense, the language is still pure."
msgstr ""
"その答えはPureScriptの目的は副作用を排除することではないということです。これ"
"は、純粋な計算と副作用のある計算とを型システムにおいて区別することができるよ"
"うな方法で、副作用を表現することを目的としているのです。この意味で、言語はあ"
"くまで純粋だということです。"

#. type: Plain text
#: text/chapter8.md:388
#, fuzzy
msgid ""
"Values with side-effects have different types from pure values. As such, it "
"is not possible to pass a side-effecting argument to a function, for "
"example, and have side-effects performed unexpectedly."
msgstr ""
"副作用のある値は、純粋な値とは異なる型を持っています。このように、例えば副作"
"用のある引数を関数に渡すことはできず、予期せず副作用持つようなことが起こらな"
"くなります。"

#. type: Plain text
#: text/chapter8.md:390
#, fuzzy
msgid ""
"The only way in which side-effects managed by the `Effect` monad will be "
"presented is to run a computation of type `Effect a` from JavaScript."
msgstr ""
"`Eff`モナドで管理された副作用を実行する唯一の方法は、型 `Eff eff a`の計算を"
"JavaScriptから実行することです。"

#. type: Plain text
#: text/chapter8.md:392
#, fuzzy
msgid ""
"The Spago build tool (and other tools) provide a shortcut, by generating "
"additional JavaScript to invoke the `main` computation when the application "
"starts. `main` is required to be a computation in the `Effect` monad."
msgstr ""
"ビルドツールPulp(や他のツール)は、オプションを与えることで、アプリケーション"
"の起動時に `main`計算を呼び出すためのJavaScriptコードを簡単に追加で生成できる"
"ようにしています。 `main`は `Eff`モナドでの計算であることが要求されます。"

#. type: Plain text
#: text/chapter8.md:396
#, fuzzy
msgid ""
"The `Effect` monad provides a well-typed API for computations with side-"
"effects, while at the same time generating efficient JavaScript."
msgstr ""
"`Eff`モナドの目的は、副作用のある計算に型付けされたAPIを提供すると同時に、効"
"率的なJavaScriptを生成することにあります。これは**拡張可能作用**(extensible "
"effects)のモナドとも呼ばれており、これについては後述します。"

#. type: Plain text
#: text/chapter8.md:399
msgid ""
"Let's take a closer look at the return type of the familiar `log` function. "
"`Effect` indicates that this function produces a native effect, console IO "
"in this case.  `Unit` indicates that no _meaningful_ data is returned. You "
"can think of `Unit` as being analogous to the `void` keyword in other "
"languages, such as C, Java, etc."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:400
#, fuzzy, no-wrap
msgid "log :: String -> Effect Unit\n"
msgstr "game :: Array String -> Game Unit\n"

#. type: Plain text
#: text/chapter8.md:405
#, no-wrap
msgid "> _Aside:_ You may encounter IDE suggestions for the more general (and more elaborately typed) `log` function from `Effect.Class.Console`. This is interchangeable with the one from `Effect.Console` when dealing with the basic `Effect` monad. Reasons for the more general version will become clearer after reading about \"Monad Transformers\" in the \"Monadic Adventures\" chapter. For the curious (and impatient), this works because there's a `MonadEffect` instance for `Effect`.\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:409
#, fuzzy, no-wrap
msgid ""
"> ```hs\n"
"> log :: forall m. MonadEffect m => String -> m Unit\n"
"> ```\n"
msgstr "guard :: forall m. MonadZero m => Boolean -> m Unit\n"

#. type: Plain text
#: text/chapter8.md:411
msgid ""
"Now let's consider an `Effect` that returns meaningful data. The `random` "
"function from `Effect.Random` produces a random `Number`."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:412
#, no-wrap
msgid "random :: Effect Number\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:417
msgid ""
"Here's a full example program (found in `test/Random.purs` of this chapter's "
"exercises folder)."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:418
#, no-wrap
msgid "{{#include ../exercises/chapter8/test/Random.purs}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:423
msgid ""
"Because `Effect` is a monad, we use do notation to _unwrap_ the data it "
"contains before passing this data on to the effectful `logShow` function. As "
"a refresher, here's the equivalent code written using the `bind` operator:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:424
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = random >>= logShow\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:430
msgid "Try running this yourself with:"
msgstr ""

#. type: Fenced code block
#: text/chapter8.md:431
#, no-wrap
msgid "spago run --main Test.Random\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:436
#, fuzzy
msgid ""
"You should see a randomly chosen number between `0.0` and `1.0` printed to "
"the console."
msgstr ""
"コンパイルされたJavaScriptを実行すると、コンソールに出力 `0`と `1`の間で無作"
"為に選ばれた数が表示されるでしょう。"

#. type: Plain text
#: text/chapter8.md:438
#, no-wrap
msgid "> _Aside:_ `spago run` defaults to searching in the `Main` module for a `main` function. You may also specify an alternate module as an entry point with the `--main` flag, as is done in the above example. Just be sure that this alternate module also contains a `main` function.\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:440
msgid ""
"Note that it's also possible to generate \"random\" (technically "
"pseudorandom) data without resorting to impure effectful code. We'll cover "
"these techniques in the \"Generative Testing\" chapter."
msgstr ""

#. type: Plain text
#: text/chapter8.md:442
msgid ""
"As mentioned previously, the `Effect` monad is of central importance to "
"PureScript. The reason why it's central is because it is the conventional "
"way to interoperate with PureScript's `Foreign Function Interface`, which "
"provides the mechanism to execute a program and perform side effects. While "
"it's desireable to avoid using the `Foreign Function Interface`, it's fairly "
"critical to understand how it works and how to use it, so I recommend "
"reading that chapter before doing any serious PureScript work. That said, "
"the `Effect` monad is fairly simple. It has a few helper functions, but "
"aside from that it doesn't do much except encapsulate side effects."
msgstr ""

#. type: Plain text
#: text/chapter8.md:446
msgid ""
"Let's examine a function from the `node-fs` package that involves two "
"_native_ side effects: reading mutable state, and exceptions:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:447
#, fuzzy, no-wrap
msgid "readTextFile :: Encoding -> String -> Effect String\n"
msgstr "address :: String -> String -> String -> Address\n"

#. type: Plain text
#: text/chapter8.md:452
msgid "If we attempt to read a file that does not exist:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:453
#, no-wrap
msgid ""
"import Node.Encoding (Encoding(..))\n"
"import Node.FS.Sync (readTextFile)\n"
"\n"
"main :: Effect Unit\n"
"main = do\n"
"  lines <- readTextFile UTF8 \"iDoNotExist.md\"\n"
"  log lines\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:464
#, fuzzy
msgid "We encounter the following exception:"
msgstr "次の点に注意してください。"

#. type: Fenced code block
#: text/chapter8.md:465
#, no-wrap
msgid ""
"    throw err;\n"
"    ^\n"
"Error: ENOENT: no such file or directory, open 'iDoNotExist.md'\n"
"...\n"
"  errno: -2,\n"
"  syscall: 'open',\n"
"  code: 'ENOENT',\n"
"  path: 'iDoNotExist.md'\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:477
msgid ""
"To manage this exception gracefully, we can wrap the potentially problematic "
"code in `try` to handle either outcome:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:478
#, no-wrap
msgid ""
"main :: Effect Unit\n"
"main = do\n"
"  result <- try $ readTextFile UTF8 \"iDoNotExist.md\"\n"
"  case result of\n"
"    Right lines -> log $ \"Contents: \\n\" <> lines\n"
"    Left  error -> log $ \"Couldn't open file. Error was: \" <> message error\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:488
msgid ""
"`try` runs an `Effect` and returns eventual exceptions as a `Left` value. If "
"the computation succeeds, the result gets wrapped in a `Right`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:489
#, fuzzy, no-wrap
msgid "try :: forall a. Effect a -> Effect (Either Error a)\n"
msgstr "liftF :: forall f a. (Functor f) => f a -> Free f a\n"

#. type: Plain text
#: text/chapter8.md:494
msgid ""
"We can also generate our own exceptions. Here is an alternative "
"implementation of `Data.List.head` which throws an exception if the list is "
"empty, rather than returning a `Maybe` value of `Nothing`."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:495
#, no-wrap
msgid ""
"exceptionHead :: List Int -> Effect Int\n"
"exceptionHead l = case l of\n"
"  x : _ -> pure x\n"
"  Nil -> throwException $ error \"empty list\"\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:503
msgid ""
"Note that the `exceptionHead` function is a somewhat impractical example, as "
"it is best to avoid generating exceptions in PureScript code and instead use "
"non-native effects such as `Either` and `Maybe` to manage errors and missing "
"values."
msgstr ""

#. type: Title ##
#: text/chapter8.md:504
#, fuzzy, no-wrap
msgid "Mutable State"
msgstr "可変状態"

#. type: Plain text
#: text/chapter8.md:507
#, fuzzy
msgid "There is another effect defined in the core libraries: the `ST` effect."
msgstr "Preludeには `ST`作用というまた別の作用も定義されています。"

#. type: Plain text
#: text/chapter8.md:509
#, fuzzy
msgid ""
"The `ST` effect is used to manipulate mutable state. As pure functional "
"programmers, we know that shared mutable state can be problematic. However, "
"the `ST` effect uses the type system to restrict sharing in such a way that "
"only safe _local_ mutation is allowed."
msgstr ""
"`ST`作用は変更可能な状態を操作するために使われます。純粋関数プログラミングを"
"知っているなら、共有される変更可能な状態は問題を引き起こしやすいということも"
"知っているでしょう。しかしながら、 `ST`作用は型システムを使って安全で**局所的"
"な**状態変化を可能にし、状態の共有を制限するのです。"

#. type: Plain text
#: text/chapter8.md:511
#, fuzzy
msgid ""
"The `ST` effect is defined in the `Control.Monad.ST` module. To see how it "
"works, we need to look at the types of its actions:"
msgstr ""
"`ST`作用は `Control.Monad.ST`モジュールで定義されています。これがどのように動"
"作するかを確認するには、そのアクションの型を見る必要があります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:512
#, fuzzy, no-wrap
msgid ""
"new :: forall a r. a -> ST r (STRef r a)\n"
"\n"
"read :: forall a r. STRef r a -> ST r a\n"
"\n"
"write :: forall a r. a -> STRef r a -> ST r a\n"
"\n"
"modify :: forall r a. (a -> a) -> STRef r a -> ST r a\n"
msgstr ""
"newSTRef :: forall a h eff. a -> Eff (st :: ST h | eff) (STRef h a)\n"
"\n"
"readSTRef :: forall a h eff. STRef h a -> Eff (st :: ST h | eff) a\n"
"\n"
"writeSTRef :: forall a h eff. STRef h a -> a -> Eff (st :: ST h | eff) a\n"
"\n"
"modifySTRef :: forall a h eff. STRef h a -> (a -> a) -> Eff (st :: ST h | eff) a\n"

#. type: Plain text
#: text/chapter8.md:523
#, fuzzy
msgid ""
"`new` is used to create a new mutable reference cell of type `STRef r a`, "
"which can be read using the `read` action, and modified using the `write` "
"and `modify` actions. The type `a` is the type of the value stored in the "
"cell, and the type `r` is used to indicate a _memory region_ (or _heap_) in "
"the type system."
msgstr ""
"`newSTRef`は型 `STRef h a`の変更可能な参照領域を新しく作るのに使われます。 "
"`STRef h a`は `readSTRef`アクションを使って状態を読み取ったり、 `writeSTRef`"
"アクションや `modifySTRef`アクションで状態を変更するのに使われます。型 `a`は"
"領域に格納された値の型で、型 `h`は型システムの**メモリ領域**を表しています。"

#. type: Plain text
#: text/chapter8.md:525
#, fuzzy
msgid ""
"Here is an example. Suppose we want to simulate the movement of a particle "
"falling under gravity by iterating a simple update function over a large "
"number of small time steps."
msgstr ""
"例を示します。小さな時間刻みで簡単な更新関数の実行を何度も繰り返すことによっ"
"て、重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。"

#. type: Plain text
#: text/chapter8.md:527
#, fuzzy
msgid ""
"We can do this by creating a mutable reference cell to hold the position and "
"velocity of the particle, and then using a `for` loop to update the value "
"stored in that cell:"
msgstr ""
"粒子の位置と速度を保持する変更可能な参照領域を作成し、領域に格納された値を更"
"新するのにforループ(`Control.Monad.Eff`の `forE`アクション)を使うことでこれを"
"実現することができます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:528
#, fuzzy, no-wrap
msgid ""
"import Prelude\n"
"\n"
"import Control.Monad.ST.Ref (modify, new, read)\n"
"import Control.Monad.ST (ST, for, run)\n"
"\n"
"simulate :: forall r. Number -> Number -> Int -> ST r Number\n"
"simulate x0 v0 time = do\n"
"  ref <- new { x: x0, v: v0 }\n"
"  for 0 (time * 1000) \\_ ->\n"
"    modify\n"
"      ( \\o ->\n"
"          { v: o.v - 9.81 * 0.001\n"
"          , x: o.x + o.v * 0.001\n"
"          }\n"
"      )\n"
"      ref\n"
"  final <- read ref\n"
"  pure final.x\n"
msgstr ""
"import Prelude\n"
"\n"
"import Control.Monad.Eff (Eff, forE)\n"
"import Control.Monad.ST (ST, newSTRef, readSTRef, modifySTRef)\n"
"\n"
"simulate :: forall eff h. Number -> Number -> Int -> Eff (st :: ST h | eff) Number\n"
"simulate x0 v0 time = do\n"
"  ref <- newSTRef { x: x0, v: v0 }\n"
"  forE 0 (time * 1000) \\_ -> do\n"
"    modifySTRef ref \\o ->\n"
"      { v: o.v - 9.81 * 0.001\n"
"      , x: o.x + o.v * 0.001\n"
"      }\n"
"    pure unit\n"
"  final <- readSTRef ref\n"
"  pure final.x\n"

#. type: Plain text
#: text/chapter8.md:550
#, fuzzy
msgid ""
"At the end of the computation, we read the final value of the reference "
"cell, and return the position of the particle."
msgstr ""
"計算の最後では、参照領域の最終的な値を読み取り、粒子の位置を返しています。"

#. type: Plain text
#: text/chapter8.md:552
#, fuzzy
msgid ""
"Note that even though this function uses mutable state, it is still a pure "
"function, so long as the reference cell `ref` is not allowed to be used by "
"other parts of the program. We will see that this is exactly what the `ST` "
"effect disallows."
msgstr ""
"この関数が変更可能な状態を使っていても、その参照区画 `ref`がプログラムの他の"
"部分で使われるのが許されない限り、これは純粋な関数のままであることに注意して"
"ください。 `ST`作用が禁止するものが正確には何であるのかについては後ほど見ま"
"す。"

#. type: Plain text
#: text/chapter8.md:554
#, fuzzy
msgid ""
"To run a computation with the `ST` effect, we have to use the `run` function:"
msgstr "`ST`作用で計算を実行するには、 `runST`関数を使用する必要があります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:555
#, fuzzy, no-wrap
msgid "run :: forall a. (forall r. ST r a) -> a\n"
msgstr "runST :: forall a eff. (forall h. Eff (st :: ST h | eff) a) -> Eff eff a\n"

#. type: Plain text
#: text/chapter8.md:560
#, fuzzy
msgid ""
"The thing to notice here is that the region type `r` is quantified _inside "
"the parentheses_ on the left of the function arrow. That means that whatever "
"action we pass to `run` has to work with _any region_ `r` whatsoever."
msgstr ""
"ここで注目して欲しいのは、領域型 `h`が関数矢印の左辺にある**括弧の内側で**量"
"化されているということです。 `runST`に渡したどんなアクションでも、 **任意の領"
"域**`h`がなんであれ動作するということを意味しています。"

#. type: Plain text
#: text/chapter8.md:562
#, fuzzy
msgid ""
"However, once a reference cell has been created by `new`, its region type is "
"already fixed, so it would be a type error to try to use the reference cell "
"outside the code delimited by `run`.  This is what allows `run` to safely "
"remove the `ST` effect, and turn `simulate` into a pure function!"
msgstr ""
"しかしながら、ひとたび参照領域が `newSTRef`によって作成されると、その領域の型"
"はすでに固定されており、 `runST`によって限定されたコードの外側で参照領域を使"
"おうとしても型エラーになるでしょう。 `runST`が安全に `ST`作用を除去できるのは"
"これが理由なのです！"

#. type: Fenced code block (hs)
#: text/chapter8.md:563
#, fuzzy, no-wrap
msgid ""
"simulate' :: Number -> Number -> Int -> Number\n"
"simulate' x0 v0 time = run (simulate x0 v0 time)\n"
msgstr ""
"simulate' :: Number -> Number -> Number -> Number\n"
"simulate' x0 v0 time = runPure (runST (simulate x0 v0 time))\n"

#. type: Plain text
#: text/chapter8.md:569
#, fuzzy
msgid "You can even try running this function in PSCi:"
msgstr "`PSCi`でこの関数を実行してみてください。"

#. type: Fenced code block (text)
#: text/chapter8.md:570
#, fuzzy, no-wrap
msgid ""
"> import Main\n"
"\n"
"> simulate' 100.0 0.0 0\n"
"100.00\n"
"\n"
"> simulate' 100.0 0.0 1\n"
"95.10\n"
"\n"
"> simulate' 100.0 0.0 2\n"
"80.39\n"
"\n"
"> simulate' 100.0 0.0 3\n"
"55.87\n"
"\n"
"> simulate' 100.0 0.0 4\n"
"21.54\n"
msgstr ""
"> import Main\n"
"\n"
"> simulate' 100.0 0.0 0.0\n"
"100.00\n"
"\n"
"> simulate' 100.0 0.0 1.0\n"
"95.10\n"
"\n"
"> simulate' 100.0 0.0 2.0\n"
"80.39\n"
"\n"
"> simulate' 100.0 0.0 3.0\n"
"55.87\n"
"\n"
"> simulate' 100.0 0.0 4.0\n"
"21.54\n"

#. type: Plain text
#: text/chapter8.md:590
#, fuzzy
msgid ""
"In fact, if we inline the definition of `simulate` at the call to `run`, as "
"follows:"
msgstr ""
"もし `simulate`の定義を `runST`の呼び出しのところへ埋め込むとすると、次のよう"
"になります。"

#. type: Fenced code block (hs)
#: text/chapter8.md:591
#, fuzzy, no-wrap
msgid ""
"simulate :: Number -> Number -> Int -> Number\n"
"simulate x0 v0 time =\n"
"  run do\n"
"    ref <- new { x: x0, v: v0 }\n"
"    for 0 (time * 1000) \\_ ->\n"
"      modify\n"
"        ( \\o ->\n"
"            { v: o.v - 9.81 * 0.001\n"
"            , x: o.x + o.v * 0.001\n"
"            }\n"
"        )\n"
"        ref\n"
"    final <- read ref\n"
"    pure final.x\n"
msgstr ""
"simulate :: Number -> Number -> Int -> Number\n"
"simulate x0 v0 time = runPure $ runST do\n"
"  ref <- newSTRef { x: x0, v: v0 }\n"
"  forE 0 (time * 1000) \\_ -> do\n"
"    modifySTRef ref \\o ->  \n"
"      { v: o.v - 9.81 * 0.001\n"
"      , x: o.x + o.v * 0.001  \n"
"      }\n"
"    pure unit  \n"
"  final <- readSTRef ref\n"
"  pure final.x\n"

#. type: Plain text
#: text/chapter8.md:609
#, fuzzy
msgid ""
"then the compiler will notice that the reference cell is not allowed to "
"escape its scope, and can safely turn `ref` into a `var`. Here is the "
"generated JavaScript for `simulate` inlined with `run`:"
msgstr ""
"参照区画はそのスコープから逃れることができないことがコンパイラにわかります"
"し、安全に `var`に変換することができます。 `runST`の呼び出しの本体に対して生"
"成されたJavaScriptは次のようになります。"

#. type: Fenced code block (javascript)
#: text/chapter8.md:610
#, fuzzy, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return (function __do() {\n"
"\n"
"        var ref = { value: { x: x0, v: v0 } };\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        return ref.value.x;\n"
"\n"
"      })();\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""
"var ref = { x: x0, v: v0 };\n"
"\n"
"Control_Monad_Eff.forE(0)(time * 1000 | 0)(function (i) {\n"
"  return function __do() {\n"
"    ref = (function (o) {\n"
"      return {\n"
"        v: o.v - 9.81 * 1.0e-3,\n"
"        x: o.x + o.v * 1.0e-3\n"
"      };\n"
"    })(ref);\n"
"    return Prelude.unit;\n"
"  };\n"
"})();\n"
"\n"
"return ref.x;\n"

#. type: Plain text
#: text/chapter8.md:636
msgid ""
"Note that this resulting JavaScript is not as optimal as it could be. See "
"[this issue](https://github.com/purescript-contrib/purescript-book/"
"issues/121) for more details. The above snippet should be updated once that "
"issue is resolved."
msgstr ""

#. type: Plain text
#: text/chapter8.md:638
msgid ""
"For comparison, this is the generated JavaScript of the non-inlined form:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter8.md:639
#, no-wrap
msgid ""
"var simulate = function (x0) {\n"
"  return function (v0) {\n"
"    return function (time) {\n"
"      return function __do() {\n"
"\n"
"        var ref = Control_Monad_ST_Internal[\"new\"]({ x: x0, v: v0 })();\n"
"\n"
"        Control_Monad_ST_Internal[\"for\"](0)(time * 1000 | 0)(function (v) {\n"
"          return Control_Monad_ST_Internal.modify(function (o) {\n"
"            return {\n"
"              v: o.v - 9.81 * 1.0e-3,\n"
"              x: o.x + o.v * 1.0e-3\n"
"            };\n"
"          })(ref);\n"
"        })();\n"
"\n"
"        var $$final = Control_Monad_ST_Internal.read(ref)();\n"
"        return $$final.x;\n"
"      };\n"
"    };\n"
"  };\n"
"};\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:665
#, fuzzy
msgid ""
"The `ST` effect is a good way to generate short JavaScript when working with "
"locally-scoped mutable state, especially when used together with actions "
"like `for`, `foreach`, and `while` which generate efficient loops."
msgstr ""
"局所的な変更可能状態を扱うとき、特に `Eff`モナドで効率のよいループを生成する "
"`forE`、 `foreachE`、 `whileE`、 `untilE`のようなアクションを一緒に使うときに"
"は、 `ST`作用は短いJavaScriptを生成できる良い方法となります。"

#. type: Bullet: '1. '
#: text/chapter8.md:671
#, fuzzy
msgid ""
"(Medium) Rewrite the `safeDivide` function as `exceptionDivide` and throw an "
"exception using `throwException` with the message `\"div zero\"` if the "
"denominator is zero."
msgstr ""
"（やや難しい） もし分母で分子を割り切れないなら `throwException`を使って例外"
"を投げるように `safeDivide`関数を書き直してください。"

#. type: Bullet: '1. '
#: text/chapter8.md:671
msgid ""
"(Medium) Write a function `estimatePi :: Int -> Number` that uses `n` terms "
"of the [Gregory Series](https://mathworld.wolfram.com/GregorySeries.html) to "
"calculate an approximation of `pi`. _Hints:_ You can pattern your answer "
"like the definition of `simulate` above. You might need to convert an `Int` "
"into a `Number` using `toNumber :: Int -> Number` from `Data.Int`."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter8.md:671
msgid ""
"(Medium) Write a function `fibonacci :: Int -> Int` to compute the `n`th "
"Fibonacci number, using `ST` to track the values of the previous two "
"Fibonacci numbers. Using PSCi, compare the speed of your new `ST`-based "
"implementation against the recursive implementation (`fib`) from Chapter 4."
msgstr ""

#. type: Title ##
#: text/chapter8.md:672
#, fuzzy, no-wrap
msgid "DOM Effects"
msgstr "DOM作用"

#. type: Plain text
#: text/chapter8.md:675
#, fuzzy
msgid ""
"In the final sections of this chapter, we will apply what we have learned "
"about effects in the `Effect` monad to the problem of working with the DOM."
msgstr ""
"この章の最後の節では、 `Eff`モナドでの作用についてこれまで学んだことを、実際"
"のDOM操作の問題に応用します。"

#. type: Plain text
#: text/chapter8.md:677
#, fuzzy
msgid ""
"There are a number of PureScript packages for working directly with the DOM, "
"or with open-source DOM libraries. For example:"
msgstr ""
"DOMを直接扱ったり、オープンソースのDOMライブラリを扱う、自由に利用可能な"
"PureScriptパッケージが幾つかあります。"

#. type: Plain text
#: text/chapter8.md:681
#, fuzzy
msgid ""
"- [`web-dom`](https://github.com/purescript-web/purescript-web-dom) provides "
"type definitions and low level interface implementations for the W3C DOM "
"spec.  - [`web-html`](https://github.com/purescript-web/purescript-web-html) "
"provides type definitions and low level interface implementations for the "
"W3C HTML5 spec.  - [`jquery`](https://github.com/paf31/purescript-jquery) is "
"a set of bindings to the [jQuery](http://jquery.org) library."
msgstr ""
"- [`purescript-dom`](http://github.com/purescript-contrib/purescript-dom) - "
"低レベルなJavaScript DOM APIのバインディング - [`purescript-jquery`](http://"
"github.com/paf31/purescript-jquery) - [jQuery](http://jquery.org)ライブラリの"
"バインディング"

#. type: Plain text
#: text/chapter8.md:683
#, fuzzy
msgid ""
"There are also PureScript libraries which build abstractions on top of these "
"libraries, such as"
msgstr "上記のライブラリを抽象化するPureScript向けのライブラリもあります。"

#. type: Plain text
#: text/chapter8.md:687
#, fuzzy
msgid ""
"- [`thermite`](https://github.com/paf31/purescript-thermite), which builds "
"on [`react`](https://github.com/purescript-contrib/purescript-react)  - "
"[`react-basic-hooks`](https://github.com/megamaddu/purescript-react-basic-"
"hooks), which builds on [`react-basic`](https://github.com/lumihq/purescript-"
"react-basic)  - [`halogen`](https://github.com/purescript-halogen/purescript-"
"halogen) which provides a type-safe set of abstractions on top of a custom "
"virtual DOM library."
msgstr ""
"- [`purescript-thermite`](http://github.com/paf31/purescript-thermite) - "
"`purescript-react`上で構築されるライブラリ - [`purescript-halogen`](http://"
"github.com/slamdata/purescript-halogen) - 仮想DOMを抽象的する型安全なライブラ"
"リ"

#. type: Plain text
#: text/chapter8.md:689
#, fuzzy
msgid ""
"In this chapter, we will use the `react-basic-hooks` library to add a user "
"interface to our address book application, but the interested reader is "
"encouraged to explore alternative approaches."
msgstr ""
"この章では `purescript-react`を使用し、住所簿にインターフェイスを追加します"
"が、興味のあるユーザは異なるアプローチで進めることをおすすめします。"

#. type: Title ##
#: text/chapter8.md:690
#, fuzzy, no-wrap
msgid "An Address Book User Interface"
msgstr "住所録のユーザーインタフェース"

#. type: Plain text
#: text/chapter8.md:693
#, fuzzy
msgid ""
"Using the `react-basic-hooks` library, we will define our application as a "
"React _component_. React components describe HTML elements in code as pure "
"data structures, which are then efficiently rendered to the DOM. In "
"addition, components can respond to events like button clicks. The `react-"
"basic-hooks` library uses the `Effect` monad to describe how to handle these "
"events."
msgstr ""
"`purescript-react`を使用するために**Reactコンポーネント**と同じ様にアプリケー"
"ションを定義します。Reactコンポーネントは、コード内のHTML要素を純粋なデータ構"
"造体として記述し、効率的にDOMにレンダリングします。さらに、コンポーネントはボ"
"タンのクリックなどのイベントに応答できます。 `purescript-react`ライブラリは "
"`Eff`モナドを使ってこれらのイベントをどのように扱うかを記述します。"

#. type: Plain text
#: text/chapter8.md:695
#, fuzzy
msgid ""
"A full tutorial for the React library is well beyond the scope of this "
"chapter, but the reader is encouraged to consult its documentation where "
"needed. For our purposes, React will provide a practical example of the "
"`Effect` monad."
msgstr ""
"Reactライブラリの完全なチュートリアルはこの章の範囲をはるかに超えていますが、"
"読者は必要に応じてマニュアルを参照することをお勧めします。目的に応じて、React"
"は `Eff`モナドの実用的な例を提供してくれます。"

#. type: Plain text
#: text/chapter8.md:697
#, fuzzy
msgid ""
"We are going to build a form which will allow a user to add a new entry into "
"our address book. The form will contain text boxes for the various fields "
"(first name, last name, city, state, etc.), and an area in which validation "
"errors will be displayed. As the user types text into the text boxes, the "
"validation errors will be updated."
msgstr ""
"まずは利用者が住所録に新しい項目を追加できるフォームを構築することにしましょ"
"う。フォームには、さまざまなフィールド（姓、名前、都市、州など）を入力するテ"
"キストボックス、および検証エラーが表示される領域が含まれます。テキストボック"
"スに利用者がテキストを入力すると、検証エラーが更新されます。"

#. type: Plain text
#: text/chapter8.md:699
#, fuzzy
msgid ""
"To keep things simple, the form will have a fixed shape: the different phone "
"number types (home, cell, work, other) will be expanded into separate text "
"boxes."
msgstr ""
"シンプルさを保つために、フォームは固定の形状とします。電話番号は種類（自宅、"
"携帯電話、仕事、その他）ごとに別々のテキストボックスへ分けることにします。"

#. type: Plain text
#: text/chapter8.md:701
msgid ""
"You can launch the web app from the `exercises/chapter8` directory with the "
"following commands:"
msgstr ""

#. type: Fenced code block
#: text/chapter8.md:702
#, no-wrap
msgid ""
"$ npm install\n"
"$ npx spago build\n"
"$ npx parcel src/index.html --open\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:709
msgid ""
"If development tools such as `spago` and `parcel` are installed globally, "
"then the `npx` prefix may be omitted. You have likely already installed "
"`spago` globally with `npm i -g spago`, and the same can be done for "
"`parcel`."
msgstr ""

#. type: Plain text
#: text/chapter8.md:711
msgid ""
"`parcel` should launch a browser window with our \"Address Book\" app. If "
"you keep the `parcel` terminal open, and rebuild with `spago` in another "
"terminal, the page should automatically refresh with your latest edits. You "
"can also configure automatic rebuilds (and therefore automatic page refresh) "
"on file-save if you're using an [editor](https://github.com/purescript/"
"documentation/blob/master/ecosystem/Editor-and-tool-support.md#editors) that "
"supports [`purs ide`](https://github.com/purescript/purescript/tree/master/"
"psc-ide) or are running [`pscid`](https://github.com/kRITZCREEK/pscid)."
msgstr ""

#. type: Plain text
#: text/chapter8.md:713
#, fuzzy
msgid ""
"In this Address Book app, you should be able to enter some values into the "
"form fields and see the validation errors printed onto the page."
msgstr ""
"`pulp browserify --to dist/Main.js`を実行して、それからWebブラウザで `html/"
"index.html`を開き、ユーザインターフェイスを試してみてください。フォームフィー"
"ルドにいろいろな値を入力すると、ページ上に出力された検証エラーを見ることがで"
"きるでしょう。"

#. type: Plain text
#: text/chapter8.md:715
msgid "Let's explore how it works."
msgstr ""

#. type: Plain text
#: text/chapter8.md:717
msgid "The `src/index.html` file is minimal:"
msgstr ""

#. type: Fenced code block (html)
#: text/chapter8.md:718
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.html}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:723
#, no-wrap
msgid "The `<script` line includes the JavaScript entry point, `index.js`, which contains this single line:\n"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter8.md:724
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/index.js}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:729
msgid ""
"It calls our generated JavaScript equivalent of the `main` function of "
"`module Main` (`src/main.purs`). Recall that `spago build` puts all "
"generated JavaScript in the `output` directory."
msgstr ""

#. type: Plain text
#: text/chapter8.md:731
msgid ""
"The `main` function uses the DOM and HTML APIs to render our address book "
"component within the `container` element we defined in `index.html`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:732
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:main}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:737
msgid "Note that these three lines:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:738
#, no-wrap
msgid ""
"w <- window\n"
"doc <- document w\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:745
msgid "Can be consolidated to:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:746
#, no-wrap
msgid ""
"doc <- document =<< window\n"
"ctr <- getElementById \"container\" $ toNonElementParentNode doc\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:752
msgid "Or consolidated even further to:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:753
#, no-wrap
msgid ""
"ctr <- getElementById \"container\" <<< toNonElementParentNode =<< document =<< window\n"
"-- or, equivalently:\n"
"ctr <- window >>= document >>= toNonElementParentNode >>> getElementById \"container\"\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:760
msgid ""
"It is a matter of personal preference whether the intermediate `w` and `doc` "
"variables aid in readability."
msgstr ""

#. type: Plain text
#: text/chapter8.md:762
msgid ""
"Let's dig into our AddressBook `reactComponent`. We'll start with a "
"simplified component, and then build up to the actual code in `Main.purs`."
msgstr ""

#. type: Plain text
#: text/chapter8.md:764
msgid ""
"Take a look at this minimal component. Feel free to substitute the full "
"component with this one to see it run:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:765
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp =\n"
"  reactComponent\n"
"    \"AddressBookApp\"\n"
"    (\\props -> pure $ D.text \"Hi! I'm an address book\")\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:774
msgid "`reactComponent` has this intimidating signature:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:775
#, no-wrap
msgid ""
"reactComponent ::\n"
"  forall hooks props.\n"
"  Lacks \"children\" props =>\n"
"  Lacks \"key\" props =>\n"
"  Lacks \"ref\" props =>\n"
"  String ->\n"
"  ({ | props } -> Render Unit hooks JSX) ->\n"
"  Effect (ReactComponent { | props })\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:787
msgid ""
"The important points to note are the arguments after all the type class "
"constraints. It takes a `String` (an arbitrary component name), a function "
"that describes how to convert `props` into rendered `JSX`, and returns our "
"`ReactComponent` wrapped in an `Effect`."
msgstr ""

#. type: Plain text
#: text/chapter8.md:789
msgid "The props-to-JSX function is simply:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:790
#, no-wrap
msgid "\\props -> pure $ D.text \"Hi! I'm an address book\"\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:795
msgid ""
"`props` are ignored, `D.text` returns `JSX`, and `pure` lifts to rendered "
"JSX. Now `component` has everything it needs to produce the `ReactComponent`."
msgstr ""

#. type: Plain text
#: text/chapter8.md:797
msgid ""
"Next we'll examine some of the additional complexities of the full Address "
"Book component."
msgstr ""

#. type: Plain text
#: text/chapter8.md:799
#, fuzzy
msgid "These are the first few lines of our full component:"
msgstr "次に、コンポーネントの定義を見てみましょう。"

#. type: Fenced code block (hs)
#: text/chapter8.md:800
#, no-wrap
msgid ""
"mkAddressBookApp :: Effect (ReactComponent {})\n"
"mkAddressBookApp = do\n"
"  reactComponent \"AddressBookApp\" \\props -> R.do\n"
"    Tuple person setPerson <- useState examplePerson\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:808
msgid "We track `person` as a piece of state with the `useState` hook."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:809
#, no-wrap
msgid "Tuple person setPerson <- useState examplePerson\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:814
msgid ""
"Note that you are free to break-up component state into multiple pieces of "
"state with multiple calls to `useState`. For example, we could rewrite this "
"app to use a separate piece of state for each record field of `Person`, but "
"that happens to result in a slightly less convenient architecture in this "
"case."
msgstr ""

#. type: Plain text
#: text/chapter8.md:816
msgid ""
"In other examples, you may encounter the `/\\` infix operator for `Tuple`. "
"This is equivalent to the above line:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:817
#, no-wrap
msgid "firstName /\\ setFirstName <- useState p.firstName\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:822
msgid ""
"`useState` takes a default initial value and returns the current value and a "
"way to update the value. We can check the type of `useState` to gain more "
"insight of the types `person` and `setPerson`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:823
#, no-wrap
msgid ""
"useState ::\n"
"  forall state.\n"
"  state ->\n"
"  Hook (UseState state) (Tuple state ((state -> state) -> Effect Unit))\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:831
msgid ""
"We can strip the `Hook (UseState state)` wrapper off of the return value "
"because `useState` is called within an `R.do` block. We'll elaborate on `R."
"do` later."
msgstr ""

#. type: Plain text
#: text/chapter8.md:833
msgid "So now we can observe the following signatures:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:834
#, no-wrap
msgid ""
"person :: state\n"
"setPerson :: (state -> state) -> Effect Unit\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:840
msgid ""
"The specific type of `state` is determined by our initial default value. "
"`Person` `Record` in this case because that is the type of `examplePerson`."
msgstr ""

#. type: Plain text
#: text/chapter8.md:842
msgid "`person` is how we access the current state at each rerender."
msgstr ""

#. type: Plain text
#: text/chapter8.md:844
msgid ""
"`setPerson` is how we update the state. We simply provide a function that "
"describes how to transform the current state to the new state. The record "
"update syntax is perfect for this when the type of `state` happens to be a "
"`Record`, for example:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:845
#, no-wrap
msgid ""
"setPerson (\\currentPerson -> currentPerson {firstName = \"NewName\"})\n"
"\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:851
msgid "or as shorthand:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:852
#, no-wrap
msgid "setPerson _ {firstName = \"NewName\"}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:857
msgid ""
"Non-`Record` states can also follow this update pattern. See [this guide]"
"(https://github.com/megamaddu/purescript-react-basic-hooks/"
"pull/24#issuecomment-620300541) for more details on best practices."
msgstr ""

#. type: Plain text
#: text/chapter8.md:859
msgid ""
"Recall that `useState` is used within an `R.do` block. `R.do` is a special "
"react hooks variant of `do`. The `R.` prefix \"qualifies\" this as coming "
"from `React.Basic.Hooks`, and means we use their hooks-compatible version of "
"`bind` in the `R.do` block. This is known as a \"qualified do\". It lets us "
"ignore the `Hook (UseState state)` wrapping and bind the inner `Tuple` of "
"values to variables."
msgstr ""

#. type: Plain text
#: text/chapter8.md:861
msgid ""
"Another possible state management strategy is with `useReducer`, but that is "
"outside the scope of this chapter."
msgstr ""

#. type: Plain text
#: text/chapter8.md:863
msgid "Rendering `JSX` occurs here:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:864
#, no-wrap
msgid ""
"pure\n"
"  $ D.div\n"
"      { className: \"container\"\n"
"      , children:\n"
"          renderValidationErrors errors\n"
"            <> [ D.div\n"
"                  { className: \"row\"\n"
"                  , children:\n"
"                      [ D.form_\n"
"                          $ [ D.h3_ [ D.text \"Basic Information\" ]\n"
"                            , formField \"First Name\" \"First Name\" person.firstName \\s ->\n"
"                                setPerson _ { firstName = s }\n"
"                            , formField \"Last Name\" \"Last Name\" person.lastName \\s ->\n"
"                                setPerson _ { lastName = s }\n"
"                            , D.h3_ [ D.text \"Address\" ]\n"
"                            , formField \"Street\" \"Street\" person.homeAddress.street \\s ->\n"
"                                setPerson _ { homeAddress { street = s } }\n"
"                            , formField \"City\" \"City\" person.homeAddress.city \\s ->\n"
"                                setPerson _ { homeAddress { city = s } }\n"
"                            , formField \"State\" \"State\" person.homeAddress.state \\s ->\n"
"                                setPerson _ { homeAddress { state = s } }\n"
"                            , D.h3_ [ D.text \"Contact Information\" ]\n"
"                            ]\n"
"                          <> renderPhoneNumbers\n"
"                      ]\n"
"                  }\n"
"              ]\n"
"      }\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:896
msgid ""
"Here we produce `JSX` which represents the intended state of the DOM. This "
"JSX is typically created by applying functions corresponding to HTML tags (e."
"g. `div`, `form`, `h3`, `li`, `ul`, `label`, `input`) which create single "
"HTML elements. These HTML elements are actually React components themselves, "
"converted to JSX. There are usually three variants of each of these "
"functions:"
msgstr ""

#. type: Bullet: '* '
#: text/chapter8.md:900
msgid "`div_`: Accepts an array of child elements. Uses default attributes."
msgstr ""

#. type: Bullet: '* '
#: text/chapter8.md:900
msgid ""
"`div`: Accepts a `Record` of attributes. An array of child elements may be "
"passed to the `children` field of this record."
msgstr ""

#. type: Bullet: '* '
#: text/chapter8.md:900
msgid ""
"`div'`: Same as `div`, but returns the `ReactComponent` before conversion to "
"`JSX`."
msgstr ""

#. type: Plain text
#: text/chapter8.md:902
msgid ""
"To display validation errors (if any) at the top of our form, we create a "
"`renderValidationErrors` helper function that turns the `Errors` structure "
"into an array of JSX. This array is prepended to the rest of our form."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:903
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:renderValidationErrors}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:908
#, fuzzy
msgid ""
"Note that since we are simply manipulating regular data structures here, we "
"can use functions like `map` to build up more interesting elements:"
msgstr ""
"ここでは通常のデータ構造体を単純に操作しているので、 `map`のような関数を使っ"
"て様々な要素を構築することができます。"

#. type: Fenced code block (hs)
#: text/chapter8.md:909
#, no-wrap
msgid "children: [ D.ul_ (map renderError xs)]\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:914
msgid ""
"We use the `className` property to define classes for CSS styling. We're "
"using the [Bootstrap](https://getbootstrap.com/) `stylesheet` for this "
"project, which is imported in `index.html`. For example, we want items in "
"our form arranged as `row`s, and validation errors to be emphasized with "
"`alert-danger` styling:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:915
#, no-wrap
msgid "className: \"alert alert-danger row\"\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:920
#, fuzzy
msgid ""
"A second helper function is `formField`, which creates a text input for a "
"single form field:"
msgstr ""
"2番目の補助関数は `formField`です。これは、単一フォームフィールドのテキスト入"
"力を含む `ReactElement`を作成します。"

#. type: Fenced code block (hs)
#: text/chapter8.md:921
#, no-wrap
msgid "{{#include ../exercises/chapter8/src/Main.purs:formField}}\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:926
msgid ""
"Putting the `input` and display `text` in a `label` aids in accessibility "
"for screen readers."
msgstr ""

#. type: Plain text
#: text/chapter8.md:928
msgid ""
"The `onChange` attribute allows us to describe how to respond to user input. "
"We use the `handler` function, which has the following type:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:929
#, no-wrap
msgid "handler :: forall a. EventFn SyntheticEvent a -> (a -> Effect Unit) -> EventHandler\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:934
msgid ""
"For the first argument to `handler` we use `targetValue`, which provides the "
"value of the text within the HTML `input` element. It matches the signature "
"expected by `handler` where the type variable `a` in this case is `Maybe "
"String`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:935
#, no-wrap
msgid "targetValue :: EventFn SyntheticEvent (Maybe String)\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:940
msgid ""
"In JavaScript, the `input` element's `onChange` event is actually "
"accompanied by a `String` value, but since strings in JavaScript can be "
"null, `Maybe` is used for safety."
msgstr ""

#. type: Plain text
#: text/chapter8.md:942
#, no-wrap
msgid "The second argument to `handler`, `(a -> Effect Unit)`, must therefore have this signature:\n"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:943
#, fuzzy, no-wrap
msgid "Maybe String -> Effect Unit\n"
msgstr "game :: Array String -> Game Unit\n"

#. type: Plain text
#: text/chapter8.md:948
msgid ""
"It is a function that describes how to convert this `Maybe String` value "
"into our desired effect. We define a custom `handleValue` function for this "
"purpose and pass it to `handler` as follows:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:949
#, no-wrap
msgid ""
"onChange:\n"
"  let\n"
"    handleValue :: Maybe String -> Effect Unit\n"
"    handleValue (Just v) = setValue v\n"
"    handleValue Nothing  = pure unit\n"
"  in\n"
"    handler targetValue handleValue\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:960
msgid ""
"`setValue` is the function we provided to each `formField` call that takes a "
"string and makes the appropriate record-update call to the `setPerson` hook."
msgstr ""

#. type: Plain text
#: text/chapter8.md:962
msgid "Note that `handleValue` can be substituted as:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter8.md:963
#, no-wrap
msgid "onChange: handler targetValue $ traverse_ setValue\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:968
msgid ""
"Feel free to investigate the definition of `traverse_` to see how both forms "
"are indeed equivalent."
msgstr ""

#. type: Plain text
#: text/chapter8.md:970
#, fuzzy
msgid ""
"That covers the basics of our component implementation. However, you should "
"read the source accompanying this chapter in order to get a full "
"understanding of the way the component works."
msgstr ""
"これは、コンポーネント実装の基本をカバーしています。しかし、コンポーネントの"
"仕組みを完全に理解するためには、この章に付随する情報をお読みください。"

#. type: Plain text
#: text/chapter8.md:972
#, fuzzy
msgid ""
"Obviously, this user interface can be improved in a number of ways. The "
"exercises will explore some ways in which we can make the application more "
"usable."
msgstr ""
"このユーザインタフェースには明らかに改善すべき点がたくさんあります。演習では"
"アプリケーションがより使いやすくなるような方法を追究していきます。"

#. type: Plain text
#: text/chapter8.md:976
msgid ""
"Modify `src/Main.purs` in the following exercises. There are no unit tests "
"for these exercises."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter8.md:979
#, fuzzy
msgid "(Easy) Modify the application to include a work phone number text box."
msgstr ""
"(簡単) このアプリケーションを変更し、職場の電話番号を入力できるテキストボック"
"スを追加してください。"

#. type: Bullet: '1. '
#: text/chapter8.md:979
msgid ""
"(Medium) Right now the application shows validation errors collected in a "
"single \"pink-alert\" background.  Modify to give each validation error its "
"own pink-alert background by separating them with blank lines."
msgstr ""

#. type: Plain text
#: text/chapter8.md:982
#, fuzzy, no-wrap
msgid ""
"    _Hint_: Instead of using a `ul` element to show the validation errors in a list, modify the code to create one `div` with the `alert` and `alert-danger` styles for each error.\n"
"1. (Difficult, Extended) One problem with this user interface is that the validation errors are not displayed next to the form fields they originated from. Modify the code to fix this problem.\n"
msgstr "(難しい、拡張) このユーザーインターフェイスの問題のひとつは、検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。コードを変更してこの問題を解決してください。"

#. type: Plain text
#: text/chapter8.md:984
#, fuzzy, no-wrap
msgid "    _Hint_: the error type returned by the validator should be extended to indicate which field caused the error. You might want to use the following modified `Errors` type:\n"
msgstr "   **ヒント**：検証器によって返されるエラーの型は、エラーの原因となっているフィールドを示すために拡張する必要があります。次のようなエラー型を使用したくなるかもしれません。\n"

#. type: Plain text
#: text/chapter8.md:992
#, fuzzy, no-wrap
msgid ""
"    ```hs\n"
"    data Field = FirstNameField\n"
"               | LastNameField\n"
"               | StreetField\n"
"               | CityField\n"
"               | StateField\n"
"               | PhoneField PhoneType\n"
msgstr ""
"   data Field = FirstNameField\n"
"              | LastNameField\n"
"              | StreetField\n"
"              | CityField\n"
"              | StateField\n"
"              | PhoneField PhoneType\n"
"\n"
"   data ValidationError = ValidationError String Field\n"
"\n"
"   type Errors = Array ValidationError\n"

#. type: Plain text
#: text/chapter8.md:994
#, no-wrap
msgid "    data ValidationError = ValidationError String Field\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:997
#, no-wrap
msgid ""
"    type Errors = Array ValidationError\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: text/chapter8.md:999
#, fuzzy, no-wrap
msgid "    You will need to write a function which extracts the validation error for a particular `Field` from the `Errors` structure.\n"
msgstr "   適切なフォーム要素を選択するように、 `Field`を `querySelector`アクションの呼び出しに変更する関数を書く必要があるでしょう。\n"

#. type: Plain text
#: text/chapter8.md:1003
#, fuzzy
msgid ""
"This chapter has covered a lot of ideas about handling side-effects in "
"PureScript:"
msgstr ""
"この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。"

#. type: Plain text
#: text/chapter8.md:1010
#, fuzzy
msgid ""
"- We met the `Monad` type class, and its connection to do notation.  - We "
"introduced the monad laws, and saw how they allow us to transform code "
"written using do notation.  - We saw how monads can be used abstractly, to "
"write code which works with different side-effects.  - We saw how monads are "
"examples of applicative functors, how both allow us to compute with side-"
"effects, and the differences between the two approaches.  - The concept of "
"native effects was defined, and we met the `Effect` monad, which is used to "
"handle native side-effects.  - We used the `Effect` monad to handle a "
"variety of effects: random number generation, exceptions, console IO, "
"mutable state, and DOM manipulation using React."
msgstr ""
"- `Monad`型クラスと、それに関連するdo記法の導入をしました。 - モナド則を導入"
"し、do記法使って書かれたコードを変換する方法を説明しました。 - 異なる副作用で"
"動作するコードを書くために、モナドを抽象的に扱う方法を説明しました。 - モナド"
"がApplicative関手の一例であること、両者がどのように副作用のある計算を可能にす"
"るのか、2つの手法の違いを説明しました。 - ネイティブな作用の概念を定義し、ネ"
"イティブな副作用を処理するために使用する `Eff`モナドを導入しました。 - どのよ"
"うに `Eff`モナドが拡張可能作用を提供するか、複数の種類のネイティブな作用を同"
"じ計算に混在させる方法を説明しました。 - 作用やレコードが種システムでどのよう"
"に扱われるか、拡張可能レコードと拡張可能作用の関連を見ました。 - 乱数生成、例"
"外、コンソール入出力、変更可能な状態、およびDOM操作といった、さまざまな作用を"
"扱うために `Eff`モナドを使いました。"

#. type: Plain text
#: text/chapter8.md:1011
#, fuzzy
msgid ""
"The `Effect` monad is a fundamental tool in real-world PureScript code. It "
"will be used in the rest of the book to handle side-effects in a number of "
"other use-cases."
msgstr ""
"`Eff`モナドは現実のPureScriptコードにおける基本的なツールです。本書ではこのあ"
"とも、様々な場面で副作用を処理するために `Eff`モナドを使っていきます。"

#. type: Title #
#: text/chapter9.md:1
#, no-wrap
msgid "Asynchronous Effects"
msgstr ""

#. type: Plain text
#: text/chapter9.md:6
msgid ""
"This chapter focuses on the `Aff` monad, which is similar to the `Effect` "
"monad, but represents _asynchronous_ side-effects. We'll demonstrate "
"examples of asynchronously interacting with the filesystem and making HTTP "
"requests. We'll also cover how to manage sequential and parallel execution "
"of asynchronous effects."
msgstr ""

#. type: Plain text
#: text/chapter9.md:10
msgid "New PureScript libraries introduced in this chapter are:"
msgstr ""

#. type: Plain text
#: text/chapter9.md:15
msgid ""
"- `aff` - defines the `Aff` monad.  - `node-fs-aff` - asynchronous "
"filesystem operations with `Aff`.  - `affjax` - HTTP requests with AJAX and "
"`Aff`.  - `parallel` - parallel execution of `Aff`."
msgstr ""

#. type: Plain text
#: text/chapter9.md:17
msgid ""
"When running outside of the browser (such as in our Node.js environment), "
"the `affjax` library requires the `xhr2` NPM module. Install that by running:"
msgstr ""

#. type: Fenced code block (shell)
#: text/chapter9.md:18
#, fuzzy, no-wrap
msgid "$ npm install\n"
msgstr "npm install\n"

#. type: Title ##
#: text/chapter9.md:22
#, fuzzy, no-wrap
msgid "Asynchronous JavaScript"
msgstr "関数型JavaScript"

#. type: Plain text
#: text/chapter9.md:25
msgid ""
"A convenient way to work with asynchronous code in JavaScript is with "
"[`async` and `await`](https://developer.mozilla.org/en-US/docs/Learn/"
"JavaScript/Asynchronous/Async_await). See [this article on asynchronous "
"JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/"
"Asynchronous/Introducing) for more background information."
msgstr ""

#. type: Plain text
#: text/chapter9.md:27
msgid ""
"Here is an example of using this technique to copy the contents of one file "
"to another file:"
msgstr ""

#. type: Fenced code block (js)
#: text/chapter9.md:28
#, no-wrap
msgid ""
"import { promises as fsPromises } from 'fs'\n"
"\n"
"async function copyFile(file1, file2) {\n"
"  let data = await fsPromises.readFile(file1, { encoding: 'utf-8' });\n"
"  fsPromises.writeFile(file2, data, { encoding: 'utf-8' });\n"
"}\n"
"\n"
"copyFile('file1.txt', 'file2.txt')\n"
".catch(e => {\n"
"  console.log('There was a problem with copyFile: ' + e.message);\n"
"});\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:43
msgid ""
"It is also possible to use callbacks or synchronous functions, but those are "
"less desireable because:"
msgstr ""

#. type: Plain text
#: text/chapter9.md:46
msgid ""
"- Callbacks lead to excessive nesting, known as \"Callback Hell\" or the "
"\"Pyramid of Doom\".  - Synchronous functions block execution of the other "
"code in your app."
msgstr ""

#. type: Title ##
#: text/chapter9.md:47
#, no-wrap
msgid "Asynchronous PureScript"
msgstr ""

#. type: Plain text
#: text/chapter9.md:50
msgid ""
"The `Aff` monad in PureScript offers similar ergonomics of JavaScript's "
"`async`/`await` syntax. Here is the same `copyFile` example from before, but "
"rewritten in PureScript using `Aff`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:51
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/Copy.purs:copyFile}}\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:56
msgid ""
"It is also possible to re-write the above snippet using callbacks or "
"synchronous functions (for example with `Node.FS.Async` and `Node.FS.Sync` "
"respectively), but those share the same downsides as discussed earlier with "
"JavaScript, and so that coding style is not recommended."
msgstr ""

#. type: Plain text
#: text/chapter9.md:58
msgid ""
"The syntax for working with `Aff` is very similar to working with `Effect`. "
"They are both monads, and can therefore be written with do notation."
msgstr ""

#. type: Plain text
#: text/chapter9.md:60
msgid ""
"For example, if we look at the signature of `readTextFile`, we see that it "
"returns the file contents as a `String` wrapped in `Aff`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:60
#, no-wrap
msgid "readTextFile :: Encoding -> FilePath -> Aff String\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:64
#, no-wrap
msgid "We can \"unwrap\" the returned string with a bind arrow (`<-`) in do notation:\n"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:64
#, no-wrap
msgid "my_data <- readTextFile UTF8 file1\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:68
msgid "Then pass it as the string argument to `writeTextFile`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:68
#, no-wrap
msgid "writeTextFile :: Encoding -> FilePath -> String -> Aff Unit\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:73
msgid ""
"The only other notable feature unique to `Aff` in the above example is "
"`attempt`, which captures errors or exceptions encountered while running "
"`Aff` code and stores them in an `Either`:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:73
#, fuzzy, no-wrap
msgid "attempt :: forall a. Aff a -> Aff (Either Error a)\n"
msgstr "liftF :: forall f a. (Functor f) => f a -> Free f a\n"

#. type: Plain text
#: text/chapter9.md:78
msgid ""
"You should hopefully be able to draw on your knowledge of concepts from "
"previous chapters and combine this with the new `Aff` patterns learned in "
"the above `copyFile` example to tackle the following exercises:"
msgstr ""

#. type: Bullet: ' 1. '
#: text/chapter9.md:82
#, fuzzy
msgid ""
"(Easy) Write a `concatenateFiles` function which concatenates two text files."
msgstr ""
"(簡単)`readFileCont`と `writeFileCont`を使って、2つのテキストフ​​ァイルを連結す"
"る関数を書いてください。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:84
#, fuzzy
msgid ""
"(Medium) Write a function `concatenateMany` to concatenate multiple text "
"files, given an array of input file names and an output file name. _Hint_: "
"use `traverse`."
msgstr ""
"(やや難しい) 入力ファイル名の配列を与えて複数のテキストファイルを連結する関"
"数 `concatenateMany`を書く。 **ヒント**：`traverse`を使用します。"

#. type: Bullet: ' 1. '
#: text/chapter9.md:86
msgid ""
"(Medium) Write a function `countCharacters :: FilePath -> Aff (Either Error "
"Int)` that returns the number of characters in a file, or an error if one is "
"encountered."
msgstr ""

#. type: Title ##
#: text/chapter9.md:87
#, no-wrap
msgid "Additional Aff Resources"
msgstr ""

#. type: Plain text
#: text/chapter9.md:90
msgid ""
"If you haven't already taken a look at the [official Aff guide](https://"
"pursuit.purescript.org/packages/purescript-aff/), skim through that now. "
"It's not a direct prerequisite for completing the remaining exercises in "
"this chapter, but you may find it helpful to lookup some functions on "
"Pursuit."
msgstr ""

#. type: Plain text
#: text/chapter9.md:94
msgid ""
"You're also welcome to consult these supplemental resources too, but again, "
"the exercises in this chapter don't depend on them: * [Drew's Aff Post]"
"(https://blog.drewolson.org/asynchronous-purescript)  * [Additional Aff "
"Explanation and Examples](https://github.com/JordanMartinez/purescript-"
"jordans-reference/tree/latestRelease/21-Hello-World/02-Effect-and-Aff/src/03-"
"Aff)"
msgstr ""

#. type: Title ##
#: text/chapter9.md:95
#, fuzzy, no-wrap
msgid "A HTTP Client"
msgstr "HTTPクライアント"

#. type: Plain text
#: text/chapter9.md:100
msgid ""
"The `affjax` library offers a convenient way to make asynchronous AJAX HTTP "
"requests with `Aff`. Depending on what environment you are targeting you "
"need to use either the [purescript-affjax-web](https://github.com/purescript-"
"contrib/purescript-affjax-web) or the [purescript-affjax-node](https://"
"github.com/purescript-contrib/purescript-affjax-node) library.  In the rest "
"of this chapter we will be targeting node and thus using `purescript-affjax-"
"node`.  Consult the [Affjax docs](https://pursuit.purescript.org/packages/"
"purescript-affjax) for more usage information. Here is an example that makes "
"HTTP GET requests at a provided URL and returns the response body or an "
"error message:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:101
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/HTTP.purs:getUrl}}\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:106
msgid ""
"When calling this in the repl, `launchAff_` is required to convert the `Aff` "
"to a repl-compatible `Effect`:"
msgstr ""

#. type: Fenced code block (shell)
#: text/chapter9.md:107
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> :pa\n"
"â¦ import Prelude\n"
"â¦ import Effect.Aff (launchAff_)\n"
"â¦ import Effect.Class.Console (log)\n"
"â¦ import Test.HTTP (getUrl)\n"
"â¦\n"
"â¦ launchAff_ do\n"
"â¦   str <- getUrl \"https://reqres.in/api/users/1\"\n"
"â¦   log str\n"
"â¦\n"
"unit\n"
"{\"data\":{\"id\":1,\"email\":\"george.bluth@reqres.in\",\"first_name\":\"George\",\"last_name\":\"Bluth\", ...}}\n"
msgstr ""

#. type: Bullet: '1. '
#: text/chapter9.md:127
msgid ""
"(Easy) Write a function `writeGet` which makes an HTTP `GET` request to a "
"provided url, and writes the response body to a file."
msgstr ""

#. type: Title ##
#: text/chapter9.md:128
#, fuzzy, no-wrap
msgid "Parallel Computations"
msgstr "並列計算"

#. type: Plain text
#: text/chapter9.md:131
#, fuzzy
msgid ""
"We've seen how to use the `Aff` monad and do notation to compose "
"asynchronous computations in sequence. It would also be useful to be able to "
"compose asynchronous computations _in parallel_. With `Aff`, we can compute "
"in parallel simply by initiating our two computations one after the other."
msgstr ""
"`ContT`モナドとdo記法を使って、非同期計算を順番に実行されるように合成する方法"
"を見てきました。非同期計算を**並列に**合成することもできたら便利でしょう。"

#. type: Plain text
#: text/chapter9.md:133
#, fuzzy
msgid ""
"The `parallel` package defines a type class `Parallel` for monads like `Aff` "
"which support parallel execution. When we met applicative functors earlier "
"in the book, we observed how applicative functors can be useful for "
"combining parallel computations. In fact, an instance for `Parallel` defines "
"a correspondence between a monad `m` (such as `Aff`) and an applicative "
"functor `f` which can be used to combine computations in parallel:"
msgstr ""
"`purescript-parallel`パッケージは型クラス`Parallel`を定義します。この型クラス"
"はモナドのために並列計算を提供する`Async`のようなものです。以前に本書で"
"Applicative関手を導入したとき、並列計算を合成するときにApplicative関手がどの"
"ように便利なのかを観察しました。実は`Parallel`のインスタンスは、(`Async`のよ"
"うな)モナド`m`と、並列に計算を合成するために使われるApplicative関手`f`との対"
"応関係を定義しているのです。"

#. type: Fenced code block (hs)
#: text/chapter9.md:134
#, fuzzy, no-wrap
msgid ""
"class (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n"
"  sequential :: forall a. f a -> m a\n"
"  parallel :: forall a. m a -> f a\n"
msgstr ""
"class (Monad m, Applicative f) <= Parallel f m | m -> f, f -> m where\n"
"  sequential :: forall a. f a -> m a\n"
"  parallel :: forall a. m a -> f a\n"

#. type: Plain text
#: text/chapter9.md:141
#, fuzzy
msgid "The class defines two functions:"
msgstr "このクラスは2つの関数を定義しています。"

#. type: Plain text
#: text/chapter9.md:144
#, fuzzy
msgid ""
"- `parallel`, which takes computations in the monad `m` and turns them into "
"computations in the applicative functor `f`, and - `sequential`, which "
"performs a conversion in the opposite direction."
msgstr ""
"- `parallel`：モナド `m`を計算し、それを応用ファンクタ `f`の計算に変換しま"
"す。 - `sequential`：反対方向の変換を行います。"

#. type: Plain text
#: text/chapter9.md:146
#, fuzzy
msgid ""
"The `aff` library provides a `Parallel` instance for the `Aff` monad. It "
"uses mutable references to combine `Aff` actions in parallel, by keeping "
"track of which of the two continuations has been called. When both results "
"have been returned, we can compute the final result and pass it to the main "
"continuation."
msgstr ""
"`purescript-parallel`ライブラリは `Async`モナドの `Parallel`インスタンスを提"
"供します。 これは、2つの継続(continuation)のどちらが呼び出されたかを追跡する"
"ことによって、変更可能な参照を使用して並列に `Async`アクションを組み合わせま"
"す。 両方の結果が返されたら、最終結果を計算してメインの継続に渡すことができま"
"す。"

#. type: Plain text
#: text/chapter9.md:148
#, fuzzy
msgid ""
"Because applicative functors support lifting of functions of arbitrary "
"arity, we can perform more computations in parallel by using the applicative "
"combinators. We can also benefit from all of the standard library functions "
"which work with applicative functors, such as `traverse` and `sequence`!"
msgstr ""
"Applicative関手では任意個引数の関数の持ち上げができるので、このApplicativeコ"
"ンビネータを使ってより多くの計算を並列に実行することができます。 `traverse`"
"と `sequence`のようなApplicative関手を扱うすべての標準ライブラリ関数から恩恵"
"を受けることもできます。"

#. type: Plain text
#: text/chapter9.md:150
#, fuzzy
msgid ""
"We can also combine parallel computations with sequential portions of code, "
"by using applicative combinators in a do notation block, or vice versa, "
"using `parallel` and `sequential` to change type constructors where "
"appropriate."
msgstr ""
"必要に応じて `Parralel`と `runParallel`を使って型構築子を変更することで、do記"
"法ブロックのApplicativeコンビネータを使って、直列的なコードの一部で並列計算を"
"結合したり、またはその逆を行ったりすることができます。"

#. type: Plain text
#: text/chapter9.md:154
msgid ""
"To demonstrate the difference between sequential and parallel execution, "
"we'll create an array of 100 10-millisecond delays, then execute those "
"delays with both techniques.  You'll notice in the repl that `seqDelay` is "
"much slower than `parDelay`.  Note that parallel execution is enabled by "
"simply replacing `sequence_` with `parSequence_`."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:155
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelDelay.purs:delays}}\n"
msgstr ""

#. type: Fenced code block (shell)
#: text/chapter9.md:159
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelDelay\n"
"\n"
"> seqDelay -- This is slow\n"
"unit\n"
"\n"
"> parDelay -- This is fast\n"
"unit\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:172
msgid ""
"Here's a more real-world example of making multiple HTTP requests in "
"parallel. We're reusing our `getUrl` function to fetch information from two "
"users in parallel. Note that `parTraverse` (the parallel version of "
"`traverse`) is used in this case. This example would also work fine with "
"`traverse` instead, but it will be slower."
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:173
#, no-wrap
msgid "{{#include ../exercises/chapter9/test/ParallelFetch.purs:fetchPar}}\n"
msgstr ""

#. type: Fenced code block (shell)
#: text/chapter9.md:177
#, no-wrap
msgid ""
"$ spago repl\n"
"\n"
"> import Test.ParallelFetch\n"
"\n"
"> fetchPar\n"
"unit\n"
"[\"{\\\"data\\\":{\\\"id\\\":1,\\\"email\\\":\\\"george.bluth@reqres.in\\\", ... }\"\n"
",\"{\\\"data\\\":{\\\"id\\\":2,\\\"email\\\":\\\"janet.weaver@reqres.in\\\", ... }\"\n"
"]\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:190
msgid ""
"A full listing of available parallel functions can be found in the "
"[`parallel` docs on Pursuit](https://pursuit.purescript.org/packages/"
"purescript-parallel/docs/Control.Parallel). The [aff docs section on "
"parallel](https://github.com/purescript-contrib/purescript-aff#parallel-"
"execution) also contains more examples."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter9.md:194
msgid ""
"(Easy) Write a `concatenateManyParallel` function which has the same "
"signature as the earlier `concatenateMany` function, but reads all input "
"files in parallel."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter9.md:198
msgid ""
"(Medium) Write a `getWithTimeout :: Number -> String -> Aff (Maybe String)` "
"function which makes an HTTP `GET` request at the provided URL and returns "
"either:"
msgstr ""

#. type: Bullet: '    - '
#: text/chapter9.md:198
msgid ""
"`Nothing`: if the request takes longer than the provided timeout (in "
"milliseconds)."
msgstr ""

#. type: Bullet: '    - '
#: text/chapter9.md:198
msgid ""
"The string response: if the request succeeds before the timeout elapses."
msgstr ""

#. type: Bullet: '1. '
#: text/chapter9.md:200
msgid ""
"(Difficult) Write a `recurseFiles` function which takes a \"root\" file and "
"returns an array of all paths listed in that file (and listed in the listed "
"files too). Read listed files in parallel. Paths are relative to the "
"directory of the file they appear in. _Hint:_ The `node-path` module has "
"some helpful functions for negotiating directories."
msgstr ""

#. type: Plain text
#: text/chapter9.md:202
#, fuzzy
msgid "For example, if starting from the following `root.txt` file:"
msgstr "たとえば、次のような単純な代数的データ型を考えてみましょう。"

#. type: Fenced code block (shell)
#: text/chapter9.md:202
#, no-wrap
msgid ""
"$ cat root.txt\n"
"a.txt\n"
"b/a.txt\n"
"c/a/a.txt\n"
"\n"
"$ cat a.txt\n"
"b/b.txt\n"
"\n"
"$ cat b/b.txt\n"
"c/a.txt\n"
"\n"
"$ cat b/c/a.txt\n"
"\n"
"$ cat b/a.txt\n"
"\n"
"$ cat c/a/a.txt\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:221
msgid "The expected output is:"
msgstr ""

#. type: Fenced code block (hs)
#: text/chapter9.md:221
#, no-wrap
msgid "[\"root.txt\",\"a.txt\",\"b/a.txt\",\"b/b.txt\",\"b/c/a.txt\",\"c/a/a.txt\"]\n"
msgstr ""

#. type: Plain text
#: text/chapter9.md:230
msgid ""
"In this chapter we covered asynchronous effects and learned how to: - Run "
"asynchronous code in the `Aff` monad with the `aff` library.  - Make HTTP "
"requests asynchronously with the `affjax` library.  - Run asynchronous code "
"in parallel with the `parallel` library."
msgstr ""

#, fuzzy
#~ msgid ""
#~ "- The PureScript IRC channel is a great place to chat about issues you "
#~ "may be having. Point your IRC client at irc.freenode.net, and connect to "
#~ "the #purescript channel.  - The [PureScript website](http://purescript."
#~ "org) contains links to several learning resources, including code "
#~ "samples, videos and other resources for beginners.  - The [PureScript "
#~ "documentation repository](https://github.com/purescript/documentation) "
#~ "collects articles and examples on a wide variety of topics, written by "
#~ "PureScript developers and users.  - [Try PureScript!](http://try."
#~ "purescript.org) is a website which allows users to compile PureScript "
#~ "code in the web browser, and contains several simple examples of code.  - "
#~ "[Pursuit](http://pursuit.purescript.org) is a searchable database of "
#~ "PureScript types and functions."
#~ msgstr ""
#~ "- PureScript IRCチャン​​ネルはあなたが抱える問題についてチャットするのに最適"
#~ "な場所です。IRCクライアントでirc.freenode.netをポイントし、#purescriptチャ"
#~ "ンネルに接続してください。 - [PureScriptのウェブサイト](http://purescript."
#~ "org)にはPureScriptの開発者によって書かれたブログ記事や、初心者向けの動画、"
#~ "その他のリソースへのリンクがあります。 - [PureScriptコンパイラのドキュメン"
#~ "ト](https://github.com/purescript/documentation)は、言語の主要な機能につい"
#~ "ての簡単​​なコード例があります。 - [Try PureScript!](http://try.purescript."
#~ "org)ではユーザーがWebブラウザでPureScriptコードをコンパイルすることができ"
#~ "ます。また、ウェブサイトにはコードの簡単な例がいくつか含まれています。 - "
#~ "[Pursuit](http://pursuit.purescript.org)は、PureScriptの型や関数を検索する"
#~ "ことができるデータベースです。"

#, fuzzy
#~ msgid ""
#~ "In this chapter, the goal will be to set up a working PureScript "
#~ "development environment, and to write our first PureScript program."
#~ msgstr ""
#~ "この章の目標は、作業用のPureScript開発環境を準備し、最初のPureScriptプログ"
#~ "ラムを書くことです。"

#, fuzzy
#~ msgid ""
#~ "Our first project will be a very simple PureScript library, which will "
#~ "provide a single function which can compute the length of the diagonal in "
#~ "a right-angled triangle."
#~ msgstr ""
#~ "これから書く最初のコードはごく単純なPureScriptライブラリで、直角三角形の対"
#~ "角線の長さを計算する関数ひとつだけを提供します。"

#, fuzzy
#~ msgid ""
#~ "Here are the tools we will be using to set up our PureScript development "
#~ "environment:"
#~ msgstr "PureScript開発環境を準備するために、次のツールを使います。"

#, fuzzy
#~ msgid ""
#~ "- [`purs`](http://purescript.org) - The PureScript compiler itself.  - "
#~ "[`npm`](http://npmjs.org) - The Node Package Manager, which will allow us "
#~ "to install the rest of our development tools.  - [Pulp](https://github."
#~ "com/bodil/pulp) - A command-line tool which automates many of the tasks "
#~ "associated with managing PureScript projects."
#~ msgstr ""
#~ "- [`purs`](http://purescript.org) - PureScriptコンパイラ本体 - [`npm`]"
#~ "(http://npmjs.org) - 残りの開発ツールをインストールできるようにする、Node"
#~ "パッケージマネージャ - [`Pulp`](https://github.com/purescript-contrib/"
#~ "pulp) ​​- さまざまな作業をパッケージマネージャと連動して自動化するコマンドラ"
#~ "インツール"

#, fuzzy
#~ msgid ""
#~ "The rest of the chapter will guide you through installing and configuring "
#~ "these tools."
#~ msgstr "この章ではこれらのツールのインストール方法と設定を説明します。"

#, fuzzy, no-wrap
#~ msgid "Installing PureScript"
#~ msgstr "PureScriptのインストール"

#, fuzzy
#~ msgid ""
#~ "The recommended approach to installing the PureScript compiler is to "
#~ "download a binary release for your platform from the [PureScript website]"
#~ "(http://purescript.org)."
#~ msgstr ""
#~ "PureScriptコンパイラをインストールするときにお勧めなのは、[PureScriptの"
#~ "ウェブサイト](http://purescript.org)からバイナリ配布物としてダウンロードす"
#~ "る方法です。"

#, fuzzy
#~ msgid ""
#~ "You should verify that the PureScript compiler executables are available "
#~ "on your path. Try running the PureScript compiler on the command line to "
#~ "verify this:"
#~ msgstr ""
#~ "PureScriptコンパイラおよび関連する実行ファイルが、パス上で利用できるかどう"
#~ "か確認をしてください。試しに、コマンドラインでPureScriptコンパイラを実行し"
#~ "てみましょう。"

#, fuzzy, no-wrap
#~ msgid "$ purs\n"
#~ msgstr "$ purs\n"

#, fuzzy
#~ msgid "Other options for installing the PureScript compiler include:"
#~ msgstr ""
#~ "PureScriptコンパイラをインストールする他の選択肢としては、次のようなものが"
#~ "あります。"

#, fuzzy
#~ msgid ""
#~ "- Via NPM: `npm install -g purescript`.  - Building the compiler from "
#~ "source. Instructions can be found on the PureScript website."
#~ msgstr ""
#~ "- NPMを使用する。`npm install -g purescript` - ソースコードからコンパイル"
#~ "を行う。この方法については、PureScriptのWebサイトが参考になります。"

#, fuzzy, no-wrap
#~ msgid "Installing Tools"
#~ msgstr "各ツールのインストール"

#, fuzzy
#~ msgid ""
#~ "If you do not have a working installation of [NodeJS](http://nodejs."
#~ "org/), you should install it. This should also install the `npm` package "
#~ "manager on your system. Make sure you have `npm` installed and available "
#~ "on your path."
#~ msgstr ""
#~ "もし[NodeJS](http://nodejs.org/)がインストールされていないなら、NodeJSをイ"
#~ "ンストールする必要があります。そうするとシステムに `npm`パッケージマネー"
#~ "ジャもインストールされるはずです。 `npm`がインストールされ、パス上で利用可"
#~ "能であることを確認してください。"

#, fuzzy
#~ msgid ""
#~ "You will also need to install the Pulp command line tool, and the Bower "
#~ "package manager using `npm`, as follows:"
#~ msgstr ""
#~ "`npm`がインストールされたら、 `pulp`と `bower`もインストールする必要があり"
#~ "ます。プロジェクトがどこで作業しているかにかかわらずこれらのコマンドライン"
#~ "ツールが利用可能であるようにするため、通常はグローバルにインストールしてお"
#~ "くのがいいでしょう。"

#, fuzzy, no-wrap
#~ msgid "$ npm install -g pulp bower\n"
#~ msgstr "$ npm install -g pulp bower\n"

#, fuzzy
#~ msgid ""
#~ "This will place the `pulp` and `bower` command line tools on your path. "
#~ "At this point, you will have all the tools needed to create your first "
#~ "PureScript project."
#~ msgstr ""
#~ "これで、最初のPureScriptプロジェクトを作成するために必要なすべてのツールの"
#~ "用意ができたことになります。"

#, fuzzy, no-wrap
#~ msgid "Hello, PureScript!"
#~ msgstr "Hello, PureScript!"

#, fuzzy
#~ msgid ""
#~ "Let's start out simple. We'll use Pulp to compile and run a simple Hello "
#~ "World! program."
#~ msgstr ""
#~ "まずはシンプルに始めましょう。PureScriptコンパイラ`pulp`を直接使用して、基"
#~ "本的なHello World! プログラムをコンパイルします。"

#, fuzzy
#~ msgid ""
#~ "Begin by creating a project in an empty directory, using the `pulp init` "
#~ "command:"
#~ msgstr ""
#~ "最初に空のディレクトリ`my-project`を作成し、そこで`pulp init`を実行しま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ mkdir my-project\n"
#~ "$ cd my-project\n"
#~ "$ pulp init\n"
#~ "\n"
#~ "* Generating project skeleton in ~/my-project\n"
#~ "\n"
#~ "$ ls\n"
#~ "\n"
#~ "bower.json\tsrc\t\ttest\n"
#~ msgstr ""
#~ "$ mkdir my-project\n"
#~ "$ cd my-project\n"
#~ "$ pulp init\n"
#~ "\n"
#~ "* Generating project skeleton in ~/my-project\n"
#~ "\n"
#~ "$ ls\n"
#~ "\n"
#~ "bower.json\tsrc\t\ttest\n"

#, fuzzy
#~ msgid ""
#~ "Pulp has created two directories, `src` and `test`, and a `bower.json` "
#~ "configuration file for us. The `src` directory will contain our source "
#~ "files, and the `test` directory will contain our tests. We will use the "
#~ "`test` directory later in the book."
#~ msgstr ""
#~ "Pulpは`src`と`test`という2つのディレクトリと設定ファイル`bower.json`を作成"
#~ "してくれます。`src`ディレクトリにはソースコードファイルを保存し、`test`"
#~ "ディレクトリにはテストコードファイルを保存します。`test`ディレクトリはこの"
#~ "本の後半で使います。"

#, fuzzy
#~ msgid "Modify the `src/Main.purs` file to contain the following content:"
#~ msgstr ""
#~ "`src/Main.purs`という名前のファイルに、以下のコードを貼り付けてください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "module Main where\n"
#~ "\n"
#~ "import Control.Monad.Eff.Console\n"
#~ "\n"
#~ "main = log \"Hello, World!\"\n"
#~ msgstr ""
#~ "module Main where\n"
#~ "\n"
#~ "import Control.Monad.Eff.Console\n"
#~ "\n"
#~ "main = log \"Hello, World!\"\n"

#, fuzzy
#~ msgid "This small sample illustrates a few key ideas:"
#~ msgstr ""
#~ "これは小さなサンプルコードですが、​​いくつかの重要な概念を示しています。"

#, fuzzy
#~ msgid ""
#~ "- Every file begins with a module header. A module name consists of one "
#~ "or more capitalized words separated by dots. In this case, only a single "
#~ "word is used, but `My.First.Module` would be an equally valid module "
#~ "name.  - Modules are imported using their full names, including dots to "
#~ "separate the parts of the module name. Here, we import the `Control.Monad."
#~ "Eff.Console` module, which provides the `log` function.  - The `main` "
#~ "program is defined as a function application. In PureScript, function "
#~ "application is indicated with whitespace separating the function name "
#~ "from its arguments."
#~ msgstr ""
#~ "- すべてのソースファイルはモジュールヘッダから始まります。モジュール名は、"
#~ "ドットで区切られた大文字で始まる1つ以上の単語から構成されています。ここで"
#~ "はモジュール名としてひとつの単語だけが使用されていますが、 `My.First."
#~ "Module`というようなモジュール名も有効です。 - モジュールは、モジュール名の"
#~ "各部分を区切るためのドットを含めた、完全な名前を使用してインポートされま"
#~ "す。ここでは `log`関数を提供する `Control.Monad.Eff.Console`モジュールをイ"
#~ "ンポートしています。 - この `main`プログラムの定義本体は、関数適用の式に"
#~ "なっています。PureScriptでは、関数適用は関数名のあとに引数を空白で区切って"
#~ "書くことで表します。"

#, fuzzy
#~ msgid "Let's build and run this code using the following command:"
#~ msgstr ""
#~ "それではこのコードをビルドして実行してみましょう。次のコマンドを実行しま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ pulp run\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "Hello, World!\n"
#~ msgstr ""
#~ "$ pulp run\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "Hello, World!\n"

#, fuzzy
#~ msgid ""
#~ "Congratulations! You just compiled and executed your first PureScript "
#~ "program."
#~ msgstr ""
#~ "おめでとうございます!　はじめてPureScriptで作成されたプログラムのコンパイ"
#~ "ルと実行ができました。"

#, fuzzy, no-wrap
#~ msgid "Compiling for the Browser"
#~ msgstr "ブラウザ向けのコンパイル"

#, fuzzy
#~ msgid ""
#~ "Pulp can be used to turn our PureScript code into Javascript suitable for "
#~ "use in the web browser, by using the `pulp browserify` command:"
#~ msgstr ""
#~ "Pulpは `pulp browserify`を実行して、PureScriptコードをブラウザで使うことに"
#~ "適したJavaScriptに変換することができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ pulp browserify\n"
#~ "\n"
#~ "* Browserifying project in ~/my-project\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "* Browserifying...\n"
#~ msgstr ""
#~ "$ pulp browserify\n"
#~ "\n"
#~ "* Browserifying project in ~/my-project\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "* Browserifying...\n"

#, fuzzy
#~ msgid ""
#~ "Following this, you should see a large amount of Javascript code printed "
#~ "to the console. This is the output of the [Browserify](http://browserify."
#~ "org/) tool, applied to a standard PureScript library called the "
#~ "_Prelude_, as well as the code in the `src` directory. This Javascript "
#~ "code can be saved to a file, and included in a HTML document. If you try "
#~ "this, you should see the words \"Hello, World!\" printed to your "
#~ "browser's console."
#~ msgstr ""
#~ "これに続いて、大量のJavaScriptコードがコンソールに表示されます。 これは"
#~ "[Browserify](http://browserify.org/)の出力で、**Prelude**と呼ばれる標準の"
#~ "PureScriptライブラリに加え、`src`ディレクトリのコードにも適用されます。こ"
#~ "のJavaScriptコードをファイルに保存し、HTML文書に含めることもできます。これ"
#~ "を試しに実行してみると、ブラウザのコンソールに\"Hello、World！\"という文章"
#~ "が出力されます。"

#, fuzzy, no-wrap
#~ msgid "Removing Unused Code"
#~ msgstr "使用されていないコードを取り除く"

#, fuzzy
#~ msgid ""
#~ "Pulp provides an alternative command, `pulp build`, which can be used "
#~ "with the `-O` option to apply _dead code elimination_, which removes "
#~ "unnecessary Javascript from the output. The result is much smaller:"
#~ msgstr ""
#~ "Pulpは代替コマンド `pulp build`を提供しています。 `-O`オプションで**未使用"
#~ "コードの削除**を適用すると、不要なJavaScriptを出力から取り除くことができま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ pulp build -O --to output.js\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "* Bundling Javascript...\n"
#~ "* Bundled.\n"
#~ msgstr ""
#~ "$ pulp build -O --to output.js\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "* Bundling Javascript...\n"
#~ "* Bundled.\n"

#, fuzzy
#~ msgid ""
#~ "Again, the generated code can be used in a HTML document. If you open "
#~ "`output.js`, you should see a few compiled modules which look like this:"
#~ msgstr ""
#~ "この場合も、生成されたコードはHTML文書で使用できます。 `output.js`を開く"
#~ "と、次のようなコンパイルされたモジュールがいくつか表示されます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "(function(exports) {\n"
#~ "  \"use strict\";\n"
#~ "\n"
#~ "  var Control_Monad_Eff_Console = PS[\"Control.Monad.Eff.Console\"];\n"
#~ "\n"
#~ "  var main = Control_Monad_Eff_Console.log(\"Hello, World!\");\n"
#~ "  exports[\"main\"] = main;\n"
#~ "})(PS[\"Main\"] = PS[\"Main\"] || {});\n"
#~ msgstr ""
#~ "(function(exports) {\n"
#~ "  \"use strict\";\n"
#~ "\n"
#~ "  var Control_Monad_Eff_Console = PS[\"Control.Monad.Eff.Console\"];\n"
#~ "\n"
#~ "  var main = Control_Monad_Eff_Console.log(\"Hello, World!\");\n"
#~ "  exports[\"main\"] = main;\n"
#~ "})(PS[\"Main\"] = PS[\"Main\"] || {});\n"

#, fuzzy
#~ msgid ""
#~ "This illustrates a few points about the way the PureScript compiler "
#~ "generates Javascript code:"
#~ msgstr ""
#~ "ここでPureScriptコンパイラがJavaScriptコードを生成する方法の要点が示されて"
#~ "います。"

#, fuzzy
#~ msgid ""
#~ "- Every module gets turned into an object, created by a wrapper function, "
#~ "which contains the module's exported members.  - PureScript tries to "
#~ "preserve the names of variables wherever possible - Function applications "
#~ "in PureScript get turned into function applications in JavaScript.  - The "
#~ "main method is run after all modules have been defined, and is generated "
#~ "as a simple method call with no arguments.  - PureScript code does not "
#~ "rely on any runtime libraries. All of the code that is generated by the "
#~ "compiler originated in a PureScript module somewhere which your code "
#~ "depended on."
#~ msgstr ""
#~ "- すべてのモジュールはオブジェクトに変換され、そのオブジェクトにはそのモ"
#~ "ジュールのエクスポートされたメンバが含まれています。モジュールは即時関数パ"
#~ "ターンによってスコープが限定されたコードで初期化されています。 - "
#~ "PureScriptは可能な限り変数の名前をそのまま使おうとします。 - PureScriptに"
#~ "おける関数適用は、そのままJavaScriptの関数適用に変換されます。 - 引数のな"
#~ "い単純な呼び出しとしてメインメソッド呼び出しが生成され、すべてのモジュール"
#~ "が定義された後に実行されます。 - PureScriptコードはどんな実行時ライブラリ"
#~ "にも依存しません。コンパイラによって生成されるすべてのコードは、あなたの"
#~ "コードが依存するいずれかのPureScriptモジュールをもとに出力されているもので"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "These points are important, since they mean that PureScript generates "
#~ "simple, understandable code. In fact, the code generation process in "
#~ "general is quite a shallow transformation. It takes relatively little "
#~ "understanding of the language to predict what JavaScript code will be "
#~ "generated for a particular input."
#~ msgstr ""
#~ "PureScriptはシンプルで理解しやすいコードを生成すること重視しているので、こ"
#~ "れらの点は大切です。実際に、ほとんどのコード生成処理はごく軽い変換です。"
#~ "PureScriptについての理解が比較的浅くても、ある入力からどのようなJavaScript"
#~ "コードが生成されるかを予測することは難しくありません。"

#, fuzzy, no-wrap
#~ msgid "Compiling CommonJS Modules"
#~ msgstr "CommonJSモジュールのコンパイル"

#, fuzzy
#~ msgid ""
#~ "Pulp can also be used to generate CommonJS modules from PureScript code. "
#~ "This can be useful when using NodeJS, or just when developing a larger "
#~ "project which uses CommonJS modules to break code into smaller components."
#~ msgstr ""
#~ "pulpは、PureScriptコードからCommonJSモジュールを生成するためにも使用できま"
#~ "す。 これは、NodeJSを使用する場合やCommonJSモジュールを使用してコードを小"
#~ "さなコンポーネントに分割する大きなプロジェクトを開発する場合に便利です。"

#, fuzzy
#~ msgid ""
#~ "To build CommonJS modules, use the `pulp build` command (without the `-O` "
#~ "option):"
#~ msgstr ""
#~ "CommonJSモジュールをビルドするには、（ `-O`オプションなしで） `pulp build`"
#~ "コマンドを使います。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ pulp build\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ msgstr ""
#~ "$ pulp build\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"

#, fuzzy
#~ msgid ""
#~ "The generated modules will be placed in the `output` directory by "
#~ "default. Each PureScript module will be compiled to its own CommonJS "
#~ "module, in its own subdirectory."
#~ msgstr ""
#~ "生成されたモジュールはデフォルトで `output`ディレクトリに置かれます。 各"
#~ "PureScriptモジュールは、それ自身のサブディレクトリにある独自のCommonJSモ"
#~ "ジュールにコンパイルされます。"

#, fuzzy, no-wrap
#~ msgid "Tracking Dependencies with Bower"
#~ msgstr "Bowerによる依存関係の追跡"

#, fuzzy
#~ msgid ""
#~ "To write the `diagonal` function (the goal of this chapter), we will need "
#~ "to be able to compute square roots. The `purescript-math` package "
#~ "contains type definitions for functions defined on the JavaScript `Math` "
#~ "object, so let's install it:"
#~ msgstr ""
#~ "この章の目的となっている `diagonal`関数を書くためには、平方根を計算できる"
#~ "ようにする必要があります。 `purescript-math`パッケージにはJavaScriptの "
#~ "`Math`オブジェクトのプロパティとして定義されている関数の型定義が含まれてい"
#~ "ますので、 `purescript-math`パッケージをインストールしてみましょう。 `npm`"
#~ "の依存関係でやったのと同じように、次のようにコマンドラインに入力すると直接"
#~ "このパッケージをダウンロードできます。"

#, fuzzy, no-wrap
#~ msgid "$ bower install purescript-math --save\n"
#~ msgstr "$ bower install purescript-math --save\n"

#, fuzzy
#~ msgid ""
#~ "The `--save` option causes the dependency to be added to the `bower.json` "
#~ "configuration file."
#~ msgstr ""
#~ "`--save`オプションは依存関係を `bower.json`設定ファイルに追加させます。"

#, fuzzy
#~ msgid ""
#~ "The `purescript-math` library sources should now be available in the "
#~ "`bower_components` subdirectory, and will be included when you compile "
#~ "your project."
#~ msgstr ""
#~ "`purescript-math`ライブラリは、依存するライブラリと一緒に "
#~ "`bower_components`サブディレクトリにインストールされます。"

#, fuzzy, no-wrap
#~ msgid "Computing Diagonals"
#~ msgstr "対角線の長さの計算"

#, fuzzy
#~ msgid ""
#~ "Let's write the `diagonal` function, which will be an example of using a "
#~ "function from an external library."
#~ msgstr ""
#~ "それでは外部ライブラリの関数を使用する例として `diagonal`関数を書いてみま"
#~ "しょう。"

#, fuzzy
#~ msgid ""
#~ "First, import the `Math` module by adding the following line at the top "
#~ "of the `src/Main.purs` file:"
#~ msgstr ""
#~ "まず、 `src/Main.purs`ファイルの先頭に次の行を追加し、 `Math`モジュールを"
#~ "インポートします。"

#, fuzzy, no-wrap
#~ msgid "import Math (sqrt)\n"
#~ msgstr "import Math (sqrt)\n"

#, fuzzy
#~ msgid ""
#~ "It's also necessary to import the `Prelude` module, which defines very "
#~ "basic operations such as numeric addition and multiplication:"
#~ msgstr ""
#~ "また、数値の加算や乗算のようなごく基本的な演算を定義する `Prelude`モジュー"
#~ "ルをインポートすることも必要です。"

#, fuzzy, no-wrap
#~ msgid "import Prelude\n"
#~ msgstr "import Prelude\n"

#, fuzzy
#~ msgid "Now define the `diagonal` function as follows:"
#~ msgstr "そして、次のように `diagonal`関数を定義します。"

#, fuzzy
#~ msgid ""
#~ "Note that there is no need to define a type for our function. The "
#~ "compiler is able to infer that `diagonal` is a function which takes two "
#~ "numbers and returns a number. In general, however, it is a good practice "
#~ "to provide type annotations as a form of documentation."
#~ msgstr ""
#~ "この関数の型を定義する必要はないことに注意してください。 `diagonal`は2つの"
#~ "数を取り数を返す関数である、とコンパイラは推論することができます。しかし、"
#~ "ドキュメントとしても役立つので、通常は型注釈を提供しておくことをお勧めしま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "Let's also modify the `main` function to use the new `diagonal` function:"
#~ msgstr ""
#~ "それでは、新しい `diagonal`関数を使うように `main`関数も変更してみましょ"
#~ "う。"

#, fuzzy, no-wrap
#~ msgid "main = logShow (diagonal 3.0 4.0)\n"
#~ msgstr "main = logShow (diagonal 3.0 4.0)\n"

#, fuzzy
#~ msgid "Now compile and run the project again, using `pulp run`:"
#~ msgstr "`pulp run`を使用して、モジュールを再コンパイルします。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ pulp run\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "5.0\n"
#~ msgstr ""
#~ "$ pulp run\n"
#~ "\n"
#~ "* Building project in ~/my-project\n"
#~ "* Build successful.\n"
#~ "5.0\n"

#, fuzzy, no-wrap
#~ msgid "Testing Code Using the Interactive Mode"
#~ msgstr "対話式処理系を使用したコードのテスト"

#, fuzzy
#~ msgid ""
#~ "The PureScript compiler also ships with an interactive REPL called PSCi. "
#~ "This can be very useful for testing your code, and experimenting with new "
#~ "ideas. Let's use PSCi to test the `diagonal` function."
#~ msgstr ""
#~ "PureScriptコンパイラには `PSCi`と呼ばれる対話式のREPL(Read-eval-print "
#~ "loop)が付属しています。 `PSCi`はコードをテストなど思いついたことを試すのに"
#~ "とても便利です。それでは、 `psci`を使って `diagonal`関数をテストしてみま"
#~ "しょう。"

#, fuzzy
#~ msgid ""
#~ "Pulp can load source modules into PSCi automatically, via the `pulp repl` "
#~ "command:"
#~ msgstr ""
#~ "`pulp repl`コマンドを使ってソースモジュールを自動的に `PSCi`にロードするこ"
#~ "とができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ pulp repl\n"
#~ ">\n"
#~ msgstr ""
#~ "$ pulp repl\n"
#~ ">\n"

#, fuzzy
#~ msgid "You can type `:?` to see a list of commands:"
#~ msgstr "コマンドの一覧を見るには、 `:?`と入力します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> :?\n"
#~ "The following commands are available:\n"
#~ "\n"
#~ "    :?                        Show this help menu\n"
#~ "    :quit                     Quit PSCi\n"
#~ "    :reset                    Reset\n"
#~ "    :browse      <module>     Browse <module>\n"
#~ "    :type        <expr>       Show the type of <expr>\n"
#~ "    :kind        <type>       Show the kind of <type>\n"
#~ "    :show        import       Show imported modules\n"
#~ "    :show        loaded       Show loaded modules\n"
#~ "    :paste       paste        Enter multiple lines, terminated by ^D\n"
#~ msgstr ""
#~ "> :?\n"
#~ "The following commands are available:\n"
#~ "\n"
#~ "    :?                        Show this help menu\n"
#~ "    :quit                     Quit PSCi\n"
#~ "    :reset                    Reset\n"
#~ "    :browse      <module>     Browse <module>\n"
#~ "    :type        <expr>       Show the type of <expr>\n"
#~ "    :kind        <type>       Show the kind of <type>\n"
#~ "    :show        import       Show imported modules\n"
#~ "    :show        loaded       Show loaded modules\n"
#~ "    :paste       paste        Enter multiple lines, terminated by ^D\n"

#, fuzzy
#~ msgid ""
#~ "By pressing the Tab key, you should be able to see a list of all "
#~ "functions available in your own code, as well as any Bower dependencies "
#~ "and the Prelude modules."
#~ msgstr ""
#~ "Tabキーを押すと、自分のコードで利用可能なすべての関数、及びBowerの依存関係"
#~ "とプレリュードモジュールのリストをすべて見ることができるはずです。"

#, fuzzy
#~ msgid "Start by importing the `Prelude` module:"
#~ msgstr "`Prelude`モジュールを読み込んでください。"

#, fuzzy, no-wrap
#~ msgid "> import Prelude\n"
#~ msgstr "> import Prelude\n"

#, fuzzy
#~ msgid "Try evaluating a few expressions now:"
#~ msgstr ""
#~ "幾つか数式を評価してみてください。 `PSCi`で評価を行うには、1行以上の式を入"
#~ "力し、Ctrl+ Dで入力を終了します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> 1 + 2\n"
#~ "3\n"
#~ "\n"
#~ "> \"Hello, \" <> \"World!\"\n"
#~ "\"Hello, World!\"\n"
#~ msgstr ""
#~ "> 1 + 2\n"
#~ "3\n"
#~ "\n"
#~ "> \"Hello, \" <> \"World!\"\n"
#~ "\"Hello, World!\"\n"

#, fuzzy
#~ msgid "Let's try out our new `diagonal` function in PSCi:"
#~ msgstr "それでは `PSCi`で `diagonal`関数を試してみましょう。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Main\n"
#~ "> diagonal 5.0 12.0\n"
#~ "\n"
#~ "13.0\n"
#~ msgstr ""
#~ "> import Main\n"
#~ "> diagonal 5.0 12.0\n"
#~ "\n"
#~ "13.0\n"

#, fuzzy
#~ msgid "You can also use PSCi to define functions:"
#~ msgstr "また、 `PSCi`で関数を定義することもできます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> double x = x * 2\n"
#~ "\n"
#~ "> double 10\n"
#~ "20\n"
#~ msgstr ""
#~ "> double x = x * 2\n"
#~ "\n"
#~ "> double 10\n"
#~ "20\n"

#, fuzzy
#~ msgid ""
#~ "Don't worry if the syntax of these examples is unclear right now - it "
#~ "will make more sense as you read through the book."
#~ msgstr ""
#~ "コード例の構文がまだよくわからなくても心配はいりません。 この本を読み進め"
#~ "るうちにわかるようになっていきます。"

#, fuzzy
#~ msgid ""
#~ "Finally, you can check the type of an expression by using the `:type` "
#~ "command:"
#~ msgstr "最後に、 `:type`コマンドを使うと式の型を確認することができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> :type true\n"
#~ "Boolean\n"
#~ "\n"
#~ "> :type [1, 2, 3]\n"
#~ "Array Int\n"
#~ msgstr ""
#~ "> :type true\n"
#~ "Boolean\n"
#~ "\n"
#~ "> :type [1, 2, 3]\n"
#~ "Array Int\n"

#, fuzzy
#~ msgid ""
#~ "Try out the interactive mode now. If you get stuck at any point, simply "
#~ "use the Reset command `:reset` to unload any modules which may be "
#~ "compiled in memory."
#~ msgstr ""
#~ "`PSCi`で試してみてください。もしどこかでつまずいた場合は、メモリ内にあるコ"
#~ "ンパイル済みのすべてのモジュールをアンロードするリセットコマンド `：reset`"
#~ "を使用してみてください。"

#, fuzzy
#~ msgid ""
#~ "(Medium) Use `bower install` to install the `purescript-globals` package "
#~ "as a dependency. Test out its functions in PSCi (_Hint_: you can use the "
#~ "`:browse` command in PSCi to browse the contents of a module)."
#~ msgstr ""
#~ "(やや難しい) `purescript-globals`パッケージを依存関係としてインストールす"
#~ "るには、`bower install`を使います。PSCiでその機能を試してみてください。 "
#~ "(**ヒント**： PSCiの `：browse`コマンドを使うと、モジュールの内容を閲覧す"
#~ "ることができます)"

#, fuzzy
#~ msgid ""
#~ "In this chapter, we set up a simple PureScript project using the Pulp "
#~ "tool."
#~ msgstr ""
#~ "この章では、Pulpツールを使用して簡単なPureScriptプロジェクトを設定しまし"
#~ "た。"

#, fuzzy
#~ msgid ""
#~ "We also wrote our first PureScript function, and a JavaScript program "
#~ "which could be compiled and executed either in the browser or in NodeJS."
#~ msgstr ""
#~ "また、最初のPureScript関数を書き、コンパイルし、NodeJSを使用して実行するこ"
#~ "とができました。"

#, fuzzy
#~ msgid ""
#~ "We will use this development setup in the following chapters to compile, "
#~ "debug and test our code, so you should make sure that you are comfortable "
#~ "with the tools and techniques involved."
#~ msgstr ""
#~ "以降の章では、コードをコンパイルやデバッグ、テストするためにこの開発設定を"
#~ "使用しますので、これらのツールや使用手順に十分習熟しておくとよいでしょう。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "module Data.AddressBook where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Plus (empty)\n"
#~ "import Data.List (List(..), filter, head)\n"
#~ "import Data.Maybe (Maybe)\n"
#~ msgstr ""
#~ "module Data.AddressBook where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Plus (empty)\n"
#~ "import Data.List (List(..), filter, head)\n"
#~ "import Data.Maybe (Maybe)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type Entry =\n"
#~ "  { firstName :: String\n"
#~ "  , lastName  :: String\n"
#~ "  , address   :: Address\n"
#~ "  }\n"
#~ msgstr "type Entry = { firstName :: String, lastName :: String, address :: Address }\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type Address =\n"
#~ "  { street :: String\n"
#~ "  , city   :: String\n"
#~ "  , state  :: String\n"
#~ "  }\n"
#~ msgstr "type Address = { street :: String, city :: String, state :: String }\n"

#, fuzzy, no-wrap
#~ msgid "type AddressBook = List Entry\n"
#~ msgstr "type AddressBook = List Entry\n"

#, fuzzy, no-wrap
#~ msgid "showEntry :: Entry -> String\n"
#~ msgstr "showEntry :: Entry -> String\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "showEntry entry = entry.lastName <> \", \" <>\n"
#~ "                  entry.firstName <> \": \" <>\n"
#~ "                  showAddress entry.address\n"
#~ msgstr ""
#~ "showEntry entry = entry.lastName <> \", \" <>\n"
#~ "                  entry.firstName <> \": \" <> \n"
#~ "                  showAddress entry.address\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "showAddress :: Address -> String\n"
#~ "showAddress addr = addr.street <> \", \" <>\n"
#~ "                   addr.city <> \", \" <>\n"
#~ "                   addr.state\n"
#~ msgstr ""
#~ "showAddress :: Address -> String\n"
#~ "showAddress addr = addr.street <> \", \" <>\n"
#~ "                   addr.city <> \", \" <>\n"
#~ "                   addr.state\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "emptyBook :: AddressBook\n"
#~ "emptyBook = empty\n"
#~ msgstr ""
#~ "emptyBook :: AddressBook\n"
#~ "emptyBook = empty\n"

#, fuzzy, no-wrap
#~ msgid "insertEntry :: Entry -> AddressBook -> AddressBook\n"
#~ msgstr "insertEntry :: Entry -> AddressBook -> AddressBook\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> :type insertEntry example emptyBook\n"
#~ "AddressBook\n"
#~ msgstr ""
#~ "> :type insertEntry example emptyBook\n"
#~ "AddressBook\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "insertEntry :: Entry -> AddressBook -> AddressBook\n"
#~ "insertEntry = Cons\n"
#~ msgstr ""
#~ "insertEntry :: Entry -> AddressBook -> AddressBook\n"
#~ "insertEntry = Cons\n"

#, fuzzy, no-wrap
#~ msgid "findEntry :: String -> String -> AddressBook -> Maybe Entry\n"
#~ msgstr "findEntry :: String -> String -> AddressBook -> Maybe Entry\n"

#, fuzzy
#~ msgid ""
#~ "In the code for `findEntry` above, we used a different form of function "
#~ "application: the `head` function was applied to the expression `filter "
#~ "filterEntry book` by using the infix `$` symbol."
#~ msgstr ""
#~ "上でみた `findEntry`のコードでは、少し異なる形式の関数適用が使用されていま"
#~ "す。 `head`関数は中置の `$`演算子を使って式 `filter filterEntry book`に適"
#~ "用されています。"

#, fuzzy
#~ msgid ""
#~ "This is equivalent to the usual application `head (filter filterEntry "
#~ "book)`"
#~ msgstr ""
#~ "これは `head (filter filterEntry book)`という通常の関数適用と同じ意味で"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "So `apply` takes a function and a value and applies the function to the "
#~ "value. The `infixr` keyword is used to define `($)` as an alias for "
#~ "`apply`."
#~ msgstr ""
#~ "ここで、 `apply`は関数と値をとり、その値にその関数を適用します。 `infixr`"
#~ "キーワードは `($)`を `apply`の別名として定義します。"

#, fuzzy
#~ msgid ""
#~ "But why would we want to use `$` instead of regular function application? "
#~ "The reason is that `$` is a right-associative, low precedence operator. "
#~ "This means that `$` allows us to remove sets of parentheses for deeply-"
#~ "nested applications."
#~ msgstr ""
#~ "しかし、なぜ通常の関数適用の代わりに `$`を使ったのでしょうか？　その理由"
#~ "は `$`は右結合で優先順位の低い演算子だということにあります。これは、深い入"
#~ "れ子になった関数適用のための括弧を、 `$`を使うと取り除くことができることを"
#~ "意味します。"

#, fuzzy
#~ msgid ""
#~ "For example, the following nested function application, which finds the "
#~ "street in the address of an employee's boss:"
#~ msgstr ""
#~ "たとえば、ある従業員の上司の住所がある道路を見つける、次の入れ子になった関"
#~ "数適用を考えてみましょう。"

#, fuzzy, no-wrap
#~ msgid "street (address (boss employee))\n"
#~ msgstr "street (address (boss employee))\n"

#, fuzzy
#~ msgid "becomes (arguably) easier to read when expressed using `$`:"
#~ msgstr "これは `$`を使用して表現すればずっと簡単になります。"

#, fuzzy, no-wrap
#~ msgid "street $ address $ boss employee\n"
#~ msgstr "street $ address $ boss employee\n"

#, fuzzy, no-wrap
#~ msgid "Tests, Tests, Tests ..."
#~ msgstr "テスト、テスト、テスト……"

#, fuzzy
#~ msgid ""
#~ "Now that we have the core of a working application, let's try it out "
#~ "using PSCi."
#~ msgstr ""
#~ "これでこのアプリケーションの中核部分が完成しましたので、 `PSCi`を使って試"
#~ "してみましょう。"

#, fuzzy
#~ msgid ""
#~ "Let's first try looking up an entry in the empty address book (we "
#~ "obviously expect this to return an empty result):"
#~ msgstr ""
#~ "まずは空の住所録から項目を検索してみましょう（これは明らかに空の結果が返っ"
#~ "てくることが期待されます）。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> findEntry \"John\" \"Smith\" emptyBook\n"
#~ "\n"
#~ "No type class instance was found for\n"
#~ "\n"
#~ "    Data.Show.Show { firstName :: String\n"
#~ "                   , lastName :: String\n"
#~ "                   , address :: { street :: String\n"
#~ "                                , city :: String\n"
#~ "                                , state :: String\n"
#~ "                                }\n"
#~ "                   }\n"
#~ msgstr ""
#~ "> findEntry \"John\" \"Smith\" emptyBook\n"
#~ "\n"
#~ "No type class instance was found for\n"
#~ "\n"
#~ "    Data.Show.Show { firstName :: String\n"
#~ "                   , lastName :: String\n"
#~ "                   , address :: { street :: String\n"
#~ "                                , city :: String\n"
#~ "                                , state :: String\n"
#~ "                                }\n"
#~ "                   }\n"

#, fuzzy
#~ msgid ""
#~ "An error! Not to worry, this error simply means that PSCi doesn't know "
#~ "how to print a value of type `Entry` as a String."
#~ msgstr ""
#~ "エラーです！でも心配しないでください。これは単に 型 `Entry`の値を文字列と"
#~ "して出力する方法を `PSCi`が知らないという意味のエラーです。"

#, fuzzy
#~ msgid ""
#~ "The return type of `findEntry` is `Maybe Entry`, which we can convert to "
#~ "a `String` by hand."
#~ msgstr ""
#~ "`findEntry`の返り値の型は `Maybe Entry`ですが、これは手作業で文字列に変換"
#~ "することができます。"

#, fuzzy
#~ msgid ""
#~ "Our `showEntry` function expects an argument of type `Entry`, but we have "
#~ "a value of type `Maybe Entry`. Remember that this means that the function "
#~ "returns an optional value of type `Entry`. What we need to do is apply "
#~ "the `showEntry` function if the optional value is present, and propagate "
#~ "the missing value if not."
#~ msgstr ""
#~ "`showEntry`関数は `Entry`型の引数を期待していますが、今あるのは `Maybe "
#~ "Entry`型の値です。この関数は `Entry`型のオプショナルな値を返すことを忘れな"
#~ "いでください。行う必要があるのは、オプショナルな値の中に項目の値が存在すれ"
#~ "ば `showEntry`関数を適用し、そうでなければ存在しないという値をそのまま伝播"
#~ "することです。"

#, fuzzy
#~ msgid ""
#~ "Fortunately, the Prelude module provides a way to do this. The `map` "
#~ "operator can be used to lift a function over an appropriate type "
#~ "constructor like `Maybe` (we'll see more on this function, and others "
#~ "like it, later in the book, when we talk about functors):"
#~ msgstr ""
#~ "幸いなことに、Preludeモジュールはこれを行う方法を提供しています。 `map`演"
#~ "算子は `Maybe`のような適切な型構築子まで関数を「持ち上げる」ことができます"
#~ "（この本の後半で関手について説明するときに、この関数やそれに類似する他のも"
#~ "のについて詳しく見ていきます）。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Prelude\n"
#~ "> map showEntry (findEntry \"John\" \"Smith\" emptyBook)\n"
#~ "\n"
#~ "Nothing\n"
#~ msgstr ""
#~ "> import Prelude\n"
#~ "> map showEntry (findEntry \"John\" \"Smith\" emptyBook)\n"
#~ "\n"
#~ "Nothing\n"

#, fuzzy
#~ msgid ""
#~ "That's better - the return value `Nothing` indicates that the optional "
#~ "return value does not contain a value - just as we expected."
#~ msgstr ""
#~ "今度はうまくいきました。この返り値 `Nothing`は、オプショナルな返り値に値が"
#~ "含まれていないことを示しています。期待していたとおりです。"

#, fuzzy
#~ msgid ""
#~ "For ease of use, we can create a function which prints an `Entry` as a "
#~ "String, so that we don't have to use `showEntry` every time:"
#~ msgstr ""
#~ "もっと使いやすくするために、 `Entry`を文字列として出力するような関数を定義"
#~ "し、毎回 `showEntry`を使わなくてもいいようにすることもできます。"

#, fuzzy, no-wrap
#~ msgid "> printEntry firstName lastName book = map showEntry (findEntry firstName lastName book)\n"
#~ msgstr ""
#~ "printEntry firstName lastName book\n"
#~ "  = map showEntry (findEntry firstName lastName book)\n"

#, fuzzy
#~ msgid ""
#~ "Now let's create a non-empty address book, and try again. We'll reuse our "
#~ "example entry from earlier:"
#~ msgstr ""
#~ "それでは空でない住所録を作成してもう一度試してみましょう。先ほどの項目の例"
#~ "を再利用します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> book1 = insertEntry entry emptyBook\n"
#~ "\n"
#~ "> printEntry \"John\" \"Smith\" book1\n"
#~ "\n"
#~ "Just (\"Smith, John: 123 Fake St., Faketown, CA\")\n"
#~ msgstr ""
#~ "> book1 = insertEntry entry emptyBook\n"
#~ "\n"
#~ "> printEntry \"John\" \"Smith\" book1\n"
#~ "\n"
#~ "Just (\"Smith, John: 123 Fake St., Faketown, CA\")\n"

#, fuzzy
#~ msgid ""
#~ "This time, the result contained the correct value. Try defining an "
#~ "address book `book2` with two names by inserting another name into "
#~ "`book1`, and look up each entry by name."
#~ msgstr ""
#~ "今度は結果が正しい値を含んでいました。 `book1`に別の名前で項目を挿入して、"
#~ "ふたつの名前がある住所録 `book2`を定義し、それぞれの項目を名前で検索してみ"
#~ "てください。"

#, fuzzy
#~ msgid ""
#~ "The source code for this chapter is contained in the two files `src/Data/"
#~ "Path.purs` and `src/FileOperations.purs`."
#~ msgstr ""
#~ "この章のソースコードには、`src/Data/Path.purs`と`src/FileOperations.purs`"
#~ "という２つのファイルが含まれています。"

#, fuzzy
#~ msgid ""
#~ "The `Data.Path` module contains a model of a virtual filesystem. You do "
#~ "not need to modify the contents of this module."
#~ msgstr ""
#~ "`Data.Path`モジュールには、仮想ファイルシステムが含まれています。このモ"
#~ "ジュールの内容を変更する必要はありません。"

#, fuzzy
#~ msgid ""
#~ "The `FileOperations` module contains functions which use the `Data.Path` "
#~ "API. Solutions to the exercises can be completed in this file."
#~ msgstr ""
#~ "`FileOperations`モジュールには、`Data.Path`APIを使用する関数が含まれていま"
#~ "す。演習への回答はこのファイルだけで完了することができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "fact :: Int -> Int\n"
#~ "fact 0 = 1\n"
#~ "fact n = n * fact (n - 1)\n"
#~ msgstr ""
#~ "fact :: Int -> Int\n"
#~ "fact 0 = 1\n"
#~ "fact n = n * fact (n - 1)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "fib :: Int -> Int\n"
#~ "fib 0 = 1\n"
#~ "fib 1 = 1\n"
#~ "fib n = fib (n - 1) + fib (n - 2)\n"
#~ msgstr ""
#~ "fib :: Int -> Int\n"
#~ "fib 0 = 1\n"
#~ "fib 1 = 1\n"
#~ "fib n = fib (n - 1) + fib (n - 2)\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Define an infix synonym `<$?>` for `filter`. Rewrite your answer "
#~ "to the previous question to use your new operator. Experiment with the "
#~ "precedence level and associativity of your operator in PSCi."
#~ msgstr ""
#~ "(やや難しい)`filter`関数と同じ意味の中置演算子`<$?>`を定義してみましょう。"
#~ "先ほどの演習の回答を、この新しい演算子を使用して書き換えてください。また、"
#~ "`PSCi`でこの演算子の優先順位と結合性を試してみてください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "factors :: Int -> Array (Array Int)\n"
#~ "factors n = filter (\\xs -> product xs == n) $ do\n"
#~ "  i <- 1 .. n\n"
#~ "  j <- i .. n\n"
#~ "  pure [i, j]\n"
#~ msgstr ""
#~ "factors :: Int -> Array (Array Int)\n"
#~ "factors n = filter (\\xs -> product xs == n) $ do\n"
#~ "  i <- 1 .. n\n"
#~ "  j <- i .. n\n"
#~ "  pure [i, j]\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "factors :: Int -> Array (Array Int)\n"
#~ "factors n = filter (\\xs -> product xs == n) $ do\n"
#~ "  i <- 1 .. n\n"
#~ "  j <- i .. n\n"
#~ "  [[i, j]]\n"
#~ msgstr ""
#~ "factors :: Int -> Array (Array Int)\n"
#~ "factors n = filter (\\xs -> product xs == n) $ do\n"
#~ "  i <- 1 .. n\n"
#~ "  j <- i .. n\n"
#~ "  [[i, j]]\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Control.MonadZero (guard)\n"
#~ "\n"
#~ "factors :: Int -> Array (Array Int)\n"
#~ "factors n = do\n"
#~ "  i <- 1 .. n\n"
#~ "  j <- i .. n\n"
#~ "  guard $ i * j == n\n"
#~ "  pure [i, j]\n"
#~ msgstr ""
#~ "import Control.MonadZero (guard)\n"
#~ "\n"
#~ "factors :: Int -> Array (Array Int)\n"
#~ "factors n = do\n"
#~ "  i <- 1 .. n\n"
#~ "  j <- i .. n\n"
#~ "  guard $ i * j == n\n"
#~ "  pure [i, j]\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) A _Pythagorean triple_ is an array of numbers `[a, b, c]` such "
#~ "that `aÂ² + bÂ² = cÂ²`. Use the `guard` function in an array "
#~ "comprehension to write a function `triples` which takes a number `n` and "
#~ "calculates all Pythagorean triples whose components are less than `n`. "
#~ "Your function should have type `Int -> Array (Array Int)`."
#~ msgstr ""
#~ "(やや難しい) **ピタゴラスの三つ組数**とは、`a² + b² = c²`を満たすような３"
#~ "つの数の配列`[a, b, c]`のことです。配列内包表記の中で`guard`関数を使用し"
#~ "て、数`n`を引数に取り、どの要素も`n`より小さいようなピタゴラスの三つ組数す"
#~ "べてを求める関数を書いてみましょう。その関数は`Int -> Array (Array Int)`と"
#~ "いう型を持っていなければなりません。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "fact :: Int -> Int -> Int\n"
#~ "fact 0 acc = acc\n"
#~ "fact n acc = fact (n - 1) (acc * n)\n"
#~ msgstr ""
#~ "fact :: Int -> Int -> Int\n"
#~ "fact 0 acc = acc\n"
#~ "fact n acc = fact (n - 1) (acc * n)\n"

#, fuzzy
#~ msgid ""
#~ "For example, consider this array recursion which reverses the input array "
#~ "by appending elements at the head of the input array to the end of the "
#~ "result."
#~ msgstr "たとえば、入力配列を逆順にする、この配列の再帰を考えてみましょう。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "reverse :: forall a. Array a -> Array a\n"
#~ "reverse [] = []\n"
#~ "reverse xs = snoc (reverse (unsafePartial tail xs))\n"
#~ "                  (unsafePartial head xs)\n"
#~ msgstr ""
#~ "reverse :: forall a. Array a -> Array a\n"
#~ "reverse [] = []\n"
#~ "reverse xs = snoc (reverse (unsafePartial tail xs))\n"
#~ "                  (unsafePartial head xs)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "reverse :: forall a. Array a -> Array a\n"
#~ "reverse = reverse' []\n"
#~ "  where\n"
#~ "    reverse' acc [] = acc\n"
#~ "    reverse' acc xs = reverse' (unsafePartial head xs : acc)\n"
#~ "                               (unsafePartial tail xs)\n"
#~ msgstr ""
#~ "reverse :: forall a. Array a -> Array a\n"
#~ "reverse = reverse' []\n"
#~ "  where\n"
#~ "    reverse' acc [] = acc\n"
#~ "    reverse' acc xs = reverse' (unsafePartial head xs : acc)\n"
#~ "                               (unsafePartial tail xs)\n"

#, fuzzy
#~ msgid ""
#~ "For example, the `reverse` example can be written as a fold in at least "
#~ "two ways. Here is a version which uses `foldr`:"
#~ msgstr ""
#~ "例えば、 先ほどの`reverse`の例は、畳み込みとして少なくとも2つの方法で書く"
#~ "ことができます。`foldr`を使用すると次のようになります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    ```haskell\n"
#~ "    import Prelude\n"
#~ "    import Data.Array.Partial (head, tail)\n"
#~ msgstr ""
#~ "    ```haskell\n"
#~ "    import Prelude\n"
#~ "    import Data.Array.Partial (head, tail)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    count :: forall a. (a -> Boolean) -> Array a -> Int\n"
#~ "    count _ [] = 0\n"
#~ "    count p xs = if p (unsafePartial head xs)\n"
#~ "                   then count p (unsafePartial tail xs) + 1\n"
#~ "                   else count p (unsafePartial tail xs)\n"
#~ "    ```\n"
#~ msgstr ""
#~ "    count :: forall a. (a -> Boolean) -> Array a -> Int\n"
#~ "    count _ [] = 0\n"
#~ "    count p xs = if p (unsafePartial head xs)\n"
#~ "                   then count p (unsafePartial tail xs) + 1\n"
#~ "                   else count p (unsafePartial tail xs)\n"
#~ "    ```\n"

#, fuzzy, no-wrap
#~ msgid "allFiles :: Path -> Array Path\n"
#~ msgstr "allFiles :: Path -> Array Path\n"

#, fuzzy, no-wrap
#~ msgid "allFiles file = file : concatMap allFiles (ls file)\n"
#~ msgstr "allFiles file = file : concatMap allFiles (ls file)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "allFiles' :: Path -> Array Path\n"
#~ "allFiles' file = file : do\n"
#~ "  child <- ls file\n"
#~ "  allFiles' child\n"
#~ msgstr ""
#~ "allFiles' :: Path -> Array Path\n"
#~ "allFiles' file = file : do\n"
#~ "  child <- ls file\n"
#~ "  allFiles' child\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Write a fold to determine the largest and smallest files in the "
#~ "filesystem."
#~ msgstr ""
#~ "(やや難しい) このファイルシステムで最大と最小のファイルを決定するような畳"
#~ "み込みを書いてください。"

#, fuzzy, no-wrap
#~ msgid "    _Hint_: Try to write this function as an array comprehension using do notation.\n"
#~ msgstr "    **ヒント**：do記法で配列内包表記を使用して、この関数を記述してみてください。\n"

#, fuzzy
#~ msgid ""
#~ "The project uses some Bower packages which we have already seen, and adds "
#~ "the following new dependencies:"
#~ msgstr ""
#~ "このプロジェクトでは、これまで見てきたBowerパッケージを引き続き使用します"
#~ "が、それに加えて次の新しい依存関係が追加されます。"

#, fuzzy
#~ msgid ""
#~ "- `purescript-globals`, which provides access to some common JavaScript "
#~ "values and functions.  - `purescript-math`, which provides access to the "
#~ "JavaScript `Math` module."
#~ msgstr ""
#~ "- `purescript-globals`: 一般的なJavaScriptの値や関数の取り扱いを可能にしま"
#~ "す。 - `purescript-math`: JavaScriptの `Math`オブジェクトの関数群を利用可"
#~ "能にします。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "module Data.Picture where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "import Data.Foldable (foldl)\n"
#~ msgstr ""
#~ "module Data.Picture where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "import Data.Foldable (foldl)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Global as Global\n"
#~ "import Math as Math\n"
#~ msgstr ""
#~ "import Global as Global\n"
#~ "import Math as Math\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "fromString :: String -> Boolean\n"
#~ "fromString \"true\" = true\n"
#~ "fromString _      = false\n"
#~ "\n"
#~ "toString :: Boolean -> String\n"
#~ "toString true  = \"true\"\n"
#~ "toString false = \"false\"\n"
#~ msgstr ""
#~ "fromString :: String -> Boolean\n"
#~ "fromString \"true\" = true\n"
#~ "fromString _      = false\n"
#~ "\n"
#~ "toString :: Boolean -> String\n"
#~ "toString true  = \"true\"\n"
#~ "toString false = \"false\"\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "gcd :: Int -> Int -> Int\n"
#~ "gcd n 0 = n\n"
#~ "gcd 0 n = n\n"
#~ "gcd n m | n > m     = gcd (n - m) m\n"
#~ "        | otherwise = gcd n (m - n)\n"
#~ msgstr ""
#~ "gcd :: Int -> Int -> Int\n"
#~ "gcd n 0 = n\n"
#~ "gcd 0 n = n\n"
#~ "gcd n m | n > m = gcd (n - m) m\n"
#~ "        | otherwise = gcd n (m - n)\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Look up _Pascal's Rule_ for computing binomial coefficients. Use "
#~ "it to write a function which computes binomial coefficients using pattern "
#~ "matching."
#~ msgstr ""
#~ "（やや難しい）二項係数を計算するための**パスカルの公式**(Pascal's Rule、パ"
#~ "スカルの三角形を参照のこと)について調べてみてください。パスカルの公式を利"
#~ "用し、パターン照合を使って二項係数を計算する関数を記述してください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "isEmpty :: forall a. Array a -> Boolean\n"
#~ "isEmpty [] = true\n"
#~ "isEmpty _ = false\n"
#~ msgstr ""
#~ "isEmpty :: forall a. Array a -> Boolean\n"
#~ "isEmpty [] = true\n"
#~ "isEmpty _ = false\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "takeFive :: Array Int -> Int\n"
#~ "takeFive [0, 1, a, b, _] = a * b\n"
#~ "takeFive _ = 0\n"
#~ msgstr ""
#~ "takeFive :: Array Int -> Int\n"
#~ "takeFive [0, 1, a, b, _] = a * b\n"
#~ "takeFive _ = 0\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "showPerson :: { first :: String, last :: String } -> String\n"
#~ "showPerson { first: x, last: y } = y <> \", \" <> x\n"
#~ msgstr ""
#~ "showPerson :: { first :: String, last :: String } -> String\n"
#~ "showPerson { first: x, last: y } = y <> \", \" <> x\n"

#, fuzzy
#~ msgid ""
#~ "We can read the new type signature of `showPerson` as \"takes any record "
#~ "with `first` and `last` fields which are `Strings` _and any other "
#~ "fields_, and returns a `String`\"."
#~ msgstr ""
#~ "`showPerson`の推論された型シグネチャは、 `String`であるような `first`と "
#~ "`last`というフィールドと、**それ以外の任意のフィールドを**持った任意のレ"
#~ "コードを引数に取り、 `String`を返す、というように読むことができます。"

#, fuzzy
#~ msgid ""
#~ "This function is polymorphic in the _row_ `r` of record fields, hence the "
#~ "name _row polymorphism_."
#~ msgstr ""
#~ "この関数はレコードフィールドの行 `r`について多相的なので、行多相と呼ばれる"
#~ "わけです。"

#, fuzzy
#~ msgid ""
#~ "We will see row polymorphism again later, when we discuss _extensible "
#~ "effects_."
#~ msgstr ""
#~ "後ほど**拡張可能作用**(Extensible effects)について議論するときに、再び行多"
#~ "相について見ていくことになります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type Address = { street :: String, city :: String }\n"
#~ "\n"
#~ "type Person = { name :: String, address :: Address }\n"
#~ "\n"
#~ "livesInLA :: Person -> Boolean\n"
#~ "livesInLA { address: { city: \"Los Angeles\" } } = true\n"
#~ "livesInLA _ = false\n"
#~ msgstr ""
#~ "type Address = { street :: String, city :: String }\n"
#~ "\n"
#~ "type Person = { name :: String, address :: Address }\n"
#~ "\n"
#~ "livesInLA :: Person -> Boolean\n"
#~ "livesInLA { address: { city: \"Los Angeles\" } } = true\n"
#~ "livesInLA _ = false\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "sortPair :: Array Int -> Array Int\n"
#~ "sortPair arr@[x, y]\n"
#~ "  | x <= y = arr\n"
#~ "  | otherwise = [y, x]\n"
#~ "sortPair arr = arr\n"
#~ msgstr ""
#~ "sortPair :: Array Int -> Array Int\n"
#~ "sortPair arr@[x, y]\n"
#~ "  | x <= y = arr\n"
#~ "  | otherwise = [y, x]\n"
#~ "sortPair arr = arr\n"

#, fuzzy
#~ msgid ""
#~ "This way, we save ourselves from allocating a new array if the pair is "
#~ "already sorted."
#~ msgstr ""
#~ "その結果、ペアがすでにソートされている場合は、新しい配列を複製する必要があ"
#~ "りません。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Data.Array.Partial (tail)\n"
#~ "import Partial.Unsafe (unsafePartial)\n"
#~ "\n"
#~ "lzs :: Array Int -> Array Int\n"
#~ "lzs [] = []\n"
#~ "lzs xs = case sum xs of\n"
#~ "           0 -> xs\n"
#~ "           _ -> lzs (unsafePartial tail xs)\n"
#~ msgstr ""
#~ "import Data.Array.Partial (tail)\n"
#~ "import Partial.Unsafe (unsafePartial)\n"
#~ "\n"
#~ "lzs :: Array Int -> Array Int\n"
#~ "lzs [] = []\n"
#~ "lzs xs = case sum xs of\n"
#~ "           0 -> xs\n"
#~ "           _ -> lzs (unsafePartial tail xs)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Partial.Unsafe (unsafePartial)\n"
#~ "\n"
#~ "partialFunction :: Boolean -> Boolean\n"
#~ "partialFunction = unsafePartial \\true -> true\n"
#~ msgstr ""
#~ "import Partial.Unsafe (unsafePartial)\n"
#~ "\n"
#~ "partialFunction :: Boolean -> Boolean\n"
#~ "partialFunction = unsafePartial \\true -> true\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "Redundant cases have been detected.\n"
#~ "The definition has the following redundant cases:\n"
#~ "\n"
#~ "  false\n"
#~ msgstr ""
#~ "Redundant cases have been detected.\n"
#~ "The definition has the following redundant cases:\n"
#~ "\n"
#~ "  false\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "data Shape\n"
#~ "  = Circle Point Number\n"
#~ "  | Rectangle Point Number Number\n"
#~ "  | Line Point Point\n"
#~ "  | Text Point String\n"
#~ msgstr ""
#~ "data Shape\n"
#~ "  = Circle Point Number\n"
#~ "  | Rectangle Point Number Number\n"
#~ "  | Line Point Point\n"
#~ "  | Text Point String\n"

#, fuzzy
#~ msgid ""
#~ "The `Point` type might also be defined as an algebraic data type, as "
#~ "follows:"
#~ msgstr "次のように `Point`型を代数的データ型として定義することもできます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "data Point = Point\n"
#~ "  { x :: Number\n"
#~ "  , y :: Number\n"
#~ "  }\n"
#~ msgstr ""
#~ "data Point = Point\n"
#~ "  { x :: Number\n"
#~ "  , y :: Number\n"
#~ "  }\n"

#, fuzzy
#~ msgid "The `Point` data type illustrates some interesting points:"
#~ msgstr "この `Point`データ型は、興味深い点をいくつか示しています。"

#, fuzzy
#~ msgid ""
#~ "- The data carried by an ADT's constructors doesn't have to be restricted "
#~ "to primitive types: constructors can include records, arrays, or even "
#~ "other ADTs.  - Even though ADTs are useful for describing data with "
#~ "multiple constructors, they can also be useful when there is only a "
#~ "single constructor.  - The constructors of an algebraic data type might "
#~ "have the same name as the ADT itself. This is quite common, and it is "
#~ "important not to confuse the `Point` _type constructor_ with the `Point` "
#~ "_data constructor_ - they live in different namespaces."
#~ msgstr ""
#~ "- 代数的データ型の構築子に格納されるデータは、プリミティブ型に限定されるわ"
#~ "けではありません。構築子はレコード、配列、あるいは他の代数的データ型を含め"
#~ "ることもできます。 - 代数的データ型は複数の構築子があるデータを記述するの"
#~ "に便利ですが、構築子がひとつだけのときでも便利です。 - 代数的データ型の構"
#~ "築子は、代数的データ型自身と同じ名前の場合もあります。これはごく一般的であ"
#~ "り、 `Point`**データ構築子**と `Point`**型構築子**を混同しないようにするこ"
#~ "とが大切です。これらは異なる名前空間にあります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "exampleLine :: Shape\n"
#~ "exampleLine = Line p1 p2\n"
#~ "  where\n"
#~ "    p1 :: Point\n"
#~ "    p1 = Point { x: 0.0, y: 0.0 }\n"
#~ "\n"
#~ "    p2 :: Point\n"
#~ "    p2 = Point { x: 100.0, y: 50.0 }\n"
#~ msgstr ""
#~ "exampleLine :: Shape\n"
#~ "exampleLine = Line p1 p2\n"
#~ "  where\n"
#~ "    p1 :: Point\n"
#~ "    p1 = Point { x: 0.0, y: 0.0 }\n"
#~ "\n"
#~ "    p2 :: Point\n"
#~ "    p2 = Point { x: 100.0, y: 50.0 }\n"

#, fuzzy
#~ msgid ""
#~ "To construct the points `p1` and `p2`, we apply the `Point` constructor "
#~ "to its single argument, which is a record."
#~ msgstr ""
#~ "`p1`及び `p2`を構築するため、レコードを引数として `Point`構築子を適用して"
#~ "います。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "showPoint :: Point -> String\n"
#~ "showPoint (Point { x: x, y: y }) =\n"
#~ "  \"(\" <> show x <> \", \" <> show y <> \")\"\n"
#~ "\n"
#~ "showShape :: Shape -> String\n"
#~ "showShape (Circle c r)      = ...\n"
#~ "showShape (Rectangle c w h) = ...\n"
#~ "showShape (Line start end)  = ...\n"
#~ "showShape (Text p text) = ...\n"
#~ msgstr ""
#~ "showPoint :: Point -> String\n"
#~ "showPoint (Point { x: x, y: y }) =\n"
#~ "  \"(\" <> show x <> \", \" <> show y <> \")\"\n"
#~ "\n"
#~ "showShape :: Shape -> String\n"
#~ "showShape (Circle c r)      = ...\n"
#~ "showShape (Rectangle c w h) = ...\n"
#~ "showShape (Line start end)  = ...\n"
#~ "showShape (Text p text) = ...\n"

#, fuzzy
#~ msgid ""
#~ "`showPoint` is another example of pattern matching. In this case, there "
#~ "is only a single case, but we use a nested pattern to match the fields of "
#~ "the record contained inside the `Point` constructor."
#~ msgstr ""
#~ "`showPoint`は、パターン照合の別の例にもなっています。 `showPoint`はひとつ"
#~ "の場合しかありませんが、 `Point`構築子の中に含まれたレコードのフィールドに"
#~ "適合する、入れ子になったパターンが使われています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "showPoint :: Point -> String\n"
#~ "showPoint (Point { x, y }) = ...\n"
#~ msgstr ""
#~ "showPoint :: Point -> String\n"
#~ "showPoint (Point { x, y }) = ...\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "origin :: Point\n"
#~ "origin = Point { x, y }\n"
#~ "  where\n"
#~ "    x = 0.0\n"
#~ "    y = 0.0\n"
#~ msgstr ""
#~ "origin :: Point\n"
#~ "origin = Point { x, y }\n"
#~ "  where\n"
#~ "    x = 0.0\n"
#~ "    y = 0.0\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "newtype Pixels = Pixels Number\n"
#~ "newtype Inches = Inches Number\n"
#~ msgstr ""
#~ "newtype Pixels = Pixels Number\n"
#~ "newtype Inches = Inches Number\n"

#, fuzzy
#~ msgid ""
#~ "This way, it is impossible to pass a value of type `Pixels` to a function "
#~ "which expects `Inches`, but there is no runtime performance overhead."
#~ msgstr ""
#~ "こうすると `Inches`を期待している関数に `Pixels`型の値を渡すことは不可能に"
#~ "なりますが、実行時の効率に余計な負荷が加わることはありません。"

#, fuzzy
#~ msgid ""
#~ "Newtypes will become important when we cover _type classes_ in the next "
#~ "chapter, since they allow us to attach different behavior to a type "
#~ "without changing its representation at runtime."
#~ msgstr ""
#~ "newtypeは次の章で**型クラス**を扱う際に重要になります。newtypeは実行時の表"
#~ "現を変更することなく型に異なる振る舞いを与えることを可能にするからです。"

#, fuzzy, no-wrap
#~ msgid "type Picture = Array Shape\n"
#~ msgstr "type Picture = Array Shape\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "showPicture :: Picture -> Array String\n"
#~ "showPicture = map showShape\n"
#~ msgstr ""
#~ "showPicture :: Picture -> Array String\n"
#~ "showPicture = map showShape\n"

#, fuzzy
#~ msgid ""
#~ "The `Bounds` data type defines a bounding rectangle. It is also defined "
#~ "as an algebraic data type with a single constructor:"
#~ msgstr ""
#~ "`Bounds`は外接矩形を定義するデータ型です。また、構築子をひとつだけ持つ代数"
#~ "的データ型として定義されています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "data Bounds = Bounds\n"
#~ "  { top    :: Number\n"
#~ "  , left   :: Number\n"
#~ "  , bottom :: Number\n"
#~ "  , right  :: Number\n"
#~ "  }\n"
#~ msgstr ""
#~ "data Bounds = Bounds\n"
#~ "  { top    :: Number\n"
#~ "  , left   :: Number\n"
#~ "  , bottom :: Number\n"
#~ "  , right  :: Number\n"
#~ "  }\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "bounds :: Picture -> Bounds\n"
#~ "bounds = foldl combine emptyBounds\n"
#~ "  where\n"
#~ "    combine :: Bounds -> Shape -> Bounds\n"
#~ "    combine b shape = union (shapeBounds shape) b\n"
#~ msgstr ""
#~ "bounds :: Picture -> Bounds\n"
#~ "bounds = foldl combine emptyBounds\n"
#~ "  where\n"
#~ "    combine :: Bounds -> Shape -> Bounds\n"
#~ "    combine b shape = union (shapeBounds shape) b\n"

#, fuzzy
#~ msgid ""
#~ "(Easy) Use the `showShape` function from the previous chapter to define a "
#~ "`Show` instance for the `Shape` type."
#~ msgstr ""
#~ "(簡単)前章の `showShape`関数を使って、 `Shape`型に対しての `Show`インスタ"
#~ "ンスを定義してみましょう。"

#, fuzzy, no-wrap
#~ msgid "    Define `Show` and `Eq` instances for `Complex`.\n"
#~ msgstr "    `Complex`について、 `Show`と `Eq`のインスタンスを定義してください。\n"

#, fuzzy, no-wrap
#~ msgid "Type Annotations"
#~ msgstr "型注釈"

#, fuzzy
#~ msgid ""
#~ "PureScript has another rule regarding type class instances, called the "
#~ "_overlapping instances rule_. Whenever a type class instance is required "
#~ "at a function call site, PureScript will use the information inferred by "
#~ "the type checker to choose the correct instance. At that time, there "
#~ "should be exactly one appropriate instance for that type. If there are "
#~ "multiple valid instances, the compiler will issue a warning."
#~ msgstr ""
#~ "PureScriptには型クラスのインスタンスに関する**重複インスタンス規則"
#~ "**(Overlapping instances rule)という規則があります。型クラスのインスタンス"
#~ "が関数呼び出しのところで必要とされるときはいつでも、PureScriptは正しいイン"
#~ "スタンスを選択するために型検証器によって推論された情報を使用します。そのと"
#~ "き、その型の適切なインスタンスがちょうどひとつだけ存在しなければなりませ"
#~ "ん。"

#, fuzzy
#~ msgid ""
#~ "To demonstrate this, we can try creating two conflicting type class "
#~ "instances for an example type. In the following code, we create two "
#~ "overlapping `Show` instances for the type `T`:"
#~ msgstr ""
#~ "これを実証するために、適当な型に対して2つの異なる型クラスのインスタンスを"
#~ "作成してみましょう。次のコードでは、型 `T`の2つの重複する `Show`インスタン"
#~ "スを作成しています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "module Overlapped where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "\n"
#~ "data T = T\n"
#~ "\n"
#~ "instance showT1 :: Show T where\n"
#~ "  show _ = \"Instance 1\"\n"
#~ "\n"
#~ "instance showT2 :: Show T where\n"
#~ "  show _ = \"Instance 2\"\n"
#~ msgstr ""
#~ "module Overlapped where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "\n"
#~ "data T = T\n"
#~ "\n"
#~ "instance showT1 :: Show T where\n"
#~ "  show _ = \"Instance 1\"\n"
#~ "  \n"
#~ "instance showT2 :: Show T where\n"
#~ "  show _ = \"Instance 2\"\n"

#, fuzzy
#~ msgid ""
#~ "This module will compile with no warnings. However, if we _use_ `show` at "
#~ "type `T` (requiring the compiler to to find a `Show` instance), the "
#~ "overlapping instances rule will be enforced, resulting in a warning:"
#~ msgstr ""
#~ "このモジュールはエラーなくコンパイルされます。 `PSCi`を起動し、型 `T`の "
#~ "`Show`インスタンスを見つけようとすると、重複インスタンス規則が適用され、エ"
#~ "ラーになります。"

#, fuzzy, no-wrap
#~ msgid "Overlapping instances found for Prelude.Show T\n"
#~ msgstr "Overlapping instances found for Prelude.Show T\n"

#, fuzzy
#~ msgid ""
#~ "The overlapping instances rule is enforced so that automatic selection of "
#~ "type class instances is a predictable process. If we allowed two type "
#~ "class instances for a type to exist, then either could be chosen "
#~ "depending on the order of module imports, and that could lead to "
#~ "unpredictable behavior of the program at runtime, which is undesirable."
#~ msgstr ""
#~ "重複インスタンスルールが適用されるのは、型クラスのインスタンスの自動選択が"
#~ "予測可能な処理であるようにするためです。もし型に対してふたつの型クラスイン"
#~ "スタンスを許し、モジュールインポートの順序に従ってどちらかを選ぶようにする"
#~ "と、実行時のプログラムの振る舞いが予測できなくなってしまい好ましくありませ"
#~ "ん。"

#, fuzzy
#~ msgid ""
#~ "If it is truly the case that there are two valid type class instances for "
#~ "a type, satisfying the appropriate laws, then a common approach is to "
#~ "define newtypes which wrap the existing type. Since different newtypes "
#~ "are allowed to have different type class instances under the overlapping "
#~ "instances rule, there is no longer an issue. This approach is taken in "
#~ "PureScript's standard libraries, for example in `purescript-maybe`, where "
#~ "the `Maybe a` type has multiple valid instances for the `Monoid` type "
#~ "class."
#~ msgstr ""
#~ "適切な法則を満たすふたつ妥当な型クラスインスタンスが存在しうるなら、既存の"
#~ "型を包むnewtypeを定義するのが一般的な方法です。重複インスタンスのルールの"
#~ "下でも、異なるnewtypeなら異なる型クラスインスタンスを持つことが許されるの"
#~ "で、問題はなくなります。この手法はPureScriptの標準ライブラリでも使われてお"
#~ "り、例えば `purescript-monoid`では、 `Maybe a`型は `Monoid`型クラスの妥当"
#~ "なインスタンスを複数持っています。"

#, fuzzy, no-wrap
#~ msgid "   data NonEmpty a = NonEmpty a (Array a)\n"
#~ msgstr "   data NonEmpty a = NonEmpty a (Array a)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "   Write an `Eq` instance for the type `NonEmpty a` which reuses the instances for `Eq a` and `Eq (Array a)`.\n"
#~ "1. (Medium) Write a `Semigroup` instance for `NonEmpty a` by reusing the `Semigroup` instance for `Array`.\n"
#~ "1. (Medium) Write a `Functor` instance for `NonEmpty`.\n"
#~ "1. (Medium) Given any type `a` with an instance of `Ord`, we can add a new \"infinite\" value which is greater than any other value:\n"
#~ msgstr ""
#~ "   `Eq a`と `Eq (Array a)`のインスタンスを再利用して、型 `NonEmpty a`に対する `Eq`インスタンスを書いてみましょう。    \n"
#~ "1. (やや難しい)`Semigroup`インスタンスを `Array`に再利用して `NonEmpty a`の `Semigroup`インスタンスを作成しましょう。\n"
#~ "1. (やや難しい)`NonEmpty`の `Functor`インスタンスを書いてみましょう。\n"
#~ "1. (やや難しい)`Ord`のインスタンスを持つ型 `a`があれば、他の値より大きい新しい **無限**の値を追加することができます。\n"

#, fuzzy, no-wrap
#~ msgid "   data Extended a = Finite a | Infinite\n"
#~ msgstr "   data Extended a = Finite a | Infinite\n"

#, fuzzy, no-wrap
#~ msgid "   data OneMore f a = OneMore a (f a)\n"
#~ msgstr "   data OneMore f a = OneMore a (f a)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "   instance foldableOneMore :: Foldable f => Foldable (OneMore f) where\n"
#~ "     ...\n"
#~ msgstr "   instance foldableOneMore :: Foldable f => Foldable (OneMore f) where\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "   class Monoid m <= Action m a where\n"
#~ "     act :: m -> a -> a\n"
#~ msgstr ""
#~ "   class Monoid m <= Action m a where\n"
#~ "     act :: m -> a -> a\n"

#, fuzzy, no-wrap
#~ msgid "   That is, the action respects the operations defined by the `Monoid` class.\n"
#~ msgstr "   この動作は `Monoid`クラスによって定義された操作を順守します。\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "   newtype Multiply = Multiply Int\n"
#~ "\n"
#~ "   instance semigroupMultiply :: Semigroup Multiply where\n"
#~ "     append (Multiply n) (Multiply m) = Multiply (n * m)\n"
#~ "\n"
#~ "   instance monoidMultiply :: Monoid Multiply where\n"
#~ "     mempty = Multiply 1\n"
#~ msgstr ""
#~ "   newtype Multiply = Multiply Int\n"
#~ "\n"
#~ "   instance semigroupMultiply :: Semigroup Multiply where\n"
#~ "     append (Multiply n) (Multiply m) = Multiply (n * m)\n"
#~ "\n"
#~ "   instance monoidMultiply :: Monoid Multiply where\n"
#~ "     mempty = Multiply 1\n"

#, fuzzy, no-wrap
#~ msgid "   This monoid acts on strings by repeating an input string some number of times. Write an instance which implements this action:\n"
#~ msgstr "   このモノイドは、文字列の何度かの繰り返しとして文字列に対して動作します。このアクションを実装するインスタンスを作成します。\n"

#, fuzzy, no-wrap
#~ msgid "   instance repeatAction :: Action Multiply String\n"
#~ msgstr "   instance repeatAction :: Action Multiply String\n"

#, fuzzy, no-wrap
#~ msgid "   newtype Self m = Self m\n"
#~ msgstr "   newtype Self m = Self m\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "newtype HashCode = HashCode Int\n"
#~ "\n"
#~ "hashCode :: Int -> HashCode\n"
#~ "hashCode h = HashCode (h `mod` 65535)\n"
#~ "\n"
#~ "class Eq a <= Hashable a where\n"
#~ "  hash :: a -> HashCode\n"
#~ msgstr ""
#~ "newtype HashCode = HashCode Int\n"
#~ "\n"
#~ "hashCode :: Int -> HashCode\n"
#~ "hashCode h = HashCode (h `mod` 65535)\n"
#~ "\n"
#~ "class Eq a <= Hashable a where\n"
#~ "  hash :: a -> HashCode\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "combineHashes :: HashCode -> HashCode -> HashCode\n"
#~ "combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)\n"
#~ msgstr ""
#~ "combineHashes :: HashCode -> HashCode -> HashCode\n"
#~ "combineHashes (HashCode h1) (HashCode h2) = hashCode (73 * h1 + 51 * h2)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "hashEqual :: forall a. Hashable a => a -> a -> Boolean\n"
#~ "hashEqual = eq `on` hash\n"
#~ msgstr ""
#~ "hashEqual :: forall a. Hashable a => a -> a -> Boolean\n"
#~ "hashEqual = eq `on` hash\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "instance hashInt :: Hashable Int where\n"
#~ "  hash = hashCode\n"
#~ msgstr ""
#~ "instance hashInt :: Hashable Int where\n"
#~ "  hash = hashCode\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "instance hashBoolean :: Hashable Boolean where\n"
#~ "  hash false = hashCode 0\n"
#~ "  hash true  = hashCode 1\n"
#~ msgstr ""
#~ "instance hashBoolean :: Hashable Boolean where\n"
#~ "  hash false = hashCode 0\n"
#~ "  hash true  = hashCode 1\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "instance hashChar :: Hashable Char where\n"
#~ "  hash = hash <<< toCharCode\n"
#~ msgstr ""
#~ "instance hashChar :: Hashable Char where\n"
#~ "  hash = hash <<< toCharCode\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "instance hashArray :: Hashable a => Hashable (Array a) where\n"
#~ "  hash = foldl combineHashes (hashCode 0) <<< map hash\n"
#~ msgstr ""
#~ "instance hashArray :: Hashable a => Hashable (Array a) where\n"
#~ "  hash = foldl combineHashes (hashCode 0) <<< map hash\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "instance hashString :: Hashable String where\n"
#~ "  hash = hash <<< toCharArray\n"
#~ msgstr ""
#~ "instance hashString :: Hashable String where\n"
#~ "  hash = hash <<< toCharArray\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "   newtype Hour = Hour Int\n"
#~ "\n"
#~ "   instance eqHour :: Eq Hour where\n"
#~ "     eq (Hour n) (Hour m) = mod n 12 == mod m 12\n"
#~ msgstr ""
#~ "   newtype Hour = Hour Int\n"
#~ "\n"
#~ "   instance eqHour :: Eq Hour where\n"
#~ "     eq (Hour n) (Hour m) = mod n 12 == mod m 12\n"

#, fuzzy
#~ msgid ""
#~ "(Difficult) Prove the type class laws for the `Hashable` instances for "
#~ "`Maybe`, `Either` and `Tuple`."
#~ msgstr ""
#~ "(難しい)`Maybe`、 `Either`、 `Tuple`の `Hashable`インスタンスが型クラスの"
#~ "法則を満たしていることを証明してください。"

#, fuzzy
#~ msgid ""
#~ "(Easy) Use `lift2` to write lifted versions of the numeric operators `+`, "
#~ "`-`, `*` and `/` which work with optional arguments."
#~ msgstr ""
#~ "(簡単)`lift2`を使って、オプショナルな引数に対して働く、数に対する演算子`"
#~ "+`、`-`、`*`、`/`の持ち上げられたバージョンを書いてください。"

#, fuzzy
#~ msgid ""
#~ "(Medium) Convince yourself that the definition of `lift3` given above in "
#~ "terms of `<$>` and `<*>` does type check."
#~ msgstr ""
#~ "(やや難しい) 上で与えられた`lift3`の定義について、`<$>`と`<*>`の型が整合し"
#~ "ていることを確認して下さい。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "address :: String -> String -> String -> Address\n"
#~ "\n"
#~ "phoneNumber :: PhoneType -> String -> PhoneNumber\n"
#~ "\n"
#~ "person :: String -> String -> Address -> Array PhoneNumber -> Person\n"
#~ msgstr ""
#~ "address :: String -> String -> String -> Address\n"
#~ "\n"
#~ "phoneNumber :: PhoneType -> String -> PhoneNumber\n"
#~ "\n"
#~ "person :: String -> String -> Address -> Array PhoneNumber -> Person\n"

#, fuzzy, no-wrap
#~ msgid "data PhoneType = HomePhone | WorkPhone | CellPhone | OtherPhone\n"
#~ msgstr "data PhoneType = HomePhone | WorkPhone | CellPhone | OtherPhone\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "examplePerson :: Person\n"
#~ "examplePerson =\n"
#~ "  person \"John\" \"Smith\"\n"
#~ "         (address \"123 Fake St.\" \"FakeTown\" \"CA\")\n"
#~ "  \t     [ phoneNumber HomePhone \"555-555-5555\"\n"
#~ "         , phoneNumber CellPhone \"555-555-0000\"\n"
#~ "  \t     ]\n"
#~ msgstr ""
#~ "examplePerson :: Person\n"
#~ "examplePerson =\n"
#~ "  person \"John\" \"Smith\"\n"
#~ "         (address \"123 Fake St.\" \"FakeTown\" \"CA\")\n"
#~ "                [ phoneNumber HomePhone \"555-555-5555\"\n"
#~ "                , phoneNumber CellPhone \"555-555-0000\"\n"
#~ "                ]\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "nonEmpty :: String -> Either String Unit\n"
#~ "nonEmpty \"\" = Left \"Field cannot be empty\"\n"
#~ "nonEmpty _  = Right unit\n"
#~ "\n"
#~ "validatePerson :: Person -> Either String Person\n"
#~ "validatePerson (Person o) =\n"
#~ "  person <$> (nonEmpty o.firstName *> pure o.firstName)\n"
#~ "         <*> (nonEmpty o.lastName  *> pure o.lastName)\n"
#~ "         <*> pure o.address\n"
#~ "         <*> pure o.phones\n"
#~ msgstr ""
#~ "nonEmpty :: String -> Either String Unit\n"
#~ "nonEmpty \"\" = Left \"Field cannot be empty\"\n"
#~ "nonEmpty _ = Right unit\n"
#~ "\n"
#~ "validatePerson :: Person -> Either String Person\n"
#~ "validatePerson (Person o) =\n"
#~ "  person <$> (nonEmpty o.firstName *> pure o.firstName)\n"
#~ "         <*> (nonEmpty o.lastName *> pure o.lastName)\n"
#~ "         <*> pure o.address\n"
#~ "         <*> pure o.phones\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type Errors = Array String\n"
#~ "\n"
#~ "nonEmpty :: String -> String -> V Errors Unit\n"
#~ "nonEmpty field \"\" = invalid [\"Field '\" <> field <> \"' cannot be empty\"]\n"
#~ "nonEmpty _     _  = pure unit\n"
#~ "\n"
#~ "lengthIs :: String -> Number -> String -> V Errors Unit\n"
#~ "lengthIs field len value | S.length value /= len =\n"
#~ "  invalid [\"Field '\" <> field <> \"' must have length \" <> show len]\n"
#~ "lengthIs _     _   _     =\n"
#~ "  pure unit\n"
#~ "\n"
#~ "validateAddress :: Address -> V Errors Address\n"
#~ "validateAddress (Address o) =\n"
#~ "  address <$> (nonEmpty \"Street\" o.street *> pure o.street)\n"
#~ "          <*> (nonEmpty \"City\"   o.city   *> pure o.city)\n"
#~ "          <*> (lengthIs \"State\" 2 o.state *> pure o.state)\n"
#~ msgstr ""
#~ "type Errors = Array String\n"
#~ "\n"
#~ "nonEmpty :: String -> String -> V Errors Unit\n"
#~ "nonEmpty field \"\" = invalid [\"Field '\" <> field <> \"' cannot be empty\"]\n"
#~ "nonEmpty _     _  = pure unit\n"
#~ "\n"
#~ "lengthIs :: String -> Number -> String -> V Errors Unit\n"
#~ "lengthIs field len value | S.length value /= len =\n"
#~ "  invalid [\"Field '\" <> field <> \"' must have length \" <> show len]\n"
#~ "lengthIs _ _ _ =\n"
#~ "  pure unit\n"
#~ "\n"
#~ "validateAddress :: Address -> V Errors Address\n"
#~ "validateAddress (Address o) =\n"
#~ "  address <$> (nonEmpty \"Street\" o.street  *> pure o.street)\n"
#~ "          <*> (nonEmpty \"City\"   o.city    *> pure o.city)\n"
#~ "          <*> (lengthIs \"State\"  2 o.state *> pure o.state)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "matches :: String -> R.Regex -> String -> V Errors Unit\n"
#~ "matches _     regex value | R.test regex value =\n"
#~ "  pure unit\n"
#~ "matches field _     _     =\n"
#~ "  invalid [\"Field '\" <> field <> \"' did not match the required format\"]\n"
#~ msgstr ""
#~ "matches :: String -> R.Regex -> String -> V Errors Unit\n"
#~ "matches _ regex value | R.test regex value =\n"
#~ "  pure unit\n"
#~ "matches field _ _ =\n"
#~ "  invalid [\"Field '\" <> field <> \"' did not match the required format\"]\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "validatePhoneNumber :: PhoneNumber -> V Errors PhoneNumber\n"
#~ "validatePhoneNumber (PhoneNumber o) =\n"
#~ "  phoneNumber <$> pure o.\"type\"\n"
#~ "              <*> (matches \"Number\" phoneNumberRegex o.number *> pure o.number)\n"
#~ msgstr ""
#~ "validatePhoneNumber :: PhoneNumber -> V Errors PhoneNumber\n"
#~ "validatePhoneNumber (PhoneNumber o) =\n"
#~ "  phoneNumber <$> pure o.\"type\"\n"
#~ "              <*> (matches \"Number\" phoneNumberRegex o.number *> pure o.number)\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Using the `matches` validator, write a validation function which "
#~ "checks that a string is not entirely whitespace. Use it to replace "
#~ "`nonEmpty` where appropriate."
#~ msgstr ""
#~ "(やや難しい)`matches`検証器を使って、文字列に全く空白が含まれないことを検"
#~ "証する検証関数を​​書いてください。この関数を使って、適切な場合に`nonEmpty`を"
#~ "置き換えてください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "arrayNonEmpty :: forall a. String -> Array a -> V Errors Unit\n"
#~ "arrayNonEmpty field [] =\n"
#~ "  invalid [\"Field '\" <> field <> \"' must contain at least one value\"]\n"
#~ "arrayNonEmpty _     _  =\n"
#~ "  pure unit\n"
#~ "\n"
#~ "validatePerson :: Person -> V Errors Person\n"
#~ "validatePerson (Person o) =\n"
#~ "  person <$> (nonEmpty \"First Name\" o.firstName *>\n"
#~ "              pure o.firstName)\n"
#~ "         <*> (nonEmpty \"Last Name\"  o.lastName  *>\n"
#~ "              pure o.lastName)\n"
#~ "\t       <*> validateAddress o.address\n"
#~ "         <*> (arrayNonEmpty \"Phone Numbers\" o.phones *>\n"
#~ "              traverse validatePhoneNumber o.phones)\n"
#~ msgstr ""
#~ "arrayNonEmpty :: forall a. String -> Array a -> V Errors Unit\n"
#~ "arrayNonEmpty field [] =\n"
#~ "  invalid [\"Field '\" <> field <> \"' must contain at least one value\"]\n"
#~ "arrayNonEmpty _ _ =\n"
#~ "  pure unit\n"
#~ "\n"
#~ "validatePerson :: Person -> V Errors Person\n"
#~ "validatePerson (Person o) =\n"
#~ "  person <$> (nonEmpty \"First Name\" o.firstName *>\n"
#~ "              pure o.firstName)\n"
#~ "         <*> (nonEmpty \"Last Name\" o.lastName *>\n"
#~ "              pure o.lastName)\n"
#~ "               <*> validateAddress o.address\n"
#~ "         <*> (arrayNonEmpty \"Phone Numbers\" o.phones *>\n"
#~ "              traverse validatePhoneNumber o.phones)\n"

#, fuzzy
#~ msgid ""
#~ "There is one more interesting function here, which we haven't seen yet - "
#~ "`traverse`, which appears in the final line."
#~ msgstr ""
#~ "ここに今まで見たことのない興味深い関数がひとつあります。最後の行で使われて"
#~ "いる`traverse`です。"

#, fuzzy
#~ msgid ""
#~ "(Medium) Write a `Traversable` instance for the following binary tree "
#~ "data structure, which combines side-effects from left-to-right:"
#~ msgstr ""
#~ "(やや難しい) 左から右へと副作用を連鎖させる、次のような二分木データ構造に"
#~ "ついての`Traversable`インスタンスを書いてください。"

#, fuzzy, no-wrap
#~ msgid "   data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"
#~ msgstr "   data Tree a = Leaf | Branch (Tree a) a (Tree a)\n"

#, fuzzy, no-wrap
#~ msgid "   This corresponds to an in-order traversal of the tree. What about a preorder traversal? What about reverse order?\n"
#~ msgstr "   これは木の走査の順序に対応しています。行きがけ順の走査についてはどうでしょうか。帰りがけ順では？\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Modify the code to make the `address` field of the `Person` type "
#~ "optional using `Data.Maybe`. _Hint_: Use `traverse` to validate a field "
#~ "of type `Maybe a`."
#~ msgstr ""
#~ "(やや難しい)`Data.Maybe`を使って`Person`の`address`フィールドを省略可能に"
#~ "なるようにコードを変更してください。**ヒント**：`traverse`を使って型"
#~ "`Maybe a`のフィールドを検証してみましょう。"

#, fuzzy
#~ msgid ""
#~ "The goal of this chapter is to explain why monads are a useful "
#~ "abstraction, and their connection with _do notation_. We will build upon "
#~ "the address book example of the previous chapters, by using a particular "
#~ "monad to handle the side-effects of building a user interface in the "
#~ "browser. The monad we will use is an important monad in PureScript - the "
#~ "`Eff` monad - used to encapsulate so-called _native_ effects."
#~ msgstr ""
#~ "この章の目的は、なぜモナドが便利な抽象化なのか、**do記法**とどう関係するの"
#~ "かについて説明することです。ブラウザでユーザインターフェイスを構築する副作"
#~ "用を扱うためのある種のモナドを使って、前の章の住所録の例を作ることにしま"
#~ "しょう。これから扱うEffモナドは、PureScriptにおけるとても重要なモナドで"
#~ "す。Effモナドはいわゆる**ネイティブな**作用をカプセル化するのに使われま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "The source code for this project builds on the source for the previous "
#~ "chapter. The modules from the previous project are included in the `src` "
#~ "directory for this project."
#~ msgstr ""
#~ "このプロジェクトのソースコードは前の章のソースコードの上に構築しますが、以"
#~ "前のプロジェクトのモジュールは、このプロジェクトの `src`ディレクトリに含ま"
#~ "れています。"

#, fuzzy
#~ msgid ""
#~ "- `purescript-eff`, which defines the `Eff` monad, the subject of the "
#~ "second half of the chapter.  - `purescript-react`, a set of bindings to "
#~ "the React user interface library, which we will use to build a user "
#~ "interface for our address book application."
#~ msgstr ""
#~ "- `purescript-eff` - Effモナドを提供します。 - `purescript-react` - React"
#~ "ユーザインターフェイスへ接続するライブラリを提供します。"

#, fuzzy
#~ msgid ""
#~ "In addition to the modules from the previous chapter, this chapter's "
#~ "project adds a `Main` module, which provides the entry point to the "
#~ "application, and functions to render the user interface."
#~ msgstr ""
#~ "前章のモジュールに加えて、この章では`Main`モジュールを使用します。このモ"
#~ "ジュールはエントリポイントであるとともに、UIの描写も行います。"

#, fuzzy
#~ msgid ""
#~ "To compile this project, first install React using `npm install`, and "
#~ "then build and bundle the JavaScript source with `pulp browserify --to "
#~ "dist/Main.js`. To run the project, open the `html/index.html` file in "
#~ "your web browser."
#~ msgstr ""
#~ "このプロジェクトをコンパイルするには、まずReactをインストールするため`npm "
#~ "install`を実行し、それから`pulp browserify --to dist/Main.js`でビルドを行"
#~ "います。このプロジェクトを実行するには、`html/index.html`ファイルをウェブ"
#~ "ブラウザで開いてください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Plus (empty)\n"
#~ "import Data.Array ((..))\n"
#~ "\n"
#~ "countThrows :: Int -> Array (Array Int)\n"
#~ "countThrows n = do\n"
#~ "  x <- 1 .. 6\n"
#~ "  y <- 1 .. 6\n"
#~ "  if x + y == n\n"
#~ "    then pure [x, y]\n"
#~ "    else empty\n"
#~ msgstr ""
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Plus (empty)\n"
#~ "import Data.Array ((..))\n"
#~ "\n"
#~ "countThrows :: Int -> Array (Array Int)\n"
#~ "countThrows n = do\n"
#~ "  x <- 1 .. 6\n"
#~ "  y <- 1 .. 6\n"
#~ "  if x + y == n\n"
#~ "    then pure [x, y]\n"
#~ "    else empty\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "foldl :: forall a b\n"
#~ "       . (a -> b -> a)\n"
#~ "      -> a\n"
#~ "      -> List b\n"
#~ "      -> a\n"
#~ msgstr ""
#~ "foldl :: forall a b\n"
#~ "       . (a -> b -> a)\n"
#~ "      -> a\n"
#~ "      -> List b\n"
#~ "      -> a\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "safeDivide :: Int -> Int -> Maybe Int\n"
#~ "safeDivide _ 0 = Nothing\n"
#~ "safeDivide a b = Just (a / b)\n"
#~ msgstr ""
#~ "safeDivide :: Int -> Int -> Maybe Int\n"
#~ "safeDivide _ 0 = Nothing\n"
#~ "safeDivide a b = Just (a / b)\n"

#, fuzzy
#~ msgid ""
#~ "(Easy) Look up the types of the `head` and `tail` functions from the "
#~ "`Data.Array` module in the `purescript-arrays` package. Use do notation "
#~ "with the `Maybe` monad to combine these functions into a function `third` "
#~ "which returns the third element of an array with three or more elements. "
#~ "Your function should return an appropriate `Maybe` type."
#~ msgstr ""
#~ "（簡単）　`purescript-arrays`パッケージの `Data.Array`モジュールから "
#~ "`head`関数と `tail`関数の型を探してください。 `Maybe`モナドとdo記法を使"
#~ "い、 `head`と `tail`を組み合わせて、３要素以上の配列の3番目の要素を返すよ"
#~ "うな関数を作ってください。その関数は適当な `Maybe`型を返さなければいけませ"
#~ "ん。"

#, fuzzy
#~ msgid ""
#~ "In this way, we know exactly what side-effects to expect: exactly those "
#~ "used by `main`. In addition, we can use the `Eff` monad to restrict what "
#~ "types of side-effects `main` is allowed to have, so that we can say with "
#~ "certainty for example, that our application will interact with the "
#~ "console, but nothing else."
#~ msgstr ""
#~ "このように、 `main`によって使われる副作用が期待されることを、開発者は正確"
#~ "に知ることができます。加えて、 `main`がどのような種類の副作用を持つかを制"
#~ "限するのに `Eff`モナドを使うことができるので、例えば、アプリケーションはコ"
#~ "ンソールと相互作用するが、それ以外は何もしない、ということを確実に言うこと"
#~ "ができます。"

#, fuzzy
#~ msgid ""
#~ "Here is an example. It uses the `purescript-random` package, which "
#~ "defines functions for generating random numbers:"
#~ msgstr ""
#~ "例を示しましょう。次のコードでは乱数を生成するための関数が定義されている "
#~ "`purescript-random`モジュールを使用しています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "module Main where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Monad.Eff.Random (random)\n"
#~ "import Control.Monad.Eff.Console (logShow)\n"
#~ "\n"
#~ "main = do\n"
#~ "  n <- random\n"
#~ "  logShow n\n"
#~ msgstr ""
#~ "module Main where\n"
#~ "\n"
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Monad.Eff.Random (random)\n"
#~ "import Control.Monad.Eff.Console (logShow)\n"
#~ "\n"
#~ "main = do\n"
#~ "  n <- random\n"
#~ "  logShow n\n"

#, fuzzy
#~ msgid ""
#~ "If this file is saved as `src/Main.purs`, then it can be compiled and run "
#~ "using Pulp:"
#~ msgstr ""
#~ "このファイルが `Main.purs`という名前で保存されているなら、次のコマンドでコ"
#~ "ンパイルすることができます。"

#, fuzzy, no-wrap
#~ msgid "$ pulp run\n"
#~ msgstr "$ pulp run\n"

#, fuzzy
#~ msgid ""
#~ "This program uses do notation to combine two types of native effects "
#~ "provided by the Javascript runtime: random number generation and console "
#~ "IO."
#~ msgstr ""
#~ "このプログラムは、乱数生成とコンソール入出力というJavaScriptランタイムが提"
#~ "供する２種類のネイティブな作用を、do記法で組み合わせて使っています。"

#, fuzzy, no-wrap
#~ msgid "Extensible Effects"
#~ msgstr "拡張可能作用"

#, fuzzy
#~ msgid "We can inspect the type of main by opening the module in PSCi:"
#~ msgstr "`PSCi`でモジュールを読み込み、 `main`の型を調べてみましょう。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Main\n"
#~ "\n"
#~ "> :type main\n"
#~ "forall eff. Eff (console :: CONSOLE, random :: RANDOM | eff) Unit\n"
#~ msgstr ""
#~ "> import Main\n"
#~ "\n"
#~ "> :type main\n"
#~ "forall eff. Eff (console :: CONSOLE, random :: RANDOM | eff) Unit\n"

#, fuzzy
#~ msgid ""
#~ "This type looks quite complicated, but is easily explained by analogy "
#~ "with PureScriptâs records."
#~ msgstr ""
#~ "この型はかなり複雑そうに見えますが、PureScriptのレコードの比喩で簡単に説明"
#~ "することができます。"

#, fuzzy
#~ msgid "Consider a simple function which uses a record type:"
#~ msgstr "レコード型を使った簡単な関数を考えてみましょう。"

#, fuzzy, no-wrap
#~ msgid "fullName person = person.firstName <> \" \" <> person.lastName\n"
#~ msgstr "fullName person = person.firstName <> \" \" <> person.lastName\n"

#, fuzzy
#~ msgid ""
#~ "This function creates a full name string from a record containing "
#~ "`firstName` and `lastName` properties. If you find the type of this "
#~ "function in PSCi as before, you will see this:"
#~ msgstr ""
#~ "この関数は `firstName`と `lastName`というプロパティを含むレコードから完全"
#~ "な名前の文字列を作成します。もし `PSCi`でこの関数の型を同様に調べたとする"
#~ "と、次のように表示されるでしょう。"

#, fuzzy, no-wrap
#~ msgid "forall r. { firstName :: String, lastName :: String | r } -> String\n"
#~ msgstr "forall r. { firstName :: String, lastName :: String | r } -> String\n"

#, fuzzy
#~ msgid ""
#~ "This type reads as follows: â`fullName` takes a record with `firstName` "
#~ "and `lastName` fields _and any other properties_ and returns a `String`â."
#~ msgstr ""
#~ "この型は「**少なくとも**`fullName`は `firstName`と `lastName`という2つの"
#~ "フィールドを持つようなレコードをとり、 `String`を返す。」というように読み"
#~ "ます。"

#, fuzzy
#~ msgid ""
#~ "That is, `fullName` does not care if you pass a record with more fields, "
#~ "as long as the `firstName` and `lastName` properties are present:"
#~ msgstr ""
#~ "渡したレコードが `firstName`と `lastName`いうプロパティさえ持っていれば、"
#~ "その他に余計なフィールドを持っていたとしても `fullName`は気にしません。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> firstName { firstName: \"Phil\", lastName: \"Freeman\", location: \"Los Angeles\" }\n"
#~ "Phil Freeman\n"
#~ msgstr ""
#~ "> firstName { firstName: \"Phil\", lastName: \"Freeman\", location: \"Los Angeles\" }\n"
#~ "Phil Freeman\n"

#, fuzzy
#~ msgid ""
#~ "Similarly, the type of `main` above can be interpreted as follows: "
#~ "â`main` is a _computation with side-effects_, which can be run in any "
#~ "environment which supports random number generation and console IO, _and "
#~ "any other types of side effect_, and which returns a value of type "
#~ "`Unit`â."
#~ msgstr ""
#~ "同様に、上の `main`の型は「 `main`は**副作用のある計算**で、乱数生成とコン"
#~ "ソール入出力、**およびそれ以外の任意の種類の副作用**を備えた任意の環境で実"
#~ "行することができ、型 `Unit`の値を返す」というように解釈できます。"

#, fuzzy
#~ msgid ""
#~ "This is the origin of the name âextensible effectsâ: we can always extend "
#~ "the set of side-effects, as long as we can support the set of effects "
#~ "that we need."
#~ msgstr ""
#~ "これは 「拡張可能作用」という名前の由来になっています。必要な副作用さえ備"
#~ "えていれば、その副作用の集まりをいつでも拡張できるということです。"

#, fuzzy, no-wrap
#~ msgid "Interleaving Effects"
#~ msgstr "作用の混在"

#, fuzzy
#~ msgid ""
#~ "This extensibility allows code in the `Eff` monad to _interleave_ "
#~ "different types of side-effect."
#~ msgstr ""
#~ "拡張可能作用は `Eff`モナドで異なる型の副作用を**混在**(interleave)させるこ"
#~ "とを可能にします。"

#, fuzzy
#~ msgid "The `random` function which we used has the following type:"
#~ msgstr "先ほど使った `random`関数は次のような型を持っています。"

#, fuzzy, no-wrap
#~ msgid "forall eff1. Eff (random :: RANDOM | eff1) Number\n"
#~ msgstr "forall eff1. Eff (random :: RANDOM | eff1) Number\n"

#, fuzzy
#~ msgid ""
#~ "The set of effects `(random :: RANDOM | eff1)` here is _not_ the same as "
#~ "those appearing in `main`."
#~ msgstr ""
#~ "この作用の集まり `(random :: RANDOM | eff1)`は `main`で見たものと同じ**で"
#~ "はありません**。"

#, fuzzy
#~ msgid ""
#~ "However, we can _instantiate_ the type of `random` in such a way that the "
#~ "effects do match. If we choose `eff1` to be `(console :: CONSOLE | eff)`, "
#~ "then the two sets of effects become equal, up to reordering."
#~ msgstr ""
#~ "しかし、作用が一致するように `random`の型を特殊化できます。 `eff1`に "
#~ "`(console :: CONSOLE | eff)`を選べば、これらの２つの作用の集合は同じになり"
#~ "ます。"

#, fuzzy
#~ msgid ""
#~ "Similarly, `logShow` has a type which can be specialized to match the "
#~ "effects of `main`:"
#~ msgstr ""
#~ "同様に `logShow`は `main`の作用に合わせて特殊化できる型を持っています。"

#, fuzzy, no-wrap
#~ msgid "forall eff2. Show a => a -> Eff (console :: CONSOLE | eff2) Unit\n"
#~ msgstr "forall eff2. Show a => a -> Eff (console :: CONSOLE | eff2) Unit\n"

#, fuzzy
#~ msgid "This time we have to choose `eff2` to be `(random :: RANDOM | eff)`."
#~ msgstr ""
#~ "この場合は、 `eff2`に `(random :: Random | eff)`を選ばなくてはなりません。"

#, fuzzy
#~ msgid ""
#~ "The point is that the types of `random` and `logShow` indicate the side-"
#~ "effects which they contain, but in such a way that other side-effects can "
#~ "be _mixed-in_, to build larger computations with larger sets of side-"
#~ "effects."
#~ msgstr ""
#~ "それが含む副作用を示す `random`と `logShow`の型がポイントで、より大きな副"
#~ "作用の集まりを持ったより大きな計算を構築するために、他の副作用を**混ぜ合わ"
#~ "せる**ことができるのです。"

#, fuzzy
#~ msgid ""
#~ "Note that we don't have to give a type for `main`. The compiler will find "
#~ "a most general type for `main` given the polymorphic types of `random` "
#~ "and `logShow`."
#~ msgstr ""
#~ "`main`の型注釈を与えなくてもよいことに注意してください。コンパイラは "
#~ "`random`と `logShow`の多相的な型が与えられた `main`について、最も一般的な"
#~ "型を見つけることができます。"

#, fuzzy, no-wrap
#~ msgid "The Kind of Eff"
#~ msgstr "Effの種"

#, fuzzy, no-wrap
#~ msgid "The type of `main` is unlike other types we've seen before. To explain it, we need to consider the _kind_ of `Eff`. Recall that types are classified by their kinds just like values are classified by their types. So far, we've only seen kinds built from `Type` (the kind of types) and `->` (which builds kinds for type constructors).\n"
#~ msgstr "`main`の型は今まで見てきた他の型とは異なります。それを説明するためには、まず `Eff`の**種**について考える必要があります。値がその型によって分類されるように、型がその種によって分類されることを思い出してください。これまでは `Type`（型の種）と `->`（型構築子のための種を構築する）だけから構築された種のみを見てきました。\n"

#, fuzzy
#~ msgid "To find the kind of `Eff`, use the `:kind` command in PSCi:"
#~ msgstr "`Eff`の種を見るには、 `PSCi`で `:kind`コマンドを使います。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Control.Monad.Eff\n"
#~ "\n"
#~ "> :kind Eff\n"
#~ "# Control.Monad.Eff.Effect -> Type -> Type\n"
#~ msgstr ""
#~ "> import Control.Monad.Eff\n"
#~ "\n"
#~ "> :kind Eff\n"
#~ "# Control.Monad.Eff.Effect -> Type -> Type\n"

#, fuzzy
#~ msgid "There are two kinds here that we have not seen before."
#~ msgstr "今まで見たことのない記号が２つあります。"

#, fuzzy
#~ msgid ""
#~ "`Control.Monad.Eff.Effect` is the kind of _effects_, which represents "
#~ "_type-level labels_ for different types of side-effects. To understand "
#~ "this, note that the two labels we saw in `main` above both have kind "
#~ "`Control.Monad.Eff.Effect`:"
#~ msgstr ""
#~ "`Control.Monad.Eff.Effect`は副作用の型についての**型レベルのラベル**を表す"
#~ "**作用**の種です。これを理解するためには、上の `main`で見た2つのラベルがい"
#~ "ずれも種 `Control.Monad.Eff.Effect`を持っていることに注目してください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Control.Monad.Eff.Console\n"
#~ "> import Control.Monad.Eff.Random\n"
#~ "\n"
#~ "> :kind CONSOLE\n"
#~ "Control.Monad.Eff.Effect\n"
#~ "\n"
#~ "> :kind RANDOM\n"
#~ "Control.Monad.Eff.Effect\n"
#~ msgstr ""
#~ "> import Control.Monad.Eff.Console\n"
#~ "> import Control.Monad.Eff.Random\n"
#~ "\n"
#~ "> :kind CONSOLE\n"
#~ "Control.Monad.Eff.Effect\n"
#~ "\n"
#~ "> :kind RANDOM\n"
#~ "Control.Monad.Eff.Effect\n"

#, fuzzy
#~ msgid ""
#~ "The `#` kind constructor is used to construct kinds for _rows_, i.e. "
#~ "unordered, labelled sets."
#~ msgstr ""
#~ "`#`種構築子は**行**の種を構築するのに使われます。行とは順序なしラベル付き"
#~ "の集合のことです。"

#, fuzzy
#~ msgid ""
#~ "So `Eff` is parameterized by a row of effects, and its return type. That "
#~ "is, the first argument to `Eff` is an unordered, labelled set of effect "
#~ "types, and the second argument is the return type."
#~ msgstr ""
#~ "そして、 `Eff`は作用の行と作用の返り値の型という２つの引数を持っています。"
#~ "つまり、 `Eff`の最初の引数は、作用の型の順序なしラベル付きの集合であり、２"
#~ "つめの引数は返り値の型だということです。"

#, fuzzy
#~ msgid "We can now read the type of `main` above:"
#~ msgstr "これで、先ほどの `main`の型を読むことができるようになりました。"

#, fuzzy, no-wrap
#~ msgid "forall eff. Eff (console :: CONSOLE, random :: RANDOM | eff) Unit\n"
#~ msgstr "forall eff. Eff (console :: CONSOLE, random :: RANDOM | eff) Unit\n"

#, fuzzy
#~ msgid ""
#~ "The first argument to `Eff` is `(console :: CONSOLE, random :: RANDOM | "
#~ "eff)`. This is a row which contains the `CONSOLE` effect and the `RANDOM` "
#~ "effect. The pipe symbol `|` separates the labelled effects from the _row "
#~ "variable_ `eff` which represents _any other side-effects_ we might want "
#~ "to mix in."
#~ msgstr ""
#~ "`Eff`の最初の引数は `(console :: CONSOLE, random :: RANDOM | eff)`です。こ"
#~ "れは `CONSOLE`作用と `Random`作用を含む行です。パイプ記号 `|`は、ラベルが"
#~ "付けられた作用と、それに混ぜあわせたい**それ以外の任意の作用**を表す**行変"
#~ "数**(row variable)`eff`を区切っています。"

#, fuzzy
#~ msgid ""
#~ "The second argument to `Eff` is `Unit`, which is the return type of the "
#~ "computation."
#~ msgstr "`Eff`の2番目の引数は、計算の戻り値の型 `Unit`です。"

#, fuzzy, no-wrap
#~ msgid "Records And Rows"
#~ msgstr "オブジェクトと行"

#, fuzzy
#~ msgid ""
#~ "Considering the kind of `Eff` allows us to make a deeper connection "
#~ "between extensible effects and records."
#~ msgstr ""
#~ "拡張可能作用とレコードに深いつながりをもたらしている `Eff`の種を考えてみま"
#~ "しょう。"

#, fuzzy
#~ msgid "Take the function we defined above:"
#~ msgstr "上で定義した関数 `fullName`を考えます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "fullName :: forall r. { firstName :: String, lastName :: String | r } -> String\n"
#~ "fullName person = person.firstName <> \" \" <> person.lastName\n"
#~ msgstr ""
#~ "fullName :: forall r. { firstName :: String, lastName :: String | r } -> String\n"
#~ "fullName person = person.firstName <> \" \" <> person.lastName\n"

#, fuzzy
#~ msgid ""
#~ "The kind of the type on the left of the function arrow must be `Type`, "
#~ "because only types of kind `Type` have values."
#~ msgstr ""
#~ "種 `Type`の型だけが値を持つので、関数の矢印の左辺にある型の種は `Type`でな"
#~ "ければなりません。"

#, fuzzy
#~ msgid ""
#~ "The curly braces are actually syntactic sugar, and the full type as "
#~ "understood by the PureScript compiler is as follows:"
#~ msgstr ""
#~ "中括弧は実際には構文糖であり、PureScriptコンパイラによって理解されている完"
#~ "全な型は次のようなものです。"

#, fuzzy, no-wrap
#~ msgid "fullName :: forall r. Record (firstName :: String, lastName :: String | r) -> String\n"
#~ msgstr "fullName :: forall r. Record (firstName :: String, lastName :: String | r) -> String\n"

#, fuzzy
#~ msgid ""
#~ "Note that the curly braces have been removed, and there is an extra "
#~ "`Record` constructor. `Record` is a built-in type constructor defined in "
#~ "the `Prim` module. If we find its kind, we see the following:"
#~ msgstr ""
#~ "中括弧がなくなっており、 `Record`構築子が追加されていることに注意してくだ"
#~ "さい。 `Record`は `Prim`モジュールで定義されている組み込みの型構築子で"
#~ "す。 `Record`の種を調べてみると、次のようになっています。"

#, fuzzy
#~ msgid ""
#~ "That is, `Record` is a type constructor which takes a _row of types_ and "
#~ "constructs a type. This is what allows us to write row-polymorphic "
#~ "functions on records."
#~ msgstr ""
#~ "つまり、 `Record`は**型の行**をとり型を構築する型構築子なのです。これがレ"
#~ "コードについての行多相関数を書くことを可能にしているのです。"

#, fuzzy
#~ msgid ""
#~ "The type system uses the same machinery to handle extensible effects as "
#~ "is used for row-polymorphic records (or _extensible records_). The only "
#~ "difference is the _kind_ of the types appearing in the labels. Records "
#~ "are parameterized by a row of types, and `Eff` is parameterized by a row "
#~ "of effects."
#~ msgstr ""
#~ "この型システムでは、拡張可能作用を扱うのに、行多相レコード(**拡張可能レ"
#~ "コード**)を使うときと同じ機構が使われています。唯一の違いは、ラベルに現れ"
#~ "る型の**種**です。レコードは型の行によってパラメータ化され、 `Eff`は作用の"
#~ "行によってパラメータ化されるのです。"

#, fuzzy
#~ msgid ""
#~ "The same type system feature could even be used to build other types "
#~ "which were parameterized on rows of type constructors, or even rows of "
#~ "other rows!"
#~ msgstr ""
#~ "これと同じ型システムの機能は、型構築子の行や、行の行でパラメータ化される型"
#~ "を構築するのにさえ使われることがあります！"

#, fuzzy, no-wrap
#~ msgid "Fine-Grained Effects"
#~ msgstr "きめ細かな作用"

#, fuzzy
#~ msgid ""
#~ "Type annotations are usually not required when using `Eff`, since rows of "
#~ "effects can be inferred, but they can be used to indicate to the compiler "
#~ "which effects are expected in a computation."
#~ msgstr ""
#~ "作用の行は推論されるので、大抵の場合は `Eff`を使うときに型注釈は必須ではあ"
#~ "りませんが、計算でどの作用が期待されるのかをコンパイラに示すために型注釈が"
#~ "使われることがあります。"

#, fuzzy
#~ msgid "If we annotate the previous example with a _closed_ row of effects:"
#~ msgstr "先ほどの例を、作用の**閉じた**行で注釈すると次のようになります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "main :: Eff (console :: CONSOLE, random :: RANDOM) Unit\n"
#~ "main = do\n"
#~ "  n <- random\n"
#~ "  print n\n"
#~ msgstr ""
#~ "main :: Eff (console :: CONSOLE, random :: RANDOM) Unit\n"
#~ "main = do\n"
#~ "  n <- random\n"
#~ "  logShow n\n"

#, fuzzy
#~ msgid ""
#~ "(note the lack of the row variable `eff` here), then we cannot "
#~ "accidentally include a subcomputation which makes use of a different type "
#~ "of effect. In this way, we can control the side-effects that our code is "
#~ "allowed to have."
#~ msgstr ""
#~ "行変数 `eff`がないことに注意してください。こうすると、異なった作用の型を使"
#~ "う計算を誤って含めることはできません。このように、コードが持つことを許され"
#~ "る副作用を制御することができるのです。"

#, fuzzy, no-wrap
#~ msgid "Handlers and Actions"
#~ msgstr "ハンドラとアクション"

#, fuzzy
#~ msgid ""
#~ "Functions such as `print` and `random` are called _actions_. Actions have "
#~ "the `Eff` type on the right hand side of their functions, and their "
#~ "purpose is to _introduce_ new effects."
#~ msgstr ""
#~ "` logShow`や `random`のような関数は**アクション**と呼ばれます。アクション"
#~ "はそれらの関数の右辺に `Eff`型を持っており、その目的は新たな効果を**導入**"
#~ "することにあります。"

#, fuzzy
#~ msgid ""
#~ "This is in contrast to _handlers_, in which the `Eff` type appears as the "
#~ "type of a function argument. While actions _add_ to the set of required "
#~ "effects, a handler usually _subtracts_ effects from the set."
#~ msgstr ""
#~ "これは `Eff`型が関数の引数の型として現れる**ハンドラ**とは対照的です。アク"
#~ "ションが集合へ必要な作用を**追加**するのに対し、ハンドラは集合から作用を**"
#~ "除去**します。"

#, fuzzy
#~ msgid ""
#~ "As an example, consider the `purescript-exceptions` package. It defines "
#~ "two functions, `throwException` and `catchException`:"
#~ msgstr ""
#~ "例として、 `purescript-exceptions`パッケージを考えてみます。このパッケージ"
#~ "では `throwException`と `catchException`という二つの関数が定義されていま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "throwException :: forall a eff\n"
#~ "                . Error\n"
#~ "               -> Eff (exception :: EXCEPTION | eff) a\n"
#~ "\n"
#~ "catchException :: forall a eff\n"
#~ "                . (Error -> Eff eff a)\n"
#~ "               -> Eff (exception :: EXCEPTION | eff) a\n"
#~ "               -> Eff eff a\n"
#~ msgstr ""
#~ "throwException :: forall a eff\n"
#~ "                . Error\n"
#~ "               -> Eff (exception :: EXCEPTION | eff) a\n"
#~ "\n"
#~ "catchException :: forall a eff\n"
#~ "                . (Error -> Eff eff a)\n"
#~ "               -> Eff (exception :: EXCEPTION | eff) a\n"
#~ "               -> Eff eff a\n"

#, fuzzy
#~ msgid ""
#~ "`throwException` is an action. `Eff` appears on the right hand side, and "
#~ "introduces the new `EXCEPTION` effect."
#~ msgstr ""
#~ "`throwException`はアクションです。 `Eff`は右辺に現れていて、新しく "
#~ "`Exception`作用を導入します。"

#, fuzzy
#~ msgid ""
#~ "`catchException` is a handler. `Eff` appears as the type of the second "
#~ "function argument, and the overall effect is to _remove_ the `EXCEPTION` "
#~ "effect."
#~ msgstr ""
#~ "`catchException`はハンドラです。 `Eff`は関数の第２引数の型として出現してお"
#~ "り、作用全体としては `Exception`作用を**除去**します。"

#, fuzzy
#~ msgid ""
#~ "This is useful, because the type system can be used to delimit portions "
#~ "of code which require a particular effect. That code can then be wrapped "
#~ "in a handler, allowing it to be embedded inside a block of code which "
#~ "does not allow that effect."
#~ msgstr ""
#~ "特定の作用を必要とするコードの部分を限定するために型システムを使うことがで"
#~ "きるので、これは便利です。作用のあるコードをハンドラで包むことにより、その"
#~ "作用を許さないコードブロックの中に埋め込むことができます。"

#, fuzzy
#~ msgid ""
#~ "For example, we can write a piece of code which throws exceptions using "
#~ "the `Exception` effect, then wrap that code using `catchException` to "
#~ "embed the computation in a piece of code which does not allow exceptions."
#~ msgstr ""
#~ "例えば、 `Exception`作用を使って例外を投げるコード片を書き、それからその"
#~ "コードを `catchException`で包むことによって、例外を許さないコード片の中に"
#~ "その計算を埋め込むことができるのです。"

#, fuzzy
#~ msgid ""
#~ "Suppose we wanted to read our application's configuration from a JSON "
#~ "document. The process of parsing the document might result in an "
#~ "exception. The process of reading and parsing the configuration could be "
#~ "written as a function with this type signature:"
#~ msgstr ""
#~ "JSONドキュメントからアプリケーションの設定を読みたいとしましょう。文書を構"
#~ "文解析する過程で例外を投げることがあります。設定を読み構文解析するこの処理"
#~ "は、次のような型シグネチャを持つ関数として書くことができます。"

#, fuzzy, no-wrap
#~ msgid "readConfig :: forall eff. Eff (exception :: EXCEPTION | eff) Config\n"
#~ msgstr "readConfig :: forall eff. Eff (exception :: EXCEPTION | eff) Config\n"

#, fuzzy
#~ msgid ""
#~ "Then, in the `main` function, we could use `catchException` to handle the "
#~ "`EXCEPTION` effect, logging the error and returning a default "
#~ "configuration:"
#~ msgstr ""
#~ "それから、 `main`関数で `catchException`を使用して `Exception`作用を処理す"
#~ "ることができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "main = do\n"
#~ "    config <- catchException printException readConfig\n"
#~ "    runApplication config\n"
#~ "  where\n"
#~ "    printException e = do\n"
#~ "      log (message e)\n"
#~ "      pure defaultConfig\n"
#~ msgstr ""
#~ "main = do\n"
#~ "    config <- catchException printException readConfig\n"
#~ "    runApplication config\n"
#~ "  where\n"
#~ "    printException e = do\n"
#~ "      log (message e)\n"
#~ "      pure defaultConfig\n"

#, fuzzy
#~ msgid ""
#~ "The `purescript-eff` package also defines the `runPure` handler, which "
#~ "takes a computation with _no_ side-effects, and safely evaluates it as a "
#~ "pure value:"
#~ msgstr ""
#~ "`purescript-eff`パッケージでも、副作用**なし**の計算を取り、それを純粋な値"
#~ "として安全に評価する `runPure`ハンドラが定義されています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type Pure a = Eff () a\n"
#~ "\n"
#~ "runPure :: forall a. Pure a -> a\n"
#~ msgstr ""
#~ "type Pure a = Eff () a\n"
#~ "\n"
#~ "runPure :: forall a. Pure a -> a\n"

#, fuzzy
#~ msgid ""
#~ "In fact, since `ST` is the only effect in our example, we can use `runST` "
#~ "in conjunction with `runPure` to turn `simulate` into a pure function:"
#~ msgstr ""
#~ "実際に、 `ST`はこの例の唯一の作用なので、 `runPure`と `runST`を併用すると "
#~ "`simulate`を純粋な関数に変えることができます、"

#, fuzzy
#~ msgid ""
#~ "(Difficult) The following is a simple way to estimate pi: randomly choose "
#~ "a large number `N` of points in the unit square, and count the number `n` "
#~ "which lie in the inscribed circle. An estimate for pi is `4n/N`. Use the "
#~ "`RANDOM` and `ST` effects with the `forE` function to write a function "
#~ "which estimates pi in this way."
#~ msgstr ""
#~ "（難しい） PIを推定するには次のような簡単な方法があります。単位正方形内に"
#~ "ある多数の `N`個の点を無作為に選び、内接する円に含まれるものの個数 `n`を数"
#~ "えます。このとき `4n/N`が円周率 `pi`の概算となります。 `forE`関数、 "
#~ "`Random`作用、 `ST`作用を使って、この方法で円周率 `pi`を推定する関数を書い"
#~ "てください。"

#, fuzzy
#~ msgid "The HTML file is essentially empty, except for the following line:"
#~ msgstr "次の行を除いて、HTMLファイルは基本的に空です。"

#, fuzzy, no-wrap
#~ msgid "<script type=\"text/javascript\" src=\"../dist/Main.js\"></script>\n"
#~ msgstr "<script type=\"text/javascript\" src=\"../dist/Main.js\"></script>\n"

#, fuzzy
#~ msgid ""
#~ "This line includes the JavaScript code which is generated by Pulp. We "
#~ "place it at the end of the file to ensure that the relevant elements are "
#~ "on the page before we try to access them. To rebuild the `Main.js` file, "
#~ "Pulp can be used with the `browserify` command. Make sure the `dist` "
#~ "directory exists first, and that you have installed React as an NPM "
#~ "dependency:"
#~ msgstr ""
#~ "この行には、Pulpによって生成されたJavaScriptコードが含まれています。これを"
#~ "ファイルの最後に配置して、コードからアクセスしようとする関連要素が上にある"
#~ "ことを確認します。 `Main.js`ファイルを再構築するには、 `pulp browserify`コ"
#~ "マンドを使うことができます。最初に `dist`ディレクトリが存在し、ReactをNPM"
#~ "依存関係としてインストールしたことを確認してください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ npm install # Install React\n"
#~ "$ mkdir dist/\n"
#~ "$ pulp browserify --to dist/Main.js\n"
#~ msgstr ""
#~ "$ npm install # Install React\n"
#~ "$ mkdir dist/\n"
#~ "$ pulp browserify --to dist/Main.js\n"

#, fuzzy
#~ msgid ""
#~ "The `Main` defines the `main` function, which creates the address book "
#~ "component, and renders it to the screen. The `main` function uses the "
#~ "`CONSOLE` and `DOM` effects only, as its type signature indicates:"
#~ msgstr ""
#~ "`Main`モジュールは住所録コンポーネントを作成して画面に表示する `main`関数"
#~ "を定義しています。 `main`関数は `CONSOLE`作用と `DOM`作用のみを使用してお"
#~ "り、型シグニチャは次のことを示します。"

#, fuzzy, no-wrap
#~ msgid "main :: Eff (console :: CONSOLE, dom :: DOM) Unit\n"
#~ msgstr "main :: Eff (console :: CONSOLE, dom :: DOM) Unit\n"

#, fuzzy
#~ msgid "First, `main` logs a status message to the console:"
#~ msgstr "まず、 `main`はコンソールにステータスメッセージを記録します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "main = void do\n"
#~ "  log \"Rendering address book component\"\n"
#~ msgstr ""
#~ "main = void do\n"
#~ "  log \"Rendering address book component\"\n"

#, fuzzy
#~ msgid ""
#~ "Later, `main` uses the DOM API to obtain a reference (`doc`) to the "
#~ "document body:"
#~ msgstr ""
#~ "その後、 `main`はDOM APIを使用してドキュメント本体への参照（ `doc`）を取得"
#~ "します。"

#, fuzzy, no-wrap
#~ msgid "  doc <- window >>= document\n"
#~ msgstr "  doc <- window >>= document\n"

#, fuzzy
#~ msgid ""
#~ "Note that this provides an example of interleaving effects: the `log` "
#~ "function uses the `CONSOLE` effect, and the `window` and `document` "
#~ "functions both use the `DOM` effect. The type of `main` indicates that it "
#~ "uses both effects."
#~ msgstr ""
#~ "これは混在した作用の一例になっていることに注目してください。 `log`関数は "
#~ "`CONSOLE`作用を使い、 `window`と `document`関数は両方とも `DOM`作用を使い"
#~ "ます。 `main`の型は両方の作用を利用することを示します。"

#, fuzzy, no-wrap
#~ msgid "`main` uses the `window` action to get a reference to the window object, and passes the result to the `document` function using `>>=`. `document` takes a window object and returns a reference to its document.\n"
#~ msgstr "`main`は `window`アクションを使ってウィンドウオブジェクトへの参照を取得し、その結果を `document`関数に `>>=`を使って渡します。 `document`はウィンドウオブジェクトをとり、そのドキュメントへの参照を返します。\n"

#, fuzzy
#~ msgid ""
#~ "Note that, by the definition of do notation, we could have instead "
#~ "written this as follows:"
#~ msgstr ""
#~ "do記法の定義により、これを次のようにも書けることに注意してください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  w <- window\n"
#~ "  doc <- document w\n"
#~ msgstr ""
#~ "  w <- window\n"
#~ "  doc <- document w\n"

#, fuzzy
#~ msgid ""
#~ "It is a matter of personal preference whether this is more or less "
#~ "readable. The first version is an example of _point-free_ form, since "
#~ "there are no function arguments named, unlike the second version which "
#~ "uses the name `w` for the window object."
#~ msgstr ""
#~ "どちらが読みやすいかどうかは個人の好みの問題です。前者は名前が付けられた関"
#~ "数の引数がなく、**point-free**形式の一例となっています。その一方で、後者で"
#~ "はウィンドウオブジェクトの名前として `w`が使われています。"

#, fuzzy
#~ msgid ""
#~ "The `Main` module defines an address book _component_, called "
#~ "`addressBook`. To understand its definition, we will need to first need "
#~ "to understand some concepts."
#~ msgstr ""
#~ "`Main`モジュールは `addressBook`と呼ばれる住所録**コンポーネント**を定義し"
#~ "ます。その定義を理解するために、まずいくつかの概念を理解する必要がありま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "In order to create a React component, we must first create a React "
#~ "_class_, which acts like a template for a component. In `purescript-"
#~ "react`, we can create classes using the `createClass` function. "
#~ "`createClass` requires a _specification_ of our class, which is "
#~ "essentially a collection of `Eff` actions which are used to handle "
#~ "various parts of the component's lifecycle. The action we will be "
#~ "interested in is the `Render` action."
#~ msgstr ""
#~ "Reactコンポーネントを作成するには、最初にコンポーネントのテンプレートのよ"
#~ "うに動作するReact**クラス**を作成する必要があります。 `purescript-react`で"
#~ "は、 `createClass`関数を使ってクラスを作成することができます。 "
#~ "`createClass`はクラスの**仕様**を必要とします。この本質は、コンポーネント"
#~ "のライフサイクルについて処理するために使われる `Eff`アクションの集合です。"
#~ "開発者が注目するべきなのは `Render`アクションです。"

#, fuzzy
#~ msgid ""
#~ "Here are the types of some relevant functions provided by the React "
#~ "library:"
#~ msgstr ""
#~ "Reactライブラリが提供するいくつかの関連する関数の型は次のとおりです。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "createClass\n"
#~ "  :: forall props state eff\n"
#~ "   . ReactSpec props state eff\n"
#~ "  -> ReactClass props\n"
#~ "\n"
#~ "type Render props state eff\n"
#~ "   = ReactThis props state\n"
#~ "  -> Eff ( props :: ReactProps\n"
#~ "         , refs :: ReactRefs Disallowed\n"
#~ "         , state :: ReactState ReadOnly\n"
#~ "         | eff\n"
#~ "         ) ReactElement\n"
#~ "\n"
#~ "spec\n"
#~ "  :: forall props state eff\n"
#~ "   . state\n"
#~ "  -> Render props state eff\n"
#~ "  -> ReactSpec props state eff\n"
#~ msgstr ""
#~ "createClass\n"
#~ "  :: forall props state eff\n"
#~ "   . ReactSpec props state eff\n"
#~ "  -> ReactClass props\n"
#~ "\n"
#~ "type Render props state eff\n"
#~ "   = ReactThis props state\n"
#~ "  -> Eff ( props :: ReactProps\n"
#~ "         , refs :: ReactRefs Disallowed\n"
#~ "         , state :: ReactState ReadOnly\n"
#~ "         | eff\n"
#~ "         ) ReactElement\n"
#~ "\n"
#~ "spec\n"
#~ "  :: forall props state eff\n"
#~ "   . state\n"
#~ "  -> Render props state eff\n"
#~ "  -> ReactSpec props state eff\n"

#, fuzzy
#~ msgid "There are a few interesting things to note here:"
#~ msgstr "特筆すべき点は以下です。"

#, fuzzy
#~ msgid ""
#~ "- The `Render` type synonym is provided in order to simplify some type "
#~ "signatures, and it represents the rendering function for a component.  - "
#~ "A `Render` action takes a reference to the component (of type "
#~ "`ReactThis`), and returns a `ReactElement` in the `Eff` monad. A "
#~ "`ReactElement` is a data structure describing our intended state of the "
#~ "DOM after rendering.  - Every React component defines some type of state. "
#~ "The state can be changed in response to events like button clicks. In "
#~ "`purescript-react`, the initial state value is provided in the `spec` "
#~ "function.  - The effect row in the `Render` type uses some interesting "
#~ "effects to restrict access to the React component's state in certain "
#~ "functions. For example, during rendering, access to the \"refs\" object "
#~ "is `Disallowed`, and access to the component state is `ReadOnly`."
#~ msgstr ""
#~ "- `Render`型同義語は、いくつかの型シグネチャを単純化するために提供され、コ"
#~ "ンポーネントのレンダリング機能を表します。 - `Render`アクションは"
#~ "（ `ReactThis`型の）コンポーネントへの参照をとり、 `Eff`モナドに "
#~ "`ReactElement`を返します。 `ReactElement`はレンダリング後の意図したDOMの状"
#~ "態を記述するデータ構造体です。 - すべてのReactコンポーネントは、ある型の状"
#~ "態を定義します。ボタンのクリックなどのイベントに応じて状態を変更することが"
#~ "できます。 `purescript-react`では、初期状態値が `spec`関数で提供されま"
#~ "す。 - `Render`型の作用の行は、いくつかの面白い作用を使用して、特定の関数"
#~ "からReactコンポーネントの状態へのアクセスを制限します。たとえば、レンダリ"
#~ "ングのあいだ、「refs」オブジェクトへのアクセスは `Disallowed`であり、コン"
#~ "ポーネント状態へのアクセスは `ReadOnly`です。"

#, fuzzy
#~ msgid ""
#~ "The `Main` module defines a type of states for the address book "
#~ "component, and an initial state:"
#~ msgstr ""
#~ "`Main`モジュールは、住所録コンポーネントの状態の型と初期状態を定義します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "newtype AppState = AppState\n"
#~ "  { person :: Person\n"
#~ "  , errors :: Errors\n"
#~ "  }\n"
#~ "\n"
#~ "initialState :: AppState\n"
#~ "initialState = AppState\n"
#~ "  { person: examplePerson\n"
#~ "  , errors: []\n"
#~ "  }\n"
#~ msgstr ""
#~ "newtype AppState = AppState\n"
#~ "  { person :: Person\n"
#~ "  , errors :: Errors\n"
#~ "  }\n"
#~ "\n"
#~ "initialState :: AppState\n"
#~ "initialState = AppState\n"
#~ "  { person: examplePerson\n"
#~ "  , errors: []\n"
#~ "  }\n"

#, fuzzy
#~ msgid ""
#~ "The state contains a `Person` record (which we will make editable using "
#~ "form components), and a collection of errors (which will be populated "
#~ "using our existing validation code)."
#~ msgstr ""
#~ "状態には、（フォームコンポーネントを使用して編集可能にする） `Person`レ"
#~ "コードと、既存の検証コードを使用して入力されるエラーの配列が含まれていま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid "addressBook :: forall props. ReactClass props\n"
#~ msgstr "addressBook :: forall props. ReactClass props\n"

#, fuzzy
#~ msgid ""
#~ "As already indicated, `addressBook` will use `createClass` and `spec` to "
#~ "create a React class. To do so, it will provide our initial state value, "
#~ "and a `Render` action. However, what can we do in the `Render` action? To "
#~ "answer that, `purescript-react` provides some simple actions which can be "
#~ "used:"
#~ msgstr ""
#~ "すでに述べたように、`addressBook`は`createClass`と`spec`を使用してReactク"
#~ "ラスを作成します。ここから初期状態の値と`Render`アクションを得ることができ"
#~ "ます。取得した`Render`アクションでいったい何ができるのでしょうか？　例え"
#~ "ば、`purescript-react`は以下のような単純なアクションを提供しています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "readState\n"
#~ "  :: forall props state access eff\n"
#~ "   . ReactThis props state\n"
#~ "  -> Eff ( state :: ReactState ( read :: Read\n"
#~ "                               | access\n"
#~ "                               )\n"
#~ "         | eff\n"
#~ "         ) state\n"
#~ "\n"
#~ "writeState\n"
#~ "  :: forall props state access eff\n"
#~ "   . ReactThis props state\n"
#~ "  -> state\n"
#~ "  -> Eff ( state :: ReactState ( write :: Write\n"
#~ "                               | access\n"
#~ "                               )\n"
#~ "         | eff\n"
#~ "         ) state\n"
#~ msgstr ""
#~ "readState\n"
#~ "  :: forall props state access eff\n"
#~ "   . ReactThis props state\n"
#~ "  -> Eff ( state :: ReactState ( read :: Read\n"
#~ "                               | access\n"
#~ "                               )\n"
#~ "         | eff\n"
#~ "         ) state\n"
#~ "\n"
#~ "writeState\n"
#~ "  :: forall props state access eff\n"
#~ "   . ReactThis props state\n"
#~ "  -> state\n"
#~ "  -> Eff ( state :: ReactState ( write :: Write\n"
#~ "                               | access\n"
#~ "                               )\n"
#~ "         | eff\n"
#~ "         ) state\n"

#, fuzzy
#~ msgid ""
#~ "The `readState` and `writeState` functions use extensible effects to "
#~ "ensure that we have access to the React state (via the `ReactState` "
#~ "effect), but note that read and write permissions are separated further, "
#~ "by parameterizing the `ReactState` effect on _another_ row!"
#~ msgstr ""
#~ "`readState`と `writeState`アクションは拡張可能作用を伴って、ReactState作用"
#~ "を使ってReactの状態にアクセスできるようにしますが、**他の**行の "
#~ "`ReactState`作用をパラメータ化することで、読み書き権限がさらに分離されるこ"
#~ "とに注意してください！"

#, fuzzy
#~ msgid ""
#~ "This illustrates an interesting point about PureScript's row-based "
#~ "effects: effects appearing inside rows need not be simple singletons, but "
#~ "can have interesting structure, and this flexibility enables some useful "
#~ "restrictions at compile time. If the `purescript-react` library did not "
#~ "make this restriction then it would be possible to get exceptions at "
#~ "runtime if we tried to write the state in the `Render` action, for "
#~ "example. Instead, such mistakes are now caught at compile time."
#~ msgstr ""
#~ "これは、PureScriptの行ベースの作用に関する興味深い点を示しています。行内に"
#~ "現れる作用は単純な１要素である必要はなく、様々な構造を持つことができ、この"
#~ "柔軟性によってコンパイル時にいくつかの有用な制限が可能になります。 "
#~ "`purescript-react`ライブラリがこの制限をしなかった場合、 `Render`アクショ"
#~ "ンで状態を書き込もうとすると、実行時に例外を受け取ることになります。適切な"
#~ "制限を行うことで、このような間違いがコンパイル時に捕捉されるようになりまし"
#~ "た。"

#, fuzzy
#~ msgid ""
#~ "Now we can read the definition of our `addressBook` component. It starts "
#~ "by reading the current component state:"
#~ msgstr ""
#~ "これで `addressBook`コンポーネントの定義を読むことができるようになりまし"
#~ "た。まずは現在のコンポーネントの状態を読むことから始めましょう。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "addressBook = createClass $ spec initialState \\ctx -> do\n"
#~ "  AppState { person: Person person@{ homeAddress: Address address }\n"
#~ "           , errors\n"
#~ "           } <- readState ctx\n"
#~ msgstr ""
#~ "addressBook = createClass $ spec initialState \\ctx -> do\n"
#~ "  AppState { person: Person person@{ homeAddress: Address address }\n"
#~ "           , errors\n"
#~ "           } <- readState ctx\n"

#, fuzzy
#~ msgid ""
#~ "- The name `ctx` refers to the `ReactThis` reference, and can be used to "
#~ "read and write the state where appropriate.  - The record inside "
#~ "`AppState` is matched using a record binder, including a record pun for "
#~ "the _errors_ field. We explicitly name various parts of the state "
#~ "structure for convenience."
#~ msgstr ""
#~ "- 名前`ctx`は `ReactThis`を参照しており、必要に応じて状態を読み書きするた"
#~ "めに使用することができます。 - AppState内のレコードは、レコードパターンを"
#~ "使用して照合しています。これには**errors**フィールドのレコード同名利用も含"
#~ "まれます。便利なように、状態の構造のそれぞれの部分に明示的な名前をつけてい"
#~ "ます。"

#, fuzzy
#~ msgid ""
#~ "Recall that `Render` must return a `ReactElement` structure, representing "
#~ "the intended state of the DOM. The `Render` action is defined in terms of "
#~ "some helper functions. One such helper function is "
#~ "`renderValidationErrors`, which turns the `Errors` structure into an "
#~ "array of `ReactElement`s."
#~ msgstr ""
#~ "`Render`はDOMの次の状態を表す`ReactElement`構造体を返さなければならないの"
#~ "でした。`Render`アクションはいくつかの補助関数から定義されています。その補"
#~ "助関数の1つは `renderValidationErrors`です。これは`Errors`構造体を"
#~ "`ReactElement`の配列に変換します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "renderValidationError :: String -> ReactElement\n"
#~ "renderValidationError err = D.li' [ D.text err ]\n"
#~ "\n"
#~ "renderValidationErrors :: Errors -> Array ReactElement\n"
#~ "renderValidationErrors [] = []\n"
#~ "renderValidationErrors xs =\n"
#~ "  [ D.div [ P.className \"alert alert-danger\" ]\n"
#~ "          [ D.ul' (map renderValidationError xs) ]\n"
#~ "  ]\n"
#~ msgstr ""
#~ "renderValidationError :: String -> ReactElement\n"
#~ "renderValidationError err = D.li' [ D.text err ]\n"
#~ "\n"
#~ "renderValidationErrors :: Errors -> Array ReactElement\n"
#~ "renderValidationErrors [] = []\n"
#~ "renderValidationErrors xs =\n"
#~ "  [ D.div [ P.className \"alert alert-danger\" ]\n"
#~ "          [ D.ul' (map renderValidationError xs) ]\n"
#~ "  ]\n"

#, fuzzy
#~ msgid ""
#~ "In `purescript-react`, `ReactElement`s are typically created by applying "
#~ "functions like `div`, which create single HTML elements. These functions "
#~ "usually take an array of attributes, and an array of child elements as "
#~ "arguments. However, names ending with a prime character (like `ul'` here) "
#~ "omit the attribute array, and use the default attributes instead."
#~ msgstr ""
#~ "`purescript-react`では、 `ReactElement`は通常、単一のHTML要素を `div`のよ"
#~ "うな関数を適用することで作成します。これらの関数は通常、属性の配列と子要素"
#~ "の配列を引数として取ります。しかし、ここでは `ul'`のようにプライム記号(', "
#~ "prime character)で終わる名前は属性配列を省略し、代わりにデフォルトの属性を"
#~ "使用します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "formField\n"
#~ "  :: String\n"
#~ "  -> String\n"
#~ "  -> String\n"
#~ "  -> (String -> Person)\n"
#~ "  -> ReactElement\n"
#~ "formField name hint value update =\n"
#~ "  D.div [ P.className \"form-group\" ]\n"
#~ "        [ D.label [ P.className \"col-sm-2 control-label\" ]\n"
#~ "                  [ D.text name ]\n"
#~ "        , D.div [ P.className \"col-sm-3\" ]\n"
#~ "                [ D.input [ P._type \"text\"\n"
#~ "                          , P.className \"form-control\"\n"
#~ "                          , P.placeholder hint\n"
#~ "                          , P.value value\n"
#~ "                          , P.onChange (updateAppState ctx update)\n"
#~ "                          ] []\n"
#~ "                ]\n"
#~ "        ]\n"
#~ msgstr ""
#~ "formField\n"
#~ "  :: String\n"
#~ "  -> String\n"
#~ "  -> String\n"
#~ "  -> (String -> Person)\n"
#~ "  -> ReactElement\n"
#~ "formField name hint value update =\n"
#~ "  D.div [ P.className \"form-group\" ]\n"
#~ "        [ D.label [ P.className \"col-sm-2 control-label\" ]\n"
#~ "                  [ D.text name ]\n"
#~ "        , D.div [ P.className \"col-sm-3\" ]\n"
#~ "                [ D.input [ P._type \"text\"\n"
#~ "                          , P.className \"form-control\"\n"
#~ "                          , P.placeholder hint\n"
#~ "                          , P.value value\n"
#~ "                          , P.onChange (updateAppState ctx update)\n"
#~ "                          ] []\n"
#~ "                ]\n"
#~ "        ]\n"

#, fuzzy
#~ msgid ""
#~ "Again, note that we are composing more interesting elements from simpler "
#~ "elements, applying attributes to each element as we go. One attribute of "
#~ "note here is the `onChange` attribute applied to the `input` element. "
#~ "This is an _event handler_, and is used to update the component state "
#~ "when the user edits text in our text box. Our event handler is defined "
#~ "using a third helper function, `updateAppState`:"
#~ msgstr ""
#~ "繰り返しますが、単純な要素から様々な要素を構成し、それぞれの要素に属性を適"
#~ "用しています。ここで注目すべき属性の1つは、 `input`要素に適用される "
#~ "`onChange`属性です。これは**イベントハンドラ**で、ユーザーがテキストボック"
#~ "ス内のテキストを編集するときにコンポーネントの状態を更新するために使用され"
#~ "ます。イベントハンドラは、3番目の補助関数 `updateAppState`を使用して定義さ"
#~ "れています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "updateAppState\n"
#~ "  :: forall props eff\n"
#~ "   . ReactThis props AppState\n"
#~ "  -> (String -> Person)\n"
#~ "  -> Event\n"
#~ "  -> Eff ( console :: CONSOLE\n"
#~ "         , state :: ReactState ReadWrite\n"
#~ "         | eff\n"
#~ "         ) Unit\n"
#~ msgstr ""
#~ "updateAppState\n"
#~ "  :: forall props eff\n"
#~ "   . ReactThis props AppState\n"
#~ "  -> (String -> Person)\n"
#~ "  -> Event\n"
#~ "  -> Eff ( console :: CONSOLE\n"
#~ "         , state :: ReactState ReadWrite\n"
#~ "         | eff\n"
#~ "         ) Unit\n"

#, fuzzy
#~ msgid ""
#~ "`updateAppState` takes a reference to the component in the form of our "
#~ "`ReactThis` value, a function to update the `Person` record, and the "
#~ "`Event` record we are responding to. First, it extracts the new value of "
#~ "the text box from the `change` event (using the `valueOf` helper "
#~ "function), and uses it to create a new `Person` state:"
#~ msgstr ""
#~ "`updateAppState`は、 `ReactThis`値の形式でコンポーネントへの参照、 "
#~ "`Person`レコードを更新する関数、そして `Event`レコードを取ります。まず、"
#~ "（valueOf補助関数を使用して） `change`イベントからテキストボックスの新しい"
#~ "値を抽出し、それを使って新しい `Person`状態を作成します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  for_ (valueOf e) \\s -> do\n"
#~ "    let newPerson = update s\n"
#~ msgstr ""
#~ "  for_ (valueOf e) \\s -> do\n"
#~ "    let newPerson = update s\n"

#, fuzzy
#~ msgid ""
#~ "Then, it runs the validation function, and updates the component state "
#~ "(using `writeState`) accordingly:"
#~ msgstr ""
#~ "次に、検証関数を実行し、それに応じて（writeStateを使用して）コンポーネント"
#~ "の状態を更新します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    log \"Running validators\"\n"
#~ "    case validatePerson' newPerson of\n"
#~ "      Left errors ->\n"
#~ "        writeState ctx (AppState { person: newPerson\n"
#~ "                                 , errors: errors\n"
#~ "                                 })\n"
#~ "      Right _ ->\n"
#~ "        writeState ctx (AppState { person: newPerson\n"
#~ "                                 , errors: []\n"
#~ "                                 })\n"
#~ msgstr ""
#~ "    log \"Running validators\"\n"
#~ "    case validatePerson' newPerson of\n"
#~ "      Left errors ->\n"
#~ "        writeState ctx (AppState { person: newPerson\n"
#~ "                                 , errors: errors\n"
#~ "                                 })\n"
#~ "      Right _ ->\n"
#~ "        writeState ctx (AppState { person: newPerson\n"
#~ "                                 , errors: []\n"
#~ "                                 })\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Instead of using a `ul` element to show the validation errors in "
#~ "a list, modify the code to create one `div` with the `alert` style for "
#~ "each error."
#~ msgstr ""
#~ "(やや難しい) 検証エラーを `ul`要素を使ってリストで表示するかわりに、それぞ"
#~ "れのエラーについてひとつづつ `alert`スタイルで `div`を作成するように、コー"
#~ "ドを変更してください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "main = void $ unsafePartial do\n"
#~ "  Just canvas <- getCanvasElementById \"canvas\"\n"
#~ "  ctx <- getContext2D canvas\n"
#~ msgstr ""
#~ "main = void $ unsafePartial do\n"
#~ "  Just canvas <- getCanvasElementById \"canvas\"\n"
#~ "  ctx <- getContext2D canvas\n"

#, fuzzy
#~ msgid ""
#~ "We continue by setting the fill style to solid blue, by using the "
#~ "`setFillStyle` action:"
#~ msgstr ""
#~ "`ctx`の取得に続けて、 `setFillStyle`アクションを使って塗りのスタイルを青一"
#~ "色の塗りつぶしに設定しています。"

#, fuzzy, no-wrap
#~ msgid "  setFillStyle \"#0000FF\" ctx\n"
#~ msgstr "  setFillStyle \"#0000FF\" ctx\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "fillPath :: forall eff a. Context2D ->\n"
#~ "                          Eff (canvas :: CANVAS | eff) a ->\n"
#~ "                          Eff (canvas :: CANVAS | eff) a\n"
#~ msgstr ""
#~ "fillPath :: forall eff a. Context2D ->\n"
#~ "                          Eff (canvas :: Canvas | eff) a ->\n"
#~ "                          Eff (canvas :: Canvas | eff) a\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  fillPath ctx $ rect ctx\n"
#~ "    { x: 250.0\n"
#~ "    , y: 250.0\n"
#~ "    , w: 100.0\n"
#~ "    , h: 100.0\n"
#~ "    }\n"
#~ msgstr ""
#~ "  fillPath ctx $ rect ctx\n"
#~ "    { x: 250.0\n"
#~ "    , y: 250.0\n"
#~ "    , w: 100.0\n"
#~ "    , h: 100.0\n"
#~ "    }\n"

#, fuzzy
#~ msgid ""
#~ "For example, this code fills an arc segment centered at `(300, 300)` with "
#~ "radius `50`:"
#~ msgstr ""
#~ "たとえば、次のコードは中心 `(300、300)`、半径 `50`の円弧を塗りつぶします。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "translate\n"
#~ "  :: forall r\n"
#~ "   . Number\n"
#~ "  -> Number\n"
#~ "  -> { x :: Number, y :: Number | r }\n"
#~ "  -> { x :: Number, y :: Number | r }\n"
#~ "translate dx dy shape = shape\n"
#~ "  { x = shape.x + dx\n"
#~ "  , y = shape.y + dy\n"
#~ "  }\n"
#~ msgstr ""
#~ "translate :: forall r. Number -> Number ->\n"
#~ "              { x :: Number, y :: Number | r } ->\n"
#~ "              { x :: Number, y :: Number | r }\n"
#~ "translate dx dy shape = shape\n"
#~ "  { x = shape.x + dx\n"
#~ "  , y = shape.y + dy\n"
#~ "  }\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  setFillStyle \"#FF0000\" ctx\n"
#~ "\n"
#~ "  fillPath ctx $ do\n"
#~ "    moveTo ctx 300.0 260.0\n"
#~ "    lineTo ctx 260.0 340.0\n"
#~ "    lineTo ctx 340.0 340.0\n"
#~ "    closePath ctx\n"
#~ msgstr ""
#~ "  setFillStyle \"#FF0000\" ctx\n"
#~ "\n"
#~ "  fillPath ctx $ do\n"
#~ "    moveTo ctx 300.0 260.0\n"
#~ "    lineTo ctx 260.0 340.0\n"
#~ "    lineTo ctx 340.0 340.0\n"
#~ "    closePath ctx\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  setFillStyle \"#FF0000\" ctx\n"
#~ "  setStrokeStyle \"#000000\" ctx\n"
#~ msgstr ""
#~ "  setFillStyle \"#FF0000\" ctx\n"
#~ "  setStrokeStyle \"#000000\" ctx\n"

#, fuzzy, no-wrap
#~ msgid "  for_ (1 .. 100) \\_ -> do\n"
#~ msgstr "  for_ (1 .. 100) \\_ -> do\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    x <- random\n"
#~ "    y <- random\n"
#~ "    r <- random\n"
#~ msgstr ""
#~ "    x <- random\n"
#~ "    y <- random\n"
#~ "    r <- random\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    let path = arc ctx\n"
#~ "         { x     : x * 600.0\n"
#~ "         , y     : y * 600.0\n"
#~ "         , r     : r * 50.0\n"
#~ "         , start : 0.0\n"
#~ "         , end   : Math.pi * 2.0\n"
#~ "         }\n"
#~ "    fillPath ctx path\n"
#~ "    strokePath ctx path\n"
#~ msgstr ""
#~ "    let path = arc ctx\n"
#~ "         { x     : x * 600.0\n"
#~ "         , y     : y * 600.0\n"
#~ "         , r     : r * 50.0\n"
#~ "         , start : 0.0\n"
#~ "         , end   : Math.pi * 2.0\n"
#~ "         }\n"
#~ "    fillPath ctx path\n"
#~ "    strokePath ctx path\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "withContext\n"
#~ "  :: forall eff a\n"
#~ "   . Context2D\n"
#~ "  -> Eff (canvas :: CANVAS | eff) a\n"
#~ "  -> Eff (canvas :: CANVAS | eff) a          \n"
#~ msgstr ""
#~ "withContext :: forall eff a. Context2D -> \n"
#~ "                             Eff (canvas :: Canvas | eff) a ->\n"
#~ "                             Eff (canvas :: Canvas | eff) a          \n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Control.Monad.Eff.Ref\n"
#~ "\n"
#~ "> :kind Ref\n"
#~ "Type -> Type\n"
#~ "\n"
#~ "> :kind REF\n"
#~ "Control.Monad.Eff.Effect\n"
#~ msgstr ""
#~ "> import Control.Monad.Eff.Ref\n"
#~ "\n"
#~ "> :kind Ref\n"
#~ "Type -> Type\n"
#~ "\n"
#~ "> :kind REF\n"
#~ "Control.Monad.Eff.Effect\n"

#, fuzzy
#~ msgid ""
#~ "A value of type `Ref a` is a mutable reference cell containing a value of "
#~ "type `a`, much like an `STRef h a`, which we saw in the previous chapter. "
#~ "The difference is that, while the `ST` effect can be removed by using "
#~ "`runST`, the `Ref` effect does not provide a handler. Where `ST` is used "
#~ "to track safe, local mutation, `Ref` is used to track global mutation. As "
#~ "such, it should be used sparingly."
#~ msgstr ""
#~ "型 `RefVal a`の値は型 `a`値を保持する変更可能な領域への参照で、前の章で見"
#~ "た `STRef h a`によく似ています。その違いは、 `ST`作用は `runST`を用いて除"
#~ "去することができますが、 `Ref`作用はハンドラを提供しないということです。 "
#~ "`ST`は安全に局所的な状態変更を追跡するために使用されますが、 `Ref`は大域的"
#~ "な状態変更を追跡するために使用されます。そのため、 `Ref`は慎重に使用する必"
#~ "要があります。"

#, fuzzy, no-wrap
#~ msgid "  clickCount <- newRef 0\n"
#~ msgstr "  clickCount <- newRef 0\n"

#, fuzzy, no-wrap
#~ msgid "    modifyRef clickCount (\\count -> count + 1)\n"
#~ msgstr "    modifyRef clickCount (\\count -> count + 1)\n"

#, fuzzy
#~ msgid "The `readRef` action is used to read the new click count:"
#~ msgstr ""
#~ "`readRef`アクションは新しいクリック数を読み取るために使われています。"

#, fuzzy, no-wrap
#~ msgid "    count <- readRef clickCount\n"
#~ msgstr "    count <- readRef clickCount\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    withContext ctx do\n"
#~ "      let scaleX = Math.sin (toNumber count * Math.pi / 4.0) + 1.5\n"
#~ "      let scaleY = Math.sin (toNumber count * Math.pi / 6.0) + 1.5\n"
#~ "\n"
#~ "      translate { translateX: 300.0, translateY:  300.0 } ctx\n"
#~ "      rotate (toNumber count * Math.pi / 18.0) ctx\n"
#~ "      scale { scaleX: scaleX, scaleY: scaleY } ctx\n"
#~ "      translate { translateX: -100.0, translateY: -100.0 } ctx\n"
#~ "\n"
#~ "      fillPath ctx $ rect ctx\n"
#~ "        { x: 0.0\n"
#~ "        , y: 0.0\n"
#~ "        , w: 200.0\n"
#~ "        , h: 200.0\n"
#~ "        }\n"
#~ msgstr ""
#~ "    withContext ctx do\n"
#~ "      let scaleX = Math.sin (toNumber count * Math.pi / 4.0) + 1.5\n"
#~ "      let scaleY = Math.sin (toNumber count * Math.pi / 6.0) + 1.5\n"
#~ "\n"
#~ "      translate { translateX: 300.0, translateY:  300.0 } ctx\n"
#~ "      rotate (toNumber count * Math.pi / 18.0) ctx\n"
#~ "      scale { scaleX: scaleX, scaleY: scaleY } ctx\n"
#~ "      translate { translateX: -100.0, translateY: -100.0 } ctx\n"
#~ "\n"
#~ "      fillPath ctx $ rect ctx\n"
#~ "        { x: 0.0\n"
#~ "        , y: 0.0\n"
#~ "        , w: 200.0\n"
#~ "        , h: 200.0\n"
#~ "        }\n"

#, fuzzy, no-wrap
#~ msgid "Examples"
#~ msgstr "演習"

#, fuzzy, no-wrap
#~ msgid "data Alphabet = L | R | F\n"
#~ msgstr "data Alphabet = L | R | F\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type Sentence = Array Alphabet\n"
#~ "\n"
#~ "initial :: Sentence\n"
#~ "initial = [F, R, R, F, R, R, F, R, R]\n"
#~ msgstr ""
#~ "type Sentence = Array Alphabet\n"
#~ "\n"
#~ "initial :: Sentence\n"
#~ "initial = [F, R, R, F, R, R, F, R, R]\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "productions :: Alphabet -> Sentence\n"
#~ "productions L = [L]\n"
#~ "productions R = [R]\n"
#~ "productions F = [F, L, F, R, R, F, L, F]\n"
#~ msgstr ""
#~ "productions :: Alphabet -> Sentence\n"
#~ "productions L = [L]\n"
#~ "productions R = [R]\n"
#~ "productions F = [F, L, F, R, R, F, L, F]\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "forall eff. Sentence\n"
#~ "         -> (Alphabet -> Sentence)\n"
#~ "         -> (Alphabet -> Eff (canvas :: Canvas | eff) Unit)\n"
#~ "         -> Int\n"
#~ "         -> Eff (canvas :: CANVAS | eff) Unit\n"
#~ msgstr ""
#~ "forall eff. Sentence\n"
#~ "         -> (Alphabet -> Sentence)\n"
#~ "         -> (Alphabet -> Eff (canvas :: Canvas | eff) Unit)\n"
#~ "         -> Int\n"
#~ "         -> Eff (canvas :: Canvas | eff) Unit\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type State =\n"
#~ "  { x :: Number\n"
#~ "  , y :: Number\n"
#~ "  , theta :: Number\n"
#~ "  }\n"
#~ msgstr ""
#~ "type State =\n"
#~ "  { x :: Number\n"
#~ "  , y :: Number\n"
#~ "  , theta :: Number\n"
#~ "  }\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "initialState :: State\n"
#~ "initialState = { x: 120.0, y: 200.0, theta: 0.0 }\n"
#~ msgstr ""
#~ "initialState :: State\n"
#~ "initialState = { x: 120.0, y: 200.0, theta: 0.0 }\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "lsystem :: forall a s eff\n"
#~ "         . Array a\n"
#~ "        -> (a -> Array a)\n"
#~ "        -> (s -> a -> Eff (canvas :: CANVAS | eff) s)\n"
#~ "        -> Int\n"
#~ "        -> s\n"
#~ "        -> Eff (canvas :: CANVAS | eff) s\n"
#~ "lsystem init prod interpret n state = go init n\n"
#~ "  where\n"
#~ msgstr ""
#~ "lsystem :: forall a s eff. Array a\n"
#~ "        -> (a -> Array a)\n"
#~ "        -> (s -> a -> Eff (canvas :: Canvas | eff) s)\n"
#~ "        -> Int\n"
#~ "        -> s\n"
#~ "        -> Eff (canvas :: Canvas | eff) s\n"
#~ "lsystem init prod interpret n state = go init n\n"
#~ "  where\n"

#, fuzzy, no-wrap
#~ msgid "  go s 0 = foldM interpret state s\n"
#~ msgstr "  go s 0 = foldM interpret state s\n"

#, fuzzy, no-wrap
#~ msgid "  go s n = go (concatMap prod s) (n - 1)\n"
#~ msgstr "  go s n = go (concatMap prod s) (n - 1)\n"

#, fuzzy, no-wrap
#~ msgid "interpret :: State -> Alphabet -> Eff (canvas :: CANVAS) State\n"
#~ msgstr "interpret :: State -> Alphabet -> Eff (canvas :: Canvas) State\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "interpret state L = pure $ state { theta = state.theta - Math.pi / 3 }\n"
#~ "interpret state R = pure $ state { theta = state.theta + Math.pi / 3 }\n"
#~ msgstr ""
#~ "interpret state L = pure $ state { theta = state.theta - Math.pi / 3 }\n"
#~ "interpret state R = pure $ state { theta = state.theta + Math.pi / 3 }\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "interpret state F = do\n"
#~ "  let x = state.x + Math.cos state.theta * 1.5\n"
#~ "      y = state.y + Math.sin state.theta * 1.5\n"
#~ "  moveTo ctx state.x state.y\n"
#~ "  lineTo ctx x y\n"
#~ "  pure { x, y, theta: state.theta }\n"
#~ msgstr ""
#~ "interpret state F = do\n"
#~ "  let x = state.x + Math.cos state.theta * 1.5\n"
#~ "      y = state.y + Math.sin state.theta * 1.5\n"
#~ "  moveTo ctx state.x state.y\n"
#~ "  lineTo ctx x y\n"
#~ "  pure { x, y, theta: state.theta }\n"

#, fuzzy, no-wrap
#~ msgid "strokePath ctx $ lsystem initial productions interpret 5 initialState\n"
#~ msgstr "strokePath ctx $ lsystem initial productions interpret 5 initialState\n"

#, fuzzy
#~ msgid ""
#~ "In the next chapter, we will see how to implement libraries like "
#~ "`purescript-canvas` which wrap existing JavaScript functionality, by "
#~ "using PureScript's _foreign function interface_."
#~ msgstr ""
#~ "次の章では、PureScriptの**外部関数インタフェース**(foreign function "
#~ "interface)を使って、既存のJavaScriptの関数をラップした `purescript-canvas`"
#~ "のようなライブラリを実装する方法について説明します。"

#, fuzzy
#~ msgid ""
#~ "- How to call pure JavaScript functions from PureScript, - How to create "
#~ "new effect types and actions for use with the `Eff` monad, based on "
#~ "existing JavaScript code, - How to call PureScript code from JavaScript, "
#~ "- How to understand the representation of PureScript values at runtime, - "
#~ "How to work with untyped data using the `purescript-foreign` package."
#~ msgstr ""
#~ "- PureScriptから純粋なJavaScript関数を呼び出す方法 - 既存のJavaScriptコー"
#~ "ドに基づいて、作用型と `Eff`モナドと一緒に使用する新しいアクションを作成す"
#~ "る方法 - JavaScriptからPureScriptコードを呼び出す方法 - 実行時のPureScript"
#~ "の値の表現を知る方法 - `purescript-foreign`パッケージを使用して型付けされ"
#~ "ていないデータを操作する方法"

#, fuzzy
#~ msgid "This chapter adds two new Bower dependencies:"
#~ msgstr "この章では、2つの新しいBower依存関係を追加します。"

#, fuzzy
#~ msgid ""
#~ "The `purescript-foreign` library, which provides a data type and "
#~ "functions for working with _untyped data_."
#~ msgstr "`purescript-foreign`- データ型と関数を提供しています。"

#, fuzzy
#~ msgid ""
#~ "The `purescript-foreign-generic` library, which adds support for "
#~ "_datatype generic programming_ to the `purescript-foreign` library."
#~ msgstr ""
#~ "`purescript-foreign-generic`- **データ型ジェネリックプログラミング**を操作"
#~ "するためのデータ型と関数を提供します。"

#, fuzzy
#~ msgid ""
#~ "_Note_: to avoid browser-specific issues with local storage when the "
#~ "webpage is served from a local file, it might be necessary to run this "
#~ "chapter's project over HTTP."
#~ msgstr ""
#~ "**注意**：ウェブページがローカルファイルから配信されているときに起こる、"
#~ "ローカルストレージとブラウザ特有の問題を避けるために、この章の例を実行する"
#~ "には、HTTPを経由してこの章のプロジェクトを実行する必要があります。\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "var Test = require('Test');\n"
#~ "Test.gcd(15)(20);\n"
#~ msgstr ""
#~ "var Test = require('Test');\n"
#~ "Test.gcd(15)(20);\n"

#, fuzzy, no-wrap
#~ msgid "shout(require('Prelude').showNumber)(42);\n"
#~ msgstr "shout(require('Prelude').showNumber)(42);\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "module Data.URI where\n"
#~ "\n"
#~ "foreign import encodeURIComponent :: String -> String\n"
#~ msgstr ""
#~ "module Data.URI where\n"
#~ "\n"
#~ "foreign import encodeURIComponent :: String -> String\n"

#, fuzzy
#~ msgid ""
#~ "We also need to write a foreign Javascript module. If the module above is "
#~ "saved as `src/Data/URI.purs`, then the foreign Javascript module should "
#~ "be saved as `src/Data/URI.js`:"
#~ msgstr ""
#~ "また、外部JavaScriptモジュールを書く必要があります。上記のモジュールを"
#~ "`src/Data/URI.purs`として保存した場合、次のような外部JavaScriptモジュール"
#~ "を`src/Data/URI.js`として保存します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "\"use strict\";\n"
#~ "\n"
#~ "exports.encodeURIComponent = encodeURIComponent;\n"
#~ msgstr ""
#~ "\"use strict\";\n"
#~ "\n"
#~ "exports.encodeURIComponent = encodeURIComponent;\n"

#, fuzzy
#~ msgid ""
#~ "Pulp will find `.js` files in the `src` directory, and provide them to "
#~ "the compiler as foreign Javascript modules."
#~ msgstr ""
#~ "Pulpは`src`ディレクトリにある`.js`ファイルを見つけ、それを外部JavaScriptモ"
#~ "ジュールとしてコンパイラに提供します。"

#, fuzzy
#~ msgid ""
#~ "Javascript functions and values are exported from foreign Javascript "
#~ "modules by assigning them to the `exports` object just like a regular "
#~ "CommonJS module. The `purs` compiler treats this module like a regular "
#~ "CommonJS module, and simply adds it as a dependency to the compiled "
#~ "PureScript module. However, when bundling code for the browser with `psc-"
#~ "bundle` or `pulp build -O --to`, it is very important to follow the "
#~ "pattern above, assigning exports to the `exports` object using a property "
#~ "assignment. This is because `psc-bundle` recognizes this format, allowing "
#~ "unused Javascript exports to be removed from bundled code."
#~ msgstr ""
#~ "JavaScriptの関数と値は、通常のCommonJSモジュールと同じように`exports`オブ"
#~ "ジェクトに代入することで、外部JavaScriptモジュールからエクスポートされま"
#~ "す。`purs`コンパイラは、このモジュールを通常のCommonJSモジュールのように扱"
#~ "い、コンパイルされたPureScriptモジュールへの依存関係として追加します。しか"
#~ "し、`psc-bundle`や`pulp build -O --to`を使ってブラウザ向けのコードをバンド"
#~ "ルするときは、上記のパターンに従い、プロパティ代入を使って`exports`オブ"
#~ "ジェクトにエクスポートする値を代入することがとても重要です。 これは、`psc-"
#~ "bundle`がこの形式を認識し、未使用のJavaScriptのエクスポートをバンドルされ"
#~ "たコードから削除できるようにするためです。"

#, fuzzy
#~ msgid ""
#~ "This approach works well for simple JavaScript values, but is of limited "
#~ "use for more complicated examples. The reason is that most idiomatic "
#~ "JavaScript code does not meet the strict criteria imposed by the runtime "
#~ "representations of the basic PureScript types. In those cases, we have "
#~ "another option - we can _wrap_ the JavaScript code in such a way that we "
#~ "can force it to adhere to the correct runtime representation."
#~ msgstr ""
#~ "この手法は簡単なJav​​aScriptの値には適していますが、もっと複雑な値に使うには"
#~ "限界があります。ほとんどの既存のJavaScriptコードは、基本的なPureScriptの型"
#~ "の実行時表現によって課せられた厳しい条件を満たしていないからです。このよう"
#~ "な場合のためには、適切な実行時表現に従うことを強制するようにJavaScriptコー"
#~ "ドを**ラップする**という別の方法があります。"

#, fuzzy, no-wrap
#~ msgid "Wrapping JavaScript Values"
#~ msgstr "JavaScriptの値のラッピング"

#, fuzzy
#~ msgid ""
#~ "We might want to wrap Javascript values and functions for a number of "
#~ "reasons:"
#~ msgstr ""
#~ "これはPureScriptの型を与えるためにJavaScriptコードの既存の部分をラップする"
#~ "場合に特に便利です。このようにしたくなる理由はいくつかあります。"

#, fuzzy
#~ msgid ""
#~ "- A function takes multiple arguments, but we want to call it like a "
#~ "curried function.  - We might want to use the `Eff` monad to keep track "
#~ "of any JavaScript side-effects.  - It might be necessary to handle corner "
#~ "cases like `null` or `undefined`, to give a function the correct runtime "
#~ "representation."
#~ msgstr ""
#~ "- 関数が複数の引数を取るが、カリー化した関数と同じように呼び出したい。 - "
#~ "任意のJavaScriptの副作用を追跡するために、 `Eff`モナドを使うことができま"
#~ "す。 - 関数の適切な実行時表現を与えるために、 `null`や `undefined`のような"
#~ "特殊な場合を処理するために必要な場合があります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "function head(arr) {\n"
#~ "    return arr[0];\n"
#~ "}\n"
#~ msgstr ""
#~ "function head(arr) {\n"
#~ "    return arr[0];\n"
#~ "}\n"

#, fuzzy
#~ msgid ""
#~ "Throwing an exception in the case of failure is less than ideal - "
#~ "idiomatic PureScript code uses the type system to represent side-effects "
#~ "such as missing values. One example of this approach is the `Maybe` type "
#~ "constructor. In this section, we will build another solution using the "
#~ "FFI."
#~ msgstr ""
#~ "失敗した場合に例外を投げるという方法は、あまり理想的とはいえません。"
#~ "PureScriptのコードでは、欠けた値のような副作用は型システムを使って扱うのが"
#~ "普通です。この手法としては `Maybe`型構築子を使う方法もありますが、この節で"
#~ "はFFIを使用した別の解決策を扱います。"

#, fuzzy
#~ msgid ""
#~ "Suppose we wanted to define a new type `Undefined a` whose representation "
#~ "at runtime was like that for the type `a`, but also allowing the "
#~ "`undefined` value."
#~ msgstr ""
#~ "実行時には型 `a`のように表現されますが `undefined`の値も許容するような新し"
#~ "い型 `Undefined a`を定義したいとしましょう。"

#, fuzzy
#~ msgid ""
#~ "Note the two changes: the body of the `head` function is now much "
#~ "simpler, and returns `arr[0]` even if that value is undefined, and the "
#~ "type signature has been changed to reflect the fact that our function can "
#~ "return an undefined value."
#~ msgstr ""
#~ "2点変更がある注意してください。 `head`関数の本体ははるかに簡単で、もしその"
#~ "値が未定義であったとしても `arr[0]`を返し、型シグネチャはこの関数が未定義"
#~ "の値を返すことがあるという事実を反映するよう変更されています。"

#, fuzzy
#~ msgid ""
#~ "For example, the following foreign type declaration is taken from the "
#~ "Prelude in the `Data.Function.Uncurried` module:"
#~ msgstr ""
#~ "たとえば、Preludeの `Data.Function.Uncurried`モジュールには次の外部型宣言"
#~ "があります。"

#, fuzzy, no-wrap
#~ msgid "foreign import data Fn2 :: Type -> Type -> Type -> Type\n"
#~ msgstr "foreign import data Fn2 :: Type -> Type -> Type -> Type\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Data.Function.Uncurried\n"
#~ "\n"
#~ "divides :: Fn2 Int Int Boolean\n"
#~ "divides = mkFn2 \\n m -> m % n == 0\n"
#~ msgstr ""
#~ "import Data.Function.Uncurried\n"
#~ "\n"
#~ "divides :: Fn2 Int Int Boolean\n"
#~ "divides = mkFn2 \\n m -> m % n == 0\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> runFn2 divides 2 10\n"
#~ "true\n"
#~ "\n"
#~ "> runFn2 divides 3 10\n"
#~ "false\n"
#~ msgstr ""
#~ "> runFn2 divides 2 10\n"
#~ "true\n"
#~ "\n"
#~ "> runFn2 divides 3 10\n"
#~ "false\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "exports.divides = function(n, m) {\n"
#~ "    return m % n === 0;\n"
#~ "};\n"
#~ msgstr ""
#~ "exports.divides = function(n, m) {\n"
#~ "    return m % n === 0;\n"
#~ "};\n"

#, fuzzy, no-wrap
#~ msgid "foreign import data Eff :: # Effect -> Type -> Type\n"
#~ msgstr "foreign import data Eff :: # Effect -> Type -> Type\n"

#, fuzzy
#~ msgid ""
#~ "Recall that the `Eff` type constructor is parameterized by a row of "
#~ "effects and a return type, which is reflected in its kind."
#~ msgstr ""
#~ "`Eff`型の構築子は作用の行と返り値の型によってパラメータ化されおり、それが"
#~ "種に反映されることを思い出してください。"

#, fuzzy, no-wrap
#~ msgid "foreign import random :: forall eff. Eff (random :: RANDOM | eff) Number\n"
#~ msgstr "foreign import random :: forall eff. Eff (random :: RANDOM | eff) Number\n"

#, fuzzy
#~ msgid ""
#~ "The effects `RANDOM` and `CONSOLE` are also defined as foreign types. "
#~ "Their kinds are defined to be `Effect`, the kind of effects. For example:"
#~ msgstr ""
#~ "作用 `RANDOM`と `CONSOLE`も外部型として定義されています。その種は `!`、つ"
#~ "まり作用であると定義されています。例えば次のようになります。"

#, fuzzy, no-wrap
#~ msgid "foreign import data RANDOM :: Effect\n"
#~ msgstr "foreign import data RANDOM :: Effect\n"

#, fuzzy
#~ msgid ""
#~ "In fact, it is possible to define new effects in this way, as we will "
#~ "soon see."
#~ msgstr ""
#~ "詳しくはあとで見ていきますが、このように新たな作用を定義することが可能なの"
#~ "です。"

#, fuzzy, no-wrap
#~ msgid "require('Main').main();\n"
#~ msgstr "require('Main').main();\n"

#, fuzzy, no-wrap
#~ msgid "Defining New Effects"
#~ msgstr "新しい作用の定義"

#, fuzzy
#~ msgid ""
#~ "The source code for this chapter defines two new effects. The simplest is "
#~ "the `ALERT` effect, defined in the `Control.Monad.Eff.Alert` module. It "
#~ "is used to indicate that a computation might alert the user using a popup "
#~ "window."
#~ msgstr ""
#~ "この章のソースコードでは、2つの新しい作用が定義されています。最も簡単なの"
#~ "は `Control.Monad.Eff.Alert`モジュールで定義された `ALERT`作用です。これは"
#~ "その計算がポップアップウィンドウを使用してユーザに警告しうることを示すため"
#~ "に使われます。"

#, fuzzy
#~ msgid "The effect is defined first, using a foreign type declaration:"
#~ msgstr "この作用は最初に外部型宣言を使用して定義されています。"

#, fuzzy
#~ msgid ""
#~ "`ALERT` is given the kind `Effect`, indicating that it represents an "
#~ "effect, as opposed to a type."
#~ msgstr ""
#~ "`Alert`は種 `Effect`が与えられており、 `Alert`が型ではなく作用であることを"
#~ "示しています。"

#, fuzzy
#~ msgid ""
#~ "Next, the `alert` action is defined. The `alert` action displays a popup, "
#~ "and adds the `ALERT` effect to the row of effects:"
#~ msgstr ""
#~ "次に、 `alert`アクションが定義されています。 `alert`アクションはポップアッ"
#~ "プを表示し、作用の行に `Alert`作用を追加します。"

#, fuzzy
#~ msgid ""
#~ "The foreign Javascript module is straightforward, defining the `alert` "
#~ "function by assigning it to the `exports` variable:"
#~ msgstr ""
#~ " JavaScriptモジュールは簡単で、 `alert`関数を `exports`変数に代入して定義"
#~ "します。\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "\"use strict\";\n"
#~ "\n"
#~ "exports.alert = function(msg) {\n"
#~ "    return function() {\n"
#~ "        window.alert(msg);\n"
#~ "    };\n"
#~ "};\n"
#~ "\n"
#~ msgstr ""
#~ "\"use strict\";\n"
#~ "\n"
#~ "exports.alert = function(msg) {\n"
#~ "    return function() {\n"
#~ "        window.alert(msg);\n"
#~ "    };\n"
#~ "};\n"
#~ "\n"

#, fuzzy
#~ msgid ""
#~ "Note that, as in the case of `log`, the `alert` function uses a function "
#~ "of no arguments to represent the computation of type `Eff (alert :: ALERT "
#~ "| eff) Unit`."
#~ msgstr ""
#~ "`log`の場合のように、 `alert`関数は型 `Eff (alert :: ALERT | eff) Unit`の"
#~ "計算を表現するために引数なしの関数を使っていることに注意してください。"

#, fuzzy
#~ msgid ""
#~ "The second effect defined in this chapter is the `STORAGE` effect, which "
#~ "is defined in the `Control.Monad.Eff.Storage` module. It is used to "
#~ "indicate that a computation might read or write values using the Web "
#~ "Storage API."
#~ msgstr ""
#~ "この章で定義される２つめの作用は、 `Control.Monad.Eff.Storage`モジュールで"
#~ "定義されている `STORAGE`作用です。これは計算がWeb Storage APIを使用して値"
#~ "を読み書きする可能性があることを示すために使われます。"

#, fuzzy
#~ msgid "The effect is defined in the same way:"
#~ msgstr "この作用も同じように定義されています。"

#, fuzzy, no-wrap
#~ msgid "foreign import data STORAGE :: Effect\n"
#~ msgstr "foreign import data STORAGE :: Effect\n"

#, fuzzy
#~ msgid ""
#~ "The `Control.Monad.Eff.Storage` module defines two actions: `getItem`, "
#~ "which retrieves a value from local storage, and `setItem` which inserts "
#~ "or updates a value in local storage. The two functions have the following "
#~ "types:"
#~ msgstr ""
#~ "`Control.Monad.Eff.Storage`モジュールには、ローカルストレージから値を取得"
#~ "する `getItem`と、ローカルストレージに値を挿入したり値を更新する `setItem`"
#~ "という、２つのアクションが定義されています。この二つの関数は、次のような型"
#~ "を持っています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "foreign import getItem\n"
#~ "  :: forall eff\n"
#~ "   . String\n"
#~ "  -> Eff (storage :: STORAGE | eff) Foreign\n"
#~ "\n"
#~ "foreign import setItem\n"
#~ "  :: forall eff\n"
#~ "   . String\n"
#~ "  -> String\n"
#~ "  -> Eff (storage :: STORAGE | eff) Unit\n"
#~ msgstr ""
#~ "foreign import getItem :: forall eff . String\n"
#~ "  -> Eff (storage :: STORAGE | eff) Foreign\n"
#~ "foreign import setItem :: forall eff . String\n"
#~ "  -> String -> Eff (storage :: STORAGE | eff) Unit\n"

#, fuzzy
#~ msgid ""
#~ "The interested reader can inspect the source code for this module to see "
#~ "the definitions of these actions."
#~ msgstr ""
#~ "興味のある読者は、このモジュールのソースコードでこれらのアクションがどのよ"
#~ "うに定義されているか調べてみてください。"

#, fuzzy
#~ msgid ""
#~ "`setItem` takes a key and a value (both strings), and returns a "
#~ "computation which stores the value in local storage at the specified key."
#~ msgstr ""
#~ "`setItem`はキーと値(両方とも文字列)を受け取り、指定されたキーでローカルス"
#~ "トレージに値を格納する計算を返します。"

#, fuzzy
#~ msgid ""
#~ "`Data.Foreign` provides a way to work with _untyped data_, or more "
#~ "generally, data whose runtime representation is uncertain."
#~ msgstr ""
#~ "`Data.Foreign`は、**型付けされていないデータ**、もっと一般的にいえば実行時"
#~ "表現が不明なデータを扱う方法を提供しています。"

#, fuzzy, no-wrap
#~ msgid "Working With Untyped Data"
#~ msgstr "型付けされていないデータの操作"

#, fuzzy
#~ msgid ""
#~ "In this section, we will see how we can use the `Data.Foreign` library to "
#~ "turn untyped data into typed data, with the correct runtime "
#~ "representation for its type."
#~ msgstr ""
#~ "この節では、型付けされていないデータを、その型の適切な実行時表現を持った型"
#~ "付けされたデータに変換する、 `Data.Foreign`ライブラリの使い方について見て"
#~ "行きます。"

#, fuzzy
#~ msgid ""
#~ "The code for this chapter builds on the address book example from chapter "
#~ "8, by adding a Save button at the bottom of the form. When the Save "
#~ "button is clicked, the state of the form is serialized to JSON and stored "
#~ "in local storage. When the page is reloaded, the JSON document is "
#~ "retrieved from local storage and parsed."
#~ msgstr ""
#~ "この章のコードは、第8章の住所録の上にフォームの一番下に保存ボタンを追加す"
#~ "ることで作っていきます。保存ボタンがクリックされると、フォームの状態をJSON"
#~ "に直列化し、ローカルストレージに格納します。ページが再読み込みされると、"
#~ "JSON文書がローカルストレージから取得され、構文解析されます。"

#, fuzzy
#~ msgid "The `Main` module defines a type for the saved form data:"
#~ msgstr "`Main`モジュールではフォームデータの型を定義します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "newtype FormData = FormData\n"
#~ "  { firstName  :: String\n"
#~ "  , lastName   :: String\n"
#~ "  , street     :: String\n"
#~ "  , city       :: String\n"
#~ "  , state      :: String\n"
#~ "  , homePhone  :: String\n"
#~ "  , cellPhone  :: String\n"
#~ "  }\n"
#~ msgstr ""
#~ "newtype FormData = FormData\n"
#~ "  { firstName  :: String\n"
#~ "  , lastName   :: String\n"
#~ "  , street     :: String\n"
#~ "  , city       :: String\n"
#~ "  , state      :: String\n"
#~ "  , homePhone  :: String\n"
#~ "  , cellPhone  :: String\n"
#~ "  }\n"

#, fuzzy
#~ msgid ""
#~ "The problem is that we have no guarantee that the JSON will have the "
#~ "correct form. Put another way, we don't know that the JSON represents the "
#~ "correct type of data at runtime. This is the sort of problem that is "
#~ "solved by the `purescript-foreign` library. Here are some other examples:"
#~ msgstr ""
#~ "問題は、このJSONが正しい形式を持っているという保証がないことです。別の言い"
#~ "方をすれば、JSONが実行時にデータの正しい型を表しているかはわかりません。こ"
#~ "の問題は `purescript-foreign`ライブラリによって解決することができます。他"
#~ "にも次のような使いかたがあります。"

#, fuzzy
#~ msgid ""
#~ "- A JSON response from a web service - A value passed to a function from "
#~ "JavaScript code"
#~ msgstr ""
#~ "- WebサービスからJSONレスポンス - JavaScriptコードから関数に渡された値"

#, fuzzy
#~ msgid ""
#~ "Let's try the `purescript-foreign` and `purescript-foreign-generic` "
#~ "libraries in PSCi."
#~ msgstr ""
#~ "それでは、 `PSCi`で `purescript-foreign`及び `purescript-foreign-generic`"
#~ "ライブラリを試してみましょう。"

#, fuzzy
#~ msgid "Start by importing some modules:"
#~ msgstr "二つのモジュールをインポートして起動します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Data.Foreign\n"
#~ "> import Data.Foreign.Generic\n"
#~ "> import Data.Foreign.JSON\n"
#~ msgstr ""
#~ "> import Data.Foreign\n"
#~ "> import Data.Foreign.Generic\n"
#~ "> import Data.Foreign.JSON\n"

#, fuzzy
#~ msgid ""
#~ "A good way to obtain a `Foreign` value is to parse a JSON document. "
#~ "`purescript-foreign-generic` defines the following two functions:"
#~ msgstr ""
#~ "`Foreign`な値を取得するためには、JSON文書を解析するのがいいでしょう。 "
#~ "`purescript-foreign`では次の2つの関数が定義されています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "parseJSON :: String -> F Foreign\n"
#~ "decodeJSON :: forall a. Decode a => String -> F a\n"
#~ msgstr ""
#~ "parseJSON :: String -> F Foreign\n"
#~ "decodeJSON :: forall a. Decode a => String -> F a\n"

#, fuzzy
#~ msgid ""
#~ "The type constructor `F` is actually just a type synonym, defined in "
#~ "`Data.Foreign`:"
#~ msgstr "型構築子`F`は、実際には`Data.Foreign`で定義されている型同義語です。"

#, fuzzy, no-wrap
#~ msgid "type F = Except (NonEmptyList ForeignError)\n"
#~ msgstr "type F = Except (NonEmptyList ForeignError)\n"

#, fuzzy
#~ msgid ""
#~ "Here, `Except` is an monad for handling exceptions in pure code, much "
#~ "like `Either`.  We can convert a value in the `F` monad into a value in "
#~ "the `Either` monad by using the `runExcept` function."
#~ msgstr ""
#~ "ここで`Except`は、`Either`のように、純粋なコードで例外を処理するためのモナ"
#~ "ドです。 `runExcept`関数を使うと、`F`モナドの値を`Either`モナドの値に変換"
#~ "することができます。"

#, fuzzy
#~ msgid ""
#~ "Most of the functions in the `purescript-foreign` and `purescript-foreign-"
#~ "generic` libraries return a value in the `F` monad, which means that we "
#~ "can use do notation and the applicative functor combinators to build "
#~ "typed values."
#~ msgstr ""
#~ "`purescript-foreign`と`purescript-foreign-generic`ライブラリにあるほとんど"
#~ "の関数は`F`モナドの中に値を入れて返します。 要はdo記法とアプリカティブファ"
#~ "ンクターコンビネータを型付けされた値の構築に使うことができるのです。"

#, fuzzy
#~ msgid ""
#~ "The `Decode` type class represents those types which can be obtained from "
#~ "untyped data.  There are type class instances defined for the primitive "
#~ "types and arrays, and we can define our own instances as well."
#~ msgstr ""
#~ "この `Decode`型クラスは、それらの型が型付けされていないデータから得られる"
#~ "ことを表しています。 プリミティブ型や配列については型クラスインスタンスが"
#~ "すでに定義されていますが、独自のインスタンスを定義することもできます。"

#, fuzzy
#~ msgid ""
#~ "Let's try parsing some simple JSON documents using `decodeJSON` in PSCi "
#~ "(remembering to use `runExcept` to unwrap the results):"
#~ msgstr ""
#~ "それでは `PSCi`で `readJSON`を使用していくつかの簡単なJSON文書を解析してみ"
#~ "ましょう。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Control.Monad.Except\n"
#~ "\n"
#~ "> runExcept (decodeJSON \"\\\"Testing\\\"\" :: F String)\n"
#~ "Right \"Testing\"\n"
#~ "\n"
#~ "> runExcept (decodeJSON \"true\" :: F Boolean)\n"
#~ "Right true\n"
#~ "\n"
#~ "> runExcept (decodeJSON \"[1, 2, 3]\" :: F (Array Int))\n"
#~ "Right [1, 2, 3]\n"
#~ msgstr ""
#~ "> import Control.Monad.Except\n"
#~ "\n"
#~ "> runExcept (decodeJSON \"\\\"Testing\\\"\" :: F String)\n"
#~ "Right \"Testing\"\n"
#~ "\n"
#~ "> runExcept (decodeJSON \"true\" :: F Boolean)\n"
#~ "Right true\n"
#~ "\n"
#~ "> runExcept (decodeJSON \"[1, 2, 3]\" :: F (Array Int))\n"
#~ "Right [1, 2, 3]\n"

#, fuzzy
#~ msgid ""
#~ "Recall that in the `Either` monad, the `Right` data constructor indicates "
#~ "success. Note however, that invalid JSON, or an incorrect type leads to "
#~ "an error:"
#~ msgstr ""
#~ "`Either`モナドでは `Right`データ構築子は成功を示していることを思い出してく"
#~ "ださい。しかし、その不正なJSONや誤った型はエラーを引き起こすことに注意して"
#~ "ください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> runExcept (decodeJSON \"[1, 2, true]\" :: F (Array Int))\n"
#~ "(Left (NonEmptyList (NonEmpty (ErrorAtIndex 2 (TypeMismatch \"Int\" \"Boolean\")) Nil)))\n"
#~ msgstr ""
#~ "> runExcept (decodeJSON \"[1, 2, true]\" :: F (Array Int))\n"
#~ "(Left (NonEmptyList (NonEmpty (ErrorAtIndex 2 (TypeMismatch \"Int\" \"Boolean\")) Nil)))\n"

#, fuzzy
#~ msgid ""
#~ "The `purescript-foreign-generic` library tells us where in the JSON "
#~ "document the type error occurred."
#~ msgstr ""
#~ "`purescript-foreign-generic`ライブラリはJSON文書で型エラーが発生した位置を"
#~ "教えてくれます。"

#, fuzzy, no-wrap
#~ msgid "Handling Null and Undefined Values"
#~ msgstr "nullとundefined値の取り扱い"

#, fuzzy
#~ msgid ""
#~ "Real-world JSON documents contain null and undefined values, so we need "
#~ "to be able to handle those too."
#~ msgstr ""
#~ "実世界のJSON文書にはnullやundefined値が含まれているので、それらも扱えるよ"
#~ "うにしなければなりません。"

#, fuzzy
#~ msgid ""
#~ "`purescript-foreign-generic` defines a type constructors which solves "
#~ "this problem: `NullOrUndefined`. It serves a similar purpose to the "
#~ "`Undefined` type constructor that we defined earlier, but uses the "
#~ "`Maybe` type constructor internally to represent missing values."
#~ msgstr ""
#~ "`purescript-foreign-generic`では、この問題を解決する3種類の構築子、 "
#~ "`Null`、 `Undefined`、 `NullOrUndefined`が定義されています。先に定義した "
#~ "`Undefined`型の構築子と似た目的を持っていますが、省略可能な値を表すために "
#~ "`Maybe`型の構築子を内部的に使っています。"

#, fuzzy
#~ msgid ""
#~ "The module also provides a function `unNullOrUndefined` to unwrap the "
#~ "inner value. We can lift the appropriate function over the `decodeJSON` "
#~ "action to parse JSON documents which permit null values:"
#~ msgstr ""
#~ "それぞれの型の構築子について、ラップされた値から内側の値を取り出す関数、 "
#~ "`runNullOrUndefined`が提供されています。 `null`値を許容するJSON文書を解析"
#~ "するには、 `readJSON`アクションまで対応する適切な関数を持ち上げます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> import Prelude\n"
#~ "> import Data.Foreign.NullOrUndefined\n"
#~ "\n"
#~ "> runExcept (unNullOrUndefined <$> decodeJSON \"42\" :: F (NullOrUndefined Int))\n"
#~ "(Right (Just 42))\n"
#~ "\n"
#~ "> runExcept (unNullOrUndefined <$> decodeJSON \"null\" :: F (NullOrUndefined Int))\n"
#~ "(Right Nothing)\n"
#~ msgstr ""
#~ "> import Prelude\n"
#~ "> import Data.Foreign.NullOrUndefined\n"
#~ "\n"
#~ "> runExcept (unNullOrUndefined <$> decodeJSON \"42\" :: F (NullOrUndefined Int))\n"
#~ "(Right (Just 42))\n"
#~ "\n"
#~ "> runExcept (unNullOrUndefined <$> decodeJSON \"null\" :: F (NullOrUndefined Int))\n"
#~ "(Right Nothing)\n"

#, fuzzy, no-wrap
#~ msgid "In each case, the type annotation applies to the term to the right of the `<$>` operator. For example, `decodeJSON \"42\"` has the type `F (NullOrUndefined Int)`. The `unNullOrUndefined` function is then lifted over `F` to give the final type `F (Maybe Int)`.\n"
#~ msgstr "それぞれの場合で、型注釈が `<$>`演算子の右辺に適用されています。たとえば、 `readJSON \"42\"`は型 `F (NullOrUndefined Int)`を持っています。 `unNullOrUndefined`関数は最終的な型 `F (Maybe Number)`与えるために `F`まで持ち上げられます。\n"

#, fuzzy
#~ msgid ""
#~ "The type `NullOrUndefined Int` represents values which are either "
#~ "integers, or null. What if we wanted to parse more interesting values, "
#~ "like arrays of integers, where each element might be `null`? In that "
#~ "case, we could lift the function `map unNullOrUndefined` over the "
#~ "`decodeJSON` action, as follows:"
#~ msgstr ""
#~ "型 `NullOrUndefined Int`は数またはnullいずれかの値を表しています。各要素"
#~ "が `null`をかもしれない数値の配列のように、より興味深いの値を解析したい場"
#~ "合はどうでしょうか。その場合には、次のように `readJSON`アクションまで関数 "
#~ "`map unNullOrUndefined`を持ち上げます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "> runExcept (map unNullOrUndefined <$> decodeJSON \"[1, 2, null]\" :: F (Array (NullOrUndefined Int)))\n"
#~ "(Right [(Just 1),(Just 2),Nothing])\n"
#~ msgstr ""
#~ "> runExcept (map unNullOrUndefined <$> decodeJSON \"[1, 2, null]\"\n"
#~ "    :: F (Array (NullOrUndefined Int))) (Right [(Just 1),(Just 2),Nothing])\n"

#, fuzzy
#~ msgid ""
#~ "In general, using newtypes to wrap an existing type is a good way to "
#~ "provide different serialization strategies for the same type. The "
#~ "`NullOrUndefined` type is defined as a newtype around the `Maybe` type "
#~ "constructor."
#~ msgstr ""
#~ "一般的には、同じ型に異なる直列化戦略を提供するには、newtypesを使って既存の"
#~ "型をラップするのがいいでしょう。 `NullOrUndefined`それぞれの型は、 `Maybe`"
#~ "型構築子に包まれたnewtypeとして定義されています。"

#, fuzzy, no-wrap
#~ msgid "Generic JSON Serialization"
#~ msgstr "住所録の項目の直列化"

#, fuzzy
#~ msgid ""
#~ "In fact, we rarely need to write instances for the `Decode` class, since "
#~ "the `purescript-foreign-generic` class allows us to _derive_ instances "
#~ "using a technique called _datatype-generic programming_. A full "
#~ "explanation of this technique is beyond the scope of this book, but it "
#~ "allows us to write functions once, and reuse them over many different "
#~ "data types, based on the structure of a the types themselves."
#~ msgstr ""
#~ "実のところ、`purescript-foreign-generic`クラスは**datatype-generic "
#~ "programming**という技術を使ってインスタンスの**自動導出**(derive)すること"
#~ "が可能なので、`Decode`クラスのインスタンスを自分で書く必要はほとんどありま"
#~ "せん。このテクニックの完全な説明は本書の範囲を超えていますが、関数を一度記"
#~ "述すれば、型自体の構造に基づいてさまざまなデータ型に再利用することができま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "To derive a `Decode` instance for our `FormData` type (so that we may "
#~ "deserialize it from its JSON representation), we first use the `derive` "
#~ "keyword to derive an instance of the `Generic` type class, which looks "
#~ "like this:"
#~ msgstr ""
#~ "`FormData`型の `Decode`インスタンスを派生させるためには、まず `derive`キー"
#~ "ワードを使って `Generic`型クラスのインスタンスを派生させます。"

#, fuzzy, no-wrap
#~ msgid "derive instance genericFormData :: Generic FormData _\n"
#~ msgstr "derive instance genericFormData :: Generic FormData _\n"

#, fuzzy
#~ msgid ""
#~ "Next, we simply define the `decode` function using the `genericDecode` "
#~ "function, as follows:"
#~ msgstr ""
#~ "そして、`genericDecode`関数を使って、次のように`decode`関数を定義します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "instance decodeFormData :: Decode FormData where\n"
#~ "  decode = genericDecode (defaultOptions { unwrapSingleConstructors = true })\n"
#~ msgstr ""
#~ "instance decodeFormData :: Decode FormData where\n"
#~ "  decode = genericDecode (defaultOptions { unwrapSingleConstructors = true })\n"

#, fuzzy
#~ msgid "In fact, we can also derive an _encoder_ in the same way:"
#~ msgstr "実際、同じ方法で `encoder`を導出することもできます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "instance encodeFormData :: Encode FormData where\n"
#~ "  encode = genericEncode (defaultOptions { unwrapSingleConstructors = true })\n"
#~ msgstr ""
#~ "instance encodeFormData :: Encode FormData where\n"
#~ "  encode = genericEncode (defaultOptions { unwrapSingleConstructors = true })\n"

#, fuzzy
#~ msgid ""
#~ "It is important that we use the same options in the decoder and encoder, "
#~ "otherwise our encoded JSON documents might not get decoded correctly."
#~ msgstr ""
#~ "デコーダとエンコーダで同じオプションを使用することが重要です。そうしない"
#~ "と、エンコードされたJSONドキュメントが正しくデコードされないことがありま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "Now, when the Save button is clicked, a value of type `FormData` is "
#~ "passed to the `encode` function, serializing it as a JSON document. The "
#~ "`FormData` type is a newtype for a record, so a value of type `FormData` "
#~ "passed to `encode` will be serialized as a JSON _object_. This is because "
#~ "we used the `unwrapSingleConstructors` option when defining our JSON "
#~ "encoder."
#~ msgstr ""
#~ "保存ボタンをクリックすると、JSON文書への直列化を行う`encode`関数に"
#~ "`FormData`型の値が渡されます。`FormData`型はレコードのnewtypeで、`encode`"
#~ "が渡された`FormData`型の値はJSON**オブジェクト**として直列化されます。これ"
#~ "は、JSONエンコーダを定義する際に`unwrapSingleConstructors`オプションを指定"
#~ "したためです。"

#, fuzzy
#~ msgid ""
#~ "Our `Decode` type class instance is used with `decodeJSON` to parse the "
#~ "JSON document when it is retrieved from local storage, as follows:"
#~ msgstr ""
#~ "この`Decode`型クラスのインスタンスは、`decodeJSON`とともにローカル·スト"
#~ "レージから取得したJSON文書を解析するために次のように使われています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "loadSavedData = do\n"
#~ "  item <- getItem \"person\"\n"
#~ "\n"
#~ "  let\n"
#~ "    savedData :: Either (NonEmptyList ForeignError) (Maybe FormData)\n"
#~ "    savedData = runExcept do\n"
#~ "      jsonOrNull <- traverse readString =<< readNullOrUndefined item\n"
#~ "      traverse decodeJSON jsonOrNull\n"
#~ msgstr ""
#~ "loadSavedData = do\n"
#~ "  item <- getItem \"person\"\n"
#~ "\n"
#~ "  let\n"
#~ "    savedData :: Either (NonEmptyList ForeignError) (Maybe FormData)\n"
#~ "    savedData = runExcept do\n"
#~ "      jsonOrNull <- traverse readString =<< readNullOrUndefined item\n"
#~ "      traverse decodeJSON jsonOrNull\n"

#, fuzzy
#~ msgid ""
#~ "The `savedData` action reads the `FormData` structure in two steps: "
#~ "first, it parses the `Foreign` value obtained from `getItem`. The type of "
#~ "`jsonOrNull` is inferred by the compiler to be `Maybe String` (exercise "
#~ "for the reader - how is this type inferred?). The `traverse` function is "
#~ "then used to apply `decodeJSON` to the (possibly missing) element of the "
#~ "result of type `Maybe String`. The type class instance inferred for "
#~ "`decodeJSON` is the one we just wrote, resulting in a value of type `F "
#~ "(Maybe FormData)`."
#~ msgstr ""
#~ "`savedData`アクションは２つの手順にわけて `FormData`構造を読み取ります。ま"
#~ "ず、 `getItem`から得た `Foreign`値を解析します。 `jsonOrNull`の型はコンパ"
#~ "イラによって `Null String`だと推論されます(読者への演習：　この型はどのよ"
#~ "うに推論されているのでしょうか？)。 `traverse`関数は `readJSON`を `Maybe."
#~ "String`型の結果の(不足しているかもしれない)要素へと適用するのに使われま"
#~ "す。 `readJSON`について推論される型クラスのインスタンスはちょうどさっき書"
#~ "いたもので、型 `F (Maybe FormData)`の値で結果を返します。"

#, fuzzy
#~ msgid ""
#~ "We need to use the monadic structure of `F`, since the argument to "
#~ "`traverse` uses the result `jsonOrNull` obtained in the first line."
#~ msgstr ""
#~ "`traverse`の引数には `read`が最初の行で得た結果 `jsonOrNull`を使っているの"
#~ "で、 `F`のモナド構造を使う必要があります。"

#, fuzzy
#~ msgid "There are three possibilities for the result of `FormData`:"
#~ msgstr "結果の `FormData`には3つの可能性があります。"

#, fuzzy
#~ msgid ""
#~ "- If the outer constructor is `Left`, then there was an error parsing the "
#~ "JSON string, or it represented a value of the wrong type. In this case, "
#~ "the application displays an error using the `alert` action we wrote "
#~ "earlier.  - If the outer constructor is `Right`, but the inner "
#~ "constructor is `Nothing`, then `getItem` also returned `Nothing` which "
#~ "means that the key did not exist in local storage. In this case, the "
#~ "application continues quietly.  - Finally, a value matching the pattern "
#~ "`Right (Just _)` indicates a successfully parsed JSON document. In this "
#~ "case, the application updates the form fields with the appropriate values."
#~ msgstr ""
#~ "- もし外側の構築子が `Left`なら、JSON文字列の解析中にエラーがあったか、そ"
#~ "れが間違った型の値を表しています。この場合、アプリケーションは先ほど書い"
#~ "た `alert`アクションを使用してエラーを表示します。 - もし外側の構築子が "
#~ "`Right`で内側の構築子が `Nothing`なら、 `getItem`が `Nothing`を返してお"
#~ "り、キーがローカルストレージに存在していなかったことを意味しています。この"
#~ "場合、アプリケーションは静かに実行を継続します。 - 最後に、 `Right (Just "
#~ "_)`に適合した値はJSON文書としてただしく構文解析されたことを示しています。"
#~ "この場合、アプリケーションは適切な値でフォームフィールドを更新します。"

#, fuzzy
#~ msgid ""
#~ "Try out the code, by running `pulp build -O --to dist/Main.js`, and then "
#~ "opening the browser to `html/index.html`. You should be able to save the "
#~ "form fields' contents to local storage by clicking the Save button, and "
#~ "then see the fields repopulated when the page is refreshed."
#~ msgstr ""
#~ "`pulp build -O --to dist/Main.js`を実行してコードを試してから、ブラウザで "
#~ "`html/index.html`を開いてください。 保存ボタンをクリックするとフォーム"
#~ "フィールドの内容をローカルストレージへ保存することができ、ページを再読込す"
#~ "るとフィールドが再現されるはずです。"

#, fuzzy
#~ msgid ""
#~ "_Note_: You may need to serve the HTML and Javascript files from a HTTP "
#~ "server locally in order to avoid certain browser-specific issues."
#~ msgstr ""
#~ "**注意**：ブラウザ特有の問題を避けるために、ローカルなHTTPサーバからHTML"
#~ "ファイルとJavaScriptファイルを提供する必要があるかもしれません。\n"

#, fuzzy
#~ msgid ""
#~ "(Easy) Use `decodeJSON` to parse a JSON document representing a two-"
#~ "dimensional JavaScript array of integers, such as `[[1, 2, 3], [4, 5], "
#~ "[6]]`. What if the elements are allowed to be null? What if the arrays "
#~ "themselves are allowed to be null?"
#~ msgstr ""
#~ "(簡単)`decodeJSON`を使って、 `[[1, 2, 3], [4, 5], [6]]`のようなJavaScript"
#~ "の数の２次元配列を表現するJSON文書を解析してください。要素をnullにすること"
#~ "が許容されている場合はどうでしょうか。配列自体をnullにすることが許容されて"
#~ "いる場合はどうなりますか。"

#, fuzzy
#~ msgid ""
#~ "(Medium) Convince yourself that the implementation of `savedData` should "
#~ "type-check, and write down the inferred types of each subexpression in "
#~ "the computation."
#~ msgstr ""
#~ "(やや難しい)`savedData`の実装の型を検証し、計算のそれぞれの部分式の推論さ"
#~ "れた型を書き出してみましょう。"

#, fuzzy
#~ msgid ""
#~ "(Medium) The following data type represents a binary tree with values at "
#~ "the leaves:"
#~ msgstr "(難しい)次のデータ型は、葉で値を持つ二分木を表しています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    Derive `Encode` and `Decode` instances for this type using `purescript-foreign-generic`, and verify that encoded values can correctly be decoded in PSCi.\n"
#~ "1. (Difficult) The following `data` type should be represented directly in JSON as either an integer or a string:\n"
#~ msgstr ""
#~ "    `purescript-foreign-generic`を使ってこのタイプの `Encode`と `Decode`インスタンスを導き、エンコードされた値がPSCiで正しくデコードできることを確認してください。\n"
#~ "1. (難しい) 次の`data`型は、整数か文字列のどちらかであるJSONを直接表現しています。 \n"

#, fuzzy
#~ msgid "It is also necessary to install the `yargs` module using NPM:"
#~ msgstr ""
#~ "また、NPMを使って `yargs`モジュールをインストールする必要があります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "node ./dist/Main.js -p <player name>\n"
#~ "\n"
#~ "Options:\n"
#~ "  -p, --player  Player name  [required]\n"
#~ "  -d, --debug   Use debug mode\n"
#~ "\n"
#~ "Missing required arguments: p\n"
#~ "The player name is required\n"
#~ msgstr ""
#~ "node ./dist/Main.js -p <player name>\n"
#~ "\n"
#~ "Options:\n"
#~ "  -p, --player  Player name  [required]\n"
#~ "  -d, --debug   Use debug mode\n"
#~ "\n"
#~ "Missing required arguments: p\n"
#~ "The player name is required\n"

#, fuzzy
#~ msgid ""
#~ "This looks very similar to the API provided by the `REF` and `ST` "
#~ "effects. However, notice that we do not pass a mutable reference cell "
#~ "such as a `Ref` or `STRef` to the actions. The difference between `State` "
#~ "and the solutions provided by the `Eff` monad is that the `State` monad "
#~ "only supports a single piece of state which is implicit - the state is "
#~ "implemented as a function argument hidden by the `State` monad's data "
#~ "constructor, so there is no explicit reference to pass around."
#~ msgstr ""
#~ "これは `REF`作用や `ST`作用が提供するAPIととてもよく似ています。しかし、こ"
#~ "れらのアクションに `Ref`や `STRef`に渡しているような、可変領域への参照を引"
#~ "数に渡さないことに注意してください。 `State`と `Eff`モナドが提供する解決策"
#~ "の違いは、 `State`モナドは暗黙的な単一の状態だけを提供していることです。こ"
#~ "の状態は `State`モナドの型構築子によって隠された関数の引数として実装されて"
#~ "おり、参照は明示的には渡されないのです。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "split :: Parser String\n"
#~ "split = do\n"
#~ "  s <- get\n"
#~ "  tell [\"The state is \" <> show s]\n"
#~ "  case s of\n"
#~ "    \"\" -> throwError \"Empty string\"\n"
#~ "    _ -> do\n"
#~ "      put (drop 1 s)\n"
#~ "      pure (take 1 s)\n"
#~ msgstr ""
#~ "split :: Parser String\n"
#~ "split = do\n"
#~ "  s <- get\n"
#~ "  tell [\"The state is \" <> show s]\n"
#~ "  case s of\n"
#~ "    \"\" -> throwError \"Empty string\"\n"
#~ "    _ -> do\n"
#~ "      put (drop 1 s)\n"
#~ "      pure (take 1 s)\n"

#, fuzzy
#~ msgid ""
#~ "Other examples of `Alternative` type constructors are `Maybe` and `Array`."
#~ msgstr ""
#~ "`Alternative`型構築子の他の例としては、 `Maybe`や、 `Array`つまり配列の型"
#~ "構築子があります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "upper :: Parser String\n"
#~ "upper = do\n"
#~ "  s <- split\n"
#~ "  guard $ toUpper s == s\n"
#~ "  pure s\n"
#~ msgstr ""
#~ "upper :: Parser String\n"
#~ "upper = do\n"
#~ "  s <- split\n"
#~ "  guard $ toUpper s == s\n"
#~ "  pure s\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "lower :: Parser String\n"
#~ "lower = do\n"
#~ "  s <- split\n"
#~ "  guard $ toLower s == s\n"
#~ "  pure s\n"
#~ msgstr ""
#~ "lower :: Parser String\n"
#~ "lower = do\n"
#~ "  s <- split\n"
#~ "  guard $ toLower s == s\n"
#~ "  pure s\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type PlayerName = String\n"
#~ "\n"
#~ "newtype GameEnvironment = GameEnvironment\n"
#~ "  { playerName    :: PlayerName\n"
#~ "  , debugMode     :: Boolean\n"
#~ "  }\n"
#~ msgstr ""
#~ "type PlayerName = String\n"
#~ "\n"
#~ "newtype GameEnvironment = GameEnvironment\n"
#~ "  { playerName    :: PlayerName\n"
#~ "  , debugMode     :: Boolean\n"
#~ "  }\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import qualified Data.Map as M\n"
#~ "import qualified Data.Set as S\n"
#~ "\n"
#~ "newtype GameState = GameState\n"
#~ "  { items       :: M.Map Coords (S.Set GameItem)\n"
#~ "  , player      :: Coords\n"
#~ "  , inventory   :: S.Set GameItem\n"
#~ "  }\n"
#~ msgstr ""
#~ "import qualified Data.Map as M\n"
#~ "import qualified Data.Set as S\n"
#~ "\n"
#~ "newtype GameState = GameState\n"
#~ "  { items       :: M.Map Coords (S.Set GameItem)\n"
#~ "  , player      :: Coords\n"
#~ "  , inventory   :: S.Set GameItem\n"
#~ "  }\n"

#, fuzzy, no-wrap
#~ msgid "data GameItem = Candle | Matches\n"
#~ msgstr "data GameItem = Candle | Matches\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "type Log = L.List String\n"
#~ "\n"
#~ "type Game = RWS GameEnvironment Log GameState\n"
#~ msgstr ""
#~ "type Log = L.List String\n"
#~ "\n"
#~ "type Game = RWS GameEnvironment Log GameState\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "has :: GameItem -> Game Boolean\n"
#~ "has item = do\n"
#~ "  GameState state <- get\n"
#~ "  pure $ item `S.member` state.inventory\n"
#~ msgstr ""
#~ "has :: GameItem -> Game Boolean\n"
#~ "has item = do\n"
#~ "  GameState state <- get\n"
#~ "  pure $ item `S.member` state.inventory\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "pickUp :: GameItem -> Game Unit\n"
#~ "pickUp item = do\n"
#~ "  GameState state <- get\n"
#~ msgstr ""
#~ "pickUp :: GameItem -> Game Unit\n"
#~ "pickUp item = do\n"
#~ "  GameState state <- get\n"

#, fuzzy, no-wrap
#~ msgid "  case state.player `M.lookup` state.items of\n"
#~ msgstr "  case state.player `M.lookup` state.items of\n"

#, fuzzy, no-wrap
#~ msgid "    Just items | item `S.member` items -> do\n"
#~ msgstr "    Just items | item `S.member` items -> do\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "      let newItems = M.update (Just <<< S.delete item) state.player state.items\n"
#~ "          newInventory = S.insert item state.inventory\n"
#~ "      put $ GameState state { items     = newItems\n"
#~ "                            , inventory = newInventory\n"
#~ "                            }\n"
#~ "      tell (L.singleton (\"You now have the \" <> show item))\n"
#~ msgstr ""
#~ "      let newItems = M.update (Just <<< S.delete item) state.player state.items\n"
#~ "          newInventory = S.insert item state.inventory\n"
#~ "      put $ GameState state { items     = newItems\n"
#~ "                            , inventory = newInventory\n"
#~ "                            }\n"
#~ "      tell (L.singleton (\"You now have the \" <> show item))\n"

#, fuzzy, no-wrap
#~ msgid "    _ -> tell (L.singleton \"I don't see that item here.\")\n"
#~ msgstr "    _ -> tell (L.singleton \"I don't see that item here.\")\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  GameEnvironment env <- ask\n"
#~ "  if env.debugMode\n"
#~ "    then do\n"
#~ "      state <- get\n"
#~ "      tell (L.singleton (show state))\n"
#~ "    else tell (L.singleton \"Not running in debug mode.\")\n"
#~ msgstr ""
#~ "  GameEnvironment env <- ask\n"
#~ "  if env.debugMode\n"
#~ "    then do\n"
#~ "      state <- get\n"
#~ "      tell (L.singleton (show state))\n"
#~ "    else tell (L.singleton \"Not running in debug mode.\")\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "runGame\n"
#~ "  :: forall eff\n"
#~ "   . GameEnvironment\n"
#~ "  -> Eff ( exception :: EXCEPTION\n"
#~ "         , readline :: RL.READLINE\n"
#~ "         , console :: CONSOLE\n"
#~ "         | eff\n"
#~ "         ) Unit\n"
#~ msgstr ""
#~ "runGame :: forall eff . GameEnvironment\n"
#~ "  -> Eff ( exception :: EXCEPTION\n"
#~ "         , readline :: RL.READLINE\n"
#~ "         , console :: CONSOLE\n"
#~ "         | eff\n"
#~ "         ) Unit\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "runGame env = do\n"
#~ "  interface <- createConsoleInterface noCompletion\n"
#~ msgstr ""
#~ "runGame env = do\n"
#~ "  interface <- createConsoleInterface noCompletion\n"

#, fuzzy, no-wrap
#~ msgid "  setPrompt \"> \" 2 interface\n"
#~ msgstr "setPrompt \"> \" 2 interface\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "lineHandler\n"
#~ "  :: GameState\n"
#~ "  -> String\n"
#~ "  -> Eff ( exception :: EXCEPTION\n"
#~ "         , console :: CONSOLE\n"
#~ "         , readline :: RL.READLINE\n"
#~ "         | eff\n"
#~ "         ) Unit\n"
#~ "lineHandler currentState input = do\n"
#~ "  case runRWS (game (split \" \" input)) env currentState of\n"
#~ "    RWSResult state _ written -> do\n"
#~ "      for_ written log\n"
#~ "      setLineHandler interface $ lineHandler state\n"
#~ "  prompt interface\n"
#~ "  pure unit\n"
#~ msgstr ""
#~ "lineHandler :: GameState -> String\n"
#~ "             -> Eff ( exception :: EXCEPTION\n"
#~ "                    , console :: CONSOLE\n"
#~ "                    , readline :: RL.READLINE\n"
#~ "                    | eff\n"
#~ "                    ) Unit\n"
#~ "lineHandler currentState input = do\n"
#~ "  case runRWS (game (split \" \" input)) env currentState of\n"
#~ "    RWSResult state _ written -> do\n"
#~ "      for_ written log\n"
#~ "      setLineHandler interface $ lineHandler state\n"
#~ "  prompt interface\n"
#~ "  pure unit\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  setLineHandler interface $ lineHandler initialGameState\n"
#~ "  prompt interface\n"
#~ msgstr ""
#~ "  setLineHandler interface $ lineHandler initialGameState\n"
#~ "  prompt interface\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "runY :: forall a eff.\n"
#~ "          YargsSetup ->\n"
#~ "          Y (Eff (exception :: EXCEPTION, console :: CONSOLE | eff) a) ->\n"
#~ "             Eff (exception :: EXCEPTION, console :: CONSOLE | eff) a\n"
#~ msgstr ""
#~ "runY :: forall a eff. YargsSetup ->\n"
#~ "                      Y (Eff (exception :: EXCEPTION, console :: CONSOLE | eff) a) ->\n"
#~ "                      Eff (exception :: EXCEPTION, console :: CONSOLE | eff) a\n"

#, fuzzy, no-wrap
#~ msgid "main = runY (usage \"$0 -p <player name>\") $ map runGame env\n"
#~ msgstr "main = runY (usage \"$0 -p <player name>\") $ map runGame env\n"

#, fuzzy, no-wrap
#~ msgid "The second argument uses the `map` function to lift the `runGame` function over the `Y` type constructor. The argument `env` is constructed in a `where` declaration using the applicative operators `<$>` and `<*>`:\n"
#~ msgstr "2番目の引数では、 `Y`型構築子まで `runGame`関数を持ち上げるために `<$>`コンビネータを使用しています。引数 `env`は `where`節でApplicative演算子 `<$>`、 `<*>`を使って構築されています。\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "  where\n"
#~ "  env :: Y GameEnvironment\n"
#~ "  env = gameEnvironment\n"
#~ "          <$> yarg \"p\" [\"player\"]\n"
#~ "                   (Just \"Player name\")\n"
#~ "                   (Right \"The player name is required\")\n"
#~ "                   false\n"
#~ "          <*> flag \"d\" [\"debug\"]\n"
#~ "                   (Just \"Use debug mode\")\n"
#~ msgstr ""
#~ "  where\n"
#~ "  env :: Y GameEnvironment\n"
#~ "  env = gameEnvironment\n"
#~ "          <$> yarg \"p\" [\"player\"]\n"
#~ "                   (Just \"Player name\")\n"
#~ "                   (Right \"The player name is required\")\n"
#~ "                   false\n"
#~ "          <*> flag \"d\" [\"debug\"]\n"
#~ "                   (Just \"Use debug mode\")\n"

#, fuzzy, no-wrap
#~ msgid "Here, the `gameEnvironment` function, which has the type `PlayerName -> Boolean -> GameEnvironment`, is lifted over `Y`. The two arguments specify how to read the player name and debug flag from the command line options. The first argument describes the player name option, which is specified by the `-p` or `--player` options, and the second describes the debug mode flag, which is turned on using the `-d` or `--debug` options.\n"
#~ msgstr "`PlayerName -> Boolean -> GameEnvironment`という型を持つこの `gameEnvironment`関数は、 `Y`まで持ち上げられています。このふたつの引数は、コマンドラインオプションからプレイヤー名とデバッグフラグを読み取る方法を指定しています。最初の引数は `-p`もしくは `--player`オプションで指定されるプレイヤー名オプションについて記述しており、２つ目の引数は `-d`もしくは `--debug`オプションで指定されるデバッグモードフラグについて記述しています。\n"

#, fuzzy
#~ msgid ""
#~ "This demonstrates two basic functions defined in the `Node.Yargs."
#~ "Applicative` module: `yarg`, which defines a command line option which "
#~ "takes an optional argument (of type `String`, `Number` or `Boolean`), and "
#~ "`flag` which defines a command line flag of type `Boolean`."
#~ msgstr ""
#~ "これは `Node.Yargs.Applicative`モジュールで定義されているふたつの基本的な"
#~ "関数について示しています。 `yarg`は(型 `String`、 `Number`、 `Boolean`の)"
#~ "オプショナルな引数を取りコマンドラインオプションを定義し、 `flag`は型 "
#~ "`Boolean`のコマンドラインフラグを定義しています。"

#, fuzzy
#~ msgid ""
#~ "In the next chapter, we will see how monad transformers can be used to "
#~ "give an elegant solution to a common complaint when working with "
#~ "asynchronous JavaScript code - the problem of _callback hell_."
#~ msgstr ""
#~ "次の章では、非同期なJavaScriptのコードにありがちな不満、**コールバック地獄"
#~ "**の問題に対して、モナド変換子がどのような洗練された解決策を与えるのかを見"
#~ "ていきます。"

#, fuzzy, no-wrap
#~ msgid "Callback Hell"
#~ msgstr "コールバック地獄"

#, fuzzy
#~ msgid ""
#~ "In this chapter, we will see how the tools we have seen so far - namely "
#~ "monad transformers and applicative functors - can be put to use to solve "
#~ "real-world problems. In particular, we will see how we can solve the "
#~ "problem of _callback hell_."
#~ msgstr ""
#~ "この章では、これまでに見てきたモナド変換子やApplicative関手といった道具"
#~ "が、現実世界の問題解決にどのように役立つかを見ていきましょう。ここでは特"
#~ "に、**コールバック地獄**(callback hell)の問題を解決について見ていきます。"

#, fuzzy
#~ msgid ""
#~ "The source code for this chapter can be compiled and run using `pulp "
#~ "run`. It is also necessary to install the `request` module using NPM:"
#~ msgstr ""
#~ "この章のソースコードは、 `pulp run`を使ってコンパイルして実行することがで"
#~ "きます。 また、 `request`モジュールをNPMを使ってインストールする必要があり"
#~ "ます。"

#, fuzzy, no-wrap
#~ msgid "The Problem"
#~ msgstr "問題"

#, fuzzy
#~ msgid ""
#~ "Asynchronous code in JavaScript typically uses _callbacks_ to structure "
#~ "program flow. For example, to read text from a file, the preferred "
#~ "approach is to use the `readFile` function and to pass a callback - a "
#~ "function that will be called when the text is available:"
#~ msgstr ""
#~ "通常、JavaScriptの非同期処理コードでは、プログラムの流れを構造化するために"
#~ "**コールバック**(callbacks)を使用します。たとえば、ファイルからテキストを"
#~ "読み取るのに好ましいアプローチとしては、 `readFile`関数を使用し、コール"
#~ "バック、つまりテキストが利用可能になったときに呼び出される関数を渡すことで"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "function readText(onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.readFile('file1.txt', { encoding: 'utf-8' }, function (error, data) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      onSuccess(data);\n"
#~ "    }   \n"
#~ "  });\n"
#~ "}\n"
#~ msgstr ""
#~ "function readText(onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.readFile('file1.txt', { encoding: 'utf-8' }, function (error, data) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      onSuccess(data);\n"
#~ "    }   \n"
#~ "  });\n"
#~ "}\n"

#, fuzzy
#~ msgid ""
#~ "However, if multiple asynchronous operations are involved, this can "
#~ "quickly lead to nested callbacks, which can result in code which is "
#~ "difficult to read:"
#~ msgstr ""
#~ "しかしながら、複数の非同期操作が関与している場合には入れ子になったコール"
#~ "バックを生じることになり、すぐに読めないコードになってしまいます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "function copyFile(onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.readFile('file1.txt', { encoding: 'utf-8' }, function (error, data1) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      fs.writeFile('file2.txt', data, { encoding: 'utf-8' }, function (error) {\n"
#~ "        if (error) {\n"
#~ "          onFailure(error.code);\n"
#~ "        } else {\n"
#~ "          onSuccess();\n"
#~ "        }\n"
#~ "      });\n"
#~ "    }   \n"
#~ "  });\n"
#~ "}\n"
#~ msgstr ""
#~ "function copyFile(onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.readFile('file1.txt', { encoding: 'utf-8' }, function (error, data1) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      fs.writeFile('file2.txt', data, { encoding: 'utf-8' }, function (error) {\n"
#~ "        if (error) {\n"
#~ "          onFailure(error.code);\n"
#~ "        } else {\n"
#~ "          onSuccess();\n"
#~ "        }\n"
#~ "      });\n"
#~ "    }   \n"
#~ "  });\n"
#~ "} \n"

#, fuzzy
#~ msgid ""
#~ "One solution to this problem is to break out individual asynchronous "
#~ "calls into their own functions:"
#~ msgstr ""
#~ "この問題に対する解決策のひとつとしては、独自の関数に個々の非同期呼び出しを"
#~ "分割することです。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "function writeCopy(data, onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.writeFile('file2.txt', data, { encoding: 'utf-8' }, function (error) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      onSuccess();\n"
#~ "    }\n"
#~ "  });\n"
#~ "}\n"
#~ "\n"
#~ "function copyFile(onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.readFile('file1.txt', { encoding: 'utf-8' }, function (error, data) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      writeCopy(data, onSuccess, onFailure);\n"
#~ "    }   \n"
#~ "  });\n"
#~ "}\n"
#~ msgstr ""
#~ "function writeCopy(data, onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.writeFile('file2.txt', data, { encoding: 'utf-8' }, function (error) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      onSuccess();\n"
#~ "    }\n"
#~ "  });\n"
#~ "}\n"
#~ "\n"
#~ "function copyFile(onSuccess, onFailure) {\n"
#~ "  var fs = require('fs');\n"
#~ "  fs.readFile('file1.txt', { encoding: 'utf-8' }, function (error, data) {\n"
#~ "    if (error) {\n"
#~ "      onFailure(error.code);\n"
#~ "    } else {\n"
#~ "      writeCopy(data, onSuccess, onFailure);\n"
#~ "    }   \n"
#~ "  });\n"
#~ "} \n"

#, fuzzy
#~ msgid "This solution works but has some issues:"
#~ msgstr "この解決策は一応は機能しますが、いくつか問題があります。"

#, fuzzy
#~ msgid ""
#~ "- It is necessary to pass intermediate results to asynchronous functions "
#~ "as function arguments, in the same way that we passed `data` to "
#~ "`writeCopy` above. This is fine for small functions, but if there are "
#~ "many callbacks involved, the data dependencies can become complex, "
#~ "resulting in many additional function arguments.  - There is a common "
#~ "pattern - the callbacks `onSuccess` and `onFailure` are usually specified "
#~ "as arguments to every asynchronous function - but this pattern has to be "
#~ "documented in module documentation which accompanies the source code. It "
#~ "is better to capture this pattern in the type system, and to use the type "
#~ "system to enforce its use."
#~ msgstr ""
#~ "- 上で `writeCopy`へ `data`を渡したのと同じ方法で、非同期関数に関数の引数"
#~ "として途中の結果を渡さなければなりません。これは小さな関数についてはうまく"
#~ "いきますが、多くのコールバック関係する場合はデータの依存関係は複雑になるこ"
#~ "とがあり、関数の引数が大量に追加される結果になります。 - どんな非同期関数"
#~ "でもコールバック `onSuccess`と `onFailure`が引数として定義されるという共通"
#~ "のパターンがありますが、このパターンはソースコードに付随したモジュールのド"
#~ "キュメントに記述することで実施しなければなりません。このパターンを管理する"
#~ "には型システムのほうがよいですし、型システムで使い方を強制しておくほうがい"
#~ "いでしょう。"

#, fuzzy
#~ msgid ""
#~ "Next, we will see how to use the techniques we have learned so far to "
#~ "solve these issues."
#~ msgstr ""
#~ "次に、これらの問題を解決するために、これまでに学んだ手法を使用する方法につ"
#~ "いて説明していきます。"

#, fuzzy, no-wrap
#~ msgid "The Continuation Monad"
#~ msgstr "継続モナド"

#, fuzzy
#~ msgid ""
#~ "Let's translate the `copyFile` example above into PureScript by using the "
#~ "FFI. In doing so, the structure of the computation will become apparent, "
#~ "and we will be led naturally to a monad transformer which is defined in "
#~ "the `purescript-transformers` package - the continuation monad "
#~ "transformer `ContT`."
#~ msgstr ""
#~ "`copyFile`の例をFFIを使ってPureScriptへと翻訳していきましょう。 PureScript"
#~ "で書いていくにつれ、計算の構造はわかりやすくなり、 `purescript-"
#~ "transformers`パッケージで定義されている継続モナド変換子 `ContT`が自然に導"
#~ "入されることになるでしょう。"

#, fuzzy
#~ msgid ""
#~ "_Note_: in practice, it is not necessary to write these functions by hand "
#~ "every time. Asynchronous file IO functions can be found in the "
#~ "`purescript-node-fs` and `purescript-node-fs-aff` libraries."
#~ msgstr ""
#~ "_Note_: in practice, it is not necessary to write these functions by hand "
#~ "every time. Asynchronous file IO functions can be found in the "
#~ "`purescript-node-fs` and `purescript-node-fs-aff` libraries."

#, fuzzy
#~ msgid ""
#~ "First, we need to gives types to `readFile` and `writeFile` using the "
#~ "FFI. Let's start by defining some type synonyms, and a new effect for "
#~ "file IO:"
#~ msgstr ""
#~ "まず、FFIを使って `readFile`と `writeFile`に型を与えなくてはなりません。型"
#~ "同義語をいくつかと、ファイル入出力のための作用を定義することから始めましょ"
#~ "う。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "foreign import data FS :: Effect\n"
#~ "\n"
#~ "type ErrorCode = String\n"
#~ "type FilePath = String\n"
#~ msgstr ""
#~ "foreign import data FS :: Effect\n"
#~ "\n"
#~ "type ErrorCode = String\n"
#~ "type FilePath = String\n"

#, fuzzy
#~ msgid ""
#~ "`readFile` takes a filename and a callback which takes two arguments. If "
#~ "the file was read successfully, the second argument will contain the file "
#~ "contents, and if not, the first argument will be used to indicate the "
#~ "error."
#~ msgstr ""
#~ "`readFile`はファイル名と2引数のコールバックを引数に取ります。ファイルが正"
#~ "常に読み込まれた場合は、2番目の引数にはファイルの内容が含まれますが、そう"
#~ "でない場合は、最初の引数がエラーを示すために使われます。"

#, fuzzy
#~ msgid ""
#~ "In our case, we will wrap `readFile` with a function which takes two "
#~ "callbacks: an error callback (`onFailure`) and a result callback "
#~ "(`onSuccess`), much like we did with `copyFile` and `writeCopy` above. "
#~ "Using the multiple-argument function support from `Data.Function` for "
#~ "simplicity, our wrapped function `readFileImpl` might look like this:"
#~ msgstr ""
#~ "今回は `readFile`を2つのコールバックを引数としてとる関数としてラップするこ"
#~ "とにします。先ほどの `copyFile`や `writeCopy`とまったく同じように、エラー"
#~ "コールバック(`onFailure`)と結果コールバック(`onSuccess`)の2つです。簡単の"
#~ "ために `Data.Function`の多引数関数の機能を使うと、このラップされた関数 "
#~ "`readFileImpl`は次のようになるでしょう。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "foreign import readFileImpl\n"
#~ "  :: forall eff\n"
#~ "   . Fn3 FilePath\n"
#~ "         (String -> Eff (fs :: FS | eff) Unit)\n"
#~ "         (ErrorCode -> Eff (fs :: FS | eff) Unit)\n"
#~ "         (Eff (fs :: FS | eff) Unit)\n"
#~ msgstr ""
#~ "foreign import readFileImpl\n"
#~ "  :: forall eff\n"
#~ "   . Fn3 FilePath\n"
#~ "         (String -> Eff (fs :: FS | eff) Unit)\n"
#~ "         (ErrorCode -> Eff (fs :: FS | eff) Unit)\n"
#~ "         (Eff (fs :: FS | eff) Unit)\n"

#, fuzzy
#~ msgid ""
#~ "In the foreign Javascript module, `readFileImpl` would be defined as:"
#~ msgstr ""
#~ "外部JavaScriptモジュールでは、`readFileImpl`は次のように定義されます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "exports.readFileImpl = function(path, onSuccess, onFailure) {\n"
#~ "  return function() {\n"
#~ "    require('fs').readFile(path, {\n"
#~ "      encoding: 'utf-8'\n"
#~ "    }, function(error, data) {\n"
#~ "      if (error) {\n"
#~ "        onFailure(error.code)();\n"
#~ "      } else {\n"
#~ "        onSuccess(data)();\n"
#~ "      }\n"
#~ "    });\n"
#~ "  };\n"
#~ "};\n"
#~ msgstr ""
#~ "exports.readFileImpl = function(path, onSuccess, onFailure) {\n"
#~ "  return function() {\n"
#~ "    require('fs').readFile(path, {\n"
#~ "      encoding: 'utf-8'\n"
#~ "    }, function(error, data) {\n"
#~ "      if (error) {\n"
#~ "        onFailure(error.code)();\n"
#~ "      } else {\n"
#~ "        onSuccess(data)();\n"
#~ "      }\n"
#~ "    });\n"
#~ "  };\n"
#~ "};\n"

#, fuzzy
#~ msgid ""
#~ "This type signature indicates that `readFileImpl` takes three arguments: "
#~ "a file path, a success callback and an error callback, and returns an "
#~ "effectful computation which returns an empty (`Unit`) result. Notice that "
#~ "the callbacks themselves are given types which use the `Eff` monad to "
#~ "track their effects."
#~ msgstr ""
#~ "`readFileImpl`はファイルパス、成功時のコールバック、失敗時のコールバックと"
#~ "いう３つの引数を取り、空(`Unit`)の結果を返す副作用のある計算を返す、という"
#~ "ことをこの型は言っています。コー​​ルバック自身にも、その作用を追跡するため"
#~ "に `Eff`モナドを使うような型が与えられていることに注意してください。"

#, fuzzy
#~ msgid ""
#~ "You should try to understand why this implementation has the correct "
#~ "runtime representation for its type."
#~ msgstr ""
#~ "この `readFileImpl`の実装がその型の正しい実行時表現を持っている理由を、よ"
#~ "く理解しておくようにしてください。"

#, fuzzy
#~ msgid ""
#~ "`writeFileImpl` is very similar - it is different only in that the file "
#~ "content is passed to the function itself, not to the callback. Its "
#~ "implementation looks like this:"
#~ msgstr ""
#~ "`writeFileImpl`もよく似ています。違いはファイルがコールバックではなく関数"
#~ "自身に渡されるということだけです。実装は次のようになります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "foreign import writeFileImpl\n"
#~ "  :: forall eff\n"
#~ "   . Fn4 FilePath\n"
#~ "         String\n"
#~ "         (Eff (fs :: FS | eff) Unit)\n"
#~ "         (ErrorCode -> Eff (fs :: FS | eff) Unit)\n"
#~ "         (Eff (fs :: FS | eff) Unit)\n"
#~ msgstr ""
#~ "foreign import writeFileImpl\n"
#~ "  :: forall eff\n"
#~ "   . Fn4 FilePath\n"
#~ "         String\n"
#~ "         (Eff (fs :: FS | eff) Unit)\n"
#~ "         (ErrorCode -> Eff (fs :: FS | eff) Unit)\n"
#~ "         (Eff (fs :: FS | eff) Unit)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "exports.writeFileImpl = function(path, data, onSuccess, onFailure) {\n"
#~ "  return function() {\n"
#~ "    require('fs').writeFile(path, data, {\n"
#~ "      encoding: 'utf-8'\n"
#~ "    }, function(error) {\n"
#~ "      if (error) {\n"
#~ "        onFailure(error.code)();\n"
#~ "      } else {\n"
#~ "        onSuccess();\n"
#~ "      }\n"
#~ "    });\n"
#~ "  };\n"
#~ "};\n"
#~ msgstr ""
#~ "exports.writeFileImpl = function(path, data, onSuccess, onFailure) {\n"
#~ "  return function() {\n"
#~ "    require('fs').writeFile(path, data, {\n"
#~ "      encoding: 'utf-8'\n"
#~ "    }, function(error) {\n"
#~ "      if (error) {\n"
#~ "        onFailure(error.code)();\n"
#~ "      } else {\n"
#~ "        onSuccess();\n"
#~ "      }\n"
#~ "    });\n"
#~ "  };\n"
#~ "};\n"

#, fuzzy
#~ msgid ""
#~ "Given these FFI declarations, we can write the implementations of "
#~ "`readFile` and `writeFile`. These will use the `Data.Function.Uncurried` "
#~ "module to turn the multiple-argument FFI bindings into regular (curried) "
#~ "PureScript functions, and therefore have slightly more readable types."
#~ msgstr ""
#~ "これらのFFIの宣言が与えられれば、 `readFile`と `writeFile`の実装を書くこと"
#~ "ができます。 `Data.Function`ライブラリを使って、多引数のFFIバインディング"
#~ "を通常の(カリー化された)PureScript関数へと変換するので、もう少し読みやすい"
#~ "型になるでしょう。"

#, fuzzy
#~ msgid ""
#~ "In addition, instead of requiring two callbacks, one for successes and "
#~ "one for failures, we can require only a single callback which responds to "
#~ "_either_ successes or failures. That is, the new callback takes a value "
#~ "in the `Either ErrorCode` monad as its argument:"
#~ msgstr ""
#~ "さらに、成功時と失敗時の２つの必須のコールバックに代わって、成功か失敗の**"
#~ "どちらか**(Either) に対応した単一のコールバックを要求するようにします。つ"
#~ "まり、新しいコールバックは引数として `Either ErrorCode`モナドの値をとりま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "readFile\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> (Either ErrorCode String -> Eff (fs :: FS | eff) Unit)\n"
#~ "  -> Eff (fs :: FS | eff) Unit\n"
#~ "readFile path k =\n"
#~ "  runFn3 readFileImpl\n"
#~ "         path\n"
#~ "         (k <<< Right)\n"
#~ "         (k <<< Left)\n"
#~ "\n"
#~ "writeFile\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> String\n"
#~ "  -> (Either ErrorCode Unit -> Eff (fs :: FS | eff) Unit)\n"
#~ "  -> Eff (fs :: FS | eff) Unit\n"
#~ "writeFile path text k =\n"
#~ "  runFn4 writeFileImpl\n"
#~ "         path\n"
#~ "         text\n"
#~ "         (k $ Right unit)\n"
#~ "         (k <<< Left)\n"
#~ msgstr ""
#~ "readFile :: forall eff . FilePath\n"
#~ "  -> (Either ErrorCode String -> Eff (fs :: FS | eff) Unit)\n"
#~ "  -> Eff (fs :: FS | eff) Unit\n"
#~ "readFile path k =\n"
#~ "  runFn3 readFileImpl\n"
#~ "         path\n"
#~ "         (k <<< Right)\n"
#~ "         (k <<< Left)\n"
#~ "\n"
#~ "writeFile :: forall eff . FilePath\n"
#~ "  -> String\n"
#~ "  -> (Either ErrorCode Unit -> Eff (fs :: FS | eff) Unit)\n"
#~ "  -> Eff (fs :: FS | eff) Unit\n"
#~ "writeFile path text k =\n"
#~ "  runFn4 writeFileImpl\n"
#~ "         path\n"
#~ "         text\n"
#~ "         (k $ Right unit)\n"
#~ "         (k <<< Left)\n"

#, fuzzy
#~ msgid ""
#~ "Now we can spot an important pattern. Each of these functions takes a "
#~ "callback which returns a value in some monad (in this case `Eff (fs :: FS "
#~ "| eff)`) and returns a value in _the same monad_. This means that when "
#~ "the first callback returns a result, that monad can be used to bind the "
#~ "result to the input of the next asynchronous function. In fact, that's "
#~ "exactly what we did by hand in the `copyFile` example."
#~ msgstr ""
#~ "ここで、重要なパターンを見つけることができます。これらの関数は何らかのモナ"
#~ "ド(この場合は `Eff (fs :: FS | eff)`)で値を返すコールバックをとり、**同一"
#~ "のモナド**で値を返します。これは、最初のコールバックが結果を返したときに、"
#~ "そのモナドは次の非同期関数の入力に結合するためにその結果を使用することがで"
#~ "きることを意味しています。実際、 `copyFile`の例で手作業でやったことがまさ"
#~ "にそれです。"

#, fuzzy
#~ msgid ""
#~ "This is the basis of the _continuation monad transformer_, which is "
#~ "defined in the `Control.Monad.Cont.Trans` module in `purescript-"
#~ "transformers`."
#~ msgstr ""
#~ "これは `purescript-transformers`の `Control.Monad.Cont.Trans`モジュールで"
#~ "定義されている**継続モナド変換子**(continuation monad transformer)の基礎と"
#~ "なっています。"

#, fuzzy
#~ msgid "`ContT` is defined as a newtype as follows:"
#~ msgstr "`ContT`は次のようなnewtypeとして定義されます。"

#, fuzzy, no-wrap
#~ msgid "newtype ContT r m a = ContT ((a -> m r) -> m r)\n"
#~ msgstr "newtype ContT r m a = ContT ((a -> m r) -> m r)\n"

#, fuzzy
#~ msgid ""
#~ "A _continuation_ is just another name for a callback. A continuation "
#~ "captures the _remainder_ of a computation - in our case, what happens "
#~ "after a result has been provided after an asynchronous call."
#~ msgstr ""
#~ "**継続**(continuation)はコールバックの別名です。継続は計算の**残余"
#~ "**(remainder)を捕捉します。ここで「残余」とは、非同期呼び出しが行われ、結"
#~ "果が提供された後に起こることを指しています。\n"

#, fuzzy
#~ msgid ""
#~ "The argument to the `ContT` data constructor looks remarkably similar to "
#~ "the types of `readFile` and `writeFile`. In fact, if we take the type `a` "
#~ "to be the type `Either ErrorCode String`, `r` to be `Unit` and `m` to be "
#~ "the monad `Eff (fs :: FS | eff)`, we recover the right-hand side of the "
#~ "type of `readFile`."
#~ msgstr ""
#~ "`ContT`データ構築子の引数は `readFile`と `writeFile`の型ととてもよく似てい"
#~ "ます。実際、もし型`a`を`ErrorCode String`型、`r`を`Unit`、`m`をモナド"
#~ "`Eff(fs :: FS | eff)`というように選ぶと、`readFile`の型の右辺を復元するこ"
#~ "とができます。"

#, fuzzy
#~ msgid ""
#~ "This motivates the following type synonym, defining an `Async` monad, "
#~ "which we will use to compose asynchronous actions like `readFile` and "
#~ "`writeFile`:"
#~ msgstr ""
#~ "`readFile`や`writeFile`のような非同期のアクションを組み立てるために使う"
#~ "`Async`モナドを定義するため、次のような型同義語を導入します。"

#, fuzzy, no-wrap
#~ msgid "type Async eff = ContT Unit (Eff eff)\n"
#~ msgstr "type Async eff = ContT Unit (Eff eff)\n"

#, fuzzy
#~ msgid ""
#~ "For our purposes, we will always use `ContT` to transform the `Eff` "
#~ "monad, and the type `r` will always be `Unit`, but this is not required."
#~ msgstr ""
#~ "今回の目的では `Eff`モナドを変換するために常に `ContT`を使い、型 `r`は常"
#~ "に `Unit`になりますが、必ずそうしなければならないというわけではありませ"
#~ "ん。"

#, fuzzy
#~ msgid ""
#~ "We can treat `readFile` and `writeFile` as computations in the `Async` "
#~ "monad, by simply applying the `ContT` data constructor:"
#~ msgstr ""
#~ "`ContT`データ構築子を適用するだけで、 `readFile`と `writeFile`を `Async`モ"
#~ "ナドの計算として扱うことができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "readFileCont\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> Async (fs :: FS | eff) (Either ErrorCode String)\n"
#~ "readFileCont path = ContT $ readFile path\n"
#~ "\n"
#~ "writeFileCont\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> String\n"
#~ "  -> Async (fs :: FS | eff) (Either ErrorCode Unit)\n"
#~ "writeFileCont path text = ContT $ writeFile path text\n"
#~ msgstr ""
#~ "readFileCont\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> Async (fs :: FS | eff) (Either ErrorCode String)\n"
#~ "readFileCont path = ContT $ readFile path\n"
#~ "\n"
#~ "writeFileCont\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> String\n"
#~ "  -> Async (fs :: FS | eff) (Either ErrorCode Unit)\n"
#~ "writeFileCont path text = ContT $ writeFile path text\n"

#, fuzzy
#~ msgid ""
#~ "With that, we can write our copy-file routine by simply using do notation "
#~ "for the `ContT` monad transformer:"
#~ msgstr ""
#~ "ここで `ContT`モナド変換子に対してdo記法を使うだけで、ファイル複製処理を書"
#~ "くことができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "copyFileCont\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> FilePath\n"
#~ "  -> Async (fs :: FS | eff) (Either ErrorCode Unit)\n"
#~ "copyFileCont src dest = do\n"
#~ "  e <- readFileCont src\n"
#~ "  case e of\n"
#~ "    Left err -> pure $ Left err\n"
#~ "    Right content -> writeFileCont dest content\n"
#~ msgstr ""
#~ "copyFileCont\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> FilePath\n"
#~ "  -> Async (fs :: FS | eff) (Either ErrorCode Unit)\n"
#~ "copyFileCont src dest = do\n"
#~ "  e <- readFileCont src\n"
#~ "  case e of\n"
#~ "    Left err -> pure $ Left err\n"
#~ "    Right content -> writeFileCont dest content\n"

#, fuzzy
#~ msgid ""
#~ "Note how the asynchronous nature of `readFileCont` is hidden by the "
#~ "monadic bind expressed using do notation - this looks just like "
#~ "synchronous code, but the `ContT` monad is taking care of wiring our "
#~ "asynchronous functions together."
#~ msgstr ""
#~ "`readFileCont`の非同期性がdo記法によってモナドの束縛に隠されていることに注"
#~ "目してください。これはまさに同期的なコードのように見えますが、 `ContT`モナ"
#~ "ド変換子は非同期関数を書くのを手助けしているのです。"

#, fuzzy
#~ msgid ""
#~ "We can run this computation using the `runContT` handler by providing a "
#~ "continuation. The continuation represents _what to do next_, i.e. what to "
#~ "do when the asynchronous copy-file routine completes. For our simple "
#~ "example, we can just choose the `logShow` function as the continuation, "
#~ "which will print the result of type `Either ErrorCode Unit` to the "
#~ "console:"
#~ msgstr ""
#~ "継続を与えて `runContT`ハンドラを使うと、この計算を実行することができま"
#~ "す。この継続は**次に何をするか**、例えば非同期なファイル複製処理が完了した"
#~ "時に何をするか、を表しています。この簡単な例では、型 `Either ErrorCode "
#~ "Unit`の結果をコンソールに出力する `logShow`関数を単に継続として選んでいま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Monad.Eff.Console (logShow)\n"
#~ "import Control.Monad.Cont.Trans (runContT)\n"
#~ "\n"
#~ "main =\n"
#~ "  runContT\n"
#~ "    (copyFileCont \"/tmp/1.txt\" \"/tmp/2.txt\")\n"
#~ "    logShow\n"
#~ msgstr ""
#~ "import Prelude\n"
#~ "\n"
#~ "import Control.Monad.Eff.Console (logShow)\n"
#~ "import Control.Monad.Cont.Trans (runContT)\n"
#~ "\n"
#~ "main =\n"
#~ "  runContT\n"
#~ "    (copyFileCont \"/tmp/1.txt\" \"/tmp/2.txt\")\n"
#~ "    logShow\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Use the FFI to give an appropriate type to the `setTimeout` "
#~ "function. Write a wrapper function which uses the `Async` monad:"
#~ msgstr ""
#~ "(やや難しい) FFIを使って、 `setTimeout`関数に適切な型を与えてください。ま"
#~ "た、 `Async`モナドを使った次のようなラッパー関数を書いてください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    ```haskell\n"
#~ "    type Milliseconds = Int\n"
#~ msgstr ""
#~ "    ```haskell\n"
#~ "    type Milliseconds = Int\n"

#, fuzzy, no-wrap
#~ msgid "    foreign import data TIMEOUT :: Effect\n"
#~ msgstr "    foreign import data TIMEOUT :: Effect\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    setTimeoutCont\n"
#~ "      :: forall eff\n"
#~ "       . Milliseconds\n"
#~ "      -> Async (timeout :: TIMEOUT | eff) Unit\n"
#~ "    ```\n"
#~ msgstr ""
#~ "    setTimeoutCont\n"
#~ "      :: forall eff\n"
#~ "       . Milliseconds\n"
#~ "      -> Async (timeout :: TIMEOUT | eff) Unit\n"
#~ "    ```\n"

#, fuzzy, no-wrap
#~ msgid "Putting ExceptT To Work"
#~ msgstr "ExceptTを機能させる"

#, fuzzy
#~ msgid "This solution works, but it can be improved."
#~ msgstr "この方法はうまく動きますが、まだ改良の余地があります。"

#, fuzzy
#~ msgid ""
#~ "In the implementation of `copyFileCont`, we had to use pattern matching "
#~ "to analyze the result of the `readFileCont` computation (of type `Either "
#~ "ErrorCode String`) to determine what to do next. However, we know that "
#~ "the `Either` monad has a corresponding monad transformer, `ExceptT`, so "
#~ "it is reasonable to expect that we should be able to use `ExceptT` with "
#~ "`ContT` to combine the two effects of asynchronous computation and error "
#~ "handling."
#~ msgstr ""
#~ "`copyFileCont`の実装において、次に何をするかを決定するためには、パターン照"
#~ "合を使って(型 `Either ErrorCode String`の)`readFileCont`計算の結果を解析し"
#~ "なければなりません。しかしながら、 `Either`モナドは対応するモナド変換子 "
#~ "`ExceptT`を持っていることがわかっているので、 `ContT`を持つ `ExceptT`を"
#~ "使って非同期計算とエラー処理の２つの作用を結合できると期待するのは理にか"
#~ "なっています。"

#, fuzzy
#~ msgid ""
#~ "In fact, it is possible, and we can see why if we look at the definition "
#~ "of `ExceptT`:"
#~ msgstr ""
#~ "実際にそれは可能で、 `ExceptT`の定義を見ればそれがなぜかがわかります。"

#, fuzzy
#~ msgid ""
#~ "`ExceptT` simply changes the result of the underlying monad from `a` to "
#~ "`Either e a`. This means that we can rewrite `copyFileCont` by "
#~ "transforming our current monad stack with the `ExceptT ErrorCode` "
#~ "transformer. It is as simple as applying the `ExceptT` data constructor "
#~ "to our existing solution:"
#~ msgstr ""
#~ "`ExceptT`は基礎のモナドの結果を単純に `a`から `Either e a`に変更します。現"
#~ "在のモナドスタックを `ExceptT ErrorCode`変換子で変換するように、 "
#~ "`copyFileCont`を書き換えることができることを意味します。それは現在の方法"
#~ "に `ExceptT`データ構築子を適用するだけなので簡単です。型同義語を与えると、"
#~ "ここでも型シグネチャを整理することができます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "readFileContEx\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> ExceptT ErrorCode (Async (fs :: FS | eff)) String\n"
#~ "readFileContEx path = ExceptT $ readFileCont path\n"
#~ "\n"
#~ "writeFileContEx\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> String\n"
#~ "  -> ExceptT ErrorCode (Async (fs :: FS | eff)) Unit\n"
#~ "writeFileContEx path text = ExceptT $ writeFileCont path text\n"
#~ msgstr ""
#~ "readFileContEx\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> ExceptT ErrorCode (Async (fs :: FS | eff)) String\n"
#~ "readFileContEx path = ExceptT $ readFileCont path\n"
#~ "\n"
#~ "writeFileContEx\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> String\n"
#~ "  -> ExceptT ErrorCode (Async (fs :: FS | eff)) Unit\n"
#~ "writeFileContEx path text = ExceptT $ writeFileCont path text\n"

#, fuzzy
#~ msgid ""
#~ "Now, our copy-file routine is much simpler, since the asynchronous error "
#~ "handling is hidden inside the `ExceptT` monad transformer:"
#~ msgstr ""
#~ "非同期エラー処理が `ExceptT`モナド変換子の内部に隠されているので、このファ"
#~ "イル複製処理ははるかに単純になります。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "copyFileContEx\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> FilePath\n"
#~ "  -> ExceptT ErrorCode (Async (fs :: FS | eff)) Unit\n"
#~ "copyFileContEx src dest = do\n"
#~ "  content <- readFileContEx src\n"
#~ "  writeFileContEx dest content\n"
#~ msgstr ""
#~ "copyFileContEx\n"
#~ "  :: forall eff\n"
#~ "   . FilePath\n"
#~ "  -> FilePath\n"
#~ "  -> ExceptT ErrorCode (Async (fs :: FS | eff)) Unit\n"
#~ "copyFileContEx src dest = do\n"
#~ "  content <- readFileContEx src\n"
#~ "  writeFileContEx dest content\n"

#, fuzzy
#~ msgid ""
#~ "(Medium) Modify your solution which concatenated two files, using "
#~ "`ExceptT` to handle any errors."
#~ msgstr ""
#~ "(やや難しい) 任意のエラーを処理するために、 `ExceptT`を使用して2つのファイ"
#~ "ルを連結しする先ほどの解決策を書きなおしてください。"

#, fuzzy
#~ msgid ""
#~ "As another example of using `ContT` to handle asynchronous functions, "
#~ "we'll now look at the `Network.HTTP.Client` module from this chapter's "
#~ "source code. This module uses the `Async` monad to support asynchronous "
#~ "HTTP requests using the `request` module, which is available via NPM."
#~ msgstr ""
#~ "`ContT`を使って非同期機能を処理する例として、この章のソースコードの "
#~ "`Network.HTTP.Client`モジュールについても見ていきましょう。このモジュール"
#~ "では `Async`モナドを使用して、NodeJSの非同期を `request`モジュールを使って"
#~ "います。"

#, fuzzy
#~ msgid ""
#~ "The `request` module provides a function which takes a URL and a "
#~ "callback, makes a HTTP(S) request and invokes the callback when the "
#~ "response is available, or in the event of an error. Here is an example "
#~ "request:"
#~ msgstr ""
#~ "`request`モジュールは、URLとコールバックを受け取り、応答が利用可能なとき、"
#~ "またはエラーが発生したときにHTTP（S）リクエストを生成してコールバックを呼"
#~ "び出す関数を提供します。 リクエストの例を次に示します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "require('request')('http://purescript.org'), function(err, _, body) {\n"
#~ "  if (err) {\n"
#~ "    console.error(err);\n"
#~ "  } else {\n"
#~ "    console.log(body);\n"
#~ "  }\n"
#~ "});\n"
#~ msgstr ""
#~ "require('request')('http://purescript.org'), function(err, _, body) {\n"
#~ "  if (err) {\n"
#~ "    console.error(err);\n"
#~ "  } else {\n"
#~ "    console.log(body);\n"
#~ "  }\n"
#~ "});\n"

#, fuzzy
#~ msgid ""
#~ "We will recreate this simple example in PureScript using the `Async` "
#~ "monad."
#~ msgstr ""
#~ "`Async`モナドを使うと、この簡単な例をPureScriptで書きなおすことができま"
#~ "す。"

#, fuzzy
#~ msgid ""
#~ "In the `Network.HTTP.Client` module, the `request` method is wrapped with "
#~ "a function `getImpl`:"
#~ msgstr ""
#~ "`Network.HTTP.Client`モジュールでは、 `request`メソッドは以下のようなAPIを"
#~ "持つ関数 `getImpl`としてラップされています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "foreign import data HTTP :: Effect\n"
#~ "\n"
#~ "type URI = String\n"
#~ "\n"
#~ "foreign import getImpl\n"
#~ "  :: forall eff\n"
#~ "   . Fn3 URI\n"
#~ "         (String -> Eff (http :: HTTP | eff) Unit)\n"
#~ "         (String -> Eff (http :: HTTP | eff) Unit)\n"
#~ "         (Eff (http :: HTTP | eff) Unit)\n"
#~ msgstr ""
#~ "foreign import data HTTP :: Effect\n"
#~ "\n"
#~ "type URI = String\n"
#~ "\n"
#~ "foreign import getImpl\n"
#~ "  :: forall eff\n"
#~ "   . Fn3 URI\n"
#~ "         (String -> Eff (http :: HTTP | eff) Unit)\n"
#~ "         (String -> Eff (http :: HTTP | eff) Unit)\n"
#~ "         (Eff (http :: HTTP | eff) Unit)\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "exports.getImpl = function(uri, done, fail) {\n"
#~ "  return function() {\n"
#~ "    require('request')(uri, function(err, _, body) {\n"
#~ "      if (err) {\n"
#~ "        fail(err)();\n"
#~ "      } else {\n"
#~ "        done(body)();\n"
#~ "      }\n"
#~ "    });\n"
#~ "  };\n"
#~ "};\n"
#~ msgstr ""
#~ "exports.getImpl = function(uri, done, fail) {\n"
#~ "  return function() {\n"
#~ "    require('request')(uri, function(err, _, body) {\n"
#~ "      if (err) {\n"
#~ "        fail(err)();\n"
#~ "      } else {\n"
#~ "        done(body)();\n"
#~ "      }\n"
#~ "    });\n"
#~ "  };\n"
#~ "};\n"

#, fuzzy
#~ msgid ""
#~ "Again, we can use the `Data.Function.Uncurried` module to turn this into "
#~ "a regular, curried PureScript function. As before, we turn the two "
#~ "callbacks into a single callback, this time accepting a value of type "
#~ "`Either String String`, and apply the `ContT` constructor to construct an "
#~ "action in our `Async` monad:"
#~ msgstr ""
#~ "再び`Data.Function.Uncurried`モジュールを使って、これを通常のカリー化され"
#~ "たPureScript関数に変換します。先ほどと同じように、２つのコールバックを"
#~ "`Maybe Chunk`型の値を受け入れるひとつのコールバックに変換しています。"
#~ "`Either String String`型の値を受け取り、`ContT`データ構築子を適用して"
#~ "`Async`モナドのアクションを構築します。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "get :: forall eff.\n"
#~ "  URI ->\n"
#~ "  Async (http :: HTTP | eff) (Either String String)\n"
#~ "get req = ContT \\k ->\n"
#~ "  runFn3 getImpl req (k <<< Right) (k <<< Left)\n"
#~ msgstr ""
#~ "get :: forall eff.\n"
#~ "  URI ->\n"
#~ "  Async (http :: HTTP | eff) (Either String String)\n"
#~ "get req = ContT \\k ->\n"
#~ "  runFn3 getImpl req (k <<< Right) (k <<< Left)\n"

#, fuzzy
#~ msgid ""
#~ "(Easy) Use `runContT` to test `get` in PSCi, printing the result to the "
#~ "console."
#~ msgstr ""
#~ "(やや難しい)`runContT`を使ってHTTP応答の各チャンクをコンソールへ出力するこ"
#~ "とで、 `get`を試してみてください。"

#, fuzzy
#~ msgid ""
#~ "(Medium) Use `ExceptT` to write a function `getEx` which wraps `get`, as "
#~ "we did previously for `readFileCont` and `writeFileCont`."
#~ msgstr ""
#~ "(やや難しい)`readFileCont`と `writeFileCont`に対して以前に行ったように、 "
#~ "`ExceptT`を使い `get`をラップする関数 `getEx`を書いてください。"

#, fuzzy
#~ msgid ""
#~ "(Difficult) Write a function which saves the response body of a request "
#~ "to a file on disk using `getEx` and `writeFileContEx`."
#~ msgstr ""
#~ "（難しい） `getEx`と `writeFileContEx`を使って、ディスク上のファイルからの"
#~ "内容をを保存する関数を書いてください。"

#, fuzzy
#~ msgid ""
#~ "If we are using `ContT` to transform the `Eff` monad, then we can compute "
#~ "in parallel simply by initiating our two computations one after the other."
#~ msgstr ""
#~ "もし`ContT`を使って`Eff`モナドを変換しているなら、単に２つの計算のうち一方"
#~ "を開始した後に他方の計算を開始すれば、並列に計算することができます。"

#, fuzzy
#~ msgid ""
#~ "We can use the `parallel` function to create a version of our "
#~ "`readFileCont` action which can be combined in parallel. Here is a simple "
#~ "example which reads two text files in parallel, and concatenates and "
#~ "prints their results:"
#~ msgstr ""
#~ "`parallel`関数を使うと`readFileCont`アクションの別のバージョンを作成するこ"
#~ "ともできます。これは並列に組み合わせることができます。２つのテキストファイ"
#~ "ルを並列に読み取り、連結してその結果を出力する簡単な例は次のようになりま"
#~ "す。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "import Prelude\n"
#~ "import Control.Apply (lift2)\n"
#~ "import Control.Monad.Cont.Trans (runContT)\n"
#~ "import Control.Monad.Eff.Console (logShow)\n"
#~ "import Control.Monad.Parallel (parallel, sequential)\n"
#~ "\n"
#~ "main = flip runContT logShow do\n"
#~ "  sequential $\n"
#~ "   lift2 append\n"
#~ "     <$> parallel (readFileCont \"/tmp/1.txt\")\n"
#~ "     <*> parallel (readFileCont \"/tmp/2.txt\")\n"
#~ msgstr ""
#~ "import Prelude\n"
#~ "import Control.Apply (lift2)\n"
#~ "import Control.Monad.Cont.Trans (runContT)\n"
#~ "import Control.Monad.Eff.Console (logShow)\n"
#~ "import Control.Monad.Parallel (parallel, sequential)\n"
#~ "\n"
#~ "main = flip runContT logShow do\n"
#~ "  sequential $\n"
#~ "   lift2 append\n"
#~ "     <$> parallel (readFileCont \"/tmp/1.txt\")\n"
#~ "     <*> parallel (readFileCont \"/tmp/2.txt\")\n"

#, fuzzy
#~ msgid ""
#~ "Note that, since `readFileCont` returns a value of type `Either ErrorCode "
#~ "String`, we need to lift the `append` function over the `Either` type "
#~ "constructor using `lift2` to form our combining function."
#~ msgstr ""
#~ "`readFileCont`は `Either ErrorCode String`型の値を返すので、 `lift2`を使っ"
#~ "て `Either`型構築子より `append`関数を持ち上げて結合関数を形成する必要があ"
#~ "ることに注意してください。"

#, fuzzy
#~ msgid ""
#~ "(Easy) Use `parallel` and `sequential` to make two HTTP requests and "
#~ "collect their response bodies in parallel. Your combining function should "
#~ "concatenate the two response bodies, and your continuation should use "
#~ "`print` to print the result to the console."
#~ msgstr ""
#~ "(簡単)`parallel`と ` sequential`を使って2つのHTTPリクエストを作成し、それ"
#~ "らのレスポンス内容を並行して収集します。あなたの結合関数は2つのレスポンス"
#~ "内容を連結しなければならず、続けて `print`を使って結果をコンソールに出力し"
#~ "てください。"

#, fuzzy
#~ msgid ""
#~ "(Medium) The applicative functor which corresponds to `Async` is also an "
#~ "instance of `Alternative`. The `<|>` operator defined by this instance "
#~ "runs two computations in parallel, and returns the result from the "
#~ "computation which completes first."
#~ msgstr ""
#~ "(やや難しい)`Async`に対応するapplicative関手は ` Alternative`のインスタン"
#~ "スです。このインスタンスによって定義される `<|>`演算子は2つの計算を並列に"
#~ "実行し、最初に完了する計算結果を返します。"

#, fuzzy, no-wrap
#~ msgid "    Use this `Alternative` instance in conjunction with your `setTimeoutCont` function to define a function\n"
#~ msgstr "    この `Alternative`インスタンスを `setTimeoutCont`関数と共に使用して関数を定義してください。\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    ```haskell\n"
#~ "    timeout :: forall a eff\n"
#~ "             . Milliseconds\n"
#~ "            -> Async (timeout :: TIMEOUT | eff) a\n"
#~ "            -> Async (timeout :: TIMEOUT | eff) (Maybe a)\n"
#~ "    ```\n"
#~ msgstr ""
#~ "    ```haskell\n"
#~ "    timeout :: forall a eff\n"
#~ "             . Milliseconds\n"
#~ "            -> Async (timeout :: TIMEOUT | eff) a\n"
#~ "            -> Async (timeout :: TIMEOUT | eff) (Maybe a)\n"
#~ "    ```\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    which returns `Nothing` if the specified computation does not provide a result within the given number of milliseconds.\n"
#~ "1. (Medium) `purescript-parallel` also provides instances of the `Parallel` class for several monad transformers, including `ExceptT`.\n"
#~ msgstr ""
#~ "    指定された計算が指定されたミリ秒数以内に結果を提供しない場合、 `Nothing`を返します。\n"
#~ "1. (やや難しい)`purescript-parallel`は `ExceptT`を含むいくつかのモナド変換子のための `Parallel`クラスのインスタンスも提供します。\n"

#, fuzzy, no-wrap
#~ msgid "    Rewrite the parallel file IO example to use `ExceptT` for error handling, instead of lifting `append` with `lift2`. Your solution should use the `ExceptT` transformer to transform the `Async` monad.\n"
#~ msgstr "    `lift2`で `append`を持ち上げる代わりに、 `ExceptT`を使ってエラー処理を行うように、並列ファイル入出力の例を書きなおしてください。解決策は `Async`モナドを変換するために `ExceptT`変換子を使うとよいでしょう。\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "    Use this approach to modify your `concatenateMany` function to read multiple input files in parallel.\n"
#~ "1. (Difficult, Extended) Suppose we are given a collection of JSON documents on disk, such that each document contains an array of references to other files on disk:\n"
#~ msgstr ""
#~ "    同様の手法で複数の入力ファイルを並列に読み込むために `concatenateMany`関数を書き換えてください。\n"
#~ "1. (難しい、拡張) ディスク上のJSON文書の配列が与えられ、それぞれの文書はディスク上の他のファイルへの参照の配列を含んでいるとします。\n"

#, fuzzy, no-wrap
#~ msgid "   { references: ['/tmp/1.json', '/tmp/2.json'] }\n"
#~ msgstr "   { references: ['/tmp/1.json', '/tmp/2.json'] }\n"

#, fuzzy, no-wrap
#~ msgid "   Write a utility which takes a single filename as input, and spiders the JSON files on disk referenced transitively by that file, collecting a list of all referenced files.\n"
#~ msgstr "   入力として単一のファイル名をとり、そのファイルから参照されているディスク上のすべてのJSONファイルをたどって、参照されたすべてのファイルの一覧を収集するユーティリティを書いてください。\n"

#, fuzzy, no-wrap
#~ msgid "   Your utility should use the `purescript-foreign` library to parse the JSON documents, and should fetch files referenced by a single file in parallel.\n"
#~ msgstr "   そのユーティリティは、JSON文書を解析するために `purescript-foreign`ライブラリを使用する必要があり、単一のファイルが参照するファイルは並列に取得しなければなりません！\n"

#, fuzzy
#~ msgid ""
#~ "In this chapter, we have seen a practical demonstration of monad "
#~ "transformers:"
#~ msgstr ""
#~ "この章ではモナド変換子の実用的なデモンストレーションを見てきました。"

#, fuzzy
#~ msgid ""
#~ "- We saw how the common JavaScript idiom of callback-passing can be "
#~ "captured by the `ContT` monad transformer.  - We saw how the problem of "
#~ "callback hell can be solved by using do notation to express sequential "
#~ "asynchronous computations, and applicative functors to express "
#~ "parallelism.  - We used `ExceptT` to express _asynchronous errors_."
#~ msgstr ""
#~ "- コールバック渡しの一般的なJavaScriptのイディオムを `ContT`モナド変換子に"
#~ "よって捉えることができる方法を説明しました。 - どのようにコールバック地獄"
#~ "の問題を解決するかを説明しました。　直列の非同期計算を表現するdo記法を使用"
#~ "して、かつ並列性を表現するためにApplicative関手によって解決することができ"
#~ "る方法を説明しました。 - **非同期エラー**を表現するために `ExceptT`を使い"
#~ "ました。"

#, fuzzy
#~ msgid ""
#~ "Here, `isSorted` and `isSubarrayOf` are implemented as helper functions "
#~ "with the following types:"
#~ msgstr ""
#~ "ここで、 `isSorted`と `isSubarrayOf`は次のような型を持つ補助関数として実装"
#~ "されています。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "isSorted :: forall a. Ord a => Array a -> Boolean\n"
#~ "isSubarrayOf :: forall a. Eq a => Array a -> Array a -> Boolean\n"
#~ msgstr ""
#~ "isSorted :: forall a. Ord a => Array a -> Boolean\n"
#~ "isSubarrayOf :: forall a. Eq a => Array a -> Array a -> Boolean\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "$ pulp test\n"
#~ "\n"
#~ "* Build successful. Running tests...\n"
#~ "\n"
#~ "100/100 test(s) passed.\n"
#~ "100/100 test(s) passed.\n"
#~ "\n"
#~ "* Tests OK.\n"
#~ msgstr ""
#~ "$ pulp test\n"
#~ "\n"
#~ "* Build successful. Running tests...\n"
#~ "\n"
#~ "100/100 test(s) passed.\n"
#~ "100/100 test(s) passed.\n"
#~ "\n"
#~ "* Tests OK.\n"

#, fuzzy, no-wrap
#~ msgid ""
#~ "Error: Test 6 failed:\n"
#~ "[79168] not a subarray of [-752832,686016]\n"
#~ msgstr ""
#~ "Error: Test 6 failed:\n"
#~ "[79168] not a subarray of [-752832,686016]\n"

#, fuzzy
#~ msgid ""
#~ "(Easy) Write a property which asserts that merging an array with the "
#~ "empty array does not modify the original array."
#~ msgstr ""
#~ "（簡単）　空の配列を持つ配列を統合しても元の配列は変更されない、と主張する"
#~ "性質を書いてください。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "quickCheck \\xs ys ->\n"
#~ "  isSorted $ ints $ mergePoly (sort xs) (sort ys)\n"
#~ "quickCheck \\xs ys ->\n"
#~ "  ints xs `isSubarrayOf` mergePoly xs ys\n"
#~ msgstr ""
#~ "quickCheck \\xs ys ->\n"
#~ "  isSorted $ ints $ mergePoly (sort xs) (sort ys)\n"
#~ "quickCheck \\xs ys ->\n"
#~ "  ints xs `isSubarrayOf` mergePoly xs ys\n"

#, fuzzy
#~ msgid ""
#~ "In the case of the subarray property, we simply have to change the name "
#~ "of the function to `mergeWith` - we still expect our input arrays to be "
#~ "subarrays of the result:"
#~ msgstr ""
#~ "部分配列性については、単に関数の名前を `mergeWith`に変えるだけです。引き続"
#~ "き入力配列は結果の部分配列になっていると期待できます。"

#, fuzzy, no-wrap
#~ msgid ""
#~ "quickCheck \\xs ys f ->\n"
#~ "  xs `isSubarrayOf` mergeWith (numberToBool f) xs ys\n"
#~ msgstr ""
#~ "quickCheck \\xs ys f ->\n"
#~ "  xs `isSubarrayOf` mergeWith (numberToBool f) xs ys\n"

#, fuzzy
#~ msgid "(Difficult) Modify the `ContentF` type to support a new action"
#~ msgstr ""
#~ "(難しい) `ContentF`型を変更して、次の新しいアクションをサポートするように"
#~ "してください。"

#, fuzzy, no-wrap
#~ msgid "   isMobile :: Content Boolean\n"
#~ msgstr "   isMobile :: Content Boolean\n"

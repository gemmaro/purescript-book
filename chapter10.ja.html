<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>外部関数インターフェース - PureScript by Example</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="index.ja.html"><strong aria-hidden="true">15.</strong> 序文 (Foreword)</a></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">16.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">17.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">18.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">19.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html"><strong aria-hidden="true">20.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html"><strong aria-hidden="true">21.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">22.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">23.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">24.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.ja.html" class="active"><strong aria-hidden="true">25.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.ja.html"><strong aria-hidden="true">26.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.ja.html"><strong aria-hidden="true">27.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.ja.html"><strong aria-hidden="true">28.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.ja.html"><strong aria-hidden="true">29.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="外部関数インタフェース"><a class="header" href="#外部関数インタフェース">外部関数インタフェース</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章でPureScriptの<strong>外部関数インターフェース</strong> (foreign function interface; FFI) を紹介します。
これによりPureScriptコードからJavaScriptコードへの呼び出し、およびその逆が可能になります。
これから扱うのは次のようなものです。</p>
<ul>
<li>純粋で、作用のある、非同期なJavaScript関数をPureScriptから呼び出す。</li>
<li>型付けされていないデータを扱う。</li>
<li><code>argonaut</code>パッケージを使ってJSONに符号化したりJSONを構文解析したりする。</li>
</ul>
<p>この章の終わりにかけて、住所録の例に立ち返ります。
この章の目的は、FFIを使ってアプリケーションに次の新しい機能を追加することです。</p>
<ul>
<li>利用者にポップアップ通知で警告する。</li>
<li>フォームのデータを直列化してブラウザのローカルストレージに保存し、アプ
リケーションが再起動したときにそれを再読み込みする</li>
</ul>
<p>いくつかの一般にはそこまで重用されない追加の話題を押さえた補遺もあります。
自由にこれらの節を読んで構いませんが、
学習目標にあまり関係しなければ本の残りを読み進める妨げにならないようにしてください。</p>
<ul>
<li>実行時のPureScriptの値の表現を理解する。</li>
<li>JavaScriptからPureScriptを呼び出す。</li>
</ul>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。
今回もそれぞれのディレクトリから適切なソースファイルがソースファイルに含められています。</p>
<p>この章は<code>argonaut</code>ライブラリを依存関係として導入しています。
このライブラリはJSONに符号化したりJSONを復号化したりするために使います。</p>
<p>この章の演習は<code>test/MySolutions.purs</code>に書き、
<code>spago test</code>を走らせることによって<code>test/Main.purs</code>中の単体試験に対して確認することができます。</p>
<p>住所録アプリは<code>parcel src/index.html --open</code>で立ち上げることができます。
8章と同じ作業の流れを使っているので、より詳しい説明についてはそちらの章を参照してください。</p>
<h2 id="免責事項"><a class="header" href="#免責事項">免責事項</a></h2>
<p>JavaScriptを扱う作業をできる限り簡単にするため、
PureScriptは直感的な外部関数インタフェースを提供します。
しかしながら、FFIはPureScriptの<strong>高度な</strong>機能であることには留意していただきたいと思います。
FFIを安全かつ効率的に使用するには、
扱うつもりであるデータの実行時の表現についてよく理解していなければなりません。
この章では、PureScriptの標準ライブラリのコードに付いて回る
そのような理解を与えることを目指しています。</p>
<p>PureScriptのFFIはとても柔軟に設計されています。
実際には、外部関数に最低限の型だけを与えるか、
それとも型システムを利用して外部のコードの誤った使い方を防ぐようにするか、
開発者が選ぶことができるということを意味しています。
標準ライブラリのコードは、後者の手法を好む傾向にあります。</p>
<p>簡単な例としては、
JavaScriptの関数で戻り値が <code>null</code>にならないことを保証することはできません。
実のところ、JavaScriptらしさのあるコードはかなり頻繁に <code>null</code>を返します！
しかし、大抵PureScriptの型にnull値が巣喰うことはありません。
そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するときは、
これらの特殊な場合を適切に処理するのは開発者の責任です。</p>
<h2 id="purescriptからjavascriptを呼び出す"><a class="header" href="#purescriptからjavascriptを呼び出す">PureScriptからJavaScriptを呼び出す</a></h2>
<p>PureScriptからJavaScriptコードを使用する最も簡単な方法は、
<strong>外部インポート宣言</strong> (foreign import declaration) を使用し、
既存のJavaScriptの値に型を与えることです。
外部インポート宣言には<strong>外部JavaScriptモジュール</strong> (foreign JavaScript module) から
<strong>エクスポート</strong>された対応するJavaScriptでの宣言がなくてはなりません。</p>
<p>たとえば、特殊文字をエスケープすることによりURIのコンポーネントを符号化するJavaScriptの
<code>encodeURIComponent</code>関数について考えてみます。</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p><code>null</code>でない文字列から <code>null</code>でない文字列への関数であり、副作用を持っていないので、この関数はその型 <code>String -&gt; String</code>について適切な実行時表現を持っています。</p>
<p>次のような外部インポート宣言を使うと、この関数に型を割り当てることができます。</p>
<pre><code class="language-haskell">module Test.URI where

foreign import _encodeURIComponent :: String -&gt; String
</code></pre>
<p>インポートしてくるための外部JavaScriptモジュールを書く必要もあります。
対応する外部JavaScriptモジュールは同名で拡張子が<code>.purs</code>から<code>.js</code>に変わったものです。
上のPureScriptモジュールが<code>URI.purs</code>として保存されているなら、
外部JavaScriptモジュールは<code>URI.js</code>として保存されます。
<code>encodeURIComponent</code>は既に定義されているので、<code>_encodeURIComponent</code>としてエクスポートせねばなりません。</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

export const _encodeURIComponent = encodeURIComponent;
</code></pre>
<p>バージョン0.15からPureScriptはJavaScriptと通訳する際にESモジュールシステムを使います。
ESモジュールではオブジェクトに<code>export</code>キーワードを与えることで関数と値はモジュールからエクスポートされます。</p>
<p>これら2つの部品を使うことで、PureScriptで書かれた関数のように、
PureScriptから<code>encodeURIComponent</code>関数を使うことができます。
例えばPSCiで上記の計算を再現できます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; _encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>外部モジュールに自前の関数を定義することもできます。
以下は<code>Number</code>を平方する自前のJavaScript関数を作って呼び出す方法の一例です。</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

export const square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="多変数関数"><a class="header" href="#多変数関数">多変数​関数</a></h2>
<p>第2章の<code>diagonal</code>関数を外部モジュールで書き直してみましょう。
この関数は直角三角形の対角線を計算します。</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>PureScriptの関数は<strong>カリー化</strong>されていることを思い出してください。
<code>diagonal</code>は<code>Number</code>を取って<strong>関数</strong>を返す関数です。
そして返された関数は<code>Number</code>を取って<code>Number</code>を返します。</p>
<pre><code class="language-js">export const diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>もしくはES6の矢印構文ではこうです。
（後述するES6についての補足を査証してください）</p>
<pre><code class="language-js">export const diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="カリー化されていない関数"><a class="header" href="#カリー化されていない関数">カリー化されていない関数</a></h2>
<p>JavaScriptでカリー化された関数を書くことは、
ただでさえJavaScriptらしいものではない上に、常に可能というわけでもありません。
よくある多変数なJavaScriptの関数は<strong>カリー化されていない</strong>形式を取るでしょう。</p>
<pre><code class="language-js">export const diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>モジュール<code>Data.Function.Uncurried</code>は<strong>ラッパー</strong>型と
カリー化されていない関数を取り扱う関数をエクスポートします。</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>型構築子<code>Fn2</code>を調べると以下です。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code>は3つの型引数を取ります。
<code>Fn2 a b c</code>は、型 <code>a</code>と <code>b</code>の2つの引数、
返り値の型 <code>c</code>をもつカリー化されていない関数の型を表現しています。
これを使って外部モジュールから<code>diagonalUncurried</code>をインポートしました。</p>
<p>カリー化されていない関数と引数を取る<code>runFn2</code>で呼び出すことができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p><code>functions</code>パッケージでは0引数から10引数までの関数について同様の型構築子が定義されています。</p>
<h2 id="カリー化されていない関数についての補足"><a class="header" href="#カリー化されていない関数についての補足">カリー化されていない関数についての補足</a></h2>
<p>PureScriptのカリー化された関数にはもちろん利点があります。
部分的に関数を適用することができ、関数型に型クラスインスタンスを与えられます。
しかし効率上の代償も付いてくるのです。
効率性が決定的に重要なコードでは多変数を受け付けるカリー化されていないJavaScript関数を定義する必要が時々あります。</p>
<p>PureScriptでカリー化されていない関数を作ることもできます。
2引数の関数については<code>mkFn2</code>関数が使えます。</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>前と同様に<code>runFn2</code>関数を使うと、カリー化されていない2引数の関数を適用することができます。</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>ここで重要なのは、引数がすべて適用されるなら、コンパイラは <code>mkFn2</code>関数や
<code>runFn2</code>関数を<strong>インライン化</strong>するということです。そのため、生成されるコードはとてもコンパクトになります。</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>対照的に、こちらがこれまでのカリー化された関数です。</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>そして生成結果のコードが以下です。
入れ子の関数のため比較的簡潔ではありません。</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="現代的なjavascriptの構文についての補足"><a class="header" href="#現代的なjavascriptの構文についての補足">現代的なJavaScriptの構文についての補足</a></h2>
<p>前に見た矢印関数構文はES6の機能であり、そのためいくつかの古いブラウザ（名指しすればIE11）と互換性がありません。
執筆時点でWebブラウザをまだ更新していない<a href="https://caniuse.com/#feat=arrow-functions">6%の利用者が矢印関数を使うことができないと推計</a>されています。</p>
<p>ほとんどの利用者にとって互換性があるようにするため、
PureScriptコンパイラによって生成されるJavaScriptコードは矢印関数を使っていません。
また、同じ理由で<strong>公開するライブラリでも矢印関数を避ける</strong>ことが推奨されます。</p>
<p>それでも自分のFFIコードで矢印関数を使うこともできますが、
デプロイの作業工程でES5に互換性のある関数に変換するために<a href="https://github.com/babel/babel#intro">Babel</a>などのツールを含めるべきです。</p>
<p>ES6の矢印関数がより読みやすく感じたら<a href="https://github.com/lebab/lebab">Lebab</a>のようなツールを使ってコンパイラの<code>output</code>ディレクトリにJavaScriptのオードを変換することができます。</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>この操作により上の<code>curriedAdd</code>関数は以下に変換されます。</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>本書の残りの例では入れ子の関数の代わりに矢印関数を使います。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>（普通）<code>Test.MySolutions</code>モジュールの中に箱の体積を求めるJavaScriptの関数<code>volumeFn</code>を書いてください。
<code>Data.Function.Uncurried</code>の<code>Fn</code>ラッパーを使ってください。</li>
<li>（普通）<code>volumeFn</code>を矢印関数を使って書き直し、<code>volumeArrow</code>としてください。</li>
</ol>
<h2 id="単純な型を渡す"><a class="header" href="#単純な型を渡す">単純な型を渡す</a></h2>
<p>以下のデータ型はPureScriptとJavaScriptの間でそのまま渡し合うことができます。</p>
<div class="table-wrapper"><table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
</div>
<p><code>String</code>と<code>Number</code>という原始型の例は既に見てきました。
ここから<code>Array</code>や<code>Record</code>（JavaScriptでは<code>Object</code>）といった構造的な型を眺めていきます。</p>
<p><code>Array</code>の受け渡しを実演するために、
以下に<code>Int</code>の<code>Array</code>を取って別の配列として累計の和を返すJavaScriptの関数の呼び出し方を示します。
JavaScriptは<code>Int</code>のための分離した型を持たないため、PureScriptでの<code>Int</code>と<code>Number</code>はJavaScriptでの<code>Number</code>に翻訳される点を思い起こしてください。</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">export const cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p><code>Record</code>の受け渡しを実演するために、以下に2つの<code>Complex</code>な数をレコードとして取り、和を別のレコードとして返すJavaScriptの呼び出し方を示します。
PureScriptでの<code>Record</code>がJavaScriptでは<code>Object</code>として表現されることに注意してください。</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">export const addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>なお、上の手法にはJavaScriptが期待通りの型を返すことへの信頼を要します。
PureScriptはJavaScriptのコードに型検査を適用することができないからです。
この型安全性の配慮について後のJSONの節でより詳しく記述していきます。
型の不整合から身を守る手法についても押さえます。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（普通）<code>Complex</code>の数の配列を取って別の複素数の配列として累計の和を返すJavaScriptの関数<code>cumulativeSumsComplex</code>（と対応するPureScriptの外部インポート）を書いてください。</li>
</ol>
<h2 id="単純な型を越えて"><a class="header" href="#単純な型を越えて">単純な型を越えて</a></h2>
<p><code>String</code>、<code>Number</code>、<code>Array</code>、そして<code>Record</code>といったJavaScript固有の表現を持つ型をFFI越しに送ったり受け取ったりする方法を数例見てきました。
ここから<code>Maybe</code>のようなPureScriptで使えるいくつかの他の型の使い方を押さえていきます。</p>
<p>外部宣言を使用して、配列についての <code>head</code>関数を改めて作成したいとしましょう。
JavaScriptでは次のような関数を書くことになるでしょう。</p>
<pre><code class="language-javascript">export const head = arr =&gt;
  arr[0];
</code></pre>
<p>この関数をどう型付けましょうか？
型 <code>forall a. Array a -&gt; a</code>を与えようとしても、空の配列に対してこの関数は <code>undefined</code>を返します。
したがって型<code>forall a. Array a -&gt; a</code>は正しくこの実装を表現していないのです。</p>
<p>代わりにこのコーナーケースを扱うために<code>Maybe</code>値を返したいところです。</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>しかしどうやって<code>Maybe</code>を返しましょうか。
つい以下のように書きたくなります。</p>
<pre><code class="language-js">// こうしないでください
import Data_Maybe from '../Data.Maybe'

export const maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>外部モジュールで直接<code>Data.Maybe</code>モジュールをインポートして使うことはお勧めしません。
というのもコードがコード生成器の変化に対して脆くなるからです。
<code>create</code>や<code>value</code>は公開のAPIではありません。
加えて、このようにすることは不要なコードの消去のための<code>purs bundle</code>を使う際に問題を引き起こしえます。</p>
<p>推奨されるやり方はFFIで定義された関数に余剰の引数を加えて必要な関数を受け付けることです。</p>
<pre><code class="language-js">export const maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>ただし、次のように書きますが、</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>以下ではないことに注意です。</p>
<pre><code class="language-hs">forall a. ( a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>どちらの形式でも動きますが、後者は<code>Just</code>と<code>Nothing</code>の場所での招かれざる入力により晒されやすくなります。
例えばより脆弱な場合では以下のようにして呼ぶことができます。</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>これはいかなる配列についても<code>Just 1000</code>を返します。
この脆弱性は<code>a</code>が<code>Int</code>のときに（これは入力の配列に基づきます）<code>(\_ -&gt; Just 1000)</code>と<code>Just 1000</code>がシグネチャ<code>(a -&gt; Maybe a)</code>と<code>Maybe a</code>にそれぞれ合致しているために許されているのです。</p>
<p>より安全な型シグネチャでは入力の配列に基づいて<code>a</code>が<code>Int</code>に決定されたとしても、<code>forall x</code>に絡むシグネチャに合致する妥当な関数を提供する必要があります。
<code>(forall x. Maybe x)</code>の <em>唯一</em> の選択肢は<code>Nothing</code>ですが、それは<code>Just</code>値が<code>x</code>の型を前提にしてしまい、するともはや全ての<code>x</code>については妥当でなくなってしまうからです。
<code>(forall x. x -&gt; Maybe x)</code>の唯一の選択肢は<code>Just</code>（望んでいる引数）と<code>(\_ -&gt; Nothing)</code>であり、後者は唯一残っている脆弱性になるのです。</p>
<h2 id="外部型の定義"><a class="header" href="#外部型の定義">外部型の定義</a></h2>
<p><code>Maybe a</code>を返す代わりに実は<code>arr[0]</code>を返したいのだとしましょう。
型<code>a</code>ないし<code>undefined</code>値（ただ<code>null</code>ではありません）のいずれかの値を表現する型がほしいです。
この型を<code>Undefined a</code>と呼びましょう。</p>
<p><strong>外部インポート宣言</strong>を使うと、<strong>外部型</strong> (foreign type) を定義することができます。
構文は外部関数を定義するのと似ています。</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>このキーワード<code>data</code>は型を定義していることを表しています。
値ではありせん。
型シグネチャの代わりに、新しい型の<strong>種</strong>を与えます。
この場合は<code>Undefined</code>の種が <code>Type -&gt; Type</code>であると宣言しています。
言い換えれば<code>Undefined</code>は型構築子です。</p>
<p>これで元の<code>head</code>の定義を単に再利用することができます。</p>
<pre><code class="language-javascript">export const undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>PureScriptモジュールには以下を追加します。</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p><code>undefinedHead</code>関数の本体は<code>undefined</code>かもしれない<code>arr[0]</code>を返します。
そしてこの型シグネチャはその事実を正しく反映しています。</p>
<p>この関数はその型の適切な実行時表現を持っていますが、
型 <code>Undefined a</code>の値を使用する方法がありませんので、まったく役に立ちません。
いや、言い過ぎました。
別のFFIでこの型を使えますからね。</p>
<p>値が未定義かどうかを教えてくれる関数を書くことができます。</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>外部JavaScriptモジュールで次のように定義できます。</p>
<pre><code class="language-javascript">export const isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>これでPureScriptで <code>isUndefined</code>と <code>undefinedHead</code>を一緒に使用すると、
便利な関数を定義することができます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>このように、定義したこの外部関数はとても簡単です。
つまりPureScriptの型検査器を使うことによる利益が最大限得られるのです。
一般に、外部関数は可能な限り小さく保ち、できるだけアプリケーションの処理はPureScriptコードへ移動しておくことをおすすめします。</p>
<h2 id="例外"><a class="header" href="#例外">例外</a></h2>
<p>他の選択肢としては、空の配列の場合に例外を投げる方法があります。
厳密に言えば、純粋な関数は例外を投げるべきではありませんが、それをする柔軟さはあります。
安全性に欠けていることを関数名で示します。</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>JavaScriptモジュールでは、 <code>unsafeHead</code>を以下のように定義することができます。</p>
<pre><code class="language-javascript">export const unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>
<p>（普通）二次多項式<code>a*x^2 + b*x + c = 0</code>を表現するレコードが与えられているとします。</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>二次多項式を使ってこの多項式の根を求めるJavaScriptの関数<code>quadraticRootsImpl</code>とそのラッパーの<code>quadraticRoots :: Quadratic -&gt; Pair Complex</code>を書いてください。
2つの根を<code>Complex</code>の数の<code>Pair</code>として返してください。
<em>ヒント</em> ：<code>quadraticRoots</code>ラッパーを使って<code>Pair</code>の構築子を<code>quadraticRootsImpl</code>に渡してください。</p>
</li>
<li>
<p>（普通）関数<code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>を書いてください。
この関数は<code>undefined</code>を<code>Nothing</code>に、<code>a</code>の値を<code>Just a</code>に変換します。</p>
</li>
<li>
<p>（難しい）<code>toMaybe</code>が備わっていれば<code>maybeHead</code>を以下に書き換えられます。</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>これは前の実装よりも良い手法なのでしょうか。
<strong>補足</strong>：この演習のための単体試験はありません。</p>
</li>
</ol>
<h2 id="型クラスメンバー関数を使う"><a class="header" href="#型クラスメンバー関数を使う">型クラスメンバー関数を使う</a></h2>
<p>ちょうど前にFFIを越えて<code>Maybe</code>の構築子を渡す手引きをしましたが、
今回はJavaScriptを呼び出すPureScriptを書く別の場合です。
JavaScriptの呼び出しでも続けざまにPureScriptの関数を呼び出します。
ここでは型クラスのメンバー関数のFFIを越えた渡し方を探ります。</p>
<p>型<code>x</code>に合う適切な<code>show</code>のインスタンスを期待する外部JavaScript関数を書くことから始めます。</p>
<pre><code class="language-js">export const boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + &quot;!!!&quot;;
</code></pre>
<p>それから対応するシグネチャを書きます。</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>そして<code>show</code>の正しいインスタンスを渡すラッパー関数も書きます。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>代わりにポイントフリー形式だとこうです。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>そうしてラッパーを呼び出すことができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 &quot;Hat&quot;)
&quot;(TUPLE 1 \&quot;HAT\&quot;)!!!&quot;
</code></pre>
<p>以下は複数の関数を渡すことを実演する別の例です。
これらの関数には複数引数関数 (<code>eq</code>) が含まれます。</p>
<pre><code class="language-js">export const showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return &quot;Equivalent&quot;;
  } else {
    return show(a) + &quot; is not equal to &quot; + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
&quot;Nothing is not equal to (Just 5)&quot;
</code></pre>
<h2 id="作用のある関数"><a class="header" href="#作用のある関数">作用のある関数</a></h2>
<p><code>bold</code>関数を拡張してコンソールにログ出力するようにしましょう。
ログ出力は<code>Effect</code>であり、<code>Effect</code>はJavaScriptで無引数関数として表現されます。
つまり<code>()</code>と矢印記法だとこうです。</p>
<pre><code class="language-js">export const yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + &quot;!!!&quot;);
</code></pre>
<p>新しい外部インポートは返る型が<code>String</code>から<code>Effect Unit</code>に変わった点以外は以前と同じです。</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>REPLで試すと文字列が（引用符で囲まれず）直接コンソールに印字され<code>unit</code>値が返ることに気付きます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 &quot;Hat&quot;)
(TUPLE 1 &quot;HAT&quot;)!!!
unit
</code></pre>
<p><code>Effect.Uncurried</code>に<code>EffectFn</code>ラッパーというものもあります。
これらは既に見た<code>Data.Function.Uncurried</code>の<code>Fn</code>ラッパーに似ています。
これらのラッパーがあればカリー化されていない作用のある関数をPureScriptで呼び出すことができます。</p>
<p>一般的にこれらを使うのは、
こうしたAPIをカリー化された関数に包むのではなく、
既存のJavaScriptライブラリのAPIを直接呼び出したいときぐらいです。
したがってカリー化していない<code>yell</code>の例を見せてもあまり意味がありません。
というのもJavaScriptがPureScriptの型クラスのメンバーに依っているからで、
さらにそれは既存のJavaScriptの生態系にそのメンバーが見付からないためです。</p>
<p>その代わりに以前の<code>diagonal</code>の例を変更し、結果を返すことに加えてログ出力を含めるとこうなります。</p>
<pre><code class="language-js">export const diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log(&quot;Diagonal is &quot; + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="非同期関数"><a class="header" href="#非同期関数">非同期関数</a></h2>
<p>JavaScriptのプロミスは<code>aff-promise</code>ライブラリの助けを借りて直接PureScriptの非同期作用に翻訳されます。
より多くの情報についてはライブラリの<a href="https://pursuit.purescript.org/packages/purescript-aff-promise">ドキュメント</a>をあたってください。
ここではいくつかの例に触れるだけとします。</p>
<p>JavaScriptの<code>wait</code>プロミス（または非同期関数）をPureScriptのプロジェクトで使いたいとします。
<code>ms</code>ミリ秒分だけ送らせて実行させるのに使うことができます。</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>単に<code>Effect</code>（無引数関数）に包んで公開するだけでよいです。</p>
<pre><code class="language-js">export const sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>そして以下のようにインポートします。</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>そうしてこの<code>Promise</code>を<code>Aff</code>ブロック中で以下のように走らせることができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
… launchAff_ do
…   log &quot;waiting&quot;
…   sleep 300
…   log &quot;done waiting&quot;
…
waiting
unit
done waiting
</code></pre>
<p>REPLでの非同期ログ出力はブロック全体が実行を終了するまで印字するのを待つ点に注意しましょう。
このコードは<code>spago test</code>で走らせたときは、印字の <em>合間に</em> 僅かな遅延があり、より予測に近い振舞いをします。</p>
<p>プロミスから値を返す別の例を見てみましょう。
この関数は<code>async</code>と<code>await</code>を使って書かれていますが、
これはプロミスの糖衣構文に過ぎません。</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

export const diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p><code>Number</code>を返すため、この型を<code>Promise</code>と<code>Aff</code>のラッパーの中に表します。</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
… launchAff_ do
…   res &lt;- diagonalAsync 300 3.0 4.0
…   logShow res
…
unit
5.0
</code></pre>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<p>上の節の演習はまだやるべきこと一覧にあります。
もし何か良い演習の考えがあればご提案ください。</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>アプリケーションでJSONを使うことには多くの理由があります。
例えばWebのAPIと疎通するよくある手段であるためです。
この節では他の用例についてもお話ししましょう。
構造的なデータをFFI越しに渡す際の型安全性を向上させる手法から始めます。</p>
<p>少し前のFFI関数<code>cumulativeSums</code>と<code>addComplex</code>を再訪し、
それぞれに1つバグを混入させてみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push(&quot;Broken&quot;); // Bug
  return sums;
};

export const addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>返る型が正しくない事実があるにも関わらず、
元の型シグネチャを使うことができ、コードはそれでもコンパイルされます。</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>コードを実行することさえ可能で、そうすると予期しない結果を生み出すか実行時エラーになります。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>例えば結果の<code>sums</code>はもはや正しい<code>Array Int</code>ではありませんが、
これは<code>String</code>が配列に含まれているからです。
そして更なる操作は即時のエラーではなく予期しない振舞いを生み出します。
というのもこれらの<code>sums</code>の<code>sum</code>は<code>10</code>ではなく<code>0</code>だからです。
これでは捜索の難しいバグになりかねませんね。</p>
<p>同様に<code>addComplexBroken</code>を呼び出すときは1つもエラーが出ません。
しかしながら<code>Complex</code>の結果の<code>imag</code>フィールドにアクセスすると予期しない振舞い（<code>7.0</code>ではなく<code>Nan</code>を返すため）やはっきりしない実行時エラーを生じることでしょう。</p>
<p>PureScriptのコードにバグ一匹通さないようにするため、JavaScriptのコードでJSONを使いましょう。</p>
<p><code>argonaut</code>ライブラリには必要としているJSONの復号化と符号化の機能が備わっています。
このライブラリには素晴らしい<a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">ドキュメント</a>があるので、本書では基本的な用法だけを押さえます。</p>
<p>返る型を<code>Json</code>として定義するようにして、代わりとなる外部インポートをつくるとこうなります。</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>単純に既存の壊れた関数を指し示しているだけである点に注意します。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSumsBroken
export const addComplexJson = addComplexBroken
</code></pre>
<p>そして返された<code>Json</code>の値を復号化するラッパーを書きます。</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>それから返る型への復号が成功しなかったどんな値も<code>Left</code>の<code>String</code>なエラーとして表れます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left &quot;Couldn't decode Array (Failed at index 3): Value is not a Number&quot;)

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left &quot;JSON was missing expected field: imag&quot;)
</code></pre>
<p>うまく動くバージョンで呼び出すと<code>Right</code>の値が返ります。</p>
<p>次のREPLブロックを走らせる前に、うまく動くバージョンを指し示すように<code>test/Examples.js</code>に以下の変更を加えて、これを手元で試してみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSums
export const addComplexJson = addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>JSONを使うことは、<code>Map</code>や<code>Set</code>のような他の構造的な型をFFI越しに渡す最も簡単な方法でもあります。
ただしJSONは真偽値、数値、文字列、配列、そして他のJSONの値からなるオブジェクトのみから構成されるため、JSONでは直接<code>Map</code>や<code>Set</code>を書くことができません。
しかしこれらの構造を配列として表現することはでき（キーとバリューもまたJSONで表現されているとします）、それから<code>Map</code>や<code>Set</code>に復号し直すことができるのです。</p>
<p>以下は<code>String</code>のキーと<code>Int</code>のバリューからなる<code>Map</code>を変更する外部関数シグネチャと、それに伴うJSONの符号化と復号化を扱うラッパー関数の例です。</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>関数合成の絶好の用例になっていますね。
これらの両方の代替案は上のものと等価です。</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>以下はJavaScriptでの実装です。
<code>Array.from</code>の工程が、復号の前にJavaScriptの<code>Map</code>をJSONに親和性のある形式に変換し、PureScriptの<code>Map</code>に変換し直すために必須である点に注意してください。</p>
<pre><code class="language-js">export const mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set(&quot;Foo&quot;, 42);
  return Array.from(m);
};
</code></pre>
<p>これで<code>Map</code>をFFI越しに送ったり受け取ったりできます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple &quot;hat&quot; 1, Tuple &quot;cat&quot; 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple &quot;Foo&quot; 42),(Tuple &quot;cat&quot; 2),(Tuple &quot;hat&quot; 1)]))
</code></pre>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>
<p>（普通）<code>Map</code>中の全ての値の<code>Set</code>を返すJavaScriptの関数とPureScriptのラッパー<code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code>を書いてください。</p>
</li>
<li>
<p>（簡単）より広い種類のマップに関して動作するよう、前のJavaScriptの関数の新しいラッパーを書いてください。シグネチャは<code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code>です。
なお<code>k</code>と<code>v</code>にいくつかの型クラス制約を加える必要があるでしょう。
コンパイラが導いてくれます。</p>
</li>
<li>
<p>（普通）少し前の<code>quadraticRoots</code>を書き換えて<code>quadraticRootSet</code>としてください。
この関数は<code>Complex</code>の根をJSONを介して（<code>Pair</code>の代わりに）<code>Set</code>として返します。</p>
</li>
<li>
<p>（難しい）少し前の<code>quadraticRoots</code>を書き換えて<code>quadraticRootsSafe</code>としてください。
この関数はJSONを使って<code>Complex</code>の根の<code>Pair</code>をFFI越しに渡します。
JavaScriptでは<code>Pair</code>構築子を使わないでください。
ただしその代わりに復号器に互換性のある形式で対を返すだけにしてください。
<strong>ヒント</strong>：<code>DecodeJson</code>インタンスを<code>Pair</code>に書く必要があるでしょう。
自前の復号インスタンスを書く上での説明については<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonautのドキュメント</a>をあたってください。
<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a>インスタンスも参考になるかもしれません。
「孤立インスタンス」を作ることを避けるために、<code>Pair</code>に<code>newtype</code>ラッパーが必要になる点に注意してください。</p>
</li>
<li>
<p>（普通）2次元配列を含むJSON文字列を構文解析して復号する<code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code>関数を書いてください。
例えば<code>&quot;[[1, 2, 3], [4, 5], [6]]&quot;</code>です。
<strong>ヒント</strong>：復号の前に<code>jsonParser</code>を使って<code>String</code>を<code>Json</code>に変換する必要があるでしょう。</p>
</li>
<li>
<p>（普通）以下のデータ型は値が葉にある二分木を表現します。</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>汎化された<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを<code>Tree</code>型に導出してください。
このやり方についての説明は<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonautのドキュメント</a>をあたってください。
なお、この演習の単体試験を有効にするには汎化された<code>Show</code>及び<code>Eq</code>インスタンスも必要になります。
しかしJSONのインスタンスと格闘したあとではこれらの実装は直感的に進むでしょう。</p>
</li>
<li>
<p>（難しい）以下の<code>data</code>型は整数か文字列かでJSONで異なって表現されます。</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>この振舞いを実装する<code>IntOrString</code>データ型に<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを書いてください。
<strong>ヒント</strong>：<code>Control.Alt</code>の<code>alt</code>演算子が役立つかもしれません。</p>
</li>
</ol>
<h2 id="住所録"><a class="header" href="#住所録">住所録</a></h2>
<p>この節では新しく獲得したFFIとJSONの知識を適用して第8章の住所録の例を構築していきたいと思います。以下の機能を加えていきます。</p>
<ul>
<li>保存ボタンをフォームの底に置き、クリックしたときにフォームの状態をJSON
に直列化してローカルストレージに保存します。</li>
<li>ページの再読み込み時にローカルストレージからJSON文書を自動的に取得しま
す。フォームのフィールドにはこの文書の内容を入れます。</li>
<li>フォームの状態を保存したり読み込んだりするのに問題があればポップアップ
の警告を出します。</li>
</ul>
<p><code>Effect.Storage</code>モジュールに以下のWebストレージAPIのためのFFIラッパーをつくることから始めていきます。</p>
<ul>
<li><code>setItem</code>はキーと値（両方とも文字列）を受け取り、指定されたキーでロー
カルストレージに値を格納する計算を返します。</li>
<li><code>getItem</code>はキーを取り、ローカルストレージから関連付けられたバリューの
取得を試みます。しかし<code>window.localStorage</code>の<code>getItem</code>メソッドは
<code>null</code>を返しうるので、返る型は<code>String</code>ではなく<code>Json</code>です。</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>以下はこれらの関数に対応するJavaScriptの実装で、<code>Effect/Storage.js</code>にあります。</p>
<pre><code class="language-js">export const setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

export const getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>以下のように保存ボタンを作ります。</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: &quot;form-group row col-form-label&quot;
    , children:
        [ D.button
            { className: &quot;btn-primary btn&quot;
            , onClick: handler_ validateAndSave
            , children: [ D.text &quot;Save&quot; ]
            }
        ]
    }
</code></pre>
<p>そして<code>validateAndSave</code>関数中では、検証された<code>person</code>をJSON文字列とし、<code>setItem</code>を使って書き込みます。</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log &quot;Running validators&quot;
  case validatePerson' person of
    Left errs -&gt; log $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;
    Right validPerson -&gt; do
      setItem &quot;person&quot; $ stringify $ encodeJson validPerson
      log &quot;Saved&quot;
</code></pre>
<p>なおこの段階でコンパイルしようとすると以下のエラーに遭遇します。</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>これはなぜかというと<code>Person</code>レコード中の<code>PhoneType</code>が<code>EncodeJson</code>インスタンスを必要としているからです。
単純に汎用符号化インスタンスと復号化インスタンスを導出すれば完了です。
この仕組みについてより詳しくはargonautのドキュメントで見られます。</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance genericPhoneType :: Generic PhoneType _

instance encodeJsonPhoneType :: EncodeJson PhoneType where encodeJson = genericEncodeJson
instance decodeJsonPhoneType :: DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>これで<code>person</code>をローカルストレージに保存できます。
しかしデータを取得できない限りあまり便利ではありません。
次はそれに取り掛かりましょう。</p>
<p>ローカルストレージから「person」文字列を取得することから始めましょう。</p>
<pre><code class="language-hs">item &lt;- getItem &quot;person&quot;
</code></pre>
<p>それからローカルストレージから<code>Person</code>レコードへの文字列の変換を扱うお助け関数をつくります。
なおこのストレージ中の文字列は<code>null</code>かもしれないので、うまく<code>String</code>として復号化されるまでは外部の<code>Json</code>として表現します。
道中には他にも多くの変換工程があり、それぞれで<code>Either</code>の値を返します。
そのためこれらを<code>do</code>ブロックの中にまとめるのは理に適っています。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>そうしてこの結果が成功しているかどうか調べます。
もし失敗していればエラーをログ出力し既定の<code>examplePerson</code>を使います。
そうでなければローカルストレージから取得した人物を使います。</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>最後にこの<code>initialPerson</code>を<code>props</code>レコードを介してコンポーネントに渡します。</p>
<pre><code class="language-hs">-- Create JSX node from react component.
app = element addressBookApp { initialPerson }
</code></pre>
<p>そして状態フックで使うために別の方から拾い上げます。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent &quot;AddressBookApp&quot; \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>仕上げとして、それぞれの<code>Left</code>値の<code>String</code>に<code>lmap</code>を使って前置し、エラー文言の質を向上させます。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap (&quot;No string in local storage: &quot; &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap (&quot;Cannot parse JSON string: &quot;   &lt;&gt; _) $ jsonParser jsonString
  lmap               (&quot;Cannot decode Person: &quot;       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>最初のエラーのみこのアプリの通常の操作内で起こります。
他のエラーはWebブラウザの開発ツールを開いてローカルストレージ中に保存された「person」文字列を編集し、そのページを参照することで引き起こせます。
どのようにJSON文字列を変更したかが、どのエラーの引き金になるかを決定します。
それぞれのエラーを引き起こせるかどうかやってみてください。</p>
<p>これでローカルストレージについては押さえました。
次に<code>alert</code>アクションを実装していきます。
このアクションは<code>Effect.Console</code>モジュールの<code>log</code>アクションによく似ています。
唯一の相違点は<code>alert</code>アクションが<code>window.alert</code>メソッドを使うことで、
対して<code>log</code>アクションは<code>console.log</code>メソッドを使っています。
そういうわけで<code>alert</code>は<code>window.alert</code>が定義された環境でのみ使うことができます。
例えばWebブラウザなどです。</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">export const alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>この警告が次のいずれかの場合に現れるようにしたいです。</p>
<ul>
<li>利用者が検証エラーを含むフォームを保存しようと試みている。</li>
<li>状態がローカルストレージから取得できない。</li>
</ul>
<p>以上は単に以下の行で<code>log</code>を<code>alert</code>に置き換えるだけで達成できます。</p>
<pre><code class="language-hs">Left errs -&gt; alert $ &quot;There are &quot; &lt;&gt; show (length errs) &lt;&gt; &quot; validation errors.&quot;

alert $ &quot;Error: &quot; &lt;&gt; err &lt;&gt; &quot;. Loading examplePerson&quot;
</code></pre>
<h2 id="演習-5"><a class="header" href="#演習-5">演習</a></h2>
<ol>
<li>（普通）<code>localStorage</code>オブジェクトの <code>removeItem</code>メソッドのラッパーを書き、
<code>Effect.Storage</code>モジュールに外部関数を追加してください</li>
<li>（普通）「リセット」ボタンを追加してください。
このボタンをクリックすると新しく作った<code>removeItem</code>関数を呼び出して
ローカルストレージから「人物」の項目を削除します。</li>
<li>（簡単）JavaScriptの <code>Window</code>オブジェクトの <code>confirm</code>メソッドのラッパーを書き、
<code>Effect.Alert</code>モジュールにその外部関数を追加してください。</li>
<li>（普通）利用者が「リセット」ボタンをクリックしたときにこの<code>confirm</code>関数を呼び出し、
本当にアドレス帳を白紙にしたいか尋ねるようにしてください。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、PureScriptから外部のJavaScriptコードを扱う方法を学びました。また、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。</p>
<ul>
<li>外部関数が正しい表現を持っていることを確かめる重要性を見てきました。</li>
<li>外部型や<code>Json</code>データ型を使用することによって、null値やJavaScriptの他の
型のデータのような特殊な場合に対処する方法を学びました。</li>
<li>安全にJSONデータを直列化・直列化復元する方法を見ました。</li>
</ul>
<p>より多くの例については、Githubの <code>purescript</code>組織、<code>purescript-contrib</code>組織および
<code>purescript-node</code>組織が、FFIを使用するライブラリの例を多数提供しています。残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾つか見ていきます。</p>
<h2 id="補遺"><a class="header" href="#補遺">補遺</a></h2>
<h3 id="javascriptからpurescriptを呼び出す"><a class="header" href="#javascriptからpurescriptを呼び出す">JavaScriptからPureScriptを呼び出す</a></h3>
<p>少なくとも単純な型を持った関数については、JavaScriptからPureScript関数を呼び出すのはとても簡単です。</p>
<p>例として以下のような簡単なモジュールを見てみましょう。</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。
関数を定義するのにPureScriptを使いたくなるかもしれない良い例となっていますが、
JavaScriptからそれを呼び出すためには条件があります。
PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装する開発者は型検証器の恩恵を受けることができます。</p>
<p>この関数をJavaScriptから呼び出す方法を理解するには、PureScriptの関数は常に引数がひとつのJavaScript関数へと変換され、引数へは次のようにひとつづつ適用していかなければならないことを理解するのが重要です。</p>
<pre><code class="language-javascript">import Test from 'Test.js';
Test.gcd(15)(20);
</code></pre>
<p>ここでは、コードがPureScriptモジュールをESモジュールにコンパイルする <code>spago build</code>でコンパイルされていると仮定しています。
そのため、 <code>import</code>を使って <code>Test</code>モジュールをインポートした後、 <code>Test</code>オブジェクトの <code>gcd</code>関数を参照することができました。</p>
<p><code>pulp build -O --to file.js</code>を使用して、ブラウザ用のJavaScriptコードをバンドルすることもできます。
その場合、グローバルなPureScript名前空間から <code>Test</code>モジュールにアクセスします。デフォルトは <code>PS</code>です。</p>
<pre><code class="language-javascript">var Test = PS.Test;
Test.gcd(15)(20);
</code></pre>
<h3 id="名前の生成を理解する"><a class="header" href="#名前の生成を理解する">名前の生成を理解する</a></h3>
<p>PureScriptはコード生成時にできるだけ名前を保存することを目的としています。具体的には、少なくともトップレベルで宣言される名前については、PureScriptやJavaScriptのキーワードでなければほとんどの識別子が保存されます。</p>
<p>識別子としてJavaScriptのキーワードを使う場合は、名前はダブルダラー記号でエスケープされます。たとえば、次のPureScriptコードを考えてみます。</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープされます。たとえば、このPureScriptコードを考えます。</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図している場合、識別子は英数字のみを使用し、JavaScriptの予約語を避けることをお勧めします。
ユーザ定義演算子がPureScriptコードでの使用のために提供される場合でも、JavaScriptから使うための英数字の名前を持った代替関数を提供しておくことをお勧めします。</p>
<h3 id="実行時のデータ表現"><a class="header" href="#実行時のデータ表現">実行時のデータ表現</a></h3>
<p>型はプログラムがある意味で「正しい」ことをコンパイル時に判断できるようにします。つまり、その点については壊れることがありません。しかし、これは何を意味するのでしょうか？PureScriptでは式の型は実行時の表現と互換性がなければならないことを意味します。</p>
<p>そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行時のデータ表現について理解することが重要です。これは、与えられた任意のPureScriptの式について、その値が実行時にどのように評価されるかという挙動を理解できるべきであることを意味しています。</p>
<p>PureScriptの式は、実行時に特に単純な表現を持っているということは朗報です。型を考慮すれば式の実行時のデータ表現を把握することが常に可能です。</p>
<p>単純な型については、対応関係はほとんど自明です。たとえば、式が型 <code>Boolean</code>を持っていれば、実行時のその値 <code>v</code>は <code>typeof v === 'boolean'</code>を満たします。つまり、型 <code>Boolean</code>の式は <code>true</code>もしくは
<code>false</code>のどちらか一方の（JavaScriptの）値へと評価されます。特に<code>null</code>や <code>undefined</code>に評価される型
<code>Boolean</code>のPureScriptの式はありません。</p>
<p><code>Int</code>や<code>Number</code>や<code>String</code>の型の式についても同様のことが成り立ちます。<code>Int</code>や<code>Number</code>型の式は
<code>null</code>でないJavaScriptの数へと評価されますし、 <code>String</code>型の式は
<code>null</code>でないJavaScriptの文字列へと評価されます。たとえ<code>typeof</code>を使うことによって型<code>Number</code>の値と見分けがつかなくなっても、型<code>Int</code>の式は実行時に整数に評価されます。</p>
<p><code>Unit</code>についてはどうでしょうか？<code>Unit</code>には現住 (<code>unit</code>)
が1つのみで値が観測できないため、実のところ実行時に何で表現されるかは重要ではありません。古いコードは<code>{}</code>を使って表現する傾向がありました。しかし比較的新しいコードでは<code>undefined</code>を使う傾向にあります。なので、<code>Unit</code>を表現するのに使うものは本当に何でも問題にならないのですが、<code>undefined</code>を使うことが推奨されます。（関数から何も返さないときも<code>undefined</code>を返します）</p>
<p>もっと複雑な型についてはどうでしょうか？</p>
<p>すでに見てきたように、PureScriptの関数は引数がひとつのJavaScriptの関数に対応しています。厳密に言えば、任意の型 <code>a</code>、 <code>b</code>について、式 <code>f</code>の型が <code>a -&gt; b</code>で、式 <code>x</code>が型 <code>a</code>についての適切な実行時表現の値へと評価されるなら、 <code>f</code>はJavaScriptの関数へと評価され、 <code>x</code>を評価した結果に <code>f</code>を適用すると、それは型 <code>b</code>の適切な実行時表現を持ちます。簡単な例としては、 <code>String -&gt; String</code>型の式は、 <code>null</code>でないJavaScript文字列から <code>null</code>でないJavaScript文字列への関数へと評価されます。</p>
<p>ご想像のとおり、PureScriptの配列はJavaScriptの配列に対応しています。しかし、PureScriptの配列は均質であり、つまりすべての要素が同じ型を持っていることは覚えておいてください。具体的には、もしPureScriptの式
<code>e</code>が何らかの型 <code>a</code>について型 <code>Array a</code>を持っているなら、 <code>e</code>はすべての要素が型
<code>a</code>の適切な実行時表現を持った（<code>null</code>でない）JavaScript配列へと評価されます。</p>
<p>PureScriptのレコードがJavaScriptのオブジェクトへと評価されることはすでに見てきました。ちょうど関数と配列の場合のように、そのラベルに関連付けられている型を考慮すれば、レコードのフィールドのデータの実行時の表現についても推論することができます。もちろん、レコードのそれぞれのフィールドは、同じ型である必要はありません。</p>
<h3 id="adtの表現"><a class="header" href="#adtの表現">ADTの表現</a></h3>
<p>PureScriptコンパイラは、代数的データ型のすべての構築子についてそれぞれ関数を定義し、新たなJavaScriptオブジェクト型を作成します。これらの構築子はこれらのプロトタイプに基づいて新しいJavaScriptオブジェクトを作成する関数に対応しています。</p>
<p>たとえば、次のような単純なADTを考えてみましょう。</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>PureScriptコンパイラは、次のようなコードを生成します。</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>ここで2つのJavaScriptオブジェクト型 <code>Zero</code>と
<code>One</code>を見てください。JavaScriptのキーワード<code>new</code>を使用すると、それぞれの型の値を作成することができます。引数を持つ構築子については、コンパイラは
<code>value0</code>、 <code>value1</code>などと呼ばれるフィールドに対応するデータを格納します。</p>
<p>PureScriptコンパイラは補助関数も生成します。引数のない構築子については、コンパイラは構築子が使われるたびに
<code>new</code>演算子を使うのではなく、データを再利用できるように
<code>value</code>プロパティを生成します。ひとつ以上の引数を持つ構築子では、適切な表現を持つ引数を取り適切な構築子を適用する
<code>create</code>関数をコンパイラは生成します。</p>
<p>2引数以上の構築子についてはどうでしょうか？その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成します。しかし今回は、補助関数は2引数のカリー化された関数です。たとえば、次のような代数的データ型を考えます。</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>このコードからは、次のようなJavaScriptコードが生成されます。</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>ここで、オブジェクト型 <code>Two</code>の値はキーワード<code>new</code>または <code>Two.create</code>関数を使用すると作成することができます。</p>
<p>newtypeの場合はまた少し異なります。newtypeは単一の引数を取る単一の構築子を持つよう制限された代数的データ型であることを思い出してください。この場合には、実際はnewtypeの実行時表現は、その引数の型と同じになります。</p>
<p>例えば、電話番号を表す次のようなnewtypeを考えます。</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>これは実行時にはJavaScriptの文字列として表されます。newtypeは型安全性の追加の層を提供しますが、実行時の関数呼び出しのオーバーヘッドがないので、ライブラリを設計するのに役に立ちます。</p>
<h3 id="量化された型の表現"><a class="header" href="#量化された型の表現">量化された型の表現</a></h3>
<p>量化された型（多相型）の式は、制限された表現を実行時に持っています。実際には、所与の量化された型を持つ式が比較的少ないということですが、これによってとても効率的に解決できることを意味しています。</p>
<p>例えば、次の多相型を考えてみます。</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>この型を持っている関数にはどんなものがあるでしょうか。少なくともひとつはこの型を持つ関数が存在しています。すなわち、
<code>Prelude</code>で定義されている恒等関数 <code>id</code>です。</p>
<pre><code class="language-haskell">id :: forall a. a -&gt; a
id a = a
</code></pre>
<p>実のところ、 <code>id</code>の関数はこの型の<strong>唯一の</strong>（全）関数です！これは確かに間違いなさそうに見えますが（この型を持った
<code>id</code>とは明らかに異なる式を書こうとしてみてください）、これを確かめるにはどうしたらいいでしょうか。これは型の実行時表現を考えることによって確認することができます。</p>
<p>量化された型 <code>forall a. t</code>の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 <code>a</code>をどのように選んでも型 <code>t</code>の適切な実行時表現を持っていなければなりません。上の例では、型 <code>forall a. a -&gt; a</code>の関数は、 <code>String -&gt; String</code>、 <code>Number -&gt; Number</code>、 <code>Array Boolean -&gt; Array Boolean</code>などといった型について、適切な実行時表現を持っていなければなりません。 これらは、文字列から文字列、数から数の関数でなくてはなりません。</p>
<p>しかし、それだけでは十分ではありません。量化された型の実行時表現は、これよりも更に厳しくなります。任意の式が<strong>パラメトリック多相的</strong>でなければなりません。つまり、その実装において、引数の型についてのどんな情報も使うことができないのです。この追加の条件は、考えられる多相型のうち、以下のJavaScriptの関数のような問題のある実装を防止します。</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>確かにこの関数は文字列から文字列、数から数へというような関数ではありますが、追加の条件を満たしていません。引数の実行時の型を調べており、したがって、この関数は型 <code>forall a. a -&gt; a</code>の正しい実装だとはいえないのです。</p>
<p>関数の引数の実行時の型を検査することができなければ、唯一の選択肢は引数をそのまま返すことだけであり、したがって <code>id</code>はたしかに <code>forall a. a -&gt; a</code>の唯一の実装なのです。</p>
<p><strong>パラメトリック多相</strong> (parametric polymorphism) と<strong>パラメトリック性</strong> (parametricity)
についての詳しい議論は本書の範囲を超えています。ただ注目していただきたいことは、PureScriptの型は、実行時に<strong>消去</strong>されているので、PureScriptの多相関数は（FFIを使わない限り）引数の実行時表現を検査することが<strong>できず</strong>、そのためこの多相的なデータの表現が適切になっているということなのです。</p>
<h3 id="制約のある型の表現"><a class="header" href="#制約のある型の表現">制約のある型の表現</a></h3>
<p>型クラス制約を持つ関数は、実行時に面白い表現を持っています。関数の振る舞いはコンパイラによって選ばれた型クラスのインスタンスに依存する可能性があるため、関数には<strong>型クラス辞書</strong>
(type class dictionary)
と呼ばれる追加の引数が与えられます。この辞書には選ばれたインスタンスから提供される型クラスの関数の実装が含まれます。</p>
<p>例えば、 <code>Show</code>型クラスを使った制約のある型を持つ、次のような単純なPureScript関数について考えます。</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>生成されるJavaScriptは次のようになります。</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p><code>shout</code>は1引数ではなく、2引数の（カリー化された）関数にコンパイルされていることに注意してください。最初の引数 <code>dict</code>は
<code>Show</code>制約の型クラス辞書です。 <code>dict</code>には型 <code>a</code>の <code>show</code>関数の実装が含まれています。</p>
<p>最初の引数として明示的に<code>Data.Show</code>の型クラス辞書を渡すと、JavaScriptからこの関数を呼び出すことができます。</p>
<pre><code class="language-javascript">import { showNumber } from 'Data.Show'

shout(showNumber)(42);
</code></pre>
<h3 id="演習-6"><a class="header" href="#演習-6">演習</a></h3>
<ol>
<li>
<p>（簡単）これらの型の実行時の表現は何でしょうか。</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>これらの型を持つ式についてわかることはなんでしょうか。</p>
</li>
<li>
<p>（普通）<code>spago build</code>を使ってコンパイルし、NodeJSの <code>import</code>機能を使ってモジュールをインポートすることで、JavaScriptから <code>arrays</code>ライブラリの関数を使ってみてください。<strong>ヒント</strong>：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。</p>
</li>
</ol>
<h3 id="副作用の表現"><a class="header" href="#副作用の表現">副作用の表現</a></h3>
<p><code>Effect</code>モナドも外部型として定義されています。その実行時表現はとても簡単です。型 <code>Effect a</code>の式は引数なしのJavaScript関数へと評価されます。この関数はあらゆる副作用を実行し型 <code>a</code>の適切な実行時表現で値を返します。</p>
<p><code>Effect</code>型構築子の定義は、 <code>Effect</code>モジュールで次のように与えられています。</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>簡単な例として、 <code>random</code>パッケージで定義される <code>random</code>関数を考えてみてください。その型は次のようなものでした。</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p><code>random</code>関数の定義は次のように与えられます。</p>
<pre><code class="language-javascript">export const random = Math.random;
</code></pre>
<p><code>random</code>関数は実行時には引数なしの関数として表現されていることに注目してください。これは乱数生成という副作用を実行しそれを返しますが、返り値は
<code>Number</code>型の実行時表現と一致します。それは <code>null</code>でないJavaScriptの数です。</p>
<p>もう少し興味深い例として、<code>console</code>パッケージ中の<code>Effect.Console</code>モジュールで定義された <code>log</code>関数を考えてみましょう。
<code>log</code>関数は次の型を持っています。</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>この定義は次のようになっています。</p>
<pre><code class="language-javascript">export const log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>実行時の
<code>log</code>の表現は、単一の引数のJavaScript関数で、引数なしの関数を返します。内側の関数はコンソールにメッセージを書き込むという副作用を実行します。</p>
<p><code>Effect a</code>型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出すことができます。例えば、この
<code>main</code>関数は何らかの型 <code>a</code>について<code>Effect a</code>という型でなければならないので、次のように実行することができます。</p>
<pre><code class="language-javascript">import { main } from 'Main'

main();
</code></pre>
<p><code>spago bundle-app --to</code>または <code>spago run</code>を使用するときは、<code>Main</code>モジュールが定義されている場合は常に、この
<code>main</code>の呼び出しを自動的に生成することができます。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter9.ja.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter11.ja.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter9.ja.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter11.ja.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

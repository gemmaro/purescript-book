<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Canvasグラフィックス - 実例によるPureScript</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">序文</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.html" class="active"><strong aria-hidden="true">12.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">実例によるPureScript</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gemmaro/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="canvasグラフィックス"><a class="header" href="#canvasグラフィックス">Canvasグラフィックス</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章は<code>canvas</code>パッケージに焦点を当てる発展的な例となります。
このパッケージはPureScriptでHTML5のCanvas APIを使用して2Dグラフィックスを生成する手段を提供します。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。</p>
<ul>
<li><code>canvas</code>はHTML5のCanvas APIメソッドの型を与えます。</li>
<li><code>refs</code>は <em>大域的な変更可能領域への参照</em> を使うための副作用を提供します。</li>
</ul>
<p>この章の各ソースコードは、<code>main</code>メソッドが定義されているモジュールの集合へと分割されています。
この章の各節の内容は個別のファイルで実装されており、各時点での適切なファイルの<code>main</code>メソッドを実行できるように、Spagoビルドコマンドを変更することで、<code>Main</code>モジュールを合わせられるようになっています。</p>
<p>HTMLファイル<code>html/index.html</code>には、各例で使用される単一の<code>canvas</code>要素、及びコンパイルされたPureScriptコードを読み込む<code>script</code>要素が含まれています。
各節のコードを試すにはブラウザでHTMLファイルを開きます。
ほとんどの演習はブラウザを対象にしているので、この章には単体試験はありません。</p>
<h2 id="単純な図形"><a class="header" href="#単純な図形">単純な図形</a></h2>
<p><code>Example/Rectangle.purs</code>ファイルには簡単な導入例が含まれています。
この例ではキャンバスの中心に青い四角形を1つ描画します。
このモジュールへは、<code>Effect</code>モジュールからの<code>Effect</code>型と、Canvas
APIを扱うための<code>Effect</code>モナドの動作を含む<code>Graphics.Canvas</code>モジュールをインポートします。</p>
<p>他のモジュールでも同様ですが、<code>main</code>動作は最初に<code>getCanvasElementById</code>動作を使ってキャンバスオブジェクトへの参照を取得し、<code>getContext2D</code>動作を使ってキャンバスの2D描画文脈にアクセスします。</p>
<p><code>void</code>関数は関手を取り値を<code>Unit</code>で置き換えます。
例では<code>main</code>がシグネチャに沿うようにするために使われています。</p>
<pre><code class="language-haskell">main :: Effect Unit
main = void $ unsafePartial do
  Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
  ctx &lt;- getContext2D canvas
</code></pre>
<p><em>補足</em>：この<code>unsafePartial</code>の呼び出しは必須です。
これは<code>getCanvasElementById</code>の結果のパターン照合部分で、<code>Just</code>値構築子のみと照合するためです。
ここではこれで問題ありませんが、恐らく実際の製品のコードでは<code>Nothing</code>値構築子と照合させ、適切なエラー文言を提供したほうがよいでしょう。</p>
<p>これらの動作の型はPSCiを使うかドキュメントを見ると確認できます。</p>
<pre><code class="language-haskell">getCanvasElementById :: String -&gt; Effect (Maybe CanvasElement)

getContext2D :: CanvasElement -&gt; Effect Context2D
</code></pre>
<p><code>CanvasElement</code>と <code>Context2D</code>は <code>Graphics.Canvas</code>モジュールで定義されている型です。
このモジュールでは<code>Canvas</code>作用も定義されており、モジュール内の全てのアクションで使用されています。</p>
<p>グラフィックス文脈<code>ctx</code>はキャンバスの状態を管理し、原始的な図形を描画したり、スタイルや色を設定したり、座標変換を適用したりするための手段を提供します。</p>
<p>話を進めると、<code>setFillStyle</code>動作を使うことで塗り潰しスタイルを濃い青に設定できます。
より長い16進数記法の<code>#0000FF</code>も青には使えますが、単純な色については略記法がより簡単です。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#00F&quot;
</code></pre>
<p><code>setFillStyle</code>動作がグラフィックス文脈を引数として取っていることに注意してください。
これは<code>Graphics.Canvas</code>ではよくあるパターンです。</p>
<p>最後に、<code>fillPath</code>動作を使用して矩形を塗り潰しています。
<code>fillPath</code>は次のような型を持っています。</p>
<pre><code class="language-haskell">fillPath :: forall a. Context2D -&gt; Effect a -&gt; Effect a
</code></pre>
<p><code>fillPath</code>はグラフィックスの文脈と描画するパスを構築する他の動作を引数に取ります。
<code>rect</code>動作を使うとパスを構築できます。
<code>rect</code>はグラフィックスの文脈と矩形の位置及びサイズを格納するレコードを取ります。</p>
<pre><code class="language-haskell">  fillPath ctx $ rect ctx
    { x: 250.0
    , y: 250.0
    , width: 100.0
    , height: 100.0
    }
</code></pre>
<p>mainモジュールの名前として<code>Example.Rectangle</code>を与えてこの長方形のコード例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Rectangle --to dist/Main.js
</code></pre>
<p>それでは <code>html/index.html</code>ファイルを開き、このコードによってキャンバスの中央に青い四角形が描画されていることを確認してみましょう。</p>
<h2 id="行多相を利用する"><a class="header" href="#行多相を利用する">行多相を利用する</a></h2>
<p>パスを描画する方法は他にもあります。
<code>arc</code>関数は円弧を描画します。
<code>moveTo</code>関数、<code>lineTo</code>関数、<code>closePath</code>関数は断片的な線分のパスを描画できます。</p>
<p><code>Shapes.purs</code>ファイルでは長方形と円弧と三角形の、3つの図形を描画しています。</p>
<p><code>rect</code>関数は引数としてレコードをとることを見てきました。
実際には、長方形のプロパティは型同義語で定義されています。</p>
<pre><code class="language-haskell">type Rectangle =
  { x :: Number
  , y :: Number
  , width :: Number
  , height :: Number
  }
</code></pre>
<p><code>x</code>と<code>y</code>プロパティは左上隅の位置を表しており、<code>w</code>と<code>h</code>のプロパティはそれぞれ幅と高さを表しています。</p>
<p><code>arc</code>関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画できます。</p>
<pre><code class="language-haskell">type Arc =
  { x      :: Number
  , y      :: Number
  , radius :: Number
  , start  :: Number
  , end    :: Number
  }
</code></pre>
<p>ここで、<code>x</code>と<code>y</code>プロパティは弧の中心、<code>r</code>は半径、<code>start</code>と<code>end</code>は弧の両端の角度を弧度法で表しています。</p>
<p>例えばこのコードは中心が<code>(300, 300)</code>に中心があり半径<code>50</code>の円弧を塗り潰します。
弧は1回転のうち2/3ラジアン分あります。
単位円が上下逆様になっている点に注意してください。
これはy軸がキャンバスの下向きに伸びるためです。</p>
<pre><code class="language-haskell">  fillPath ctx $ arc ctx
    { x      : 300.0
    , y      : 300.0
    , radius : 50.0
    , start  : 0.0
    , end    : Math.tau * 2.0 / 3.0
    }
</code></pre>
<p><code>Rectangle</code>レコード型と<code>Arc</code>レコード型の両方共、<code>Number</code>型の<code>x</code>と<code>y</code>というプロパティを含んでいますね。
どちらの場合でもこの組は点を表しています。
つまり、何れのレコード型にも作用する行多相な関数を書けます。</p>
<p>例えば<code>Shapes</code>モジュールでは<code>x</code>と<code>y</code>のプロパティを変更し図形を並行移動する<code>translate</code>関数が定義されています。</p>
<pre><code class="language-haskell">translate
  :: forall r
   . Number
  -&gt; Number
  -&gt; { x :: Number, y :: Number | r }
  -&gt; { x :: Number, y :: Number | r }
translate dx dy shape = shape
  { x = shape.x + dx
  , y = shape.y + dy
  }
</code></pre>
<p>この行多相型に注目してください。
<code>translate</code>が <code>x</code>と
<code>y</code>というプロパティと、<em>それに加えて他の任意のプロパティ</em>を持つどんなレコードでも受け入れ、同じ型のレコードを返すと書かれています。
<code>x</code>フィールドと <code>y</code>フィールドは更新されますが、残りのフィールドは変更されません。</p>
<p>これは<em>レコード更新構文</em>の例です。
<code>shape { ... }</code>という式は、<code>shape</code>を元にして、括弧の中で指定された値で更新されたフィールドを持つ新たなレコードを作ります。
なお、波括弧の中の式はレコード直値のようなコロンではなく、等号でラベルと式を区切って書きます。</p>
<p><code>Shapes</code>の例からわかるように、<code>translate</code>関数は<code>Rectangle</code>レコードと<code>Arc</code>レコード双方に対して使えます。</p>
<p><code>Shape</code>の例で描画される3つ目の型は線分の断片からなるパスです。
対応するコードは次のようになります。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;

  fillPath ctx $ do
    moveTo ctx 300.0 260.0
    lineTo ctx 260.0 340.0
    lineTo ctx 340.0 340.0
    closePath ctx
</code></pre>
<p>ここでは3つの関数が使われています。</p>
<ul>
<li><code>moveTo</code>はパスの現在地を指定された座標に移動します。</li>
<li><code>lineTo</code>は現在地と指定された座標の間の線分を描画し、現在地を更新します。</li>
<li><code>closePath</code>は現在地と開始地点とを結ぶ線分を描画してパスを完結します。</li>
</ul>
<p>このコード片の結果は二等辺三角形の塗り潰しになります。</p>
<p>mainモジュールとして<code>Example.Shapes</code>を指定して、この例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Shapes --to dist/Main.js
</code></pre>
<p>そしてもう一度<code>html/index.html</code>を開き、結果を確認してください。
キャンバスに3つの異なる図形が描画されるはずです。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>
<p>（簡単）これまでの各例について、<code>strokePath</code>関数や<code>setStrokeStyle</code>関数を使ってみましょう。</p>
</li>
<li>
<p>（簡単）関数の引数の内部でdo記法ブロックを使うと、<code>fillPath</code>関数と<code>strokePath</code>関数は共通のスタイルを持つ複雑なパスを描画できます。
同じ<code>fillPath</code>呼び出しを使って隣り合う2つの矩形を描画するように、<code>Rectangle</code>の例を変更してみてください。
線分と円弧の組み合わせを使って、扇形を描画してみてください。</p>
</li>
<li>
<p>（普通）次のような2次元の点を表すレコードが与えられたとします。</p>
<pre><code class="language-haskell">type Point = { x :: Number, y :: Number }
</code></pre>
<p>これは2次元の点を表現しています。
多数の点からなる閉じたパスを線描きする関数 <code>renderPath</code>を書いてください。</p>
<pre><code class="language-haskell">renderPath
  :: Context2D
  -&gt; Array Point
  -&gt; Effect Unit
</code></pre>
<p>次のような関数を考えます。</p>
<pre><code class="language-haskell">f :: Number -&gt; Point
</code></pre>
<p>この関数は引数として<code>1</code>から<code>0</code>の間の<code>Number</code>を取り、<code>Point</code>を返します。
<code>renderPath</code>関数を使い、関数<code>f</code>のグラフを描く動作を書いてください。
その動作では有限個の点で<code>f</code>を標本化することによって近似しなければなりません。</p>
<p>関数 <code>f</code>を変更し、様々なパスが描画されることを確かめてください。</p>
</li>
</ol>
<h2 id="無作為に円を描く"><a class="header" href="#無作為に円を描く">無作為に円を描く</a></h2>
<p><code>Example/Random.purs</code>ファイルには、<code>Effect</code>モナドを使って2種類の副作用を綴じ合わせる例が含まれています。
1つの副作用は乱数生成で、もう1つはキャンバスの操作です。
この例では無作為に生成された円をキャンバスに100個描画します。</p>
<p><code>main</code>動作ではこれまでのようにグラフィックス文脈への参照を取得し、線描きと塗り潰しのスタイルを設定します。</p>
<pre><code class="language-haskell">  setFillStyle ctx &quot;#F00&quot;
  setStrokeStyle ctx &quot;#000&quot;
</code></pre>
<p>次のコードでは<code>for_</code>動作を使って<code>0</code>から<code>100</code>までの整数について反復しています。</p>
<pre><code class="language-haskell">  for_ (1 .. 100) \_ -&gt; do
</code></pre>
<p>各繰り返しで、do記法ブロックは<code>0</code>と<code>1</code>の間に分布する3つの乱数を生成することから始まります。
これらの数はそれぞれ<code>x</code>座標、<code>y</code>座標、半径<code>r</code>を表しています。</p>
<pre><code class="language-haskell">    x &lt;- random
    y &lt;- random
    r &lt;- random
</code></pre>
<p>次のコードでは各円について、これらの変数に基づいて<code>Arc</code>を作成し、最後に現在のスタイルに従って円弧を塗り潰し、線描きします。</p>
<pre><code class="language-haskell">    let path = arc ctx
         { x                  : x * 600.0
         , y                  : y * 600.0
         , radius             : r * 50.0
         , start              : 0.0
         , end                : Number.tau
         , useCounterClockwise: false
         }

    fillPath ctx path
    strokePath ctx path
</code></pre>
<p>mainモジュールとして<code>Example.Random</code>を指定して、この例をビルドしましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Random --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いて、結果を確認してみましょう。</p>
<h2 id="座標変換"><a class="header" href="#座標変換">座標変換</a></h2>
<p>キャンバスは簡単な図形を描画するだけのものではありません。
キャンバスは座標変換を管理しており、描画の前に図形を変形するのに使えます。
図形は平行移動、回転、拡大縮小、及び斜めに変形できます。</p>
<p><code>canvas</code>ライブラリではこれらの変換を以下の関数で提供しています。</p>
<pre><code class="language-haskell">translate :: Context2D
          -&gt; TranslateTransform
          -&gt; Effect Context2D

rotate    :: Context2D
          -&gt; Number
          -&gt; Effect Context2D

scale     :: Context2D
          -&gt; ScaleTransform
          -&gt; Effect Context2D

transform :: Context2D
          -&gt; Transform
          -&gt; Effect Context2D
</code></pre>
<p><code>translate</code>動作は<code>TranslateTransform</code>レコードのプロパティで指定した大きさだけ平行移動します。</p>
<p><code>rotate</code>動作は最初の引数で指定されたラジアンの数値に応じて、原点を中心として回転します。</p>
<p><code>scale</code>動作は原点を中心として拡大縮小します。
<code>ScaleTransform</code>レコードは<code>x</code>軸と<code>y</code>軸に沿った拡大率を指定するのに使います。</p>
<p>最後の <code>transform</code>はこの4つのうちで最も一般化された動作です。
この動作では行列に従ってアフィン変換します。</p>
<p>これらの動作が呼び出された後に描画される図形は、自動的に適切な座標変換が適用されます。</p>
<p>実際には、これらの関数の各作用は、文脈の現在の変換行列に対して変換行列を<em>右から乗算</em>していきます。
つまり、もしある作用の変換をしていくと、その作用は実際には逆順に適用されていきます。</p>
<pre><code class="language-haskell">transformations ctx = do
  translate ctx { translateX: 10.0, translateY: 10.0 }
  scale ctx { scaleX: 2.0, scaleY: 2.0 }
  rotate ctx (Math.tau / 4.0)

  renderScene
</code></pre>
<p>この一連の動作の作用では、まずシーンが回転され、それから拡大縮小され、最後に平行移動されます。</p>
<h2 id="文脈の保存"><a class="header" href="#文脈の保存">文脈の保存</a></h2>
<p>座標変換を使ってシーンの一部を描画し、それからその変換を元に戻す、という使い方はよくあります。</p>
<p>Canvas APIにはキャンバスの状態の<em>スタック</em>を操作する<code>save</code>と<code>restore</code>メソッドが備わっています。
<code>canvas</code>ではこの機能を次のような関数で梱包しています。</p>
<pre><code class="language-haskell">save
  :: Context2D
  -&gt; Effect Context2D

restore
  :: Context2D
  -&gt; Effect Context2D
</code></pre>
<p><code>save</code>動作は現在の文脈の状態（現在の変換行列や描画スタイル）をスタックにプッシュし、<code>restore</code>動作はスタックの一番上の状態をポップし、文脈の状態を復元します。</p>
<p>これらの動作により、現在の状態を保存し、いろいろなスタイルや変換を適用してから原始的な図形を描画し、最後に元の変換と状態を復元できます。
例えば次の関数は幾つかのキャンバス動作を実行しますが、その前に回転を適用し、その後に変換を復元します。</p>
<pre><code class="language-haskell">rotated ctx render = do
  save ctx
  rotate (Math.tau / 3.0) ctx
  render
  restore ctx
</code></pre>
<p>こういったよくある高階関数の使われ方の抽象化として、<code>canvas</code>ライブラリでは元の文脈状態を保存しつつ幾つかのキャンバス動作を実行する<code>withContext</code>関数が提供されています。</p>
<pre><code class="language-haskell">withContext
  :: Context2D
  -&gt; Effect a
  -&gt; Effect a
</code></pre>
<p><code>withContext</code>を使うと、先ほどの <code>rotated</code>関数を次のように書き換えることができます。</p>
<pre><code class="language-haskell">rotated ctx render =
  withContext ctx do
    rotate (Math.tau / 3.0) ctx
    render
</code></pre>
<h2 id="大域的な変更可能状態"><a class="header" href="#大域的な変更可能状態">大域的な変更可能状態</a></h2>
<p>この節では <code>refs</code>パッケージを使って <code>Effect</code>モナドの別の作用について実演してみます。</p>
<p><code>Effect.Ref</code>モジュールでは、大域的に変更可能な参照のための型構築子、及びそれに紐付く作用を提供します。</p>
<pre><code class="language-text">&gt; import Effect.Ref

&gt; :kind Ref
Type -&gt; Type
</code></pre>
<p>型<code>Ref a</code>の値は型<code>a</code>の値を含む可変参照セルであり、大域的な変更を追跡するのに使われます。
そういったわけでこれは少しだけ使う分に留めておくべきです。</p>
<p><code>Example/Refs.purs</code>ファイルには <code>canvas</code>要素上のマウスクリックを追跡するのに <code>Ref</code>を使う例が含まれます。</p>
<p>このコードでは最初に<code>new</code>動作を使って値<code>0</code>を含む新しい参照を作成しています。</p>
<pre><code class="language-haskell">  clickCount &lt;- Ref.new 0
</code></pre>
<p>クリックイベント制御子の内部では、<code>modify</code>動作を使用してクリック数を更新し、更新された値が返されています。</p>
<pre><code class="language-haskell">    count &lt;- Ref.modify (\count -&gt; count + 1) clickCount
</code></pre>
<p><code>render</code>関数ではクリック数に応じた変換を矩形に適用しています。</p>
<pre><code class="language-haskell">  withContext ctx do
    let scaleX = Number.sin (toNumber count * Number.tau / 8.0) + 1.5
    let scaleY = Number.sin (toNumber count * Number.tau / 12.0) + 1.5

    translate ctx { translateX: 300.0, translateY:  300.0 }
    rotate ctx (toNumber count * Number.tau / 36.0)
    scale ctx { scaleX: scaleX, scaleY: scaleY }
    translate ctx { translateX: -100.0, translateY: -100.0 }

    fillPath ctx $ rect ctx
      { x: 0.0
      , y: 0.0
      , width: 200.0
      , height: 200.0
      }
</code></pre>
<p>この動作では元の変換を保存するために<code>withContext</code>を使用しており、それから一連の変換を適用しています（変換が下から上に適用されることを思い出してください）。</p>
<ul>
<li>矩形が<code>(-100, -100)</code>だけ平行移動し、中心が原点に来ます。</li>
<li>矩形が原点を中心に拡大されます。</li>
<li>矩形が原点を中心に<code>10</code>の倍数分の角度で回転します。</li>
<li>矩形が<code>(300, 300)</code>だけ平行移動し、中心がキャンバスの中心に来ます。</li>
</ul>
<p>このコード例をビルドしてみましょう。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.Refs --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>ファイルを開いてみましょう。
緑の四角形が表示され、何度かキャンバスをクリックするとキャンバスの中心の周りで回転するはずです。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（簡単）パスの線描と塗り潰しを同時に行う高階関数を書いてください。
その関数を使用して<code>Random.purs</code>の例を書き直してください。</li>
<li>（普通）<code>Random</code>作用と<code>Dom</code>作用を使用して、マウスがクリックされたときに、キャンバスに無作為な位置、色、半径の円を描画するアプリケーションを作成してください。</li>
<li>（普通）指定された座標の点を中心として回転させることでシーンを変換する関数を書いてください。
<em>手掛かり</em>：変換を使い、最初にシーンを原点まで平行移動しましょう。</li>
</ol>
<h2 id="l-system"><a class="header" href="#l-system">L-System</a></h2>
<p>この章の最後の例として、 <code>canvas</code>パッケージを使用して<em>L-system</em>（またの名を<em>Lindenmayer
system</em>）を描画する関数を記述します。</p>
<p>1つのL-Systemは<em>アルファベット</em>、つまりアルファベット由来の文字の初期の並びと、<em>生成規則</em>の集合で定義されます。
各生成規則は、アルファベットの文字を取り、それを置き換える文字の並びを返します。
この処理は文字の初期の並びから始まり、複数回繰り返されます。</p>
<p>もしアルファベットの各文字がキャンバス上で実行される命令と対応付けられていれば、その指示に順番に従うことでL-Systemを描画できます。</p>
<p>例えばアルファベットが文字<code>L</code>（左回転）、<code>R</code>（右回転）、<code>F</code>（前進）で構成されているとします。
次のような生成規則を定義できます。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF
</code></pre>
<p>配列 &quot;FRRFRRFRR&quot; から始めて処理を繰り返すと、次のような経過を辿ります。</p>
<pre><code class="language-text">FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...
</code></pre>
<p>というように続きます。
この命令群に対応する線分パスをプロットすると、<em>コッホ曲線</em>に近似されます。
反復回数を増やすと、曲線の解像度が増していきます。</p>
<p>それでは型と関数のある言語へとこれを翻訳してみましょう。</p>
<p>アルファベットの文字は以下のADTで表現できます。</p>
<pre><code class="language-haskell">data Letter = L | R | F
</code></pre>
<p>このデータ型では、アルファベットの文字ごとに1つずつデータ構築子が定義されています。</p>
<p>文字の初期配列はどのように表したらいいでしょうか。
単なるアルファベットの配列でいいでしょう。
これを <code>Sentence</code>と呼ぶことにします。</p>
<pre><code class="language-haskell">type Sentence = Array Letter

initial :: Sentence
initial = [F, R, R, F, R, R, F, R, R]
</code></pre>
<p>生成規則は以下のように<code>Letter</code>から <code>Sentence</code>への関数として表すことができます。</p>
<pre><code class="language-haskell">productions :: Letter -&gt; Sentence
productions L = [L]
productions R = [R]
productions F = [F, L, F, R, R, F, L, F]
</code></pre>
<p>これはまさに上記の仕様をそのまま書き写したものです。</p>
<p>これで、この形式の仕様を受け取ってキャンバスに描画する関数<code>lsystem</code>を実装できます。
<code>lsystem</code>はどのような型を持っているべきでしょうか。
<code>initial</code>や<code>productions</code>のような値だけでなく、アルファベットの文字をキャンバスに描画できる関数を引数に取る必要があります。</p>
<p><code>lsystem</code>の型の最初の大まかな設計は以下です。</p>
<pre><code class="language-haskell">Sentence
-&gt; (Letter -&gt; Sentence)
-&gt; (Letter -&gt; Effect Unit)
-&gt; Int
-&gt; Effect Unit
</code></pre>
<p>最初の2つの引数の型は、値 <code>initial</code>と <code>productions</code>に対応しています。</p>
<p>3番目の引数は、アルファベットの文字を取り、キャンバス上の幾つかの動作を実行することによって<em>解釈</em>する関数を表します。
この例では、文字<code>L</code>は左回転、文字<code>R</code>で右回転、文字<code>F</code>は前進を意味します。</p>
<p>最後の引数は、実行したい生成規則の繰り返し回数を表す数です。</p>
<p>最初に気付くことは、この<code>lsystem</code>関数は1つの型<code>Letter</code>に対してのみ動作するのですが、どんなアルファベットについても機能すべきですから、この型はもっと一般化されるべきです。
それでは、量子化された型変数 <code>a</code>について、<code>Letter</code>と <code>Sentence</code>を <code>a</code>と <code>Array a</code>で置き換えましょう。</p>
<pre><code class="language-haskell">forall a. Array a
          -&gt; (a -&gt; Array a)
          -&gt; (a -&gt; Effect Unit)
          -&gt; Int
          -&gt; Effect Unit
</code></pre>
<p>次に気付くこととしては、「左回転」と「右回転」のような命令を実装するためには、幾つかの状態を管理する必要があります。
具体的に言えば、その時点でパスが動いている方向を状態として持たなければなりません。
計算を通じて状態を渡すように関数を変更する必要があります。
ここでも<code>lsystem</code>関数は状態がどんな型でも動作したほうがよいので、型変数<code>s</code>を使用してそれを表しています。</p>
<p>型 <code>s</code>を追加する必要があるのは3箇所で、次のようになります。</p>
<pre><code class="language-haskell">forall a s. Array a
            -&gt; (a -&gt; Array a)
            -&gt; (s -&gt; a -&gt; Effect s)
            -&gt; Int
            -&gt; s
            -&gt; Effect s
</code></pre>
<p>まず追加の引数の型として <code>lsystem</code>に型 <code>s</code>が追加されています。
この引数はL-Systemの初期状態を表しています。</p>
<p>型
<code>s</code>は引数にも現れますが、解釈関数（<code>lsystem</code>の第3引数）の返り値の型としても現れます。解釈関数は今のところ、引数としてL-Systemの現在の状態を受け取り、返り値として更新された新しい状態を返します。</p>
<p>この例の場合では、次のような型を使って状態を表す型を定義できます。</p>
<pre><code class="language-haskell">type State =
  { x :: Number
  , y :: Number
  , theta :: Number
  }
</code></pre>
<p>プロパティ <code>x</code>と <code>y</code>はパスの現在の位置を表しています。
プロパティ<code>theta</code>はパスの現在の向きを表しており、ラジアンで表された水平線に対するパスの角度として指定されています。</p>
<p>システムの初期状態は次のように指定されます。</p>
<pre><code class="language-haskell">initialState :: State
initialState = { x: 120.0, y: 200.0, theta: 0.0 }
</code></pre>
<p>それでは、 <code>lsystem</code>関数を実装してみます。定義はとても単純であることがわかるでしょう。</p>
<p><code>lsystem</code>は第4引数の値（型は<code>Int</code>）に応じて再帰するのが良さそうです。
再帰の各ステップでは、生成規則に従って状態が更新され、現在の文が変化していきます。
このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を移譲することから始めましょう。</p>
<pre><code class="language-haskell">lsystem :: forall a s
         . Array a
        -&gt; (a -&gt; Array a)
        -&gt; (s -&gt; a -&gt; Effect s)
        -&gt; Int
        -&gt; s
        -&gt; Effect s
lsystem init prod interpret n state = go init n
  where
</code></pre>
<p><code>go</code>関数は第2引数について再帰することで動作します。
場合分けは2つであり、<code>n</code>がゼロであるときと<code>n</code>がゼロでないときです。</p>
<p>1つ目の場合は再帰は完了し、解釈関数に応じて現在の文を解釈します。
型<code>Array a</code>の文、型<code>s</code>の状態、型<code>s -&gt; a -&gt; Effect s</code>の関数があります。
以前定義した<code>foldM</code>の出番のようです。
この関数は<code>control</code>パッケージで手に入ります。</p>
<pre><code class="language-haskell">  go s 0 = foldM interpret state s
</code></pre>
<p>ゼロでない場合ではどうでしょうか。
その場合は、単に生成規則を現在の文のそれぞれの文字に適用して、その結果を連結し、そして再帰的に<code>go</code>を呼び出すことによって繰り返します。</p>
<pre><code class="language-haskell">  go s i = go (concatMap prod s) (i - 1)
</code></pre>
<p>これだけです。
<code>foldM</code>や<code>concatMap</code>のような高階関数を使うと、アイデアを簡潔に表現できるのです。</p>
<p>しかし、話はこれで終わりではありません。
ここで与えた型は、実際はまだ特殊化されすぎています。
この定義ではキャンバスの操作が実装のどこにも使われていないことに注目してください。
それに、全く<code>Effecta</code>モナドの構造を利用していません。
実際には、この関数は<em>どんな</em>モナド<code>m</code>についても動作します。</p>
<p>この章に添付されたソースコードで指定されている<code>lsystem</code>の型はもっと一般的になっています。</p>
<pre><code class="language-haskell">lsystem :: forall a m s
         . Monad m
         =&gt; Array a
         -&gt; (a -&gt; Array a)
         -&gt; (s -&gt; a -&gt; m s)
         -&gt; Int
         -&gt; s
         -&gt; m s
</code></pre>
<p>この型で書かれていることは、この解釈関数はモナド<code>m</code>が持つ任意の副作用を完全に自由に持つことができる、ということだと理解できます。
キャンバスに描画したり、またはコンソールに情報を出力したりするかもしれませんし、失敗や複数の戻り値に対応しているかもしれません。
こういった様々な型の副作用を使ったL-Systemを記述してみることを読者にお勧めします。</p>
<p>この関数は実装からデータを分離することの威力を示す良い例となっています。
この手法の利点は、複数の異なる方法でデータを解釈できることです。
さらに<code>lsystem</code>を2つの小さな関数へと分解できます。
1つ目は<code>concatMap</code>の適用の繰り返しを使って文を構築するもの、2つ目は<code>foldM</code>を使って文を解釈するものです。
これは読者の演習として残しておきます。</p>
<p>それでは解釈関数を実装して、この章の例を完成させましょう。
<code>lsystem</code>の型が教えてくれているのは、型シグネチャが、何らかの型 <code>a</code>と <code>s</code>、型構築子 <code>m</code>について、 <code>s -&gt; a -&gt; m s</code>でなければならないということです。
<code>a</code>を <code>Letter</code>、 <code>s</code>を <code>State</code>、モナド <code>m</code>を <code>Effect</code>というように選びたいということがわかっています。
これにより次のような型になります。</p>
<pre><code class="language-haskell">    interpret :: State -&gt; Letter -&gt; Effect State
</code></pre>
<p>この関数を実装するには、 <code>Letter</code>型の3つのデータ構築子それぞれについて処理する必要があります。文字 <code>L</code>（左回転）と
<code>R</code>（右回転）の解釈では、<code>theta</code>を適切な角度へ変更するように状態を更新するだけです。</p>
<pre><code class="language-haskell">    interpret state L = pure $ state { theta = state.theta - Number.tau / 6.0 }
    interpret state R = pure $ state { theta = state.theta + Number.tau / 6.0 }
</code></pre>
<p>文字<code>F</code>（前進）を解釈するには、次のようにパスの新しい位置を計算し、線分を描画し、状態を更新します。</p>
<pre><code class="language-haskell">    interpret state F = do
      let x = state.x + Number.cos state.theta * 1.5
          y = state.y + Number.sin state.theta * 1.5
      moveTo ctx state.x state.y
      lineTo ctx x y
      pure { x, y, theta: state.theta }
</code></pre>
<p>なお、この章のソースコードでは、名前 <code>ctx</code>がスコープに入るように、<code>interpret</code>関数は <code>main</code>関数内で
<code>let</code>束縛を使用して定義されています。
<code>State</code>型が文脈を持つように変更できるでしょうが、それはこのシステムの状態の変化する部分ではないので不適切でしょう。</p>
<p>このL-Systemを描画するには、次のような<code>strokePath</code>動作を使用するだけです。</p>
<pre><code class="language-haskell">  strokePath ctx $ lsystem initial productions interpret 5 initialState
</code></pre>
<p>次のコマンドを使ってL-Systemをコンパイルします。</p>
<pre><code class="language-text">$ spago bundle-app --main Example.LSystem --to dist/Main.js
</code></pre>
<p><code>html/index.html</code>を開いてみましょう。
キャンバスにコッホ曲線が描画されるのがわかると思います。</p>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>strokePath</code>の代わりに <code>fillPath</code>を使用するように、上のL-Systemの例を変更してください。
<em>手掛かり</em>：<code>closePath</code>の呼び出しを含め、 <code>moveTo</code>の呼び出しを <code>interpret</code>関数の外側に移動する必要があります。</p>
</li>
<li>
<p>（簡単）描画システムへの影響を理解するために、コード中の様々な数値の定数を変更してみてください。</p>
</li>
<li>
<p>（普通）<code>lsystem</code>関数を2つの小さな関数に分割してください。
1つ目は<code>concatMap</code>の適用の繰り返しを使用して最終的な文を構築するもので、2つ目は
<code>foldM</code>を使用して結果を解釈するものでなくてはなりません。</p>
</li>
<li>
<p>（普通）<code>setShadowOffsetX</code>、<code>setShadowOffsetY</code>、<code>setShadowBlur</code>、<code>setShadowColor</code>動作を使い、塗りつぶされた図形にドロップシャドウを追加してください。
<em>手掛かり</em>：PSCiを使って、これらの関数の型を調べてみましょう。</p>
</li>
<li>
<p>（普通）向きを変えるときの角度の大きさは今のところ一定 (<code>tau/6</code>) です。
これに代えて、<code>Letter</code>データ型の中に角度を移動させ、生成規則によって変更できるようにしてください。</p>
<pre><code class="language-haskell">type Angle = Number

data Letter = L Angle | R Angle | F
</code></pre>
<p>この新しい情報を生成規則でどう使うと、面白い図形を作ることができるでしょうか。</p>
</li>
<li>
<p>（難しい）4つの文字からなるアルファベットでL-Systemが与えられたとします。
それぞれ<code>L</code>（60度左回転）、<code>R</code>（60度右回転）、<code>F</code>（前進）、<code>M</code>（これも前進）です。</p>
<p>このシステムの文の初期状態は、単一の文字 <code>M</code>です。</p>
<p>このシステムの生成規則は次のように指定されています。</p>
<pre><code class="language-text">L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM
</code></pre>
<p>このL-Systemを描画してください。
<em>補足</em>：最後の文のサイズは反復回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を削減する必要があります。</p>
<p>ここで、生成規則における <code>L</code>と <code>M</code>の間の対称性に注目してください。2つの「前進」命令は、次のようなアルファベット型を使用すると、<code>Boolean</code>値を使って区別できます。</p>
<pre><code class="language-haskell">data Letter = L | R | F Boolean
</code></pre>
<p>このアルファベットの表現を使用して、もう一度このL-Systemを実装してください。</p>
</li>
<li>
<p>（難しい）解釈関数で別のモナド <code>m</code>を使ってみましょう。<code>Effect.Console</code>作用を利用してコンソール上にL-Systemを出力したり、<code>Random</code>作用を利用して状態の型に無作為の「突然変異」を適用したりしてみてください。</p>
</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、<code>canvas</code>ライブラリを使用することにより、PureScriptからHTML5 Canvas APIを使う方法について学びました。
また、これまで学んできた多くの手法からなる実用的な実演を見ました。
マップや畳み込み、レコードと行多相、副作用を扱うための<code>Effect</code>モナドです。</p>
<p>この章の例では、高階関数の威力を示すとともに、 <em>実装からのデータの分離</em>
も実演してみせました。これは例えば、代数データ型を使用してこれらの概念を次のように拡張し、描画関数からシーンの表現を完全に分離できるようになります。</p>
<pre><code class="language-haskell">data Scene
  = Rect Rectangle
  | Arc Arc
  | PiecewiseLinear (Array Point)
  | Transformed Transform Scene
  | Clipped Rectangle Scene
  | ...
</code></pre>
<p>この手法は<code>drawing</code>パッケージで採られており、描画前に様々な方法でシーンをデータとして操作できる柔軟性を齎しています。</p>
<p>キャンバスに描画されるゲームの例については<a href="https://github.com/JordanMartinez/purescript-cookbook/blob/master/README.md#recipes">cookbook</a>の「Behavior」と「Signal」のレシピを見てください。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter11.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter13.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter11.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter13.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

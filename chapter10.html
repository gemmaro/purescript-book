<!DOCTYPE HTML>
<html lang="ja" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>外部関数インターフェース - 実例によるPureScript</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">序文</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.html" class="active"><strong aria-hidden="true">10.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvasグラフィックス</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> テストの自動生成</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> 領域特化言語</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">実例によるPureScript</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gemmaro/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="外部関数インターフェース"><a class="header" href="#外部関数インターフェース">外部関数インターフェース</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>本章ではPureScriptの<em>外部関数インターフェース</em> (foreign function interface; <em>FFI</em>) を紹介します。
これによりPureScriptコードからJavaScriptコードへの呼び出し、及びその逆が可能になります。
以下の方法を押さえていきます。</p>
<ul>
<li>純粋で、作用のある、非同期なJavaScript関数をPureScriptから呼び出す。</li>
<li>型付けされていないデータを扱う。</li>
<li><code>argonaut</code>パッケージを使ってJSONにエンコードしたりJSONを構文解析したりする。</li>
</ul>
<p>この章の終わりにかけて、住所録の例に立ち返ります。
この章の目的は、FFIを使ってアプリケーションに次の新しい機能を追加することです。</p>
<ul>
<li>利用者にポップアップ通知で警告する。</li>
<li>フォームのデータを直列化してブラウザのローカルストレージに保存し、アプリケーションが再起動したときにそれを再読み込みする</li>
</ul>
<p>さらに一般にはそこまで重用されない幾つかの追加の話題を押さえた補遺もあります。
ご自由にこれらの節を読んで構いませんが、学習目標にあまり関係しなければ、本書の残りを読み進める妨げにならないようにしてください。</p>
<ul>
<li>実行時のPureScriptの値の表現を理解する。</li>
<li>JavaScriptからPureScriptを呼び出す。</li>
</ul>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。
そうしたわけでソースツリーにはこれらの章からの適切なソースファイルが含まれています。</p>
<p>この章は<code>argonaut</code>ライブラリを依存関係として導入しています。
このライブラリはJSONにエンコードしたりJSONをデコードしたりするために使います。</p>
<p>この章の演習は<code>test/MySolutions.purs</code>に書き、<code>spago test</code>を走らせることによって<code>test/Main.purs</code>中の単体試験について確認できます。</p>
<p>住所録アプリは<code>parcel src/index.html --open</code>で立ち上げることができます。8章と同じ作業の流れになっているので、より詳しい説明についてはそちらの章を参照してください。</p>
<h2 id="免責事項"><a class="header" href="#免責事項">免責事項</a></h2>
<p>JavaScriptの扱いをできる限り単純にするため、PureScriptは直感的な外部関数インターフェースを提供しています。
しかし、FFIはこの言語の<em>応用的な</em>機能であることには心に留めておかれると良いでしょう。
安全かつ効率的に使用するには、扱うつもりであるデータの実行時の表現について理解していなければなりません。
この章では、PureScriptの標準ライブラリのコードに付いて回るそのような理解を伝授することを目指します。</p>
<p>PureScriptのFFIはとても柔軟に設計されています。
実際には、外部関数にとても単純な型を与えるか、型システムを利用して外部のコードの誤った使い方を防ぐようにするか、開発者が選べるようになっています。
標準ライブラリのコードは、後者の手法を採る傾向にあります。</p>
<p>簡単な例としては、JavaScriptの関数で戻り値が <code>null</code>にならないことは保証できません。
実のところ、JavaScriptらしさのあるコードはかなり頻繁に <code>null</code>を返します。
しかし、大抵PureScriptの型にnull値が巣喰うことはありません。
そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するとき、これらの特殊な場合を適切に処理するのは開発者の責任です。</p>
<h2 id="purescriptからjavascriptを呼び出す"><a class="header" href="#purescriptからjavascriptを呼び出す">PureScriptからJavaScriptを呼び出す</a></h2>
<p>PureScriptからJavaScriptコードを使用する最も簡単な方法は、 <em>外部インポート宣言</em> (foreign import
declaration) を使用し、既存のJavaScriptの値に型を与えることです。
外部インポート宣言には <em>外部JavaScriptモジュール</em> (foreign JavaScript module) から <em>エクスポートされた</em>
対応するJavaScriptでの宣言がなくてはなりません。</p>
<p>例えば特殊文字をエスケープすることによりURIのコンポーネントをエンコードするJavaScriptの
<code>encodeURIComponent</code>関数について考えてみます。</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p>この関数は関数の型<code>String -&gt; String</code>について適切な実行時表現を持っています。
<code>null</code>でない文字列を取って<code>null</code>でない文字列にするもので、副作用を持たないからです。</p>
<p>次のような外部インポート宣言を使うと、この関数に型を割り当てることができます。</p>
<pre><code class="language-haskell">module Test.URI where

foreign import _encodeURIComponent :: String -&gt; String
</code></pre>
<p>インポートしてくるための外部JavaScriptモジュールを書く必要もあります。
対応する外部JavaScriptモジュールは、同名で拡張子が<code>.purs</code>から<code>.js</code>に変わったものです。
上のPureScriptモジュールが<code>URI.purs</code>として保存されているなら、外部JavaScriptモジュールを<code>URI.js</code>として保存します。
<code>encodeURIComponent</code>は既に定義されているので、<code>_encodeURIComponent</code>としてエクスポートせねばなりません。</p>
<pre><code class="language-javascript">"use strict";

export const _encodeURIComponent = encodeURIComponent;
</code></pre>
<p>バージョン0.15からPureScriptはJavaScriptと通訳する際にESモジュールシステムを使います。
ESモジュールではオブジェクトに<code>export</code>キーワードを与えることで関数と値がモジュールからエクスポートされます。</p>
<p>これら2つの部品を使うことで、PureScriptで書かれた関数のように、PureScriptから<code>encodeURIComponent</code>関数を使うことができます。
例えばPSCiで上記の計算を再現できます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.URI
&gt; _encodeURIComponent "Hello World"
"Hello%20World"
</code></pre>
<p>外部モジュールには独自の関数も定義できます。
以下は<code>Number</code>を平方する独自のJavaScript関数を作って呼び出す方法の一例です。</p>
<p><code>test/Examples.js</code>:</p>
<pre><code class="language-js">"use strict";

export const square = function (n) {
  return n * n;
};
</code></pre>
<p><code>test/Examples.purs</code>:</p>
<pre><code class="language-hs">module Test.Examples where

foreign import square :: Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; square 5.0
25.0
</code></pre>
<h2 id="多変数関数"><a class="header" href="#多変数関数">多変数関数</a></h2>
<p>第2章の<code>diagonal</code>関数を外部モジュールで書き直してみましょう。
この関数は直角三角形の対角線を計算します。</p>
<pre><code class="language-hs">foreign import diagonal :: Number -&gt; Number -&gt; Number
</code></pre>
<p>PureScriptの関数は<em>カリー化</em>されていることを思い出してください。
<code>diagonal</code>は<code>Number</code>を取って<em>関数</em>を返す関数です。
そして返された関数は<code>Number</code>を取って<code>Number</code>を返します。</p>
<pre><code class="language-js">export const diagonal = function (w) {
  return function (h) {
    return Math.sqrt(w * w + h * h);
  };
};
</code></pre>
<p>もしくはES6の矢印構文ではこうです（後述するES6についての補足を参照してください）。</p>
<pre><code class="language-js">export const diagonalArrow = w =&gt; h =&gt;
  Math.sqrt(w * w + h * h);
</code></pre>
<pre><code class="language-hs">foreign import diagonalArrow :: Number -&gt; Number -&gt; Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; diagonal 3.0 4.0
5.0
&gt; diagonalArrow 3.0 4.0
5.0
</code></pre>
<h2 id="カリー化されていない関数"><a class="header" href="#カリー化されていない関数">カリー化されていない関数</a></h2>
<p>JavaScriptでカリー化された関数を書くことは、ただでさえJavaScriptらしいものではない上に、常に可能というわけでもありません。
よくある多変数なJavaScriptの関数は <em>カリー化されていない</em> 形式を取るでしょう。</p>
<pre><code class="language-js">export const diagonalUncurried = function (w, h) {
  return Math.sqrt(w * w + h * h);
};
</code></pre>
<p>モジュール<code>Data.Function.Uncurried</code>は<em>梱包</em>型とカリー化されていない関数を取り扱う関数をエクスポートします。</p>
<pre><code class="language-hs">foreign import diagonalUncurried :: Fn2 Number Number Number
</code></pre>
<p>型構築子<code>Fn2</code>を調べると以下です。</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.Function.Uncurried 
&gt; :kind Fn2
Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p><code>Fn2</code>は3つの型引数を取ります。
<code>Fn2 a b c</code>は、型<code>a</code>と<code>b</code>の2つの引数、返り値の型<code>c</code>を持つカリー化されていない関数の型を表現しています。
これを使って外部モジュールから<code>diagonalUncurried</code>をインポートしました。</p>
<p>そうして<code>runFn2</code>を使って呼び出せます。
これはカリー化されていない関数と引数を取るものです。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Function.Uncurried
&gt; runFn2 diagonalUncurried 3.0 4.0
5.0
</code></pre>
<p><code>functions</code>パッケージでは0引数から10引数までの関数について同様の型構築子が定義されています。</p>
<h2 id="カリー化されていない関数についての補足"><a class="header" href="#カリー化されていない関数についての補足">カリー化されていない関数についての補足</a></h2>
<p>PureScriptのカリー化された関数には勿論利点があります。
部分的に関数を適用でき、関数型に型クラスインスタンスを与えられるのです。
しかし効率上の代償も付いてきます。
効率性が決定的に重要なコードでは時々、多変数を受け付けるカリー化されていないJavaScript関数を定義する必要があります。</p>
<p>PureScriptでカリー化されていない関数を作ることもできます。
2引数の関数については<code>mkFn2</code>関数が使えます。</p>
<pre><code class="language-haskell">uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>前と同様に<code>runFn2</code>関数を使うと、カリー化されていない2引数の関数を適用できます。</p>
<pre><code class="language-haskell">uncurriedSum :: Int
uncurriedSum = runFn2 uncurriedAdd 3 10
</code></pre>
<p>ここで重要なのは、引数が全て適用されるなら、コンパイラは <code>mkFn2</code>関数や <code>runFn2</code>関数を<em>インライン化</em>するということです。
そのため、生成されるコードはとても簡潔になります。</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
  return m + n | 0;
};

var uncurriedSum = uncurriedAdd(3, 10);
</code></pre>
<p>対照的に、こちらがこれまでのカリー化された関数です。</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n

curriedSum :: Int
curriedSum = curriedAdd 3 10
</code></pre>
<p>そして生成結果のコードが以下です。
入れ子の関数のため比較的簡潔ではありません。</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
  return function (m) {
    return m + n | 0;
  };
};

var curriedSum = curriedAdd(3)(10);
</code></pre>
<h2 id="現代的なjavascriptの構文についての補足"><a class="header" href="#現代的なjavascriptの構文についての補足">現代的なJavaScriptの構文についての補足</a></h2>
<p>前に見た矢印関数構文はES6の機能であり、そのため幾つかの古いブラウザ（名指しすればIE11）と互換性がありません。
執筆時点でwebブラウザをまだ更新していない<a href="https://caniuse.com/#feat=arrow-functions">6%の利用者が矢印関数を使うことができないと推計</a>されています。</p>
<p>ほとんどの利用者にとって互換性があるようにするため、PureScriptコンパイラによって生成されるJavaScriptコードは矢印関数を使っていません。
また、同じ理由で<strong>公開するライブラリでも矢印関数を避ける</strong>ことが推奨されます。</p>
<p>それでも自分のFFIコードで矢印関数を使うこともできますが、デプロイの作業工程でES5に互換性のある関数へ変換するために<a href="https://github.com/babel/babel#intro">Babel</a>などのツールを含めると良いでしょう。</p>
<p>ES6の矢印関数がより読みやすく感じたら<a href="https://github.com/lebab/lebab">Lebab</a>のようなツールを使ってコンパイラの<code>output</code>ディレクトリにJavaScriptのコードを変換できます。</p>
<pre><code class="language-sh">npm i -g lebab
lebab --replace output/ --transform arrow,arrow-return
</code></pre>
<p>この操作により上の<code>curriedAdd</code>関数は以下に変換されます。</p>
<pre><code class="language-js">var curriedAdd = n =&gt; m =&gt;
  m + n | 0;
</code></pre>
<p>本書の残りの例では入れ子の関数の代わりに矢印関数を使います。</p>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>（普通）<code>Test.MySolutions</code>モジュールの中に箱の体積を求めるJavaScriptの関数<code>volumeFn</code>を書いてください。
<code>Data.Function.Uncurried</code>の梱包<code>Fn</code>を使ってください。</li>
<li>（普通）<code>volumeFn</code>を矢印関数を使って書き直し、<code>volumeArrow</code>としてください。</li>
</ol>
<h2 id="単純な型を渡す"><a class="header" href="#単純な型を渡す">単純な型を渡す</a></h2>
<p>以下のデータ型はPureScriptとJavaScriptの間でそのまま渡し合うことができます。</p>
<div class="table-wrapper"><table><thead><tr><th>PureScript</th><th>JavaScript</th></tr></thead><tbody>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>String</td><td>String</td></tr>
<tr><td>Int, Number</td><td>Number</td></tr>
<tr><td>Array</td><td>Array</td></tr>
<tr><td>Record</td><td>Object</td></tr>
</tbody></table>
</div>
<p><code>String</code>と<code>Number</code>という原始型の例は既に見てきました。
ここから<code>Array</code>や<code>Record</code>（JavaScriptでは<code>Object</code>）といった構造的な型を眺めていきます。</p>
<p><code>Array</code>を渡すところを実演するために、以下に<code>Int</code>の<code>Array</code>を取って別の配列として累計の和を返すJavaScriptの関数の呼び出し方を示します。
前にありましたが、JavaScriptは<code>Int</code>のための分離した型を持たないため、PureScriptでの<code>Int</code>と<code>Number</code>は両方共JavaScriptでの<code>Number</code>に翻訳されます。</p>
<pre><code class="language-hs">foreign import cumulativeSums :: Array Int -&gt; Array Int
</code></pre>
<pre><code class="language-js">export const cumulativeSums = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  return sums;
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; cumulativeSums [1, 2, 3]
[1,3,6]
</code></pre>
<p><code>Record</code>を渡すところを実演するために、以下に2つの<code>Complex</code>な数をレコードとして取り、和を別のレコードとして返すJavaScriptの呼び出し方を示します。
PureScriptでの<code>Record</code>がJavaScriptでは<code>Object</code>として表現されることに注意してください。</p>
<pre><code class="language-hs">type Complex = {
  real :: Number,
  imag :: Number
}

foreign import addComplex :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<pre><code class="language-js">export const addComplex = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    imag: a.imag + b.imag
  }
};
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; addComplex { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
{ imag: 6.0, real: 4.0 }
</code></pre>
<p>なお、上の手法にはJavaScriptが期待通りの型を返すことを信用する必要があります。
PureScriptはJavaScriptのコードに型検査を適用できないからです。
この型安全性の配慮について後のJSONの節でより詳しく解説していきます。
型の不整合から身を守る手法についても押さえます。</p>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<ol>
<li>（普通）<code>Complex</code>な数の配列を取って別の複素数の配列として累計の和を返すJavaScriptの関数<code>cumulativeSumsComplex</code>（と対応するPureScriptの外部インポート）を書いてください。</li>
</ol>
<h2 id="単純な型を越えて"><a class="header" href="#単純な型を越えて">単純な型を越えて</a></h2>
<p><code>String</code>、<code>Number</code>、<code>Array</code>、そして<code>Record</code>といった、JavaScript固有の表現を持つ型をFFI越しに送ったり受け取ったりする方法を数例見てきました。
ここから<code>Maybe</code>のようなPureScriptで使える幾つかの他の型の使い方を押さえていきます。</p>
<p>外部宣言を使用して、配列についての <code>head</code>関数を改めて作成したいとしましょう。
JavaScriptでは次のような関数を書くことになるでしょう。</p>
<pre><code class="language-javascript">export const head = arr =&gt;
  arr[0];
</code></pre>
<p>この関数をどう型付けましょうか。
型 <code>forall a. Array a -&gt; a</code>を与えようとしても、空の配列に対してこの関数は <code>undefined</code>を返します。
したがって型<code>forall a. Array a -&gt; a</code>は正しくこの実装を表現していないのです。</p>
<p>代わりにこの特殊な場合を扱うために<code>Maybe</code>値を返したいところです。</p>
<pre><code class="language-hs">foreign import maybeHead :: forall a. Array a -&gt; Maybe a
</code></pre>
<p>しかしどうやって<code>Maybe</code>を返しましょうか。
つい以下のように書きたくなります。</p>
<pre><code class="language-js">// こうしないでください
import Data_Maybe from '../Data.Maybe'

export const maybeHead = arr =&gt; {
  if (arr.length) {
    return Data_Maybe.Just.create(arr[0]);
  } else {
    return Data_Maybe.Nothing.value;
  }
}
</code></pre>
<p>外部モジュールで直接<code>Data.Maybe</code>モジュールをインポートして使うことはお勧めしません。というのもコードがコード生成器の変化に対して脆くなるからです。<code>create</code>や<code>value</code>は公開のAPIではありません。加えて、このようにすると、不要なコードを消去する<code>purs bundle</code>を使う際に問題を引き起こす可能性があります。</p>
<p>推奨されるやり方はFFIで定義された関数に余剰の引数を加えて必要な関数を受け付けることです。</p>
<pre><code class="language-js">export const maybeHeadImpl = just =&gt; nothing =&gt; arr =&gt; {
  if (arr.length) {
    return just(arr[0]);
  } else {
    return nothing;
  }
};
</code></pre>
<pre><code class="language-hs">foreign import maybeHeadImpl :: forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a

maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead arr = maybeHeadImpl Just Nothing arr
</code></pre>
<p>ただし、次のように書きますが、</p>
<pre><code class="language-hs">forall a. (forall x. x -&gt; Maybe x) -&gt; (forall x. Maybe x) -&gt; Array a -&gt; Maybe a
</code></pre>
<p>以下ではないことに注意です。</p>
<pre><code class="language-hs">forall a. (a -&gt; Maybe a) -&gt; Maybe a -&gt; Array a -&gt; Maybe a
</code></pre>
<p>どちらの形式でも動きますが、後者は<code>Just</code>と<code>Nothing</code>の場所での招かれざる入力に対してより脆弱です。</p>
<p>例えば、比較的脆い方では、以下のように呼び出せるでしょう。</p>
<pre><code class="language-hs">maybeHeadImpl (\_ -&gt; Just 1000) (Just 1000) [1,2,3]
</code></pre>
<p>これは如何なる配列の入力に対しても<code>Just 1000</code>を返します。</p>
<p>この脆弱性では、<code>a</code>が<code>Int</code>のときに（これは入力の配列に基づきます）<code>(\_ -&gt; Just 1000)</code>と<code>Just 1000</code>がシグネチャ<code>(a -&gt; Maybe a)</code>と<code>Maybe a</code>にそれぞれ照合するために許容されてしまっています。</p>
<p>より安全な型シグネチャでは、入力の配列に基づいて<code>a</code>が<code>Int</code>に決定されたとしても、<code>forall x</code>に絡むシグネチャに合致する妥当な関数を提供する必要があります。<code>(forall x. Maybe x)</code>の <em>唯一</em> の選択肢は<code>Nothing</code>ですが、それは<code>Just</code>値が<code>x</code>の型を前提にしてしまうと、もはや全ての<code>x</code>については妥当でなくなってしまうからです。<code>(forall x. x -&gt; Maybe x)</code>の唯一の選択肢は<code>Just</code>（望まれている引数）と<code>(\_ -&gt; Nothing)</code>であり、後者は唯一残っている脆弱性になるのです。</p>
<h2 id="外部型の定義"><a class="header" href="#外部型の定義">外部型の定義</a></h2>
<p><code>Maybe a</code>を返す代わりに<code>arr[0]</code>を返したいのだとしましょう。
型<code>a</code>ないし<code>undefined</code>値（ただし<code>null</code>ではありません）の何れかの値を表現する型がほしいです。
この型を<code>Undefined a</code>と呼びましょう。</p>
<p><em>外部インポート宣言</em> を使うと、<em>外部型</em> (foreign type) を定義できます。構文は外部関数を定義するのと似ています。</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>このキーワード<code>data</code>は<em>型</em>を定義していることを表しています。
値ではありせん。
型シグネチャの代わりに、新しい型の<em>種</em>を与えます。
この場合は<code>Undefined</code>の種が <code>Type -&gt; Type</code>であると宣言しています。
言い換えれば<code>Undefined</code>は型構築子です。</p>
<p>これで元の<code>head</code>の定義を再利用できます。</p>
<pre><code class="language-javascript">export const undefinedHead = arr =&gt;
  arr[0];
</code></pre>
<p>PureScriptモジュールには以下を追加します。</p>
<pre><code class="language-haskell">foreign import undefinedHead :: forall a. Array a -&gt; Undefined a
</code></pre>
<p><code>undefinedHead</code>関数の本体は<code>undefined</code>かもしれない<code>arr[0]</code>を返します。
そしてこの型シグネチャはその事実を正しく反映しています。</p>
<p>この関数はその型の適切な実行時表現を持っていますが、型<code>Undefined a</code>の値を使用する方法がないので、全く役に立ちません。
いや、言い過ぎました。
別のFFIでこの型を使えますからね。</p>
<p>値が未定義かどうかを教えてくれる関数を書くことができます。</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>外部JavaScriptモジュールで次のように定義できます。</p>
<pre><code class="language-javascript">export const isUndefined = value =&gt;
  value === undefined;
</code></pre>
<p>これでPureScriptで <code>isUndefined</code>と <code>undefinedHead</code>を一緒に使用すると、便利な関数を定義できます。</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; undefinedHead
</code></pre>
<p>このように、定義したこの外部関数はとても単純です。
つまりPureScriptの型検査器を使うことによる利益が最大限得られるのです。
一般に、外部関数は可能な限り小さく保ち、できるだけアプリケーションの処理はPureScriptコードへ移動しておくことをお勧めします。</p>
<h2 id="例外"><a class="header" href="#例外">例外</a></h2>
<p>他の選択肢としては、空の配列の場合に例外を投げる方法があります。
厳密に言えば、純粋な関数は例外を投げるべきではありませんが、そうする柔軟さはあります。
安全性に欠けていることを関数名で示します。</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>JavaScriptモジュールでは、<code>unsafeHead</code>を以下のように定義できます。</p>
<pre><code class="language-javascript">export const unsafeHead = arr =&gt; {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>
<p>（普通）二次多項式 \( a x ^ 2 + b x + c = 0 \) を表現するレコードが与えられているとします。</p>
<pre><code class="language-hs">type Quadratic = {
  a :: Number,
  b :: Number,
  c :: Number
}
</code></pre>
<p>二次多項式を使ってこの多項式の根を求めるJavaScriptの関数<code>quadraticRootsImpl</code>とその梱包の<code>quadraticRoots :: Quadratic -&gt; Pair Complex</code>を書いてください。
2つの根を<code>Complex</code>の数の<code>Pair</code>として返してください。
<em>手掛かり</em>：梱包<code>quadraticRoots</code>を使って<code>Pair</code>の構築子を<code>quadraticRootsImpl</code>に渡してください。</p>
</li>
<li>
<p>（普通）関数<code>toMaybe :: forall a. Undefined a -&gt; Maybe a</code>を書いてください。
この関数は<code>undefined</code>を<code>Nothing</code>に、<code>a</code>の値を<code>Just a</code>に変換します。</p>
</li>
<li>
<p>（難しい）<code>toMaybe</code>が準備できたら、<code>maybeHead</code>を以下に書き換えられます。</p>
<pre><code class="language-hs">maybeHead :: forall a. Array a -&gt; Maybe a
maybeHead = toMaybe &lt;&lt;&lt; undefinedHead
</code></pre>
<p>これは前の実装よりも良いやり方なのでしょうか。
<em>補足</em>：この演習のための単体試験はありません。</p>
</li>
</ol>
<h2 id="型クラスメンバー関数を使う"><a class="header" href="#型クラスメンバー関数を使う">型クラスメンバー関数を使う</a></h2>
<p>つい先程までFFI越しに<code>Maybe</code>の構築子を渡す手引きをしましたが、今回はJavaScriptを呼び出すPureScriptを書く別の場合です。
JavaScriptの呼び出しでも続けざまにPureScriptの関数を呼び出します。
ここでは型クラスのメンバー関数をFFI越しに渡す方法を探ります。</p>
<p>型<code>x</code>に合う適切な<code>show</code>のインスタンスを期待する外部JavaScript関数を書くことから始めます。</p>
<pre><code class="language-js">export const boldImpl = show =&gt; x =&gt;
  show(x).toUpperCase() + "!!!";
</code></pre>
<p>それから対応するシグネチャを書きます。</p>
<pre><code class="language-hs">foreign import boldImpl :: forall a. (a -&gt; String) -&gt; a -&gt; String
</code></pre>
<p>そして<code>show</code>の正しいインスタンスを渡す梱包関数も書きます。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold x = boldImpl show x
</code></pre>
<p>代えてポイントフリー形式だとこうです。</p>
<pre><code class="language-hs">bold :: forall a. Show a =&gt; a -&gt; String
bold = boldImpl show
</code></pre>
<p>そうして梱包を呼び出すことができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; bold (Tuple 1 "Hat")
"(TUPLE 1 \"HAT\")!!!"
</code></pre>
<p>以下は複数の関数を渡す別の実演例です。
これらの関数には複数引数の関数 (<code>eq</code>) が含まれます。</p>
<pre><code class="language-js">export const showEqualityImpl = eq =&gt; show =&gt; a =&gt; b =&gt; {
  if (eq(a)(b)) {
    return "Equivalent";
  } else {
    return show(a) + " is not equal to " + show(b);
  }
}
</code></pre>
<pre><code class="language-hs">foreign import showEqualityImpl :: forall a. (a -&gt; a -&gt; Boolean) -&gt; (a -&gt; String) -&gt; a -&gt; a -&gt; String

showEquality :: forall a. Eq a =&gt; Show a =&gt; a -&gt; a -&gt; String
showEquality = showEqualityImpl eq show
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Maybe
&gt; showEquality Nothing (Just 5)
"Nothing is not equal to (Just 5)"
</code></pre>
<h2 id="作用のある関数"><a class="header" href="#作用のある関数">作用のある関数</a></h2>
<p><code>bold</code>関数を拡張してコンソールにログ出力するようにしましょう。
ログ出力は<code>Effect</code>であり、<code>Effect</code>はJavaScriptにおいて無引数関数として表現されます。
つまり<code>()</code>と矢印記法だとこうです。</p>
<pre><code class="language-js">export const yellImpl = show =&gt; x =&gt; () =&gt;
  console.log(show(x).toUpperCase() + "!!!");
</code></pre>
<p>新しくなった外部インポートは、返る型が<code>String</code>から<code>Effect Unit</code>に変わった点以外は以前と同じです。</p>
<pre><code class="language-hs">foreign import yellImpl :: forall a. (a -&gt; String) -&gt; a -&gt; Effect Unit

yell :: forall a. Show a =&gt; a -&gt; Effect Unit
yell = yellImpl show
</code></pre>
<p>REPLで試すと文字列が（引用符で囲まれず）直接コンソールに印字され<code>unit</code>値が返ることがわかります。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Tuple
&gt; yell (Tuple 1 "Hat")
(TUPLE 1 "HAT")!!!
unit
</code></pre>
<p><code>Effect.Uncurried</code>に梱包<code>EffectFn</code>というものもあります。
これらは既に見た<code>Data.Function.Uncurried</code>の梱包<code>Fn</code>に似ています。
これらの梱包があればカリー化されていない作用のある関数をPureScriptで呼び出すことができます。</p>
<p>一般的にこれらを使うのは、こうしたAPIをカリー化された関数に包むのではなく、既存のJavaScriptライブラリのAPIを直接呼び出したいときぐらいです。
したがってカリー化していない<code>yell</code>の例を見せてもあまり意味がありません。
というのもJavaScriptがPureScriptの型クラスのメンバーに依っているからで、更にそれは既存のJavaScriptのエコシステムにそのメンバーが見付からないためです。</p>
<p>翻って以前の<code>diagonal</code>の例を変更し、結果を返すことに加えてログ出力を含めるとこうなります。</p>
<pre><code class="language-js">export const diagonalLog = function(w, h) {
  let result = Math.sqrt(w * w + h * h);
  console.log("Diagonal is " + result);
  return result;
};
</code></pre>
<pre><code class="language-hs">foreign import diagonalLog :: EffectFn2 Number Number Number
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Effect.Uncurried
&gt; runEffectFn2 diagonalLog 3.0 4.0
Diagonal is 5
5.0
</code></pre>
<h2 id="非同期関数"><a class="header" href="#非同期関数">非同期関数</a></h2>
<p><code>aff-promise</code>ライブラリの助けを借りるとJavaScriptのプロミスは直接PureScriptの非同期作用に翻訳されます。
詳細についてはライブラリの<a href="https://pursuit.purescript.org/packages/purescript-aff-promise">ドキュメント</a>をあたってください。
ここでは幾つかの例に触れるだけとします。</p>
<p>JavaScriptの<code>wait</code>プロミス（または非同期関数）をPureScriptのプロジェクトで使いたいとします。
<code>ms</code>ミリ秒分だけ送らせて実行させるのに使うことができます。</p>
<pre><code class="language-js">const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));
</code></pre>
<p>単に<code>Effect</code>（無引数関数）に包んで公開するだけで大丈夫です。</p>
<pre><code class="language-js">export const sleepImpl = ms =&gt; () =&gt;
  wait(ms);
</code></pre>
<p>そして以下のようにインポートします。</p>
<pre><code class="language-hs">foreign import sleepImpl :: Int -&gt; Effect (Promise Unit)

sleep :: Int -&gt; Aff Unit
sleep = sleepImpl &gt;&gt;&gt; toAffE
</code></pre>
<p>そうして<code>Aff</code>ブロック中でこの<code>Promise</code>を以下のように走らせることができます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Prelude
&gt; import Test.Examples
&gt; import Effect.Class.Console
&gt; import Effect.Aff
&gt; :pa
… launchAff_ do
…   log "waiting"
…   sleep 300
…   log "done waiting"
…
waiting
unit
done waiting
</code></pre>
<p>REPLでの非同期ログ出力はブロック全体が実行を終了するまで印字を待機する点に注意しましょう。
このコードを<code>spago test</code>で走らせた場合、印字の<em>合間に</em>僅かな遅延があり、より予測に近い挙動をします。</p>
<p>他にプロミスから値を返す例を見てみましょう。
この関数は<code>async</code>と<code>await</code>を使って書かれていますが、これはプロミスの糖衣構文に過ぎません。</p>
<pre><code class="language-js">async function diagonalWait(delay, w, h) {
  await wait(delay);
  return Math.sqrt(w * w + h * h);
}

export const diagonalAsyncImpl = delay =&gt; w =&gt; h =&gt; () =&gt;
  diagonalWait(delay, w, h);
</code></pre>
<p><code>Number</code>を返すため、この型を<code>Promise</code>と<code>Aff</code>の梱包の中で表現します。</p>
<pre><code class="language-hs">foreign import diagonalAsyncImpl :: Int -&gt; Number -&gt; Number -&gt; Effect (Promise Number)

diagonalAsync :: Int -&gt; Number -&gt; Number -&gt; Aff Number
diagonalAsync i x y = toAffE $ diagonalAsyncImpl i x y
</code></pre>
<pre><code class="language-text">$ spago repl

import Prelude
import Test.Examples
import Effect.Class.Console
import Effect.Aff
&gt; :pa
… launchAff_ do
…   res &lt;- diagonalAsync 300 3.0 4.0
…   logShow res
…
unit
5.0
</code></pre>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<p>上の節の演習はまだやるべきことの一覧にあります。
もし何か良い演習の考えがあればご提案ください。</p>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>アプリケーションでJSONを使うことには多くの理由があります。
例えばwebのAPIと疎通するよくある手段であるためです。
この節では他の用例についてもお話ししましょう。
構造的なデータをFFI越しに渡す場合に型安全性を向上させる手法から始めます。</p>
<p>少し前のFFI関数<code>cumulativeSums</code>と<code>addComplex</code>を再訪し、それぞれに1つバグを混入させてみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsBroken = arr =&gt; {
  let sum = 0
  let sums = []
  arr.forEach(x =&gt; {
    sum += x;
    sums.push(sum);
  });
  sums.push("Broken"); // Bug
  return sums;
};

export const addComplexBroken = a =&gt; b =&gt; {
  return {
    real: a.real + b.real,
    broken: a.imag + b.imag // Bug
  }
};
</code></pre>
<p>実際は返る型が正しくないのですが、元々の型シグネチャを使うことができ、依然としてコードはコンパイルされます。</p>
<pre><code class="language-hs">foreign import cumulativeSumsBroken :: Array Int -&gt; Array Int

foreign import addComplexBroken :: Complex -&gt; Complex -&gt; Complex
</code></pre>
<p>コードの実行さえ可能で、そうすると予期しない結果を生み出すか実行時エラーになります。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Foldable (sum)

&gt; sums = cumulativeSumsBroken [1, 2, 3]
&gt; sums
[1,3,6,Broken]
&gt; sum sums
0

&gt; complex = addComplexBroken { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
&gt; complex.real
4.0
&gt; complex.imag + 1.0
NaN
&gt; complex.imag
  var str = n.toString();
              ^
TypeError: Cannot read property 'toString' of undefined
</code></pre>
<p>例えば結果の<code>sums</code>はもはや正しい<code>Array Int</code>ではありませんが、それは<code>String</code>が配列に含まれているからです。
そして更なる操作は即時のエラーではなく予期しない挙動を生み出します。
というのもこれらの<code>sums</code>の<code>sum</code>は<code>10</code>ではなく<code>0</code>だからです。
これでは捜索の難しいバグになりかねませんね。</p>
<p>同様に<code>addComplexBroken</code>を呼び出すときは1つもエラーが出ません。
しかし、<code>Complex</code>の結果の<code>imag</code>フィールドにアクセスすると予期しない挙動（<code>7.0</code>ではなく<code>Nan</code>を返すため）やはっきりしない実行時エラーを生じることでしょう。</p>
<p>PureScriptのコードにバグ一匹通さないようにするため、JavaScriptのコードでJSONを使いましょう。</p>
<p><code>argonaut</code>ライブラリにはこのために必要なJSONのデコードとエンコードの機能が備わっています。
このライブラリには素晴らしい<a href="https://github.com/purescript-contrib/purescript-argonaut#documentation">ドキュメント</a>があるので、本書では基本的な用法だけを押さえます。</p>
<p>返る型を<code>Json</code>として定義するようにして、代わりとなる外部インポートを作るとこうなります。</p>
<pre><code class="language-hs">foreign import cumulativeSumsJson :: Array Int -&gt; Json
foreign import addComplexJson :: Complex -&gt; Complex -&gt; Json
</code></pre>
<p>単純に既存の壊れた関数を指している点に注意します。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSumsBroken
export const addComplexJson = addComplexBroken
</code></pre>
<p>そして返された<code>Json</code>の値をデコードする梱包を書きます。</p>
<pre><code class="language-hs">cumulativeSumsDecoded :: Array Int -&gt; Either JsonDecodeError (Array Int)
cumulativeSumsDecoded arr = decodeJson $ cumulativeSumsJson arr

addComplexDecoded :: Complex -&gt; Complex -&gt; Either JsonDecodeError Complex
addComplexDecoded a b = decodeJson $ addComplexJson a b
</code></pre>
<p>そうすると返る型へのデコードが成功しなかったどんな値も<code>Left</code>の<code>String</code>なエラーとして表れます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Left "Couldn't decode Array (Failed at index 3): Value is not a Number")

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Left "JSON was missing expected field: imag")
</code></pre>
<p>正常に動作するバージョンで呼び出すと<code>Right</code>の値が返ります。</p>
<p>次のREPLブロックを走らせる前に、正常に動作するバージョンを指すように、<code>test/Examples.js</code>へ以下の変更を加えて、手元で試してみましょう。</p>
<pre><code class="language-js">export const cumulativeSumsJson = cumulativeSums
export const addComplexJson = addComplex
</code></pre>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples

&gt; cumulativeSumsDecoded [1, 2, 3]
(Right [1,3,6])

&gt; addComplexDecoded { real: 1.0, imag: 2.0 } { real: 3.0, imag: 4.0 }
(Right { imag: 6.0, real: 4.0 })
</code></pre>
<p>JSONを使うのは、<code>Map</code>や<code>Set</code>のようなその他の構造的な型をFFI越しに渡す、最も簡単な方法でもあります。
JSONは真偽値、数値、文字列、配列、そして他のJSONの値からなるオブジェクトのみから構成されるため、JSONでは直接<code>Map</code>や<code>Set</code>を書けません。
しかしこれらの構造を配列としては表現でき（キーとバリューもまたJSONで表現されているとします）、それから<code>Map</code>や<code>Set</code>に復元できるのです。</p>
<p>以下は<code>String</code>のキーと<code>Int</code>のバリューからなる<code>Map</code>を変更する外部関数シグネチャと、それに伴うJSONのエンコードとデコードを扱う梱包関数の例です。</p>
<pre><code class="language-hs">foreign import mapSetFooJson :: Json -&gt; Json

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo json = decodeJson $ mapSetFooJson $ encodeJson json
</code></pre>
<p>関数合成の絶好の用例になっていますね。
以下の代案は両方とも上のものと等価です。</p>
<pre><code class="language-hs">mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = decodeJson &lt;&lt;&lt; mapSetFooJson &lt;&lt;&lt; encodeJson

mapSetFoo :: Map String Int -&gt; Either JsonDecodeError (Map String Int)
mapSetFoo = encodeJson &gt;&gt;&gt; mapSetFooJson &gt;&gt;&gt; decodeJson
</code></pre>
<p>以下はJavaScriptでの実装です。
なお、<code>Array.from</code>の工程は、JavaScriptの<code>Map</code>をJSONに親和性のある形式に変換し、デコードでPureScriptの<code>Map</code>に変換し直すために必須です。</p>
<pre><code class="language-js">export const mapSetFooJson = j =&gt; {
  let m = new Map(j);
  m.set("Foo", 42);
  return Array.from(m);
};
</code></pre>
<p>これで<code>Map</code>をFFI越しに送ったり受け取ったりできます。</p>
<pre><code class="language-text">$ spago repl

&gt; import Test.Examples
&gt; import Data.Map
&gt; import Data.Tuple

&gt; myMap = fromFoldable [ Tuple "hat" 1, Tuple "cat" 2 ]

&gt; :type myMap
Map String Int

&gt; myMap
(fromFoldable [(Tuple "cat" 2),(Tuple "hat" 1)])

&gt; mapSetFoo myMap
(Right (fromFoldable [(Tuple "Foo" 42),(Tuple "cat" 2),(Tuple "hat" 1)]))
</code></pre>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>
<p>（普通）<code>Map</code>中の全てのバリューの<code>Set</code>を返すJavaScriptの関数とPureScriptの梱包<code>valuesOfMap :: Map String Int -&gt; Either JsonDecodeError (Set Int)</code>を書いてください。</p>
</li>
<li>
<p>（簡単）より広い種類のマップに関して動作するよう、前のJavaScriptの関数の新しい梱包を書いてください。
シグネチャは<code>valuesOfMapGeneric :: forall k v. Map k v -&gt; Either JsonDecodeError (Set v)</code>です。
なお、<code>k</code>と<code>v</code>に幾つかの型クラス制約を加える必要があるでしょう。
コンパイラが導いてくれます。</p>
</li>
<li>
<p>（普通）少し前の<code>quadraticRoots</code>関数を書き換えて<code>quadraticRootSet</code>としてください。
この関数は<code>Complex</code>の根をJSONを介して（<code>Pair</code>の代わりに）<code>Set</code>として返します。</p>
</li>
<li>
<p>（難しい）少し前の<code>quadraticRoots</code>関数を書き換えて<code>quadraticRootsSafe</code>としてください。
この関数はJSONを使って<code>Complex</code>の根の<code>Pair</code>をFFI越しに渡します。
JavaScriptでは<code>Pair</code>構築子を使わないでください。
その代わり、デコーダーに互換性のある形式で対を返すだけにしてください。
<em>手掛かり</em>：<code>DecodeJson</code>インタンスを<code>Pair</code>用に書く必要があるでしょう。
独自のデコードインスタンスを書く上での説明については<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#writing-new-instances">argonautのドキュメント</a>をあたってください。
<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/blob/master/src/Data/Argonaut/Decode/Class.purs">decodeJsonTuple</a>インスタンスも参考になるかもしれません。
「孤立インスタンス」を作ることを避けるために、<code>Pair</code>に<code>newtype</code>の梱包が必要になる点に注意してください。</p>
</li>
<li>
<p>（普通）2次元配列を含むJSON文字列を構文解析してデコードする<code>parseAndDecodeArray2D :: String -&gt; Either String (Array (Array Int))</code>関数を書いてください。
例えば<code>"[[1, 2, 3], [4, 5], [6]]"</code>です。
<em>手掛かり</em>：デコードの前に<code>jsonParser</code>を使って<code>String</code>を<code>Json</code>に変換する必要があるでしょう。</p>
</li>
<li>
<p>（普通）以下のデータ型は値が葉にある二分木を表現します。</p>
<pre><code class="language-haskell">data Tree a
  = Leaf a
  | Branch (Tree a) (Tree a)
</code></pre>
<p>汎化された<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを<code>Tree</code>型用に導出してください。
このやり方についての説明は<a href="https://github.com/purescript-contrib/purescript-argonaut-codecs/tree/main/docs#generics">argonautのドキュメント</a>をあたってください。
なお、この演習の単体試験を有効にするには、汎化された<code>Show</code>及び<code>Eq</code>インスタンスも必要になります。
しかしJSONのインスタンスと格闘したあとでは、これらの実装は直感的に進むことでしょう。</p>
</li>
<li>
<p>（難しい）以下の<code>data</code>型は整数か文字列かによってJSONで異なって表現されます。</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>この挙動を実装する<code>IntOrString</code>データ型に、<code>EncodeJson</code>及び<code>DecodeJson</code>インスタンスを書いてください。
<em>手掛かり</em>：<code>Control.Alt</code>の<code>alt</code>演算子が役立つかもしれません。</p>
</li>
</ol>
<h2 id="住所録"><a class="header" href="#住所録">住所録</a></h2>
<p>この節では新しく獲得したFFIとJSONの知識を応用して、第8章の住所録の例を構築していきたいと思います。
以下の機能を加えていきます。</p>
<ul>
<li>保存ボタンをフォームの一番下に配置し、クリックしたときにフォームの状態をJSONに直列化してローカルストレージに保存します。</li>
<li>ページの再読み込み時にローカルストレージからJSON文書を自動的に取得します。
フォームのフィールドにはこの文書の内容を入れます。</li>
<li>フォームの状態を保存したり読み込んだりするのに問題があればポップアップの警告を出します。</li>
</ul>
<p><code>Effect.Storage</code>モジュールに以下のwebストレージAPIのためのFFIの梱包を作ることから始めていきます。</p>
<ul>
<li><code>setItem</code>はキーと値（両方とも文字列）を受け取り、指定されたキーでローカルストレージに値を格納する計算を返します。</li>
<li><code>getItem</code>はキーを取り、ローカルストレージから関連付けられたバリューの取得を試みます。
しかし<code>window.localStorage</code>の<code>getItem</code>メソッドは<code>null</code>を返しうるので、返る型は<code>String</code>ではなく<code>Json</code>です。</li>
</ul>
<pre><code class="language-haskell">foreign import setItem :: String -&gt; String -&gt; Effect Unit

foreign import getItem :: String -&gt; Effect Json
</code></pre>
<p>以下はこれらの関数に対応するJavaScriptの実装で、<code>Effect/Storage.js</code>にあります。</p>
<pre><code class="language-js">export const setItem = key =&gt; value =&gt; () =&gt;
  window.localStorage.setItem(key, value);

export const getItem = key =&gt; () =&gt;
  window.localStorage.getItem(key);
</code></pre>
<p>以下のように保存ボタンを作ります。</p>
<pre><code class="language-hs">saveButton :: R.JSX
saveButton =
  D.label
    { className: "form-group row col-form-label"
    , children:
        [ D.button
            { className: "btn-primary btn"
            , onClick: handler_ validateAndSave
            , children: [ D.text "Save" ]
            }
        ]
    }
</code></pre>
<p>そして<code>validateAndSave</code>関数中では、検証された<code>person</code>をJSON文字列とし、<code>setItem</code>を使って書き込みます。</p>
<pre><code class="language-hs">validateAndSave :: Effect Unit
validateAndSave = do
  log "Running validators"
  case validatePerson' person of
    Left errs -&gt; log $ "There are " &lt;&gt; show (length errs) &lt;&gt; " validation errors."
    Right validPerson -&gt; do
      setItem "person" $ stringify $ encodeJson validPerson
      log "Saved"
</code></pre>
<p>なお、この段階でコンパイルしようとすると以下のエラーに遭遇します。</p>
<pre><code class="language-text">  No type class instance was found for
    Data.Argonaut.Encode.Class.EncodeJson PhoneType
</code></pre>
<p>これはなぜかというと<code>Person</code>レコード中の<code>PhoneType</code>が<code>EncodeJson</code>インスタンスを必要としているからです。
また、ついでに汎用のエンコードインスタンスとデコードインスタンスを導出していきます。
この仕組みについての詳細情報はargonautのドキュメントにあります。</p>
<pre><code class="language-hs">import Data.Argonaut (class DecodeJson, class EncodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode.Generic (genericEncodeJson)
import Data.Generic.Rep (class Generic)

derive instance Generic PhoneType _

instance EncodeJson PhoneType where encodeJson = genericEncodeJson
instance DecodeJson PhoneType where decodeJson = genericDecodeJson
</code></pre>
<p>これで<code>person</code>をローカルストレージに保存できます。
しかしデータを取得できない限りあまり便利ではありません。
次はそれに取り掛かりましょう。</p>
<p>ローカルストレージから「person」文字列で取得することから始めましょう。</p>
<pre><code class="language-hs">item &lt;- getItem "person"
</code></pre>
<p>そうしてローカルストレージ由来の文字列から<code>Person</code>レコードへ変換する補助関数を作ります。
なお、このストレージ中の文字列は<code>null</code>かもしれないので、正常に<code>String</code>としてデコードされるまでは外部の<code>Json</code>として表現します。
道中には他にも多くの変換工程があり、それぞれで<code>Either</code>の値を返します。
そのためこれらをまとめて<code>do</code>ブロックの中に纏めるのは理に適っています。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- decodeJson item
  j          &lt;- jsonParser jsonString
  decodeJson j
</code></pre>
<p>そうしてこの結果が成功しているかどうか調べます。
もし失敗していればエラーをログ出力し、既定の<code>examplePerson</code>を使います。
そうでなければローカルストレージから取得した人物を使います。</p>
<pre><code class="language-hs">initialPerson &lt;- case processItem item of
  Left  err -&gt; do
    log $ "Error: " &lt;&gt; err &lt;&gt; ". Loading examplePerson"
    pure examplePerson
  Right p   -&gt; pure p
</code></pre>
<p>最後にこの<code>initialPerson</code>を<code>props</code>レコードを介してコンポーネントに渡します。</p>
<pre><code class="language-hs">-- reactコンポーネントからJSXノードを作成します。
app = element addressBookApp { initialPerson }
</code></pre>
<p>そして状態フックで使うために別の箇所で拾い上げます。</p>
<pre><code class="language-hs">mkAddressBookApp :: Effect (ReactComponent { initialPerson :: Person })
mkAddressBookApp =
  reactComponent "AddressBookApp" \props -&gt; R.do
    Tuple person setPerson &lt;- useState props.initialPerson
</code></pre>
<p>仕上げとして、各<code>Left</code>値の<code>String</code>に<code>lmap</code>を使って前置し、エラー文言の質を向上させます。</p>
<pre><code class="language-hs">processItem :: Json -&gt; Either String Person
processItem item = do
  jsonString &lt;- lmap ("No string in local storage: " &lt;&gt; _) $ decodeJson item
  j          &lt;- lmap ("Cannot parse JSON string: "   &lt;&gt; _) $ jsonParser jsonString
  lmap               ("Cannot decode Person: "       &lt;&gt; _) $ decodeJson j
</code></pre>
<p>最初のエラーのみがこのアプリの通常の操作内で起こります。
他のエラーはwebブラウザの開発ツールを開いてローカルストレージ中に保存された「person」文字列を編集し、そのページを参照することで引き起こせます。
どのようにJSON文字列を変更したかが、どのエラーを引き起こすかを決定します。
各エラーを引き起こせるかご確認ください。</p>
<p>これでローカルストレージについては押さえました。
次に<code>alert</code>動作を実装していきます。
この動作は<code>Effect.Console</code>モジュールの<code>log</code>動作に似ています。
唯一の相違点は<code>alert</code>動作が<code>window.alert</code>メソッドを使うことで、対して<code>log</code>動作は<code>console.log</code>メソッドを使っています。
そういうわけで<code>alert</code>は<code>window.alert</code>が定義された環境でのみ使うことができます。
webブラウザなどです。</p>
<pre><code class="language-hs">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<pre><code class="language-js">export const alert = msg =&gt; () =&gt;
  window.alert(msg);
</code></pre>
<p>この警告が次の何れかの場合に現れるようにしたいです。</p>
<ul>
<li>利用者が検証エラーを含むフォームを保存しようと試みている。</li>
<li>状態がローカルストレージから取得できない。</li>
</ul>
<p>以上は単に以下の行で<code>log</code>を<code>alert</code>に置き換えるだけで達成できます。</p>
<pre><code class="language-hs">Left errs -&gt; alert $ "There are " &lt;&gt; show (length errs) &lt;&gt; " validation errors."

alert $ "Error: " &lt;&gt; err &lt;&gt; ". Loading examplePerson"
</code></pre>
<h2 id="演習-5"><a class="header" href="#演習-5">演習</a></h2>
<ol>
<li>（普通）<code>localStorage</code>オブジェクトの <code>removeItem</code>メソッドの梱包を書き、
<code>Effect.Storage</code>モジュールに外部関数を追加してください</li>
<li>（普通）「リセット」ボタンを追加してください。
このボタンをクリックすると新しく作った<code>removeItem</code>関数を呼び出してローカルストレージから「人物」の項目を削除します。</li>
<li>（簡単）JavaScriptの <code>Window</code>オブジェクトの <code>confirm</code>メソッドの梱包を書き、
<code>Effect.Alert</code>モジュールにその外部関数を追加してください。</li>
<li>（普通）利用者が「リセット」ボタンをクリックしたときにこの<code>confirm</code>関数を呼び出し、本当に住所録を白紙にしたいか尋ねるようにしてください。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章では、PureScriptから外部のJavaScriptコードを扱う方法を学びました。
また、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。</p>
<ul>
<li>外部関数が正しい表現を持っていることを確かめる重要性を見てきました。</li>
<li>外部型や<code>Json</code>データ型を使用することによって、null値やJavaScriptの他の型のデータのような特殊な場合に対処する方法を学びました。</li>
<li>安全にJSONデータを直列化・直列化復元する方法を見ました。</li>
</ul>
<p>より多くの例については、GitHubの<code>purescript</code>組織、<code>purescript-contrib</code>組織、及び<code>purescript-node</code>組織が、FFIを使用するライブラリの例を多数提供しています。
残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾つか見ていきます。</p>
<h2 id="補遺"><a class="header" href="#補遺">補遺</a></h2>
<h3 id="javascriptからpurescriptを呼び出す"><a class="header" href="#javascriptからpurescriptを呼び出す">JavaScriptからPureScriptを呼び出す</a></h3>
<p>少なくとも単純な型を持つ関数については、JavaScriptからPureScript関数を呼び出すのはとても簡単です。</p>
<p>例として以下のような簡単なモジュールを見てみましょう。</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m – n) n
</code></pre>
<p>この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。
PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装する開発者は型検証器の恩恵を受けることができます。
そういうわけで関数を定義するのにPureScriptを使いたくなるかもしれない良い例となっていますが、JavaScriptからそれを呼び出すためには条件があります。</p>
<p>この関数をJavaScriptから呼び出す方法を理解する上で重要なのは、PureScriptの関数は常に引数が1つのJavaScript関数へと変換され、引数へは次のように1つずつ適用していかなければならないということです。</p>
<pre><code class="language-javascript">import Test from 'Test.js';
Test.gcd(15)(20);
</code></pre>
<p>ここでは<code>spago build</code>でコンパイルされていることを前提としています。
SpagoはPureScriptモジュールをESモジュールにコンパイルするものです。
そのため、<code>import</code>を使って<code>Test</code>モジュールをインポートした後、<code>Test</code>オブジェクトの<code>gcd</code>関数を参照できました。</p>
<p><code>spago bundle-app</code>や<code>spago bundle-module</code>コマンドを使って生成されたJavaScriptを単一のファイルにまとめることもできます。
詳細な情報については<a href="https://github.com/purescript/spago#bundle-a-project-into-a-single-js-file">ドキュメント</a>をあたってください。</p>
<h3 id="名前の生成を理解する"><a class="header" href="#名前の生成を理解する">名前の生成を理解する</a></h3>
<p>PureScriptはコード生成時にできるだけ名前を保持することを目指します。
とりわけ、PureScriptやJavaScriptのキーワードでなければほとんどの識別子が保存されることが期待できます。
少なくとも最上位で宣言される名前についてはそうです。</p>
<p>識別子としてJavaScriptのキーワードを使う場合は、名前は2重のドル記号でエスケープされます。
例えば次のPureScriptコードを考えてみます。</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープされます。
例えばこのPureScriptコードを考えます。</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>これは以下のJavaScriptを生成します。</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図している場合、識別子は英数字のみを使用し、JavaScriptのキーワードを避けることをお勧めします。
ユーザ定義演算子がPureScriptコードでの使用のために提供される場合、JavaScriptから使うための英数字の名前を持つ代替関数を提供しておくことをお勧めします。</p>
<h3 id="実行時のデータ表現"><a class="header" href="#実行時のデータ表現">実行時のデータ表現</a></h3>
<p>型はプログラムがある意味で「正しい」ことをコンパイル時に論証できるようにします。
つまり、その点については壊れることがありません。
しかし、これは何を意味するのでしょうか。
PureScriptでは、式の型は実行時の表現と互換性があることを意味します。</p>
<p>そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行時のデータ表現について理解することが重要です。
これはつまり、与えられた任意のPureScriptの式について、その値が実行時にどのように評価されるかという挙動を理解できるべきだということです。</p>
<p>幸いにもPureScriptの式はとりわけ実行時に単純な表現を持っています。
型を考慮すれば式の実行時のデータ表現を把握することが常に可能です。</p>
<p>単純な型については、対応関係はほとんど自明です。
例えば式が型 <code>Boolean</code>を持っていれば、実行時のその値 <code>v</code>は <code>typeof v === 'boolean'</code>を満たします。
つまり、型 <code>Boolean</code>の式は <code>true</code>もしくは <code>false</code>のどちらか一方の（JavaScriptの）値へと評価されます。
特に<code>null</code>や <code>undefined</code>に評価される型<code>Boolean</code>なPureScriptの式はありません。</p>
<p><code>Int</code>や<code>Number</code>や<code>String</code>の型の式についても似た法則が成り立ちます。
<code>Int</code>や<code>Number</code>型の式はnullでないJavaScriptの数へと評価されますし、<code>String</code>型の式はnullでないJavaScriptの文字列へと評価されます。
<code>typeof</code>を使った場合に型<code>Number</code>の値と見分けがつかなくなるにせよ、型<code>Int</code>の式は実行時に整数に評価されます。</p>
<p><code>Unit</code>についてはどうでしょうか。
<code>Unit</code>には現住 (<code>unit</code>) が1つのみで値が観測できないため、実のところ実行時に何で表現されるかは重要ではありません。
古いコードは<code>{}</code>を使って表現する傾向がありました。
しかし比較的新しいコードでは<code>undefined</code>を使う傾向にあります。
なので、<code>Unit</code>を表現するのに使うものは何であれ差し支えありませんが、<code>undefined</code>を使うことが推奨されます（関数から何も返さないときも<code>undefined</code>を返します）。</p>
<p>もっと複雑な型についてはどうでしょうか。</p>
<p>既に見てきたように、PureScriptの関数は引数が1つのJavaScriptの関数に対応しています。
厳密に言えばこうなります。
ある型<code>a</code>と<code>b</code>について、式<code>f</code>の型が<code>a -&gt; b</code>で、式<code>x</code>が型<code>a</code>についての適切な実行時表現の値へと評価されるとします。
このとき<code>f</code>はJavaScriptの関数へと評価されますが、この関数は<code>x</code>を評価した結果に<code>f</code>を適用すると型<code>b</code>の適切な実行時表現を持ちます。
単純な例としては、<code>String -&gt; String</code>型の式は、nullでないJavaScript文字列からnullでないJavaScript文字列への関数へと評価されます。</p>
<p>ご想像の通り、PureScriptの配列はJavaScriptの配列に対応しています。
しかし、PureScriptの配列は均質である、つまり全ての要素が同じ型を持っていることは覚えておいてください。
具体的には、もしPureScriptの式<code>e</code>が何らかの型<code>a</code>について型<code>Array a</code>を持つなら、<code>e</code>は（nullでない）JavaScript配列へと評価されます。
この配列の全ての要素は型<code>a</code>の適切な実行時表現を持ちます。</p>
<p>PureScriptのレコードがJavaScriptのオブジェクトへと評価されることは既に見てきました。
関数や配列の場合のように、そのラベルに関連付けられている型を考慮すれば、レコードのフィールド中のデータの実行時の表現について論証できます。
勿論、レコードのフィールドは、同じ型である必要はありません。</p>
<h3 id="adtの表現"><a class="header" href="#adtの表現">ADTの表現</a></h3>
<p>代数的データ型の全ての構築子について、PureScriptコンパイラは関数を定義することで新たなJavaScriptオブジェクト型を作成します。
これらの構築子はプロトタイプに基づいて新しいJavaScriptオブジェクトを作成する関数に対応しています。</p>
<p>例えば次のような単純なADTを考えてみましょう。</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>PureScriptコンパイラは、次のようなコードを生成します。</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>ここで2つのJavaScriptオブジェクト型<code>Zero</code>と<code>One</code>を見てください。
JavaScriptのキーワード<code>new</code>を使用すると、各型の値を作成できます。
引数を持つ構築子については、コンパイラは<code>value0</code>、<code>value1</code>などという名前のフィールドに、対応するデータを格納します。</p>
<p>PureScriptコンパイラは補助関数も生成します。
引数のない構築子については、コンパイラは構築子が使われるたびに <code>new</code>演算子を使うのではなく、データを再利用できるように
<code>value</code>プロパティを生成します。
1つ以上の引数を持つ構築子では、コンパイラは適切な表現を持つ引数を取り適切な構築子を適用する <code>create</code>関数を生成します。</p>
<p>1引数より多く取る構築子についてはどうでしょうか。
その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成します。
ただしこの場合、補助関数は2引数のカリー化された関数です。
例えば次のような代数的データ型を考えます。</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>このコードからは、次のようなJavaScriptコードが生成されます。</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>ここで、オブジェクト型<code>Two</code>の値はキーワード<code>new</code>または<code>Two.create</code>関数を使用すると作成できます。</p>
<p>newtypeの場合はまた少し異なります。
newtypeは代数的データ型のようなもので、単一の引数を取る単一の構築子を持つよう制限されていたことを思い出してください。
この場合、newtypeの実行時表現は、その引数の型と同じになります。</p>
<p>例えば、以下の電話番号を表すnewtypeは実行時にJavaScriptの文字列として表現されます。</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>newtypeは、関数呼び出しによる実行時のオーバーヘッドなく更なる型安全性のための層を提供するため、ライブラリを設計するのに便利です。</p>
<h3 id="量化された型の表現"><a class="header" href="#量化された型の表現">量化された型の表現</a></h3>
<p>量化された型（多相型）の式は、実行時は制限された表現になっています。
実際、所与の量化された型を持つ式がより少なくなりますが、それによりかなり効率的に推論できるのです。</p>
<p>例えば、次の多相型を考えてみます。</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>この型を持っている関数にはどんなものがあるでしょうか。
実は少なくとも1つ、この型を持つ関数が存在します。</p>
<pre><code class="language-haskell">identity :: forall a. a -&gt; a
identity a = a
</code></pre>
<blockquote>
<p>なお、<code>Prelude</code>に定義された実際の<a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Category#v:identity"><code>identity</code></a>関数は僅かに違った型を持ちます。</p>
</blockquote>
<p>実のところ、<code>identity</code>関数はこの型の<em>唯一の</em>（全）関数です。
これは確かに間違いなさそうに思えますが（この型を持った <code>id</code>とは明らかに異なる式を書こうとしてみてください）、確かめるにはどうしたらいいでしょうか。
型の実行時表現を考えることによって確かめられます。</p>
<p>量化された型 <code>forall a. t</code>の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 <code>a</code>をどのように選んでも型 <code>t</code>の適切な実行時表現を持っていなければなりません。上の例では、型 <code>forall a. a -&gt; a</code>の関数は、 <code>String -&gt; String</code>、 <code>Number -&gt; Number</code>、 <code>Array Boolean -&gt; Array Boolean</code>などといった型について、適切な実行時表現を持っていなければなりません。 これらは、文字列から文字列、数から数の関数でなくてはなりません。</p>
<p>しかし、それだけでは充分ではありません。
量化された型の実行時表現は、これよりも更に厳しいものです。
任意の式が<em>パラメトリック多相的</em>であることを要求しています。
つまり、その実装において、引数の型についてのどんな情報も使うことができないのです。
この追加の条件は、以下のJavaScriptの関数のような問題のある実装が多相型に現住することを防止します。</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return "Argument was a string.";
    } else {
        return a;
    }
}
</code></pre>
<p>確かにこの関数は文字列を取って文字列を返し、数を取って数を返す、といったものです。
しかしこの関数は追加条件を満たしていません。
引数の実行時の型を調べており、型<code>forall a. a -&gt; a</code>の正しい現住にはならないからです。</p>
<p>関数の引数の実行時の型を検査できなければ、唯一の選択肢は引数をそのまま返すことだけです。
したがって<code>id</code>は確かに<code>forall a. a -&gt; a</code>の唯一の現住なのです。</p>
<p><em>パラメトリック多相</em>と<em>パラメトリック性</em>についての詳しい議論は本書の範囲を超えています。
ただ、PureScriptの型は実行時に<em>消去</em>されており、PureScriptの多相関数は（FFIを使わない限り）引数の実行時表現を検査<em>できない</em>ため、この多相的なデータの表現が適切になっているという点にはご留意ください。</p>
<h3 id="制約のある型の表現"><a class="header" href="#制約のある型の表現">制約のある型の表現</a></h3>
<p>型クラス制約を持つ関数は、実行時に面白い表現を持っています。
関数の挙動はコンパイラによって選ばれた型クラスのインスタンスに依存する可能性があるため、関数には<em>型クラス辞書</em>と呼ばれる追加の引数が与えられます。
この辞書には選ばれたインスタンスから提供される型クラスの関数の実装が含まれます。</p>
<p>例えば以下は、<code>Show</code>型クラスを使う制約付きの型を持つ、単純なPureScript関数です。</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; "!!!"
</code></pre>
<p>生成されるJavaScriptは次のようになります。</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + "!!!";
    };
};
</code></pre>
<p><code>shout</code>は1引数ではなく、2引数の（カリー化された）関数にコンパイルされていることに注意してください。最初の引数 <code>dict</code>は
<code>Show</code>制約の型クラス辞書です。 <code>dict</code>には型 <code>a</code>の <code>show</code>関数の実装が含まれています。</p>
<p>最初の引数として明示的に<code>Data.Show</code>の型クラス辞書を渡すと、JavaScriptからこの関数を呼び出すことができます。</p>
<pre><code class="language-javascript">import { showNumber } from 'Data.Show'

shout(showNumber)(42);
</code></pre>
<h3 id="演習-6"><a class="header" href="#演習-6">演習</a></h3>
<ol>
<li>
<p>（簡単）これらの型の実行時の表現は何でしょうか。</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>これらの型を持つ式についてわかることは何でしょうか。</p>
</li>
<li>
<p>（普通）<code>spago build</code>を使ってコンパイルし、NodeJSの <code>import</code>機能を使ってモジュールをインポートすることで、JavaScriptから <code>arrays</code>ライブラリの関数を使ってみてください。
<em>手掛かり</em>：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。</p>
</li>
</ol>
<h3 id="副作用の表現"><a class="header" href="#副作用の表現">副作用の表現</a></h3>
<p><code>Effect</code>モナドも外部型として定義されています。
その実行時表現はとても単純です。
型<code>Effect a</code>の式は<strong>引数なしの</strong>JavaScript関数へと評価されます。
この関数はあらゆる副作用を実行し、型<code>a</code>の適切な実行時表現を持つ値を返します。</p>
<p><code>Effect</code>型構築子の定義は、 <code>Effect</code>モジュールで次のように与えられています。</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>簡単な例として、 <code>random</code>パッケージで定義される <code>random</code>関数を考えてみてください。その型は次のようなものでした。</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p><code>random</code>関数の定義は次のように与えられます。</p>
<pre><code class="language-javascript">export const random = Math.random;
</code></pre>
<p><code>random</code>関数は実行時には引数なしの関数として表現されていることに注目してください。
この関数は乱数生成という副作用を実行して返しますが、返り値は<code>Number</code>型の実行時表現と一致します。
<code>Number</code>型はnullでないJavaScriptの数です。</p>
<p>もう少し興味深い例として、<code>console</code>パッケージ中の<code>Effect.Console</code>モジュールで定義された <code>log</code>関数を考えてみましょう。
<code>log</code>関数は次の型を持っています。</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>この定義は次のようになっています。</p>
<pre><code class="language-javascript">export const log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>実行時の <code>log</code>の表現は、単一の引数のJavaScript関数で、引数なしの関数を返します。
内側の関数はコンソールに文言を書き込むという副作用を実行します。</p>
<p><code>Effect a</code>型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出すことができます。例えば、この
<code>main</code>関数は何らかの型<code>a</code>について<code>Effect a</code>という型でなければならないので、次のように実行できます。</p>
<pre><code class="language-javascript">import { main } from 'Main'

main();
</code></pre>
<p><code>spago bundle-app --to</code>または<code>spago run</code>を使用する場合、<code>Main</code>モジュールが定義されている場合は常に、この<code>main</code>の呼び出しを自動的に生成できます。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter9.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter11.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter9.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter11.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

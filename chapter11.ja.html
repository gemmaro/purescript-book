<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>モナドな冒険 - PureScript by Example</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Foreword</a></li><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect Monad</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Asynchronous Effects</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="chapter1.ja.html"><strong aria-hidden="true">15.</strong> 導入</a></li><li class="chapter-item expanded "><a href="chapter2.ja.html"><strong aria-hidden="true">16.</strong> はじめよう</a></li><li class="chapter-item expanded "><a href="chapter3.ja.html"><strong aria-hidden="true">17.</strong> 関数とレコード</a></li><li class="chapter-item expanded "><a href="chapter4.ja.html"><strong aria-hidden="true">18.</strong> 再帰、マップ、畳み込み</a></li><li class="chapter-item expanded "><a href="chapter5.ja.html"><strong aria-hidden="true">19.</strong> パターン照合</a></li><li class="chapter-item expanded "><a href="chapter6.ja.html"><strong aria-hidden="true">20.</strong> 型クラス</a></li><li class="chapter-item expanded "><a href="chapter7.ja.html"><strong aria-hidden="true">21.</strong> アプリカティブによる検証</a></li><li class="chapter-item expanded "><a href="chapter8.ja.html"><strong aria-hidden="true">22.</strong> 作用モナド</a></li><li class="chapter-item expanded "><a href="chapter9.ja.html"><strong aria-hidden="true">23.</strong> 非同期作用</a></li><li class="chapter-item expanded "><a href="chapter10.ja.html"><strong aria-hidden="true">24.</strong> 外部関数インターフェース</a></li><li class="chapter-item expanded "><a href="chapter11.ja.html" class="active"><strong aria-hidden="true">25.</strong> モナドな冒険</a></li><li class="chapter-item expanded "><a href="chapter12.ja.html"><strong aria-hidden="true">26.</strong> Canvasグラフィックス</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/purescript-contrib/purescript-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="モナドな冒険"><a class="header" href="#モナドな冒険">モナドな冒険</a></h1>
<h2 id="この章の目標"><a class="header" href="#この章の目標">この章の目標</a></h2>
<p>この章の目標は<strong>モナド変換子</strong> (monad transformers) について学ぶことで
す。モナド変換子は異なるモナドから提供された副作用を合成する方法を提供
します。NodeJSのコンソール上で遊ぶことができる、テキストアドベンチャー
ゲームを題材として扱います。ゲームの様々な副作用（ロギング、状態、およ
び設定）がすべてモナド変換子スタックによって提供されます。</p>
<h2 id="プロジェクトの準備"><a class="header" href="#プロジェクトの準備">プロジェクトの準備</a></h2>
<p>このモジュールのプロジェクトでは以下の新しい依存関係が導入されます。</p>
<ul>
<li><code>ordered-collections</code> は不変のマップと集合のためのデータ型を提供します</li>
<li><code>transformers</code> は標準のモナド変換子の実装を提供します</li>
<li><code>node-readline</code> - NodeJSが提供する
<a href="http://nodejs.org/api/readline.html"><code>readline</code></a>インターフェイスへの
FFIバインディングを提供します</li>
<li><code>optparse</code> はコマンドライン引数を処理するアプリカティブ構文解析器を提
供します</li>
</ul>
<h2 id="ゲームの遊びかた"><a class="header" href="#ゲームの遊びかた">ゲームの遊びかた</a></h2>
<p>プロジェクトを走らせるには<code>spago run</code>を使います。</p>
<p>既定では使い方が表示されます。</p>
<pre><code class="language-text">Monadic Adventures! A game to learn monad transformers

Usage: run.js (-p|--player &lt;player name&gt;) [-d|--debug]
  Play the game as &lt;player name&gt;

Available options:
  -p,--player &lt;player name&gt;
                           The player's name &lt;String&gt;
  -d,--debug               Use debug mode
  -h,--help                Show this help text
</code></pre>
<p>コマンドライン引数を提供するためには、追加の引数を直接アプリケーション
に渡す<code>-a</code>オプション付きで<code>spago run</code>を呼び出すか、
<code>spago bundle-app</code>とすればよいです。2つ目の方法では<code>node</code>で直接走らせられる
index.jsファイルが作られます。
例えば<code>-p</code>オプションを使ってプレイヤー名を与えるには次のようにします。</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;
&gt;
</code></pre>
<pre><code class="language-text">$ spago bundle-app 
$ node index.js -p Phil
&gt;
</code></pre>
<p>プロンプトからは、 <code>look</code>、 <code>inventory</code>、 <code>take</code>、 <code>use</code>、 <code>north</code>、
<code>south</code>、 <code>east</code>、 <code>west</code>などのコマンドを入力することができます。
<code>debug</code>コマンドもあり、<code>--debug</code>コマンドラインオプションが与えられたと
きには、ゲームの状態を出力するのに使えます。</p>
<p>ゲームは2次元の碁盤の目の上が舞台で、コマンド <code>north</code>、 <code>south</code>、
<code>east</code>、 <code>west</code>を発行することによってプレイヤーが移動します。ゲームに
はアイテムの集まりがあり、プレイヤーの所持アイテム一覧を表したり、ゲー
ム盤上のその位置にあるアイテムの一覧を表すのに使われます。 <code>take</code>コマ
ンドを使うと、プレイヤーの位置にあるアイテムを拾い上げることができます。</p>
<p>参考までに、このゲームのひと通りの流れは次のようになります。</p>
<pre><code class="language-text">$ spago run -a &quot;-p Phil&quot;

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre>
<p>このゲームはとても単純ですが、この章の目的は <code>transformers</code>パッケージ
を使用してこのようなゲームを素早く開発できるようにするライブラリを構築
することです。</p>
<h2 id="stateモナド"><a class="header" href="#stateモナド">Stateモナド</a></h2>
<p><code>transformers</code>パッケージで提供されているいくつかのモナドを見ることから
始めましょう。</p>
<p>最初の例は<code>State</code>モナドで、これは純粋なコードで<strong>変更可能状態</strong>をモデ
ル化する手段を提供します。すでに <code>Effect</code>モナドによって提供される変更
可能状態の手法について見てきました。<code>State</code>はその代替を提供します。</p>
<p><code>State</code>型構築子は、状態の型 <code>s</code>、および返り値の型 <code>a</code>という2種類の引数
を取ります。「<code>State</code>モナド」というように説明はしていますが、
<code>Monad</code>型クラスのインスタンスは実際には任意の型 <code>s</code>についての <code>State s</code>型構築子に対して提供されています。</p>
<p><code>Control.Monad.State</code>モジュールは以下のAPIを提供しています。</p>
<pre><code class="language-haskell">get     :: forall s.             State s s
gets    :: forall s. (s -&gt; a) -&gt; State s a
put     :: forall s. s        -&gt; State s Unit
modify  :: forall s. (s -&gt; s) -&gt; State s s
modify_ :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p>なおここではこれらのAPIシグネチャは<code>State</code>型構築子を使った、単純化され
た形式で表されています。実際のAPIは本章の後にある「型クラス」節で押さ
える<code>MonadState</code>が関わってきます。ですからIDEのツールチップやPursuitで
異なるシグネチャを見たとしても心配しないでください。</p>
<p>例を見てみましょう。 <code>State</code>モナドの使いかたのひとつとしては、整数の配
列中の値を現在の状態に加えるものが考えられます。状態の型<code>s</code>として
<code>Int</code>を選択し、配列の走査に <code>traverse_</code>を使って、配列の要素それぞれに
ついて <code>modify</code>を呼び出すと、これを実現することができます。</p>
<pre><code class="language-haskell">import Data.Foldable (traverse_)
import Control.Monad.State
import Control.Monad.State.Class

sumArray :: Array Int -&gt; State Int Unit
sumArray = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre>
<p><code>Control.Monad.State</code>モジュールは <code>State</code>モナドでの計算を実行するための次の3つの関数を提供します。</p>
<pre><code class="language-haskell">evalState :: forall s a. State s a -&gt; s -&gt; a
execState :: forall s a. State s a -&gt; s -&gt; s
runState  :: forall s a. State s a -&gt; s -&gt; Tuple a s
</code></pre>
<p>3つの関数はそれぞれ型<code>s</code>の初期状態と型<code>State s a</code>の計算を引数にとりま
す。 <code>evalState</code>は返り値だけを返し、 <code>execState</code>は最終的な状態だけを返
し、 <code>runState</code>は <code>Tuple a s</code>型の値として表現された両方を返します。</p>
<p>先ほどの <code>sumArray</code>関数が与えられたとすると、PSCiで <code>execState</code>を使う
と次のように複数の配列内の数字を合計することができます。</p>
<pre><code class="language-text">&gt; :paste
… execState (do
…   sumArray [1, 2, 3]
…   sumArray [4, 5]
…   sumArray [6]) 0
… ^D
21
</code></pre>
<h2 id="演習"><a class="header" href="#演習">演習</a></h2>
<ol>
<li>
<p>(簡単) 上の例で、 <code>execState</code>を <code>runState</code>や <code>evalState</code>で 置き換える
と結果はどうなるでしょうか。</p>
</li>
<li>
<p>（普通）括弧からなる文字列について、次のいずれかであれば<strong>平衡して
いる</strong>とします。1つは0個以上のより短い平衡した文字列を連結したもの
で、もう1つはより短い平衡した文字列を一対の括弧で囲んだものです。</p>
<p><code>State</code>モナドと <code>traverse_</code>関数を使用して、次のような関数を書いてください。</p>
<pre><code class="language-haskell">testParens :: String -&gt; Boolean
</code></pre>
<p>これは <code>String</code>が括弧の対応が正しく付けられているかどうかを調べる
関数です。調べ方はまだ閉じられていない開括弧の数を把握しておくこと
です。この関数は次のように動作しなくてはなりません。</p>
<pre><code class="language-text">&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false
</code></pre>
<p><strong>ヒント</strong>：入力の文字列を文字の配列に変換するのに、
<code>Data.String.CodeUnits</code>モジュールの <code>toCharArray</code>関数を使うと良い
でしょう。</p>
</li>
</ol>
<h2 id="readerモナド"><a class="header" href="#readerモナド">Readerモナド</a></h2>
<p><code>transformers</code>パッケージでは <code>Reader</code>というモナドも提供されています。
このモナドは大域的な設定を読み取る機能を提供します。 <code>State</code>モナドがひ
とつの可変状態を読み書きする機能を提供するのに対し、 <code>Reader</code>モナドは
ひとつのデータの読み取りの機能だけを提供します。</p>
<p><code>Reader</code>型構築子は、設定の型を表す型 <code>r</code>、および戻り値の型 <code>a</code>の2つの
型引数を取ります。</p>
<p><code>Contro.Monad.Reader</code>モジュールは以下のAPIを提供します。</p>
<pre><code class="language-haskell">ask   :: forall r. Reader r r
local :: forall r a. (r -&gt; r) -&gt; Reader r a -&gt; Reader r a
</code></pre>
<p><code>ask</code>アクションは現在の設定を読み取るために使い、 <code>local</code>アクションは
変更された設定で計算を実行するために使います。</p>
<p>たとえば、権限で制御されたアプリケーションを開発しており、現在の利用者
の権限オブジェクトを保持するのに <code>Reader</code>モナドを使いたいとしましょう。
型 <code>r</code>を次のようなAPIを備えた型 <code>Permission</code>として選択できます。</p>
<pre><code class="language-haskell">hasPermission :: String -&gt; Permissions -&gt; Boolean
addPermission :: String -&gt; Permissions -&gt; Permissions
</code></pre>
<p>利用者が特定の権限を持っているかどうかを確認したいときは、 <code>ask</code>を使っ
て現在の権限オブジェクトを取得すればいつでも調べることができます。たと
えば、管理者だけが新しい利用者の作成を許可されているとしましょう。</p>
<pre><code class="language-haskell">createUser :: Reader Permissions (Maybe User)
createUser = do
  permissions &lt;- ask
  if hasPermission &quot;admin&quot; permissions
    then map Just newUser
    else pure Nothing
</code></pre>
<p><code>local</code>アクションを使うと、計算の実行中に <code>Permissions</code>オブジェクトを
変更し、ユーザーの権限を昇格させることもできます。</p>
<pre><code class="language-haskell">runAsAdmin :: forall a. Reader Permissions a -&gt; Reader Permissions a
runAsAdmin = local (addPermission &quot;admin&quot;)
</code></pre>
<p>こうすると、利用者が <code>admin</code>権限を持っていなかった場合であっても、新し
い利用者を作成する関数を書くことができます。</p>
<pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre>
<p><code>Reader</code>モナドの計算を実行するには、大域的な設定を与える <code>runReader</code>関
数を使います。</p>
<pre><code class="language-haskell">runReader :: forall r a. Reader r a -&gt; r -&gt; a
</code></pre>
<h2 id="演習-1"><a class="header" href="#演習-1">演習</a></h2>
<p>以下の演習では、 <code>Reader</code>モナドを使って、字下げのついた文書を出力する
ための小さなライブラリを作っていきます。「大域的な設定」は、現在の字下
げの深さを示す数になります。</p>
<pre><code class="language-haskell">type Level = Int

type Doc = Reader Level String
</code></pre>
<ol>
<li>
<p>（簡単）現在の字下げの深さで文字列を出力する関数 <code>line</code>を書いてくださ
い。関数は以下の型を持っている必要があります。</p>
<pre><code class="language-haskell">line :: String -&gt; Doc
</code></pre>
<p><strong>ヒント</strong>：現在の字下げの深さを読み取るためには <code>ask</code>関数を使用
します。<code>Data.Monoid</code>の<code>power</code>関数も役に立つかもしれません。</p>
</li>
<li>
<p>（普通）<code>local</code>関数を使用して次の関数を書いてください。</p>
<pre><code class="language-haskell">indent :: Doc -&gt; Doc
</code></pre>
<p>この関数はコードブロックの字下げの深さを大きくします。</p>
</li>
<li>
<p>（普通）<code>Data.Traversable</code>で定義された <code>sequence</code>関数を使用して、次
の関数を書いてください。</p>
<pre><code class="language-haskell">cat :: Array Doc -&gt; Doc
</code></pre>
<p>この関数は文書の集まりを改行で区切って連結します。</p>
</li>
<li>
<p>（普通）<code>runReader</code>関数を使用して次の関数を書いてください。</p>
<pre><code class="language-haskell">render :: Doc -&gt; String
</code></pre>
<p>この関数は文書を文字列として出力します。</p>
</li>
</ol>
<p>これで、このライブラリを次のように使うと、簡単な文書を書くことができ
るでしょう。</p>
<pre><code class="language-haskell">render $ cat
  [ line &quot;Here is some indented text:&quot;
  , indent $ cat
      [ line &quot;I am indented&quot;
      , line &quot;So am I&quot;
      , indent $ line &quot;I am even more indented&quot;
      ]
  ]
</code></pre>
<h2 id="writerモナド"><a class="header" href="#writerモナド">Writerモナド</a></h2>
<p><code>Writer</code>モナドは、計算の返り値に加えて、もうひとつの値を累積していく機
能を提供します。</p>
<p>よくある使い方としては型 <code>String</code>もしくは <code>Array String</code>でログを累積し
ていくというものなどがありますが、 <code>Writer</code>モナドはこれよりもっと一般
的なものです。これは累積するのに任意のモノイドの値を使うことができ、
<code>Additive Int</code>モノイドを使って、合計を追跡し続けるのに使ったり、 <code>Disj Boolean</code>モノイドを使って途中の <code>Boolean</code>値のいずれかが真であるかどうか
を追跡するのに使うことができます。</p>
<p><code>Writer</code>型の構築子は、 <code>Monoid</code>型クラスのインスタンスである型 <code>w</code>、お
よび返り値の型 <code>a</code>という2つの型引数を取ります。</p>
<p><code>Writer</code>のAPIで重要なのは <code>tell</code>関数です。</p>
<pre><code class="language-haskell">tell :: forall w a. Monoid w =&gt; w -&gt; Writer w Unit
</code></pre>
<p><code>tell</code>アクションは、与えられた値を現在の累積結果に加算します。</p>
<p>例として、 <code>Array String</code>モノイドを使用して、既存の関数にログ機能を追
加してみましょう。<strong>最大公約数</strong>関数の以前の実装を考えてみます。</p>
<pre><code class="language-haskell">gcd :: Int -&gt; Int -&gt; Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n &gt; m
            then gcd (n - m) m
            else gcd n (m - n)
</code></pre>
<p><code>Writer (Array String) Int</code>に返り値の型を変更することで、この関数にログ機能を追加することができます。</p>
<pre><code class="language-haskell">import Control.Monad.Writer
import Control.Monad.Writer.Class

gcdLog :: Int -&gt; Int -&gt; Writer (Array String) Int
</code></pre>
<p>各手順で二つの入力を記録するために、少し関数を変更する必要があります。</p>
<pre><code class="language-haskell">    gcdLog n 0 = pure n
    gcdLog 0 m = pure m
    gcdLog n m = do
      tell [&quot;gcdLog &quot; &lt;&gt; show n &lt;&gt; &quot; &quot; &lt;&gt; show m]
      if n &gt; m
        then gcdLog (n - m) m
        else gcdLog n (m - n)
</code></pre>
<p><code>Writer</code>モナドの計算を実行するには、 <code>execWriter</code>関数と <code>runWriter</code>関数のいずれかを使います。</p>
<pre><code class="language-haskell">execWriter :: forall w a. Writer w a -&gt; w
runWriter  :: forall w a. Writer w a -&gt; Tuple a w
</code></pre>
<p>ちょうど <code>State</code>モナドの場合と同じように、 <code>execWriter</code>が累積されたログだけを返すのに対して、
<code>runWriter</code>は累積されたログと結果の両方を返します。</p>
<p>PSCiで修正された関数を試してみましょう。</p>
<pre><code class="language-text">&gt; import Control.Monad.Writer
&gt; import Control.Monad.Writer.Class

&gt; runWriter (gcdLog 21 15)
Tuple 3 [&quot;gcdLog 21 15&quot;,&quot;gcdLog 6 15&quot;,&quot;gcdLog 6 9&quot;,&quot;gcdLog 6 3&quot;,&quot;gcdLog 3 3&quot;]
</code></pre>
<h2 id="演習-2"><a class="header" href="#演習-2">演習</a></h2>
<ol>
<li>
<p>（普通）<code>Writer</code>モナドと <code>monoid</code>パッケージの <code>Additive Int</code>モノイドを
使うように、上の <code>sumArray</code>関数を書き換えてください。</p>
</li>
<li>
<p>（普通）<strong>コラッツ関数</strong>は、自然数 <code>n</code>が偶数なら <code>n / 2</code>、 <code>n</code>が奇数な
ら <code>3 * n + 1</code>であると定義されています。たとえば、 <code>10</code>で始まるコラッ
ツ数列は次のようになります。</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的
に <code>1</code>になるということが予想されています。</p>
<p>数列が <code>1</code>に到達するまでに何回のコラッツ関数の適用が必要かを計算
する再帰的な関数を書いてください。</p>
<p><code>Writer</code>モナドを使用してコラッツ関数のそれぞれの適用の経過を記録
するように、関数を変更してください。</p>
</li>
</ol>
<h2 id="モナド変換子"><a class="header" href="#モナド変換子">モナド変換子</a></h2>
<p>上の3つのモナド、 <code>State</code>、 <code>Reader</code>、 <code>Writer</code>は、いずれもいわゆる
<strong>モナド変換子</strong>（monad transformers）の例となっています。対応するモナド変
換子はそれぞれ <code>StateT</code>、 <code>ReaderT</code>、 <code>WriterT</code>と呼ばれています。</p>
<p>モナド変換子とは何でしょうか。さて、これまで見てきたように、モナドは
PureScriptのコードを何らかの種類の副作用で拡張するものでした。このモナ
ドはPureScriptで適切なハンドラ（<code>runState</code>、 <code>runReader</code>、
<code>runWriter</code>など）を使って解釈することができます。使用する必要がある副
作用が<strong>ひとつだけ</strong>なら、これで問題ありません。しかし、同時に複数の副
作用を使用できると便利なことがよくあります。例えば、 <code>Maybe</code>と
<code>Reader</code>を一緒に使用すると、ある大域的な設定の文脈で<strong>省略可能な結果</strong>
を表現することができます。もしくは、 <code>Either</code>モナドの純粋なエラー追跡
機能と、 <code>State</code>モナドが提供する変更可能な状態が同時に欲しくなるかもし
れません。この問題を解決するのが<strong>モナド変換子</strong>です。</p>
<p>ただし<code>Effect</code>モナドがこの問題に対する部分的な解決策を提供していたこと
は既に見てきました。モナド変換子はまた異なった解決策を提供しますが、こ
れらの手法にはそれぞれ利点と限界があります。</p>
<p>モナド変換子は型だけでなく別の型構築子もパラメータに取る型構築子です。
モナド変換子はモナドをひとつ取り、独自のいろいろな副作用を追加した別の
モナドへと変換します。</p>
<p>例を見てみましょう。<code>State</code>のモナド変換子版は
<code>Control.Monad.State.Trans</code>モジュールで定義されている<code>StateT</code>です。
PSCiを使って <code>StateT</code>の種を見てみましょう。</p>
<pre><code class="language-text">&gt; import Control.Monad.State.Trans
&gt; :kind StateT
Type -&gt; (Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>とても読みにくそうに思うかもしれませんが、使い方を理解するために、
<code>StateT</code>にひとつ引数を与えてみましょう。</p>
<p><code>State</code>の場合、最初の型引数は使いたい状態の型です。それでは型
<code>String</code>を与えてみましょう。</p>
<pre><code class="language-text">&gt; :kind StateT String
(Type -&gt; Type) -&gt; Type -&gt; Type
</code></pre>
<p>次の引数は種 <code>Type -&gt; Type</code>の型構築子です。これは <code>StateT</code>の機能を追加
したい元のモナドを表します。例として、 <code>Either String</code>モナドを選んでみ
ます。</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String)
Type -&gt; Type
</code></pre>
<p>型構築子が残りました。最後の引数は戻り値の型を表しており、たとえばそれ
を <code>Number</code>にすることができます。</p>
<pre><code class="language-text">&gt; :kind StateT String (Either String) Number
Type
</code></pre>
<p>最後に、種 <code>Type</code>の何かが残りましたが、これはつまりこの型の値を探して
みることができるということです。</p>
<p>構築したモナド <code>StateT String (Either String)</code>は、エラーで失敗する可能
性があり、変更可能な状態を使える計算を表しています。</p>
<p>外側の <code>StateT String (Either String)</code>モナドのアクション(<code>get</code>、 <code>put</code>、
<code>modify</code>)は直接使うことができますが、ラップされている内側のモナド
(<code>Either String</code>)の作用を使うためには、これらの関数をモナド変換子まで
「持ち上げ」なくてはいけません。 <code>Control.MonadTrans</code>モジュールでは、
モナド変換子であるような型構築子を捕捉する <code>MonadTrans</code>型クラスを次の
ように定義しています。</p>
<pre><code class="language-haskell">class MonadTrans t where
  lift :: forall m a. Monad m =&gt; m a -&gt; t m a
</code></pre>
<p>このクラスは、基礎となる任意のモナド <code>m</code>の計算をとり、それをラップされ
たモナド <code>t m</code>へと持ち上げる、 <code>lift</code>というひとつの関数だけを持ってい
ます。今回の場合、型構築子 <code>t</code>は <code>StateT String</code>で、 <code>m</code>は <code>Either String</code>モナドとなり、 <code>lift</code>は型 <code>Either String a</code>の計算を、型 <code>State String (Either String) a</code>の計算へと持ち上げる方法を提供することになり
ます。これは、型 <code>Either String a</code>の計算を使うときは、 <code>lift</code>を使えば
いつでも作用 <code>StateT String</code>と <code>Either String</code>を一緒に使うことができる
ことを意味します。</p>
<p>たとえば、次の計算は <code>StateT</code>モナド変換子で導入されている状態を読み込
み、状態が空の文字列である場合はエラーを投げます。</p>
<pre><code class="language-haskell">import Data.String (drop, take)

split :: StateT String (Either String) String
split = do
  s &lt;- get
  case s of
    &quot;&quot; -&gt; lift $ Left &quot;Empty string&quot;
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>状態が空でなければ、この計算は <code>put</code>を使って状態を <code>drop 1 s</code>（最初の
文字を取り除いた <code>s</code>）へと更新し、 <code>take 1 s</code>（<code>s</code>の最初の文字）を返し
ます。</p>
<p>それではPSCiでこれを試してみましょう。</p>
<pre><code class="language-text">&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;
</code></pre>
<p>これは <code>StateT</code>を使わなくても実装できるので、さほど驚くようなことでは
ありません。しかし、モナドとして扱っているので、do記法やアプリカティブ
コンビネータを使って、小さな計算から大きな計算を構築していくことができ
ます。例えば、2回 <code>split</code>を適用すると、文字列から最初の2文字を読むこと
ができます。</p>
<pre><code class="language-text">&gt; runStateT ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple &quot;te&quot; &quot;st&quot;))
</code></pre>
<p>他にもアクションを沢山用意すれば、 <code>split</code>関数を使って、基本的な構文解
析ライブラリを構築することができます。これは実際に <code>parsing</code>ライブラリ
で採用されている手法です。これがモナド変換子の力なのです。必要な副作用
を選択して、do記法とアプリカティブコンビネータで表現力を維持しながら、
様々な問題のための特注のモナドを作成することができるのです。</p>
<h2 id="excepttモナド変換子"><a class="header" href="#excepttモナド変換子">ExceptTモナド変換子</a></h2>
<p><code>transformers</code>パッケージでは、 <code>Either e</code>モナドに対応する変換子である
<code>ExceptT e</code>モナド変換子も定義されています。これは次のAPIを提供します。</p>
<pre><code class="language-haskell">class MonadError e m where
  throwError :: forall a. e -&gt; m a
  catchError :: forall a. m a -&gt; (e -&gt; m a) -&gt; m a

instance monadErrorExceptT :: Monad m =&gt; MonadError e (ExceptT e m)

runExceptT :: forall e m a. ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p><code>MonadError</code>クラスは <code>e</code>型のエラーのスローとキャッチをサポートするモナ
ドを取得し、 <code>ExceptT e</code>モナド変換子のインスタンスが提供されます。
<code>Either e</code>モナドの <code>Left</code>と同じように、 <code>throwError</code>アクションは失敗を
示すために使われます。 <code>catchError</code>アクションを使うと、 <code>throwError</code>で
エラーが投げられたあとでも処理を継続することができるようになります。</p>
<p><code>runExceptT</code>ハンドラを使うと、型 <code>ExceptT e m a</code>の計算を実行することが
できます。</p>
<p>このAPIは <code>exceptions</code>パッケージの <code>Exception</code>作用によって提供されてい
るものと似ています。しかし、いくつかの重要な違いがあります。</p>
<ul>
<li><code>Exception</code>が実際のJavaScriptの例外を使っているのに対して<code>ExceptT</code>モデ
ルは代数的データ型を使っています。</li>
<li><code>Exception</code>作用がJavaScriptの <code>Error</code>型というひとつ例外の型だけを扱う
のに対して<code>ExceptT</code>は<code>Error</code>型クラスのどんな型のエラーでも扱います。つ
まり、 <code>ExceptT</code>では新たなエラー型を自由に定義できます。</li>
</ul>
<p>試しに <code>ExceptT</code>を使って <code>Writer</code>モナドを包んでみましょう。ここでもモ
ナド変換子 <code>ExceptT e</code>のアクションを自由に直接使うこともできますが、
<code>Writer</code>モナドの計算は <code>lift</code>を使って持ちあげるべきです。</p>
<pre><code class="language-haskell">import Control.Monad.Except
import Control.Monad.Writer

writerAndExceptT :: ExceptT String (Writer (Array String)) String
writerAndExceptT = do
  lift $ tell [&quot;Before the error&quot;]
  _ &lt;- throwError &quot;Error!&quot;
  lift $ tell [&quot;After the error&quot;]
  pure &quot;Return value&quot;
</code></pre>
<p>PSCiでこの関数を試すと、ログの蓄積とエラーの送出という2つの作用がどの
ように相互作用しているのかを見ることができます。まず、 <code>runExceptT</code>を
使って外側の <code>ExceptT</code>計算を実行し、型 <code>Writer (Array String) (Either String String)</code>の結果を残します。それから、 <code>runWriter</code>で内側の
<code>Writer</code>計算を実行します。</p>
<pre><code class="language-text">&gt; runWriter $ runExceptT writerAndExceptT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]
</code></pre>
<p>実際に追加されるログは、エラーが投げられる前に書かれたログメッセージだ
けであることにも注目してください。</p>
<h2 id="モナド変換子スタック"><a class="header" href="#モナド変換子スタック">モナド変換子スタック</a></h2>
<p>これまで見てきたように、モナド変換子を使うと既存のモナドの上に新しいモ
ナドを構築することができます。任意のモナド変換子 <code>t1</code>と任意のモナド
<code>m</code>について、その適用 <code>t1 m</code>もまたモナドになります。これは<strong>2つめの</strong>
モナド変換子 <code>t2</code>を先ほどの結果 <code>t1 m</code>に適用すると、3つ目のモナド <code>t2 (t1 m)</code>を作れることを意味しています。このように、構成するモナドによっ
て提供された副作用を組み合わせる、モナド変換子の<strong>スタック</strong>を構築する
ことができます。</p>
<p>実際には、基本となるモナド <code>m</code>は、ネイティブの副作用が必要なら
<code>Effect</code>モナド、さもなくば <code>Data.Identity</code>モジュールで定義されている
<code>Identity</code>モナドになります。 <code>Identity</code>モナドは何の新しい副作用も追加
しませんから、 <code>Identity</code>モナドの変換は、モナド変換子の作用だけを提供
します。実際に、 <code>State</code>モナド、 <code>Reader</code>モナド、 <code>Writer</code>モナドは、
<code>Identity</code>モナドをそれぞれ <code>StateT</code>、 <code>ReaderT</code>、 <code>WriterT</code>で変換する
ことによって実装されています。</p>
<p>それでは3つの副作用が組み合わされている例を見てみましょう。
<code>Identity</code>モナドをスタックの底にして、 <code>StateT</code>作用、 <code>WriterT</code>作用、
<code>ExceptT</code>作用を使います。このモナド変換子スタックは、可変状態、ログの
蓄積、そして純粋なエラーの副作用を提供します。</p>
<p>このモナド変換子スタックを使うと、ロギングの機能が追加された <code>split</code>ア
クションを再現させられます。</p>
<pre><code class="language-haskell">type Errors = Array String

type Log = Array String

type Parser = StateT String (WriterT Log (ExceptT Errors Identity))

split :: Parser String
split = do
  s &lt;- get
  lift $ tell [&quot;The state is &quot; &lt;&gt; s]
  case s of
    &quot;&quot; -&gt; lift $ lift $ throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>この計算をPSCiで試してみると、 <code>split</code>が実行されるたびに状態がログに追
加されることがわかります。</p>
<p>モナド変換子スタックに現れる順序に従って、副作用を取り除いていかなけれ
ばならないことに注意してください。最初に <code>StateT</code>型構築子を取り除くた
めに <code>runStateT</code>を使い、それから <code>runtWriteT</code>を使い、その後
<code>runExceptT</code>を使います。最後に <code>unwrap</code>を使用して <code>Identity</code>モナドの演
算を実行します。</p>
<pre><code class="language-text">&gt; runParser p s = unwrap $ runExceptT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
(Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;]))

&gt; runParser ((&lt;&gt;) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
(Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;]))
</code></pre>
<p>しかしながら状態が空であることが理由で解析が失敗した場合は、ログはまっ
たく出力されません。</p>
<pre><code class="language-text">&gt; runParser split &quot;&quot;
(Left [&quot;Empty string&quot;])
</code></pre>
<p>これは、 <code>ExceptT</code>モナド変換子が提供する副作用が、 <code>WriterT</code>モナド変換
子が提供する副作用と干渉するためです。これはモナド変換子スタックが構成
されている順序を変更することで解決することができます。スタックの最上部
に <code>ExceptT</code>変換子を移動すると、先ほど <code>Writer</code>を <code>ExceptT</code>に変換した
ときと同じように、最初のエラーまでに書かれたすべてのメッセージが含まれ
るようになります。</p>
<p>このコードの問題のひとつは、複数のモナド変換子の上まで計算を持ち上げる
ために、 <code>lift</code>関数を複数回使わなければならないということです。たとえ
ば、 <code>throwError</code>の呼び出しは、1回目は <code>WriteT</code>へ、2回目は <code>StateT</code>へ
と、2回持ちあげなければなりません。小さなモナド変換子スタックならなん
とかなりますが、そのうち不便だと感じるようになるでしょう。</p>
<p>幸いなことに、これから見るような型クラス推論によって提供されるコードの
自動生成を使うと、ほとんどの「重労働」を任せられます。</p>
<h2 id="演習-3"><a class="header" href="#演習-3">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>Identity</code>関手の上の <code>ExceptT</code>モナド変換子を使って、分母がゼロ
の場合は（文字列「Divide by zero!」の）エラーを投​​げる、2つの数の商を求
める関数 <code>safeDivide</code>を書いてください。</p>
</li>
<li>
<p>（普通）次のような構文解析関数を書いてください。</p>
<pre><code class="language-haskell">string :: String -&gt; Parser String
</code></pre>
<p>これは現在の状態が接頭辞に適合するか、もしくはエラーメッセージと
ともに失敗します。</p>
<p>この構文解析器は次のように動作します。</p>
<pre><code class="language-text">&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;
(Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;]))
</code></pre>
<p><strong>ヒント</strong>：出発点として <code>split</code>の実装を使うといいでしょう。
<code>stripPrefix</code>関数も役に立ちます。</p>
</li>
<li>
<p>（難しい）以前 <code>Reader</code>モナドを使用して書いた文書表示ライブラリを、
<code>ReaderT</code>と <code>WriterT</code>モナド変換子を使用して再実装してください。</p>
<p>文字列を出力する <code>line</code>や文字列を連結する <code>cat</code>を使うのではなく、
<code>WriteT</code>モナド変換子と一緒に <code>Array String</code>モノイドを使い、結果へ
行を追加するのに <code>tell</code>を使ってください。アポストロフィ (<code>'</code>) で
終わる以外は元の実装と同じ名前を使ってください。</p>
</li>
</ol>
<h2 id="型クラスが助けに来たぞ"><a class="header" href="#型クラスが助けに来たぞ">型クラスが助けに来たぞ！</a></h2>
<p>本章の最初で扱った <code>State</code>モナドを見てみると、 <code>State</code>モナドのアクショ
ンには次のような型が与えられていました。</p>
<pre><code class="language-haskell">get    :: forall s.             State s s
put    :: forall s. s        -&gt; State s Unit
modify :: forall s. (s -&gt; s) -&gt; State s Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>モジュールで与えられている型は、実際にはこ
れよりもっと一般的です。</p>
<pre><code class="language-haskell">get    :: forall m s. MonadState s m =&gt;             m s
put    :: forall m s. MonadState s m =&gt; s        -&gt; m Unit
modify :: forall m s. MonadState s m =&gt; (s -&gt; s) -&gt; m Unit
</code></pre>
<p><code>Control.Monad.State.Class</code>モジュールには<code>MonadState</code>（多変数）型クラ
スが定義されています。この型クラスは「純粋な変更可能な状態を提供するモ
ナド」への抽象化を可能にします。予想できると思いますが、 <code>State s</code>型構
築子は <code>MonadState s</code>型クラスのインスタンスになっており、このクラスに
は他にも興味深いインスタンスが数多くあります。</p>
<p>特に、 <code>transformers</code>パッケージではモナド変換子 <code>WriterT</code>、 <code>ReaderT</code>、
<code>ExceptT</code>についての <code>MonadState</code>のインスタンスが提供されています。通底
する<code>Monad</code>が<code>MonadState</code>インスタンスを持っていれば常に、これらのモナ
ド変換子にもインスタンスがあります。実践的には、 <code>StateT</code>がモナド変換
子スタックの<strong>どこか</strong>に現れ、 <code>StateT</code>より上のすべてが <code>MonadState</code>の
インスタンスであれば、 <code>get</code>、 <code>put</code>、 <code>modify</code>を直接自由に使用するこ
とができます。</p>
<p>当然ですが、これまで扱ってきた <code>ReaderT</code>、 <code>WriterT</code>、 <code>ExceptT</code>変換子
についても、同じことが成り立っています。<code>transformers</code>では主な変換子そ
れぞれについての型クラスが定義されています。これによりそれらの操作に対
応するモナドの上に抽象化することができるのです。</p>
<p>上の <code>split</code>関数の場合、構築されたこのモナドスタックは型クラス
<code>MonadState</code>、 <code>MonadWriter</code>、 <code>MonadError</code>それぞれのインスタンスです。
これはつまり、 <code>lift</code>をまったく呼び出す必要がないことを意味します！ま
るでモナドスタック自体に定義されていたかのように、アクション <code>get</code>、
<code>put</code>、 <code>tell</code>、 <code>throwError</code>をそのまま使用することができます。</p>
<pre><code class="language-haskell">split :: Parser String
split = do
  s &lt;- get
  tell [&quot;The state is &quot; &lt;&gt; show s]
  case s of
    &quot;&quot; -&gt; throwError [&quot;Empty string&quot;]
    _ -&gt; do
      put (drop 1 s)
      pure (take 1 s)
</code></pre>
<p>この計算はまるで、可変状態、ロギング、エラー処理という３つの副作用に対
応した、独自のプログラミング言語を拡張したかのようにみえます。しかしな
がら、内部的にはすべてはあくまで純粋な関数と普通のデータを使って実装さ
れているのです。</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p><code>control</code>パッケージでは失敗しうる計算を操作するための抽象化がいくつか
定義されています。そのひとつは <code>Alternative</code>型クラスです。</p>
<pre><code class="language-haskell">class Functor f &lt;= Alt f where
  alt :: forall a. f a -&gt; f a -&gt; f a

class Alt f &lt;= Plus f where
  empty :: forall a. f a

class (Applicative f, Plus f) &lt;= Alternative f
</code></pre>
<p><code>Alternative</code>は2つの新しいコンビネータを提供しています。1つは失敗しう
る計算のプロトタイプを提供する <code>empty</code>値で、もう1つはエラーが起きたと
きに<strong>代替</strong> (Alternative) 計算へ戻ってやり直す機能を提供する<code>alt</code>関数
（そしてその別名<code>&lt;|&gt;</code>）演算子です。</p>
<p><code>Data.Array</code>モジュールでは <code>Alternative</code>型クラスで型構築子を操作する2
つの便利な関数を提供します。</p>
<pre><code class="language-haskell">many :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
some :: forall f a. Alternative f =&gt; Lazy (f (Array a)) =&gt; f a -&gt; f (Array a)
</code></pre>
<p><code>Data.List</code>にも等価な<code>many</code>と<code>some</code>があります。</p>
<p><code>many</code>コンビネータは計算を<strong>ゼロ回以上</strong>繰り返し実行するために
<code>Alternative</code>型クラスを使用しています。 <code>some</code>コンビネータも似ています
が、成功するために少なくとも1回の計算を必要とします。</p>
<p><code>Parser</code>モナド変換子スタックの場合は、<code>ExceptT</code>コンポーネントによる
<code>Alternative</code>のインスタンスがあります。このコンポーネントでは異なる分
枝のエラーに<code>Monoid</code>インスタンスを使って組み合わせることによって対応し
ています（だから<code>Errors</code>型に<code>Array String</code>を選ぶ必要があったんですね）。
これは、構文解析器を複数回実行するのに<code>many</code>関数と<code>some</code>関数を使うこと
ができることを意味します。</p>
<pre><code class="language-text">&gt; import Data.Array (many)

&gt; runParser (many split) &quot;test&quot;
(Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;)
              [ &quot;The state is \&quot;test\&quot;&quot;
              , &quot;The state is \&quot;est\&quot;&quot;
              , &quot;The state is \&quot;st\&quot;&quot;
              , &quot;The state is \&quot;t\&quot;&quot;
              ]))
</code></pre>
<p>ここでは入力文字列 <code>&quot;test&quot;</code>は、1文字からなる文字列4つの配列を返すよう
に繰り返し分割されています。残った状態は空で、ログは <code>split</code>コンビネー
タが4回適用されたことを示しています。</p>
<h2 id="モナド内包表記"><a class="header" href="#モナド内包表記">モナド内包表記</a></h2>
<p><code>Control.MonadPlus</code>モジュールには <code>MonadPlus</code>と呼ばれる
<code>Alternative</code>型クラスの副クラスが定義されています。 <code>MonadPlus</code>はモナ
ドと<code>Alternative</code>両方のインスタンスである型構築子を取ります。</p>
<pre><code class="language-haskell">class (Monad m, Alternative m) &lt;= MonadPlus m
</code></pre>
<p>実際、<code>Parser</code>モナドは <code>MonadPlus</code>のインスタンスです。</p>
<p>以前に本書中で配列内包表記を扱ったとき、不要な結果をフィルタリングする
ために使われる<code>guard</code>関数を導入しました。実際は <code>guard</code>関数はもっと一
般的で、 <code>MonadPlus</code>のインスタンスであるすべてのモナドに対して使うこと
ができます。</p>
<pre><code class="language-haskell">guard :: forall m. Alternative m =&gt; Boolean -&gt; m Unit
</code></pre>
<p><code>&lt;|&gt;</code>演算子は失敗時のバックトラッキングをできるようにします。これがど
のように役立つかを見るために、大文字だけに適合する <code>split</code>コンビネータ
の亜種を定義してみましょう。</p>
<pre><code class="language-haskell">upper :: Parser String
upper = do
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre>
<p>ここで、文字列が大文字でない場合に失敗するよう <code>guard</code>を使用しています。
このコードは前に見た配列内包表記とよく似ていることに注目してください。
このように<code>MonadPlus</code>を使うことは、<strong>モナド内包表記</strong> (monad
comprehensions) の構築と呼ばれることがあります。</p>
<h2 id="バックトラッキング"><a class="header" href="#バックトラッキング">バックトラッキング</a></h2>
<p><code>&lt;|&gt;</code>演算子を使うと、失敗したときに別の代替計算へとバックトラックする
ことができます。これを確かめるために、小文字に一致するもう一つの構文解
析器を定義してみましょう。</p>
<pre><code class="language-haskell">lower :: Parser String
lower = do
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre>
<p>これにより、まずもし最初の文字が大文字なら複数の大文字に適合し、さもな
くばもし最初の文字が小文字なら複数の小文字に適合する、という構文解析器
を定義することができます。</p>
<pre><code class="language-text">&gt; upperOrLower = some upper &lt;|&gt; some lower
</code></pre>
<p>この構文解析器は、大文字と小文字が切り替わるまで、文字に適合し続けます。</p>
<pre><code class="language-text">&gt; runParser upperOrLower &quot;abcDEF&quot;
(Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;))
              [ &quot;The state is \&quot;abcDEF\&quot;&quot;
              , &quot;The state is \&quot;bcDEF\&quot;&quot;
              , &quot;The state is \&quot;cDEF\&quot;&quot;
              ]))
</code></pre>
<p><code>many</code>を使うと、文字列を小文字と大文字の要素に完全に分割することもできます。</p>
<pre><code class="language-text">&gt; components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
(Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;)
              [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
              , &quot;The state is \&quot;CDeFgh\&quot;&quot;
              , &quot;The state is \&quot;DeFgh\&quot;&quot;
              , &quot;The state is \&quot;eFgh\&quot;&quot;
              , &quot;The state is \&quot;Fgh\&quot;&quot;
              , &quot;The state is \&quot;gh\&quot;&quot;
              , &quot;The state is \&quot;h\&quot;&quot;
              ]))
</code></pre>
<p>繰り返しになりますが、これはモナド変換子がもたらす再利用性の威力を示し
ています。標準的な抽象化を再利用することで、宣言型スタイルのバックトラッ
ク構文解析器をわずか数行のコードで書くことができました！</p>
<h2 id="演習-4"><a class="header" href="#演習-4">演習</a></h2>
<ol>
<li>
<p>（簡単）<code>string</code>構文解析器の実装から <code>lift</code>関数の呼び出しを取り除いて
ください。新しい実装の型が整合していることを確認し、なぜそのようになる
のかをよく納得しておきましょう。</p>
</li>
<li>
<p>（普通）<code>string</code>構文解析器と <code>many</code>コンビネータを使って、文字列
<code>&quot;a&quot;</code>の連続と、それに続く文字列 <code>&quot;b&quot;</code>の連続からなる文字列を認識する構
文解析器<code>asFollowedByBs</code>を書いてください。</p>
</li>
<li>
<p>（普通）<code>&lt;|&gt;</code>演算子を使って、文字 <code>a</code>と文字 <code>b</code>が任意の順序で現れるよ
うな文字列を認識する構文解析器<code>asOrBs</code>を書いてください。</p>
</li>
<li>
<p>（難しい）<code>Parser</code>モナドを次のように定義することもできます。</p>
<pre><code class="language-haskell">type Parser = ExceptT Errors (StateT String (WriterT Log Identity))
</code></pre>
<p>このように変更すると、構文解析関数にどのような影響を与えるでしょうか。</p>
</li>
</ol>
<h2 id="rwsモナド"><a class="header" href="#rwsモナド">RWSモナド</a></h2>
<p>モナド変換子のある特定の組み合わせは頻出なので、<code>transformers</code>パッケー
ジ内の単一のモナド変換子として提供されています。<code>Reader</code>、 <code>Writer</code>、
<code>State</code>のモナドは、<strong>Reader-Writer-State</strong>モナドに組み合わさり、より単
純に<code>RWS</code>モナドともされます。このモナドは <code>RWST</code>モナド変換子と呼ばれる、
対応するモナド変換子を持っています。</p>
<p>ここでは <code>RWS</code>モナドを使ってテキストアドベンチャーゲームの処理を設計し
ていきます。</p>
<p><code>RWS</code>モナドは（戻り値の型に加えて）3つの型変数を使って定義されています。</p>
<pre><code class="language-haskell">type RWS r w s = RWST r w s Identity
</code></pre>
<p>副作用を提供しない <code>Identity</code>に基底のモナドを設定することで、 <code>RWS</code>モ
ナドが独自のモナド変換子を用いて定義されていることに注意してください。</p>
<p>第1型引数 <code>r</code>は大域的な設定の型を表します。第2型引数 <code>w</code>はログを蓄積す
るために使用するモノイド、第3型引数 <code>s</code>は可変状態の型を表しています。</p>
<p>このゲームの場合には、大域的な設定は <code>Data.GameEnvironment</code>モジュール
の <code>GameEnvironment</code>と呼ばれる型で定義されています。</p>
<pre><code class="language-haskell">type PlayerName = String

newtype GameEnvironment = GameEnvironment
  { playerName    :: PlayerName
  , debugMode     :: Boolean
  }
</code></pre>
<p>プレイヤー名と、ゲームがデバッグモードで動作しているか否かを示すフラグ
が定義されています。これらのオプションは、モナド変換子を実行するときに
コマンドラインから設定されます。</p>
<p>可変状態は <code>Data.GameState</code>モジュールの <code>GameState</code>と呼ばれる型で定義
されています。</p>
<pre><code class="language-haskell">import Data.Map as M
import Data.Set as S

newtype GameState = GameState
  { items       :: M.Map Coords (S.Set GameItem)
  , player      :: Coords
  , inventory   :: S.Set GameItem
  }
</code></pre>
<p><code>Coords</code>データ型は2次元平面の点を表し、 <code>GameItem</code>データ型はゲーム内の
アイテムの列挙です。</p>
<pre><code class="language-haskell">data GameItem = Candle | Matches
</code></pre>
<p><code>GameState</code>型は2つの新しいデータ構造を使っています。<code>Map</code>と<code>Set</code>はそれ
ぞれ整列されたマップと整列された集合を表します。<code>items</code>属性は、そのゲー
ム平面上の座標からゲームアイテムの集合への対応付けになっています。
<code>player</code>属性はプレイヤーの現在の座標を格納しており、 <code>inventory</code>属性は
現在プレイヤーが保有するゲームアイテムの集合です。</p>
<p><code>Map</code>と <code>Set</code>のデータ構造はキーによって整列され、 <code>Ord</code>型クラスの任意
の型をキーとして使用することができます。これは今回のデータ構造のキーが
完全に順序付けできることを意味します。</p>
<p>ゲームのアクションを書く上で<code>Map</code>と <code>Set</code>構造をどのように使っていくの
かを見ていきます。</p>
<p>ログとしては <code>List String</code>モノイドを使います。<code>Game</code>モナド用の型同義語
を定義し、<code>RWS</code>を使って実装できます。</p>
<pre><code class="language-haskell">type Log = L.List String

type Game = RWS GameEnvironment Log GameState
</code></pre>
<h2 id="ゲームロジックの実装"><a class="header" href="#ゲームロジックの実装">ゲームロジックの実装</a></h2>
<p>今回は、 <code>Reader</code>モナド、 <code>Writer</code>モナド、 <code>State</code>モナドのアクションを
再利用し、 <code>Game</code>モナドで定義されている単純なアクションを組み合わせて
ゲームを構築していきます。このアプリケーションの最上位では、 <code>Game</code>モ
ナドで純粋な計算を実行しており、 <code>Effect</code>モナドはコンソールにテキスト
を出力するような観測可能な副作用へと結果を変換するために使っています。</p>
<p>このゲームで最も簡単なアクションのひとつは <code>has</code>アクションです。このア
クションはプレイヤーの持ち物に特定のゲームアイテムが含まれているかどう
かを調べます。これは次のように定義されます。</p>
<pre><code class="language-haskell">has :: GameItem -&gt; Game Boolean
has item = do
  GameState state &lt;- get
  pure $ item `S.member` state.inventory
</code></pre>
<p>この関数は、現在のゲームの状態を読み取るために <code>MonadState</code>型クラスで
定義されている <code>get</code>アクションを使っており、それから指定した
<code>GameItem</code>が持ち物アイテムの<code>Set</code>に出現するかどうかを調べるために
<code>Data.Set</code>で定義されている <code>member</code>関数を使っています。</p>
<p>他にも <code>pickUp</code>アクションがあります。現在の位置にゲームアイテムがある
場合、プレイヤーの持ち物にそのアイテムを追加します。これには
<code>MonadWriter</code>と <code>MonadState</code>型クラスのアクションを使っています。一番最
初に現在のゲームの状態を読み取ります。</p>
<pre><code class="language-haskell">pickUp :: GameItem -&gt; Game Unit
pickUp item = do
  GameState state &lt;- get
</code></pre>
<p>次に <code>pickUp</code>は現在の位置にあるアイテムの集合を検索します。これは
<code>Data.Map</code>で定義された <code>lookup</code>関数を使って行います。</p>
<pre><code class="language-haskell">  case state.player `M.lookup` state.items of
</code></pre>
<p><code>lookup</code>関数は <code>Maybe</code>型構築子で示されたオプショナルな結果を返します。
<code>lookup</code>関数は、キーがマップにない場合は <code>Nothing</code>を返し、それ以外の場
合は <code>Just</code>構築子で対応する値を返します。</p>
<p>関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含ま
れている場合です。ここでも<code>member</code>関数を使うとこれを調べることができます。</p>
<pre><code class="language-haskell">    Just items | item `S.member` items -&gt; do
</code></pre>
<p>この場合、 <code>put</code>を使ってゲームの状態を更新し、 <code>tell</code>を使ってログにメッ
セージを追加できます。</p>
<pre><code class="language-haskell">          let newItems = M.update (Just &lt;&lt;&lt; S.delete item) state.player state.items
              newInventory = S.insert item state.inventory
          put $ GameState state { items     = newItems
                                , inventory = newInventory
                                }
          tell (L.singleton (&quot;You now have the &quot; &lt;&gt; show item))
</code></pre>
<p>ここで2つの計算のどちらも<code>lift</code>が必要ないことに注意してください。なぜ
なら<code>MonadState</code>と <code>MonadWriter</code>の両方について <code>Game</code>モナド変換子スタッ
ク用の適切なインスタンスが存在するからです。</p>
<p><code>put</code>への引数では、レコード更新を使ってゲームの状態の <code>items</code>と
<code>inventory</code>フィールドを変更しています。特定のキーの値を変更する
<code>Data.Map</code>の <code>update</code>関数を使っています。この場合、プレイヤーの現在の
位置にあるアイテムの集合を変更するのに、<code>delete</code>関数を使って指定したア
イテムを集合から取り除いています。<code>insert</code>を使って新しいアイテムをプレ
イヤーの持ち物集合に加えるときにも、<code>inventory</code>は更新されます。</p>
<p>最後に、<code>pickUp</code>関数は <code>tell</code>を使ってユーザに次のように通知することに
より、残りの場合を処理します。</p>
<pre><code class="language-haskell">    _ -&gt; tell (L.singleton &quot;I don't see that item here.&quot;)
</code></pre>
<p><code>Reader</code>モナドを使う例として、 <code>debug</code>コマンドのコードを見てみましょう。
ゲームがデバッグモードで実行されている場合、このコマンドを使うとユーザ
は実行時にゲームの状態を調べることができます。</p>
<pre><code class="language-haskell">  GameEnvironment env &lt;- ask
  if env.debugMode
    then do
      state :: GameState &lt;- get
      tell (L.singleton (show state))
    else tell (L.singleton &quot;Not running in debug mode.&quot;)
</code></pre>
<p>ここでは、ゲームの設定を読み込むために <code>ask</code>アクションを使用しています。
繰り返しますが、どの計算でも<code>lift</code>は必要がなく、同じdo記法ブロック内で
<code>MonadState</code>、 <code>MonadReader</code>、 <code>MonadWriter</code>型クラスで定義されているア
クションを使うことができることに注意してください。</p>
<p><code>debugMode</code>フラグが設定されている場合、 <code>tell</code>アクションを使ってログに
状態が追加されます。そうでなければ、エラーメッセージが追加されます。</p>
<p><code>Game.purs</code>モジュールの残りの部分では、 <code>MonadState</code>型クラス、
<code>MonadReader</code>型クラス、 <code>MonadWriter</code>型クラスでそれぞれ定義されたアク
ションだけを使って、同様のアクションが定義されています。</p>
<h2 id="計算の実行"><a class="header" href="#計算の実行">計算の実行</a></h2>
<p>このゲームロジックは <code>RWS</code>モナドで動くため、ユーザのコマンドに応答する
ためには計算を実行する必要があります。</p>
<p>このゲームのフロントエンドは2つのパッケージで構成されています。アプリ
カティブなコマンドライン構文解析を提供する<code>optparse</code>と、対話的なコンソー
ルベースのアプリケーションを書くことを可能にするNodeJSの <code>readline</code>モ
ジュールをラップする <code>node-readline</code>パッケージです。</p>
<p>このゲームロジックへのインタフェースは <code>Game</code>モジュール内の関数
<code>game</code>によって提供されます。</p>
<pre><code class="language-haskell">game :: Array String -&gt; Game Unit
</code></pre>
<p>この計算を実行するには、ユーザが入力した単語のリストを文字列の配列とし
て渡してから、 <code>runRWS</code>を使って <code>RWS</code>の計算結果を実行します。</p>
<pre><code class="language-haskell">data RWSResult state result writer = RWSResult state result writer

runRWS :: forall r w s a. RWS r w s a -&gt; r -&gt; s -&gt; RWSResult s a w
</code></pre>
<p><code>runRWS</code>は <code>runReader</code>、 <code>runWriter</code>、 <code>runState</code>を組み合わせたように
見えます。これは、引数として大域的な設定および初期状態をとり、ログ、結
果、最的な終状態を含むデータ構造を返します。</p>
<p>このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数
<code>runGame</code>によって定義されます。</p>
<pre><code class="language-haskell">runGame :: GameEnvironment -&gt; Effect Unit
</code></pre>
<p>この関数は（<code>node-readline</code>と<code>console</code>パッケージを使って）コンソールを
介してユーザとやり取りします。<code>runGame</code>は関数の引数としてのゲームの設
定を取ります。</p>
<p><code>node-readline</code>パッケージでは<code>LineHandler</code>型が提供されています。これは
端末からのユーザ入力を扱う <code>Effect</code>モナドのアクションを表します。対応
するAPIは次の通りです。</p>
<pre><code class="language-haskell">type LineHandler a = String -&gt; Effect a

foreign import setLineHandler
  :: forall a
   . Interface
  -&gt; LineHandler a
  -&gt; Effect Unit
</code></pre>
<p><code>Interface</code>型はコンソールのハンドルを表しており、コンソールとやり取り
する関数への引数として渡されます。 <code>createConsoleInterface</code>関数を使用
すると <code>Interface</code>を作成することができます。</p>
<pre><code class="language-haskell">import Node.ReadLine as RL

runGame env = do
  interface &lt;- RL.createConsoleInterface RL.noCompletion
</code></pre>
<p>最初の手順はコンソールにプロンプトを設定することです。 <code>interface</code>ハン
ドルを渡し、プロンプト文字列と字下げレベルを与えます。</p>
<pre><code class="language-haskell">  RL.setPrompt &quot;&gt; &quot; interface
</code></pre>
<p>今回は行制御関数を実装することに関心があります。ここでの行制御は
<code>let</code>宣言内の補助関数を使って次のように定義されています。</p>
<pre><code class="language-haskell">    lineHandler :: GameState -&gt; String -&gt; Effect Unit
    lineHandler currentState input = do
      case runRWS (game (split (wrap &quot; &quot;) input)) env currentState of
        RWSResult state _ written -&gt; do
          for_ written log
          RL.setLineHandler (lineHandler state) $ interface
      RL.prompt interface
      pure unit
</code></pre>
<p><code>let</code>束縛が<code>env</code>という名前のゲーム構成や<code>interface</code>という名前のコンソー
ルハンドルを包み込んでいます。</p>
<p>このハンドラは追加の最初の引数としてゲームの状態を取ります。ゲームのロ
ジックを実行するために <code>runRWS</code>にゲームの状態を渡さなければならないの
で、これは必要となっています。</p>
<p>このアクションが最初に行うことは、 <code>Data.String</code>モジュールの <code>split</code>関
数を使用して、ユーザーの入力を単語に分割することです。それから、ゲーム
環境と現在のゲームの状態を渡し、 <code>runRWS</code>を使用して（<code>RWS</code>モナドで）
<code>game</code>アクションを実行しています。</p>
<p>純粋な計算であるゲームロジックを実行するには、画面にすべてのログメッセー
ジを出力して、ユーザに次のコマンドのためのプロンプトを表示する必要があ
ります。 <code>for_</code>アクションが（<code>List String</code>型の）ログを走査し、コンソー
ルにその内容を出力するために使われています。最後に<code>setLineHandler</code>を使っ
て行制御関数を更新することでゲームの状態を更新し、<code>prompt</code>アクションを
使ってプロンプトを再び表示しています。</p>
<p><code>runGame</code>関数は最終的にコンソールインターフェイスに最初の行制御子を取
り付けて、最初のプロンプトを表示します。</p>
<pre><code class="language-haskell">  RL.setLineHandler (lineHandler initialGameState) interface
  RL.prompt interface
</code></pre>
<h2 id="演習-5"><a class="header" href="#演習-5">演習</a></h2>
<ol>
<li>
<p>（普通）ゲームの格子上にある全てのゲームアイテムをユーザの持ちものに移
動する新しいコマンド <code>cheat</code>を実装してください。関数<code>cheat :: Game Unit</code>を<code>Game</code>モジュールに作り、この関数を<code>game</code>から使ってください。</p>
</li>
<li>
<p>（難しい）<code>RWS</code>モナドの <code> Writer</code>コンポーネントは、エラーメッセージと
情報メッセージの2つの種類のメッセージのために使われています。このため、
コードのいくつかの箇所では、エラーの場合を扱うためにcase式を使用してい
ます。</p>
<p>エラーメッセージを扱うのに <code>ExceptT</code>モナド変換子を使うようにし、
情報メッセージを扱うのに <code>RWS</code>を使うようにするよう、コードをリファ
クタリングしてください。<strong>補足</strong>：この演習にはテストはありません。</p>
</li>
</ol>
<h2 id="コマンドラインオプションの扱い"><a class="header" href="#コマンドラインオプションの扱い">コマンドラインオプションの扱い</a></h2>
<p>このアプリケーションの最後の部品は、コマンドラインオプションの解析と
<code>GameEnvironment</code>設定レコードを作成する役目にあります。このためには
<code>optparse</code>パッケージを使用します。</p>
<p><code>optparse</code>は<strong>アプリカティブなコマンドラインオプション構文解析器</strong>の一
例です。アプリカティブ関手を使うと、いろいろな副作用の型を表す型構築子
まで任意個数の引数の関数をを持ち上げられることを思い出してください。
<code>optparse</code>パッケージの場合には、コマンドラインオプションからの読み取り
の副作用を追加する<code>Parser</code>関手（optparseのモジュール
<code>Options.Applicative</code>からインポートされたもの。<code>Split</code>モジュールで定義
した<code>Parser</code>と混同しないように）が興味深い関手になっています。これは次
のようなハンドラを提供しています。</p>
<pre><code class="language-haskell">customExecParser :: forall a. ParserPrefs → ParserInfo a → Effect a
</code></pre>
<p>実例を見るのが一番です。このアプリケーションの <code>main</code>関数は
<code>customExecParser</code>を使って次のように定義されています。</p>
<pre><code class="language-haskell">main = OP.customExecParser prefs argParser &gt;&gt;= runGame 
</code></pre>
<p>最初の引数は<code>optparse</code>ライブラリを設定するために使用されます。今回の場
合、アプリケーションが引数なしで走らされたときは、（「missing argument」
エラーを表示する代わりに）<code>OP.prefs OP.showHelpOnEmpty</code>を使って使用方
法のメッセージを表示するように設定していますが、
<code>Options.Applicative.Builder</code>モジュールには他にもいくつかのオプション
を提供しています。</p>
<p>2つ目の引数は解析プログラムの完全な説明です。</p>
<pre><code class="language-haskell">  argParser :: OP.ParserInfo GameEnvironment
  argParser = OP.info (env &lt;**&gt; OP.helper) parserOptions

  parserOptions = fold 
    [ OP.fullDesc
    , OP.progDesc &quot;Play the game as &lt;player name&gt;&quot;
    , OP.header &quot;Monadic Adventures! A game to learn monad transformers&quot; 
    ]
</code></pre>
<p>ここで<code>OP.info</code>は使用方法のメッセージが書式化されたようにオプションの
集合と共に<code>Parser</code>を結合します。<code>env &lt;**&gt; OP.helper</code>は<code>env</code>と名付けら
れた任意のコマンドライン引数<code>Parser</code>を取り、自動的に<code>--help</code>オプション
を加えます。使用方法のメッセージ用のオプションは型が<code>InfoMod</code>であり、
これはモノイドなので<code>fold</code>関数を使って複数のオプションを一緒に追加でき
ます。</p>
<p>解析器の面白い部分は<code>GameEnvironment</code>の構築にあります。</p>
<pre><code class="language-haskell">  env :: OP.Parser GameEnvironment
  env = gameEnvironment &lt;$&gt; player &lt;*&gt; debug

  player :: OP.Parser String
  player = OP.strOption $ fold 
    [ OP.long &quot;player&quot;
    , OP.short 'p'
    , OP.metavar &quot;&lt;player name&gt;&quot;
    , OP.help &quot;The player's name &lt;String&gt;&quot;
    ]

  debug :: OP.Parser Boolean
  debug = OP.switch $ fold 
    [ OP.long &quot;debug&quot;
    , OP.short 'd'
    , OP.help &quot;Use debug mode&quot;
    ]
</code></pre>
<p><code>player</code>と<code>debug</code>は両方とも<code>Parser</code>なので、アプリカティブ演算子<code>&lt;$&gt;</code>と
<code>&lt;*&gt;</code>を使って<code>gameEnvironment</code>関数を持ち上げることができます。この関数
は<code>Parser</code>上で型<code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code>を持ちます。
<code>OP.strOption</code>は文字列値を期待するコマンドラインオプションを構築し、一
緒に畳み込まれた<code>Mod</code>の集まりを介して設定されています。<code>OP.flag</code>は似た
ような動作をしますが、関連付けられた値は期待しません。<code>optparse</code>は多種
多様なコマンドライン解析器を構築するために使える様々な修飾子について、
大部の<a href="https://pursuit.purescript.org/packages/purescript-optparse">ドキュメン
ト</a>を提供
しています。</p>
<p>アプリカティブ演算子による記法を使うことで、コマンドラインインターフェ
イスに対してコンパクトで宣言的な仕様を与えることが可能になったことに注
目です。また、<code>runGame</code>に新しい関数引数を追加し、<code>env</code>の定義中で
<code>&lt;*&gt;</code>を使って追加の引数まで <code>runGame</code>を持ち上げるだけで、簡単に新しい
コマンドライン引数を追加することができます。</p>
<h2 id="演習-6"><a class="header" href="#演習-6">演習</a></h2>
<ol>
<li>（普通）<code>GameEnvironment</code>レコードに新しい真偽値のプロパティ
<code>cheatMode</code>を追加してください。 また、 <code>optparse</code>設定に、チートモード
を有効にする新しいコマンドラインフラグ <code>-c</code>を追加してください。チート
モードが有効になっていない場合、 <code>cheat</code>コマンドは禁止されなければなり
ません。</li>
</ol>
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<p>この章ではこれまで学んできた技術の実践的な実演を行いました。モナド変換
子を使用したゲームの純粋な仕様の構築、コンソールを使用したフロントエン
ドを構築するための <code>Effect</code>モナドがそれです。</p>
<p>ユーザインターフェイスからの実装を分離したので、ゲームの別のフロントエ
ンドを作成することも可能でしょう。例えば、 <code>Effect</code>モナドでCanvas API
やDOMを使用して、ブラウザでゲームを描画するようなことができるでしょう。</p>
<p>モナド変換子によって命令型のスタイルで安全なコードを書くことができるこ
とを見てきました。このスタイルでは型システムによって作用が追跡されてい
ます。また、型クラスはモナドが提供するアクションへと抽象化する強力な方
法を提供します。このモナドのお陰でコードの再利用が可能になりました。標
準的なモナド変換子を組み合わせることにより、 <code>Alternative</code>や
<code>MonadPlus</code>のような標準的な抽象化を使用して、役に立つモナドを構築する
ことができました。</p>
<p>モナド変換子は、高階多相や多変数型クラスなどの高度な型システムの機能を
利用することによって記述することができ、表現力の高いコードの優れた実演
となっています。</p>
<hr />
<small>
<p>この翻訳は<a href="https://github.com/aratama">aratama</a>氏による翻訳を元に改変を加えています。
同氏の翻訳リポジトリは<a href="https://github.com/aratama/purescript-book-ja"><code>aratama/purescript-book-ja</code></a>に、Webサイトは<a href="http://aratama.github.io/purescript/">実例によるPureScript</a>にあります。</p>
<p><a href="https://book.purescript.org/">原文の使用許諾</a>：</p>
<blockquote>
<p>Copyright (c) 2014-2017 Phil Freeman.</p>
<p>The text of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License: <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US</a>.</p>
<p>Some text is derived from the <a href="https://github.com/purescript/documentation">PureScript Documentation Repo</a>, which uses the same license, and is copyright <a href="https://github.com/purescript/documentation/blob/master/CONTRIBUTORS.md">various contributors</a>.</p>
<p>The exercises are licensed under the MIT license.</p>
</blockquote>
<p><a href="http://aratama.github.io/purescript/">aratama氏訳の使用許諾</a>：</p>
<blockquote>
<p>This book is licensed under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</p>
<p>本書は<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.ja">クリエイティブコモンズ 表示 - 非営利 - 継承 3.0 非移植ライセンス</a>でライセンスされています。</p>
</blockquote>
<p>本翻訳の使用許諾：</p>
<p>本翻訳も原文と原翻訳にしたがい、
<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>の下に提供されています。</p>
</small>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter10.ja.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter12.ja.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter10.ja.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter12.ja.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
